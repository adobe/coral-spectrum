var Coral = (function (exports) {
  'use strict';

  // Any copyright is dedicated to the Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
  // Source https://developer.mozilla.org/fr/docs/Web/API/Element/closest
  (function () {
    if (!Element.prototype.matches) Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
    if (!Element.prototype.closest) Element.prototype.closest = function (s) {
      var el = this;
      if (!document.documentElement.contains(el)) return null;

      do {
        if (el.matches(s)) return el;
        el = el.parentElement || el.parentNode;
      } while (el !== null && el.nodeType == 1);

      return null;
    };
  })();

  // Any copyright is dedicated to the Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
  // Source https://developer.mozilla.org/en/docs/Web/API/Element/matches
  (function () {
    if (!Element.prototype.matches) {
      Element.prototype.matches = Element.prototype.msMatchesSelector;
    }
  })();

  // Any copyright is dedicated to the Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
  // Source https://developer.mozilla.org/en-US/docs/Web/API/ChildNode/remove
  (function (arr) {
    arr.forEach(function (item) {
      if (item.hasOwnProperty('remove')) {
        return;
      }

      Object.defineProperty(item, 'remove', {
        configurable: true,
        enumerable: true,
        writable: true,
        value: function remove() {
          this.parentNode && this.parentNode.removeChild(this);
        }
      });
    });
  })([Element.prototype, CharacterData.prototype, DocumentType.prototype]);

  /**
   * classList.js: Cross-browser full element.classList implementation.
   * 1.1.20150312
   *
   * By Eli Grey, http://eligrey.com
   * License: Dedicated to the public domain.
   * See https://github.com/eligrey/classList.js/blob/master/LICENSE.md
   */
  // Source http://purl.eligrey.com/github/classList.js/blob/master/classList.js
  (function () {
    var testElement = document.createElement("_");
    testElement.classList.add("c1", "c2"); // Polyfill for IE 10/11 and Firefox <26, where classList.add and
    // classList.remove exist but support only one argument at a time.

    if (!testElement.classList.contains("c2")) {
      var createMethod = function createMethod(method) {
        var original = DOMTokenList.prototype[method];

        DOMTokenList.prototype[method] = function (token) {
          var i,
              len = arguments.length;

          for (i = 0; i < len; i++) {
            token = arguments[i];
            original.call(this, token);
          }
        };
      };

      createMethod('add');
      createMethod('remove');
    }

    testElement.classList.toggle("c3", false); // Polyfill for IE 10 and Firefox <24, where classList.toggle does not
    // support the second argument.

    if (testElement.classList.contains("c3")) {
      var _toggle = DOMTokenList.prototype.toggle;

      DOMTokenList.prototype.toggle = function (token, force) {
        if (1 in arguments && !this.contains(token) === !force) {
          return force;
        } else {
          return _toggle.call(this, token);
        }
      };
    } // Polyfill for IE11 SVG classList support


    if (!("classList" in document.createElementNS("http://www.w3.org/2000/svg", "g"))) {
      var descr = Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'classList');
      Object.defineProperty(SVGElement.prototype, 'classList', descr);
    }

    testElement = null;
  })();

  // Any copyright is dedicated to the Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
  // Source https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent#Polyfill
  (function () {
    if (typeof window.CustomEvent === "function") return false;

    function CustomEvent(event, params) {
      params = params || {
        bubbles: false,
        cancelable: false,
        detail: undefined
      };
      var evt = document.createEvent('CustomEvent');
      evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
      return evt;
    }

    CustomEvent.prototype = window.Event.prototype;
    window.CustomEvent = CustomEvent;
  })();

  /**
   MIT License
   Copyright (c) 2018 Juan Valencia

   Permission is hereby granted, free of charge, to any person obtaining a copy
   of this software and associated documentation files (the "Software"), to deal
   in the Software without restriction, including without limitation the rights
   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   copies of the Software, and to permit persons to whom the Software is
   furnished to do so, subject to the following conditions:

   The above copyright notice and this permission notice shall be included in all
   copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   SOFTWARE.
   */
  // focus - focusOptions - preventScroll polyfill
  var supportsPreventScrollOption = false;

  try {
    var focusElem = document.createElement('div');
    focusElem.addEventListener('focus', function (event) {
      event.preventDefault();
      event.stopPropagation();
    }, true);
    focusElem.focus(Object.defineProperty({}, 'preventScroll', {
      get: function get() {
        supportsPreventScrollOption = true;
      }
    }));
  } catch (e) {}

  if (HTMLElement.prototype.nativeFocus === undefined && !supportsPreventScrollOption) {
    HTMLElement.prototype.nativeFocus = HTMLElement.prototype.focus;

    var getScrollParent = function getScrollParent(node) {
      var isElement = node instanceof HTMLElement;
      var overflowY = isElement && window.getComputedStyle(node).overflowY;
      var isScrollable = overflowY !== 'visible' && overflowY !== 'hidden';

      if (!node) {
        return null;
      } else if (isScrollable && node.scrollHeight >= node.clientHeight) {
        return node;
      }

      return getScrollParent(node.parentNode) || document.body;
    };

    var patchedFocus = function patchedFocus(args) {
      var scrollElement = getScrollParent(this);
      var actualPosition = scrollElement.scrollTop;
      this.nativeFocus();

      if (args && args.preventScroll) {
        // Hijacking the event loop order, since the focus() will trigger
        // internally an scroll that goes to the event loop
        setTimeout(function () {
          scrollElement.scrollTop = actualPosition;
        }, 0);
      }
    };

    HTMLElement.prototype.focus = patchedFocus;
  }

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn(this, result);
    };
  }

  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object);
      if (object === null) break;
    }

    return object;
  }

  function _get(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get;
    } else {
      _get = function _get(target, property, receiver) {
        var base = _superPropBase(target, property);

        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(receiver);
        }

        return desc.value;
      };
    }

    return _get(target, property, receiver || target);
  }

  function set(target, property, value, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.set) {
      set = Reflect.set;
    } else {
      set = function set(target, property, value, receiver) {
        var base = _superPropBase(target, property);

        var desc;

        if (base) {
          desc = Object.getOwnPropertyDescriptor(base, property);

          if (desc.set) {
            desc.set.call(receiver, value);
            return true;
          } else if (!desc.writable) {
            return false;
          }
        }

        desc = Object.getOwnPropertyDescriptor(receiver, property);

        if (desc) {
          if (!desc.writable) {
            return false;
          }

          desc.value = value;
          Object.defineProperty(receiver, property, desc);
        } else {
          _defineProperty(receiver, property, value);
        }

        return true;
      };
    }

    return set(target, property, value, receiver);
  }

  function _set(target, property, value, receiver, isStrict) {
    var s = set(target, property, value, receiver || target);

    if (!s && isStrict) {
      throw new Error('failed to set property');
    }

    return value;
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var check = function check(it) {
    return it && it.Math == Math && it;
  }; // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028


  var global_1 = // eslint-disable-next-line no-undef
  check((typeof globalThis === "undefined" ? "undefined" : _typeof(globalThis)) == 'object' && globalThis) || check((typeof window === "undefined" ? "undefined" : _typeof(window)) == 'object' && window) || check((typeof self === "undefined" ? "undefined" : _typeof(self)) == 'object' && self) || check(_typeof(commonjsGlobal) == 'object' && commonjsGlobal) || // eslint-disable-next-line no-new-func
  Function('return this')();

  var fails = function fails(exec) {
    try {
      return !!exec();
    } catch (error) {
      return true;
    }
  };

  var descriptors = !fails(function () {
    return Object.defineProperty({}, 1, {
      get: function get() {
        return 7;
      }
    })[1] != 7;
  });

  var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
  var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor; // Nashorn ~ JDK8 bug

  var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({
    1: 2
  }, 1); // `Object.prototype.propertyIsEnumerable` method implementation
  // https://tc39.github.io/ecma262/#sec-object.prototype.propertyisenumerable

  var f = NASHORN_BUG ? function propertyIsEnumerable(V) {
    var descriptor = getOwnPropertyDescriptor(this, V);
    return !!descriptor && descriptor.enumerable;
  } : nativePropertyIsEnumerable;
  var objectPropertyIsEnumerable = {
    f: f
  };

  var createPropertyDescriptor = function createPropertyDescriptor(bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value: value
    };
  };

  var toString = {}.toString;

  var classofRaw = function classofRaw(it) {
    return toString.call(it).slice(8, -1);
  };

  var split = ''.split; // fallback for non-array-like ES3 and non-enumerable old V8 strings

  var indexedObject = fails(function () {
    // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
    // eslint-disable-next-line no-prototype-builtins
    return !Object('z').propertyIsEnumerable(0);
  }) ? function (it) {
    return classofRaw(it) == 'String' ? split.call(it, '') : Object(it);
  } : Object;

  // `RequireObjectCoercible` abstract operation
  // https://tc39.github.io/ecma262/#sec-requireobjectcoercible
  var requireObjectCoercible = function requireObjectCoercible(it) {
    if (it == undefined) throw TypeError("Can't call method on " + it);
    return it;
  };

  var toIndexedObject = function toIndexedObject(it) {
    return indexedObject(requireObjectCoercible(it));
  };

  var isObject = function isObject(it) {
    return _typeof(it) === 'object' ? it !== null : typeof it === 'function';
  };

  // https://tc39.github.io/ecma262/#sec-toprimitive
  // instead of the ES6 spec version, we didn't implement @@toPrimitive case
  // and the second argument - flag - preferred type is a string

  var toPrimitive = function toPrimitive(input, PREFERRED_STRING) {
    if (!isObject(input)) return input;
    var fn, val;
    if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
    if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;
    if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
    throw TypeError("Can't convert object to primitive value");
  };

  var hasOwnProperty = {}.hasOwnProperty;

  var has = function has(it, key) {
    return hasOwnProperty.call(it, key);
  };

  var document$1 = global_1.document; // typeof document.createElement is 'object' in old IE

  var EXISTS = isObject(document$1) && isObject(document$1.createElement);

  var documentCreateElement = function documentCreateElement(it) {
    return EXISTS ? document$1.createElement(it) : {};
  };

  var ie8DomDefine = !descriptors && !fails(function () {
    return Object.defineProperty(documentCreateElement('div'), 'a', {
      get: function get() {
        return 7;
      }
    }).a != 7;
  });

  var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor; // `Object.getOwnPropertyDescriptor` method
  // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor

  var f$1 = descriptors ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
    O = toIndexedObject(O);
    P = toPrimitive(P, true);
    if (ie8DomDefine) try {
      return nativeGetOwnPropertyDescriptor(O, P);
    } catch (error) {
      /* empty */
    }
    if (has(O, P)) return createPropertyDescriptor(!objectPropertyIsEnumerable.f.call(O, P), O[P]);
  };
  var objectGetOwnPropertyDescriptor = {
    f: f$1
  };

  var anObject = function anObject(it) {
    if (!isObject(it)) {
      throw TypeError(String(it) + ' is not an object');
    }

    return it;
  };

  var nativeDefineProperty = Object.defineProperty; // `Object.defineProperty` method
  // https://tc39.github.io/ecma262/#sec-object.defineproperty

  var f$2 = descriptors ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
    anObject(O);
    P = toPrimitive(P, true);
    anObject(Attributes);
    if (ie8DomDefine) try {
      return nativeDefineProperty(O, P, Attributes);
    } catch (error) {
      /* empty */
    }
    if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
    if ('value' in Attributes) O[P] = Attributes.value;
    return O;
  };
  var objectDefineProperty = {
    f: f$2
  };

  var createNonEnumerableProperty = descriptors ? function (object, key, value) {
    return objectDefineProperty.f(object, key, createPropertyDescriptor(1, value));
  } : function (object, key, value) {
    object[key] = value;
    return object;
  };

  var setGlobal = function setGlobal(key, value) {
    try {
      createNonEnumerableProperty(global_1, key, value);
    } catch (error) {
      global_1[key] = value;
    }

    return value;
  };

  var SHARED = '__core-js_shared__';
  var store = global_1[SHARED] || setGlobal(SHARED, {});
  var sharedStore = store;

  var functionToString = Function.toString; // this helper broken in `3.4.1-3.4.4`, so we can't use `shared` helper

  if (typeof sharedStore.inspectSource != 'function') {
    sharedStore.inspectSource = function (it) {
      return functionToString.call(it);
    };
  }

  var inspectSource = sharedStore.inspectSource;

  var WeakMap$1 = global_1.WeakMap;
  var nativeWeakMap = typeof WeakMap$1 === 'function' && /native code/.test(inspectSource(WeakMap$1));

  var shared = createCommonjsModule(function (module) {
    (module.exports = function (key, value) {
      return sharedStore[key] || (sharedStore[key] = value !== undefined ? value : {});
    })('versions', []).push({
      version: '3.6.4',
      mode:  'global',
      copyright: 'Â© 2020 Denis Pushkarev (zloirock.ru)'
    });
  });

  var id = 0;
  var postfix = Math.random();

  var uid = function uid(key) {
    return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
  };

  var keys = shared('keys');

  var sharedKey = function sharedKey(key) {
    return keys[key] || (keys[key] = uid(key));
  };

  var hiddenKeys = {};

  var WeakMap$2 = global_1.WeakMap;
  var set$1, get, has$1;

  var enforce = function enforce(it) {
    return has$1(it) ? get(it) : set$1(it, {});
  };

  var getterFor = function getterFor(TYPE) {
    return function (it) {
      var state;

      if (!isObject(it) || (state = get(it)).type !== TYPE) {
        throw TypeError('Incompatible receiver, ' + TYPE + ' required');
      }

      return state;
    };
  };

  if (nativeWeakMap) {
    var store$1 = new WeakMap$2();
    var wmget = store$1.get;
    var wmhas = store$1.has;
    var wmset = store$1.set;

    set$1 = function set(it, metadata) {
      wmset.call(store$1, it, metadata);
      return metadata;
    };

    get = function get(it) {
      return wmget.call(store$1, it) || {};
    };

    has$1 = function has(it) {
      return wmhas.call(store$1, it);
    };
  } else {
    var STATE = sharedKey('state');
    hiddenKeys[STATE] = true;

    set$1 = function set(it, metadata) {
      createNonEnumerableProperty(it, STATE, metadata);
      return metadata;
    };

    get = function get(it) {
      return has(it, STATE) ? it[STATE] : {};
    };

    has$1 = function has$1(it) {
      return has(it, STATE);
    };
  }

  var internalState = {
    set: set$1,
    get: get,
    has: has$1,
    enforce: enforce,
    getterFor: getterFor
  };

  var redefine = createCommonjsModule(function (module) {
    var getInternalState = internalState.get;
    var enforceInternalState = internalState.enforce;
    var TEMPLATE = String(String).split('String');
    (module.exports = function (O, key, value, options) {
      var unsafe = options ? !!options.unsafe : false;
      var simple = options ? !!options.enumerable : false;
      var noTargetGet = options ? !!options.noTargetGet : false;

      if (typeof value == 'function') {
        if (typeof key == 'string' && !has(value, 'name')) createNonEnumerableProperty(value, 'name', key);
        enforceInternalState(value).source = TEMPLATE.join(typeof key == 'string' ? key : '');
      }

      if (O === global_1) {
        if (simple) O[key] = value;else setGlobal(key, value);
        return;
      } else if (!unsafe) {
        delete O[key];
      } else if (!noTargetGet && O[key]) {
        simple = true;
      }

      if (simple) O[key] = value;else createNonEnumerableProperty(O, key, value); // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
    })(Function.prototype, 'toString', function toString() {
      return typeof this == 'function' && getInternalState(this).source || inspectSource(this);
    });
  });

  var path = global_1;

  var aFunction = function aFunction(variable) {
    return typeof variable == 'function' ? variable : undefined;
  };

  var getBuiltIn = function getBuiltIn(namespace, method) {
    return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global_1[namespace]) : path[namespace] && path[namespace][method] || global_1[namespace] && global_1[namespace][method];
  };

  var ceil = Math.ceil;
  var floor = Math.floor; // `ToInteger` abstract operation
  // https://tc39.github.io/ecma262/#sec-tointeger

  var toInteger = function toInteger(argument) {
    return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
  };

  var min = Math.min; // `ToLength` abstract operation
  // https://tc39.github.io/ecma262/#sec-tolength

  var toLength = function toLength(argument) {
    return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
  };

  var max = Math.max;
  var min$1 = Math.min; // Helper for a popular repeating case of the spec:
  // Let integer be ? ToInteger(index).
  // If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).

  var toAbsoluteIndex = function toAbsoluteIndex(index, length) {
    var integer = toInteger(index);
    return integer < 0 ? max(integer + length, 0) : min$1(integer, length);
  };

  var createMethod = function createMethod(IS_INCLUDES) {
    return function ($this, el, fromIndex) {
      var O = toIndexedObject($this);
      var length = toLength(O.length);
      var index = toAbsoluteIndex(fromIndex, length);
      var value; // Array#includes uses SameValueZero equality algorithm
      // eslint-disable-next-line no-self-compare

      if (IS_INCLUDES && el != el) while (length > index) {
        value = O[index++]; // eslint-disable-next-line no-self-compare

        if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not
      } else for (; length > index; index++) {
        if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
      }
      return !IS_INCLUDES && -1;
    };
  };

  var arrayIncludes = {
    // `Array.prototype.includes` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.includes
    includes: createMethod(true),
    // `Array.prototype.indexOf` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.indexof
    indexOf: createMethod(false)
  };

  var indexOf = arrayIncludes.indexOf;

  var objectKeysInternal = function objectKeysInternal(object, names) {
    var O = toIndexedObject(object);
    var i = 0;
    var result = [];
    var key;

    for (key in O) {
      !has(hiddenKeys, key) && has(O, key) && result.push(key);
    } // Don't enum bug & hidden keys


    while (names.length > i) {
      if (has(O, key = names[i++])) {
        ~indexOf(result, key) || result.push(key);
      }
    }

    return result;
  };

  // IE8- don't enum bug keys
  var enumBugKeys = ['constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf'];

  var hiddenKeys$1 = enumBugKeys.concat('length', 'prototype'); // `Object.getOwnPropertyNames` method
  // https://tc39.github.io/ecma262/#sec-object.getownpropertynames

  var f$3 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
    return objectKeysInternal(O, hiddenKeys$1);
  };

  var objectGetOwnPropertyNames = {
    f: f$3
  };

  var f$4 = Object.getOwnPropertySymbols;
  var objectGetOwnPropertySymbols = {
    f: f$4
  };

  var ownKeys = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
    var keys = objectGetOwnPropertyNames.f(anObject(it));
    var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;
    return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
  };

  var copyConstructorProperties = function copyConstructorProperties(target, source) {
    var keys = ownKeys(source);
    var defineProperty = objectDefineProperty.f;
    var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
    }
  };

  var replacement = /#|\.prototype\./;

  var isForced = function isForced(feature, detection) {
    var value = data[normalize(feature)];
    return value == POLYFILL ? true : value == NATIVE ? false : typeof detection == 'function' ? fails(detection) : !!detection;
  };

  var normalize = isForced.normalize = function (string) {
    return String(string).replace(replacement, '.').toLowerCase();
  };

  var data = isForced.data = {};
  var NATIVE = isForced.NATIVE = 'N';
  var POLYFILL = isForced.POLYFILL = 'P';
  var isForced_1 = isForced;

  var getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;
  /*
    options.target      - name of the target object
    options.global      - target is the global object
    options.stat        - export as static methods of target
    options.proto       - export as prototype methods of target
    options.real        - real prototype method for the `pure` version
    options.forced      - export even if the native feature is available
    options.bind        - bind methods to the target, required for the `pure` version
    options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
    options.unsafe      - use the simple assignment of property instead of delete + defineProperty
    options.sham        - add a flag to not completely full polyfills
    options.enumerable  - export as enumerable property
    options.noTargetGet - prevent calling a getter on target
  */

  var _export = function _export(options, source) {
    var TARGET = options.target;
    var GLOBAL = options.global;
    var STATIC = options.stat;
    var FORCED, target, key, targetProperty, sourceProperty, descriptor;

    if (GLOBAL) {
      target = global_1;
    } else if (STATIC) {
      target = global_1[TARGET] || setGlobal(TARGET, {});
    } else {
      target = (global_1[TARGET] || {}).prototype;
    }

    if (target) for (key in source) {
      sourceProperty = source[key];

      if (options.noTargetGet) {
        descriptor = getOwnPropertyDescriptor$1(target, key);
        targetProperty = descriptor && descriptor.value;
      } else targetProperty = target[key];

      FORCED = isForced_1(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced); // contained in target

      if (!FORCED && targetProperty !== undefined) {
        if (_typeof(sourceProperty) === _typeof(targetProperty)) continue;
        copyConstructorProperties(sourceProperty, targetProperty);
      } // add a flag to not completely full polyfills


      if (options.sham || targetProperty && targetProperty.sham) {
        createNonEnumerableProperty(sourceProperty, 'sham', true);
      } // extend global


      redefine(target, key, sourceProperty, options);
    }
  };

  var aFunction$1 = function aFunction(it) {
    if (typeof it != 'function') {
      throw TypeError(String(it) + ' is not a function');
    }

    return it;
  };

  var nativeApply = getBuiltIn('Reflect', 'apply');
  var functionApply = Function.apply; // MS Edge argumentsList argument is optional

  var OPTIONAL_ARGUMENTS_LIST = !fails(function () {
    nativeApply(function () {
      /* empty */
    });
  }); // `Reflect.apply` method
  // https://tc39.github.io/ecma262/#sec-reflect.apply

  _export({
    target: 'Reflect',
    stat: true,
    forced: OPTIONAL_ARGUMENTS_LIST
  }, {
    apply: function apply(target, thisArgument, argumentsList) {
      aFunction$1(target);
      anObject(argumentsList);
      return nativeApply ? nativeApply(target, thisArgument, argumentsList) : functionApply.call(target, thisArgument, argumentsList);
    }
  });

  // https://tc39.github.io/ecma262/#sec-object.keys

  var objectKeys = Object.keys || function keys(O) {
    return objectKeysInternal(O, enumBugKeys);
  };

  // https://tc39.github.io/ecma262/#sec-object.defineproperties

  var objectDefineProperties = descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
    anObject(O);
    var keys = objectKeys(Properties);
    var length = keys.length;
    var index = 0;
    var key;

    while (length > index) {
      objectDefineProperty.f(O, key = keys[index++], Properties[key]);
    }

    return O;
  };

  var html = getBuiltIn('document', 'documentElement');

  var GT = '>';
  var LT = '<';
  var PROTOTYPE = 'prototype';
  var SCRIPT = 'script';
  var IE_PROTO = sharedKey('IE_PROTO');

  var EmptyConstructor = function EmptyConstructor() {
    /* empty */
  };

  var scriptTag = function scriptTag(content) {
    return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
  }; // Create object with fake `null` prototype: use ActiveX Object with cleared prototype


  var NullProtoObjectViaActiveX = function NullProtoObjectViaActiveX(activeXDocument) {
    activeXDocument.write(scriptTag(''));
    activeXDocument.close();
    var temp = activeXDocument.parentWindow.Object;
    activeXDocument = null; // avoid memory leak

    return temp;
  }; // Create object with fake `null` prototype: use iframe Object with cleared prototype


  var NullProtoObjectViaIFrame = function NullProtoObjectViaIFrame() {
    // Thrash, waste and sodomy: IE GC bug
    var iframe = documentCreateElement('iframe');
    var JS = 'java' + SCRIPT + ':';
    var iframeDocument;
    iframe.style.display = 'none';
    html.appendChild(iframe); // https://github.com/zloirock/core-js/issues/475

    iframe.src = String(JS);
    iframeDocument = iframe.contentWindow.document;
    iframeDocument.open();
    iframeDocument.write(scriptTag('document.F=Object'));
    iframeDocument.close();
    return iframeDocument.F;
  }; // Check for document.domain and active x support
  // No need to use active x approach when document.domain is not set
  // see https://github.com/es-shims/es5-shim/issues/150
  // variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
  // avoid IE GC bug


  var activeXDocument;

  var _NullProtoObject = function NullProtoObject() {
    try {
      /* global ActiveXObject */
      activeXDocument = document.domain && new ActiveXObject('htmlfile');
    } catch (error) {
      /* ignore */
    }

    _NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
    var length = enumBugKeys.length;

    while (length--) {
      delete _NullProtoObject[PROTOTYPE][enumBugKeys[length]];
    }

    return _NullProtoObject();
  };

  hiddenKeys[IE_PROTO] = true; // `Object.create` method
  // https://tc39.github.io/ecma262/#sec-object.create

  var objectCreate = Object.create || function create(O, Properties) {
    var result;

    if (O !== null) {
      EmptyConstructor[PROTOTYPE] = anObject(O);
      result = new EmptyConstructor();
      EmptyConstructor[PROTOTYPE] = null; // add "__proto__" for Object.getPrototypeOf polyfill

      result[IE_PROTO] = O;
    } else result = _NullProtoObject();

    return Properties === undefined ? result : objectDefineProperties(result, Properties);
  };

  var slice = [].slice;
  var factories = {};

  var construct = function construct(C, argsLength, args) {
    if (!(argsLength in factories)) {
      for (var list = [], i = 0; i < argsLength; i++) {
        list[i] = 'a[' + i + ']';
      } // eslint-disable-next-line no-new-func


      factories[argsLength] = Function('C,a', 'return new C(' + list.join(',') + ')');
    }

    return factories[argsLength](C, args);
  }; // `Function.prototype.bind` method implementation
  // https://tc39.github.io/ecma262/#sec-function.prototype.bind


  var functionBind = Function.bind || function bind(that
  /* , ...args */
  ) {
    var fn = aFunction$1(this);
    var partArgs = slice.call(arguments, 1);

    var boundFunction = function bound()
    /* args... */
    {
      var args = partArgs.concat(slice.call(arguments));
      return this instanceof boundFunction ? construct(fn, args.length, args) : fn.apply(that, args);
    };

    if (isObject(fn.prototype)) boundFunction.prototype = fn.prototype;
    return boundFunction;
  };

  var nativeConstruct = getBuiltIn('Reflect', 'construct'); // `Reflect.construct` method
  // https://tc39.github.io/ecma262/#sec-reflect.construct
  // MS Edge supports only 2 arguments and argumentsList argument is optional
  // FF Nightly sets third argument as `new.target`, but does not create `this` from it

  var NEW_TARGET_BUG = fails(function () {
    function F() {
      /* empty */
    }

    return !(nativeConstruct(function () {
      /* empty */
    }, [], F) instanceof F);
  });
  var ARGS_BUG = !fails(function () {
    nativeConstruct(function () {
      /* empty */
    });
  });
  var FORCED = NEW_TARGET_BUG || ARGS_BUG;
  _export({
    target: 'Reflect',
    stat: true,
    forced: FORCED,
    sham: FORCED
  }, {
    construct: function construct(Target, args
    /* , newTarget */
    ) {
      aFunction$1(Target);
      anObject(args);
      var newTarget = arguments.length < 3 ? Target : aFunction$1(arguments[2]);
      if (ARGS_BUG && !NEW_TARGET_BUG) return nativeConstruct(Target, args, newTarget);

      if (Target == newTarget) {
        // w/o altered newTarget, optimization for 0-4 arguments
        switch (args.length) {
          case 0:
            return new Target();

          case 1:
            return new Target(args[0]);

          case 2:
            return new Target(args[0], args[1]);

          case 3:
            return new Target(args[0], args[1], args[2]);

          case 4:
            return new Target(args[0], args[1], args[2], args[3]);
        } // w/o altered newTarget, lot of arguments case


        var $args = [null];
        $args.push.apply($args, args);
        return new (functionBind.apply(Target, $args))();
      } // with altered newTarget, not support built-in constructors


      var proto = newTarget.prototype;
      var instance = objectCreate(isObject(proto) ? proto : Object.prototype);
      var result = Function.apply.call(Target, instance, args);
      return isObject(result) ? result : instance;
    }
  });

  var ERROR_INSTEAD_OF_FALSE = fails(function () {
    // eslint-disable-next-line no-undef
    Reflect.defineProperty(objectDefineProperty.f({}, 1, {
      value: 1
    }), 1, {
      value: 2
    });
  }); // `Reflect.defineProperty` method
  // https://tc39.github.io/ecma262/#sec-reflect.defineproperty

  _export({
    target: 'Reflect',
    stat: true,
    forced: ERROR_INSTEAD_OF_FALSE,
    sham: !descriptors
  }, {
    defineProperty: function defineProperty(target, propertyKey, attributes) {
      anObject(target);
      var key = toPrimitive(propertyKey, true);
      anObject(attributes);

      try {
        objectDefineProperty.f(target, key, attributes);
        return true;
      } catch (error) {
        return false;
      }
    }
  });

  var getOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f; // `Reflect.deleteProperty` method
  // https://tc39.github.io/ecma262/#sec-reflect.deleteproperty

  _export({
    target: 'Reflect',
    stat: true
  }, {
    deleteProperty: function deleteProperty(target, propertyKey) {
      var descriptor = getOwnPropertyDescriptor$2(anObject(target), propertyKey);
      return descriptor && !descriptor.configurable ? false : delete target[propertyKey];
    }
  });

  // https://tc39.github.io/ecma262/#sec-toobject

  var toObject = function toObject(argument) {
    return Object(requireObjectCoercible(argument));
  };

  var correctPrototypeGetter = !fails(function () {
    function F() {
      /* empty */
    }

    F.prototype.constructor = null;
    return Object.getPrototypeOf(new F()) !== F.prototype;
  });

  var IE_PROTO$1 = sharedKey('IE_PROTO');
  var ObjectPrototype = Object.prototype; // `Object.getPrototypeOf` method
  // https://tc39.github.io/ecma262/#sec-object.getprototypeof

  var objectGetPrototypeOf = correctPrototypeGetter ? Object.getPrototypeOf : function (O) {
    O = toObject(O);
    if (has(O, IE_PROTO$1)) return O[IE_PROTO$1];

    if (typeof O.constructor == 'function' && O instanceof O.constructor) {
      return O.constructor.prototype;
    }

    return O instanceof Object ? ObjectPrototype : null;
  };

  // https://tc39.github.io/ecma262/#sec-reflect.get

  function get$1(target, propertyKey
  /* , receiver */
  ) {
    var receiver = arguments.length < 3 ? target : arguments[2];
    var descriptor, prototype;
    if (anObject(target) === receiver) return target[propertyKey];
    if (descriptor = objectGetOwnPropertyDescriptor.f(target, propertyKey)) return has(descriptor, 'value') ? descriptor.value : descriptor.get === undefined ? undefined : descriptor.get.call(receiver);
    if (isObject(prototype = objectGetPrototypeOf(target))) return get$1(prototype, propertyKey, receiver);
  }

  _export({
    target: 'Reflect',
    stat: true
  }, {
    get: get$1
  });

  // https://tc39.github.io/ecma262/#sec-reflect.getownpropertydescriptor

  _export({
    target: 'Reflect',
    stat: true,
    sham: !descriptors
  }, {
    getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
      return objectGetOwnPropertyDescriptor.f(anObject(target), propertyKey);
    }
  });

  // https://tc39.github.io/ecma262/#sec-reflect.getprototypeof

  _export({
    target: 'Reflect',
    stat: true,
    sham: !correctPrototypeGetter
  }, {
    getPrototypeOf: function getPrototypeOf(target) {
      return objectGetPrototypeOf(anObject(target));
    }
  });

  // https://tc39.github.io/ecma262/#sec-reflect.has

  _export({
    target: 'Reflect',
    stat: true
  }, {
    has: function has(target, propertyKey) {
      return propertyKey in target;
    }
  });

  var objectIsExtensible = Object.isExtensible; // `Reflect.isExtensible` method
  // https://tc39.github.io/ecma262/#sec-reflect.isextensible

  _export({
    target: 'Reflect',
    stat: true
  }, {
    isExtensible: function isExtensible(target) {
      anObject(target);
      return objectIsExtensible ? objectIsExtensible(target) : true;
    }
  });

  // https://tc39.github.io/ecma262/#sec-reflect.ownkeys

  _export({
    target: 'Reflect',
    stat: true
  }, {
    ownKeys: ownKeys
  });

  var freezing = !fails(function () {
    return Object.isExtensible(Object.preventExtensions({}));
  });

  // https://tc39.github.io/ecma262/#sec-reflect.preventextensions

  _export({
    target: 'Reflect',
    stat: true,
    sham: !freezing
  }, {
    preventExtensions: function preventExtensions(target) {
      anObject(target);

      try {
        var objectPreventExtensions = getBuiltIn('Object', 'preventExtensions');
        if (objectPreventExtensions) objectPreventExtensions(target);
        return true;
      } catch (error) {
        return false;
      }
    }
  });

  // https://tc39.github.io/ecma262/#sec-reflect.set

  function set$2(target, propertyKey, V
  /* , receiver */
  ) {
    var receiver = arguments.length < 4 ? target : arguments[3];
    var ownDescriptor = objectGetOwnPropertyDescriptor.f(anObject(target), propertyKey);
    var existingDescriptor, prototype;

    if (!ownDescriptor) {
      if (isObject(prototype = objectGetPrototypeOf(target))) {
        return set$2(prototype, propertyKey, V, receiver);
      }

      ownDescriptor = createPropertyDescriptor(0);
    }

    if (has(ownDescriptor, 'value')) {
      if (ownDescriptor.writable === false || !isObject(receiver)) return false;

      if (existingDescriptor = objectGetOwnPropertyDescriptor.f(receiver, propertyKey)) {
        if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false;
        existingDescriptor.value = V;
        objectDefineProperty.f(receiver, propertyKey, existingDescriptor);
      } else objectDefineProperty.f(receiver, propertyKey, createPropertyDescriptor(0, V));

      return true;
    }

    return ownDescriptor.set === undefined ? false : (ownDescriptor.set.call(receiver, V), true);
  } // MS Edge 17-18 Reflect.set allows setting the property to object
  // with non-writable property on the prototype


  var MS_EDGE_BUG = fails(function () {
    var object = objectDefineProperty.f({}, 'a', {
      configurable: true
    }); // eslint-disable-next-line no-undef

    return Reflect.set(objectGetPrototypeOf(object), 'a', 1, object) !== false;
  });
  _export({
    target: 'Reflect',
    stat: true,
    forced: MS_EDGE_BUG
  }, {
    set: set$2
  });

  var aPossiblePrototype = function aPossiblePrototype(it) {
    if (!isObject(it) && it !== null) {
      throw TypeError("Can't set " + String(it) + ' as a prototype');
    }

    return it;
  };

  // https://tc39.github.io/ecma262/#sec-object.setprototypeof
  // Works with __proto__ only. Old v8 can't work with null proto objects.

  /* eslint-disable no-proto */

  var objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {
    var CORRECT_SETTER = false;
    var test = {};
    var setter;

    try {
      setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;
      setter.call(test, []);
      CORRECT_SETTER = test instanceof Array;
    } catch (error) {
      /* empty */
    }

    return function setPrototypeOf(O, proto) {
      anObject(O);
      aPossiblePrototype(proto);
      if (CORRECT_SETTER) setter.call(O, proto);else O.__proto__ = proto;
      return O;
    };
  }() : undefined);

  // https://tc39.github.io/ecma262/#sec-reflect.setprototypeof

  if (objectSetPrototypeOf) _export({
    target: 'Reflect',
    stat: true
  }, {
    setPrototypeOf: function setPrototypeOf(target, proto) {
      anObject(target);
      aPossiblePrototype(proto);

      try {
        objectSetPrototypeOf(target, proto);
        return true;
      } catch (error) {
        return false;
      }
    }
  });

  var reflect = path.Reflect;

  var nativeSymbol = !!Object.getOwnPropertySymbols && !fails(function () {
    // Chrome 38 Symbol has incorrect toString conversion
    // eslint-disable-next-line no-undef
    return !String(Symbol());
  });

  var useSymbolAsUid = nativeSymbol // eslint-disable-next-line no-undef
  && !Symbol.sham // eslint-disable-next-line no-undef
  && _typeof(Symbol.iterator) == 'symbol';

  var WellKnownSymbolsStore = shared('wks');
  var _Symbol = global_1.Symbol;
  var createWellKnownSymbol = useSymbolAsUid ? _Symbol : _Symbol && _Symbol.withoutSetter || uid;

  var wellKnownSymbol = function wellKnownSymbol(name) {
    if (!has(WellKnownSymbolsStore, name)) {
      if (nativeSymbol && has(_Symbol, name)) WellKnownSymbolsStore[name] = _Symbol[name];else WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);
    }

    return WellKnownSymbolsStore[name];
  };

  var TO_STRING_TAG = wellKnownSymbol('toStringTag');
  var test = {};
  test[TO_STRING_TAG] = 'z';
  var toStringTagSupport = String(test) === '[object z]';

  var TO_STRING_TAG$1 = wellKnownSymbol('toStringTag'); // ES3 wrong here

  var CORRECT_ARGUMENTS = classofRaw(function () {
    return arguments;
  }()) == 'Arguments'; // fallback for IE11 Script Access Denied error

  var tryGet = function tryGet(it, key) {
    try {
      return it[key];
    } catch (error) {
      /* empty */
    }
  }; // getting tag from ES6+ `Object.prototype.toString`


  var classof = toStringTagSupport ? classofRaw : function (it) {
    var O, tag, result;
    return it === undefined ? 'Undefined' : it === null ? 'Null' // @@toStringTag case
    : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG$1)) == 'string' ? tag // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O) // ES3 arguments fallback
    : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;
  };

  // https://tc39.github.io/ecma262/#sec-object.prototype.tostring


  var objectToString = toStringTagSupport ? {}.toString : function toString() {
    return '[object ' + classof(this) + ']';
  };

  // https://tc39.github.io/ecma262/#sec-object.prototype.tostring

  if (!toStringTagSupport) {
    redefine(Object.prototype, 'toString', objectToString, {
      unsafe: true
    });
  }

  var createMethod$1 = function createMethod(CONVERT_TO_STRING) {
    return function ($this, pos) {
      var S = String(requireObjectCoercible($this));
      var position = toInteger(pos);
      var size = S.length;
      var first, second;
      if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
      first = S.charCodeAt(position);
      return first < 0xD800 || first > 0xDBFF || position + 1 === size || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF ? CONVERT_TO_STRING ? S.charAt(position) : first : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
    };
  };

  var stringMultibyte = {
    // `String.prototype.codePointAt` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.codepointat
    codeAt: createMethod$1(false),
    // `String.prototype.at` method
    // https://github.com/mathiasbynens/String.prototype.at
    charAt: createMethod$1(true)
  };

  var ITERATOR = wellKnownSymbol('iterator');
  var BUGGY_SAFARI_ITERATORS = false;

  var returnThis = function returnThis() {
    return this;
  }; // `%IteratorPrototype%` object
  // https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object


  var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

  if ([].keys) {
    arrayIterator = [].keys(); // Safari 8 has buggy iterators w/o `next`

    if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;else {
      PrototypeOfArrayIteratorPrototype = objectGetPrototypeOf(objectGetPrototypeOf(arrayIterator));
      if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
    }
  }

  if (IteratorPrototype == undefined) IteratorPrototype = {}; // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()

  if ( !has(IteratorPrototype, ITERATOR)) {
    createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);
  }

  var iteratorsCore = {
    IteratorPrototype: IteratorPrototype,
    BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
  };

  var defineProperty = objectDefineProperty.f;
  var TO_STRING_TAG$2 = wellKnownSymbol('toStringTag');

  var setToStringTag = function setToStringTag(it, TAG, STATIC) {
    if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG$2)) {
      defineProperty(it, TO_STRING_TAG$2, {
        configurable: true,
        value: TAG
      });
    }
  };

  var iterators = {};

  var IteratorPrototype$1 = iteratorsCore.IteratorPrototype;

  var returnThis$1 = function returnThis() {
    return this;
  };

  var createIteratorConstructor = function createIteratorConstructor(IteratorConstructor, NAME, next) {
    var TO_STRING_TAG = NAME + ' Iterator';
    IteratorConstructor.prototype = objectCreate(IteratorPrototype$1, {
      next: createPropertyDescriptor(1, next)
    });
    setToStringTag(IteratorConstructor, TO_STRING_TAG, false);
    iterators[TO_STRING_TAG] = returnThis$1;
    return IteratorConstructor;
  };

  var IteratorPrototype$2 = iteratorsCore.IteratorPrototype;
  var BUGGY_SAFARI_ITERATORS$1 = iteratorsCore.BUGGY_SAFARI_ITERATORS;
  var ITERATOR$1 = wellKnownSymbol('iterator');
  var KEYS = 'keys';
  var VALUES = 'values';
  var ENTRIES = 'entries';

  var returnThis$2 = function returnThis() {
    return this;
  };

  var defineIterator = function defineIterator(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
    createIteratorConstructor(IteratorConstructor, NAME, next);

    var getIterationMethod = function getIterationMethod(KIND) {
      if (KIND === DEFAULT && defaultIterator) return defaultIterator;
      if (!BUGGY_SAFARI_ITERATORS$1 && KIND in IterablePrototype) return IterablePrototype[KIND];

      switch (KIND) {
        case KEYS:
          return function keys() {
            return new IteratorConstructor(this, KIND);
          };

        case VALUES:
          return function values() {
            return new IteratorConstructor(this, KIND);
          };

        case ENTRIES:
          return function entries() {
            return new IteratorConstructor(this, KIND);
          };
      }

      return function () {
        return new IteratorConstructor(this);
      };
    };

    var TO_STRING_TAG = NAME + ' Iterator';
    var INCORRECT_VALUES_NAME = false;
    var IterablePrototype = Iterable.prototype;
    var nativeIterator = IterablePrototype[ITERATOR$1] || IterablePrototype['@@iterator'] || DEFAULT && IterablePrototype[DEFAULT];
    var defaultIterator = !BUGGY_SAFARI_ITERATORS$1 && nativeIterator || getIterationMethod(DEFAULT);
    var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
    var CurrentIteratorPrototype, methods, KEY; // fix native

    if (anyNativeIterator) {
      CurrentIteratorPrototype = objectGetPrototypeOf(anyNativeIterator.call(new Iterable()));

      if (IteratorPrototype$2 !== Object.prototype && CurrentIteratorPrototype.next) {
        if ( objectGetPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype$2) {
          if (objectSetPrototypeOf) {
            objectSetPrototypeOf(CurrentIteratorPrototype, IteratorPrototype$2);
          } else if (typeof CurrentIteratorPrototype[ITERATOR$1] != 'function') {
            createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR$1, returnThis$2);
          }
        } // Set @@toStringTag to native iterators


        setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true);
      }
    } // fix Array#{values, @@iterator}.name in V8 / FF


    if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
      INCORRECT_VALUES_NAME = true;

      defaultIterator = function values() {
        return nativeIterator.call(this);
      };
    } // define iterator


    if ( IterablePrototype[ITERATOR$1] !== defaultIterator) {
      createNonEnumerableProperty(IterablePrototype, ITERATOR$1, defaultIterator);
    }

    iterators[NAME] = defaultIterator; // export additional methods

    if (DEFAULT) {
      methods = {
        values: getIterationMethod(VALUES),
        keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
        entries: getIterationMethod(ENTRIES)
      };
      if (FORCED) for (KEY in methods) {
        if (BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
          redefine(IterablePrototype, KEY, methods[KEY]);
        }
      } else _export({
        target: NAME,
        proto: true,
        forced: BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME
      }, methods);
    }

    return methods;
  };

  var charAt = stringMultibyte.charAt;
  var STRING_ITERATOR = 'String Iterator';
  var setInternalState = internalState.set;
  var getInternalState = internalState.getterFor(STRING_ITERATOR); // `String.prototype[@@iterator]` method
  // https://tc39.github.io/ecma262/#sec-string.prototype-@@iterator

  defineIterator(String, 'String', function (iterated) {
    setInternalState(this, {
      type: STRING_ITERATOR,
      string: String(iterated),
      index: 0
    }); // `%StringIteratorPrototype%.next` method
    // https://tc39.github.io/ecma262/#sec-%stringiteratorprototype%.next
  }, function next() {
    var state = getInternalState(this);
    var string = state.string;
    var index = state.index;
    var point;
    if (index >= string.length) return {
      value: undefined,
      done: true
    };
    point = charAt(string, index);
    state.index += point.length;
    return {
      value: point,
      done: false
    };
  });

  // iterable DOM collections
  // flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
  var domIterables = {
    CSSRuleList: 0,
    CSSStyleDeclaration: 0,
    CSSValueList: 0,
    ClientRectList: 0,
    DOMRectList: 0,
    DOMStringList: 0,
    DOMTokenList: 1,
    DataTransferItemList: 0,
    FileList: 0,
    HTMLAllCollection: 0,
    HTMLCollection: 0,
    HTMLFormElement: 0,
    HTMLSelectElement: 0,
    MediaList: 0,
    MimeTypeArray: 0,
    NamedNodeMap: 0,
    NodeList: 1,
    PaintRequestList: 0,
    Plugin: 0,
    PluginArray: 0,
    SVGLengthList: 0,
    SVGNumberList: 0,
    SVGPathSegList: 0,
    SVGPointList: 0,
    SVGStringList: 0,
    SVGTransformList: 0,
    SourceBufferList: 0,
    StyleSheetList: 0,
    TextTrackCueList: 0,
    TextTrackList: 0,
    TouchList: 0
  };

  var UNSCOPABLES = wellKnownSymbol('unscopables');
  var ArrayPrototype = Array.prototype; // Array.prototype[@@unscopables]
  // https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables

  if (ArrayPrototype[UNSCOPABLES] == undefined) {
    objectDefineProperty.f(ArrayPrototype, UNSCOPABLES, {
      configurable: true,
      value: objectCreate(null)
    });
  } // add a key to Array.prototype[@@unscopables]


  var addToUnscopables = function addToUnscopables(key) {
    ArrayPrototype[UNSCOPABLES][key] = true;
  };

  var ARRAY_ITERATOR = 'Array Iterator';
  var setInternalState$1 = internalState.set;
  var getInternalState$1 = internalState.getterFor(ARRAY_ITERATOR); // `Array.prototype.entries` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.entries
  // `Array.prototype.keys` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.keys
  // `Array.prototype.values` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.values
  // `Array.prototype[@@iterator]` method
  // https://tc39.github.io/ecma262/#sec-array.prototype-@@iterator
  // `CreateArrayIterator` internal method
  // https://tc39.github.io/ecma262/#sec-createarrayiterator

  var es_array_iterator = defineIterator(Array, 'Array', function (iterated, kind) {
    setInternalState$1(this, {
      type: ARRAY_ITERATOR,
      target: toIndexedObject(iterated),
      // target
      index: 0,
      // next index
      kind: kind // kind

    }); // `%ArrayIteratorPrototype%.next` method
    // https://tc39.github.io/ecma262/#sec-%arrayiteratorprototype%.next
  }, function () {
    var state = getInternalState$1(this);
    var target = state.target;
    var kind = state.kind;
    var index = state.index++;

    if (!target || index >= target.length) {
      state.target = undefined;
      return {
        value: undefined,
        done: true
      };
    }

    if (kind == 'keys') return {
      value: index,
      done: false
    };
    if (kind == 'values') return {
      value: target[index],
      done: false
    };
    return {
      value: [index, target[index]],
      done: false
    };
  }, 'values'); // argumentsList[@@iterator] is %ArrayProto_values%
  // https://tc39.github.io/ecma262/#sec-createunmappedargumentsobject
  // https://tc39.github.io/ecma262/#sec-createmappedargumentsobject

  iterators.Arguments = iterators.Array; // https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables

  addToUnscopables('keys');
  addToUnscopables('values');
  addToUnscopables('entries');

  var ITERATOR$2 = wellKnownSymbol('iterator');
  var TO_STRING_TAG$3 = wellKnownSymbol('toStringTag');
  var ArrayValues = es_array_iterator.values;

  for (var COLLECTION_NAME in domIterables) {
    var Collection = global_1[COLLECTION_NAME];
    var CollectionPrototype = Collection && Collection.prototype;

    if (CollectionPrototype) {
      // some Chrome versions have non-configurable methods on DOMTokenList
      if (CollectionPrototype[ITERATOR$2] !== ArrayValues) try {
        createNonEnumerableProperty(CollectionPrototype, ITERATOR$2, ArrayValues);
      } catch (error) {
        CollectionPrototype[ITERATOR$2] = ArrayValues;
      }

      if (!CollectionPrototype[TO_STRING_TAG$3]) {
        createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG$3, COLLECTION_NAME);
      }

      if (domIterables[COLLECTION_NAME]) for (var METHOD_NAME in es_array_iterator) {
        // some Chrome versions have non-configurable methods on DOMTokenList
        if (CollectionPrototype[METHOD_NAME] !== es_array_iterator[METHOD_NAME]) try {
          createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, es_array_iterator[METHOD_NAME]);
        } catch (error) {
          CollectionPrototype[METHOD_NAME] = es_array_iterator[METHOD_NAME];
        }
      }
    }
  }

  var nativePromiseConstructor = global_1.Promise;

  var redefineAll = function redefineAll(target, src, options) {
    for (var key in src) {
      redefine(target, key, src[key], options);
    }

    return target;
  };

  var SPECIES = wellKnownSymbol('species');

  var setSpecies = function setSpecies(CONSTRUCTOR_NAME) {
    var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
    var defineProperty = objectDefineProperty.f;

    if (descriptors && Constructor && !Constructor[SPECIES]) {
      defineProperty(Constructor, SPECIES, {
        configurable: true,
        get: function get() {
          return this;
        }
      });
    }
  };

  var anInstance = function anInstance(it, Constructor, name) {
    if (!(it instanceof Constructor)) {
      throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');
    }

    return it;
  };

  var ITERATOR$3 = wellKnownSymbol('iterator');
  var ArrayPrototype$1 = Array.prototype; // check on default Array iterator

  var isArrayIteratorMethod = function isArrayIteratorMethod(it) {
    return it !== undefined && (iterators.Array === it || ArrayPrototype$1[ITERATOR$3] === it);
  };

  var functionBindContext = function functionBindContext(fn, that, length) {
    aFunction$1(fn);
    if (that === undefined) return fn;

    switch (length) {
      case 0:
        return function () {
          return fn.call(that);
        };

      case 1:
        return function (a) {
          return fn.call(that, a);
        };

      case 2:
        return function (a, b) {
          return fn.call(that, a, b);
        };

      case 3:
        return function (a, b, c) {
          return fn.call(that, a, b, c);
        };
    }

    return function ()
    /* ...args */
    {
      return fn.apply(that, arguments);
    };
  };

  var ITERATOR$4 = wellKnownSymbol('iterator');

  var getIteratorMethod = function getIteratorMethod(it) {
    if (it != undefined) return it[ITERATOR$4] || it['@@iterator'] || iterators[classof(it)];
  };

  var callWithSafeIterationClosing = function callWithSafeIterationClosing(iterator, fn, value, ENTRIES) {
    try {
      return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value); // 7.4.6 IteratorClose(iterator, completion)
    } catch (error) {
      var returnMethod = iterator['return'];
      if (returnMethod !== undefined) anObject(returnMethod.call(iterator));
      throw error;
    }
  };

  var iterate_1 = createCommonjsModule(function (module) {
    var Result = function Result(stopped, result) {
      this.stopped = stopped;
      this.result = result;
    };

    var iterate = module.exports = function (iterable, fn, that, AS_ENTRIES, IS_ITERATOR) {
      var boundFunction = functionBindContext(fn, that, AS_ENTRIES ? 2 : 1);
      var iterator, iterFn, index, length, result, next, step;

      if (IS_ITERATOR) {
        iterator = iterable;
      } else {
        iterFn = getIteratorMethod(iterable);
        if (typeof iterFn != 'function') throw TypeError('Target is not iterable'); // optimisation for array iterators

        if (isArrayIteratorMethod(iterFn)) {
          for (index = 0, length = toLength(iterable.length); length > index; index++) {
            result = AS_ENTRIES ? boundFunction(anObject(step = iterable[index])[0], step[1]) : boundFunction(iterable[index]);
            if (result && result instanceof Result) return result;
          }

          return new Result(false);
        }

        iterator = iterFn.call(iterable);
      }

      next = iterator.next;

      while (!(step = next.call(iterator)).done) {
        result = callWithSafeIterationClosing(iterator, boundFunction, step.value, AS_ENTRIES);
        if (_typeof(result) == 'object' && result && result instanceof Result) return result;
      }

      return new Result(false);
    };

    iterate.stop = function (result) {
      return new Result(true, result);
    };
  });

  var ITERATOR$5 = wellKnownSymbol('iterator');
  var SAFE_CLOSING = false;

  try {
    var called = 0;
    var iteratorWithReturn = {
      next: function next() {
        return {
          done: !!called++
        };
      },
      'return': function _return() {
        SAFE_CLOSING = true;
      }
    };

    iteratorWithReturn[ITERATOR$5] = function () {
      return this;
    }; // eslint-disable-next-line no-throw-literal


    Array.from(iteratorWithReturn, function () {
      throw 2;
    });
  } catch (error) {
    /* empty */
  }

  var checkCorrectnessOfIteration = function checkCorrectnessOfIteration(exec, SKIP_CLOSING) {
    if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
    var ITERATION_SUPPORT = false;

    try {
      var object = {};

      object[ITERATOR$5] = function () {
        return {
          next: function next() {
            return {
              done: ITERATION_SUPPORT = true
            };
          }
        };
      };

      exec(object);
    } catch (error) {
      /* empty */
    }

    return ITERATION_SUPPORT;
  };

  var SPECIES$1 = wellKnownSymbol('species'); // `SpeciesConstructor` abstract operation
  // https://tc39.github.io/ecma262/#sec-speciesconstructor

  var speciesConstructor = function speciesConstructor(O, defaultConstructor) {
    var C = anObject(O).constructor;
    var S;
    return C === undefined || (S = anObject(C)[SPECIES$1]) == undefined ? defaultConstructor : aFunction$1(S);
  };

  var engineUserAgent = getBuiltIn('navigator', 'userAgent') || '';

  var engineIsIos = /(iphone|ipod|ipad).*applewebkit/i.test(engineUserAgent);

  var location = global_1.location;
  var set$3 = global_1.setImmediate;
  var clear = global_1.clearImmediate;
  var process = global_1.process;
  var MessageChannel = global_1.MessageChannel;
  var Dispatch = global_1.Dispatch;
  var counter = 0;
  var queue = {};
  var ONREADYSTATECHANGE = 'onreadystatechange';
  var defer, channel, port;

  var run = function run(id) {
    // eslint-disable-next-line no-prototype-builtins
    if (queue.hasOwnProperty(id)) {
      var fn = queue[id];
      delete queue[id];
      fn();
    }
  };

  var runner = function runner(id) {
    return function () {
      run(id);
    };
  };

  var listener = function listener(event) {
    run(event.data);
  };

  var post = function post(id) {
    // old engines have not location.origin
    global_1.postMessage(id + '', location.protocol + '//' + location.host);
  }; // Node.js 0.9+ & IE10+ has setImmediate, otherwise:


  if (!set$3 || !clear) {
    set$3 = function setImmediate(fn) {
      var args = [];
      var i = 1;

      while (arguments.length > i) {
        args.push(arguments[i++]);
      }

      queue[++counter] = function () {
        // eslint-disable-next-line no-new-func
        (typeof fn == 'function' ? fn : Function(fn)).apply(undefined, args);
      };

      defer(counter);
      return counter;
    };

    clear = function clearImmediate(id) {
      delete queue[id];
    }; // Node.js 0.8-


    if (classofRaw(process) == 'process') {
      defer = function defer(id) {
        process.nextTick(runner(id));
      }; // Sphere (JS game engine) Dispatch API

    } else if (Dispatch && Dispatch.now) {
      defer = function defer(id) {
        Dispatch.now(runner(id));
      }; // Browsers with MessageChannel, includes WebWorkers
      // except iOS - https://github.com/zloirock/core-js/issues/624

    } else if (MessageChannel && !engineIsIos) {
      channel = new MessageChannel();
      port = channel.port2;
      channel.port1.onmessage = listener;
      defer = functionBindContext(port.postMessage, port, 1); // Browsers with postMessage, skip WebWorkers
      // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
    } else if (global_1.addEventListener && typeof postMessage == 'function' && !global_1.importScripts && !fails(post)) {
      defer = post;
      global_1.addEventListener('message', listener, false); // IE8-
    } else if (ONREADYSTATECHANGE in documentCreateElement('script')) {
      defer = function defer(id) {
        html.appendChild(documentCreateElement('script'))[ONREADYSTATECHANGE] = function () {
          html.removeChild(this);
          run(id);
        };
      }; // Rest old browsers

    } else {
      defer = function defer(id) {
        setTimeout(runner(id), 0);
      };
    }
  }

  var task = {
    set: set$3,
    clear: clear
  };

  var getOwnPropertyDescriptor$3 = objectGetOwnPropertyDescriptor.f;
  var macrotask = task.set;
  var MutationObserver$1 = global_1.MutationObserver || global_1.WebKitMutationObserver;
  var process$1 = global_1.process;
  var Promise$1 = global_1.Promise;
  var IS_NODE = classofRaw(process$1) == 'process'; // Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`

  var queueMicrotaskDescriptor = getOwnPropertyDescriptor$3(global_1, 'queueMicrotask');
  var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;
  var flush, head, last, notify, toggle, node, promise, then; // modern engines have queueMicrotask method

  if (!queueMicrotask) {
    flush = function flush() {
      var parent, fn;
      if (IS_NODE && (parent = process$1.domain)) parent.exit();

      while (head) {
        fn = head.fn;
        head = head.next;

        try {
          fn();
        } catch (error) {
          if (head) notify();else last = undefined;
          throw error;
        }
      }

      last = undefined;
      if (parent) parent.enter();
    }; // Node.js


    if (IS_NODE) {
      notify = function notify() {
        process$1.nextTick(flush);
      }; // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339

    } else if (MutationObserver$1 && !engineIsIos) {
      toggle = true;
      node = document.createTextNode('');
      new MutationObserver$1(flush).observe(node, {
        characterData: true
      });

      notify = function notify() {
        node.data = toggle = !toggle;
      }; // environments with maybe non-completely correct, but existent Promise

    } else if (Promise$1 && Promise$1.resolve) {
      // Promise.resolve without an argument throws an error in LG WebOS 2
      promise = Promise$1.resolve(undefined);
      then = promise.then;

      notify = function notify() {
        then.call(promise, flush);
      }; // for other environments - macrotask based on:
      // - setImmediate
      // - MessageChannel
      // - window.postMessag
      // - onreadystatechange
      // - setTimeout

    } else {
      notify = function notify() {
        // strange IE + webpack dev server bug - use .call(global)
        macrotask.call(global_1, flush);
      };
    }
  }

  var microtask = queueMicrotask || function (fn) {
    var task = {
      fn: fn,
      next: undefined
    };
    if (last) last.next = task;

    if (!head) {
      head = task;
      notify();
    }

    last = task;
  };

  var PromiseCapability = function PromiseCapability(C) {
    var resolve, reject;
    this.promise = new C(function ($$resolve, $$reject) {
      if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
      resolve = $$resolve;
      reject = $$reject;
    });
    this.resolve = aFunction$1(resolve);
    this.reject = aFunction$1(reject);
  }; // 25.4.1.5 NewPromiseCapability(C)


  var f$5 = function f(C) {
    return new PromiseCapability(C);
  };

  var newPromiseCapability = {
    f: f$5
  };

  var promiseResolve = function promiseResolve(C, x) {
    anObject(C);
    if (isObject(x) && x.constructor === C) return x;
    var promiseCapability = newPromiseCapability.f(C);
    var resolve = promiseCapability.resolve;
    resolve(x);
    return promiseCapability.promise;
  };

  var hostReportErrors = function hostReportErrors(a, b) {
    var console = global_1.console;

    if (console && console.error) {
      arguments.length === 1 ? console.error(a) : console.error(a, b);
    }
  };

  var perform = function perform(exec) {
    try {
      return {
        error: false,
        value: exec()
      };
    } catch (error) {
      return {
        error: true,
        value: error
      };
    }
  };

  var process$2 = global_1.process;
  var versions = process$2 && process$2.versions;
  var v8 = versions && versions.v8;
  var match, version;

  if (v8) {
    match = v8.split('.');
    version = match[0] + match[1];
  } else if (engineUserAgent) {
    match = engineUserAgent.match(/Edge\/(\d+)/);

    if (!match || match[1] >= 74) {
      match = engineUserAgent.match(/Chrome\/(\d+)/);
      if (match) version = match[1];
    }
  }

  var engineV8Version = version && +version;

  var task$1 = task.set;
  var SPECIES$2 = wellKnownSymbol('species');
  var PROMISE = 'Promise';
  var getInternalState$2 = internalState.get;
  var setInternalState$2 = internalState.set;
  var getInternalPromiseState = internalState.getterFor(PROMISE);
  var PromiseConstructor = nativePromiseConstructor;
  var TypeError$1 = global_1.TypeError;
  var document$2 = global_1.document;
  var process$3 = global_1.process;
  var $fetch = getBuiltIn('fetch');
  var newPromiseCapability$1 = newPromiseCapability.f;
  var newGenericPromiseCapability = newPromiseCapability$1;
  var IS_NODE$1 = classofRaw(process$3) == 'process';
  var DISPATCH_EVENT = !!(document$2 && document$2.createEvent && global_1.dispatchEvent);
  var UNHANDLED_REJECTION = 'unhandledrejection';
  var REJECTION_HANDLED = 'rejectionhandled';
  var PENDING = 0;
  var FULFILLED = 1;
  var REJECTED = 2;
  var HANDLED = 1;
  var UNHANDLED = 2;
  var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;
  var FORCED$1 = isForced_1(PROMISE, function () {
    var GLOBAL_CORE_JS_PROMISE = inspectSource(PromiseConstructor) !== String(PromiseConstructor);

    if (!GLOBAL_CORE_JS_PROMISE) {
      // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
      // We can't detect it synchronously, so just check versions
      if (engineV8Version === 66) return true; // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test

      if (!IS_NODE$1 && typeof PromiseRejectionEvent != 'function') return true;
    } // We need Promise#finally in the pure version for preventing prototype pollution
    // deoptimization and performance degradation
    // https://github.com/zloirock/core-js/issues/679

    if (engineV8Version >= 51 && /native code/.test(PromiseConstructor)) return false; // Detect correctness of subclassing with @@species support

    var promise = PromiseConstructor.resolve(1);

    var FakePromise = function FakePromise(exec) {
      exec(function () {
        /* empty */
      }, function () {
        /* empty */
      });
    };

    var constructor = promise.constructor = {};
    constructor[SPECIES$2] = FakePromise;
    return !(promise.then(function () {
      /* empty */
    }) instanceof FakePromise);
  });
  var INCORRECT_ITERATION = FORCED$1 || !checkCorrectnessOfIteration(function (iterable) {
    PromiseConstructor.all(iterable)['catch'](function () {
      /* empty */
    });
  }); // helpers

  var isThenable = function isThenable(it) {
    var then;
    return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
  };

  var notify$1 = function notify(promise, state, isReject) {
    if (state.notified) return;
    state.notified = true;
    var chain = state.reactions;
    microtask(function () {
      var value = state.value;
      var ok = state.state == FULFILLED;
      var index = 0; // variable length - can't use forEach

      while (chain.length > index) {
        var reaction = chain[index++];
        var handler = ok ? reaction.ok : reaction.fail;
        var resolve = reaction.resolve;
        var reject = reaction.reject;
        var domain = reaction.domain;
        var result, then, exited;

        try {
          if (handler) {
            if (!ok) {
              if (state.rejection === UNHANDLED) onHandleUnhandled(promise, state);
              state.rejection = HANDLED;
            }

            if (handler === true) result = value;else {
              if (domain) domain.enter();
              result = handler(value); // can throw

              if (domain) {
                domain.exit();
                exited = true;
              }
            }

            if (result === reaction.promise) {
              reject(TypeError$1('Promise-chain cycle'));
            } else if (then = isThenable(result)) {
              then.call(result, resolve, reject);
            } else resolve(result);
          } else reject(value);
        } catch (error) {
          if (domain && !exited) domain.exit();
          reject(error);
        }
      }

      state.reactions = [];
      state.notified = false;
      if (isReject && !state.rejection) onUnhandled(promise, state);
    });
  };

  var dispatchEvent = function dispatchEvent(name, promise, reason) {
    var event, handler;

    if (DISPATCH_EVENT) {
      event = document$2.createEvent('Event');
      event.promise = promise;
      event.reason = reason;
      event.initEvent(name, false, true);
      global_1.dispatchEvent(event);
    } else event = {
      promise: promise,
      reason: reason
    };

    if (handler = global_1['on' + name]) handler(event);else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);
  };

  var onUnhandled = function onUnhandled(promise, state) {
    task$1.call(global_1, function () {
      var value = state.value;
      var IS_UNHANDLED = isUnhandled(state);
      var result;

      if (IS_UNHANDLED) {
        result = perform(function () {
          if (IS_NODE$1) {
            process$3.emit('unhandledRejection', value, promise);
          } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
        }); // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should

        state.rejection = IS_NODE$1 || isUnhandled(state) ? UNHANDLED : HANDLED;
        if (result.error) throw result.value;
      }
    });
  };

  var isUnhandled = function isUnhandled(state) {
    return state.rejection !== HANDLED && !state.parent;
  };

  var onHandleUnhandled = function onHandleUnhandled(promise, state) {
    task$1.call(global_1, function () {
      if (IS_NODE$1) {
        process$3.emit('rejectionHandled', promise);
      } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
    });
  };

  var bind = function bind(fn, promise, state, unwrap) {
    return function (value) {
      fn(promise, state, value, unwrap);
    };
  };

  var internalReject = function internalReject(promise, state, value, unwrap) {
    if (state.done) return;
    state.done = true;
    if (unwrap) state = unwrap;
    state.value = value;
    state.state = REJECTED;
    notify$1(promise, state, true);
  };

  var internalResolve = function internalResolve(promise, state, value, unwrap) {
    if (state.done) return;
    state.done = true;
    if (unwrap) state = unwrap;

    try {
      if (promise === value) throw TypeError$1("Promise can't be resolved itself");
      var then = isThenable(value);

      if (then) {
        microtask(function () {
          var wrapper = {
            done: false
          };

          try {
            then.call(value, bind(internalResolve, promise, wrapper, state), bind(internalReject, promise, wrapper, state));
          } catch (error) {
            internalReject(promise, wrapper, error, state);
          }
        });
      } else {
        state.value = value;
        state.state = FULFILLED;
        notify$1(promise, state, false);
      }
    } catch (error) {
      internalReject(promise, {
        done: false
      }, error, state);
    }
  }; // constructor polyfill


  if (FORCED$1) {
    // 25.4.3.1 Promise(executor)
    PromiseConstructor = function Promise(executor) {
      anInstance(this, PromiseConstructor, PROMISE);
      aFunction$1(executor);
      Internal.call(this);
      var state = getInternalState$2(this);

      try {
        executor(bind(internalResolve, this, state), bind(internalReject, this, state));
      } catch (error) {
        internalReject(this, state, error);
      }
    }; // eslint-disable-next-line no-unused-vars


    Internal = function Promise(executor) {
      setInternalState$2(this, {
        type: PROMISE,
        done: false,
        notified: false,
        parent: false,
        reactions: [],
        rejection: false,
        state: PENDING,
        value: undefined
      });
    };

    Internal.prototype = redefineAll(PromiseConstructor.prototype, {
      // `Promise.prototype.then` method
      // https://tc39.github.io/ecma262/#sec-promise.prototype.then
      then: function then(onFulfilled, onRejected) {
        var state = getInternalPromiseState(this);
        var reaction = newPromiseCapability$1(speciesConstructor(this, PromiseConstructor));
        reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
        reaction.fail = typeof onRejected == 'function' && onRejected;
        reaction.domain = IS_NODE$1 ? process$3.domain : undefined;
        state.parent = true;
        state.reactions.push(reaction);
        if (state.state != PENDING) notify$1(this, state, false);
        return reaction.promise;
      },
      // `Promise.prototype.catch` method
      // https://tc39.github.io/ecma262/#sec-promise.prototype.catch
      'catch': function _catch(onRejected) {
        return this.then(undefined, onRejected);
      }
    });

    OwnPromiseCapability = function OwnPromiseCapability() {
      var promise = new Internal();
      var state = getInternalState$2(promise);
      this.promise = promise;
      this.resolve = bind(internalResolve, promise, state);
      this.reject = bind(internalReject, promise, state);
    };

    newPromiseCapability.f = newPromiseCapability$1 = function newPromiseCapability(C) {
      return C === PromiseConstructor || C === PromiseWrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
    };

    if ( typeof nativePromiseConstructor == 'function') {
      nativeThen = nativePromiseConstructor.prototype.then; // wrap native Promise#then for native async functions

      redefine(nativePromiseConstructor.prototype, 'then', function then(onFulfilled, onRejected) {
        var that = this;
        return new PromiseConstructor(function (resolve, reject) {
          nativeThen.call(that, resolve, reject);
        }).then(onFulfilled, onRejected); // https://github.com/zloirock/core-js/issues/640
      }, {
        unsafe: true
      }); // wrap fetch result

      if (typeof $fetch == 'function') _export({
        global: true,
        enumerable: true,
        forced: true
      }, {
        // eslint-disable-next-line no-unused-vars
        fetch: function fetch(input
        /* , init */
        ) {
          return promiseResolve(PromiseConstructor, $fetch.apply(global_1, arguments));
        }
      });
    }
  }

  _export({
    global: true,
    wrap: true,
    forced: FORCED$1
  }, {
    Promise: PromiseConstructor
  });
  setToStringTag(PromiseConstructor, PROMISE, false);
  setSpecies(PROMISE);
  PromiseWrapper = getBuiltIn(PROMISE); // statics

  _export({
    target: PROMISE,
    stat: true,
    forced: FORCED$1
  }, {
    // `Promise.reject` method
    // https://tc39.github.io/ecma262/#sec-promise.reject
    reject: function reject(r) {
      var capability = newPromiseCapability$1(this);
      capability.reject.call(undefined, r);
      return capability.promise;
    }
  });
  _export({
    target: PROMISE,
    stat: true,
    forced:  FORCED$1
  }, {
    // `Promise.resolve` method
    // https://tc39.github.io/ecma262/#sec-promise.resolve
    resolve: function resolve(x) {
      return promiseResolve( this, x);
    }
  });
  _export({
    target: PROMISE,
    stat: true,
    forced: INCORRECT_ITERATION
  }, {
    // `Promise.all` method
    // https://tc39.github.io/ecma262/#sec-promise.all
    all: function all(iterable) {
      var C = this;
      var capability = newPromiseCapability$1(C);
      var resolve = capability.resolve;
      var reject = capability.reject;
      var result = perform(function () {
        var $promiseResolve = aFunction$1(C.resolve);
        var values = [];
        var counter = 0;
        var remaining = 1;
        iterate_1(iterable, function (promise) {
          var index = counter++;
          var alreadyCalled = false;
          values.push(undefined);
          remaining++;
          $promiseResolve.call(C, promise).then(function (value) {
            if (alreadyCalled) return;
            alreadyCalled = true;
            values[index] = value;
            --remaining || resolve(values);
          }, reject);
        });
        --remaining || resolve(values);
      });
      if (result.error) reject(result.value);
      return capability.promise;
    },
    // `Promise.race` method
    // https://tc39.github.io/ecma262/#sec-promise.race
    race: function race(iterable) {
      var C = this;
      var capability = newPromiseCapability$1(C);
      var reject = capability.reject;
      var result = perform(function () {
        var $promiseResolve = aFunction$1(C.resolve);
        iterate_1(iterable, function (promise) {
          $promiseResolve.call(C, promise).then(capability.resolve, reject);
        });
      });
      if (result.error) reject(result.value);
      return capability.promise;
    }
  });

  // https://github.com/tc39/proposal-promise-allSettled


  _export({
    target: 'Promise',
    stat: true
  }, {
    allSettled: function allSettled(iterable) {
      var C = this;
      var capability = newPromiseCapability.f(C);
      var resolve = capability.resolve;
      var reject = capability.reject;
      var result = perform(function () {
        var promiseResolve = aFunction$1(C.resolve);
        var values = [];
        var counter = 0;
        var remaining = 1;
        iterate_1(iterable, function (promise) {
          var index = counter++;
          var alreadyCalled = false;
          values.push(undefined);
          remaining++;
          promiseResolve.call(C, promise).then(function (value) {
            if (alreadyCalled) return;
            alreadyCalled = true;
            values[index] = {
              status: 'fulfilled',
              value: value
            };
            --remaining || resolve(values);
          }, function (e) {
            if (alreadyCalled) return;
            alreadyCalled = true;
            values[index] = {
              status: 'rejected',
              reason: e
            };
            --remaining || resolve(values);
          });
        });
        --remaining || resolve(values);
      });
      if (result.error) reject(result.value);
      return capability.promise;
    }
  });

  var NON_GENERIC = !!nativePromiseConstructor && fails(function () {
    nativePromiseConstructor.prototype['finally'].call({
      then: function then() {
        /* empty */
      }
    }, function () {
      /* empty */
    });
  }); // `Promise.prototype.finally` method
  // https://tc39.github.io/ecma262/#sec-promise.prototype.finally

  _export({
    target: 'Promise',
    proto: true,
    real: true,
    forced: NON_GENERIC
  }, {
    'finally': function _finally(onFinally) {
      var C = speciesConstructor(this, getBuiltIn('Promise'));
      var isFunction = typeof onFinally == 'function';
      return this.then(isFunction ? function (x) {
        return promiseResolve(C, onFinally()).then(function () {
          return x;
        });
      } : onFinally, isFunction ? function (e) {
        return promiseResolve(C, onFinally()).then(function () {
          throw e;
        });
      } : onFinally);
    }
  }); // patch native Promise.prototype for native async functions

  if ( typeof nativePromiseConstructor == 'function' && !nativePromiseConstructor.prototype['finally']) {
    redefine(nativePromiseConstructor.prototype, 'finally', getBuiltIn('Promise').prototype['finally']);
  }

  var promise$1 = path.Promise;

  /**
   *  Copyright 2018 Adobe. All rights reserved.
   *  This file is licensed to you under the Apache License, Version 2.0 (the "License");
   *  you may not use this file except in compliance with the License. You may obtain a copy
   *  of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   *  Unless required by applicable law or agreed to in writing, software distributed under
   *  the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   *  OF ANY KIND, either express or implied. See the License for the specific language
   *  governing permissions and limitations under the License.
   */
  // Provides explicit indication of elements receiving focus through keyboard interaction rather than mouse or touch.
  (function (doc) {
    // In case file is imported in SSR context, don't polyfill anything
    if (!doc) {
      return;
    }

    var NAVIGATION_KEYS = ['Tab', 'ArrowUp', 'ArrowRight', 'ArrowDown', 'ArrowLeft', 'Home', 'End', 'PageUp', 'PageDown', 'Enter', ' ', 'Escape',
    /* IE9 and Firefox < 37 */
    'Up', 'Right', 'Down', 'Left', 'Esc'];
    var TEXT_INPUT_TYPES = ['text', 'date', 'datetime-local', 'email', 'month', 'number', 'password', 'search', 'tel', 'time', 'url', 'week'];
    var keyboardFocus = false;
    var elements = doc.getElementsByClassName('focus-ring');

    function onKeydownHandler(event) {
      if (event.ctrlKey || event.altKey || event.metaKey || NAVIGATION_KEYS.indexOf(event.key) === -1) {
        return;
      }

      keyboardFocus = true;

      if (doc.activeElement && doc.activeElement !== doc.body && doc.activeElement.tagName !== 'TEXTAREA' && !(doc.activeElement.tagName === 'INPUT' && TEXT_INPUT_TYPES.indexOf(doc.activeElement.type) !== -1)) {
        doc.activeElement.classList.add('focus-ring');
      }
    }

    function onMousedownHandler() {
      keyboardFocus = false;

      for (var i = 0; i < elements.length; i++) {
        elements[i].classList.remove('focus-ring');
      }
    }

    function onFocusHandler(event) {
      var classList = event.target.classList;

      if (classList && keyboardFocus) {
        classList.add('focus-ring');
      }
    }

    function onBlurHandler(event) {
      var classList = event.target.classList;
      classList && classList.remove('focus-ring');
    }

    doc.addEventListener('keydown', onKeydownHandler, true);
    doc.addEventListener('mousedown', onMousedownHandler, true);
    doc.addEventListener('focus', onFocusHandler, true);
    doc.addEventListener('blur', onBlurHandler, true);
  })(typeof window === "undefined" ? undefined : document);

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  // todo We force the polyfill but ideally we should not load it if not required
  if (window.customElements) {
    window.customElements.forcePolyfill = true;
  }

  (function () {
    var g = new function () {}();
    var aa = new Set("annotation-xml color-profile font-face font-face-src font-face-uri font-face-format font-face-name missing-glyph".split(" "));

    function k(b) {
      var a = aa.has(b);
      b = /^[a-z][.0-9_a-z]*-[\-.0-9_a-z]*$/.test(b);
      return !a && b;
    }

    function l(b) {
      var a = b.isConnected;
      if (void 0 !== a) return a;

      for (; b && !(b.__CE_isImportDocument || b instanceof Document);) {
        b = b.parentNode || (window.ShadowRoot && b instanceof ShadowRoot ? b.host : void 0);
      }

      return !(!b || !(b.__CE_isImportDocument || b instanceof Document));
    }

    function m(b, a) {
      for (; a && a !== b && !a.nextSibling;) {
        a = a.parentNode;
      }

      return a && a !== b ? a.nextSibling : null;
    }

    function n(b, a, d) {
      d = d ? d : new Set();

      for (var c = b; c;) {
        if (c.nodeType === Node.ELEMENT_NODE) {
          var e = c;
          a(e);
          var h = e.localName;

          if ("link" === h && "import" === e.getAttribute("rel")) {
            c = e.import;
            if (c instanceof Node && !d.has(c)) for (d.add(c), c = c.firstChild; c; c = c.nextSibling) {
              n(c, a, d);
            }
            c = m(b, e);
            continue;
          } else if ("template" === h) {
            c = m(b, e);
            continue;
          }

          if (e = e.__CE_shadowRoot) for (e = e.firstChild; e; e = e.nextSibling) {
            n(e, a, d);
          }
        }

        c = c.firstChild ? c.firstChild : m(b, c);
      }
    }

    function p(b, a, d) {
      b[a] = d;
    }

    function q() {
      this.a = new Map();
      this.f = new Map();
      this.m = [];
      this.b = !1;
    }

    function ba(b, a, d) {
      b.a.set(a, d);
      b.f.set(d.constructor, d);
    }

    function r(b, a) {
      b.b = !0;
      b.m.push(a);
    }

    function v(b, a) {
      b.b && n(a, function (a) {
        return w(b, a);
      });
    }

    function w(b, a) {
      if (b.b && !a.__CE_patched) {
        a.__CE_patched = !0;

        for (var d = 0; d < b.m.length; d++) {
          b.m[d](a);
        }
      }
    }

    function x(b, a) {
      var d = [];
      n(a, function (b) {
        return d.push(b);
      });

      for (a = 0; a < d.length; a++) {
        var c = d[a];
        1 === c.__CE_state ? b.connectedCallback(c) : y(b, c);
      }
    }

    function z(b, a) {
      var d = [];
      n(a, function (b) {
        return d.push(b);
      });

      for (a = 0; a < d.length; a++) {
        var c = d[a];
        1 === c.__CE_state && b.disconnectedCallback(c);
      }
    }

    function A(b, a, d) {
      d = d ? d : new Set();
      var c = [];
      n(a, function (e) {
        var a;
        if ("link" === e.localName && "import" === e.getAttribute("rel")) a = e.import, a instanceof Node && "complete" === a.readyState ? (a.__CE_isImportDocument = !0, a.__CE_hasRegistry = !0) : e.addEventListener("load", function () {
          var a = e.import;
          a.__CE_documentLoadHandled || (a.__CE_documentLoadHandled = !0, a.__CE_isImportDocument = !0, a.__CE_hasRegistry = !0, d.delete(a), A(b, a, d));
        });else {
          if (a = e.getAttribute("is")) e.__CE_is = a;
          c.push(e);
        }
      }, d);
      if (b.b) for (a = 0; a < c.length; a++) {
        w(b, c[a]);
      }

      for (a = 0; a < c.length; a++) {
        y(b, c[a]);
      }
    }

    function y(b, a) {
      if (void 0 === a.__CE_state) {
        var d = b.a.get(a.__CE_is || a.localName);

        if (d = d && d.localName === a.localName ? d : null) {
          d.constructionStack.push(a);
          var c = d.constructor;

          try {
            try {
              if (new c() !== a) throw Error("The custom element constructor did not produce the element being upgraded.");
            } finally {
              d.constructionStack.pop();
            }
          } catch (f) {
            throw a.__CE_state = 2, f;
          }

          a.__CE_state = 1;
          a.__CE_definition = d;
          if (d.attributeChangedCallback) for (d = d.observedAttributes, c = 0; c < d.length; c++) {
            var e = d[c],
                h = a.getAttribute(e);
            null !== h && b.attributeChangedCallback(a, e, null, h, null);
          }
          l(a) && b.connectedCallback(a);
        }
      }
    }

    q.prototype.connectedCallback = function (b) {
      var a = b.__CE_definition;
      a.connectedCallback && a.connectedCallback.call(b);
    };

    q.prototype.disconnectedCallback = function (b) {
      var a = b.__CE_definition;
      a.disconnectedCallback && a.disconnectedCallback.call(b);
    };

    q.prototype.attributeChangedCallback = function (b, a, d, c, e) {
      var h = b.__CE_definition;
      h.attributeChangedCallback && -1 < h.observedAttributes.indexOf(a) && h.attributeChangedCallback.call(b, a, d, c, e);
    };

    function B(b, a) {
      this.c = b;
      this.a = a;
      this.b = void 0;
      A(this.c, this.a);
      "loading" === this.a.readyState && (this.b = new MutationObserver(this.f.bind(this)), this.b.observe(this.a, {
        childList: !0,
        subtree: !0
      }));
    }

    function C(b) {
      b.b && b.b.disconnect();
    }

    B.prototype.f = function (b) {
      var a = this.a.readyState;
      "interactive" !== a && "complete" !== a || C(this);

      for (a = 0; a < b.length; a++) {
        for (var d = b[a].addedNodes, c = 0; c < d.length; c++) {
          A(this.c, d[c]);
        }
      }
    };

    function ca() {
      var b = this;
      this.b = this.a = void 0;
      this.f = new Promise(function (a) {
        b.b = a;
        b.a && a(b.a);
      });
    }

    function D(b) {
      if (b.a) throw Error("Already resolved.");
      b.a = void 0;
      b.b && b.b(void 0);
    }

    function E(b) {
      this.i = !1;
      this.c = b;
      this.l = new Map();

      this.j = function (b) {
        return b();
      };

      this.g = !1;
      this.h = [];
      this.s = new B(b, document);
    }

    E.prototype.define = function (b, a, d) {
      var c = this;
      if (!(a instanceof Function)) throw new TypeError("Custom element constructors must be functions.");
      if (!k(b)) throw new SyntaxError("The element name '" + b + "' is not valid.");
      if (this.c.a.get(b)) throw Error("A custom element with name '" + b + "' has already been defined.");
      var e = b;

      if (d && d.extends) {
        if (!this.enableCustomizedBuiltins) throw Error("Customized builtin elements are disabled by default. Set customElements.enableCustomizedBuiltins = true.");
        if (k(d.extends)) throw Error("A customized builtin element may not extend a custom element.");
        if (document.createElement(d.extends) instanceof window.HTMLUnknownElement) throw Error("Cannot extend '" + d.extends + "': is not a real HTML element");
        e = d.extends;
      }

      if (this.i) throw Error("A custom element is already being defined.");
      this.i = !0;
      var h, f, u, t, P;

      try {
        d = function d(b) {
          var a = Q[b];
          if (void 0 !== a && !(a instanceof Function)) throw Error("The '" + b + "' callback must be a function.");
          return a;
        };

        var Q = a.prototype;
        if (!(Q instanceof Object)) throw new TypeError("The custom element constructor's prototype is not an object.");
        h = d("connectedCallback");
        f = d("disconnectedCallback");
        u = d("adoptedCallback");
        t = d("attributeChangedCallback");
        P = a.observedAttributes || [];
      } catch (xa) {
        return;
      } finally {
        this.i = !1;
      }

      ba(this.c, b, {
        name: b,
        localName: e,
        constructor: a,
        connectedCallback: h,
        disconnectedCallback: f,
        adoptedCallback: u,
        attributeChangedCallback: t,
        observedAttributes: P,
        constructionStack: []
      });
      this.h.push(b);
      this.g || (this.g = !0, this.j(function () {
        if (!1 !== c.g) for (c.g = !1, A(c.c, document); 0 < c.h.length;) {
          var b = c.h.shift();
          (b = c.l.get(b)) && D(b);
        }
      }));
    };

    E.prototype.get = function (b) {
      if (b = this.c.a.get(b)) return b.constructor;
    };

    E.prototype.upgradeElement = function (b) {
      y(this.c, b);
    };

    E.prototype.whenDefined = function (b) {
      if (!k(b)) return Promise.reject(new SyntaxError("'" + b + "' is not a valid custom element name."));
      var a = this.l.get(b);
      if (a) return a.f;
      a = new ca();
      this.l.set(b, a);
      this.c.a.get(b) && -1 === this.h.indexOf(b) && D(a);
      return a.f;
    };

    E.prototype.u = function (b) {
      C(this.s);
      var a = this.j;

      this.j = function (d) {
        return b(function () {
          return a(d);
        });
      };
    };

    window.CustomElementRegistry = E;
    E.prototype.define = E.prototype.define;
    E.prototype.get = E.prototype.get;
    E.prototype.whenDefined = E.prototype.whenDefined;
    E.prototype.upgrade = E.prototype.upgradeElement;
    E.prototype.polyfillWrapFlushCallback = E.prototype.u;
    var F = window.Document.prototype.createElement,
        da = window.Document.prototype.createElementNS,
        ea = window.Document.prototype.importNode,
        fa = window.Document.prototype.prepend,
        ga = window.Document.prototype.append,
        G = window.Node.prototype.cloneNode,
        H = window.Node.prototype.appendChild,
        I = window.Node.prototype.insertBefore,
        J = window.Node.prototype.removeChild,
        K = window.Node.prototype.replaceChild,
        L = Object.getOwnPropertyDescriptor(window.Node.prototype, "textContent"),
        M = window.Element.prototype.attachShadow,
        N = Object.getOwnPropertyDescriptor(window.Element.prototype, "innerHTML"),
        O = window.Element.prototype.getAttribute,
        R = window.Element.prototype.setAttribute,
        S = window.Element.prototype.removeAttribute,
        T = window.Element.prototype.getAttributeNS,
        U = window.Element.prototype.setAttributeNS,
        V = window.Element.prototype.removeAttributeNS,
        W = window.Element.prototype.insertAdjacentElement,
        ha = window.Element.prototype.prepend,
        ia = window.Element.prototype.append,
        ja = window.Element.prototype.before,
        ka = window.Element.prototype.after,
        la = window.Element.prototype.replaceWith,
        ma = window.Element.prototype.remove,
        na = window.HTMLElement,
        X = Object.getOwnPropertyDescriptor(window.HTMLElement.prototype, "innerHTML"),
        oa = window.HTMLElement.prototype.insertAdjacentElement,
        pa = {
      Button: window.HTMLButtonElement,
      Canvas: window.HTMLCanvasElement,
      Data: window.HTMLDataElement,
      Head: window.HTMLHeadElement,
      Mod: window.HTMLModElement,
      TableCell: window.HTMLTableCellElement,
      TableCol: window.HTMLTableColElement,
      Anchor: window.HTMLAnchorElement,
      Area: window.HTMLAreaElement,
      Base: window.HTMLBaseElement,
      Body: window.HTMLBodyElement,
      BR: window.HTMLBRElement,
      DataList: window.HTMLDataListElement,
      Details: window.HTMLDetailsElement,
      Dialog: window.HTMLDialogElement,
      Div: window.HTMLDivElement,
      DList: window.HTMLDListElement,
      Embed: window.HTMLEmbedElement,
      FieldSet: window.HTMLFieldSetElement,
      Form: window.HTMLFormElement,
      Heading: window.HTMLHeadingElement,
      HR: window.HTMLHRElement,
      Html: window.HTMLHtmlElement,
      IFrame: window.HTMLIFrameElement,
      Image: window.HTMLImageElement,
      Input: window.HTMLInputElement,
      Keygen: window.HTMLKeygenElement,
      Label: window.HTMLLabelElement,
      Legend: window.HTMLLegendElement,
      LI: window.HTMLLIElement,
      Link: window.HTMLLinkElement,
      Map: window.HTMLMapElement,
      Media: window.HTMLMediaElement,
      Menu: window.HTMLMenuElement,
      MenuItem: window.HTMLMenuItemElement,
      Meta: window.HTMLMetaElement,
      Meter: window.HTMLMeterElement,
      Object: window.HTMLObjectElement,
      OList: window.HTMLOListElement,
      OptGroup: window.HTMLOptGroupElement,
      Option: window.HTMLOptionElement,
      Output: window.HTMLOutputElement,
      Paragraph: window.HTMLParagraphElement,
      Param: window.HTMLParamElement,
      Picture: window.HTMLPictureElement,
      Pre: window.HTMLPreElement,
      Progress: window.HTMLProgressElement,
      Quote: window.HTMLQuoteElement,
      Script: window.HTMLScriptElement,
      Select: window.HTMLSelectElement,
      Slot: window.HTMLSlotElement,
      Source: window.HTMLSourceElement,
      Span: window.HTMLSpanElement,
      Style: window.HTMLStyleElement,
      TableCaption: window.HTMLTableCaptionElement,
      Table: window.HTMLTableElement,
      TableRow: window.HTMLTableRowElement,
      TableSection: window.HTMLTableSectionElement,
      Template: window.HTMLTemplateElement,
      TextArea: window.HTMLTextAreaElement,
      Time: window.HTMLTimeElement,
      Title: window.HTMLTitleElement,
      Track: window.HTMLTrackElement,
      UList: window.HTMLUListElement,
      Unknown: window.HTMLUnknownElement
    };

    function qa() {
      var b = Y;

      window.HTMLElement = function () {
        function a() {
          var a = this.constructor,
              c = b.f.get(a);
          if (!c) throw Error("The custom element being constructed was not registered with `customElements`.");
          var e = c.constructionStack;
          if (!e.length) return e = F.call(document, c.localName), Object.setPrototypeOf(e, a.prototype), e.__CE_state = 1, e.__CE_definition = c, w(b, e), e;
          var c = e.length - 1,
              h = e[c];
          if (h === g) throw Error("The HTMLElement constructor was either called reentrantly for this constructor or called multiple times.");
          e[c] = g;
          Object.setPrototypeOf(h, a.prototype);
          w(b, h);
          return h;
        }

        a.prototype = na.prototype;
        return a;
      }();
    }

    function ra() {
      var b = Y;

      function a(a, e) {
        e && (window[a] = function () {
          function d() {
            var e = this.constructor,
                d = b.f.get(e);
            if (!d) throw Error("The custom element being constructed was not registered with `customElements`.");
            var c = d.constructionStack;
            if (!c.length) return c = F.call(document, d.localName), c.setAttribute("is", d.name), Object.setPrototypeOf(c, e.prototype), c.__CE_state = 1, c.__CE_definition = d, w(b, c), c;
            var d = c.length - 1,
                h = c[d];
            if (h === g) throw Error("The " + a + " constructor was either called reentrantly for this constructor or called multiple times.");
            c[d] = g;
            Object.setPrototypeOf(h, e.prototype);
            w(b, h);
            return h;
          }

          d.prototype = e.prototype;
          return d;
        }());
      }

      for (var d in pa) {
        a("HTML" + d + "Element", pa[d]);
      }
    }

    function sa(b, a, d) {
      a.prepend = function (a) {
        for (var e = [], c = 0; c < arguments.length; ++c) {
          e[c - 0] = arguments[c];
        }

        c = e.filter(function (b) {
          return b instanceof Node && l(b);
        });
        d.o.apply(this, e);

        for (var f = 0; f < c.length; f++) {
          z(b, c[f]);
        }

        if (l(this)) for (c = 0; c < e.length; c++) {
          f = e[c], f instanceof Element && x(b, f);
        }
      };

      a.append = function (a) {
        for (var e = [], c = 0; c < arguments.length; ++c) {
          e[c - 0] = arguments[c];
        }

        c = e.filter(function (b) {
          return b instanceof Node && l(b);
        });
        d.append.apply(this, e);

        for (var f = 0; f < c.length; f++) {
          z(b, c[f]);
        }

        if (l(this)) for (c = 0; c < e.length; c++) {
          f = e[c], f instanceof Element && x(b, f);
        }
      };
    }

    function ta() {
      var b = Y;
      p(Document.prototype, "createElement", function (a, d) {
        if (this.__CE_hasRegistry) {
          var c = b.a.get(d && d.is ? d.is : a);
          if (c) return new c.constructor();
        }

        a = F.call(this, a);
        d && d.is && (a.__CE_is = d.is, a.setAttribute("is", d.is));
        w(b, a);
        return a;
      });
      p(Document.prototype, "importNode", function (a, d) {
        a = ea.call(this, a, d);
        this.__CE_hasRegistry ? A(b, a) : v(b, a);
        return a;
      });
      p(Document.prototype, "createElementNS", function (a, d, c) {
        if (this.__CE_hasRegistry && (null === a || "http://www.w3.org/1999/xhtml" === a)) {
          var e = b.a.get(c && c.is ? c.is : d);
          if (e) return new e.constructor();
        }

        a = da.call(this, a, d);
        c && c.is && (a.__CE_is = c.is, a.setAttribute("is", c.is));
        w(b, a);
        return a;
      });
      sa(b, Document.prototype, {
        o: fa,
        append: ga
      });
    }

    function ua() {
      var b = Y;

      function a(a, c) {
        Object.defineProperty(a, "textContent", {
          enumerable: c.enumerable,
          configurable: !0,
          get: c.get,
          set: function set(a) {
            if (this.nodeType === Node.TEXT_NODE) c.set.call(this, a);else {
              var e = void 0;

              if (this.firstChild) {
                var d = this.childNodes,
                    u = d.length;
                if (0 < u && l(this)) for (var e = Array(u), t = 0; t < u; t++) {
                  e[t] = d[t];
                }
              }

              c.set.call(this, a);
              if (e) for (a = 0; a < e.length; a++) {
                z(b, e[a]);
              }
            }
          }
        });
      }

      p(Node.prototype, "insertBefore", function (a, c) {
        if (a instanceof DocumentFragment) {
          var e = Array.prototype.slice.apply(a.childNodes);
          a = I.call(this, a, c);
          if (l(this)) for (c = 0; c < e.length; c++) {
            x(b, e[c]);
          }
          return a;
        }

        e = l(a);
        c = I.call(this, a, c);
        e && z(b, a);
        l(this) && x(b, a);
        return c;
      });
      p(Node.prototype, "appendChild", function (a) {
        if (a instanceof DocumentFragment) {
          var c = Array.prototype.slice.apply(a.childNodes);
          a = H.call(this, a);
          if (l(this)) for (var e = 0; e < c.length; e++) {
            x(b, c[e]);
          }
          return a;
        }

        c = l(a);
        e = H.call(this, a);
        c && z(b, a);
        l(this) && x(b, a);
        return e;
      });
      p(Node.prototype, "cloneNode", function (a) {
        a = G.call(this, a);
        this.ownerDocument.__CE_hasRegistry ? A(b, a) : v(b, a);
        return a;
      });
      p(Node.prototype, "removeChild", function (a) {
        var c = l(a),
            e = J.call(this, a);
        c && z(b, a);
        return e;
      });
      p(Node.prototype, "replaceChild", function (a, c) {
        if (a instanceof DocumentFragment) {
          var e = Array.prototype.slice.apply(a.childNodes);
          a = K.call(this, a, c);
          if (l(this)) for (z(b, c), c = 0; c < e.length; c++) {
            x(b, e[c]);
          }
          return a;
        }

        var e = l(a),
            d = K.call(this, a, c),
            f = l(this);
        f && z(b, c);
        e && z(b, a);
        f && x(b, a);
        return d;
      });
      L && L.get ? a(Node.prototype, L) : r(b, function (b) {
        a(b, {
          enumerable: !0,
          configurable: !0,
          get: function get() {
            for (var a = [], b = 0; b < this.childNodes.length; b++) {
              a.push(this.childNodes[b].textContent);
            }

            return a.join("");
          },
          set: function set(a) {
            for (; this.firstChild;) {
              J.call(this, this.firstChild);
            }

            H.call(this, document.createTextNode(a));
          }
        });
      });
    }

    function va(b) {
      var a = Element.prototype;

      a.before = function (a) {
        for (var c = [], e = 0; e < arguments.length; ++e) {
          c[e - 0] = arguments[e];
        }

        e = c.filter(function (a) {
          return a instanceof Node && l(a);
        });
        ja.apply(this, c);

        for (var d = 0; d < e.length; d++) {
          z(b, e[d]);
        }

        if (l(this)) for (e = 0; e < c.length; e++) {
          d = c[e], d instanceof Element && x(b, d);
        }
      };

      a.after = function (a) {
        for (var c = [], e = 0; e < arguments.length; ++e) {
          c[e - 0] = arguments[e];
        }

        e = c.filter(function (a) {
          return a instanceof Node && l(a);
        });
        ka.apply(this, c);

        for (var d = 0; d < e.length; d++) {
          z(b, e[d]);
        }

        if (l(this)) for (e = 0; e < c.length; e++) {
          d = c[e], d instanceof Element && x(b, d);
        }
      };

      a.replaceWith = function (a) {
        for (var c = [], e = 0; e < arguments.length; ++e) {
          c[e - 0] = arguments[e];
        }

        var e = c.filter(function (a) {
          return a instanceof Node && l(a);
        }),
            d = l(this);
        la.apply(this, c);

        for (var f = 0; f < e.length; f++) {
          z(b, e[f]);
        }

        if (d) for (z(b, this), e = 0; e < c.length; e++) {
          d = c[e], d instanceof Element && x(b, d);
        }
      };

      a.remove = function () {
        var a = l(this);
        ma.call(this);
        a && z(b, this);
      };
    }

    function wa() {
      var b = Y;

      function a(a, c) {
        Object.defineProperty(a, "innerHTML", {
          enumerable: c.enumerable,
          configurable: !0,
          get: c.get,
          set: function set(a) {
            var e = this,
                d = void 0;
            l(this) && (d = [], n(this, function (a) {
              a !== e && d.push(a);
            }));
            c.set.call(this, a);
            if (d) for (var h = 0; h < d.length; h++) {
              var f = d[h];
              1 === f.__CE_state && b.disconnectedCallback(f);
            }
            this.ownerDocument.__CE_hasRegistry ? A(b, this) : v(b, this);
            return a;
          }
        });
      }

      function d(a, c) {
        p(a, "insertAdjacentElement", function (a, e) {
          var d = l(e);
          a = c.call(this, a, e);
          d && z(b, e);
          l(a) && x(b, e);
          return a;
        });
      }

      M ? p(Element.prototype, "attachShadow", function (a) {
        return this.__CE_shadowRoot = a = M.call(this, a);
      }) : console.warn("Custom Elements: `Element#attachShadow` was not patched.");
      if (N && N.get) a(Element.prototype, N);else if (X && X.get) a(HTMLElement.prototype, X);else {
        var c = F.call(document, "div");
        r(b, function (b) {
          a(b, {
            enumerable: !0,
            configurable: !0,
            get: function get() {
              return G.call(this, !0).innerHTML;
            },
            set: function set(a) {
              var b = "template" === this.localName ? this.content : this;

              for (c.innerHTML = a; 0 < b.childNodes.length;) {
                J.call(b, b.childNodes[0]);
              }

              for (; 0 < c.childNodes.length;) {
                H.call(b, c.childNodes[0]);
              }
            }
          });
        });
      }
      p(Element.prototype, "setAttribute", function (a, c) {
        if (1 !== this.__CE_state) return R.call(this, a, c);
        var e = O.call(this, a);
        R.call(this, a, c);
        c = O.call(this, a);
        b.attributeChangedCallback(this, a.toLowerCase(), e, c, null);
      });
      p(Element.prototype, "setAttributeNS", function (a, c, d) {
        if (1 !== this.__CE_state) return U.call(this, a, c, d);
        var e = T.call(this, a, c);
        U.call(this, a, c, d);
        d = T.call(this, a, c);
        b.attributeChangedCallback(this, c, e, d, a);
      });
      p(Element.prototype, "removeAttribute", function (a) {
        if (1 !== this.__CE_state) return S.call(this, a);
        var c = O.call(this, a);
        S.call(this, a);
        null !== c && b.attributeChangedCallback(this, a.toLowerCase(), c, null, null);
      });
      p(Element.prototype, "removeAttributeNS", function (a, c) {
        if (1 !== this.__CE_state) return V.call(this, a, c);
        var d = T.call(this, a, c);
        V.call(this, a, c);
        var e = T.call(this, a, c);
        d !== e && b.attributeChangedCallback(this, c, d, e, a);
      });
      oa ? d(HTMLElement.prototype, oa) : W ? d(Element.prototype, W) : console.warn("Custom Elements: `Element#insertAdjacentElement` was not patched.");
      sa(b, Element.prototype, {
        o: ha,
        append: ia
      });
      va(b);
    }
    /*
    Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
    This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
    The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
    The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
    Code distributed by Google as part of the polymer project is also
    subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
    */

    var Z = window.customElements;

    if (!Z || Z.forcePolyfill || "function" != typeof Z.define || "function" != typeof Z.get) {
      var Y = new q();
      qa();
      ra();
      ta();
      ua();
      wa();
      document.__CE_hasRegistry = !0;
      var customElements = new E(Y);
      customElements.enableCustomizedBuiltins = true;
      Object.defineProperty(window, "customElements", {
        configurable: !0,
        enumerable: !0,
        value: customElements
      });
    }
  }).call(self);

  var vent = createCommonjsModule(function (module, exports) {
    /*
    Copyright 2018 Adobe. All rights reserved.
    This file is licensed to you under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License. You may obtain a copy
    of the License at http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software distributed under
    the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
    OF ANY KIND, either express or implied. See the License for the specific language
    governing permissions and limitations under the License.
    */
    (function (root, factory) {
      {
        // CommonJS
        module.exports = factory();
      }
    })(commonjsGlobal, function () {
      // The next ID we'll use for scoped delegation
      var lastID = 0;
      /*
        Matches selectors that are scoped, such as:
         Â > selector
         Â :scope > selector
      */

      var scopedSelectorRegex = /^\s*(>|:scope\s*>)/;
      /**
        Check if the first array contains every element in the second array
         @ignore
      */

      function contains(set, subSet) {
        for (var i = 0; i < subSet.length; i++) {
          if (set.indexOf(subSet[i]) === -1) {
            return false;
          }
        }

        return true;
      }
      /**
        Check if the provided selector is scoped (has context)
         @ignore
      */


      function isScoped(selector) {
        return selector && scopedSelectorRegex.test(selector);
      }
      /**
        Replaces the stopPropagation() method of an event object
         @ignore
      */


      function ventStopPropagation() {
        this._ventPropagationStopped = true;
        Event.prototype.stopPropagation.call(this);
      }
      /**
        Replaces the stopImmediatePropagation() method of an event object
         @ignore
      */


      function ventStopImmediatePropagation() {
        this._ventImmediatePropagationStopped = true;
        Event.prototype.stopImmediatePropagation.call(this);
      }
      /**
        Get the right method to match selectors on
         @ignore
      */


      var matchesSelector = function () {
        var proto = Element.prototype;
        var matchesSelector = proto.matches || proto.matchesSelector || proto.webkitMatchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector || proto.oMatchesSelector;

        if (!matchesSelector) {
          throw new Error('Vent: Browser does not support matchesSelector');
        }

        return matchesSelector;
      }();
      /**
        @class Vent
        @classdesc DOM event delegation
         @param {HTMLElement|String} elementOrSelector
          The element or selector indicating the element to use as the delegation root.
      */


      function Vent(elementOrSelector) {
        if (this === root) {
          throw new Error('Vent must be invoked with the new keyword');
        }

        var root;

        if (typeof elementOrSelector === 'string') {
          root = document.querySelector(elementOrSelector);
        } else {
          root = elementOrSelector;
        } // Store a reference to the root element
        // This is the node at which we'll listen to events


        this.root = root; // Map of event names to array of events
        // Don't inherit from Object so we don't collide with properties on its prototype

        this._listenersByType = Object.create(null);
        /*
          A list of all of the listener objects tracked by this instance
          Each item takes the following form:
          {
            eventName: String,
            handler: Function,
            namespaces: Array<string>,
            selector: String | null,
            useCapture: Boolean,
            isScoped: Boolean
          }
        */

        this._allListeners = []; // Ensure listeners always execute in the scope of this instance

        this._executeCaptureListeners = this._executeCaptureListeners.bind(this);
        this._executeBubbleListeners = this._executeBubbleListeners.bind(this); // All Vent instances get an ID

        this._id = this._id || lastID++;
      }
      /**
        Check if the listener should fire on the given rooted target
         @ignore
      */


      Vent.prototype._listenerMatchesRootTarget = function (listener, target) {
        return (// When no selector is provided
          listener.selector === null && // Execute if we've landed on the root
          target === this.root
        );
      };
      /**
        Check if the listener should fire on the given delegated target
         @ignore
      */


      Vent.prototype._listenerMatchesDelegateTarget = function (listener, target) {
        return (// document does not support matches()
          target !== document && // Don't bother with delegation on the root element
          target !== this.root && // Check if the event is delegated
          listener.selector !== null && ( // Only execute  if the selector matches
          // Check if the selector has context
          listener.isScoped ? // Run the match using the root element's ID
          matchesSelector.call(target, '[__vent-id__="' + this._id + '"] ' + listener.selector) // Run the match without context
          : matchesSelector.call(target, listener.selector))
        );
      };
      /**
        Check if the listener matches the given event phase
         @ignore
      */


      Vent.prototype._listenerMatchesEventPhase = function (listener, useCapture) {
        // Check if the event is the in right phase
        return listener.useCapture === useCapture;
      };
      /**
        This function is responsible for checking if listeners should be executed for the current event
         @ignore
      */


      Vent.prototype._executeListenersAtElement = function (target, listeners, event, useCapture) {
        var listener;
        var returnValue; // Execute each listener that meets the criteria

        executeListeners: for (var listenerIndex = 0; listenerIndex < listeners.length; listenerIndex++) {
          listener = listeners[listenerIndex];

          if ( // Do not process events on disabled items #1
          !(event.type === 'click' && target.disabled === true) && ( // Check if the target element matches for this listener
          this._listenerMatchesRootTarget(listener, target) || this._listenerMatchesDelegateTarget(listener, target)) && this._listenerMatchesEventPhase(listener, useCapture)) {
            // Store the target that matches the event currently
            event.matchedTarget = target; // Call handlers in the scope of the delegate target, passing the event along

            returnValue = listener.handler.call(target, event); // Prevent default and stopPropagation if the handler returned false

            if (returnValue === false) {
              event.preventDefault();
              event.stopPropagation();
            }

            if (event._ventImmediatePropagationStopped) {
              // Do not process any more event handlers and stop bubbling
              break executeListeners;
            }
          } // end if

        } // end executeListeners

      };
      /**
        Handles all events added with Vent
         @private
        @memberof Vent
      */


      Vent.prototype._executeCaptureListeners = function (event) {
        var listeners = this._listenersByType[event.type];

        if (!listeners) {
          throw new Error('Vent: _executeListeners called in response to ' + event.type + ', but we are not listening to it');
        }

        if (listeners.length) {
          // Get a copy of the listeners
          // Without this, removing an event inside of a callback will cause errors
          listeners = listeners.slice(); // Decorate the event object so we know when stopPropagation is called

          this._decorateEvent(event); // Get the event's path through the DOM


          var eventPath = this._getPath(event); // Simulate the capture phase by trickling down the target list


          trickleDown: for (var eventPathIndex = eventPath.length - 1; eventPathIndex >= 0; eventPathIndex--) {
            if (!listeners.length) {
              // Stop trickling down if there are no more listeners to execute
              break trickleDown;
            }

            var currentTargetElement = eventPath[eventPathIndex];

            this._executeListenersAtElement(currentTargetElement, listeners, event, true); // Stop if a handler told us to stop trickling down the DOM


            if (event._ventImmediatePropagationStopped || event._ventPropagationStopped) {
              // Stop simulating trickle down
              break trickleDown;
            }
          }
        } // Clean up after Vent
        // We'll be re-decorating the event object in the bubble phase, if the event gets there


        this._undecorateEvent(event);
      };
      /**
        Handles all events added with Vent
         @private
        @memberof Vent
      */


      Vent.prototype._executeBubbleListeners = function (event) {
        var listeners = this._listenersByType[event.type];

        if (!listeners) {
          throw new Error('Vent: _executeListeners called in response to ' + event.type + ', but we are not listening to it');
        }

        if (listeners.length) {
          // Get a copy of the listeners
          // Without this, removing an event inside of a callback will cause errors
          listeners = listeners.slice(); // Decorate the event object so we know when stopPropagation is called

          this._decorateEvent(event);
          /*
            Figure out if the bubble phase should be simulated
             Both focus and blur do not bubble:
              https://developer.mozilla.org/en-US/docs/Web/Events/focus
              https://developer.mozilla.org/en-US/docs/Web/Events/blur
             However, focusin, focusout, change, and other events do.
          */


          var shouldBubble = event.type !== 'focus' && event.type !== 'blur'; // Re-use the event path as calculated during the capture phase

          var eventPath = this._getPath(event); // If listeners remain and propagation was not stopped, simulate the bubble phase by bubbling up the target list


          bubbleUp: for (var eventPathIndex = 0; eventPathIndex < eventPath.length; eventPathIndex++) {
            if (!listeners.length) {
              // Stop bubbling up if there are no more listeners to execute
              break bubbleUp;
            }

            var currentTargetElement = eventPath[eventPathIndex];

            this._executeListenersAtElement(currentTargetElement, listeners, event, false); // Stop simulating the bubble phase if a handler told us to


            if (event._ventImmediatePropagationStopped || event._ventPropagationStopped) {
              break bubbleUp;
            } // If the event shouldn't bubble, only simulate it on the target


            if (!shouldBubble) {
              break bubbleUp;
            }
          }
        } // Clean up after Vent


        this._undecorateEvent(event); // Clear the path


        event['_ventPath' + this._id] = null;
      };
      /**
        Override stopPropagation/stopImmediatePropagation so we know if we should stop processing events
      */


      Vent.prototype._decorateEvent = function (event) {
        event.stopPropagation = ventStopPropagation;
        event.stopImmediatePropagation = ventStopImmediatePropagation;
      };
      /**
        Restore the normal stopPropagation methods
      */


      Vent.prototype._undecorateEvent = function (event) {
        event.stopPropagation = Event.prototype.stopPropagation;
        event.stopImmediatePropagation = Event.prototype.stopImmediatePropagation;
      };
      /**
        Restore the normal stopPropagation methods
      */


      Vent.prototype._getPath = function (event) {
        if (event['_ventPath' + this._id]) {
          return event['_ventPath' + this._id];
        } // If the event was fired on a text node, delegation should assume the target is its parent


        var target = event.target;

        if (target.nodeType === Node.TEXT_NODE) {
          target = target.parentNode;
        } // Build an array of the DOM tree between the root and the element that dispatched the event
        // The HTML specification states that, if the tree is modified during dispatch, the event should bubble as it was before
        // Building this list before we dispatch allows us to simulate that behavior


        var pathEl = target;
        var eventPath = [];

         while (pathEl && pathEl !== this.root) {
          eventPath.push(pathEl);
          pathEl = pathEl.parentNode;
        }

        eventPath.push(this.root);
        event['_ventPath' + this._id] = eventPath;
        return eventPath;
      };
      /**
        Add an event listener.
        @memberof Vent
         @param {String} eventName
          The event name to listen for, including optional namespace(s).
        @param {String} [selector]
          The selector to use for event delegation.
        @param {Function} handler
          The function that will be called when the event is fired.
        @param {Boolean} [useCapture]
          Whether or not to listen during the capturing or bubbling phase.
         @returns {Vent} this, chainable.
      */


      Vent.prototype.on = function (eventName, selector, handler, useCapture) {
        if (typeof selector === 'function') {
          useCapture = handler;
          handler = selector;
          selector = null;
        }

        if (typeof handler !== 'function') {
          throw new Error('Vent: Cannot add listener with non-function handler');
        } // Be null if every falsy (undefined or empty string passed)


        if (!selector) {
          selector = null;
        }

        if (typeof useCapture === 'undefined') {
          // Force useCapture for focus and blur events
          if (eventName === 'focus' || eventName === 'blur') {
            // true by default for focus and blur events only
            useCapture = true;
          } else {
            // false by default
            // This matches the HTML API
            useCapture = false;
          }
        } // Extract namespaces


        var namespaces = null;
        var dotIndex = eventName.indexOf('.');

        if (dotIndex !== -1) {
          namespaces = eventName.slice(dotIndex + 1).split('.');
          eventName = eventName.slice(0, dotIndex);
        } // Get/create the list for the event type


        var listenerList = this._listenersByType[eventName];

        if (!listenerList) {
          listenerList = this._listenersByType[eventName] = []; // Add the actual listener

          this.root.addEventListener(eventName, this._executeCaptureListeners, true);
          this.root.addEventListener(eventName, this._executeBubbleListeners, false);
        } // Set the special ID attribute if the selector is scoped


        var listenerIsScoped = isScoped(selector);

        if (listenerIsScoped) {
          // Normalize selectors so they don't use :scope
          selector = selector.replace(scopedSelectorRegex, '>'); // Store a unique ID and set a special attribute we'll use to scope

          this.root.setAttribute('__vent-id__', this._id);
        } // Create an object with the event's information


        var eventObject = {
          eventName: eventName,
          handler: handler,
          namespaces: namespaces,
          selector: selector,
          useCapture: useCapture,
          isScoped: listenerIsScoped
        }; // Store relative to the current type and with everyone else

        listenerList.push(eventObject);

        this._allListeners.push(eventObject);
      };
      /**
        Remove an event listener.
        @memberof Vent
         @param {String} [eventName]
          The event name to stop listening for, including optional namespace(s).
        @param {String} [selector]
          The selector that was used for event delegation.
        @param {Function} [handler]
          The function that was passed to <code>on()</code>.
        @param {Boolean} [useCapture]
          Only remove listeners with <code>useCapture</code> set to the value passed in.
         @returns {Vent} this, chainable.
      */


      Vent.prototype.off = function (eventName, selector, handler, useCapture) {
        if (typeof selector === 'function') {
          useCapture = handler;
          handler = selector;
          selector = null;
        } // Be null if not provided


        if (typeof eventName === 'undefined') {
          eventName = null;
        }

        if (typeof selector === 'undefined') {
          selector = null;
        }

        if (typeof handler === 'undefined') {
          handler = null;
        }

        if (typeof useCapture === 'undefined') {
          useCapture = null;
        } // Extract namespaces


        var namespaces = null;

        if (eventName) {
          var dotIndex = eventName.indexOf('.');

          if (dotIndex !== -1) {
            namespaces = eventName.slice(dotIndex + 1).split('.');
            eventName = eventName.slice(0, dotIndex);
          }
        } // Be null


        if (eventName === '') {
          eventName = null;
        }

        var listener;
        var index;
        var listeners = this._allListeners;

        for (var i = 0; i < listeners.length; i++) {
          listener = listeners[i];

          if ((eventName === null || listener.eventName === eventName) && (selector === null || listener.selector === selector) && (handler === null || listener.handler === handler) && (useCapture === null || listener.useCapture === useCapture) && ( // Remove matching listeners, regardless of namespace
          namespaces === null || // Listener matches all specified namespaces
          listener.namespaces && contains(listener.namespaces, namespaces))) {
            // Remove the listeners info
            this._allListeners.splice(i, 1); // Array length changed, so check the same index on the next iteration


            i--; // Get index in listenersByType map

            if (!this._listenersByType[listener.eventName]) {
              throw new Error('Vent: Missing listenersByType for ' + listener.eventName);
            } // Find the event info in the other lookup list


            index = this._listenersByType[listener.eventName].indexOf(listener);

            if (index !== -1) {
              var mapList = this._listenersByType[listener.eventName]; // Remove from the map

              mapList.splice(index, 1); // Check if we've removed all the listeners for this event type

              if (mapList.length === 0) {
                // Remove the actual listener, if necessary
                this.root.removeEventListener(listener.eventName, this._executeCaptureListeners, true);
                this.root.removeEventListener(listener.eventName, this._executeBubbleListeners, false); // Avoid using delete operator for performance

                this._listenersByType[listener.eventName] = null;
              }
            } else {
              throw new Error('Vent: Event existed in allEvents, but did not exist in listenersByType');
            } // Don't stop now! We want to remove all matching listeners, so continue to loop

          }
        }

        return this;
      };

      if (typeof CustomEvent === 'function') {
        // Use native CustomEvent on platforms that support it
        // Note: defaultPrevented will not be set correctly if CustomEvent is polyfilled

        /**
          Dispatch a custom event at the root element.
          @memberof Vent
           @param {String} eventName
            The name of the event to dispatch.
          @param {Object} [options]
            CustomEvent options.
          @param {Object} [options.bubbles=true]
            Whether the event should bubble.
          @param {Object} [options.cancelable=true]
            Whether the event should be cancelable.
          @param {Object} [options.detail]
            Data to pass to handlers as <code>event.detail</code>
        */
        Vent.prototype.dispatch = function (eventName, options) {
          options = options || {};

          if (typeof options.bubbles === 'undefined') {
            options.bubbles = true;
          }

          if (typeof options.cancelable === 'undefined') {
            options.cancelable = true;
          }

          var event = new CustomEvent(eventName, options);
          this.root.dispatchEvent(event);
          return event;
        };
      } else {
        // Use createEvent for old browsers
        Vent.prototype.dispatch = function (eventName, options) {
          options = options || {};

          if (typeof options.bubbles === 'undefined') {
            options.bubbles = true;
          }

          if (typeof options.cancelable === 'undefined') {
            options.cancelable = true;
          }

          var event = document.createEvent('CustomEvent');
          event.initCustomEvent(eventName, options.bubbles, options.cancelable, options.detail); // Dispatch the event, checking the return value to see if preventDefault() was called

          var defaultPrevented = !this.root.dispatchEvent(event); // Check if the defaultPrevented status was correctly stored back to the event object

          if (defaultPrevented !== event.defaultPrevented) {
            // dispatchEvent() doesn't correctly set event.defaultPrevented in IE 9
            // However, it does return false if preventDefault() was called
            // Unfortunately, the returned event's defaultPrevented property is read-only
            // We need to work around this such that (patchedEvent instanceof Event) === true
            // First, we'll create an object that uses the event as its prototype
            // This gives us an object we can modify that is still technically an instanceof Event
            var patchedEvent = Object.create(event); // Next, we set the correct value for defaultPrevented on the new object
            // We cannot simply assign defaultPrevented, it causes a "Invalid Calling Object" error in IE 9
            // For some reason, defineProperty doesn't cause this

            Object.defineProperty(patchedEvent, 'defaultPrevented', {
              value: defaultPrevented
            });
            return patchedEvent;
          }

          return event;
        };
      }
      /**
        Destroy this instance, removing all events and references.
        @memberof Vent
      */


      Vent.prototype.destroy = function () {
        if (this.destroyed) {
          // Instance is already destroyed, do nothing
          return;
        } // Remove all events


        this.off(); // Remove all references

        this._listenersByType = null;
        this._allListeners = null;
        this.root = null;
        this.destroyed = true;
      };

      return Vent;
    });
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  // Patch to be able to use document.createElement(tagName, customElement) from custom elements v0
  var documentCreateElement$1 = document.createElement;

  document.createElement = function createElement() {
    if (typeof arguments[1] === 'string') {
      arguments[1] = {
        is: arguments[1]
      };
    }

    return documentCreateElement$1.apply(this, arguments);
  };

  /*! (C) Andrea Giammarchi - @WebReflection - ISC Style License */
  !function (e, t) {

    function n() {
      var e = A.splice(0, A.length);

      for (et = 0; e.length;) {
        e.shift().call(null, e.shift());
      }
    }

    function r(e, t) {
      for (var n = 0, r = e.length; n < r; n++) {
        T(e[n], t);
      }
    }

    function o(e) {
      for (var t, n = 0, r = e.length; n < r; n++) {
        t = e[n], V(t, ae[a(t)]);
      }
    }

    function l(e) {
      return function (t) {
        ke(t) && (T(t, e), ie.length && r(t.querySelectorAll(ie), e));
      };
    }

    function a(e) {
      var t = Ge.call(e, "is"),
          n = e.nodeName.toUpperCase(),
          r = ce.call(le, t ? ne + t.toUpperCase() : te + n);
      return t && -1 < r && !i(n, t) ? -1 : r;
    }

    function i(e, t) {
      return -1 < ie.indexOf(e + '[is="' + t + '"]');
    }

    function u(e) {
      var t = e.currentTarget,
          n = e.attrChange,
          r = e.attrName,
          o = e.target,
          l = e[Q] || 2,
          a = e[W] || 3;
      !at || o && o !== t || !t[j] || "style" === r || e.prevValue === e.newValue && ("" !== e.newValue || n !== l && n !== a) || t[j](r, n === l ? null : e.prevValue, n === a ? null : e.newValue);
    }

    function c(e) {
      var t = l(e);
      return function (e) {
        A.push(t, e.target), et && clearTimeout(et), et = setTimeout(n, 1);
      };
    }

    function s(e) {
      lt && (lt = !1, e.currentTarget.removeEventListener(J, s)), ie.length && r((e.target || y).querySelectorAll(ie), e.detail === B ? B : x), Ue && p();
    }

    function m(e, t) {
      var n = this;
      Xe.call(n, e, t), O.call(n, {
        target: n
      });
    }

    function f(e, t, n) {
      var r = t.apply(e, n),
          l = a(r);
      return -1 < l && V(r, ae[l]), n.pop() && ie.length && o(r.querySelectorAll(ie)), r;
    }

    function d(e, t) {
      Se(e, t), I ? I.observe(e, Ye) : (ot && (e.setAttribute = m, e[_] = D(e), e[k](ee, O)), e[k](Y, u)), e[X] && at && (e.created = !0, e[X](), e.created = !1);
    }

    function p() {
      for (var e, t = 0, n = xe.length; t < n; t++) {
        e = xe[t], ue.contains(e) || (n--, xe.splice(t--, 1), T(e, B));
      }
    }

    function h(e) {
      throw new Error("A " + e + " type is already registered");
    }

    function T(e, t) {
      var n,
          r,
          o = a(e);
      -1 < o && !Ze.call(e, "TEMPLATE") && (S(e, ae[o]), o = 0, t !== x || e[x] ? t !== B || e[B] || (e[x] = !1, e[B] = !0, r = "disconnected", o = 1) : (e[B] = !1, e[x] = !0, r = "connected", o = 1, Ue && ce.call(xe, e) < 0 && xe.push(e)), o && (n = e[t + q] || e[r + q]) && n.call(e));
    }

    function L() {}

    function M(e, t, n) {
      var r = n && n[Z] || "",
          o = t.prototype,
          l = Fe(o),
          a = t.observedAttributes || pe,
          i = {
        prototype: l
      };
      _e(l, X, {
        value: function value() {
          if (Ae) Ae = !1;else if (!this[He]) {
            this[He] = !0, new t(this), o[X] && o[X].call(this);
            var e = Oe[De.get(t)];
            (!be || e.create.length > 1) && H(this);
          }
        }
      }), _e(l, j, {
        value: function value(e) {
          -1 < ce.call(a, e) && o[j] && o[j].apply(this, arguments);
        }
      }), o[z] && _e(l, G, {
        value: o[z]
      }), o[K] && _e(l, $, {
        value: o[K]
      }), r && (i[Z] = r), e = e.toUpperCase(), Oe[e] = {
        constructor: t,
        create: r ? [r, Ie(e)] : [e]
      }, De.set(t, e), y[R](e.toLowerCase(), i), g(e), Ne[e].r();
    }

    function E(e) {
      var t = Oe[e.toUpperCase()];
      return t && t.constructor;
    }

    function v(e) {
      return "string" == typeof e ? e : e && e.is || "";
    }

    function H(e) {
      for (var t, n = e[j], r = n ? e.attributes : pe, o = r.length; o--;) {
        t = r[o], n.call(e, t.name || t.nodeName, null, t.value || t.nodeValue);
      }
    }

    function g(e) {
      return e = e.toUpperCase(), e in Ne || (Ne[e] = {}, Ne[e].p = new we(function (t) {
        Ne[e].r = t;
      })), Ne[e].p;
    }

    function b() {
      ge && delete e.customElements, de(e, "customElements", {
        configurable: !0,
        value: new L()
      }), de(e, "CustomElementRegistry", {
        configurable: !0,
        value: L
      });

      for (var t = w.get(/^HTML[A-Z]*[a-z]/), n = t.length; n--; function (t) {
        var n = e[t];

        if (n) {
          e[t] = function (e) {
            var t, r;
            return e || (e = this), e[He] || (Ae = !0, t = Oe[De.get(e.constructor)], r = be && 1 === t.create.length, e = r ? Reflect.construct(n, pe, t.constructor) : y.createElement.apply(y, t.create), e[He] = !0, Ae = !1, r || H(e)), e;
          }, e[t].prototype = n.prototype;

          try {
            n.prototype.constructor = e[t];
          } catch (r) {
            de(n, He, {
              value: e[t]
            });
          }
        }
      }(t[n])) {
      }

      y.createElement = function (e, t) {
        var n = v(t);
        return n ? We.call(this, e, Ie(n)) : We.call(this, e);
      }, tt || (rt = !0, y[R](""));
    }

    var y = e.document,
        C = e.Object,
        w = function (e) {
      var t,
          n,
          r,
          o,
          l = /^[A-Z]+[a-z]/,
          a = function a(e) {
        var t,
            n = [];

        for (t in u) {
          e.test(t) && n.push(t);
        }

        return n;
      },
          i = function i(e, t) {
        (t = t.toLowerCase()) in u || (u[e] = (u[e] || []).concat(t), u[t] = u[t.toUpperCase()] = e);
      },
          u = (C.create || C)(null),
          c = {};

      for (n in e) {
        for (o in e[n]) {
          for (r = e[n][o], u[o] = r, t = 0; t < r.length; t++) {
            u[r[t].toLowerCase()] = u[r[t].toUpperCase()] = o;
          }
        }
      }

      return c.get = function (e) {
        return "string" == typeof e ? u[e] || (l.test(e) ? [] : "") : a(e);
      }, c.set = function (e, t) {
        return l.test(e) ? i(e, t) : i(t, e), c;
      }, c;
    }({
      collections: {
        HTMLAllCollection: ["all"],
        HTMLCollection: ["forms"],
        HTMLFormControlsCollection: ["elements"],
        HTMLOptionsCollection: ["options"]
      },
      elements: {
        Element: ["element"],
        HTMLAnchorElement: ["a"],
        HTMLAppletElement: ["applet"],
        HTMLAreaElement: ["area"],
        HTMLAttachmentElement: ["attachment"],
        HTMLAudioElement: ["audio"],
        HTMLBRElement: ["br"],
        HTMLBaseElement: ["base"],
        HTMLBodyElement: ["body"],
        HTMLButtonElement: ["button"],
        HTMLCanvasElement: ["canvas"],
        HTMLContentElement: ["content"],
        HTMLDListElement: ["dl"],
        HTMLDataElement: ["data"],
        HTMLDataListElement: ["datalist"],
        HTMLDetailsElement: ["details"],
        HTMLDialogElement: ["dialog"],
        HTMLDirectoryElement: ["dir"],
        HTMLDivElement: ["div"],
        HTMLDocument: ["document"],
        HTMLElement: ["element", "abbr", "address", "article", "aside", "b", "bdi", "bdo", "cite", "code", "command", "dd", "dfn", "dt", "em", "figcaption", "figure", "footer", "header", "i", "kbd", "mark", "nav", "noscript", "rp", "rt", "ruby", "s", "samp", "section", "small", "strong", "sub", "summary", "sup", "u", "var", "wbr"],
        HTMLEmbedElement: ["embed"],
        HTMLFieldSetElement: ["fieldset"],
        HTMLFontElement: ["font"],
        HTMLFormElement: ["form"],
        HTMLFrameElement: ["frame"],
        HTMLFrameSetElement: ["frameset"],
        HTMLHRElement: ["hr"],
        HTMLHeadElement: ["head"],
        HTMLHeadingElement: ["h1", "h2", "h3", "h4", "h5", "h6"],
        HTMLHtmlElement: ["html"],
        HTMLIFrameElement: ["iframe"],
        HTMLImageElement: ["img"],
        HTMLInputElement: ["input"],
        HTMLKeygenElement: ["keygen"],
        HTMLLIElement: ["li"],
        HTMLLabelElement: ["label"],
        HTMLLegendElement: ["legend"],
        HTMLLinkElement: ["link"],
        HTMLMapElement: ["map"],
        HTMLMarqueeElement: ["marquee"],
        HTMLMediaElement: ["media"],
        HTMLMenuElement: ["menu"],
        HTMLMenuItemElement: ["menuitem"],
        HTMLMetaElement: ["meta"],
        HTMLMeterElement: ["meter"],
        HTMLModElement: ["del", "ins"],
        HTMLOListElement: ["ol"],
        HTMLObjectElement: ["object"],
        HTMLOptGroupElement: ["optgroup"],
        HTMLOptionElement: ["option"],
        HTMLOutputElement: ["output"],
        HTMLParagraphElement: ["p"],
        HTMLParamElement: ["param"],
        HTMLPictureElement: ["picture"],
        HTMLPreElement: ["pre"],
        HTMLProgressElement: ["progress"],
        HTMLQuoteElement: ["blockquote", "q", "quote"],
        HTMLScriptElement: ["script"],
        HTMLSelectElement: ["select"],
        HTMLShadowElement: ["shadow"],
        HTMLSlotElement: ["slot"],
        HTMLSourceElement: ["source"],
        HTMLSpanElement: ["span"],
        HTMLStyleElement: ["style"],
        HTMLTableCaptionElement: ["caption"],
        HTMLTableCellElement: ["td", "th"],
        HTMLTableColElement: ["col", "colgroup"],
        HTMLTableElement: ["table"],
        HTMLTableRowElement: ["tr"],
        HTMLTableSectionElement: ["thead", "tbody", "tfoot"],
        HTMLTemplateElement: ["template"],
        HTMLTextAreaElement: ["textarea"],
        HTMLTimeElement: ["time"],
        HTMLTitleElement: ["title"],
        HTMLTrackElement: ["track"],
        HTMLUListElement: ["ul"],
        HTMLUnknownElement: ["unknown", "vhgroupv", "vkeygen"],
        HTMLVideoElement: ["video"]
      },
      nodes: {
        Attr: ["node"],
        Audio: ["audio"],
        CDATASection: ["node"],
        CharacterData: ["node"],
        Comment: ["#comment"],
        Document: ["#document"],
        DocumentFragment: ["#document-fragment"],
        DocumentType: ["node"],
        HTMLDocument: ["#document"],
        Image: ["img"],
        Option: ["option"],
        ProcessingInstruction: ["node"],
        ShadowRoot: ["#shadow-root"],
        Text: ["#text"],
        XMLDocument: ["xml"]
      }
    });

    "object" != _typeof(t) && (t = {
      type: t || "auto"
    });

    var A,
        O,
        N,
        D,
        I,
        F,
        S,
        V,
        P,
        R = "registerElement",
        U = 1e5 * e.Math.random() >> 0,
        _ = "__" + R + U,
        k = "addEventListener",
        x = "attached",
        q = "Callback",
        B = "detached",
        Z = "extends",
        j = "attributeChanged" + q,
        G = x + q,
        z = "connected" + q,
        K = "disconnected" + q,
        X = "created" + q,
        $ = B + q,
        Q = "ADDITION",
        W = "REMOVAL",
        Y = "DOMAttrModified",
        J = "DOMContentLoaded",
        ee = "DOMSubtreeModified",
        te = "<",
        ne = "=",
        re = /^[A-Z][._A-Z0-9]*-[-._A-Z0-9]*$/,
        oe = ["ANNOTATION-XML", "COLOR-PROFILE", "FONT-FACE", "FONT-FACE-SRC", "FONT-FACE-URI", "FONT-FACE-FORMAT", "FONT-FACE-NAME", "MISSING-GLYPH"],
        le = [],
        ae = [],
        ie = "",
        ue = y.documentElement,
        ce = le.indexOf || function (e) {
      for (var t = this.length; t-- && this[t] !== e;) {
      }

      return t;
    },
        se = C.prototype,
        me = se.hasOwnProperty,
        fe = se.isPrototypeOf,
        de = C.defineProperty,
        pe = [],
        he = C.getOwnPropertyDescriptor,
        Te = C.getOwnPropertyNames,
        Le = C.getPrototypeOf,
        Me = C.setPrototypeOf,
        Ee = !!C.__proto__,
        He = "__dreCEv1",
        ge = e.customElements,
        be = !/^force/.test(t.type) && !!(ge && ge.define && ge.get && ge.whenDefined),
        ye = C.create || C,
        Ce = e.Map || function () {
      var e,
          t = [],
          n = [];
      return {
        get: function get(e) {
          return n[ce.call(t, e)];
        },
        set: function set(r, o) {
          e = ce.call(t, r), e < 0 ? n[t.push(r) - 1] = o : n[e] = o;
        }
      };
    },
        we = e.Promise || function (e) {
      function t(e) {
        for (r = !0; n.length;) {
          n.shift()(e);
        }
      }

      var n = [],
          r = !1,
          o = {
        "catch": function _catch() {
          return o;
        },
        then: function then(e) {
          return n.push(e), r && setTimeout(t, 1), o;
        }
      };
      return e(t), o;
    },
        Ae = !1,
        Oe = ye(null),
        Ne = ye(null),
        De = new Ce(),
        Ie = function Ie(e) {
      return e.toLowerCase();
    },
        Fe = C.create || function ct(e) {
      return e ? (ct.prototype = e, new ct()) : this;
    },
        Se = Me || (Ee ? function (e, t) {
      return e.__proto__ = t, e;
    } : Te && he ? function () {
      function e(e, t) {
        for (var n, r = Te(t), o = 0, l = r.length; o < l; o++) {
          n = r[o], me.call(e, n) || de(e, n, he(t, n));
        }
      }

      return function (t, n) {
        do {
          e(t, n);
        } while ((n = Le(n)) && !fe.call(n, t));

        return t;
      };
    }() : function (e, t) {
      for (var n in t) {
        e[n] = t[n];
      }

      return e;
    }),
        Ve = e.MutationObserver || e.WebKitMutationObserver,
        Pe = e.HTMLAnchorElement,
        Re = (e.HTMLElement || e.Element || e.Node).prototype,
        Ue = !fe.call(Re, ue),
        _e = Ue ? function (e, t, n) {
      return e[t] = n.value, e;
    } : de,
        ke = Ue ? function (e) {
      return 1 === e.nodeType;
    } : function (e) {
      return fe.call(Re, e);
    },
        xe = Ue && [],
        qe = Re.attachShadow,
        Be = Re.cloneNode,
        Ze = Re.closest || function (e) {
      for (var t = this; t && t.nodeName !== e;) {
        t = t.parentNode;
      }

      return t;
    },
        je = Re.dispatchEvent,
        Ge = Re.getAttribute,
        ze = Re.hasAttribute,
        Ke = Re.removeAttribute,
        Xe = Re.setAttribute,
        $e = y.createElement,
        Qe = y.importNode,
        We = $e,
        Ye = Ve && {
      attributes: !0,
      characterData: !0,
      attributeOldValue: !0
    },
        Je = Ve || function (e) {
      ot = !1, ue.removeEventListener(Y, Je);
    },
        et = 0,
        tt = R in y && !/^force-all/.test(t.type),
        nt = !0,
        rt = !1,
        ot = !0,
        lt = !0,
        at = !0;

    if (Ve && (P = y.createElement("div"), P.innerHTML = "<div><div></div></div>", new Ve(function (e, t) {
      if (e[0] && "childList" == e[0].type && !e[0].removedNodes[0].childNodes.length) {
        P = he(Re, "innerHTML");
        var n = P && P.set;
        n && de(Re, "innerHTML", {
          set: function set(e) {
            for (; this.lastChild;) {
              this.removeChild(this.lastChild);
            }

            n.call(this, e);
          }
        });
      }

      t.disconnect(), P = null;
    }).observe(P, {
      childList: !0,
      subtree: !0
    }), P.innerHTML = ""), tt || (Me || Ee ? (S = function S(e, t) {
      fe.call(t, e) || d(e, t);
    }, V = d) : (S = function S(e, t) {
      e[_] || (e[_] = C(!0), d(e, t));
    }, V = S), Ue ? (ot = !1, function () {
      var e = he(Re, k),
          t = e.value,
          n = function n(e) {
        var t = new CustomEvent(Y, {
          bubbles: !0
        });
        t.attrName = e, t.prevValue = Ge.call(this, e), t.newValue = null, t[W] = t.attrChange = 2, Ke.call(this, e), je.call(this, t);
      },
          r = function r(e, t) {
        var n = ze.call(this, e),
            r = n && Ge.call(this, e),
            o = new CustomEvent(Y, {
          bubbles: !0
        });
        Xe.call(this, e, t), o.attrName = e, o.prevValue = n ? r : null, o.newValue = t, n ? o.MODIFICATION = o.attrChange = 1 : o[Q] = o.attrChange = 0, je.call(this, o);
      },
          o = function o(e) {
        var t,
            n = e.currentTarget,
            r = n[_],
            o = e.propertyName;
        r.hasOwnProperty(o) && (r = r[o], t = new CustomEvent(Y, {
          bubbles: !0
        }), t.attrName = r.name, t.prevValue = r.value || null, t.newValue = r.value = n[o] || null, null == t.prevValue ? t[Q] = t.attrChange = 0 : t.MODIFICATION = t.attrChange = 1, je.call(n, t));
      };

      e.value = function (e, l, a) {
        e === Y && this[j] && this.setAttribute !== r && (this[_] = {
          className: {
            name: "class",
            value: this.className
          }
        }, this.setAttribute = r, this.removeAttribute = n, t.call(this, "propertychange", o)), t.call(this, e, l, a);
      }, de(Re, k, e);
    }()) : Ve || (ue[k](Y, Je), ue.setAttribute(_, 1), ue.removeAttribute(_), ot && (O = function O(e) {
      var t,
          n,
          r,
          o = this;

      if (o === e.target) {
        t = o[_], o[_] = n = D(o);

        for (r in n) {
          if (!(r in t)) return N(0, o, r, t[r], n[r], Q);
          if (n[r] !== t[r]) return N(1, o, r, t[r], n[r], "MODIFICATION");
        }

        for (r in t) {
          if (!(r in n)) return N(2, o, r, t[r], n[r], W);
        }
      }
    }, N = function N(e, t, n, r, o, l) {
      var a = {
        attrChange: e,
        currentTarget: t,
        attrName: n,
        prevValue: r,
        newValue: o
      };
      a[l] = e, u(a);
    }, D = function D(e) {
      for (var t, n, r = {}, o = e.attributes, l = 0, a = o.length; l < a; l++) {
        t = o[l], "setAttribute" !== (n = t.name) && (r[n] = t.value);
      }

      return r;
    })), y[R] = function (e, t) {
      if (n = e.toUpperCase(), nt && (nt = !1, Ve ? (I = function (e, t) {
        function n(e, t) {
          for (var n = 0, r = e.length; n < r; t(e[n++])) {
          }
        }

        return new Ve(function (r) {
          for (var o, l, a, i = 0, u = r.length; i < u; i++) {
            o = r[i], "childList" === o.type ? (n(o.addedNodes, e), n(o.removedNodes, t)) : (l = o.target, at && l[j] && "style" !== o.attributeName && (a = Ge.call(l, o.attributeName)) !== o.oldValue && l[j](o.attributeName, o.oldValue, a));
          }
        });
      }(l(x), l(B)), F = function F(e) {
        return I.observe(e, {
          childList: !0,
          subtree: !0
        }), e;
      }, F(y), qe && (Re.attachShadow = function () {
        return F(qe.apply(this, arguments));
      })) : (A = [], y[k]("DOMNodeInserted", c(x)), y[k]("DOMNodeRemoved", c(B))), y[k](J, s), y[k]("readystatechange", s), y.importNode = function (e, t) {
        switch (e.nodeType) {
          case 1:
            return f(y, Qe, [e, !!t]);

          case 11:
            for (var n = y.createDocumentFragment(), r = e.childNodes, o = r.length, l = 0; l < o; l++) {
              n.appendChild(y.importNode(r[l], !!t));
            }

            return n;

          default:
            return Be.call(e, !!t);
        }
      }, Re.cloneNode = function (e) {
        return f(this, Be, [!!e]);
      }), rt) return rt = !1;
      if (-2 < ce.call(le, ne + n) + ce.call(le, te + n) && h(e), !re.test(n) || -1 < ce.call(oe, n)) throw new Error("The type " + e + " is invalid");

      var n,
          o,
          a = function a() {
        return u ? y.createElement(m, n) : y.createElement(m);
      },
          i = t || se,
          u = me.call(i, Z),
          m = u ? t[Z].toUpperCase() : n;

      return u && -1 < ce.call(le, te + m) && h(m), o = le.push((u ? ne : te) + n) - 1, ie = ie.concat(ie.length ? "," : "", u ? m + '[is="' + e.toLowerCase() + '"]' : m), a.prototype = ae[o] = me.call(i, "prototype") ? i.prototype : Fe(Re), ie.length && r(y.querySelectorAll(ie), x), a;
    }, y.createElement = We = function We(e, t) {
      var n = v(t),
          r = n ? $e.call(y, e, Ie(n)) : $e.call(y, e),
          o = "" + e,
          l = ce.call(le, (n ? ne : te) + (n || o).toUpperCase()),
          a = -1 < l;
      return n && (r.setAttribute("is", n = n.toLowerCase()), a && (a = i(o.toUpperCase(), n))), at = !y.createElement.innerHTMLHelper, a && V(r, ae[l]), r;
    }), addEventListener("beforeunload", function () {
      delete y.createElement, delete y.importNode, delete y[R];
    }, !1), L.prototype = {
      constructor: L,
      define: be ? function (e, t, n) {
        if (n) M(e, t, n);else {
          var r = e.toUpperCase();
          Oe[r] = {
            constructor: t,
            create: [r]
          }, De.set(t, r), ge.define(e, t);
        }
      } : M,
      get: be ? function (e) {
        return ge.get(e) || E(e);
      } : E,
      whenDefined: be ? function (e) {
        return we.race([ge.whenDefined(e), g(e)]);
      } : g
    }, !ge || /^force/.test(t.type)) b();else if (!t.noBuiltIn) try {
      !function (t, n, r) {
        var o = new RegExp("^<a\\s+is=('|\")" + r + "\\1></a>$");
        if (n[Z] = "a", t.prototype = Fe(Pe.prototype), t.prototype.constructor = t, e.customElements.define(r, t, n), !o.test(y.createElement("a", {
          is: r
        }).outerHTML) || !o.test(new t().outerHTML)) throw n;
      }(function st() {
        return Reflect.construct(Pe, [], st);
      }, {}, "document-register-element-a" + U);
    } catch (it) {
      b();
    }
    if (!t.noBuiltIn) try {
      if ($e.call(y, "a", "a").outerHTML.indexOf("is") < 0) throw {};
    } catch (ut) {
      Ie = function Ie(e) {
        return {
          is: e.toLowerCase()
        };
      };
    }
  }(window);

  /*! (C) Andrea Giammarchi - @WebReflection - ISC Style License */
  var innerHTML = function (e) {
    var t,
        r,
        n = e.registerElement,
        a = e.createElement("div"),
        l = "document-register-element",
        i = n.innerHTML;
    if (i) return i;

    try {
      if (n.call(e, l, {
        prototype: Object.create(HTMLElement.prototype, {
          createdCallback: {
            value: Object
          }
        })
      }), a.innerHTML = "<" + l + "></" + l + ">", "createdCallback" in a.querySelector(l)) return n.innerHTML = function (e, t) {
        return e.innerHTML = t, e;
      };
    } catch (c) {}

    return r = [], t = function t(_t) {
      if (!("createdCallback" in _t || "attachedCallback" in _t || "detachedCallback" in _t || "attributeChangedCallback" in _t)) {
        e.createElement.innerHTMLHelper = !0;

        for (var r, n, a = _t.parentNode, l = _t.getAttribute("is"), i = _t.nodeName, c = e.createElement.apply(e, l ? [i, l] : [i]), d = _t.attributes, u = 0, o = d.length; u < o; u++) {
          r = d[u], c.setAttribute(r.name, r.value);
        }

        for (; n = _t.firstChild;) {
          c.appendChild(n);
        }

        e.createElement.innerHTMLHelper = !1, a && a.replaceChild(c, _t), c.createdCallback && (c.created = !0, c.createdCallback(), c.created = !1);
      }
    }, (e.registerElement = function (t, a) {
      var l = (a["extends"] ? a["extends"] + '[is="' + t + '"]' : t).toLowerCase();
      return r.indexOf(l) < 0 && r.push(l), n.apply(e, arguments);
    }).innerHTML = function (e, n) {
      e.innerHTML = n;

      for (var a = r.length ? e.querySelectorAll(r.join(",")) : [], l = a.length; l--; t(a[l])) {
      }

      return e;
    };
  }(document);

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /* eslint-disable-next-line no-empty-function */
  var f$6 = function f() {}; // Mostly empty functions to avoid breaking code


  if (!window.CustomElements) {
    window.CustomElements = {
      flags: {}
    };
    window.CustomElements.upgrade = f$6;
    window.CustomElements.upgradeAll = f$6;

    window.CustomElements.instanceof = function (el, ins) {
      return el instanceof ins;
    };

    window.CustomElements.upgradeDocumentTree = f$6;
    window.CustomElements.upgradeSubtree = f$6;
    window.CustomElements.addModule = f$6;
    window.CustomElements.initializeModules = f$6;
    window.CustomElements.takeRecords = f$6;
    window.CustomElements.takeRecords = f$6;
    window.CustomElements.watchShadow = f$6;
  }

  var ResizeObserver = createCommonjsModule(function (module, exports) {
    (function (global, factory) {
       module.exports = factory() ;
    })(commonjsGlobal, function () {
      /**
       * A collection of shims that provide minimal functionality of the ES6 collections.
       *
       * These implementations are not meant to be used outside of the ResizeObserver
       * modules as they cover only a limited range of use cases.
       */

      /* eslint-disable require-jsdoc, valid-jsdoc */

      var MapShim = function () {
        if (typeof Map !== 'undefined') {
          return Map;
        }
        /**
         * Returns index in provided array that matches the specified key.
         *
         * @param {Array<Array>} arr
         * @param {*} key
         * @returns {number}
         */


        function getIndex(arr, key) {
          var result = -1;
          arr.some(function (entry, index) {
            if (entry[0] === key) {
              result = index;
              return true;
            }

            return false;
          });
          return result;
        }

        return (
          /** @class */
          function () {
            function class_1() {
              this.__entries__ = [];
            }

            Object.defineProperty(class_1.prototype, "size", {
              /**
               * @returns {boolean}
               */
              get: function get() {
                return this.__entries__.length;
              },
              enumerable: true,
              configurable: true
            });
            /**
             * @param {*} key
             * @returns {*}
             */

            class_1.prototype.get = function (key) {
              var index = getIndex(this.__entries__, key);
              var entry = this.__entries__[index];
              return entry && entry[1];
            };
            /**
             * @param {*} key
             * @param {*} value
             * @returns {void}
             */


            class_1.prototype.set = function (key, value) {
              var index = getIndex(this.__entries__, key);

              if (~index) {
                this.__entries__[index][1] = value;
              } else {
                this.__entries__.push([key, value]);
              }
            };
            /**
             * @param {*} key
             * @returns {void}
             */


            class_1.prototype.delete = function (key) {
              var entries = this.__entries__;
              var index = getIndex(entries, key);

              if (~index) {
                entries.splice(index, 1);
              }
            };
            /**
             * @param {*} key
             * @returns {void}
             */


            class_1.prototype.has = function (key) {
              return !!~getIndex(this.__entries__, key);
            };
            /**
             * @returns {void}
             */


            class_1.prototype.clear = function () {
              this.__entries__.splice(0);
            };
            /**
             * @param {Function} callback
             * @param {*} [ctx=null]
             * @returns {void}
             */


            class_1.prototype.forEach = function (callback, ctx) {
              if (ctx === void 0) {
                ctx = null;
              }

              for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
                var entry = _a[_i];
                callback.call(ctx, entry[1], entry[0]);
              }
            };

            return class_1;
          }()
        );
      }();
      /**
       * Detects whether window and document objects are available in current environment.
       */


      var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document; // Returns global object of a current environment.

      var global$1 = function () {
        if (typeof commonjsGlobal !== 'undefined' && commonjsGlobal.Math === Math) {
          return commonjsGlobal;
        }

        if (typeof self !== 'undefined' && self.Math === Math) {
          return self;
        }

        if (typeof window !== 'undefined' && window.Math === Math) {
          return window;
        } // eslint-disable-next-line no-new-func


        return Function('return this')();
      }();
      /**
       * A shim for the requestAnimationFrame which falls back to the setTimeout if
       * first one is not supported.
       *
       * @returns {number} Requests' identifier.
       */


      var requestAnimationFrame$1 = function () {
        if (typeof requestAnimationFrame === 'function') {
          // It's required to use a bounded function because IE sometimes throws
          // an "Invalid calling object" error if rAF is invoked without the global
          // object on the left hand side.
          return requestAnimationFrame.bind(global$1);
        }

        return function (callback) {
          return setTimeout(function () {
            return callback(Date.now());
          }, 1000 / 60);
        };
      }(); // Defines minimum timeout before adding a trailing call.


      var trailingTimeout = 2;
      /**
       * Creates a wrapper function which ensures that provided callback will be
       * invoked only once during the specified delay period.
       *
       * @param {Function} callback - Function to be invoked after the delay period.
       * @param {number} delay - Delay after which to invoke callback.
       * @returns {Function}
       */

      function throttle(callback, delay) {
        var leadingCall = false,
            trailingCall = false,
            lastCallTime = 0;
        /**
         * Invokes the original callback function and schedules new invocation if
         * the "proxy" was called during current request.
         *
         * @returns {void}
         */

        function resolvePending() {
          if (leadingCall) {
            leadingCall = false;
            callback();
          }

          if (trailingCall) {
            proxy();
          }
        }
        /**
         * Callback invoked after the specified delay. It will further postpone
         * invocation of the original function delegating it to the
         * requestAnimationFrame.
         *
         * @returns {void}
         */


        function timeoutCallback() {
          requestAnimationFrame$1(resolvePending);
        }
        /**
         * Schedules invocation of the original function.
         *
         * @returns {void}
         */


        function proxy() {
          var timeStamp = Date.now();

          if (leadingCall) {
            // Reject immediately following calls.
            if (timeStamp - lastCallTime < trailingTimeout) {
              return;
            } // Schedule new call to be in invoked when the pending one is resolved.
            // This is important for "transitions" which never actually start
            // immediately so there is a chance that we might miss one if change
            // happens amids the pending invocation.


            trailingCall = true;
          } else {
            leadingCall = true;
            trailingCall = false;
            setTimeout(timeoutCallback, delay);
          }

          lastCallTime = timeStamp;
        }

        return proxy;
      } // Minimum delay before invoking the update of observers.


      var REFRESH_DELAY = 20; // A list of substrings of CSS properties used to find transition events that
      // might affect dimensions of observed elements.

      var transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight']; // Check if MutationObserver is available.

      var mutationObserverSupported = typeof MutationObserver !== 'undefined';
      /**
       * Singleton controller class which handles updates of ResizeObserver instances.
       */

      var ResizeObserverController =
      /** @class */
      function () {
        /**
         * Creates a new instance of ResizeObserverController.
         *
         * @private
         */
        function ResizeObserverController() {
          /**
           * Indicates whether DOM listeners have been added.
           *
           * @private {boolean}
           */
          this.connected_ = false;
          /**
           * Tells that controller has subscribed for Mutation Events.
           *
           * @private {boolean}
           */

          this.mutationEventsAdded_ = false;
          /**
           * Keeps reference to the instance of MutationObserver.
           *
           * @private {MutationObserver}
           */

          this.mutationsObserver_ = null;
          /**
           * A list of connected observers.
           *
           * @private {Array<ResizeObserverSPI>}
           */

          this.observers_ = [];
          this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
          this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
        }
        /**
         * Adds observer to observers list.
         *
         * @param {ResizeObserverSPI} observer - Observer to be added.
         * @returns {void}
         */


        ResizeObserverController.prototype.addObserver = function (observer) {
          if (!~this.observers_.indexOf(observer)) {
            this.observers_.push(observer);
          } // Add listeners if they haven't been added yet.


          if (!this.connected_) {
            this.connect_();
          }
        };
        /**
         * Removes observer from observers list.
         *
         * @param {ResizeObserverSPI} observer - Observer to be removed.
         * @returns {void}
         */


        ResizeObserverController.prototype.removeObserver = function (observer) {
          var observers = this.observers_;
          var index = observers.indexOf(observer); // Remove observer if it's present in registry.

          if (~index) {
            observers.splice(index, 1);
          } // Remove listeners if controller has no connected observers.


          if (!observers.length && this.connected_) {
            this.disconnect_();
          }
        };
        /**
         * Invokes the update of observers. It will continue running updates insofar
         * it detects changes.
         *
         * @returns {void}
         */


        ResizeObserverController.prototype.refresh = function () {
          var changesDetected = this.updateObservers_(); // Continue running updates if changes have been detected as there might
          // be future ones caused by CSS transitions.

          if (changesDetected) {
            this.refresh();
          }
        };
        /**
         * Updates every observer from observers list and notifies them of queued
         * entries.
         *
         * @private
         * @returns {boolean} Returns "true" if any observer has detected changes in
         *      dimensions of it's elements.
         */


        ResizeObserverController.prototype.updateObservers_ = function () {
          // Collect observers that have active observations.
          var activeObservers = this.observers_.filter(function (observer) {
            return observer.gatherActive(), observer.hasActive();
          }); // Deliver notifications in a separate cycle in order to avoid any
          // collisions between observers, e.g. when multiple instances of
          // ResizeObserver are tracking the same element and the callback of one
          // of them changes content dimensions of the observed target. Sometimes
          // this may result in notifications being blocked for the rest of observers.

          activeObservers.forEach(function (observer) {
            return observer.broadcastActive();
          });
          return activeObservers.length > 0;
        };
        /**
         * Initializes DOM listeners.
         *
         * @private
         * @returns {void}
         */


        ResizeObserverController.prototype.connect_ = function () {
          // Do nothing if running in a non-browser environment or if listeners
          // have been already added.
          if (!isBrowser || this.connected_) {
            return;
          } // Subscription to the "Transitionend" event is used as a workaround for
          // delayed transitions. This way it's possible to capture at least the
          // final state of an element.


          document.addEventListener('transitionend', this.onTransitionEnd_);
          window.addEventListener('resize', this.refresh);

          if (mutationObserverSupported) {
            this.mutationsObserver_ = new MutationObserver(this.refresh);
            this.mutationsObserver_.observe(document, {
              attributes: true,
              childList: true,
              characterData: true,
              subtree: true
            });
          } else {
            document.addEventListener('DOMSubtreeModified', this.refresh);
            this.mutationEventsAdded_ = true;
          }

          this.connected_ = true;
        };
        /**
         * Removes DOM listeners.
         *
         * @private
         * @returns {void}
         */


        ResizeObserverController.prototype.disconnect_ = function () {
          // Do nothing if running in a non-browser environment or if listeners
          // have been already removed.
          if (!isBrowser || !this.connected_) {
            return;
          }

          document.removeEventListener('transitionend', this.onTransitionEnd_);
          window.removeEventListener('resize', this.refresh);

          if (this.mutationsObserver_) {
            this.mutationsObserver_.disconnect();
          }

          if (this.mutationEventsAdded_) {
            document.removeEventListener('DOMSubtreeModified', this.refresh);
          }

          this.mutationsObserver_ = null;
          this.mutationEventsAdded_ = false;
          this.connected_ = false;
        };
        /**
         * "Transitionend" event handler.
         *
         * @private
         * @param {TransitionEvent} event
         * @returns {void}
         */


        ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {
          var _b = _a.propertyName,
              propertyName = _b === void 0 ? '' : _b; // Detect whether transition may affect dimensions of an element.

          var isReflowProperty = transitionKeys.some(function (key) {
            return !!~propertyName.indexOf(key);
          });

          if (isReflowProperty) {
            this.refresh();
          }
        };
        /**
         * Returns instance of the ResizeObserverController.
         *
         * @returns {ResizeObserverController}
         */


        ResizeObserverController.getInstance = function () {
          if (!this.instance_) {
            this.instance_ = new ResizeObserverController();
          }

          return this.instance_;
        };
        /**
         * Holds reference to the controller's instance.
         *
         * @private {ResizeObserverController}
         */


        ResizeObserverController.instance_ = null;
        return ResizeObserverController;
      }();
      /**
       * Defines non-writable/enumerable properties of the provided target object.
       *
       * @param {Object} target - Object for which to define properties.
       * @param {Object} props - Properties to be defined.
       * @returns {Object} Target object.
       */


      var defineConfigurable = function defineConfigurable(target, props) {
        for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
          var key = _a[_i];
          Object.defineProperty(target, key, {
            value: props[key],
            enumerable: false,
            writable: false,
            configurable: true
          });
        }

        return target;
      };
      /**
       * Returns the global object associated with provided element.
       *
       * @param {Object} target
       * @returns {Object}
       */


      var getWindowOf = function getWindowOf(target) {
        // Assume that the element is an instance of Node, which means that it
        // has the "ownerDocument" property from which we can retrieve a
        // corresponding global object.
        var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView; // Return the local global object if it's not possible extract one from
        // provided element.

        return ownerGlobal || global$1;
      }; // Placeholder of an empty content rectangle.


      var emptyRect = createRectInit(0, 0, 0, 0);
      /**
       * Converts provided string to a number.
       *
       * @param {number|string} value
       * @returns {number}
       */

      function toFloat(value) {
        return parseFloat(value) || 0;
      }
      /**
       * Extracts borders size from provided styles.
       *
       * @param {CSSStyleDeclaration} styles
       * @param {...string} positions - Borders positions (top, right, ...)
       * @returns {number}
       */


      function getBordersSize(styles) {
        var positions = [];

        for (var _i = 1; _i < arguments.length; _i++) {
          positions[_i - 1] = arguments[_i];
        }

        return positions.reduce(function (size, position) {
          var value = styles['border-' + position + '-width'];
          return size + toFloat(value);
        }, 0);
      }
      /**
       * Extracts paddings sizes from provided styles.
       *
       * @param {CSSStyleDeclaration} styles
       * @returns {Object} Paddings box.
       */


      function getPaddings(styles) {
        var positions = ['top', 'right', 'bottom', 'left'];
        var paddings = {};

        for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
          var position = positions_1[_i];
          var value = styles['padding-' + position];
          paddings[position] = toFloat(value);
        }

        return paddings;
      }
      /**
       * Calculates content rectangle of provided SVG element.
       *
       * @param {SVGGraphicsElement} target - Element content rectangle of which needs
       *      to be calculated.
       * @returns {DOMRectInit}
       */


      function getSVGContentRect(target) {
        var bbox = target.getBBox();
        return createRectInit(0, 0, bbox.width, bbox.height);
      }
      /**
       * Calculates content rectangle of provided HTMLElement.
       *
       * @param {HTMLElement} target - Element for which to calculate the content rectangle.
       * @returns {DOMRectInit}
       */


      function getHTMLElementContentRect(target) {
        // Client width & height properties can't be
        // used exclusively as they provide rounded values.
        var clientWidth = target.clientWidth,
            clientHeight = target.clientHeight; // By this condition we can catch all non-replaced inline, hidden and
        // detached elements. Though elements with width & height properties less
        // than 0.5 will be discarded as well.
        //
        // Without it we would need to implement separate methods for each of
        // those cases and it's not possible to perform a precise and performance
        // effective test for hidden elements. E.g. even jQuery's ':visible' filter
        // gives wrong results for elements with width & height less than 0.5.

        if (!clientWidth && !clientHeight) {
          return emptyRect;
        }

        var styles = getWindowOf(target).getComputedStyle(target);
        var paddings = getPaddings(styles);
        var horizPad = paddings.left + paddings.right;
        var vertPad = paddings.top + paddings.bottom; // Computed styles of width & height are being used because they are the
        // only dimensions available to JS that contain non-rounded values. It could
        // be possible to utilize the getBoundingClientRect if only it's data wasn't
        // affected by CSS transformations let alone paddings, borders and scroll bars.

        var width = toFloat(styles.width),
            height = toFloat(styles.height); // Width & height include paddings and borders when the 'border-box' box
        // model is applied (except for IE).

        if (styles.boxSizing === 'border-box') {
          // Following conditions are required to handle Internet Explorer which
          // doesn't include paddings and borders to computed CSS dimensions.
          //
          // We can say that if CSS dimensions + paddings are equal to the "client"
          // properties then it's either IE, and thus we don't need to subtract
          // anything, or an element merely doesn't have paddings/borders styles.
          if (Math.round(width + horizPad) !== clientWidth) {
            width -= getBordersSize(styles, 'left', 'right') + horizPad;
          }

          if (Math.round(height + vertPad) !== clientHeight) {
            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;
          }
        } // Following steps can't be applied to the document's root element as its
        // client[Width/Height] properties represent viewport area of the window.
        // Besides, it's as well not necessary as the <html> itself neither has
        // rendered scroll bars nor it can be clipped.


        if (!isDocumentElement(target)) {
          // In some browsers (only in Firefox, actually) CSS width & height
          // include scroll bars size which can be removed at this step as scroll
          // bars are the only difference between rounded dimensions + paddings
          // and "client" properties, though that is not always true in Chrome.
          var vertScrollbar = Math.round(width + horizPad) - clientWidth;
          var horizScrollbar = Math.round(height + vertPad) - clientHeight; // Chrome has a rather weird rounding of "client" properties.
          // E.g. for an element with content width of 314.2px it sometimes gives
          // the client width of 315px and for the width of 314.7px it may give
          // 314px. And it doesn't happen all the time. So just ignore this delta
          // as a non-relevant.

          if (Math.abs(vertScrollbar) !== 1) {
            width -= vertScrollbar;
          }

          if (Math.abs(horizScrollbar) !== 1) {
            height -= horizScrollbar;
          }
        }

        return createRectInit(paddings.left, paddings.top, width, height);
      }
      /**
       * Checks whether provided element is an instance of the SVGGraphicsElement.
       *
       * @param {Element} target - Element to be checked.
       * @returns {boolean}
       */


      var isSVGGraphicsElement = function () {
        // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement
        // interface.
        if (typeof SVGGraphicsElement !== 'undefined') {
          return function (target) {
            return target instanceof getWindowOf(target).SVGGraphicsElement;
          };
        } // If it's so, then check that element is at least an instance of the
        // SVGElement and that it has the "getBBox" method.
        // eslint-disable-next-line no-extra-parens


        return function (target) {
          return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === 'function';
        };
      }();
      /**
       * Checks whether provided element is a document element (<html>).
       *
       * @param {Element} target - Element to be checked.
       * @returns {boolean}
       */


      function isDocumentElement(target) {
        return target === getWindowOf(target).document.documentElement;
      }
      /**
       * Calculates an appropriate content rectangle for provided html or svg element.
       *
       * @param {Element} target - Element content rectangle of which needs to be calculated.
       * @returns {DOMRectInit}
       */


      function getContentRect(target) {
        if (!isBrowser) {
          return emptyRect;
        }

        if (isSVGGraphicsElement(target)) {
          return getSVGContentRect(target);
        }

        return getHTMLElementContentRect(target);
      }
      /**
       * Creates rectangle with an interface of the DOMRectReadOnly.
       * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly
       *
       * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.
       * @returns {DOMRectReadOnly}
       */


      function createReadOnlyRect(_a) {
        var x = _a.x,
            y = _a.y,
            width = _a.width,
            height = _a.height; // If DOMRectReadOnly is available use it as a prototype for the rectangle.

        var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;
        var rect = Object.create(Constr.prototype); // Rectangle's properties are not writable and non-enumerable.

        defineConfigurable(rect, {
          x: x,
          y: y,
          width: width,
          height: height,
          top: y,
          right: x + width,
          bottom: height + y,
          left: x
        });
        return rect;
      }
      /**
       * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.
       * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit
       *
       * @param {number} x - X coordinate.
       * @param {number} y - Y coordinate.
       * @param {number} width - Rectangle's width.
       * @param {number} height - Rectangle's height.
       * @returns {DOMRectInit}
       */


      function createRectInit(x, y, width, height) {
        return {
          x: x,
          y: y,
          width: width,
          height: height
        };
      }
      /**
       * Class that is responsible for computations of the content rectangle of
       * provided DOM element and for keeping track of it's changes.
       */


      var ResizeObservation =
      /** @class */
      function () {
        /**
         * Creates an instance of ResizeObservation.
         *
         * @param {Element} target - Element to be observed.
         */
        function ResizeObservation(target) {
          /**
           * Broadcasted width of content rectangle.
           *
           * @type {number}
           */
          this.broadcastWidth = 0;
          /**
           * Broadcasted height of content rectangle.
           *
           * @type {number}
           */

          this.broadcastHeight = 0;
          /**
           * Reference to the last observed content rectangle.
           *
           * @private {DOMRectInit}
           */

          this.contentRect_ = createRectInit(0, 0, 0, 0);
          this.target = target;
        }
        /**
         * Updates content rectangle and tells whether it's width or height properties
         * have changed since the last broadcast.
         *
         * @returns {boolean}
         */


        ResizeObservation.prototype.isActive = function () {
          var rect = getContentRect(this.target);
          this.contentRect_ = rect;
          return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
        };
        /**
         * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
         * from the corresponding properties of the last observed content rectangle.
         *
         * @returns {DOMRectInit} Last observed content rectangle.
         */


        ResizeObservation.prototype.broadcastRect = function () {
          var rect = this.contentRect_;
          this.broadcastWidth = rect.width;
          this.broadcastHeight = rect.height;
          return rect;
        };

        return ResizeObservation;
      }();

      var ResizeObserverEntry =
      /** @class */
      function () {
        /**
         * Creates an instance of ResizeObserverEntry.
         *
         * @param {Element} target - Element that is being observed.
         * @param {DOMRectInit} rectInit - Data of the element's content rectangle.
         */
        function ResizeObserverEntry(target, rectInit) {
          var contentRect = createReadOnlyRect(rectInit); // According to the specification following properties are not writable
          // and are also not enumerable in the native implementation.
          //
          // Property accessors are not being used as they'd require to define a
          // private WeakMap storage which may cause memory leaks in browsers that
          // don't support this type of collections.

          defineConfigurable(this, {
            target: target,
            contentRect: contentRect
          });
        }

        return ResizeObserverEntry;
      }();

      var ResizeObserverSPI =
      /** @class */
      function () {
        /**
         * Creates a new instance of ResizeObserver.
         *
         * @param {ResizeObserverCallback} callback - Callback function that is invoked
         *      when one of the observed elements changes it's content dimensions.
         * @param {ResizeObserverController} controller - Controller instance which
         *      is responsible for the updates of observer.
         * @param {ResizeObserver} callbackCtx - Reference to the public
         *      ResizeObserver instance which will be passed to callback function.
         */
        function ResizeObserverSPI(callback, controller, callbackCtx) {
          /**
           * Collection of resize observations that have detected changes in dimensions
           * of elements.
           *
           * @private {Array<ResizeObservation>}
           */
          this.activeObservations_ = [];
          /**
           * Registry of the ResizeObservation instances.
           *
           * @private {Map<Element, ResizeObservation>}
           */

          this.observations_ = new MapShim();

          if (typeof callback !== 'function') {
            throw new TypeError('The callback provided as parameter 1 is not a function.');
          }

          this.callback_ = callback;
          this.controller_ = controller;
          this.callbackCtx_ = callbackCtx;
        }
        /**
         * Starts observing provided element.
         *
         * @param {Element} target - Element to be observed.
         * @returns {void}
         */


        ResizeObserverSPI.prototype.observe = function (target) {
          if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
          } // Do nothing if current environment doesn't have the Element interface.


          if (typeof Element === 'undefined' || !(Element instanceof Object)) {
            return;
          }

          if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
          }

          var observations = this.observations_; // Do nothing if element is already being observed.

          if (observations.has(target)) {
            return;
          }

          observations.set(target, new ResizeObservation(target));
          this.controller_.addObserver(this); // Force the update of observations.

          this.controller_.refresh();
        };
        /**
         * Stops observing provided element.
         *
         * @param {Element} target - Element to stop observing.
         * @returns {void}
         */


        ResizeObserverSPI.prototype.unobserve = function (target) {
          if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
          } // Do nothing if current environment doesn't have the Element interface.


          if (typeof Element === 'undefined' || !(Element instanceof Object)) {
            return;
          }

          if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
          }

          var observations = this.observations_; // Do nothing if element is not being observed.

          if (!observations.has(target)) {
            return;
          }

          observations.delete(target);

          if (!observations.size) {
            this.controller_.removeObserver(this);
          }
        };
        /**
         * Stops observing all elements.
         *
         * @returns {void}
         */


        ResizeObserverSPI.prototype.disconnect = function () {
          this.clearActive();
          this.observations_.clear();
          this.controller_.removeObserver(this);
        };
        /**
         * Collects observation instances the associated element of which has changed
         * it's content rectangle.
         *
         * @returns {void}
         */


        ResizeObserverSPI.prototype.gatherActive = function () {
          var _this = this;

          this.clearActive();
          this.observations_.forEach(function (observation) {
            if (observation.isActive()) {
              _this.activeObservations_.push(observation);
            }
          });
        };
        /**
         * Invokes initial callback function with a list of ResizeObserverEntry
         * instances collected from active resize observations.
         *
         * @returns {void}
         */


        ResizeObserverSPI.prototype.broadcastActive = function () {
          // Do nothing if observer doesn't have active observations.
          if (!this.hasActive()) {
            return;
          }

          var ctx = this.callbackCtx_; // Create ResizeObserverEntry instance for every active observation.

          var entries = this.activeObservations_.map(function (observation) {
            return new ResizeObserverEntry(observation.target, observation.broadcastRect());
          });
          this.callback_.call(ctx, entries, ctx);
          this.clearActive();
        };
        /**
         * Clears the collection of active observations.
         *
         * @returns {void}
         */


        ResizeObserverSPI.prototype.clearActive = function () {
          this.activeObservations_.splice(0);
        };
        /**
         * Tells whether observer has active observations.
         *
         * @returns {boolean}
         */


        ResizeObserverSPI.prototype.hasActive = function () {
          return this.activeObservations_.length > 0;
        };

        return ResizeObserverSPI;
      }(); // Registry of internal observers. If WeakMap is not available use current shim
      // for the Map collection as it has all required methods and because WeakMap
      // can't be fully polyfilled anyway.


      var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();
      /**
       * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation
       * exposing only those methods and properties that are defined in the spec.
       */

      var ResizeObserver =
      /** @class */
      function () {
        /**
         * Creates a new instance of ResizeObserver.
         *
         * @param {ResizeObserverCallback} callback - Callback that is invoked when
         *      dimensions of the observed elements change.
         */
        function ResizeObserver(callback) {
          if (!(this instanceof ResizeObserver)) {
            throw new TypeError('Cannot call a class as a function.');
          }

          if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
          }

          var controller = ResizeObserverController.getInstance();
          var observer = new ResizeObserverSPI(callback, controller, this);
          observers.set(this, observer);
        }

        return ResizeObserver;
      }(); // Expose public methods of ResizeObserver.


      ['observe', 'unobserve', 'disconnect'].forEach(function (method) {
        ResizeObserver.prototype[method] = function () {
          var _a;

          return (_a = observers.get(this))[method].apply(_a, arguments);
        };
      });

      var index = function () {
        // Export existing implementation if available.
        if (typeof global$1.ResizeObserver !== 'undefined') {
          return global$1.ResizeObserver;
        }

        return ResizeObserver;
      }();

      return index;
    });
  });

  var nextID = 0; // Remove namespace from global options

  var cleanOption = function cleanOption(name) {
    name = name.replace('coral', '');
    return name.charAt(0).toLowerCase() + name.slice(1);
  }; // Threshold time in milliseconds that the setTimeout will wait for the transitionEnd event to be triggered.


  var TRANSITION_DURATION_THRESHOLD = 100; // Based on jQuery's :focusable selector

  var FOCUSABLE_ELEMENTS = ['input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'a[href]', 'area[href]', 'summary', 'iframe', 'object', 'embed', 'audio[controls]', 'video[controls]', '[contenteditable]', '[tabindex]']; // To support Coral.commons.ready and differentiate lightweight tags from defined elements

  var CORAL_COMPONENTS = [];
  /**
   Converts CSS time to milliseconds. It supports both s and ms units. If the provided value has an unrecogenized unit,
   zero will be returned.

   @private
   @param {String} time
   The time string to convert to milliseconds.
   @returns {Number} the time in milliseconds.
   */

  function cssTimeToMilliseconds(time) {
    var num = parseFloat(time, 10);
    var unit = time.match(/m?s/);

    if (unit) {
      unit = unit[0];
    }

    if (unit === 's') {
      return num * 1000;
    } else if (unit === 'ms') {
      return num;
    } // unrecognized unit, so we return 0


    return 0;
  }
  /**
   @private

   @param first
   @param second
   @return {Function}
   */


  function returnFirst(first, second) {
    // eslint-disable-next-line func-names
    return function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var ret = first.apply(this, args);
      second.apply(this, args);
      return ret;
    };
  }
  /**
   Check if the provided object is a function

   @ignore

   @param {*} object
   The object to test

   @returns {Boolean} Whether the provided object is a function.
   */


  function isFunction(object) {
    return typeof object === 'function';
  }
  /**
   Utility belt.
   */


  var Commons = /*#__PURE__*/function () {
    /** @ignore */
    function Commons() {
      var _this = this;

      _classCallCheck(this, Commons);

      // Create a Map to link elements to observe to their resize event callbacks
      this._resizeObserverMap = new Map();
      this._resizeObserver = new ResizeObserver(function (entries) {
        for (var i = 0; i < entries.length; i++) {
          var observedElement = entries[i].target;

          var allCallbacks = _this._resizeObserverMap.get(observedElement);

          if (allCallbacks) {
            for (var j = 0; j < allCallbacks.length; j++) {
              allCallbacks[j].call(observedElement);
            }
          }
        }
      });
      var focusableElements = FOCUSABLE_ELEMENTS.slice();
      this._focusableElementsSelector = focusableElements.join(',');
      focusableElements[focusableElements.length - 1] += ':not([tabindex="-1"])';
      this._tabbableElementsSelector = focusableElements.join(':not([tabindex="-1"]),');
      this._coralSelector = ''; // @IE11

      if (!document.currentScript) {
        var scripts = document.getElementsByTagName('script');
        this._script = scripts[scripts.length - 1];
      } else {
        this._script = document.currentScript;
      }
    }
    /**
     Returns Coral global options retrieved on the <code><script></code> data attributes including:
     - <code>[data-coral-icons]</code>: source folder of the SVG icons. If the icon collections have a custom name,
     they have to be loaded manually using {@link Icon.load}.
     - <code>[data-coral-icons-external]</code>: Whether SVG icons are always referenced as external resource. Possible values are "on" (default), "off" or "js" to load icons from a script.
     - <code>[data-coral-typekit]</code>: custom typekit id used to load the fonts.
     - <code>[data-coral-logging]</code>: defines logging level. Possible values are "on" (default) or "off".
      @returns {Object}
     The global options object.
     */


    _createClass(Commons, [{
      key: "_log",

      /**
       Utility function for logging.
        @param {String} level
       Logging level
       @param {String} args
       Logging message
       */
      value: function _log(level) {
        if (console[level] && this.options.logging !== 'off') {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }

          console[level].apply(null, args);
        }
      }
      /**
       Copy the properties from all provided objects into the first object.
        @param {Object} dest
       The object to copy properties to
       @param {...Object} source
       An object to copy properties from. Additional objects can be passed as subsequent arguments.
        @returns {Object}
       The destination object, <code>dest</code>
       */

    }, {
      key: "extend",
      value: function extend() {
        var dest = arguments.length <= 0 ? undefined : arguments[0];

        for (var i = 1, ni = arguments.length; i < ni; i++) {
          var source = i < 0 || arguments.length <= i ? undefined : arguments[i];

          for (var prop in source) {
            dest[prop] = source[prop];
          }
        }

        return dest;
      }
      /**
       Copy the properties from the source object to the destination object, but calls the callback if the property is
       already present on the destination object.
        @param {Object} dest
       The object to copy properties to
       @param {...Object} source
       An object to copy properties from. Additional objects can be passed as subsequent arguments.
       @param {CommonsHandleCollision} [handleCollision]
       Called if the property being copied is already present on the destination.
       The return value will be used as the property value.
        @returns {Object}
       The destination object, <code>dest</code>
       */

    }, {
      key: "augment",
      value: function augment() {
        var dest = arguments.length <= 0 ? undefined : arguments[0];
        var handleCollision;
        var argCount = arguments.length;
        var lastArg = argCount - 1 < 0 || arguments.length <= argCount - 1 ? undefined : arguments[argCount - 1];

        if (typeof lastArg === 'function') {
          handleCollision = lastArg; // Don't attempt to augment using the last argument

          argCount--;
        }

        for (var i = 1; i < argCount; i++) {
          var source = i < 0 || arguments.length <= i ? undefined : arguments[i];

          for (var prop in source) {
            if (typeof dest[prop] !== 'undefined') {
              if (typeof handleCollision === 'function') {
                // Call the handleCollision callback if the property is already present
                var ret = handleCollision(dest[prop], source[prop], prop, dest, source);

                if (typeof ret !== 'undefined') {
                  dest[prop] = ret;
                }
              } // Otherwise, do nothing

            } else {
              dest[prop] = source[prop];
            }
          }
        }

        return dest;
      }
      /**
       Return a new object with the swapped keys and values of the provided object.
        @param {Object} obj
       The object to copy.
        @returns {Object}
       An object with its keys as the values and values as the keys of the source object.
       */

    }, {
      key: "swapKeysAndValues",
      value: function swapKeysAndValues(obj) {
        var map = {};

        for (var key in obj) {
          map[obj[key]] = key;
        }

        return map;
      }
      /**
       Execute the provided callback on the next animation frame.
        @param {Function} onNextFrame
       The callback to execute.
       */

    }, {
      key: "nextFrame",
      value: function nextFrame(onNextFrame) {
        return window.requestAnimationFrame(function () {
          if (typeof onNextFrame === 'function') {
            onNextFrame();
          }
        });
      }
      /**
       Execute the provided callback once a CSS transition has ended. This method listens for the next transitionEnd event
       on the given DOM element. In case the provided element does not have a transition defined, the callback will be
       called in the next macrotask to allow a normal application execution flow. It cannot be used to listen continuously
       on transitionEnd events.
       @param {HTMLElement} element
       The DOM element that is affected by the CSS transition.
       @param {CommonsTransitionEndCallback} onTransitionEndCallback
       The callback to execute.
       */

    }, {
      key: "transitionEnd",
      value: function transitionEnd(element, onTransitionEndCallback) {
        var propertyName;
        var hasTransitionEnded = false;
        var transitionEndEventName = null;
        var transitions = {
          transition: 'transitionend',
          WebkitTransition: 'webkitTransitionEnd',
          MozTransition: 'transitionend',
          MSTransition: 'msTransitionEnd'
        };
        var transitionEndTimeout = null;

        var onTransitionEnd = function onTransitionEnd(event) {
          var transitionStoppedByTimeout = typeof event === 'undefined';

          if (!hasTransitionEnded) {
            hasTransitionEnded = true;
            clearTimeout(transitionEndTimeout); // Remove event listener (if any was used by the current browser)

            element.removeEventListener(transitionEndEventName, onTransitionEnd); // Call callback with specified element

            onTransitionEndCallback({
              target: element,
              cssTransitionSupported: true,
              transitionStoppedByTimeout: transitionStoppedByTimeout
            });
          }
        }; // Find transitionEnd event name used by browser


        for (propertyName in transitions) {
          if (element.style[propertyName] !== undefined) {
            transitionEndEventName = transitions[propertyName];
            break;
          }
        }

        if (transitionEndEventName !== null) {
          var timeoutDelay = 0; // Gets the animation time (in milliseconds) using the computed style

          var transitionDuration = cssTimeToMilliseconds(window.getComputedStyle(element).transitionDuration); // We only setup the event listener if there is a valid transition

          if (transitionDuration !== 0) {
            // Register on transitionEnd event
            element.addEventListener(transitionEndEventName, onTransitionEnd); // As a fallback we use the transitionDuration plus a threshold. This can happen in IE10/11 where
            // transitionEnd events are sometimes skipped

            timeoutDelay = transitionDuration + TRANSITION_DURATION_THRESHOLD;
          } // Fallback in case the event does not trigger (IE10/11) or if the element does not have a valid transition


          transitionEndTimeout = window.setTimeout(onTransitionEnd, timeoutDelay);
        }
      }
      /**
       Register a Coral component as Custom Element V1
        @param {String} name
       Custom element namespace
       @param {Function} constructor
       Constructor for the custom element
       @param {Object} options
       E.g for built-in custom elements
       */

    }, {
      key: "_define",
      value: function _define(name, constructor, options) {
        window.customElements.define(name, constructor, options);
        CORAL_COMPONENTS.push(name);
      }
      /**
       Checks if Coral components and all nested Coral components are defined as Custom Elements.
        @param {HTMLElement} element
       The element that should be watched.
       @param {CommonsReadyCallback} onDefined
       The callback to call when all components are ready.
        @see https://developer.mozilla.org/en-US/docs/Web/Web_Components/Custom_Elements
       */

    }, {
      key: "ready",
      value: function ready(element, onDefined) {
        var root = element;

        if (typeof element === 'function') {
          onDefined = element;
          root = document.body;
        }

        if (!root) {
          root = document.body;
        }

        if (!(root instanceof HTMLElement)) {
          // commons.ready should not be blocking by default
          onDefined(root);
          return;
        } // @todo use ':not(:defined)' once supported ?


        this._coralSelector = this._coralSelector || CORAL_COMPONENTS.join(',');
        var elements = root.querySelectorAll(this._coralSelector); // Holds promises that resolve when the elements is defined

        var promises = []; // Don't forget to check root

        if (root !== document.body && !root._componentReady && root.matches(this._coralSelector)) {
          var name = (root.getAttribute('is') || root.tagName).toLowerCase();
          promises.push(window.customElements.whenDefined(name));
        } // Check all descending elements


        for (var i = 0; i < elements.length; i++) {
          var el = elements[i];

          if (!el._componentReady) {
            var _name = (el.getAttribute('is') || el.tagName).toLowerCase();

            promises.push(window.customElements.whenDefined(_name));
          }
        } // Call callback once all defined


        if (promises.length) {
          Promise.all(promises).then(function () {
            onDefined(element instanceof HTMLElement && element || window);
          }).catch(function (err) {
            console.error(err);
          });
        } else {
          // Call callback by default if all defined already
          onDefined(element instanceof HTMLElement && element || window);
        }
      }
      /**
       Assign an object given a nested path
        @param {Object} root
       The root object on which the path should be traversed.
       @param {String} path
       The path at which the object should be assignment.
       @param {String} obj
       The object to assign at path.
        @throws Will throw an error if the path is not present on the object.
       */

    }, {
      key: "setSubProperty",
      value: function setSubProperty(root, path, obj) {
        var nsParts = path.split('.');
        var curObj = root;

        if (nsParts.length === 1) {
          // Assign immediately
          curObj[path] = obj;
          return;
        } // Make sure we can assign at the requested location


        while (nsParts.length > 1) {
          var part = nsParts.shift();

          if (curObj[part]) {
            curObj = curObj[part];
          } else {
            throw new Error("Coral.commons.setSubProperty: could not set ".concat(path, ", part ").concat(part, " not found"));
          }
        } // Do the actual assignment


        curObj[nsParts.shift()] = obj;
      }
      /**
       Get the value of the property at the given nested path.
        @param {Object} root
       The root object on which the path should be traversed.
       @param {String} path
       The path of the sub-property to return.
        @returns {*}
       The value of the provided property.
        @throws Will throw an error if the path is not present on the object.
       */

    }, {
      key: "getSubProperty",
      value: function getSubProperty(root, path) {
        var nsParts = path.split('.');
        var curObj = root;

        if (nsParts.length === 1) {
          // Return property immediately
          return curObj[path];
        } // Make sure we can assign at the requested location


        while (nsParts.length) {
          var part = nsParts.shift(); // The property might be undefined, and that's OK if it's the last part

          if (nsParts.length === 0 || typeof curObj[part] !== 'undefined') {
            curObj = curObj[part];
          } else {
            throw new Error("Coral.commons.getSubProperty: could not get ".concat(path, ", part ").concat(part, " not found"));
          }
        }

        return curObj;
      }
      /**
       Apply a mixin to the given object.
        @param {Object} target
       The object to apply the mixin to.
       @param {Object|Function} mixin
       The mixin to apply.
       @param {Object} options
       An object to pass to functional mixins.
       */

    }, {
      key: "_applyMixin",
      value: function _applyMixin(target, mixin, options) {
        var mixinType = _typeof(mixin);

        if (mixinType === 'function') {
          mixin(target, options);
        } else if (mixinType === 'object' && mixin !== null) {
          this.extend(target, mixin);
        } else {
          throw new Error("Coral.commons.mixin: Cannot mix in ".concat(mixinType, " to ").concat(target.toString()));
        }
      }
      /**
       Mix a set of mixins to a target object.
        @private
        @param {Object} target
       The target prototype or instance on which to apply mixins.
       @param {Object|CoralMixin|Array<Object|CoralMixin>} mixins
       A mixin or set of mixins to apply.
       @param {Object} options
       An object that will be passed to functional mixins as the second argument (options).
       */

    }, {
      key: "mixin",
      value: function mixin(target, mixins, options) {
        if (Array.isArray(mixins)) {
          for (var i = 0; i < mixins.length; i++) {
            this._applyMixin(target, mixins[i], options);
          }
        } else {
          this._applyMixin(target, mixins, options);
        }
      }
      /**
       Get a unique ID.
        @returns {String} unique identifier.
       */

    }, {
      key: "getUID",
      value: function getUID() {
        return "coral-id-".concat(nextID++);
      }
      /**
       Call all of the provided functions, in order, returning the return value of the specified function.
        @param {...Function} func
       A function to call
       @param {Number} [nth=0]
       A zero-based index indicating the noth argument to return the value of.
       If the nth argument is not a function, <code>null</code> will be returned.
        @returns {Function} The aggregate function.
       */

    }, {
      key: "callAll",
      value: function callAll() {
        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }

        var nth = args[args.length - 1];

        if (typeof nth !== 'number') {
          nth = 0;
        } // Get the function whose value we should return


        var funcToReturn = args[nth]; // Only use arguments that are functions

        var functions = Array.prototype.filter.call(args, isFunction);

        if (functions.length === 2 && nth === 0) {
          // Most common usecase: two valid functions passed
          return returnFirst(functions[0], functions[1]);
        } else if (functions.length === 1) {
          // Common usecase: one valid function passed
          return functions[0];
        } else if (functions.length === 0) {
          return function () {// Fail case: no valid functions passed
          };
        }

        if (typeof funcToReturn !== 'function') {
          // If the argument at the provided index wasn't a function, just return the value of the first valid function
          funcToReturn = functions[0];
        } // eslint-disable-next-line func-names


        return function () {
          var finalRet;
          var ret;
          var func; // Skip first arg

          for (var i = 0; i < functions.length; i++) {
            func = functions[i];
            ret = func.apply(this, args); // Store return value of desired function

            if (func === funcToReturn) {
              finalRet = ret;
            }
          }

          return finalRet;
        };
      }
      /**
       Adds a resize listener to the given element.
        @param {HTMLElement} element
       The element to add the resize event to.
       @param {Function} onResize
       The resize callback.
       */
      // eslint-disable-next-line func-names

    }, {
      key: "addResizeListener",
      value: function addResizeListener(element, onResize) {
        // Map callback to element
        if (!this._resizeObserverMap.has(element)) {
          this._resizeObserverMap.set(element, []);
        }

        this._resizeObserverMap.get(element).push(onResize); // Observe element resize events


        this._resizeObserver.observe(element);
      }
      /**
       Removes a resize listener from the given element.
        @param {HTMLElement} element
       The element to remove the resize event from.
       @param {Function} onResize
       The resize callback.
       */
      // eslint-disable-next-line func-names

    }, {
      key: "removeResizeListener",
      value: function removeResizeListener(element, onResize) {
        // Stop observing element resize events
        this._resizeObserver.unobserve(element);

        this._resizeObserver.disconnect(element); // Remove event from map


        var onResizeEvents = this._resizeObserverMap.get(element);

        if (onResizeEvents) {
          var index = onResizeEvents.indexOf(onResize);

          if (index !== -1) {
            onResizeEvents.splice(index, 1);
          }
        }
      }
      /**
       Caution: the selector doesn't verify if elements are visible.
        @type {String}
       @readonly
       @see https://www.w3.org/TR/html5/editing.html#focus-management
       */

    }, {
      key: "options",
      get: function get() {
        var options = {};
        var props = this._script.dataset;

        for (var key in props) {
          // Detect Coral namespaced options
          if (key.indexOf('coral') === 0) {
            options[cleanOption(key)] = props[key];
          }
        }

        return options;
      }
    }, {
      key: "FOCUSABLE_ELEMENT_SELECTOR",
      get: function get() {
        return this._focusableElementsSelector;
      }
      /**
       Caution: the selector doesn't verify if elements are visible.
        @type {String}
       @readonly
       @see https://www.w3.org/TR/html5/editing.html#sequential-focus-navigation-and-the-tabindex-attribute
       */

    }, {
      key: "TABBABLE_ELEMENT_SELECTOR",
      get: function get() {
        return this._tabbableElementsSelector;
      }
    }]);

    return Commons;
  }();
  /**
   Called when a property already exists on the destination object.

   @typedef {function} CommonsHandleCollision

   @param {*} oldValue
   The value currently present on the destination object.
   @param {*} newValue
   The value on the destination object.
   @param {*} prop
   The property that collided.
   @param {*} dest
   The destination object.
   @param {*} source
   The source object.

   @returns {*} The value to use. If <code>undefined</code>, the old value will be used.
   */

  /**
   Execute the callback once a CSS transition has ended.

   @typedef {function} CommonsTransitionEndCallback

   @param event
   The event passed to the callback.
   @param {HTMLElement} event.target
   The DOM element that was affected by the CSS transition.
   @param {Boolean} event.cssTransitionSupported
   Whether CSS transitions are supported by the browser.
   @param {Boolean} event.transitionStoppedByTimeout
   Whether the CSS transition has been ended by a timeout (should only happen as a fallback).
   */

  /**
   Execute the callback once a component and sub-components are ready. See {@link Commons.ready}.

   @typedef {function} CommonsReadyCallback
   @param {HTMLElement} element
   The element that is ready.
   */

  /**
   A functional mixin.

   @typedef {Object} CoralMixin

   @private

   @param {Object} target
   The target prototype or instance to apply the mixin to.
   @param {Object} options
   Options for this mixin.
   @param {Coral~PropertyDescriptor.properties} options.properties
   The properties object as passed to <code>Coral.register</code>. This can be modified in place.
   */

  /**
   A utility belt.

   @type {Commons}
   */


  var commons = new Commons();

  /**
   Events helper.
   */

  var Events = /*#__PURE__*/function () {
    /**
     @param {HTMLElement|String} elementOrSelector
     The element or selector indicating the element to use as the delegation root.
     */
    function Events(elementOrSelector) {
      _classCallCheck(this, Events);

      this._vent = new vent(elementOrSelector);
    }
    /**
     Add an event listener.
      @param {String} eventName
     The event name to listen for, including optional namespace(s).
     @param {String} [selector]
     The selector to use for event delegation.
     @param {Function} handler
     The function that will be called when the event is fired.
     @param {Boolean} [useCapture]
     Whether or not to listen during the capturing or bubbling phase.
     @returns {Events} this, chainable.
     */


    _createClass(Events, [{
      key: "on",
      value: function on(eventName, selector, handler, useCapture) {
        this._vent.on(eventName, selector, handler, useCapture);

        return this;
      }
      /**
       Remove an event listener.
        @param {String} [eventName]
       The event name to stop listening for, including optional namespace(s).
       @param {String} [selector]
       The selector that was used for event delegation.
       @param {Function} [handler]
       The function that was passed to <code>on()</code>.
       @param {Boolean} [useCapture]
       Only remove listeners with <code>useCapture</code> set to the value passed in.
       @returns {Event} this, chainable.
       */

    }, {
      key: "off",
      value: function off(eventName, selector, handler, useCapture) {
        this._vent.off(eventName, selector, handler, useCapture);

        return this;
      }
      /**
       Dispatch a custom event at the root element.
        @param {String} eventName
       The name of the event to dispatch.
       @param {Object} [options]
       CustomEvent options.
       @param {Object} [options.bubbles=true]
       Whether the event should bubble.
       @param {Object} [options.cancelable=true]
       Whether the event should be cancelable.
       @param {Object} [options.detail]
       Data to pass to handlers as <code>event.detail</code>
       @returns {CustomEvent} dispatched event.
       */

    }, {
      key: "dispatch",
      value: function dispatch(eventName, options) {
        return this._vent.dispatch(eventName, options);
      }
      /**
       Destroy this instance, removing all events and references.
       */

    }, {
      key: "destroy",
      value: function destroy() {
        this._vent.destroy();
      }
    }]);

    return Events;
  }();
  /**
   An enhanced event helper.

   @type {Events}
   */


  var events = new Events(window);

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var typeKitId = commons && commons.options.typekit;

  if (!typeKitId) {
    // On pageload, determine to current pages language setting.
    // If it is english language or unset use the 1st Adobe font web project id (smaller size),
    // otherwise use the 2nd kit with all the language settings (larger size)
    typeKitId = document.querySelector('[lang]:not([lang^="en"])') === null ? 'mge7bvf' : 'rok6rmo';
  }

  var config = {
    kitId: typeKitId,
    scriptTimeout: 3000,
    active: function active() {
      events.dispatch('coral-commons:_webfontactive');
    }
  };

  if (!window.Typekit) {
    // we load the typescript only once
    var h = document.getElementsByTagName('html')[0];
    h.classList.add('wf-loading');
    var t = window.setTimeout(function () {
      h.classList.remove('wf-loading');
      h.classList.add('wf-inactive');
    }, config.scriptTimeout);
    var tk = document.createElement('script');
    var d = false; // Always load over https

    tk.src = "https://use.typekit.net/".concat(config.kitId, ".js");
    tk.type = 'text/javascript';
    tk.async = 'true';

    tk.onload = tk.onreadystatechange = function () {
      var a = this.readyState;

      if (d || a && a !== 'complete' && a !== 'loaded') {
        return;
      }

      d = true;
      clearTimeout(t);

      try {
        window.Typekit.load(config);
      } catch (b) {}
    };

    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(tk, s);
  } else {
    // If Typekit is loaded externally, listen with a MO for active fonts
    var root = document.documentElement;

    if (root.className.indexOf('wf-inactive') !== -1 || root.className.indexOf('wf-loading') !== -1) {
      var webFontLoadObserver = new MutationObserver(function () {
        if (root.className.indexOf('wf-active') !== -1) {
          webFontLoadObserver.disconnect();
          events.dispatch('coral-commons:_webfontactive');
        }
      }); // Watch for class changes

      webFontLoadObserver.observe(root, {
        attributes: true,
        attributeFilter: ['class']
      });
    }
  }

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   Enumeration for {@link i18n} locales.

   @typedef {Object} I18nLocalesEnum

   @property {String} en
   English (U.S.)
   @property {String} en-us
   English (U.S.)
   @property {String} cs
   Czech (Czechia)
   @property {String} cs-cz
   Czech (Czechia)
   @property {String} da
   Danish (Denmark)
   @property {String} da-dk
   Danish (Denmark)
   @property {String} de
   German (Germany)
   @property {String} de-de
   German (Germany)
   @property {String} es
   Spanish (Spain)
   @property {String} es-es
   Spanish (Spain)
   @property {String} fi
   Finnish (Finland)
   @property {String} fi-fi
   Finnish (Finland)
   @property {String} fr
   French (France)
   @property {String} fr-fr
   French (France)
   @property {String} it
   Italian (Italy)
   @property {String} it-it
   Italian (Italy)
   @property {String} ja
   Japanese (Japan)
   @property {String} ja-jp
   Japanese (Japan)
   @property {String} ko
   Korean (Korea)
   @property {String} ko-kr
   Korean (Korea)
   @property {String} nb
   Norwegian BokmÃ¥l (Norway)
   @property {String} nb-no
   Norwegian BokmÃ¥l (Norway)
   @property {String} nl
   Dutch (Netherlands)
   @property {String} nl-nl
   Dutch (Netherlands)
   @property {String} pl
   Polish (Poland)
   @property {String} pl-pl
   Polish (Poland)
   @property {String} pt
   Portuguese (Brazil)
   @property {String} pt-br
   Portuguese (Brazil)
   @property {String} ru
   Russian (Russia)
   @property {String} ru-ru
   Russian (Russia)
   @property {String} sv
   Swedish (Sweden)
   @property {String} sv-se
   Swedish (Sweden)
   @property {String} tr
   Turkish (Turkey)
   @property {String} tr-tr
   Turkish (Turkey)
   @property {String} zh-cn
   Simplified Chinese
   @property {String} zh-hans-cn
   Simplified Chinese
   @property {String} zh-hans
   Simplified Chinese
   @property {String} zh-tw
   Traditional Chinese
   @property {String} zh-hant-tw
   Traditional Chinese
   @property {String} zh-hant
   Traditional Chinese
   */
  var locales = {
    'en': 'en-US',
    'en-us': 'en-US',
    'cs': 'cs-CZ',
    'cs-cz': 'cs-CZ',
    'da': 'da-DK',
    'da-dk': 'da-DK',
    'de': 'de-DE',
    'de-de': 'de-DE',
    'es': 'es-ES',
    'es-es': 'es-ES',
    'fi': 'fi-FI',
    'fi-fi': 'fi-FI',
    'fr': 'fr-FR',
    'fr-fr': 'fr-FR',
    'it': 'it-IT',
    'it-it': 'it-IT',
    'ja': 'ja-JP',
    'ja-jp': 'ja-JP',
    'ko': 'ko-KR',
    'ko-kr': 'ko-KR',
    'nb': 'nb-NO',
    'nb-no': 'nb-NO',
    'nl': 'nl-NL',
    'pl': 'pl-PL',
    'pl-pl': 'pl-PL',
    'nl-nl': 'nl-NL',
    'pt': 'pt-BR',
    'pt-br': 'pt-BR',
    'ru': 'ru-RU',
    'ru-ru': 'ru-RU',
    'sv': 'sv-SE',
    'sv-se': 'sv-SE',
    'tr': 'tr-TR',
    'tr-tr': 'tr-TR',
    'zh-cn': 'zh-CN',
    'zh-hans-cn': 'zh-CN',
    'zh-hans': 'zh-CN',
    'zh-tw': 'zh-TW',
    'zh-hant-tw': 'zh-TW',
    'zh-hant': 'zh-TW'
  };
  /**
   Used to store i18n strings.

   @type {Object}
   @property {String} strings.generic
   */

  var strings = {
    generic: {}
  };
  /**
   I18n service to get/set localized strings.
   */

  var I18nProvider = /*#__PURE__*/function () {
    /**
     @param {Object} [options]
     Options for this combo handler.
     @param {String} [options.locale]
     The <code>locale</code> property defines the locale of the I18nProvider.
     */
    function I18nProvider(options) {
      _classCallCheck(this, I18nProvider);

      options = options || {}; // Default locale

      this._locale = 'en-US';

      if (options.locale) {
        this._locale = options.locale;
      }

      this._evaluate = /(\{.+?\})/g;
    }
    /**
     Sets a localized string.
      @param {String} key the key to set
     @param {String} value the value associated with the given key.
     @example
     Coral.i18n.set('English string', 'Translated string');
     Coral.i18n.set('English string: {0}', 'Translated string: {0}');
     Coral.i18n.set('English string: {0}, {1}, and {2}', 'Translated string: {2}, {0}, and {1}');
     Coral.i18n.set('English string: {name}', 'Translated string: {name}');
     Coral.i18n.set('English string: {name1}, {name2}, and {name3}', 'Translated string: {name3}, {name1}, and {name2}');
     */

    /**
     Sets multiple localized strings.
      @param {Array<String, String>} map  a key-value map to add to the strings dictionary.
     @example
     Coral.i18n.set([
     ['English string 1', 'Translated string 1'],
     ['English string 2', 'Translated string 2'],
     ['English string 1 with {0} items','Translated string 1 with {0} items'],
     ['English string 2 with {0} items','Translated string 2 with {0} items'],
     ['English string 1: {0}, {1}, and {2}','Translated string 1: {2}, {0}, and {1}'],
     ['English string 2: {0}, {1}, and {2}','Translated string 2: {2}, {0}, and {1}'],
     ['English string 1: {name}', 'Translated string 1: {name}'],
     ['English string 2: {name}', 'Translated string 2: {name}'],
     ['English string 1: {name1}, {name2}, and {name3}', 'Translated string 1: {name3}, {name1}, and {name2}'],
     ['English string 2: {name1}, {name2}, and {name3}', 'Translated string 2: {name3}, {name1}, and {name2}']
     ]);
     */

    /**
     Sets a localized string, using translation hint.
      @param {String} key the key to set
     @param {String} value the value associated with the given key.
     @param {String} translation_hint the translation hint associated with the given key.
     @example
     Coral.i18n.set('English string', 'Translated string 1', 'Translation hint 1');
     Coral.i18n.set('English string', 'Translated string 2', 'Translation hint 2');
     Coral.i18n.set('English string with {0} items' , 'Translated string 1 with {0} items', 'Translation hint 1');
     Coral.i18n.set('English string with {0} items' , 'Translated string 2 with {0} items', 'Translation hint 2');
     Coral.i18n.set('English string: {0}, {1}, and {2}', 'Translated string 1: {2}, {0}, and {1}', 'Translation hint 1');
     Coral.i18n.set('English string: {0}, {1}, and {2}', 'Translated string 2: {2}, {0}, and {1}', 'Translation hint 2');
     Coral.i18n.set('English string: {name}', 'Translated string 1: {name}', 'Translation hint 1');
     Coral.i18n.set('English string: {name}', 'Translated string 2: {name}', 'Translation hint 2');
     Coral.i18n.set('English string: {name1}, {name2}, and {name3}', 'Translated string 1: {name3}, {name1}, and {name2}', 'Translation hint 1');
     Coral.i18n.set('English string: {name1}, {name2}, and {name3}', 'Translated string 2: {name3}, {name1}, and {name2}', 'Translation hint 2');
     */

    /**
     Sets multiple localized strings, using translation hints.
      @param {Array<String, String, String>} map
     A key-value object map to add to the strings dictionary.
     @example
     Coral.i18n.set([
     ['English string', 'Translated string 1', 'Translation hint 1'],
     ['English string', 'Translated string 2', 'Translation hint 2'],
     ['English string with {0} items', 'Translated string 1 with {0} items', 'Translation hint 1'],
     ['English string with {0} items', 'Translated string 2 with {0} items', 'Translation hint 2'],
     ['English string with {0}, {1} and {2} items', 'Translated string 1 with {0}, {1} and {2} items', 'Translation hint 1'],
     ['English string with {0}, {1} and {2} items', 'Translated string 2 with {0}, {1} and {2} items', 'Translation hint 2'],
     ['English string: {name}', 'Translated string 1: {name}', 'Translation hint 1'],
     ['English string: {name}', 'Translated string 2: {name}', 'Translation hint 2'],
     ['English string: {name1}, {name2}, and {name3}', 'Translated string 1: {name3}, {name1}, and {name2}', 'Translation hint 1'],
     ['English string: {name1}, {name2}, and {name3}', 'Translated string 2: {name3}, {name1}, and {name2}', 'Translation hint 2']
     ]);
     */
    // eslint-disable-next-line func-names


    _createClass(I18nProvider, [{
      key: "set",
      value: function set() {
        strings.generic[this._locale] = strings.generic[this._locale] || {};
        var key, value, translationHint;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        if (args.length === 0) {
          // Return empty string if called without arguments
          return '';
        } else if (args.length === 1) {
          if (!args[0]) {
            throw new Error('Coral.i18n.set: Single argument must be an array of arrays of key/value/(translation hint).');
          } // multiple keys
          else if (_typeof(args[0]) === 'object' && _typeof(args[0][0]) === 'object') {
              for (var i = 0; i < args[0].length; i++) {
                key = args[0][i][0];
                value = args[0][i][1];
                translationHint = args[0][i][2];

                if (translationHint) {
                  key = "".concat(key, "/[translation hint:").concat(translationHint.replace(/&period;/g, '.'), "]");
                }

                strings.generic[this._locale][key] = value;
              }
            } else {
              throw new Error('Coral.i18n.set: Single argument must be an array of key-value pairs.');
            }
        } // single key, no translation hint
        else if (args.length === 2) {
            if (typeof args[0] === 'string' && !!args[0] && typeof args[1] === 'string' && !!args[1]) {
              key = args[0];
              value = args[1];
              strings.generic[this._locale][key] = value;
            } else {
              throw new Error('Coral.i18n.set: Both arguments must be non-empty string values.');
            }
          } // single key, with translation hint
          else if (args.length === 3) {
              if (typeof args[0] === 'string' && typeof args[1] === 'string' && typeof args[2] === 'string') {
                key = args[0];
                value = args[1];
                translationHint = args[2];

                if (translationHint !== 'null') {
                  key = "".concat(key, "/[translation hint:").concat(translationHint.replace(/&period;/g, '.'), "]");
                }

                strings.generic[this._locale][key] = value;
              } else {
                throw new Error('Coral.i18n.set: All arguments must be of string type.');
              }
            } else {
              throw new Error('Coral.i18n.set: Too many arguments provided.');
            }

        return this;
      }
      /**
       Gets a localized string, using named arguments, and translation hint.
        @param {String} key the key of the string to retrieve
       @param {Object} args one more named arguments
       @param {String} translation_hint context information for translators
       @returns {String} the localized string with arguments
       @example
       Coral.i18n.get('English string: {name}', { name: 'foo' }, 'Translation hint 1'); // => 'Translated string 1: foo'
       Coral.i18n.get('English string: {name}', { name: 'foo' }, 'Translation hint 2'); // => 'Translated string 2: foo'
       Coral.i18n.get('English string: {name1}, {name2}, and {name3}', { name1: 'foo', name2: 'bar', name3: 'qux' }, 'Translation hint 1'); // => 'Translated string 1: qux, foo, and bar'
       Coral.i18n.get('English string: {name1}, {name2}, and {name3}', { name1: 'foo', name2: 'bar', name3: 'qux' }, 'Translation hint 2'); // => 'Translated string 2: qux, foo, and bar'
       */

      /**
       Gets a localized string, using arguments, and translation hint.
        @param {String} key the key of the string to retrieve
       @param {String} args one more arguments
       @param {String} translation_hint context information for translators
       @returns {String} the localized string with arguments
       @example
       Coral.i18n.get('English string: {0}', 10, 'Translation hint 1'); // => 'Translated string 1: 10')
       Coral.i18n.get('English string: {0}', 10, 'Translation hint 2'); // => 'Translated string 2: 10')
       Coral.i18n.get('English string: {0}, {1}, and {2}', 10, 20, 30, 'Translation hint 1'); // => 'Translated string 1: 30, 10, and 20'
       Coral.i18n.get('English string: {0}, {1}, and {2}', 10, 20, 30, 'Translation hint 2'); // => 'Translated string 2: 30, 10, and 20'
       */

      /**
       Gets a localized string, using translation hint.
        @param {String} key the key of the string to retrieve
       @param {String} translation_hint context information for translators
       @returns {String} the localized string
       @example
       Coral.i18n.get('English string', 'Translation hint 1'); // => 'Translated string 1'
       Coral.i18n.get('English string', 'Translation hint 2'); // => 'Translated string 2'
       */

      /**
       Gets a localized string, using named arguments.
        @param {String} key the key of the string to retrieve
       @param {Object} args one more named arguments
       @returns {String} the localized string with arguments
       @example
       Coral.i18n.get('English string: {name}', { name: 'foo' }); // => 'Translated string: foo'
       Coral.i18n.get('English string: {name1}, {name2}, and {name3}', { name1: 'foo', name2: 'bar', name3: 'qux' }); // => 'Translated string: qux, foo, and bar'
       */

      /**
       Gets a localized string, using arguments.
        @param {String} key the key of the string to retrieve
       @param {String} args one more arguments
       @returns {String} the localized string with arguments
       @example
       Coral.i18n.get('English string: {0}', 10); // => 'Translated string: 10'
       Coral.i18n.get('English string: {0}, {1}, and {2}', 10, 20, 30); // => 'Translated string: 30, 10, and 20'
       */

      /**
       Gets a localized string.
        @param {String} key the key of the string to retrieve
       @returns {String} the localized string
       @example
       Coral.i18n.get('English string'); // => 'Translated String'
       */
      // eslint-disable-next-line func-names

    }, {
      key: "get",
      value: function get() {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        if (args.length === 0) {
          // Return empty string if called without arguments
          return '';
        } // The first argument is always the key
        // Aladdin server stores periods in keys as HTML entities, so we need to match this


        var key = args[0].replace('.', '&period;'); // The number of required variables can be determined by parsing the string

        var placeholderMatches = key.match(this._evaluate);
        var variablePlaceholderCount = placeholderMatches ? placeholderMatches.length : 0; // The hint we'll use to translate

        var translationHint = '';
        var variables = {};
        var variableCount = 0;
        var i; // Verify the number of provided arguments matches the placeholder count

        if (args[1] !== null && _typeof(args[1]) === 'object') {
          variables = args[1]; // Check if provided variables object is complete

          var placeholderName = '';

          for (i = 0; i < placeholderMatches.length; i++) {
            placeholderName = placeholderMatches[i].slice(1).slice(0, -1);

            if (variables[placeholderName] === null || typeof variables[placeholderName] === 'undefined') {
              throw new Error("Coral.i18n.get: Named key \"".concat(placeholderName, "\" not present in provided object."));
            }
          } // If an additional argument is present, it's the translation hint


          if (typeof args[2] === 'string') {
            translationHint = args[2];
          }
        } else {
          // Assume no translation hint
          variableCount = args.length - 1;

          if (variableCount === variablePlaceholderCount + 1) {
            // If we've got an extra argument, assume it's a translation hint
            translationHint = args[args.length - 1];
          } else if (variableCount !== variablePlaceholderCount) {
            throw new Error("Coral.i18n.get: Number of variable placeholders (".concat(variablePlaceholderCount, ") does not match number of variables (").concat(variableCount, ")."));
          } // Build variables object


          for (i = 0; i < variableCount; i++) {
            variables[i] = args[i + 1];
          }
        } // Include translation hint


        if (translationHint) {
          key = "".concat(key, "/[translation hint:").concat(translationHint, "]");
        } // Fetch the string


        var str = key;

        for (var component in strings) {
          if (typeof strings[component] !== 'undefined' && typeof strings[component][this._locale] !== 'undefined') {
            str = strings[component][this._locale][key] || str;
          }
        } // Optimization for a string with no placeholder
        // e.g. Coral.i18n.get('English string');


        if (variablePlaceholderCount === 0) {
          return str;
        } // Replace all variables


        return str.replace(this._evaluate, function (name) {
          name = name.slice(1).slice(0, -1);
          return variables[name];
        }); // @todo use .toLocaleString(Coral.i18n.locale) in a future release
      }
      /**
       I18n current locale value. See {@link I18nLocalesEnum}.
       @type {String}
       */

    }, {
      key: "locale",
      get: function get() {
        return this._locale;
      },
      set: function set(newLocale) {
        this._locale = newLocale;
      }
    }]);

    return I18nProvider;
  }(); // sets default locale, based on document lang attribute, if it exists, or en-US otherwise


  var docLang = document.documentElement.lang.toLowerCase();
  var locale = locales[docLang] || 'en-US';
  /**
   An i18n service.

   @type {I18nProvider}
   */

  var i18n = new I18nProvider({
    locale: locale
  });

  /**
   A map of modifier names to their corresponding keycodes.
   @ignore
   */

  var modifierCodes = {
    'â§': 16,
    'shift': 16,
    'â¥': 18,
    'alt': 18,
    'option': 18,
    'â': 17,
    'ctrl': 17,
    'control': 17,
    'â': 91,
    'cmd': 91,
    'command': 91,
    'meta': 91
  };
  /**
   Used to check if a key is a modifier.
   @ignore
   */

  var modifierCodeMap = {
    16: true,
    17: true,
    18: true,
    91: true,
    224: true
  };
  /**
   A list of modifier event property names in sorted key code order. Used to add keycodes for modifiers.
   @ignore
   */

  var modifierEventPropertyNames = ['shiftKey', 'ctrlKey', 'altKey', 'metaKey'];
  /**
   A map of key codes to normalize. These are duplicate keys such as the number pad.
   @ignore
   */

  var normalizedCodes = {
    // Numpad 0-9
    96: 48,
    97: 49,
    98: 50,
    99: 51,
    100: 52,
    101: 53,
    102: 54,
    103: 55,
    104: 56,
    105: 57
  }; // These keys are also implicitely used external

  var specialKeyCodes = {
    backspace: 8,
    tab: 9,
    // real event key is "enter" this will be mapped internally
    return: 13,
    pause: 19,
    capslock: 20,
    esc: 27,
    escape: 27,
    // real event key is " " this will be mapped internally
    space: 32,
    pageup: 33,
    pagedown: 34,
    end: 35,
    home: 36,
    // real event key is "arrowLeft" this will be mapped internally
    left: 37,
    // real event key is "arrowUp" this will be mapped internally
    up: 38,
    // real event key is "arrowRight" this will be mapped internally
    right: 39,
    // real event key is "arrowDown" this will be mapped internally
    down: 40,
    insert: 45,
    del: 46,
    delete: 46,
    period: 190,
    plus: 107,
    minus: 189,
    f1: 112,
    f2: 113,
    f3: 114,
    f4: 115,
    f5: 116,
    f6: 117,
    f7: 118,
    f8: 119,
    f9: 120,
    f10: 121,
    f11: 122,
    f12: 123,
    f13: 124,
    f14: 125,
    f15: 126,
    f16: 127,
    f17: 128,
    f18: 129,
    f19: 130,
    numlock: 144,
    scroll: 145
  }; // Match a namespaced event, such as ctrl+r.myNS

  var namespaceRE = /(.*?)(\..+)$/; // Match a selector that requires context

  var needsContextRE = /^[\x20\t\r\n\f]*[>+~]/;
  /**
   The set of tags to ignore hot keys when focused within for the default filter.

   @ignore
   */

  var restrictedTagNames = {
    INPUT: true,
    SELECT: true,
    TEXTAREA: true,
    // Support alphanumeric search
    'CORAL-SELECTLIST-ITEM': true
  };
  /**
   Normalize duplicate codes.
   @ignore
   */

  function normalizeCode(code) {
    return normalizedCodes[code] || code;
  }

  function mapSpecialEventKeyToSpecialAPIDefinition(eventKey) {
    // The official event.key is not compatible with this API special key registration, so map them
    switch (eventKey) {
      case 'enter':
        return 'return';

      case ' ':
        return 'space';

      case 'arrowup':
        return 'up';

      case 'arrowdown':
        return 'down';

      case 'arrowleft':
        return 'left';

      case 'arrowright':
        return 'right';

      default:
        return eventKey;
    }
  }
  /**
   Convert a key to its character code representation.

   @ignore

   @param key
   @return {*|Number}
   */


  function _keyToCode(key) {
    key = mapSpecialEventKeyToSpecialAPIDefinition(key.toLowerCase()); // Map special string representations to their character code equivalent

    var code = specialKeyCodes[key] || modifierCodes[key];

    if (!code && key.length > 1) {
      throw new Error("Coral.Keys: Key ".concat(key, " not recognized"));
    } // Return the special code from the map or the char code repesenting the character


    return code || key.toUpperCase().charCodeAt(0);
  }

  function cleanupFilteredListeners(keycombo, listeners, event) {
    var result = [];

    if (!listeners || !event.key || keycombo.indexOf('+') > 0) {
      return listeners;
    } // Check there is no registration conflict for same code registrations
    // For example: "." keyCharCode is 46 and "delete" keyCode is also 46


    var key = mapSpecialEventKeyToSpecialAPIDefinition(event.key.toLowerCase());

    for (var i = 0; i < listeners.length; i++) {
      if (listeners[i].originalString.indexOf(key) === 0 || key.indexOf(listeners[i].originalString) === 0) {
        result.push(listeners[i]);
      }
    }

    return result;
  }
  /**
   Handle key combination events.
   */


  var Keys = /*#__PURE__*/function () {
    /**
     @param {*} elOrSelector
     The selector or element to listen for keyboard events on. This should be the common parent of all
     elements you wish to listen for events on.
     @param {Object} [options]
     Options for this combo handler.
     @param {Function} [options.context]
     The desired value of the <code>this</code> keyword context when executing listeners. Defaults to the element on
     which the event is listened for.
     @param {Function} [options.preventDefault=false]
     Whether to prevent the default behavior when a key combo is matched.
     @param {Function} [options.stopPropagation=false]
     Whether to stop propagation when a key combo is matched.
     @param {Function} [options.filter]
     The filter function for keyboard events. This can be used to stop events from being triggered when they originate
     from specific elements. Defaults to {@link Keys.filterInputs}.
     */
    function Keys(elOrSelector, options) {
      _classCallCheck(this, Keys);

      options = options || {};

      if (typeof elOrSelector === 'undefined') {
        throw new Error("Coral.Keys: Cannot create a combo handler for ".concat(elOrSelector));
      } // Cache the element object


      this._el = typeof elOrSelector === 'string' ? document.querySelector(elOrSelector) : elOrSelector; // Use provided context

      this._context = options.context;
      /**
       The filter function to use when evaluating keypresses
       */

      this._filter = options.filter || this.constructor.filterInputs;
      /**
       Whether to prevent default
       */

      this._preventDefault = options.preventDefault || false;
      /**
       Whether to stop propagation and prevent default
       */

      this._stopPropagation = options.stopPropagation || false;
      /**
       A map of key code combinations to arrays of listener functions
       */

      this._keyListeners = [];
      /**
       A an array of key sequences objects
       */

      this._keySequences = [];
      /**
       The sorted array of currently pressed keycodes
       */

      this._currentKeys = [];
      /**
       The joined string representation of currently pressed keycodes
       */

      this._currentKeyCombo = [];
      /**
       The timeout that corresponds to sequences
       */

      this._sequenceTimeout = null;
      this._handleKeyDown = this._handleKeyDown.bind(this);
      this._handleKeyUp = this._handleKeyUp.bind(this);
      this._resetSequence = this._resetSequence.bind(this);
      this.reset = this.reset.bind(this); // Initialize immediately

      this.init();
    }

    _createClass(Keys, [{
      key: "_resetSequence",
      value: function _resetSequence() {
        window.clearTimeout(this._sequenceTimeout);

        this._keySequences.forEach(function (sequence) {
          // Reset each sequence
          sequence.currentPart = 0;
        });
      }
    }, {
      key: "_setCurrentKeyCombo",
      value: function _setCurrentKeyCombo(event) {
        // Build string for modifiers
        var currentModifiers = [];

        for (var i = 0; i < modifierEventPropertyNames.length; i++) {
          var propName = modifierEventPropertyNames[i];

          if (event[propName]) {
            currentModifiers.push(modifierCodes[propName.slice(0, -3)]);
          }
        } // Store current key combo


        this._currentKeyCombo = this._currentKeys.concat(currentModifiers).sort().join('+');
      }
      /**
       Reset the state of this instance. This resets the currently pressed keys.
        @function reset
        @returns {Keys} this, chainable.
       */

    }, {
      key: "reset",
      value: function reset() {
        // Only reset variables related to currently pressed keys
        // Don't mess with sequences
        this._currentKeys = [];
        this._currentKeyCombo = '';
        return this;
      }
    }, {
      key: "_processSequences",
      value: function _processSequences() {
        var _this = this;

        var activeSequenceListeners = []; // Check each sequence's state

        this._keySequences.forEach(function (sequence) {
          if (sequence.parts[sequence.currentPart] === _this._currentKeyCombo) {
            // If the current key combo in the sequence was pressed, increment the pointer
            sequence.currentPart++;
          } else {
            // Reset the sequence if a key was encountered out of sequence
            sequence.currentPart = 0;
          }

          if (sequence.currentPart === sequence.parts.length) {
            // If we've reached the end of the sequence, add it to the list of active sequences
            activeSequenceListeners.push(sequence); // Reset the sequence's state so it can be triggered again

            sequence.currentPart = 0;
          }
        });

        return activeSequenceListeners;
      }
    }, {
      key: "_executeListeners",
      value: function _executeListeners(event, keyup) {
        // Don't do anything if we don't have any keys pressed
        if (!this._currentKeyCombo) {
          return;
        } // Evaluate whether we should filter this keypress


        if (!this._filter(event)) {
          return;
        }

        var target = event.target || event.srcElement;
        var doc = Object.prototype.toString.call(event.currentTarget) === '[object Window]' ? event.currentTarget.document : event.currentTarget;
        var listeners = []; // Execute listeners associated with the current key combination

        var comboListeners = this._keyListeners[this._currentKeyCombo];
        comboListeners = cleanupFilteredListeners(this._currentKeyCombo, comboListeners, event); // If it is a combo key combination but we listen on the final key combination result or on special single char like "/"
        // E.g. we listen on "/" but the user presses "Shift+7" on a german-swiss keyboard
        // or we listen on "/" on the single key event on a US layout keyboard

        if (!keyup && !comboListeners) {
          if (event.key) {
            comboListeners = this._keyListeners[event.key.charCodeAt(0)];
            comboListeners = cleanupFilteredListeners(this._currentKeyCombo, comboListeners, event);
          }
        }

        var sequenceListeners;

        if (!keyup) {
          // Process sequences and get listeners associated with the current sequence
          // Don't do this on keyup as this breaks sequences with modifiers
          sequenceListeners = this._processSequences();
        }

        if (comboListeners && comboListeners.length) {
          listeners = listeners.concat(comboListeners);
        }

        if (sequenceListeners && sequenceListeners.length) {
          listeners = listeners.concat(sequenceListeners);
        }

        if (listeners && listeners.length) {
          for (var i = 0; i < listeners.length; i++) {
            var listener = listeners[i]; // Perform event delegation

            if (listener.selector) {
              var selector = ''; // This allows us to match when the delegation selector includes context

              if (listener.needsContext) {
                doc.id = doc.id || commons.getUID();
                selector = "#".concat(doc.id, " ");
              }

              var matches = Array.prototype.indexOf.call(doc.querySelectorAll(selector + listener.selector), target) >= 0; // Skip if the originating element doesn't match the selector

              if (!matches) {
                continue;
              }
            } // Add data to event object


            if (typeof listener.data !== 'undefined') {
              event.data = listener.data;
            } // Add matchedTarget


            event.matchedTarget = target; // Add keys that triggered the event

            event.keys = listener.originalString;
            listener.listener.call(this._context || doc, event);
          } // Don't do the default thing


          if (this._preventDefault) {
            event.preventDefault();
          }

          if (this._stopPropagation) {
            event.stopPropagation();
          }
        }
      }
    }, {
      key: "_handleKeyDown",
      value: function _handleKeyDown(event) {
        window.clearTimeout(this._sequenceTimeout);
        this._sequenceTimeout = window.setTimeout(this._resetSequence, this.constructor.sequenceTime); // Store pressed key in array

        var key = normalizeCode(event.keyCode); // Don't do anything when a modifier is pressed

        if (modifierCodeMap[key]) {
          return;
        }

        if (this._currentKeys.indexOf(key) === -1) {
          this._currentKeys.push(key);

          this._setCurrentKeyCombo(event);
        }

        this._executeListeners(event); // Workaround: keyup events are never triggered while the command key is down, so reset the list of keys


        if (event.metaKey) {
          this.reset();
        }

        if (!event.target.parentNode) {
          // Workaround: keyup events are never triggered if the element does not have a parent node
          this.reset();
        }
      }
    }, {
      key: "_handleKeyUp",
      value: function _handleKeyUp(event) {
        var key = normalizeCode(event.keyCode);

        if (modifierCodeMap[key]) {
          // Workaround: keyup events are not triggered when command key is down on Mac, so if the command key is
          // released, consider all keys released
          // Test: comment this out, press K, press L, press Command, release L, release Command, then release K -- L is
          // triggered. This also prevents handlers for related key combos to be triggered
          // Test: comment this out, press Control, press Alt, press A, press S, release Alt, release S -- Control+A is
          // triggered
          this.reset(); // We don't ever want to execute handlers when a modifier is released, and we can't since they don't end up in
          // currentKeys. If we weren't doing the index check below, that could result in key combo handlers for ctrl+r to
          // be triggered when someone released alt first after triggering ctrl+alt+r. In any case, return to avoid the
          // uselss extra work

          return;
        } // Remove key from array


        var index = this._currentKeys.indexOf(key);

        if (index !== -1) {
          this._currentKeys.splice(index, 1); // If too many keys are pressed, then one is removed, make sure to check for a match


          this._setCurrentKeyCombo(event);

          this._executeListeners(event, true);
        }
      }
    }, {
      key: "_keySequenceStringToArray",
      value: function _keySequenceStringToArray(keyCombo) {
        return keyCombo.toString().split('-').map(this._keyComboToCodeString);
      }
      /**
       Add a key combo listener.
        @function on
       @param {String} keyCombo
       The key combination to listen for, such as <code>'ctrl-f'</code>.
       @param {String} [selector]
       A selector to use for event delegation.
       @param {String} [data]
       Data to pass to listeners as <code>event.data</code>.
       @param {Function} listener
       The listener to execute when this key combination is pressed. Executes on keydown, or, if too many keys are
       pressed and one is released, resulting in the correct key combination, executes on keyup.
        @returns {Keys} this, chainable.
       */

    }, {
      key: "on",
      value: function on(keyCombo, selector, data, listener) {
        // keyCombo can be a map of keyCombos to handlers
        if (_typeof(keyCombo) === 'object') {
          // ( keyCombo-Object, selector, data )
          if (typeof selector !== 'string') {
            // ( keyCombo-Object, data )
            // ( keyCombo-Object, null, data )
            data = data || selector;
            selector = undefined;
          }

          for (var combo in keyCombo) {
            this.on(combo, selector, data, keyCombo[combo]);
          }

          return this;
        }

        if (typeof data === 'undefined' && typeof listener === 'undefined') {
          // ( keyCombo, listener )
          listener = selector;
          data = selector = undefined;
        } else if (typeof listener === 'undefined') {
          if (typeof selector === 'string') {
            // ( keyCombo, selector, listener )
            listener = data;
            data = undefined;
          } else {
            // ( keyCombo, data, listener )
            listener = data;
            data = selector;
            selector = undefined;
          }
        }

        if (typeof listener !== 'function') {
          throw new Error("Coral.Keys: Cannot add listener of type ".concat(_typeof(listener)));
        }

        var namespace;
        var namespaceMatch = namespaceRE.exec(keyCombo);

        if (namespaceMatch) {
          keyCombo = namespaceMatch[1];
          namespace = namespaceMatch[2];
        } // Determine if this selector needs context when evaluating event delegation
        // A selector needs context when it includes things like >, ~, :first-child, etc


        var needsContext = selector ? needsContextRE.test(selector) : false; // Check if the string is a sequence or a keypress

        if (keyCombo.toString().indexOf('-') !== -1 && keyCombo.toString().length > 1) {
          // It's a sequence!
          // Divide it into its parts and convert to a code string
          var sequenceParts = this._keySequenceStringToArray(keyCombo); // Store the listener and associated information in the list for this sequence


          this._keySequences.push({
            originalString: keyCombo,
            currentPart: 0,
            parts: sequenceParts,
            needsContext: needsContext,
            selector: selector,
            listener: listener,
            data: data,
            namespace: namespace
          });
        } else {
          var originalString = keyCombo.toString(); // It's a key combo!

          keyCombo = this._keyComboToCodeString(keyCombo);
          var listeners = this._keyListeners[keyCombo] = this._keyListeners[keyCombo] || []; // Store the listener and associated information in the list for this keyCombo

          listeners.push({
            originalString: originalString,
            // Determine if this selector needs context when evaluating event delegation
            // A selector needs context when it includes things like >, ~, :first-child, etc
            needsContext: selector ? needsContextRE.test(selector) : false,
            selector: selector,
            listener: listener,
            data: data,
            namespace: namespace
          });
        }

        return this;
      }
    }, {
      key: "_offByKeyComboString",
      value: function _offByKeyComboString(keyComboString, namespace, selector, listener) {
        var i;
        var listeners = this._keyListeners[keyComboString];

        if (listeners && listeners.length) {
          if (typeof selector === 'undefined' && typeof listener === 'undefined' && typeof namespace === 'undefined') {
            // Unbind all listeners for this key combo
            listeners.length = 0;
          } else if (typeof listener === 'undefined') {
            // Unbind all listeners of a specific selector and or namespace
            for (i = 0; i < listeners.length; i++) {
              // This comparison works because selector and namespace are undefined by default
              if (listeners[i].selector === selector && listeners[i].namespace === namespace) {
                listeners.splice(i, 1);
                i--;
              }
            }
          } else {
            // Unbind a specific listener, optionally on a specific selector and specific namespace
            for (i = 0; i < listeners.length; i++) {
              if (listeners[i].listener === listener && listeners[i].selector === selector && listeners[i].namespace === namespace) {
                listeners.splice(i, 1);
                i--;
              }
            }
          }
        }
      }
      /**
       Remove a key combo listener.
        @function off
       @param {String} keyCombo
       The key combination to listen for, such as <code>'ctrl-f'</code>.
       @param {String} [selector]
       A selector to use for event delegation.
       @param {Function} listener
       The listener that was passed to on.
        @returns {Keys} this, chainable.
       */

    }, {
      key: "off",
      value: function off(keyCombo, selector, listener) {
        if (typeof listener === 'undefined') {
          listener = selector;
          selector = undefined;
        }

        var i;
        var namespace;
        var namespaceMatch = namespaceRE.exec(keyCombo);

        if (namespaceMatch) {
          keyCombo = namespaceMatch[1];
          namespace = namespaceMatch[2];
        }

        if (keyCombo === '' && namespace !== undefined) {
          // If we have a namespace by no keyCombo, remove all events of the namespace for each key combo
          for (keyCombo in this._keyListeners) {
            this._offByKeyComboString(keyCombo, namespace, selector, listener);
          } // Remove sequences


          for (i = 0; i < this._keySequences.length; i++) {
            if (this._keySequences[i].namespace === namespace) {
              this._keySequences.splice(i, 1);

              i--;
            }
          }

          return this;
        }

        if (keyCombo.indexOf('-') !== -1) {
          // Unbind a specific key sequence listener, optionally on a specific selector and specific namespace
          for (i = 0; i < this._keySequences.length; i++) {
            if ((keyCombo === undefined || this._keySequences[i].originalString === keyCombo) && (listener === undefined || this._keySequences[i].listener === listener) && (selector === undefined || this._keySequences[i].selector === selector) && (namespace === undefined || this._keySequences[i].namespace === namespace)) {
              this._keySequences.splice(i, 1);

              i--;
            }
          }
        } else {
          keyCombo = this._keyComboToCodeString(keyCombo);

          this._offByKeyComboString(keyCombo, namespace, selector, listener);
        }

        return this;
      }
      /**
       Destroy this instance. This removes all event listeners, references, and state.
        @function destroy
       @param {Boolean} globalsOnly
       Whether only global listeners should be removed
        @returns {Keys} this, chainable.
       */

    }, {
      key: "destroy",
      value: function destroy(globalsOnly) {
        if (!globalsOnly) {
          this._keyListeners = null;
          this._currentKeys = null;
          this._currentKeyCombo = null;

          this._el.removeEventListener('keydown', this._handleKeyDown);
        }

        window.removeEventListener('keyup', this._handleKeyUp, true);
        window.removeEventListener('focus', this.reset);
        return this;
      }
      /**
       Initialize an instance created without the <code>new</code> keyword or revive a destroyed instance. This method
       will be called automatically if an instance is created with <code>new Coral.keys</code>.
        @function init
       @param {Boolean} globalsOnly
       Whether only global listeners should be added
        @returns {Keys} this, chainable.
       */

    }, {
      key: "init",
      value: function init(globalsOnly) {
        if (!globalsOnly) {
          // Reset all variable states
          this._currentKeys = [];
          this._currentKeyCombo = '';
          this._keyListeners = {};
          this._keySequences = [];

          this._el.addEventListener('keydown', this._handleKeyDown);
        } // Remove window event listeners first to avoid memory leak


        this.destroy(true); // Watching on capture so it is immune to stopPropagation(). It's very important this event
        // is handled so key entries previously added on keydown can be cleared out.
        // If multiple identical EventListeners are registered on the same EventTarget with the same parameters the
        // duplicate instances are discarded. They do not cause the EventListener to be called twice.

        window.addEventListener('keyup', this._handleKeyUp, true);
        window.addEventListener('focus', this.reset);
        return this;
      }
      /**
       The default keycombo event filter function. Ignores key combos triggered on input, select, and textarea.
        @param event
       The event passed
        @returns {Boolean} True, if event.target is not editable and event.target.tagname is not restricted
       */

    }, {
      key: "_keyComboToCodeString",

      /**
       Convert a combination of keys separated by + into the corresponding code string.
       @ignore
       */
      value: function _keyComboToCodeString(keyCombo) {
        // if single "+"
        if (keyCombo === '+') {
          return _keyToCode(keyCombo);
        }

        return keyCombo // Convert to string so numbers are supported
        .toString().split('+').map(_keyToCode) // Sort keys for easy comparison
        .sort().join('+');
      }
    }], [{
      key: "filterInputs",
      value: function filterInputs(event) {
        // Escape keycode doesn't have to be filtered
        if (event.keyCode === specialKeyCodes.escape) {
          return true;
        }

        var target = event.target;
        var tagName = target.tagName;
        var isContentEditable = target.isContentEditable;
        var isRestrictedTag = restrictedTagNames[tagName];
        return !isContentEditable && !isRestrictedTag;
      }
      /**
       Convert a key to its character code representation.
        @param {String} key
       The key character that needs to be converted. If the String contains more than one character, an error will be
       produced.
        @returns {Number} The character code of the given String.
       */

    }, {
      key: "keyToCode",
      value: function keyToCode(key) {
        return _keyToCode(key);
      }
      /**
       The time allowed between keypresses for a sequence in miliseconds
       @type {Number}
       @default 1500
       */

    }, {
      key: "sequenceTime",
      get: function get() {
        return 1500;
      }
    }]);

    return Keys;
  }();
  /**
   A key listener for global hotkeys is exposed for document eventing handling.

   @type {Keys}
   */
  // Register against the documentElement, <html>, so event delegation works


  var keys$1 = new Keys(document.documentElement, {
    // Don't let global hotkeys trigger default actions
    stopPropagation: true,
    preventDefault: true
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   Set of property value transformation functions.
   */
  var Transformation = /*#__PURE__*/function () {
    function Transformation() {
      _classCallCheck(this, Transformation);
    }

    _createClass(Transformation, [{
      key: "boolean",

      /**
       Transform the provided value into a boolean. Follows the behavior of JavaScript thruty/falsy.
        @param {*} value
       The value to convert to Boolean.
        @returns {Boolean} The corresponding boolean value.
       */
      value: function boolean(value) {
        return !!value;
      }
      /**
       Transform the provided value into a boolean. Follows the behavior of the HTML specification, in which the existence of
       the attribute indicates <code>true</code> regardless of the attribute's value. If the value is a boolean, it ignores
       the transformation.
        @param {*} value
       The value to convert to Boolean.
        @returns {Boolean} The corresponding boolean value.
       */

    }, {
      key: "booleanAttr",
      value: function booleanAttr(value) {
        return typeof value === 'boolean' ? value : !(value === null || typeof value === 'undefined');
      }
      /**
       Transforms the provided value into a floating point number.
        @param {*} value
       The value to convert to a Number.
        @returns {?Number} The corresponding number or <code>null</code> if the passed value cannot be converted to a number.
       */

    }, {
      key: "number",
      value: function number(value) {
        value = parseFloat(value);
        return isNaN(value) ? null : value;
      }
      /**
       Transforms the provided value into a floating number. The conversion is strict in the sense that if non numeric values
       are detected, <code>null</code> is returned instead.
        @param {*} value
       The value to be converted to a Number.
        @retuns {?Number} The corresponding number or <code>null</code> if the passed value cannot be converted to number.
       */

    }, {
      key: "float",
      value: function float(value) {
        if (/^(-|\+)?([0-9]+(\.[0-9]+)?|Infinity)$/.test(value)) {
          return Number(value);
        }

        return null;
      }
      /**
       Transform the provided value into a string. When given <code>null</code> or <code>undefined</code> it will be
       converted to an empty string("").
        @param {*} value
       The value to convert to String.
        @returns {String} The corresponding string value.
       */

    }, {
      key: "string",
      value: function string(value) {
        if (value === null || typeof value === 'undefined') {
          return '';
        }

        return typeof value === 'string' ? value : String(value);
      }
    }]);

    return Transformation;
  }();
  /**
   A type transform utility.

   @type {Transformation}
   */


  var transform = new Transformation();

  /**
   Set of property value validation functions.
   */

  var Validation = /*#__PURE__*/function () {
    function Validation() {
      _classCallCheck(this, Validation);
    }

    _createClass(Validation, [{
      key: "valueMustChange",

      /**
       Ensures that the value has changed.
        @param {*} newValue
       The new value.
       @param {*} oldValue
       The existing value.
        @returns {Boolean} <code>true</code> if the values are different.
       */
      value: function valueMustChange(newValue, oldValue) {
        // We can use exact equality here as validation functions are called after transform. Thus, the input value will be
        // converted to the same type as a stored value
        return newValue !== oldValue;
      }
      /**
       Ensures that the new value is within the enumeration. The enumeration can be given as an array of values or as a
       key/value Object. Take into consideration that enumerations are case sensitive.
        @example // Enumeration as Array
       Coral.validate.enumeration(['xs', 's', 'm', 'l']);
       @example // Enumeration as Object
       Coral.validate.enumeration({EXTRA_SMALL : 'xs', SMALL : 's', MEDIUM : 'm', LARGE : 'l'});
       @param {Object} enumeration
       Object that represents an enum.
        @returns {ValidationFunction}
       a validation function that ensures that the given value is within the enumeration.
       */

    }, {
      key: "enumeration",
      value: function enumeration(_enumeration) {
        // Reverses the enumeration, so that we can check that the variable new value exists inside
        var enumReversed = commons.swapKeysAndValues(_enumeration); // Returns a new function that matches the newValue, oldValue signature

        return function (newValue) {
          return typeof enumReversed[newValue] !== 'undefined';
        };
      }
    }]);

    return Validation;
  }();
  /**
   Signature of the function used to validate new input. It accepts a newValue and an oldValue which are used to
   determine if the newValue is valid.

   @typedef {function} ValidationFunction

   @param {*} newValue
   The new value to validate.
   @param {*} oldValue
   The existing value.

   @returns {Boolean} <code>true</code> if the validation succeeded, otherwise <code>false</code>.
   */

  /**
   A property transform utility.

   @type {Validation}
   */


  var validate = new Validation();

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   Signature function used to track the usage of Coral components. By default, there is no out of the box
   implementation as tracking is agnostic of the underlying technology.

   You need to implement a new tracker and add it with: <code>Coral.tracking.addListener(fn(){ });</code>

   The <code>fn()</code> callback will receive multiple arguments:
   * <code>trackData</code> - an object with fixed structure e.g. <code>{type: "button", eventType: "click", element: "save settings", feature: "sites"}</code>
   * <code>event</code> - the CustomEvent or MouseEvent details object.
   * <code>component</code> - the component reference object.

   Using the above data you can map it to your own analytics tracker.
   */
  var Tracking = /*#__PURE__*/function () {
    /* @ignore */
    function Tracking() {
      _classCallCheck(this, Tracking);

      /**
       All registered trackers.
        @type {Array<Function>}
       */
      this._trackers = [];
    }
    /**
     Returns <code>true</code> if the tracking is disabled for the given component, otherwise false.
      @param {HTMLElement} component
     @returns {Boolean}
     */


    _createClass(Tracking, [{
      key: "_isTrackingDisabledForComponent",
      value: function _isTrackingDisabledForComponent(component) {
        return component && typeof component.tracking !== 'undefined' && component.tracking === component.constructor.tracking.OFF;
      }
      /**
       Get tracking annotations from the parent Component to which the event was bound.
        @param {BaseComponent} component
       @returns {{trackingElement: String, trackingElement: String}}
       */

    }, {
      key: "_getTrackingDataFromComponentAttr",
      value: function _getTrackingDataFromComponentAttr(component) {
        if (this._isTrackingDisabledForComponent(component)) {
          return {
            trackingElement: '',
            trackingFeature: ''
          };
        } // Eg. from DOM trackingfeature="sites"


        var trackingFeature = component.trackingFeature || ''; // Eg. from DOM trackingelement="rail toggle"

        var trackingElement = component.trackingElement || '';
        return {
          trackingFeature: trackingFeature,
          trackingElement: trackingElement
        };
      }
      /**
       Returns a tracking data object that can be used to compile data to send to an actual Analytics tracker.
        @param {String} eventType
       @param {String} targetType
       @param {CustomEvent} event
       @param {BaseComponent} component
       @param {BaseComponent} childComponent
       @returns {Object} An object with the tracking data.
       */

    }, {
      key: "_createTrackingData",
      value: function _createTrackingData(eventType, targetType, event, component, childComponent) {
        var parentComponentType = (component.getAttribute('is') || component.tagName).toLowerCase(); // Gather data into the Coral Tracking structure.

        var trackDataFromAttr = this._getTrackingDataFromComponentAttr(component); // Compile data

        /**
         The default Coral tracking data object
         filled with values from root Component and child Component (if exists).
         @type {{targetType: string, targetElement: string, eventType: string, rootElement: string, rootFeature: string, rootType: string}}
         */


        return {
          targetType: targetType || parentComponentType || '',
          targetElement: childComponent && childComponent.trackingElement ? childComponent.trackingElement : component.trackingElement,
          eventType: eventType || event.type,
          rootElement: trackDataFromAttr.trackingElement,
          rootFeature: trackDataFromAttr.trackingFeature,
          rootType: parentComponentType
        };
      }
      /**
       Add a tracking callback. This will be invoked every time a tracking event is emitted.
        @param {TrackingCallback} trackingCallback
       The callback to execute.
       */

    }, {
      key: "addListener",
      value: function addListener(trackingCallback) {
        if (typeof trackingCallback !== 'function') {
          throw new Error('Coral.Tracking: Tracker must be a function callback.');
        }

        if (this._trackers.indexOf(trackingCallback) !== -1) {
          throw new Error('Coral.Tracking: Tracker callback cannot be added twice.');
        }

        this._trackers.push(trackingCallback);
      }
      /**
       Removes a tracker.
        @param {TrackingCallback} trackingCallback
       */

    }, {
      key: "removeListener",
      value: function removeListener(trackingCallback) {
        this._trackers = this._trackers.filter(function (trackerFn) {
          return trackerFn !== trackingCallback;
        });
      }
      /**
       Notify all trackers subscribed.
        @param {String} eventType
       Eg. click, select, etc.
       @param {String} targetType
       Eg. cycle button, cycle button item, etc.
       @param {CustomEvent} event
       @param {BaseComponent} component
       @param {BaseComponent} childComponent
       Optional, in case the event occurred on a child component.
       @returns {Boolean} if the event was dispatch to at least 1 tracker.
       */

    }, {
      key: "track",
      value: function track(eventType, targetType, event, component, childComponent) {
        if (this._trackers.length === 0 || this._isTrackingDisabledForComponent(component) || this._isTrackingDisabledForComponent(childComponent)) {
          return false;
        }

        var args = Array.prototype.slice.call(arguments, [2]);

        var trackingData = this._createTrackingData(eventType, targetType, event, component, childComponent);

        this._trackers.forEach(function (trackerFn) {
          trackerFn.apply(null, [trackingData].concat(args));
        });

        return true;
      }
    }]);

    return Tracking;
  }();
  /**
   Executes the callback when ever there is an interaction inside the component that needs to be tracked. This can be used
   to get insight on how users interact with the page and the features that available.

   @typedef {function} TrackingCallback

   @param {Object} trackData
   Object containing the data to be tracked. It contains the properties <code>type</code>, <code>eventType</code>,
   <code>element</code> and <code>feature</code>.
   @param {CustomEvent} event
   Underlying event that was generated by the user
   @param {HTMLElement} component
   Component that triggered the tracking event.
   */

  /**
   Tracking API to get insight on component usage.

   @type {Tracking}
   */


  var tracking = new Tracking();

  var delegateEventSplitter = /^(\S+)\s*(.*)$/; // Enum value is referenced for speed

  var ELEMENT_NODE = Node.ELEMENT_NODE;
  /**
   Return the method corresponding to the method name or the function, if passed.

   @ignore
   */

  function getListenerFromMethodNameOrFunction(obj, eventName, methodNameOrFunction) {
    // Try to get the method
    if (typeof methodNameOrFunction === 'function') {
      return methodNameOrFunction;
    } else if (typeof methodNameOrFunction === 'string') {
      if (!obj[methodNameOrFunction]) {
        throw new Error('Coral.Component: Unable to add ' + eventName + ' listener for ' + obj.toString() + ', method ' + methodNameOrFunction + ' not found');
      }

      var listener = obj[methodNameOrFunction];

      if (typeof listener !== 'function') {
        throw new Error('Coral.Component: Unable to add ' + eventName + ' listener for ' + obj.toString() + ', listener is a ' + _typeof(listener) + ' but should be a function');
      }

      return listener;
    } else if (methodNameOrFunction) {
      // If we're passed something that's truthy (like an object), but it's not a valid method name or a function, get
      // angry
      throw new Error('Coral.Component: Unable to add ' + eventName + ' listener for ' + obj.toString() + ', ' + methodNameOrFunction + ' is neither a method name or a function');
    }

    return null;
  }
  /**
   @class Component
   @classdesc The base element for all Coral components
   @extends {HTMLElement}
   */


  var Component = function Component() {
    throw new Error('Coral.Component is not meant to be invoked directly. Inherit from its prototype instead.');
  }; // Inherit from HTMLElement


  Component.prototype = Object.create(HTMLElement.prototype); // Store a reference to properties

  Component.prototype._properties = {};
  /**
   Return this component's name.

   @ignore
   */

  Component.prototype.toString = function () {
    if (this._namespace === window.Coral) {
      return "Coral.".concat(this._componentName);
    }

    return this._componentName;
  };
  /**
   Events map. Key is Backbone-style event description, value is string indicating method name or function. Handlers
   are always called with <code>this</code> as the element.

   @type {Object}
   @protected
   */


  Component.prototype._events = {};
  /**
   Called when the component is being constructed. This method applies the CSS class, renders the component, binds
   events, and sets initial property values.

   {@link Component#_initialize} is called after the above operations are complete.
   @protected
   */

  Component.prototype.createdCallback = function () {
    // We have to add toString directly on the instance or it doesn't work in IE 9
    // A side-effect of this is that toString cannot be overridden
    if (this.toString !== Component.prototype.toString) {
      this.toString = Component.prototype.toString;
    } // Track which properties have been set
    // This is used when setting defaults


    this._setProps = {};
    this._syncQueue = []; // Make sure context is correct when called by nextFrame

    this._syncDOM = this._syncDOM.bind(this); // Create a Vent instance to handle local events

    this._vent = new Vent(this); // Apply the class name

    if (this._className) {
      this.classList.add.apply(this.classList, this._className.split(' '));
    } // Create the elements property before the template. Templates that use handle="someName" attrs will need this


    this._elements = {}; // Render template, if necessary

    if (typeof this._render === 'function') {
      this._render();
    }

    var prop;
    var attr;
    var value;
    var descriptor;
    var methods; // A hash where all the content zone names are stored using the tagName as key and property as value

    this._contentZones = {}; // A list of attribute values indexed by property name
    // prop -> attrValue

    var attrValues = {}; // Build a cache of attribute values provided via the markup and check for content zones

    for (prop in this._properties) {
      descriptor = this._properties[prop];

      if (descriptor.contentZone) {
        // Check if the tag name is unique
        if (this._contentZones[descriptor.tagName]) {
          commons._log('warn', 'Coral.Component: content zone for "%s" is already defined', descriptor.tagName);
        } // Add the prop to the hash


        this._contentZones[descriptor.tagName] = prop;
      } // Use the attribute name specified by the map


      attr = descriptor.attribute || prop; // Fetch the attribute corresponding to the property from the element

      attrValues[prop] = this.getAttribute(attr);
    } // Apply default values for all properties and their associated attributes


    for (prop in this._properties) {
      descriptor = this._properties[prop];
      methods = descriptor._methods; // Get the attribute value from the cache

      value = attrValues[prop];

      if (value !== null) {
        // Since the value is loaded as an attribute, it needs to be transformed from its attribute value
        if (methods.attributeTransform) {
          value = methods.attributeTransform.call(this, value, descriptor.default);
        } // Run the value transform function


        if (descriptor.transform) {
          value = methods.transform.call(this, value, descriptor.default);
        } // Check if the value valdiates


        if (methods.validate) {
          for (var i = 0; i < methods.validate.length; i++) {
            // Don't pass the old value
            if (!methods.validate[i].call(this, value)) {
              // If it fails validation, we'll use the default
              value = null;
              break;
            }
          }
        }
      }

      if (value === null) {
        // If the property has already been set in another setter, don't apply the default
        if (this._setProps[prop]) {
          continue;
        } // If the default is a function we call it


        if (typeof descriptor.default === 'function') {
          // Call method if the default value is a method
          value = descriptor.default.call(this);
        } else {
          // Otherwise we set it from the descriptor directly
          value = descriptor.default;
        } // If the value that came out of the default is undefined,
        // this means that the property does not really have a default value
        // so we continue in order to avoid setting it


        if (typeof value === 'undefined') {
          continue;
        }
      } // Invoke the setter silently so we don't trigger "change" events on initialization


      this.set(prop, value, true);
    }

    this._delegateEvents(); // Call the initialize method, if necessary


    if (typeof this._initialize === 'function') {
      this._initialize();
    } // Add MutationObserver for content zones


    if (Object.keys(this._contentZones).length) {
      // Watch for childlist modifications
      this._observer = new MutationObserver(this._handleContentZones.bind(this));

      this._observer.observe(this, {
        childList: true,
        subtree: false // don't care about nested stuff

      });
    } // Trigger ready event


    this._componentReady = true;
  };
  /**
   Detects when items are added and removed to make sure that the state of the content zone is accurate.

   @param {Array.<MutationRecord>} records

   @private
   */


  Component.prototype._handleContentZones = function (records) {
    var record;
    var addedNodes;
    var removedNodes;
    var node;
    var tagName;
    var propertyName;

    for (var i = 0, recordsCount = records.length; i < recordsCount; i++) {
      record = records[i];
      addedNodes = record.addedNodes;
      removedNodes = record.removedNodes; // Handle removed nodes

      for (var k = 0, removedNodesCount = removedNodes.length; k < removedNodesCount; k++) {
        node = removedNodes[k]; // only bother with element nodes

        if (node.nodeType === ELEMENT_NODE) {
          tagName = node.tagName.toLowerCase(); // we use the content zone hash to check if there is an item assigned

          propertyName = this._contentZones[tagName]; // the content zone needs to be cleared if it matches the previous item; while calling the insert, content
          // zones are removed and added again in the correct location triggering a mutation

          if (propertyName && this[propertyName] === node && node.parentNode === null) {
            this[propertyName] = undefined;
          }
        }
      } // Handle added nodes


      for (var j = 0, addedNodesCount = addedNodes.length; j < addedNodesCount; j++) {
        node = addedNodes[j]; // only bother with element nodes

        if (node.nodeType === ELEMENT_NODE) {
          tagName = node.tagName.toLowerCase(); // check if the added node matches a content zone; use the content zone hash to find if the tag name exists

          propertyName = this._contentZones[tagName]; // we update the content zone if the value is different than the current

          if (propertyName && this[propertyName] !== node) {
            // assign to content zone
            this[propertyName] = node;
          }
        }
      }
    }
  };
  /**
   Called after the element has been constructed, template rendered, and attributes applied.

   @function _initialize
   @protected
   @memberof Component#
   */

  /**
   The CSS class name to apply to the element.

   @type {String}
   @member _className
   @protected
   @memberof Component#
   */

  /**
   Called during construction, is responsible for rendering any required sub-elements.

   @function _render
   @protected
   @memberof Component#
   */

  /**
   The filter function for keyboard events. By default, any child element can trigger keyboard events. You can pass
   {@link Coral.Keys.filterInputs} to avoid listening to key events triggered from within inputs.

   @function _filterKeys
   @protected
   @memberof Component#
   */


  Component.prototype._filterKeys = function () {
    return true;
  };
  /**
   Called when this element is inserted into the DOM.

   @fires Component#coral-component:attached
   @private
   */


  Component.prototype.attachedCallback = function () {
    this.trigger('coral-component:attached'); // A component that is in the DOM should respond to global events

    this._delegateGlobalEvents();
  };
  /**
   Called when this element is removed from the DOM.

   @fires Component#coral-component:detached
   @private
   */


  Component.prototype.detachedCallback = function () {
    this.trigger('coral-component:detached'); // A component that isn't in the DOM should not be responding to global events

    this._undelegateGlobalEvents();
  };
  /**
   Apply attribute changes by invoking setters. This creates a one-way relationship between attributes and properties.
   Changing an attribute updates the property, but changing the property does not update the attribute.

   @private
   */


  Component.prototype.attributeChangedCallback = function (attrName, oldValue, newValue) {
    // Use the property name from the attribute map, otherwise just set the property by the same name
    var propName = this._attributes[attrName] || attrName; // Case 1: We are handling sets/gets for this property

    var descriptor = this._properties[propName];

    if (typeof descriptor !== 'undefined') {
      if (descriptor.attribute === null) {
        // Don't set properties that have explicitly asked to have no corresponding attribute
        return;
      }

      ['attributeTransform', 'transform'].forEach(function (v) {
        // Use the stored methods
        var transform = descriptor._methods[v];

        if (transform) {
          newValue = transform.call(this, newValue, descriptor.default);
        }
      }, this); // Don't bother with the setter unless the value changed

      if (newValue !== this[propName]) {
        // Just invoke setter
        this[propName] = newValue;
      }
    } // Case 2: We have a passive setter for this attribute


    if (this._properties['_' + propName]) {
      this._properties['_' + propName].set.call(this, newValue);
    }
  };
  /**
   Queue a DOM sync for the next animation frame. In order for this to work as expected, sync methods should never
   rely on the result of another value being synced.

   @protected
   */


  Component.prototype._queueSync = function () {
    for (var i = 0, ni = arguments.length; i < ni; i++) {
      var propName = arguments[i]; // Check if a sync is already queued

      var currentIndex = this._syncQueue.indexOf(propName);

      if (currentIndex !== -1) {
        // Move to the bottom of the queue.
        // This is necessary if a sync has already been queued for a property,
        // but another property sync is queued and specifies that this sync should come later.
        // This happens when Button.text is synced, as it wants to sync icon afterwards
        this._syncQueue.splice(currentIndex, 1);
      } // Queue the sync


      this._syncQueue.push(propName);
    }

    if (!this._syncPending) {
      window.requestAnimationFrame(this._syncDOM);
      this._syncPending = true;
    }
  };
  /**
   Sync the specified property to the DOM.

   @param {String} propName
   The name of the property to sync.
   @param {Boolean} [leaveInQueue=false]
   Whether the property should be left in the queue.

   @protected
   */


  Component.prototype._syncProp = function (propName, leaveInQueue) {
    // De-queue each sync operation
    var method = this._properties[propName].sync;

    if (method) {
      method.call(this);
    } else {
      commons._log('warn', 'Coral.Component: sync method for %s is not defined', propName);
    }

    if (!leaveInQueue) {
      var index = this._syncQueue.indexOf(propName);

      if (index !== -1) {
        this._syncQueue.splice(index, 1);
      }
    }
  };
  /**
   Sync all changed properties to the DOM.

   @protected
   */


  Component.prototype._syncDOM = function () {
    var propName; // De-queue each sync operation

    while (propName = this._syncQueue.shift()) {
      // Sync the property, and avoid removing it because we already have
      this._syncProp(propName, true);
    }

    this._syncPending = false;
  };
  /**
   Add local event and key combo listeners for this component, store global event/key combo listeners for later.

   @private

   @returns {Component} this, chainable.
   */


  Component.prototype._delegateEvents = function () {
    /*
     Add listeners to new event
     - Include in hash
     Add listeners to existing event
     - Override method and use super
     Remove existing event
     - Pass null
     */
    var match;
    var eventName;
    var eventInfo;
    var listener;
    var selector;
    var elements;
    var isGlobal;
    var isKey;
    var isResize;
    var isCapture;

    for (eventInfo in this._events) {
      listener = this._events[eventInfo]; // Extract the event name and the selector

      match = eventInfo.match(delegateEventSplitter);
      eventName = match[1] + '.CoralComponent';
      selector = match[2];

      if (selector === '') {
        // instead of null because the key module checks for undefined
        selector = undefined;
      } // Try to get the method corresponding to the value in the map


      listener = getListenerFromMethodNameOrFunction(this, eventName, listener);

      if (listener) {
        // Always execute in the context of the object
        // @todo is this necessary? this should be correct anyway
        listener = listener.bind(this); // Check if the listener is on the window

        isGlobal = eventName.indexOf('global:') === 0;

        if (isGlobal) {
          eventName = eventName.substr(7);
        } // Check if the listener is a capture listener


        isCapture = eventName.indexOf('capture:') === 0;

        if (isCapture) {
          // @todo Limitation: It should be possible to do capture:global:, but it isn't
          eventName = eventName.substr(8);
        } // Check if the listener is a key listener


        isKey = eventName.indexOf('key:') === 0;

        if (isKey) {
          if (isCapture) {
            throw new Error('Coral.Keys does not currently support listening to key events with capture');
          }

          eventName = eventName.substr(4);
        } // Check if the listener is a resize listener


        isResize = eventName.indexOf('resize') === 0;

        if (isResize) {
          if (isCapture) {
            throw new Error('Coral.commons.addResizeListener does not currently support listening to resize event with capture');
          }
        }

        if (isGlobal) {
          // Store for adding/removal
          if (isKey) {
            this._globalKeys = this._globalKeys || [];

            this._globalKeys.push({
              keyCombo: eventName,
              selector: selector,
              listener: listener
            });
          } else {
            this._globalEvents = this._globalEvents || [];

            this._globalEvents.push({
              eventName: eventName,
              selector: selector,
              listener: listener,
              isCapture: isCapture
            });
          }
        } else {
          // Events on the element itself
          if (isKey) {
            // Create the keys instance only if its needed
            this._keys = this._keys || new Keys(this, {
              filter: this._filterKeys,
              // Execute key listeners in the context of the element
              context: this
            }); // Add listener locally

            this._keys.on(eventName, selector, listener);
          } else if (isResize) {
            if (selector) {
              elements = document.querySelectorAll(selector);

              for (var i = 0; i < elements.length; ++i) {
                commons.addResizeListener(elements[i], listener);
              }
            } else {
              commons.addResizeListener(this, listener);
            }
          } else {
            this._vent.on(eventName, selector, listener, isCapture);
          }
        }
      }
    }
  };
  /**
   Remove global event listeners for this component.

   @private

   @returns {Component} this, chainable.
   */


  Component.prototype._undelegateGlobalEvents = function () {
    var i;

    if (this._globalEvents) {
      // Remove global event listeners
      for (i = 0; i < this._globalEvents.length; i++) {
        var event = this._globalEvents[i];
        events.off(event.eventName, event.selector, event.listener, event.isCapture);
      }
    }

    if (this._globalKeys) {
      // Remove global key listeners
      for (i = 0; i < this._globalKeys.length; i++) {
        var key = this._globalKeys[i];
        keys$1.off(key.keyCombo, key.selector, key.listener);
      }
    }

    if (this._keys) {
      this._keys.destroy(true);
    }

    return this;
  };
  /**
   Add global event listeners for this component.

   @private

   @returns {Component} this, chainable.
   */


  Component.prototype._delegateGlobalEvents = function () {
    var i;

    if (this._globalEvents) {
      // Add global event listeners
      for (i = 0; i < this._globalEvents.length; i++) {
        var event = this._globalEvents[i];
        events.on(event.eventName, event.selector, event.listener, event.isCapture);
      }
    }

    if (this._globalKeys) {
      // Add global key listeners
      for (i = 0; i < this._globalKeys.length; i++) {
        var key = this._globalKeys[i];
        keys$1.on(key.keyCombo, key.selector, key.listener);
      }
    }

    if (this._keys) {
      this._keys.init(true);
    }

    return this;
  };
  /**
   Add an event listener.

   @param {String} eventName
   The event name to listen for.
   @param {String} [selector]
   The selector to use for event delegation.
   @param {Function} func
   The function that will be called when the event is triggered.
   @param {Boolean} [useCapture=false]
   Whether or not to listen during the capturing or bubbling phase.

   @returns {Component} this, chainable.
   */


  Component.prototype.on = function (eventName, selector, func, useCapture) {
    this._vent.on(eventName, selector, func, useCapture);

    return this;
  };
  /**
   Remove an event listener.

   @param {String} eventName
   The event name to stop listening for.
   @param {String} [selector]
   The selector that was used for event delegation.
   @param {Function} func
   The function that was passed to <code>on()</code>.
   @param {Boolean} [useCapture]
   Only remove listeners with <code>useCapture</code> set to the value passed in.

   @returns {Component} this, chainable.
   */


  Component.prototype.off = function (eventName, selector, func, useCapture) {
    this._vent.off(eventName, selector, func, useCapture);

    return this;
  };
  /**
   Trigger an event.

   @param {String} eventName
   The event name to trigger.
   @param {Object} [props]
   Additional properties to make available to handlers as <code>event.detail</code>.
   @param {Boolean} [bubbles=true]
   Set to <code>false</code> to prevent the event from bubbling.
   @param {Boolean} [cancelable=true]
   Set to <code>false</code> to prevent the event from being cancelable.

   @returns {CustomEvent} CustomEvent object
   */


  Component.prototype.trigger = function (eventName, props, bubbles, cancelable) {
    // When 'bubbles' is not set, then default to true:
    bubbles = bubbles || bubbles === undefined; // When 'cancelable' is not set, then default to true:

    cancelable = cancelable || cancelable === undefined; // CustomEvent is polyfilled for IE via Polymer:
    // https://github.com/Polymer/CustomElements/blob/master/src/boot.js#L84-L93

    var event = new CustomEvent(eventName, {
      bubbles: bubbles,
      cancelable: cancelable,
      detail: props
    }); // default value in case the dispatching fails

    var defaultPrevented = false;

    try {
      // leads to NS_ERROR_UNEXPECTED in Firefox
      // https://bugzilla.mozilla.org/show_bug.cgi?id=329509
      defaultPrevented = !this.dispatchEvent(event);
    } catch (e) {} // Check if the defaultPrevented status was correctly stored back to the event object


    if (defaultPrevented !== event.defaultPrevented) {
      // dispatchEvent() doesn't correctly set event.defaultPrevented in IE 9
      // However, it does return false if preventDefault() was called
      // Unfortunately, the returned event's defaultPrevented property is read-only
      // We need to work around this such that (patchedEvent instanceof Event) === true
      // First, we'll create an object that uses the event as its prototype
      // This gives us an object we can modify that is still technically an instanceof Event
      var patchedEvent = Object.create(event); // Next, we set the correct value for defaultPrevented on the new object
      // We cannot simply assign defaultPrevented, it causes a "Invalid Calling Object" error in IE 9
      // For some reason, defineProperty doesn't cause this

      Object.defineProperty(patchedEvent, 'defaultPrevented', {
        value: defaultPrevented
      });
      return patchedEvent;
    }

    return event;
  };
  /**
   Non-destructively remove this element. It can be re-added by simply appending it to the document again.
   It will be garbage collected if there are no more references to it.
   */


  Component.prototype.remove = function () {
    if (this.parentNode) {
      // Just remove the element from its parent. This will automatically invoke detachedCallback
      this.parentNode.removeChild(this);
    }
  };
  /**
   @ignore
   @private
   */


  Component.prototype._doSet = function (property, value, silent) {
    // Get property descriptor from constructor. Property descriptors are stored on constructor with methods
    // dereferenced to actual functions
    var descriptor = this._properties && this._properties[property];

    if (descriptor) {
      if (descriptor.contentZone && !(value instanceof HTMLElement) && this[property].set) {
        // If the property is a content zone and the passed value is not a HTML element,
        // assume we're setting multiple properties of the existing content zone with an object
        this[property].set(value);
      } // In case the Content Zone is not a Component, we still want to be able to set the new values into it
      else if (descriptor.contentZone && !(value instanceof HTMLElement) && _typeof(value) === 'object' && this[property] instanceof HTMLElement) {
          Object.keys(value).forEach(function (prop) {
            this[prop] = value[prop];
          }, this[property]);
        } else if (descriptor._methods && descriptor._methods.set) {
          // Call and pass true silent
          // Use the actual setter method instead of the original method so events are triggered etc
          descriptor._methods.set.call(this, value, !!silent);
        } else {
          this[property] = value;
        }
    } else {
      // Simply set the property if it doesn't exist or has no setter
      this[property] = value;
    }
  };
  /**
   Set a single property.

   @name Component#set
   @function

   @param {String} property
   The name of the property to set.
   @param {*} value
   The value to set the property to.
   @param {Boolean} silent
   If true, events should not be triggered as a result of this set.

   @returns {Component} this, chainable.
   */

  /**
   Set multiple properties.

   @name Component#set
   @function

   @param {Object.<String, *>} properties
   An object of property/value pairs to set.
   @param {Boolean} silent
   If true, events should not be triggered as a result of this set.

   @returns {Component} this, chainable.
   */


  Component.prototype.set = function (propertyOrProperties, valueOrSilent, silent) {
    var property;
    var properties;
    var value;

    if (typeof propertyOrProperties === 'string') {
      // Set a single property
      property = propertyOrProperties;
      value = valueOrSilent;

      this._doSet(property, value, silent);
    } else {
      properties = propertyOrProperties;
      silent = valueOrSilent; // Set a map of properties

      for (property in properties) {
        value = properties[property];

        this._doSet(property, value, silent);
      }
    }

    return this;
  };
  /**
   Get the value of a property.

   @param {String} property
   The name of the property to fetch the value of.

   @returns {*} Property value.
   */


  Component.prototype.get = function (property) {
    return this[property];
  };
  /**
   Show this component.

   @returns {Component} this, chainable
   */


  Component.prototype.show = function () {
    if (!this.hidden) {
      return this;
    }

    this.hidden = false;
    return this;
  };
  /**
   Hide this component.

   @returns {Component} this, chainable
   */


  Component.prototype.hide = function () {
    if (this.hidden) {
      return this;
    }

    this.hidden = true;
    return this;
  }; // Copy all methods for baseTagName-style inheritance


  Component.prototype._methods = {};

  for (var prop in Component.prototype) {
    if (Component.prototype.hasOwnProperty(prop)) {
      Component.prototype._methods[prop] = Component.prototype[prop];
    }
  }

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  /**
   A property descriptor.

   @typedef {Object} Coral~PropertyDescriptor
   @property {Function} [transform=null]
   The value transformation function. Values passed to setters will be ran through this function first.
   @property {Function} [attributeTransform=transform]
   The value transformation function for attribute. The value given by <code>attributeChangedCallback</code> will be
   ran through this function first before passed to setters.
   @property {Coral.validate~validationFunction} [validate={@link Coral.validate.valueMustChange}]
   The value validation function. A validation function that takes two arguments, <code>newValue</code> and
   <code>oldValue</code>, returning true if the setter should run or false if not.
   @property {String|Function} [trigger=null]
   The name of the event to trigger after this property changes, or a {Function} to call that will trigger the event.
   The function is passed the <code>newValue</code> and <code>oldValue</code>.
   @property {String|Function} [triggerBefore=null]
   The name of the event to trigger before this property changes, a {Function} to call that will trigger the event,
   or <code>true</code> to set the name automatically. The function is passed the <code>newValue</code> and
   <code>oldValue</code> and must return the Event object for <code>preventDefault()</code> to work within handlers. If
   set to <code>true</code>, {@link Coral~PropertyDescriptor} must be a string with a colon in it, such as
   <code>coral-component:change</code>, which results in <code>coral-component:beforechange</code>. If set to
   <code>false</code>, no event will be triggered before the setter is ran.
   @property {String} [attribute=propName]
   The name of the attribute corresponding to this property. If not provided, the property name itself will be used.
   If <code>null</code> is provided, the property will not be set by a corresponding attribute.
   @property {Boolean} [reflectAttribute=false]
   Whether this property should be reflected as an attribute when changed. This is useful when you want to style CSS
   according to the property's existence or value.
   @property {Function} [sync=null]
   The method to be called when this property's value should be synced to the DOM.
   @property {String|Array.<String>} [alsoSync=null]
   A property or list of properties that should be synced after this property is synced.
   @property {Function} [set={@link Coral~defaultSet}]
   The setter for this property.
   @property {Function} [get={@link Coral~defaultGet}]
   The getter for this property.
   @property {Boolean} [override=false]
   Whether this property descriptor should completely override. If <code>false</code>, this descriptor will augment
   the existing descriptor. See {@link Coral.register.augmentProperties} for details.
   @property {Boolean} [contentZone=false]
   Whether this property represents a content zone. Content zones are treated differently when set() is invoked such
   that the provided value is passed to the content zone's set() method.
   */
  // These properties won't be treated as methods

  var specialProperties = {
    extend: true,
    properties: true,
    events: true,
    _elements: true,
    name: true,
    namespace: true,
    tagName: true,
    baseTagName: true,
    className: true
  };

  function noop() {}

  function passThrough(value) {
    return value;
  }
  /**
   Creates an array with validation functions for the given properties. If no validate is specified, then the default
   validator is used.
   @ignore
   */


  function makeValidate(descriptor) {
    if (!descriptor.validate) {
      return [validate.valueMustChange];
    }

    if (Array.isArray(descriptor.validate)) {
      return descriptor.validate;
    }

    return [descriptor.validate];
  }
  /**
   Make a attribute reflect function for the given property. If the property is not reflected, return a noop.
   @ignore
   */


  function makeReflect(propName, descriptor) {
    if (!descriptor.reflectAttribute) {
      return noop;
    }

    var attrName = descriptor.attribute || propName;
    return function doReflect(value, silent) {
      // Reflect the property
      if (value === false || value === null) {
        // Non-truthy attributes should be destroyed
        this.removeAttribute(attrName);
      } else {
        // Boolean true for a value just means the property should exist
        if (value === true) {
          value = '';
        } // Only perform the set if the attribute is of a different value
        // This avoids triggering mutation observers unnecessarily


        if (this.getAttribute(attrName) !== value) {
          this.setAttribute(attrName, value);
        }
      }
    };
  }
  /**
   Make an event trigger function for the given property. If no event should be triggered, return a noop.
   @ignore
   */


  function makeTrigger(trigger) {
    if (!trigger) {
      return noop;
    }

    if (typeof trigger === 'function') {
      return trigger;
    }

    var eventName = trigger;
    return function doTrigger(newValue, oldValue) {
      // Trigger an event that has the new and old values under detail
      return this.trigger(eventName, {
        oldValue: oldValue,
        value: newValue
      });
    };
  }
  /**
   Make a queue sync function for the given property. If nothing needs to be synced, return a noop.
   @ignore
   */


  function makeQueueSync(propName, descriptor) {
    var propList = descriptor.alsoSync;
    var sync = descriptor.sync;

    if (!sync && !propList) {
      return noop;
    }

    if (propList) {
      // Other properties in addition to ours
      if (Array.isArray(propList)) {
        propList.unshift(propName);
      } else {
        propList = [propName, propList];
      }

      return function doMultiSync(value) {
        // Sync the list of properties
        this._queueSync.apply(this, propList);
      };
    }

    return function doSync(value) {
      // Sync the property
      this._queueSync(propName);
    };
  }
  /**
   Create and store the methods back to the property descriptor, then store the descriptor on the prototype.
   This enables overriding descriptor parts.

   @ignore
   */


  function storeDescriptor(proto, propName, descriptor) {
    // triggerBefore can be function, boolean, or string
    var triggerBeforeValue;

    if (typeof descriptor.triggerBefore === 'function' || typeof descriptor.triggerBefore === 'string') {
      // Directly use string or function, makeTrigger will do the rest
      triggerBeforeValue = descriptor.triggerBefore;
    } else if (descriptor.triggerBefore === true) {
      // Automatically set name based on descriptor.trigger
      if (typeof descriptor.trigger === 'string' && descriptor.trigger.indexOf(':') !== -1) {
        triggerBeforeValue = descriptor.trigger.replace(':', ':before');
      } else {
        throw new Error('Coral.register: Cannot automatically set "before" event name unless descriptor.trigger ' + 'is a string that conatins a colon');
      }
    } // Use provided setter, or make a setter that sets a "private" underscore-prefixed variable


    descriptor.set = descriptor.set || makeBasicSetter(propName); // Use provided getter, or make a getter that returns a "private" underscore-prefixed variable

    descriptor.get = descriptor.get || makeBasicGetter(propName); // Store methods

    var inheritedMethods = descriptor._methods;
    descriptor._methods = {}; // store references to inherited methods in descriptor._methods

    if (inheritedMethods) {
      for (var methodName in inheritedMethods) {
        descriptor._methods[methodName] = inheritedMethods[methodName];
      }
    }

    descriptor._methods.triggerBefore = makeTrigger(triggerBeforeValue);
    descriptor._methods.trigger = makeTrigger(descriptor.trigger);
    descriptor._methods.transform = descriptor.transform || passThrough;
    descriptor._methods.attributeTransform = descriptor.attributeTransform || passThrough;
    descriptor._methods.reflectAttribute = makeReflect(propName, descriptor);
    descriptor._methods.queueSync = makeQueueSync(propName, descriptor); // We need to store the list of validators back on the descriptor as we modify this inside of makeValidate

    descriptor._methods.validate = makeValidate(descriptor); // Store reverse mapping of attribute -> property

    if (descriptor.attribute) {
      proto._attributes[descriptor.attribute] = propName;
    } else {
      // Remove the mapping in case it was overridden
      proto._attributes[descriptor.attribute] = null;
    } // Store the descriptor


    proto._properties[propName] = descriptor;
  }
  /**
   Create a generic getter.

   @param {String} propName
   The property name whose getter should be invoked.

   @ignore
   */


  function makeGetter(propName) {
    return function getter() {
      // Invoke the original getter
      return this._properties[propName].get.call(this);
    };
  }
  /**
   Create a genertic setter.

   @param {String} propName
   The name of the property.

   @alias register.makeSetter

   @returns {Function} The setter function.
   */


  function makeSetter(propName) {
    return function setter(value, silent) {
      var descriptor = this._properties[propName];
      var methods = descriptor._methods; // Transform the value, passing the default
      // The default value cannot be cached in the outer closure as that would prevent monkey-patching

      var newValue = methods.transform.call(this, value, this._properties[propName].default); // Store the old value before the setter is invoked

      var oldValue = this[propName]; // Performs all the validations until one of them fails

      var self = this;
      var failed = methods.validate.some(function (validator) {
        return !validator.call(self, newValue, oldValue);
      }); // If a validation failed then we return

      if (failed) {
        return;
      }

      if (!silent) {
        var event = methods.triggerBefore.call(this, newValue, oldValue);

        if (event && event.defaultPrevented) {
          // Allow calls to preventDefault() to stop events
          return;
        }
      } // Invoke the original setter


      descriptor.set.call(this, newValue, silent); // Reflect the attribute

      methods.reflectAttribute.call(this, newValue); // Queue property sync. Do this before trigger, in case an event listener wants to unroll the sync queue

      methods.queueSync.call(this); // Trigger an event

      if (!silent) {
        methods.trigger.call(this, newValue, oldValue);
      } // Store that this prop has been set
      // This is used during initialization when deciding whether to apply default values


      this._setProps[propName] = true;
    };
  }

  function makeBasicGetter(propName) {
    var tempVarName = '_' + propName;
    /**
     Gets the corresponding underscore prefixed "private" property by the same name.
      @function Coral~defaultGet
     @returns The prefixed property
     */

    return function getter() {
      return this[tempVarName];
    };
  }

  function makeBasicSetter(propName) {
    var tempVarName = '_' + propName;
    /**
     Sets the corresponding underscore prefixed "private" property by the same name.
      @param {*} value  The value to set
     @function Coral~defaultSet
     */

    return function setter(value) {
      this[tempVarName] = value;
    };
  }
  /**
   Define a set of {@link Coral~PropertyDescriptors} on the passed object

   @param {Object} proto
   The object to define properties on, usually a prototype.
   @param {Object.<String, Coral~PropertyDescriptor>} properties
   A map of property names to their corresponding descriptors.

   @alias register.defineProperties
   */


  function defineProperties(proto, properties) {
    // Loop over properties and define them on the prototype
    for (var propName in properties) {
      if (!properties[propName]) {
        // Skip properties that were removed to avoid redefinition
        continue;
      }

      defineProperty$1(proto, propName, properties[propName]);
    }
  }
  /**
   Define a single {@link Coral~PropertyDescriptors} on the passed object

   @param {Object} proto
   The object to define properties on, usually a prototype.
   @param {String} propName
   The name of the property.
   @param {Coral~PropertyDescriptor} descriptor
   A property descriptor

   @alias register.defineProperty
   */


  function defineProperty$1(proto, propName, descriptor) {
    // Handle mixin case
    if (typeof descriptor === 'function') {
      // Let descriptor apply itself to the prototype
      // This allows it to add methods
      // Use its return value as the actual descriptor
      descriptor = descriptor(proto, propName); // If nothing is returned, we're done with this property

      if (!descriptor) {
        throw new Error('Coral.register.defineProperty: Property function did not return a descriptor for ' + propName);
      }
    } // Store the associated methods


    storeDescriptor(proto, propName, descriptor); // Create the generic setters and getters for this property
    // Store them back so we can access them for silent sets
    // These do not need to be overridden as they delegate to this._properties._methods

    var actualSetter = descriptor._methods.set = makeSetter(propName);
    var actualGetter = descriptor._methods.get = makeGetter(propName); // Define the property

    Object.defineProperty(proto, propName, {
      // All properties are enumerable
      enumerable: true,
      // No properties are configurable
      configurable: false,
      set: actualSetter,
      get: actualGetter
    });
  }

  var tagPrototypes = {};
  /**
   Memoized getProtoTypeOf for HTML tags
   @ignore
   */

  function getPrototypeOfTag(tagName) {
    tagPrototypes[tagName] = tagPrototypes[tagName] || Object.getPrototypeOf(document.createElement(tagName));
    return tagPrototypes[tagName];
  }
  /**
   Register a Coral component, setting up inheritance, mixins, properties, and the associated custom element.

   @memberof Coral
   @static

   @param {Object} options
   Component options.
   @param {Object} options.namespace
   Namespace where to store the constructor.
   @param {String} options.name
   Name of the constructor (i.e. 'Accordion.Item'). The constructor will be available under 'Coral' at the path
   specified by the name.
   @param {String} options.tagName
   Name of the new element (i.e 'coral-component').
   @param {String} [options.baseTagName = (none)]
   Name of the tag to extend (i.e. 'button'). This is only required when extending an existing HTML element such that
   the <code>&lt;button is="custom-element"&gt;</code> style will be used.
   @param {Object} [options.extend = Coral.Component]
   Base class of the component. When extending an existing HTML element, this should match the interface implemented
   by the tag -- that is, for <code>baseTagName: 'button'</code> you should pass
   <code>extend: HTMLButtonElement</code>.
   @param {Array.<Object|Coral~mixin>} [options.mixins]
   Mixin or {Array} of mixins to add. Mixins can be an {Object} or a {Coral~mixin}.
   @param {Object.<String, Coral~PropertyDescriptor>} [options.properties]
   A map of property names to their corresponding descriptors.
   @param {Object} [options.events]
   Map of the events and their handler.
   @param {Object} [options._elements]
   Map of elements and their locations used for caching.
   */


  var register = function register(options) {
    // Throw away options.extend if baseTagName provided and the prototype isn't part of Coral.Component
    if (options.extend && !options.extend.prototype._methods) {
      options.extend = Component;
    } // Extend Coral.Component if nothing is provided


    var extend = options.extend || Component; // We'll use the prototype of the argument passed constructor we're extending

    var baseComponentProto = extend.prototype;
    var actualPrototype = baseComponentProto; // Use passed or be an empty object so mixins can add properties to components that don't define any
    // Don't modify the passed properties object directly

    var properties = options.properties ? commons.extend({}, options.properties) : {};

    if (options.baseTagName) {
      // If we're extending a base tag, we need to use its prototype, not the Component's
      actualPrototype = getPrototypeOfTag(options.baseTagName);
    } // Setup the prototype chain


    var proto = Object.create(actualPrototype); // Store a reference to the next component's prototype in the chain
    // This allows us to crawl up the component prototype chain later

    proto._proto = baseComponentProto;

    if (options.baseTagName) {
      var protoChain = []; // Build the prototype chain

      var curBaseProto = baseComponentProto;

      while (curBaseProto && curBaseProto._methods) {
        protoChain.unshift(curBaseProto);
        curBaseProto = curBaseProto._proto;
      } // Iterate over the prototype chain and mix all the methods in


      while (curBaseProto = protoChain.shift()) {
        for (var methodName in curBaseProto._methods) {
          proto[methodName] = curBaseProto[methodName];
        }
      } // Note that we'll already get a flattened list of properties from _properties
      // So we don't have to do something similar there

    } // Create attribute -> property mappings and the property descriptor map
    // Do this before we mixin/override properties as storeDescriptor() will write back to _attributes and _properties


    proto._attributes = commons.extend({}, baseComponentProto._attributes);
    proto._properties = {}; // Define and inherit events from parent class

    proto._events = commons.extend({}, baseComponentProto._events, options.events); // Define and inherit sub-elements from parent class

    proto._elements = commons.extend({}, baseComponentProto._elements, options._elements); // Store the name and namespace on the prototype
    // the toString method of Coral.Component uses this

    proto._componentName = options.name;
    proto._namespace = options.namespace || window.Coral; // CSS className

    proto._className = options.className; // Add methods to the prototype, and store them in an object for easy access
    // We'll use this object when extending base tagnames later

    var _methods = proto._methods = {};

    for (var method in options) {
      if (!specialProperties[method]) {
        proto[method] = _methods[method] = options[method];
      }
    } // Add mixins to the prototype
    // Do this before combining properties to allow seemless modification of properties overridden by mixins


    if (options.mixins) {
      commons.mixin(proto, // A single Object, Function, or Array thereof
      options.mixins, {
        // Pass properties so functional mixins can augment them
        properties: properties
      });
    } // Store and override property descriptors


    commons.augment(proto._properties, baseComponentProto._properties, properties, function (existingDesc, newDesc, propName) {
      // Drop properties that are not defined
      if (!newDesc) {
        return null;
      } // The child component (newDesc) determines whether to ignore the base component's descriptor


      if (newDesc.override === true) {
        // The new component wants to ignore the base component's descriptor
        return newDesc;
      } // Combine and override as necessary
      // The order of arguments seems backwards because we use this method in Coral.register.augmentProperties
      // This makes it so the existing setter is called first
      // It also makes it so the new descriptor will override other properties


      var combinedDesc = commons.augment( // Don't modify the existing descriptor
      {}, newDesc, existingDesc, handleAugmentPropertyCollision); // Store the new methods and descriptor

      storeDescriptor(proto, propName, combinedDesc); // The property is already defined, so tell defineProperties not to define it again

      properties[propName] = undefined; // storeDescriptor() already stored the descriptor, but we have to return it anyway

      return combinedDesc;
    }); // Removed properties that have been removed by inheriting components

    for (var propName in proto._properties) {
      if (!proto._properties[propName]) {
        delete proto._properties[propName];
      }
    } // Define properties last
    // This allows mixins to merge and modify properties


    if (options.baseTagName) {
      // Define ALL properties as we don't pick up any from the prototype
      defineProperties(proto, proto._properties);
    } else {
      // Define just the new properties
      defineProperties(proto, properties);
    } // The options to be passed to registerElement


    var registrationOptions = {
      prototype: proto
    };

    if (options.baseTagName) {
      // When a base tag is provided, we need to tell registerElement
      registrationOptions.extends = options.baseTagName;
    } // Register the element
    // This returns a constructor


    var Constructor = document.registerElement(options.tagName, registrationOptions); // Assign the constructor at the correct location

    commons.setSubProperty(options.namespace || window.Coral || window, options.name, Constructor);
    return Constructor;
  }; // Expose globally


  register.defineProperties = defineProperties;
  register.defineProperty = defineProperty$1;
  /**
   Augment a set of property descriptors with another set.
   The <code>dest</code> property descriptors map is modified in place.
   The individual property descriptors (values of <code>dest</code>) are not modified.

   @param {Object<String,Coral~PropertyDescriptor>} dest
   The set of property descriptors to agument.
   @param {Object<String,Coral~PropertyDescriptor>} source
   The set of property descriptors to use.
   @param {Coral.commons~handleCollision} [handleCollision]
   Called if the descriptor property being copied is already present on the destination.
   The return value will be used as the property value.
   By default, if <code>sync</code> or <code>set</code> collides, both provided methods will be called.
   By default, if any other descriptor property collides, the destination's value will be used.
   */

  register.augmentProperties = function (dest, source, handleCollision) {
    commons.augment(dest, source, function (existingDesc, newDesc, propName) {
      // The mixin target (dest) determines whether to ignore the mixin's properties
      if (existingDesc.override === true) {
        // The mixin target (dest) wants to ignore the mixin's descriptor
        return existingDesc;
      } // Deep-augment individual property descriptor properties


      var combinedDesc = commons.augment( // Don't modify the existing descriptor
      {}, existingDesc, newDesc, handleCollision || handleAugmentPropertyCollision);
      return combinedDesc;
    });
  };
  /**
   Default collision handler when augmenting properties
   @ignore
   */


  function handleAugmentPropertyCollision(destValue, sourceValue, descPropName) {
    switch (descPropName) {
      case 'sync':
      case 'set':
        // Use both methods
        return callBoth(sourceValue, destValue);

      default:
        // Use component's value
        return destValue;
    }
  }
  /**
   Return a function that calls both functions and ignores their return values
   @ignore
   */


  function callBoth(first, second) {
    return function () {
      first.apply(this, arguments);
      second.apply(this, arguments);
    };
  }

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  /**
   Property descriptor factory factories
   @namespace
   */

  var property = {};
  /**
   A factory that creates descriptor factories that proxy a local property/attribute to a sub-property.
   This factory should be used when you need the property of an sub-object to be set or queued for sync when a local
   property changes.
   This is especially useful for setting the innerHTML or other properties of sub-elements.

   @param {Coral~PropertyDescriptor} descriptor
   The property descriptor
   @param {String} path
   The path under <code>this</code> to proxy to. For instance, <code>_elements.header.innerHTML</code> would proxy
   to the <code>innerHTML</code> of the element with the handle <code>header</code>
   @param {Boolean} [needsDOMSync=false]
   Whether the property set should happen asynchronously on the next animation frame.

   @returns {Function} The descriptor factory.
   */

  property.proxy = function (descriptor) {
    // Store the path
    var path = descriptor.path;

    function setProxy(value, silent) {
      /* jshint validthis: true */
      commons.setSubProperty(this, path, value);
    }

    function getProxy() {
      /* jshint validthis: true */
      return commons.getSubProperty(this, path);
    }

    var functionalDescriptor = function functionalDescriptor(proto, propName) {
      var tempPropName = '_' + propName;

      if (descriptor.needsDOMSync) {
        // If a sync needs to happen, define a method
        descriptor.sync = function () {
          commons.setSubProperty(this, path, this[tempPropName]); // Use undefined here, not null

          this[tempPropName] = undefined;
        };

        descriptor.set = function (value, silent) {
          this[tempPropName] = value;
        };

        descriptor.get = function () {
          // Return the temporary variable if it's set, otherwise get the property we're proxying
          return typeof this[tempPropName] === 'undefined' ? commons.getSubProperty(this, path) : this[tempPropName];
        };
      } else {
        // If we don't need to sync, simply delegate to the property
        // @todo test if it's faster to compose a function with new Function()
        descriptor.set = setProxy;
        descriptor.get = getProxy;
        descriptor.sync = null;
      }

      return descriptor;
    }; // Override by default
    // Store this on the function so Coral.register can check it


    functionalDescriptor.override = typeof descriptor.override !== 'undefined' ? descriptor.override : true; // Return a function that sets up the property

    return functionalDescriptor;
  };
  /**
   A factory that creates descriptor factories that proxy a local property/attribute to a sub-element's attribute.

   This is useful when you want to proxy a property/attrubute to a sub-element as an attribute set/removal.
   For instance, you may want to proxy the <code>aria-labelledby</code> property of a field component to the actual
   input inside of the component for accessibility purposes.

   When using this property factory, be sure to specify a property name not implemented by the browser already.

   @param {Coral~PropertyDescriptor} descriptor
   The property descriptor.
   @param {String} descriptor.attribute
   The attribute to proxy.
   @param {String} descriptor.handle
   The handle of the element to proxy the attribute to.
   */


  property.proxyAttr = function (descriptor) {
    var attribute = descriptor.attribute;
    var handle = descriptor.handle;

    var functionalDescriptor = function functionalDescriptor(proto, propName) {
      return commons.extend({
        attribute: attribute,
        set: function set(value) {
          // Both false and null should remove the attribute
          // This supports the behavior of Coral.transform.boolean as well as non-transformed attributes
          // Any other value, including empty string, should set it
          this._elements[handle][value === false || value === null ? 'removeAttribute' : 'setAttribute'](attribute, value);
        },
        get: function get() {
          return this._elements[handle].getAttribute(attribute);
        }
      }, descriptor);
    }; // Override by default
    // Store this on the function so Coral.register can check it


    functionalDescriptor.override = typeof descriptor.override !== 'undefined' ? descriptor.override : true;
    return functionalDescriptor;
  };
  /**
   A factory that creates descriptor factories for content zones.

   @param {Coral~PropertyDescriptor} descriptor
   The property descriptor.
   @param {String} descriptor.handle
   The handle of the element to proxy the attribute to.
   @param {String} [descriptor.tagName]
   The tag name to expect. If not provided, any tag will be accepted.
   @param {Function} [descriptor.set]
   Executed after the property is set.
   @param {Function} [descriptor.get]
   An alternate getter. If not provided, the element specified by the handle will be returned.
   @param {Function} [descriptor.insert]
   The method that inserts the content zone into the element.
   @param {Boolean} defaultContentZone
   Set to true if this is the default content zone that {@link Coral.Component#render} moves orphaned elements into.
   */


  property.contentZone = function (descriptor) {
    var handle = descriptor.handle;
    var expectedTagName = descriptor.tagName;
    var additionalSetter = descriptor.set;
    var alternateGetter = descriptor.get;
    var insert = descriptor.insert;

    var functionalDescriptor = function functionalDescriptor(proto, propName) {
      if (descriptor.defaultContentZone) {
        // Alias the setter/getter to the content zone's property
        Object.defineProperty(proto, 'defaultContentZone', {
          set: function set(value) {
            this[propName] = value;
          },
          get: function get() {
            return this[propName];
          }
        });
      } // Combine the provided descriptor with the factory's properties
      // Give precidence to the factory's properties


      return commons.extend({}, descriptor, {
        contentZone: true,
        set: function set(value) {
          var oldNode;

          if (!!value) {
            if (!(value instanceof HTMLElement)) {
              throw new Error('DOMException: Failed to set the "' + propName + '" property on "' + this.toString() + '": The provided value is not of type "HTMLElement".');
            }

            if (expectedTagName && value.tagName.toLowerCase() !== expectedTagName) {
              throw new Error('DOMException: Failed to set the "' + propName + '" property on "' + this.toString() + '": The new ' + propName + ' element is of type "' + value.tagName + '". It must be a "' + expectedTagName.toUpperCase() + '" element.');
            }

            oldNode = this._elements[handle]; // Replace the existing element

            if (insert) {
              // Remove old node
              if (oldNode && oldNode.parentNode) {
                oldNode.parentNode.removeChild(oldNode);
              } // Insert new node


              insert.call(this, value);
            } else {
              if (oldNode && oldNode.parentNode) {
                commons._log('warn', this._componentName + ' does not define an insert method for content zone ' + handle + ', falling back to replace.'); // Old way -- assume we have an old node


                this._elements[handle].parentNode.replaceChild(value, this._elements[handle]);
              } else {
                commons._log('error', this._componentName + ' does not define an insert method for content zone ' + handle + ', falling back to append.'); // Just append, which may introduce bugs, but at least doesn't crazy


                this.appendChild(value);
              }
            }
          } else {
            // we need to remove the content zone if it exists
            oldNode = this._elements[handle];

            if (oldNode && oldNode.parentNode) {
              oldNode.parentNode.removeChild(oldNode);
            }
          } // Re-assign the handle to the new element


          this._elements[handle] = value; // Invoke the setter

          if (typeof additionalSetter === 'function') {
            additionalSetter.call(this, value);
          }
        },
        get: alternateGetter || function () {
          return this._elements[handle];
        }
      });
    };

    return functionalDescriptor;
  };

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  window.Vent = window.Vent || vent;

  var delegateEventSplitter$1 = /^(\S+)\s*(.*)$/;
  /**
   Enumeration representing the tracking options.

   @typedef {Object} TrackingEnum

   @property {String} ON
   Enables tracking of the component interactions.
   @property {String} OFF
   Disables tracking of the component interactions.
   */

  var tracking$1 = {
    ON: 'on',
    OFF: 'off'
  };
  /**
   Return the method corresponding to the method name or the function, if passed.
   @ignore
   */

  var getListenerFromMethodNameOrFunction$1 = function getListenerFromMethodNameOrFunction(obj, eventName, methodNameOrFunction) {
    // Try to get the method
    if (typeof methodNameOrFunction === 'function') {
      return methodNameOrFunction;
    } else if (typeof methodNameOrFunction === 'string') {
      if (!obj[methodNameOrFunction]) {
        throw new Error("Coral.Component: Unable to add ".concat(eventName, " listener for ").concat(obj.toString(), ", method\n      ").concat(methodNameOrFunction, " not found"));
      }

      var listener = obj[methodNameOrFunction];

      if (typeof listener !== 'function') {
        throw new Error("Coral.Component: Unable to add ".concat(eventName, " listener for ").concat(obj.toString(), ", listener is a\n      ").concat(_typeof(listener), " but should be a function"));
      }

      return listener;
    } else if (methodNameOrFunction) {
      // If we're passed something that's truthy (like an object), but it's not a valid method name or a function, get
      // angry
      throw new Error("Coral.Component: Unable to add ".concat(eventName, " listener for ").concat(obj.toString(), ", ").concat(methodNameOrFunction, "\n    is neither a method name or a function"));
    }

    return null;
  };
  /**
   Add local event and key combo listeners for this component, store global event/key combo listeners for later.
   @ignore
   */


  var delegateEvents = function delegateEvents() {
    /*
     Add listeners to new event
     - Include in hash
     Add listeners to existing event
     - Override method and use super
     Remove existing event
     - Pass null
     */
    var match;
    var eventName;
    var eventInfo;
    var listener;
    var selector;
    var elements;
    var isGlobal;
    var isKey;
    var isResize;
    var isCapture;

    for (eventInfo in this._events) {
      listener = this._events[eventInfo]; // Extract the event name and the selector

      match = eventInfo.match(delegateEventSplitter$1);
      eventName = "".concat(match[1], ".CoralComponent");
      selector = match[2];

      if (selector === '') {
        // instead of null because the key module checks for undefined
        selector = undefined;
      } // Try to get the method corresponding to the value in the map


      listener = getListenerFromMethodNameOrFunction$1(this, eventName, listener);

      if (listener) {
        // Always execute in the context of the object
        // @todo is this necessary? this should be correct anyway
        listener = listener.bind(this); // Check if the listener is on the window

        isGlobal = eventName.indexOf('global:') === 0;

        if (isGlobal) {
          eventName = eventName.substr(7);
        } // Check if the listener is a capture listener


        isCapture = eventName.indexOf('capture:') === 0;

        if (isCapture) {
          // @todo Limitation: It should be possible to do capture:global:, but it isn't
          eventName = eventName.substr(8);
        } // Check if the listener is a key listener


        isKey = eventName.indexOf('key:') === 0;

        if (isKey) {
          if (isCapture) {
            throw new Error('Coral.Keys does not currently support listening to key events with capture');
          }

          eventName = eventName.substr(4);
        } // Check if the listener is a resize listener


        isResize = eventName.indexOf('resize') === 0;

        if (isResize) {
          if (isCapture) {
            throw new Error('Coral.commons.addResizeListener does not currently support listening to resize event with capture');
          }
        }

        if (isGlobal) {
          // Store for adding/removal
          if (isKey) {
            this._globalKeys = this._globalKeys || [];

            this._globalKeys.push({
              keyCombo: eventName,
              selector: selector,
              listener: listener
            });
          } else {
            this._globalEvents = this._globalEvents || [];

            this._globalEvents.push({
              eventName: eventName,
              selector: selector,
              listener: listener,
              isCapture: isCapture
            });
          }
        } // Events on the element itself
        else if (isKey) {
            // Create the keys instance only if its needed
            this._keys = this._keys || new Keys(this, {
              // The filter function for keyboard events.
              filter: this._filterKeys,
              // Execute key listeners in the context of the element
              context: this
            }); // Add listener locally

            this._keys.on(eventName, selector, listener);
          } else if (isResize) {
            if (selector) {
              elements = document.querySelectorAll(selector);

              for (var i = 0; i < elements.length; ++i) {
                commons.addResizeListener(elements[i], listener);
              }
            } else {
              commons.addResizeListener(this, listener);
            }
          } else {
            this._vent.on(eventName, selector, listener, isCapture);
          }
      }
    }
  };
  /**
   Attach global event listeners for this component.
   @ignore
   */


  var delegateGlobalEvents = function delegateGlobalEvents() {
    var i;

    if (this._globalEvents) {
      // Remove global event listeners
      for (i = 0; i < this._globalEvents.length; i++) {
        var event = this._globalEvents[i];
        events.on(event.eventName, event.selector, event.listener, event.isCapture);
      }
    }

    if (this._globalKeys) {
      // Remove global key listeners
      for (i = 0; i < this._globalKeys.length; i++) {
        var key = this._globalKeys[i];
        keys$1.on(key.keyCombo, key.selector, key.listener);
      }
    }

    if (this._keys) {
      this._keys.init(true);
    }
  };
  /**
   Remove global event listeners for this component.
   @ignore
   */


  var undelegateGlobalEvents = function undelegateGlobalEvents() {
    var i;

    if (this._globalEvents) {
      // Remove global event listeners
      for (i = 0; i < this._globalEvents.length; i++) {
        var event = this._globalEvents[i];
        events.off(event.eventName, event.selector, event.listener, event.isCapture);
      }
    }

    if (this._globalKeys) {
      // Remove global key listeners
      for (i = 0; i < this._globalKeys.length; i++) {
        var key = this._globalKeys[i];
        keys$1.off(key.keyCombo, key.selector, key.listener);
      }
    }

    if (this._keys) {
      this._keys.destroy(true);
    }
  }; // Used to find upper case characters


  var REG_EXP_UPPERCASE = /[A-Z]/g;
  /**
   Returns the constructor namespace
   @ignore
   */

  var getConstructorName = function getConstructorName(constructor) {
    // Will contain the namespace of the constructor in reversed order
    var constructorName = []; // Keep a reference on the passed constructor

    var originalConstructor = constructor; // Traverses Coral constructors if not already done to set the namespace

    if (!constructor._namespace) {
      // Set namespace on Coral constructors until 'constructor' is found
      var find = function find(obj, constructorToFind) {
        var found = false;

        var type = _typeof(obj);

        if (obj && type === 'object' || type === 'function') {
          var subObj = Object.keys(obj);

          for (var i = 0; i < subObj.length; i++) {
            var key = subObj[i]; // Components are capitalized

            if (key[0].match(REG_EXP_UPPERCASE) !== null) {
              // Keep a reference of the constructor name and its parent
              obj[key]._namespace = {
                parent: obj,
                value: key
              };
              found = obj[key] === constructorToFind;

              if (found) {
                break;
              } else {
                found = find(obj[key], constructorToFind);
              }
            }
          }
        }

        return found;
      }; // Look for the constructor in the Coral namespace


      find(window.Coral, constructor);
    } // Climb up the constructor namespace


    while (constructor) {
      if (constructor._namespace) {
        constructorName.push(constructor._namespace.value);
        constructor = constructor._namespace.parent;
      } else {
        constructor = false;
      }
    } // Build the full namespace string and save it for reuse


    originalConstructor._componentName = constructorName.reverse().join('.');
    return originalConstructor._componentName;
  };
  /**
   @base BaseComponent
   @classdesc The base element for all Coral components
   */


  var BaseComponent = function BaseComponent(superClass) {
    return /*#__PURE__*/function (_superClass) {
      _inherits(_class, _superClass);

      var _super = _createSuper(_class);

      /** @ignore */
      function _class() {
        var _this;

        _classCallCheck(this, _class);

        _this = _super.call(this); // Attach Vent

        _this._vent = new vent(_assertThisInitialized(_this));
        _this._events = {}; // Content zone MO for virtual DOM support

        if (_this._contentZones) {
          _this._contentZoneObserver = new MutationObserver(function (mutations) {
            mutations.forEach(function (mutation) {
              for (var i = 0; i < mutation.addedNodes.length; i++) {
                var addedNode = mutation.addedNodes[i];

                for (var name in _this._contentZones) {
                  var contentZone = _this._contentZones[name];

                  if (addedNode.nodeName.toLowerCase() === name && !addedNode._contentZoned) {
                    // Insert the content zone at the right position

                    /** @ignore */
                    _this[contentZone] = addedNode;
                  }
                }
              }
            });
          });

          _this._contentZoneObserver.observe(_assertThisInitialized(_this), {
            childList: true,
            subtree: true
          });
        }

        return _this;
      }
      /**
       Tracking of events. This provides insight on the usage of the components. It accepts "ON" and "OFF". In order to
       successfully track the events, {Tracking} needs to be configured.
        @type {String}
       @default TrackingEnum.ON
       @htmlattribute tracking
       */


      _createClass(_class, [{
        key: "_filterKeys",
        // The filter function for keyboard events. By default, any child element can trigger keyboard events.
        // You can pass {@link Keys.filterInputs} to avoid listening to key events triggered from within
        // inputs.
        value: function _filterKeys() {
          return true;
        } // Attach event listeners including global ones

      }, {
        key: "_delegateEvents",
        value: function _delegateEvents(eventMap) {
          this._events = commons.extend(this._events, eventMap);
          delegateEvents.call(this);
          delegateGlobalEvents.call(this); // Once events are attached, we dispose them

          this._events = {};
        } // Returns the content zone if the component is connected and contains the content zone else null
        // Ideally content zones will be replaced by shadow dom and <slot> elements

      }, {
        key: "_getContentZone",
        value: function _getContentZone(contentZone) {
          if (document.documentElement.contains(this)) {
            return this.contains(contentZone) && contentZone || null;
          } // Return the content zone by default


          return contentZone;
        } // Sets the value as content zone for the property given the specified options
        // Ideally content zones will be replaced by shadow dom and <slot> elements

      }, {
        key: "_setContentZone",
        value: function _setContentZone(property, value, options) {
          var handle = options.handle;
          var expectedTagName = options.tagName;
          var additionalSetter = options.set;
          var insert = options.insert;
          var oldNode;

          if (value) {
            if (!(value instanceof HTMLElement)) {
              throw new Error("DOMException: Failed to set the \"".concat(property, "\" property on \"").concat(this.toString(), "\":\n        The provided value is not of type \"HTMLElement\"."));
            }

            if (expectedTagName && value.tagName.toLowerCase() !== expectedTagName) {
              throw new Error("DOMException: Failed to set the \"".concat(property, "\" property on \"").concat(this.toString(), "\": The new\n        ").concat(property, " element is of type \"").concat(value.tagName, "\". It must be a \"").concat(expectedTagName.toUpperCase(), "\" element."));
            }

            oldNode = this._elements[handle]; // Flag it for the content zone MO

            value._contentZoned = true; // Replace the existing element

            if (insert) {
              // Remove old node
              if (oldNode && oldNode.parentNode) {
                oldNode.parentNode.removeChild(oldNode);
              } // Insert new node


              insert.call(this, value);
            } else if (oldNode && oldNode.parentNode) {
              commons._log('warn', "".concat(this._componentName, " does not define an insert method for content zone ").concat(handle, ", falling back to replace.")); // Old way -- assume we have an old node


              this._elements[handle].parentNode.replaceChild(value, this._elements[handle]);
            } else {
              commons._log('error', "".concat(this._componentName, " does not define an insert method for content zone ").concat(handle, ", falling back to append.")); // Just append, which may introduce bugs, but at least doesn't crazy


              this.appendChild(value);
            }
          } else {
            // we need to remove the content zone if it exists
            oldNode = this._elements[handle];

            if (oldNode && oldNode.parentNode) {
              oldNode.parentNode.removeChild(oldNode);
            }
          } // Re-assign the handle to the new element


          this._elements[handle] = value; // Invoke the setter

          if (typeof additionalSetter === 'function') {
            additionalSetter.call(this, value);
          }
        } // Handles the reflection of properties by using a flag to prevent setting the property by changing the attribute

      }, {
        key: "_reflectAttribute",
        value: function _reflectAttribute(attributeName, value) {
          if (typeof value === 'boolean') {
            if (value && !this.hasAttribute(attributeName)) {
              this._reflectedAttribute = true;
              this.setAttribute(attributeName, '');
              this._reflectedAttribute = false;
            } else if (!value && this.hasAttribute(attributeName)) {
              this._reflectedAttribute = true;
              this.removeAttribute(attributeName);
              this._reflectedAttribute = false;
            }
          } else if (this.getAttribute(attributeName) !== String(value)) {
            this._reflectedAttribute = true;
            this.setAttribute(attributeName, value);
            this._reflectedAttribute = false;
          }
        }
        /**
         Notifies external listeners about an internal interaction. This method is used internally in every
         component's method that we want to track.
          @param {String} eventType The event type. Eg. click, select, etc.
         @param {String} targetType The element type being used. Eg. cyclebutton, cyclebuttonitem, etc.
         @param {CustomEvent} event
         @param {BaseComponent} childComponent - Optional, in case the event occurred on a child component.
          @returns {BaseComponent}
         */

      }, {
        key: "_trackEvent",
        value: function _trackEvent(eventType, targetType, event, childComponent) {
          if (this.tracking === this.constructor.tracking.ON) {
            tracking.track(eventType, targetType, event, this, childComponent);
          }

          return this;
        }
        /**
         Returns the component name.
          @return {String}
         */

      }, {
        key: "toString",
        value: function toString() {
          return "Coral.".concat(this._componentName);
        }
        /**
         Add an event listener.
          @param {String} eventName
         The event name to listen for.
         @param {String} [selector]
         The selector to use for event delegation.
         @param {Function} func
         The function that will be called when the event is triggered.
         @param {Boolean} [useCapture=false]
         Whether or not to listen during the capturing or bubbling phase.
         @returns {BaseComponent} this, chainable.
         */

      }, {
        key: "on",
        value: function on(eventName, selector, func, useCapture) {
          this._vent.on(eventName, selector, func, useCapture);

          return this;
        }
        /**
         Remove an event listener.
          @param {String} eventName
         The event name to stop listening for.
         @param {String} [selector]
         The selector that was used for event delegation.
         @param {Function} func
         The function that was passed to <code>on()</code>.
         @param {Boolean} [useCapture]
         Only remove listeners with <code>useCapture</code> set to the value passed in.
         @returns {BaseComponent} this, chainable.
         */

      }, {
        key: "off",
        value: function off(eventName, selector, func, useCapture) {
          this._vent.off(eventName, selector, func, useCapture);

          return this;
        }
        /**
         Trigger an event.
          @param {String} eventName
         The event name to trigger.
         @param {Object} [props]
         Additional properties to make available to handlers as <code>event.detail</code>.
         @param {Boolean} [bubbles=true]
         Set to <code>false</code> to prevent the event from bubbling.
         @param {Boolean} [cancelable=true]
         Set to <code>false</code> to prevent the event from being cancelable.
         @returns {CustomEvent} CustomEvent object
         */

      }, {
        key: "trigger",
        value: function trigger(eventName, props, bubbles, cancelable) {
          // When 'bubbles' is not set, then default to true:
          bubbles = bubbles || bubbles === undefined; // When 'cancelable' is not set, then default to true:

          cancelable = cancelable || cancelable === undefined;
          var event = new CustomEvent(eventName, {
            bubbles: bubbles,
            cancelable: cancelable,
            detail: props
          }); // Don't trigger the event if silenced

          if (this._silenced) {
            return event;
          } // default value in case the dispatching fails


          var defaultPrevented = false;

          try {
            // leads to NS_ERROR_UNEXPECTED in Firefox
            // https://bugzilla.mozilla.org/show_bug.cgi?id=329509
            defaultPrevented = !this.dispatchEvent(event);
          } // eslint-disable-next-line no-empty
          catch (e) {} // Check if the defaultPrevented status was correctly stored back to the event object


          if (defaultPrevented !== event.defaultPrevented) {
            // dispatchEvent() doesn't correctly set event.defaultPrevented in IE 9
            // However, it does return false if preventDefault() was called
            // Unfortunately, the returned event's defaultPrevented property is read-only
            // We need to work around this such that (patchedEvent instanceof Event) === true
            // First, we'll create an object that uses the event as its prototype
            // This gives us an object we can modify that is still technically an instanceof Event
            var patchedEvent = Object.create(event); // Next, we set the correct value for defaultPrevented on the new object
            // We cannot simply assign defaultPrevented, it causes a "Invalid Calling Object" error in IE 9
            // For some reason, defineProperty doesn't cause this

            Object.defineProperty(patchedEvent, 'defaultPrevented', {
              value: defaultPrevented
            });
            return patchedEvent;
          }

          return event;
        }
        /**
         Set multiple properties.
          @param {Object.<String, *>} properties
         An object of property/value pairs to set.
         @param {Boolean} silent
         If true, events should not be triggered as a result of this set.
          @returns {BaseComponent} this, chainable.
         */

      }, {
        key: "set",
        value: function set(propertyOrProperties, valueOrSilent, silent) {
          var _this2 = this;

          var property;
          var properties;
          var value;

          var isContentZone = function isContentZone(prop) {
            return _this2._contentZones && commons.swapKeysAndValues(_this2._contentZones)[prop];
          };

          var updateContentZone = function updateContentZone(prop, val) {
            // If content zone exists and we only want to update properties on the content zone
            if (_this2[prop] instanceof HTMLElement && !(val instanceof HTMLElement)) {
              for (var contentZoneProperty in val) {
                /** @ignore */
                _this2[prop][contentZoneProperty] = val[contentZoneProperty];
              }
            } // Else assign the new value to the content zone
            else {
                /** @ignore */
                _this2[prop] = val;
              }
          };

          var setProperty = function setProperty(prop, val) {
            if (isContentZone(prop)) {
              updateContentZone(prop, val);
            } else {
              _this2._silenced = silent;
              /** @ignore */

              _this2[prop] = val;
              _this2._silenced = false;
            }
          };

          if (typeof propertyOrProperties === 'string') {
            // Set a single property
            property = propertyOrProperties;
            value = valueOrSilent;
            setProperty(property, value);
          } else {
            properties = propertyOrProperties;
            silent = valueOrSilent; // Set a map of properties

            for (property in properties) {
              value = properties[property];
              setProperty(property, value);
            }
          }

          return this;
        }
        /**
         Get the value of a property.
          @param {String} property
         The name of the property to fetch the value of.
         @returns {*} Property value.
         */

      }, {
        key: "get",
        value: function get(property) {
          return this[property];
        }
        /**
         Show this component.
          @returns {BaseComponent} this, chainable
         */

      }, {
        key: "show",
        value: function show() {
          if (!this.hidden) {
            return this;
          }
          /** @ignore */


          this.hidden = false;
          return this;
        }
        /**
         Hide this component.
         @returns {BaseComponent} this, chainable
         */

      }, {
        key: "hide",
        value: function hide() {
          if (this.hidden) {
            return this;
          }
          /** @ignore */


          this.hidden = true;
          return this;
        }
        /**
         * checks whether connectedCallback needs to be executed or not ,skip if component is not in connected state
         * or connectedCallback already executed for the component or we are ignore the connectedCallback for some reason
         *
         * @returns {Boolean} return true for skipped cases
         */

      }, {
        key: "_skipConnectedCallback",
        value: function _skipConnectedCallback() {
          return !this.isConnected || this._disconnected === false || this._ignoreConnectedCallback === true;
        }
        /**
         Returns {@link BaseComponent} tracking options.
          @return {TrackingEnum}
         */

      }, {
        key: "attributeChangedCallback",

        /** @ignore */
        // eslint-disable-next-line no-unused-vars
        value: function attributeChangedCallback(name, oldValue, value) {
          var self = this;

          if (!self._reflectedAttribute) {
            // Use the attribute/property mapping
            self[self.constructor._attributePropertyMap[name] || name] = value;
          }
        }
        /** @ignore */

      }, {
        key: "connectedCallback",
        value: function connectedCallback() {
          // A component that is reattached should respond to global events again
          if (this._disconnected) {
            delegateGlobalEvents.call(this);
          }

          this._disconnected = false;

          if (!this._rendered) {
            this.render();
          }
        }
        /** @ignore */

      }, {
        key: "render",
        value: function render() {
          this._rendered = true;
        }
        /** @ignore */

      }, {
        key: "disconnectedCallback",
        value: function disconnectedCallback() {
          // A component that isn't in the DOM should not be responding to global events
          this._disconnected = true;
          undelegateGlobalEvents.call(this);
        }
      }, {
        key: "tracking",
        get: function get() {
          return this._tracking || this.getAttribute('tracking') || tracking$1.ON;
        },
        set: function set(value) {
          value = transform.string(value).toLowerCase();
          this._tracking = validate.enumeration(tracking$1)(value) && value || tracking$1.ON;
        }
        /**
         The string representing the feature being tracked. This provides additional context to the analytics trackers
         about the feature that the element enables.
          @type {String}
         @default ""
         @htmlattribute trackingfeature
         */

      }, {
        key: "trackingFeature",
        get: function get() {
          return this._trackingFeature || this.getAttribute('trackingFeature') || '';
        },
        set: function set(value) {
          this._trackingFeature = transform.string(value);
        }
        /**
         The string representing the element name being tracked. This providex additional context to the trackers about the
         element that was interacted with.
          @type {String}
         @default ""
         @htmlattribute trackingelement
         */

      }, {
        key: "trackingElement",
        get: function get() {
          return this._trackingElement || this.getAttribute('trackingElement') || '';
        },
        set: function set(value) {
          this._trackingElement = transform.string(value);
        } // Constructs and returns the component name based on the constructor

      }, {
        key: "_componentName",
        get: function get() {
          return this.constructor._componentName || getConstructorName(this.constructor);
        }
      }], [{
        key: "tracking",
        get: function get() {
          return tracking$1;
        }
      }, {
        key: "_attributePropertyMap",
        get: function get() {
          return {
            trackingelement: 'trackingElement',
            trackingfeature: 'trackingFeature'
          };
        }
        /** @ignore */

      }, {
        key: "observedAttributes",
        get: function get() {
          return ['tracking', 'trackingelement', 'trackingfeature', 'trackingFeature'];
        }
      }]);

      return _class;
    }(superClass);
  };

  var LABELLABLE_ELEMENTS_SELECTOR = 'button,input:not([type=hidden]),keygen,meter,output,progress,select,textarea'; // @polyfill ie11
  // IE11 throws syntax error because of the "not()" in the selector for some reason in ColorInputColorProperties

  if (navigator.userAgent.indexOf('MSIE') !== -1 || navigator.appVersion.indexOf('Trident/') > 0) {
    LABELLABLE_ELEMENTS_SELECTOR = 'button,keygen,meter,output,progress,select,textarea,'; // Since we can't use :not() we have to indicate all input types

    ['text', 'password', 'submit', 'reset', 'radio', 'checkbox', 'button', 'color', 'date', 'datetime-local', 'email', 'month', 'number', 'range', 'search', 'tel', 'time', 'url', 'week'].forEach(function (type) {
      LABELLABLE_ELEMENTS_SELECTOR += "input[type=".concat(type, "],");
    }); // Remove last ","

    LABELLABLE_ELEMENTS_SELECTOR = LABELLABLE_ELEMENTS_SELECTOR.slice(0, -1);
  } // _onInputChange is only triggered on non-hidden inputs


  var TARGET_INPUT_SELECTOR = 'input:not([type=hidden])';
  /**
   @base BaseFormField
   @classdesc The base element for Form Field components. If not extending a {@link HTMLInputElement}, following
   properties should be implemented at least :
   - <code>disabled</code>. Whether this field is disabled or not.
   - <code>invalid</code>. Whether the current value of this field is invalid or not.
   - <code>name</code>. Name used to submit the data in a form.
   - <code>readOnly</code>. Whether this field is readOnly or not. Indicating that the user cannot modify the value of the control.
   - <code>required</code>. Whether this field is required or not.
   - <code>value</code>. This field's current value.
   */

  var BaseFormField = function BaseFormField(superClass) {
    return /*#__PURE__*/function (_superClass) {
      _inherits(_class, _superClass);

      var _super = _createSuper(_class);

      /** @ignore */
      function _class() {
        var _this;

        _classCallCheck(this, _class);

        _this = _super.call(this);
        _this._events = {
          'capture:change input': '_onTargetInputChange',
          'global:reset': '_onFormReset'
        };
        return _this;
      }
      /**
       Whether this field is disabled or not.
        @type {Boolean}
       @default false
       @htmlattribute disabled
       @htmlattributereflected
       @abstract
       */

      /**
       Whether the current value of this field is invalid or not.
        @type {Boolean}
       @default false
       @htmlattribute invalid
       @htmlattributereflected
       @abstract
       */

      /**
       Name used to submit the data in a form.
        @type {String}
       @default ""
       @htmlattribute name
       @htmlattributereflected
       @abstract
       */

      /**
       Whether this field is readOnly or not. Indicating that the user cannot modify the value of the control.
       This is ignored for checkbox, radio or fileupload.
        @type {Boolean}
       @default false
       @htmlattribute readonly
       @htmlattributereflected
       @abstract
       */

      /**
       Whether this field is required or not.
        @type {Boolean}
       @default false
       @htmlattribute required
       @htmlattributereflected
       @abstract
       */

      /**
       This field's current value.
        @type {String}
       @default ""
       @htmlattribute value
       @abstract
       */

      /**
       Whether the current value of this field is invalid or not.
        @type {Boolean}
       @default false
       @htmlattribute invalid
       @htmlattributereflected
       */


      _createClass(_class, [{
        key: "_getLabellableElement",

        /**
         Gets the element that should get the label. In case none of the valid labelelable items are found, the component
         will be labelled instead.
         @protected
         @returns {HTMLElement} the labellable element.
         */
        value: function _getLabellableElement() {
          // Use predefined element or query it
          var element = this._labellableElement || this.querySelector(LABELLABLE_ELEMENTS_SELECTOR); // Use the found element or the container

          return element || this;
        }
        /**
         Gets the internal input that the BaseFormField would watch for change. By default, it searches if the
         <code>_getLabellableElement()</code> is an input. Components can override this function to be able to provide a
         different implementation. In case the value is <code>null</code>, the change event will be handled no matter
         the input that produced it.
         @protected
         @return {HTMLElement} the input to watch for changes.
         */

      }, {
        key: "_getTargetChangeInput",
        value: function _getTargetChangeInput() {
          // we use this._targetChangeInput as an internal cache to avoid querying the DOM again every time
          return this._targetChangeInput || ( // assignment returns the value
          this._targetChangeInput = this._getLabellableElement().matches(TARGET_INPUT_SELECTOR) ? this._getLabellableElement() : null);
        }
        /**
         Function called whenever the target component triggers a change event. <code>_getTargetChangeInput</code> is used
         internally to determine if the input belongs to the component. If the component decides to override this function,
         the default from the base will not be called.
         @protected
         */

      }, {
        key: "_onInputChange",
        value: function _onInputChange(event) {
          // stops the current event
          event.stopPropagation();
          /** @ignore */

          this[this._componentTargetProperty] = event.target[this._eventTargetProperty]; // Explicitly re-emit the change event after the property has been set

          if (this._triggerChangeEvent) {
            this.trigger('change');
          }
        }
        /**
         Resets the formField when a reset is triggered on the parent form.
         @protected
         */

      }, {
        key: "_onFormReset",
        value: function _onFormReset(event) {
          if (event.target.contains(this)) {
            this.reset();
          }
        }
        /**
         We capture every input change and validate that it belongs to our target input. If this is the case,
         <code>_onInputChange</code> will be called with the same event.
         @protected
         */

      }, {
        key: "_onTargetInputChange",
        value: function _onTargetInputChange(event) {
          var targetInput = this._getTargetChangeInput(); // if the targetInput is null we still call _onInputChange to be backwards compatible


          if (targetInput === event.target || targetInput === null) {
            // we call _onInputChange since the target matches
            this._onInputChange(event);
          }
        }
        /**
         A utility method for adding the appropriate <code>for</code> attribute to any <code>label</code> elements
         referenced by the <code>labelledBy</code> property value.
         @param {String} labelledBy
         The value of the <code>labelledBy<code> property providing a space-delimited list of the <code>id</code>
         attributes for elements that label the formField.
         @param {String} elementId
         The <code>id</code> of the formField or one of its descendants that should be labelled by
         <code>label</code> elements referenced by the <code>labelledBy</code> property value.
         @param {Boolean} remove
         Whether the existing <code>for</code> attributes should be removed.
         @protected
         */

      }, {
        key: "_updateForAttributes",
        value: function _updateForAttributes(labelledBy, elementId, remove) {
          // labelledby contains whitespace sparated items, so we need to separate each individual id
          var labelIds = labelledBy.split(/\s+/); // we update the 'for' attribute for every id.

          labelIds.forEach(function (currentValue) {
            var labelElement = document.getElementById(currentValue);

            if (labelElement && labelElement.tagName === 'LABEL') {
              var forAttribute = labelElement.getAttribute('for');

              if (remove) {
                // we just remove it when it is our target
                if (forAttribute === elementId) {
                  labelElement.removeAttribute('for');
                }
              } else {
                // if we do not have to remove, it does not matter the current value of the label, we can set it in every
                // case
                labelElement.setAttribute('for', elementId);
              }
            }
          });
        }
        /**
         Clears the <code>value</code> of formField to the default value.
         */

      }, {
        key: "clear",
        value: function clear() {
          /** @ignore */
          this.value = '';
        }
        /**
         Resets the <code>value</code> to the initial value.
         */

      }, {
        key: "reset",
        value: function reset() {
          // since the 'value' property is not reflected, form components use it to restore the initial value. When a
          // component has support for values, this method needs to be overwritten

          /** @ignore */
          this.value = transform.string(this.getAttribute('value'));
        }
      }, {
        key: "invalid",
        get: function get() {
          return this._invalid || false;
        },
        set: function set(value) {
          this._invalid = transform.booleanAttr(value);

          this._reflectAttribute('invalid', this._invalid);

          this.setAttribute('aria-invalid', this._invalid);
          this.classList.toggle('is-invalid', this._invalid);
        }
        /**
         Reflects the <code>aria-describedby</code> attribute to the labellable element e.g. inner input.
          @type {String}
         @default null
         @htmlattribute describedby
         */

      }, {
        key: "describedBy",
        get: function get() {
          return this._getLabellableElement().getAttribute('aria-describedby');
        },
        set: function set(value) {
          value = transform.string(value);

          this._getLabellableElement()[value ? 'setAttribute' : 'removeAttribute']('aria-describedby', value);
        }
        /**
         Reflects the <code>aria-label</code> attribute to the labellable element e.g. inner input.
          @type {String}
         @default null
         @htmlattribute labelled
         */

      }, {
        key: "labelled",
        get: function get() {
          return this._getLabellableElement().getAttribute('aria-label');
        },
        set: function set(value) {
          value = transform.string(value);

          this._getLabellableElement()[value ? 'setAttribute' : 'removeAttribute']('aria-label', value);
        }
        /**
         Reference to a space delimited set of ids for the HTML elements that provide a label for the formField.
         Implementers should override this method to ensure that the appropriate descendant elements are labelled using the
         <code>aria-labelledby</code> attribute. This will ensure that the component is properly identified for
         accessibility purposes. It reflects the <code>aria-labelledby</code> attribute to the DOM.
         @type {?String}
         @default null
         @htmlattribute labelledby
         */

      }, {
        key: "labelledBy",
        get: function get() {
          return this._getLabellableElement().getAttribute('aria-labelledby');
        },
        set: function set(value) {
          value = transform.string(value); // gets the element that will get the label assigned. the _getLabellableElement method should be overriden to
          // allow other bevaviors.

          var element = this._getLabellableElement(); // we get and assign the it that will be passed around


          var elementId = element.id = element.id || commons.getUID();
          var currentLabelledBy = element.getAttribute('aria-labelledby'); // we clear the old label assignments

          if (currentLabelledBy && currentLabelledBy !== value) {
            this._updateForAttributes(currentLabelledBy, elementId, true);
          }

          if (value) {
            element.setAttribute('aria-labelledby', value);

            if (element.matches(LABELLABLE_ELEMENTS_SELECTOR)) {
              this._updateForAttributes(value, elementId);
            }
          } else {
            // since no labelledby value was set, we remove everything
            element.removeAttribute('aria-labelledby');
          }
        }
        /**
         Target property inside the component that will be updated when a change event is triggered.
         @type {String}
         @default "value"
         @protected
         */

      }, {
        key: "_componentTargetProperty",
        get: function get() {
          return 'value';
        }
        /**
         Target property that will be taken from <code>event.target</code> and set into
         {@link BaseFormField#_componentTargetProperty} when a change event is triggered.
         @type {String}
         @default "value"
         @protected
         */

      }, {
        key: "_eventTargetProperty",
        get: function get() {
          return 'value';
        }
        /**
         Whether the change event needs to be triggered when {@link BaseFormField#_onInputChange} is called.
         @type {Boolean}
         @default true
         @protected
         */

      }, {
        key: "_triggerChangeEvent",
        get: function get() {
          return true;
        }
      }], [{
        key: "_attributePropertyMap",
        get: function get() {
          return commons.extend(_get(_getPrototypeOf(_class), "_attributePropertyMap", this), {
            describedby: 'describedBy',
            labelledby: 'labelledBy',
            readonly: 'readOnly'
          });
        } // We don't want to watch existing attributes for components that extend native HTML elements

      }, {
        key: "_nativeObservedAttributes",
        get: function get() {
          return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['describedby', 'labelled', 'labelledby', 'invalid']);
        }
        /** @ignore */

      }, {
        key: "observedAttributes",
        get: function get() {
          return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['describedby', 'labelled', 'labelledby', 'invalid', 'readonly', 'name', 'value', 'disabled', 'required']);
        }
      }]);

      return _class;
    }(superClass);
  };

  /**
   Enumeration for {@link Textfield} variants.

   @typedef {Object} TextfieldVariantEnum

   @property {String} DEFAULT
   A default textfield.
   @property {String} QUIET
   A textfield with no border or background.
   */

  var variant = {
    DEFAULT: 'default',
    QUIET: 'quiet'
  }; // the textfield's base classname

  var CLASSNAME = '_coral-Textfield'; // Builds a string containing all possible variant classnames. This will be used to remove classnames when the variant
  // changes

  var ALL_VARIANT_CLASSES = [];

  for (var variantValue in variant) {
    ALL_VARIANT_CLASSES.push("".concat(CLASSNAME, "--").concat(variant[variantValue]));
  }
  /**
   @class Coral.Textfield
   @classdesc A Textfield component is the default single line text form field.
   @htmltag coral-textfield
   @htmlbasetag input
   @extends {HTMLInputElement}
   @extends {BaseComponent}
   @extends {BaseFormField}
   */


  var Textfield = /*#__PURE__*/function (_BaseFormField) {
    _inherits(Textfield, _BaseFormField);

    var _super = _createSuper(Textfield);

    /** @ignore */
    function Textfield() {
      var _this;

      _classCallCheck(this, Textfield);

      _this = _super.call(this);

      _this._delegateEvents(_this._events);

      return _this;
    }
    /**
     The textfield's variant. See {@link TextfieldVariantEnum}.
      @type {String}
     @default TextfieldVariantEnum.DEFAULT
     @htmlattribute variant
     @htmlattributereflected
     */


    _createClass(Textfield, [{
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(Textfield.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME); // Default reflected attributes

        if (!this._variant) {
          this.variant = variant.DEFAULT;
        }
      }
    }, {
      key: "variant",
      get: function get() {
        return this._variant || variant.DEFAULT;
      },
      set: function set(value) {
        var _this$classList;

        value = transform.string(value).toLowerCase();
        this._variant = validate.enumeration(variant)(value) && value || variant.DEFAULT;

        this._reflectAttribute('variant', this._variant); // removes every existing variant


        (_this$classList = this.classList).remove.apply(_this$classList, ALL_VARIANT_CLASSES);

        if (this._variant !== variant.DEFAULT) {
          this.classList.add("".concat(CLASSNAME, "--").concat(this._variant));
        }
      }
      /**
       Returns {@link Textfield} variants.
        @return {TextfieldVariantEnum}
       */

    }], [{
      key: "variant",
      get: function get() {
        return variant;
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(Textfield), "_nativeObservedAttributes", this).concat(['variant']);
      }
    }]);

    return Textfield;
  }(BaseFormField(BaseComponent(HTMLInputElement)));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons._define('coral-textfield', Textfield, {
    extends: 'input'
  });

  /**
   * Copyright 2020 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @base BaseLabellable
   @classdesc Accessibility helper for components with label and icon properties
   */
  var BaseLabellable = function BaseLabellable(superClass) {
    return /*#__PURE__*/function (_superClass) {
      _inherits(_class, _superClass);

      var _super = _createSuper(_class);

      function _class() {
        _classCallCheck(this, _class);

        return _super.apply(this, arguments);
      }

      _createClass(_class, [{
        key: "_observeLabel",
        value: function _observeLabel() {
          this._observableLabel = this._observableLabel || this._elements.label || this._elements.content; // Listen for mutations

          this._observer = new MutationObserver(this._toggleIconAriaHidden.bind(this)); // Watch for changes to the content element

          this._observer.observe(this._observableLabel, {
            // Catch changes to childList
            childList: true,
            // Catch changes to textContent
            characterData: true,
            // Monitor any child node
            subtree: true
          });
        } // Hides the icon from screen readers to avoid duplicated labels

      }, {
        key: "_toggleIconAriaHidden",
        value: function _toggleIconAriaHidden() {
          this._renderedLabel = this._renderedLabel || this.label || this.content; // toggle aria-hidden if tab is labelled

          if (this._elements.icon) {
            var isLabelled = this._renderedLabel && this._renderedLabel.textContent.trim().length || this.getAttribute('aria-label') !== null || this.getAttribute('aria-labelledby') !== null;

            this._elements.icon[isLabelled ? 'setAttribute' : 'removeAttribute']('aria-hidden', 'true');
          }
        }
        /** @ignore */

      }, {
        key: "attributeChangedCallback",

        /** @ignore */
        value: function attributeChangedCallback(name, oldValue, value) {
          if (name === 'aria-label' || name === 'aria-labelledby') {
            this._toggleIconAriaHidden();
          } else {
            _get(_getPrototypeOf(_class.prototype), "attributeChangedCallback", this).call(this, name, oldValue, value);
          }
        }
      }], [{
        key: "observedAttributes",
        get: function get() {
          return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['aria-label', 'aria-labelledby']);
        }
      }]);

      return _class;
    }(superClass);
  };

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var ICON_MAP = {
    "aBC": {
      "deprecated": true,
      "spectrumIcon": "ABC"
    },
    "abc": {
      "spectrumIcon": "ABC"
    },
    "accordionDown": {
      "spectrumIcon": "ChevronDown"
    },
    "accordionLeft": {
      "spectrumIcon": "ChevronDoubleLeft"
    },
    "accordionRight": {
      "spectrumIcon": "ChevronDoubleRight"
    },
    "accordionUp": {
      "spectrumIcon": "ChevronUp"
    },
    "adjust": {
      "spectrumIcon": "Exposure"
    },
    "adobe": {
      "spectrumIcon": "AdobeLogo"
    },
    "adobeAdvertisingCloudColor": {
      "spectrumIconDark": "AdobeAdvertisingCloudColor_Dark",
      "spectrumIconLight": "AdobeAdvertisingCloudColor_Light"
    },
    "adobeAnalyticsColor": {
      "spectrumIconDark": "AdobeAnalyticsColor_Dark",
      "spectrumIconLight": "AdobeAnalyticsColor_Light"
    },
    "adobeAnalyticsColorLight": {
      "spectrumIcon": "AdobeAnalyticsColor_Light"
    },
    "adobeAnalyticsColorDark": {
      "spectrumIcon": "AdobeAnalyticsColor_Dark"
    },
    "adobeAudienceManagerColor": {
      "spectrumIconDark": "AdobeAudienceManagerColor_Dark",
      "spectrumIconLight": "AdobeAudienceManagerColor_Light"
    },
    "adobeAudienceManagerColorLight": {
      "spectrumIcon": "AdobeAudienceManagerColor_Light"
    },
    "adobeAudienceManagerColorDark": {
      "spectrumIcon": "AdobeAudienceManagerColor_Dark"
    },
    "adobeCampaignColor": {
      "spectrumIconDark": "AdobeCampaignColor_Dark",
      "spectrumIconLight": "AdobeCampaignColor_Light"
    },
    "adobeCampaignColorLight": {
      "spectrumIcon": "AdobeCampaignColor_Light"
    },
    "adobeCampaignColorDark": {
      "spectrumIcon": "AdobeCampaignColor_Dark"
    },
    "adobeExperienceCloudColor": {
      "spectrumIcon": "AdobeExperienceCloudColor"
    },
    "adobeExperienceManagerColor": {
      "spectrumIconDark": "AdobeExperienceManagerColor_Dark",
      "spectrumIconLight": "AdobeExperienceManagerColor_Light"
    },
    "adobeExperienceManagerColorLight": {
      "spectrumIcon": "AdobeExperienceManagerColor_Light"
    },
    "adobeExperienceManagerColorDark": {
      "spectrumIcon": "AdobeExperienceManagerColor_Dark"
    },
    "adobeExperiencePlatformColor": {
      "spectrumIcon": "AdobeExperiencePlatformColor"
    },
    "adobeMediaOptimizerColor": {
      "spectrumIconDark": "AdobeMediaOptimizerColor_Dark",
      "spectrumIconLight": "AdobeMediaOptimizerColor_Light"
    },
    "adobeMediaOptimizerColorLight": {
      "spectrumIcon": "AdobeMediaOptimizerColor_Light"
    },
    "adobeMediaOptimizerColorDark": {
      "spectrumIcon": "AdobeMediaOptimizerColor_Dark"
    },
    "adobePrimetimeColor": {
      "spectrumIconDark": "AdobePrimetimeColor_Dark",
      "spectrumIconLight": "AdobePrimetimeColor_Light"
    },
    "adobePrimetimeColorLight": {
      "spectrumIcon": "AdobePrimetimeColor_Light"
    },
    "adobePrimetimeColorDark": {
      "spectrumIcon": "AdobePrimetimeColor_Dark"
    },
    "adobeSocialColor": {
      "spectrumIconDark": "AdobeSocialColor_Dark",
      "spectrumIconLight": "AdobeSocialColor_Light"
    },
    "adobeSocialColorLight": {
      "spectrumIcon": "AdobeSocialColor_Light"
    },
    "adobeSocialColorDark": {
      "spectrumIcon": "AdobeSocialColor_Dark"
    },
    "adobeTargetColor": {
      "spectrumIconDark": "AdobeTargetColor_Dark",
      "spectrumIconLight": "AdobeTargetColor_Light"
    },
    "adobeTargetColorLight": {
      "spectrumIcon": "AdobeTargetColor_Light"
    },
    "adobeTargetColorDark": {
      "spectrumIcon": "AdobeTargetColor_Dark"
    },
    "annotate": {
      "spectrumIcon": "AnnotatePen"
    },
    "automate": {
      "spectrumIcon": "Gears"
    },
    "breadcrumb": {
      "spectrumIcon": "Menu"
    },
    "calendarCheckColor": {
      "spectrumIcon": "CalendarCheckColor_Light"
    },
    "campaignRemove": {
      "spectrumIcon": "CampaignClose"
    },
    "check": {
      "spectrumIcon": "Checkmark"
    },
    "checkCircle": {
      "spectrumIcon": "CheckmarkCircle"
    },
    "closedCaptions": {
      "spectrumIcon": "CloseCaptions"
    },
    "coverImage": {
      "spectrumIcon": "FacebookCoverImage"
    },
    "deviceMobile": {
      "spectrumIcon": "DevicePhone"
    },
    "deviceTv": {
      "deprecated": true,
      "spectrumIcon": "DeviceTV"
    },
    "downloaded": {
      "spectrumIcon": "Download"
    },
    "downloadFromCloud": {
      "deprecated": true,
      "spectrumIcon": "Download"
    },
    "dPS": {
      "deprecated": true,
      "spectrumIcon": "DPS"
    },
    "dps": {
      "spectrumIcon": "DPS"
    },
    "draw": {
      "spectrumIcon": "AnnotatePen"
    },
    "emailAlert": {
      "spectrumIcon": "Alert"
    },
    "emotionAdmirationColor": {
      "spectrumIcon": "EmotionAdmirationColor_Light"
    },
    "emotionAngerColor": {
      "spectrumIcon": "EmotionAngerColor_Light"
    },
    "emotionAnticipationColor": {
      "spectrumIcon": "EmotionAnticipationColor_Light"
    },
    "emotionDisgustColor": {
      "spectrumIcon": "EmotionDisgustColor_Light"
    },
    "emotionFearColor": {
      "spectrumIcon": "EmotionFearColor_Light"
    },
    "emotionJoyColor": {
      "spectrumIcon": "EmotionJoyColor_Light"
    },
    "emotionSadnessColor": {
      "spectrumIcon": "EmotionSadnessColor_Light"
    },
    "emotionSurpriseColor": {
      "spectrumIcon": "EmotionSurpriseColor_Light"
    },
    "exclude": {
      "spectrumIcon": "Cancel"
    },
    "eyedropper": {
      "spectrumIcon": "Sampler"
    },
    "facebookCircleColor": {
      "spectrumIcon": "FacebookCircleColor_Light"
    },
    "facebookColor": {
      "spectrumIcon": "FacebookColor_Light"
    },
    "file": {
      "spectrumIcon": "Document"
    },
    "fileGlobe2": {
      "spectrumIcon": "FileGlobe"
    },
    "film": {
      "spectrumIcon": "Filmroll"
    },
    "flickrColor": {
      "spectrumIcon": "FlickrColor_Light"
    },
    "folderDefault": {
      "spectrumIcon": "FolderAdobe"
    },
    "folderLockedDefault": {
      "spectrumIcon": "FolderLockedAdobe"
    },
    "gear": {
      "spectrumIcon": "Settings"
    },
    "googleAnalyticsColor": {
      "spectrumIcon": "GoogleAnalyticsColor_Light"
    },
    "googlePlusCircleColor": {
      "spectrumIcon": "GooglePlusCircleColor_Light"
    },
    "googlePlusColor": {
      "spectrumIcon": "GooglePlusColor_Light"
    },
    "graphBarStackedHorizontal": {
      "spectrumIcon": "GraphBarHorizontalStacked"
    },
    "graphBarStackedVertical": {
      "spectrumIcon": "GraphBarVertical"
    },
    "graphTrendRounded": {
      "spectrumIcon": "GraphTrend"
    },
    "helpCircle": {
      "spectrumIcon": "Help"
    },
    "hTML5": {
      "deprecated": true,
      "spectrumIcon": "HTML5"
    },
    "html5": {
      "spectrumIcon": "HTML5"
    },
    "imageCheckColor": {
      "spectrumIcon": "ImageCheckColor_Light"
    },
    "imageMap": {
      "spectrumIcon": "ImageMapRectangle"
    },
    "infoCircle": {
      "spectrumIcon": "Info"
    },
    "instagramCircleColor": {
      "spectrumIcon": "InstagramCircleColor_Light"
    },
    "instagramColor": {
      "spectrumIcon": "InstagramColor_Light"
    },
    "linkCheckColor": {
      "spectrumIcon": "LinkCheckColor_Light"
    },
    "linkedInCircleColor": {
      "spectrumIcon": "LinkedInCircleColor_Light"
    },
    "linkedInColor": {
      "spectrumIcon": "LinkedInColor_Light"
    },
    "lockOff": {
      "spectrumIcon": "LockOpen"
    },
    "lockOn": {
      "spectrumIcon": "LockClosed"
    },
    "magentoCommerceColor": {
      "spectrumIconDark": "MagentoCommerceColor_Dark",
      "spectrumIconLight": "MagentoCommerceColor_Light"
    },
    "minus": {
      "spectrumIcon": "Remove"
    },
    "minusCircle": {
      "spectrumIcon": "RemoveCircle"
    },
    "navigation": {
      "spectrumIcon": "Rail"
    },
    "newsgatorColor": {
      "spectrumIcon": "NewsgatorColor_Light"
    },
    "open": {
      "spectrumIcon": "FolderOpen"
    },
    "os": {
      "spectrumIcon": "OS"
    },
    "oS": {
      "deprecated": true,
      "spectrumIcon": "OS"
    },
    "page": {
      "spectrumIcon": "WebPage"
    },
    "pages": {
      "spectrumIcon": "WebPages"
    },
    "paintBucket": {
      "spectrumIcon": "ColorFill"
    },
    "pausePlay": {
      "spectrumIcon": "StepForward"
    },
    "pausePlayCircle": {
      "spectrumIcon": "StepForwardCircle"
    },
    "popOut": {
      "spectrumIcon": "ArrowUpRight"
    },
    "projectCameraColor": {
      "spectrumIcon": "ProjectCameraColor_Light"
    },
    "projectColor": {
      "spectrumIcon": "ProjectColor_Light"
    },
    "projectPlayColor": {
      "spectrumIcon": "ProjectPlayColor_Light"
    },
    "projectRefreshColor": {
      "spectrumIcon": "ProjectRefreshColor_Light"
    },
    "publish": {
      "spectrumIcon": "Send"
    },
    "reflectHorizontal": {
      "spectrumIcon": "FlipHorizontal"
    },
    "reflectVertical": {
      "spectrumIcon": "FlipVertical"
    },
    "rSS": {
      "deprecated": true,
      "spectrumIcon": "RSS"
    },
    "rss": {
      "spectrumIcon": "RSS"
    },
    "save": {
      "spectrumIcon": "SaveFloppy"
    },
    "saveAs": {
      "spectrumIcon": "SaveAsFloppy"
    },
    "select": {
      "spectrumIcon": "SelectBox"
    },
    "selectAll": {
      "spectrumIcon": "SelectBoxAll"
    },
    "sinaWeiboCircleColor": {
      "spectrumIcon": "SinaWeiboCircleColor_Light"
    },
    "sinaWeiboColor": {
      "spectrumIcon": "SinaWeiboColor_Light"
    },
    "sms": {
      "spectrumIcon": "SMS"
    },
    "sMS": {
      "deprecated": true,
      "spectrumIcon": "SMS"
    },
    "sMSLightning": {
      "deprecated": true,
      "spectrumIcon": "SMSLightning"
    },
    "smsLightning": {
      "spectrumIcon": "SMSLightning"
    },
    "sMSRefresh": {
      "deprecated": true,
      "spectrumIcon": "SMSRefresh"
    },
    "smsRefresh": {
      "spectrumIcon": "SMSRefresh"
    },
    "star": {
      "spectrumIcon": "Star"
    },
    "starFill": {
      "spectrumIcon": "Star"
    },
    "starStroke": {
      "spectrumIcon": "StarOutline"
    },
    "stop": {
      "spectrumIcon": "StopCircle"
    },
    "tableCellMergeColor": {
      "spectrumIconActive": "TableCellMergeColor_Active",
      "spectrumIconDark": "TableCellMergeColor_Dark",
      "spectrumIconLight": "TableCellMergeColor_Light"
    },
    "tableColumnAddLeftColor": {
      "spectrumIconActive": "TableColumnAddLeftColor_Active",
      "spectrumIconDark": "TableColumnAddLeftColor_Dark",
      "spectrumIconLight": "TableColumnAddLeftColor_Light"
    },
    "tableColumnAddRightColor": {
      "spectrumIconActive": "TableColumnAddRightColor_Active",
      "spectrumIconDark": "TableColumnAddRightColor_Dark",
      "spectrumIconLight": "TableColumnAddLeftColor_Light"
    },
    "tableColumnMergeColor": {
      "spectrumIconActive": "TableColumnMergeColor_Active",
      "spectrumIconDark": "TableColumnMergeColor_Dark",
      "spectrumIconLight": "TableColumnMergeColor_Light"
    },
    "tableColumnRemoveCenterColor": {
      "spectrumIconActive": "TableColumnRemoveCenterColor_Active",
      "spectrumIconDark": "TableColumnRemoveCenterColor_Dark",
      "spectrumIconLight": "TableColumnRemoveCenterColor_Light"
    },
    "tableColumnSplitColor": {
      "spectrumIconActive": "TableColumnSplitColor_Active",
      "spectrumIconDark": "TableColumnSplitColor_Dark",
      "spectrumIconLight": "TableColumnSplitColor_Light"
    },
    "tableRowAddBottomColor": {
      "spectrumIconActive": "TableRowAddBottomColor_Active",
      "spectrumIconDark": "TableRowAddBottomColor_Dark",
      "spectrumIconLight": "TableRowAddBottomColor_Light"
    },
    "tableRowAddTopColor": {
      "spectrumIconActive": "TableRowAddTopColor_Active",
      "spectrumIconDark": "TableRowAddTopColor_Dark",
      "spectrumIconLight": "TableRowAddTopColor_Light"
    },
    "tableRowMergeColor": {
      "spectrumIconActive": "TableRowMergeColor_Active",
      "spectrumIconDark": "TableRowMergeColor_Dark",
      "spectrumIconLight": "TableRowMergeColor_Light"
    },
    "tableRowRemoveCenterColor": {
      "spectrumIconActive": "TableRowRemoveCenterColor_Active",
      "spectrumIconDark": "TableRowRemoveCenterColor_Dark",
      "spectrumIconLight": "TableRowRemoveCenterColor_Light"
    },
    "tableRowSplitColor": {
      "spectrumIconActive": "TableRowSplitColor_Active",
      "spectrumIconDark": "TableRowSplitColor_Dark",
      "spectrumIconLight": "TableRowSplitColor_Light"
    },
    "tableSelectColumnColor": {
      "spectrumIconActive": "TableSelectColumnColor_Active",
      "spectrumIconDark": "TableSelectColumnColor_Dark",
      "spectrumIconLight": "TableSelectColumnColor_Light"
    },
    "tableSelectRowColor": {
      "spectrumIconActive": "TableSelectRowColor_Active",
      "spectrumIconDark": "TableSelectRowColor_Dark",
      "spectrumIconLight": "TableSelectRowColor_Light"
    },
    "tag": {
      "spectrumIcon": "Label"
    },
    "tagExclude": {
      "spectrumIcon": "LabelExclude"
    },
    "tags": {
      "spectrumIcon": "Labels"
    },
    "targetCheckColor": {
      "spectrumIcon": "TargetCheckColor_Light"
    },
    "textCenter": {
      "spectrumIcon": "TextAlignCenter"
    },
    "textJustified": {
      "spectrumIcon": "TextAlignJustify"
    },
    "textLeft": {
      "spectrumIcon": "TextAlignLeft"
    },
    "textLetteredLowercase": {
      "spectrumIcon": "TextLetteredLowerCase"
    },
    "textLetteredUppercase": {
      "spectrumIcon": "TextLetteredUpperCase"
    },
    "textRight": {
      "spectrumIcon": "TextAlignRight"
    },
    "triangleDown": {
      "spectrumIcon": "ChevronDown"
    },
    "triangleRight": {
      "spectrumIcon": "ChevronRight"
    },
    "twitterCircleColor": {
      "spectrumIcon": "TwitterCircleColor_Light"
    },
    "twitterColor": {
      "spectrumIcon": "TwitterColor_Light"
    },
    "unflag": {
      "spectrumIcon": "FlagExclude"
    },
    "unpublish": {
      "spectrumIcon": "GlobeRemove"
    },
    "upload": {
      "spectrumIcon": "UploadToCloud"
    },
    "usa": {
      "spectrumIcon": "USA"
    },
    "uSA": {
      "deprecated": true,
      "spectrumIcon": "USA"
    },
    "userCircleColor": {
      "spectrumIconDark": "UserCircleColor_Dark",
      "spectrumIconLight": "UserCircleColor_Light"
    },
    "userGroupCircleColor": {
      "spectrumIconDark": "UserGroupCircleColor_Dark",
      "spectrumIconLight": "UserGroupCircleColor_Light"
    },
    "users": {
      "spectrumIcon": "UserGroup"
    },
    "viewOff": {
      "spectrumIcon": "VisibilityOff"
    },
    "viewOn": {
      "spectrumIcon": "Visibility"
    },
    "vk": {
      "spectrumIcon": "VK"
    },
    "vK": {
      "deprecated": true,
      "spectrumIcon": "VK"
    },
    "wand": {
      "spectrumIcon": "MagicWand"
    },
    "windowsColor": {
      "spectrumIcon": "WindowsColor_Light"
    },
    "wordpressColor": {
      "spectrumIcon": "WordpressColor_Light"
    },
    "write": {
      "spectrumIcon": "AnnotatePen"
    },
    "youTubeCircleColor": {
      "spectrumIcon": "YouTubeCircleColor_Light"
    },
    "youTubeColor": {
      "spectrumIcon": "YouTubeColor_Light"
    }
  };

  var SPECTRUM_ICONS_PATH = 'dist/resources/spectrum-icons.svg';

  var SPECTRUM_ICONS_COLOR_PATH = 'dist/resources/spectrum-icons-color.svg';

  var SPECTRUM_CSS_ICONS_PATH = 'dist/resources/spectrum-css-icons.svg';

  /**
   * Copyright 2020 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var SPECTRUM_ICONS = 'spectrum-icons';
  var SPECTRUM_ICONS_COLOR = 'spectrum-icons-color';
  var SPECTRUM_CSS_ICONS = 'spectrum-css-icons';

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  function handleError(string) {
    string = "Coral.Icon#load: ".concat(string);
    var error = new Error(string);
    console.error(error.toString());
  }

  function injectSVG(svgURL) {
    // 200 for web servers, 0 for CEP panels
    if (this.status !== 200 && this.status !== 0) {
      handleError("failed to fetch icons, server returned ".concat(this.status));
      return;
    } // Parse the SVG


    var parser = new DOMParser();

    try {
      var doc = parser.parseFromString(this.responseText, 'image/svg+xml');
      var svg = doc.firstChild; // Make sure a real SVG was returned

      if (svg && svg.tagName === 'svg') {
        if (svgURL.indexOf(SPECTRUM_ICONS_COLOR) !== -1) {
          // Insert it into the body
          if (document.body) {
            document.body.appendChild(svg);
          } else {
            document.addEventListener('DOMContentLoaded', function () {
              document.body.appendChild(svg);
            });
          }
        } else {
          document.head.appendChild(svg);
        }
      } else {
        handleError('parsed SVG document contained something other than an SVG');
      }
    } catch (err) {
      handleError("error parsing SVG: ".concat(err));
    }
  }

  function loadIcons(svgURL) {
    if (svgURL.slice(-3) === '.js') {
      // Injects the SVG icons in the document
      var script = document.createElement('script');
      script.async = true;
      script.type = 'text/javascript';
      script.src = svgURL;
      document.head.appendChild(script);
    } else {
      // Request the SVG icons
      var req = new XMLHttpRequest();
      req.open('GET', svgURL, true);
      req.addEventListener('load', injectSVG.bind(req, svgURL));
      req.addEventListener('error', function () {
        handleError('Request failed');
      });
      req.send();
    }
  }

  var SPECTRUM_ICONS_IDENTIFIER = 'spectrum-';
  var SPECTRUM_COLORED_ICONS_IDENTIFIER = ['ColorLight', 'Color_Light', 'ColorDark', 'Color_Dark', 'ColorActive', 'Color_Active', // Unique colored icons
  'AdobeExperienceCloudColor', 'AdobeExperiencePlatformColor'];
  var resourcesPath = (commons.options.icons || '').trim();

  if (resourcesPath.length && resourcesPath[resourcesPath.length - 1] !== '/') {
    resourcesPath += '/';
  } // @IE11


  var IS_IE11 = !window.ActiveXObject && 'ActiveXObject' in window;
  var iconsExternal = commons.options.iconsExternal || 'on';

  if (IS_IE11) {
    iconsExternal = 'off';
  }

  var resolveIconsPath = function resolveIconsPath(iconsPath) {
    var path = commons._script.src;
    return "".concat(path.split('/').slice(0, -iconsPath.split('/').length).join('/'), "/").concat(iconsPath);
  };
  /**
   Regex used to match URLs. Assume it's a URL if it has a slash, colon, or dot.

   @ignore
   */


  var URL_REGEX = /\/|:|\./g;
  /**
   Regex used to match unresolved templates e.g. for data-binding

   @ignore
   */

  var TEMPLATE_REGEX = /.*\{\{.+\}\}.*/g;
  /**
   Regex used to split camel case icon names into more screen-reader friendly alt text.

   @ignore
   */

  var SPLIT_CAMELCASE_REGEX = /([a-z])([A-Z0-9])/g;
  /**
   Regex used to match the sized spectrum icon prefix

   @ignore
   */

  var SPECTRUM_ICONS_IDENTIFIER_REGEX = /^spectrum(?:-css)?-icon(?:-\d{1,3})?-/gi;
  /**
   Regex used match the variant postfix for an icon

   @ignore
   */

  var ICONS_VARIANT_POSTFIX_REGEX = /(Outline)?(Filled)?(Small|Medium|Large)?(Color)?_?(Active|Dark|Light)?$/;
  /**
   Translation hint used for localizing default alt text for an icon

   @ignore
   */

  var ICON_ALT_TRANSLATION_HINT = 'default icon alt text';
  /**
   Returns capitalized string. This is used to map the icons with their SVG counterpart.

   @ignore
   @param {String} s
   @return {String}
   */

  var capitalize = function capitalize(s) {
    return s.charAt(0).toUpperCase() + s.slice(1);
  };
  /**
   Enumeration for {@link Icon} sizes.

   @typedef {Object} IconSizeEnum

   @property {String} EXTRA_EXTRA_SMALL
   Extra extra small size icon, typically 9px size.
   @property {String} EXTRA_SMALL
   Extra small size icon, typically 12px size.
   @property {String} SMALL
   Small size icon, typically 18px size. This is the default size.
   @property {String} MEDIUM
   Medium size icon, typically 24px size.
   @property {String} LARGE
   Large icon, typically 36px size.
   @property {String} EXTRA_LARGE
   Extra large icon, typically 48px size.
   @property {String} EXTRA_EXTRA_LARGE
   Extra extra large icon, typically 72px size.
   */


  var size = {
    EXTRA_EXTRA_SMALL: 'XXS',
    EXTRA_SMALL: 'XS',
    SMALL: 'S',
    MEDIUM: 'M',
    LARGE: 'L',
    EXTRA_LARGE: 'XL',
    EXTRA_EXTRA_LARGE: 'XXL'
  };
  /**
   Enumeration for {@link Icon} autoAriaLabel value.

   @typedef {Object} IconAutoAriaLabelEnum

   @property {String} ON
   The aria-label attribute is automatically set based on the icon name.
   @property {String} OFF
   The aria-label attribute is not set and has to be provided explicitly.
   */

  var autoAriaLabel = {
    ON: 'on',
    OFF: 'off'
  }; // icon's base classname

  var CLASSNAME$1 = '_coral-Icon'; // builds an array containing all possible size classnames. this will be used to remove classnames when the size
  // changes

  var ALL_SIZE_CLASSES = [];

  for (var sizeValue in size) {
    ALL_SIZE_CLASSES.push("".concat(CLASSNAME$1, "--size").concat(size[sizeValue]));
  } // Based on https://github.com/adobe/spectrum-css/tree/master/icons


  var sizeMap = {
    XXS: 18,
    XS: 24,
    S: 18,
    M: 24,
    L: 18,
    XL: 24,
    XXL: 24
  };
  /**
   @class Coral.Icon
   @classdesc An Icon component. Icon ships with a set of SVG icons.
   @htmltag coral-icon
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var Icon = /*#__PURE__*/function (_BaseComponent) {
    _inherits(Icon, _BaseComponent);

    var _super = _createSuper(Icon);

    /** @ignore */
    function Icon() {
      var _this;

      _classCallCheck(this, Icon);

      _this = _super.call(this);
      _this._elements = {};
      return _this;
    }
    /**
     Whether aria-label is set automatically. See {@link IconAutoAriaLabelEnum}.
      @type {String}
     @default IconAutoAriaLabelEnum.OFF
     */


    _createClass(Icon, [{
      key: "_updateIcon",
      value: function _updateIcon() {
        var iconId = this.icon; // If icon name is passed, we have to build the icon Id based on the icon name

        if (iconId.indexOf(SPECTRUM_ICONS_IDENTIFIER) !== 0) {
          var iconMapped = ICON_MAP[iconId];
          var iconName; // Restore default state

          this.removeAttribute('_context');

          if (iconMapped) {
            if (iconMapped.spectrumIcon) {
              // Use the default mapped icon
              iconName = iconMapped.spectrumIcon;
            } else {
              // Verify if icon should be light or dark by looking up parents theme
              var closest = this.closest('.coral--light, .coral--dark, .coral--lightest, .coral--darkest');

              if (closest) {
                if (closest.classList.contains('coral--light') || closest.classList.contains('coral--lightest')) {
                  // Use light icon
                  iconName = iconMapped.spectrumIconLight;
                } else {
                  // Use dark icon
                  iconName = iconMapped.spectrumIconDark;
                }
              } // Use light by default
              else {
                  iconName = iconMapped.spectrumIconLight;
                } // Mark icon as contextual icon because the icon name is defined based on the theme


              this.setAttribute('_context', '');
            } // Inform user about icon name changes


            if (iconName) {
              commons._log('warn', "Coral.Icon: the icon ".concat(iconId, " has been deprecated. Please use ").concat(iconName, " instead."));
            } else {
              commons._log('warn', "Coral.Icon: the icon ".concat(iconId, " has been removed. Please contact Icons@Adobe."));
            }
          } // In most cases, using the capitalized icon name maps to the spectrum icon name
          else {
              iconName = capitalize(iconId);
            } // Verify if icon name is a colored icon


          if (SPECTRUM_COLORED_ICONS_IDENTIFIER.some(function (identifier) {
            return iconName.indexOf(identifier) !== -1;
          })) {
            // Colored icons are 24 by default
            iconId = "spectrum-icon-24-".concat(iconName);
          } else {
            var sizeAttribute = this.getAttribute('size');
            var iconSize = sizeMap[sizeAttribute && sizeAttribute.toUpperCase() || size.SMALL];
            iconId = "spectrum-icon-".concat(iconSize, "-").concat(iconName);
          }
        } // Insert SVG Icon using HTML because DOMly doesn't support document.createElementNS for <use> element


        this.insertAdjacentHTML('beforeend', this.constructor._renderSVG(iconId));
        this._elements.svg = this.lastElementChild;
      }
      /**
       Updates the aria-label or img alt attribute depending on value of alt, title, icon and autoAriaLabel.
        In cases where the alt attribute has been removed or set to an empty string,
       for example, when the alt property is undefined and we add the attribute alt=''
       to explicitly override the default behavior, or when we remove an alt attribute
       thus restoring the default behavior, we make sure to update the alt text.
       @private
       */

    }, {
      key: "_updateAltText",
      value: function _updateAltText(value) {
        var hasAutoAriaLabel = this.autoAriaLabel === autoAriaLabel.ON;
        var img = this._elements.image;
        var isImage = this.contains(img); // alt should be prioritized over title

        var altText = typeof this.alt === 'string' ? this.alt : this.title;

        if (typeof value === 'string') {
          altText = this.alt || value;
        } else if (isImage) {
          altText = altText || img.getAttribute('alt') || img.getAttribute('title') || '';
        } else if (hasAutoAriaLabel) {
          var iconName = this.icon.replace(SPECTRUM_ICONS_IDENTIFIER_REGEX, '');
          iconName = iconName.replace(ICONS_VARIANT_POSTFIX_REGEX, '');
          altText = i18n.get(iconName.replace(SPLIT_CAMELCASE_REGEX, '$1 $2').toLowerCase(), ICON_ALT_TRANSLATION_HINT);
        } // If no other role has been set, provide the appropriate
        // role depending on whether or not the icon is an arbitrary image URL.


        var role = this.getAttribute('role');
        var roleOverride = role && role !== 'presentation' && role !== 'img';

        if (!roleOverride) {
          this.setAttribute('role', isImage ? 'presentation' : 'img');
        } // Set accessibility attributes accordingly


        if (isImage) {
          hasAutoAriaLabel && this.removeAttribute('aria-label');
          img.setAttribute('alt', altText);
        } else if (altText === '') {
          this.removeAttribute('aria-label');

          if (!roleOverride) {
            this.removeAttribute('role');
          }
        } else if (altText) {
          this.setAttribute('aria-label', altText);
        }
      }
      /**
       Whether SVG icons are referenced as external resource (on/off)
        @return {String}
       */

    }, {
      key: "attributeChangedCallback",

      /** @ignore */
      value: function attributeChangedCallback(name, oldValue, value) {
        if (name === 'alt' || name === 'title') {
          this._updateAltText(value);
        } else {
          _get(_getPrototypeOf(Icon.prototype), "attributeChangedCallback", this).call(this, name, oldValue, value);
        }
      }
      /** @ignore */

    }, {
      key: "connectedCallback",
      value: function connectedCallback() {
        _get(_getPrototypeOf(Icon.prototype), "connectedCallback", this).call(this); // Contextual icons need to be checked again


        if (this.hasAttribute('_context')) {
          this.icon = this.icon;
        }
      }
      /** @ignore */

    }, {
      key: "render",
      value: function render() {
        _get(_getPrototypeOf(Icon.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1); // Set default size

        if (!this._size) {
          this.size = size.SMALL;
        }

        var img = this.querySelector("img:not(.".concat(CLASSNAME$1, "--image)"));

        if (img) {
          this._elements.image = img;
          this._hasRawImage = true;
          this.icon = img.getAttribute('src');
          this._hasRawImage = false;
        }
      }
    }, {
      key: "autoAriaLabel",
      get: function get() {
        return this._autoAriaLabel || autoAriaLabel.OFF;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        this._autoAriaLabel = validate.enumeration(autoAriaLabel)(value) && value || autoAriaLabel.OFF;

        this._updateAltText();
      }
      /**
       Icon name.
        @type {String}
       @default ""
       @htmlattribute icon
       @htmlattributereflected
       */

    }, {
      key: "icon",
      get: function get() {
        return this._icon || '';
      },
      set: function set(value) {
        var _this2 = this;

        var icon = transform.string(value).trim(); // Avoid rendering the same icon

        if (icon !== this._icon || this.hasAttribute('_context')) {
          this._icon = icon;

          this._reflectAttribute('icon', this._icon); // Ignore unresolved templates


          if (this._icon.match(TEMPLATE_REGEX)) {
            return;
          } // Use the existing img


          if (this._hasRawImage) {
            this._elements.image.classList.add(CLASSNAME$1, "".concat(CLASSNAME$1, "--image"));

            this._updateAltText();

            return;
          } // Remove image and SVG elements


          ['image', 'svg'].forEach(function (type) {
            var el = _this2._elements[type] || _this2.querySelector(".".concat(CLASSNAME$1, "--").concat(type));

            if (el) {
              el.remove();
            }
          }); // Sets the desired icon

          if (this._icon) {
            // Detect if it's a URL
            if (this._icon.match(URL_REGEX)) {
              // Create an image and add it to the icon
              this._elements.image = this._elements.image || document.createElement('img');
              this._elements.image.className = "".concat(CLASSNAME$1, " ").concat(CLASSNAME$1, "--image");
              this._elements.image.src = this.icon;
              this.appendChild(this._elements.image);
            } else {
              this._updateIcon();
            }
          }

          this._updateAltText();
        }
      }
      /**
       Size of the icon. It accepts both lower and upper case sizes. See {@link IconSizeEnum}.
        @type {String}
       @default IconSizeEnum.SMALL
       @htmlattribute size
       @htmlattributereflected
       */

    }, {
      key: "size",
      get: function get() {
        return this._size || size.SMALL;
      },
      set: function set(value) {
        var _this$classList;

        var oldSize = this._size;
        value = transform.string(value).toUpperCase();
        this._size = validate.enumeration(size)(value) && value || size.SMALL;

        this._reflectAttribute('size', this._size); // removes all the existing sizes


        (_this$classList = this.classList).remove.apply(_this$classList, ALL_SIZE_CLASSES); // adds the new size


        this.classList.add("".concat(CLASSNAME$1, "--size").concat(this._size)); // We need to update the icon if the size changed

        if (oldSize && oldSize !== this._size && this.contains(this._elements.svg)) {
          this._elements.svg.remove();

          this._updateIcon();
        }

        this._updateAltText();
      }
      /** @private */

    }, {
      key: "title",
      get: function get() {
        return this.getAttribute('title');
      },
      set: function set(value) {
        this.setAttribute('title', value);
      }
      /** @private */

    }, {
      key: "alt",
      get: function get() {
        return this.getAttribute('alt');
      },
      set: function set(value) {
        this.setAttribute('alt', value);
      }
    }], [{
      key: "_iconsExternal",
      value: function _iconsExternal() {
        return iconsExternal;
      }
      /**
       Returns the SVG markup.
        @param {String} iconId
       @param {Array.<String>} additionalClasses
       @return {String}
       */

    }, {
      key: "_renderSVG",
      value: function _renderSVG(iconId) {
        var additionalClasses = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
        additionalClasses.unshift(CLASSNAME$1);
        additionalClasses.unshift("".concat(CLASSNAME$1, "--svg"));
        var iconPath = "#".concat(iconId); // If not colored icons

        if (this._iconsExternal() === 'on' && !SPECTRUM_COLORED_ICONS_IDENTIFIER.some(function (identifier) {
          return iconId.indexOf(identifier) !== -1;
        })) {
          // Generate spectrum-css-icons path
          if (iconId.indexOf('spectrum-css') === 0) {
            iconPath = resourcesPath ? "".concat(resourcesPath).concat(SPECTRUM_CSS_ICONS, ".svg#").concat(iconId) : "".concat(resolveIconsPath(SPECTRUM_CSS_ICONS_PATH), "#").concat(iconId);
          } // Generate spectrum-icons path
          else {
              iconPath = resourcesPath ? "".concat(resourcesPath).concat(SPECTRUM_ICONS, ".svg#").concat(iconId) : "".concat(resolveIconsPath(SPECTRUM_ICONS_PATH), "#").concat(iconId);
            }
        }

        return "\n      <svg focusable=\"false\" aria-hidden=\"true\" class=\"".concat(additionalClasses.join(' '), "\">\n        <use xlink:href=\"").concat(iconPath, "\"></use>\n      </svg>\n    ");
      }
      /**
       Returns {@link Icon} sizes.
        @return {IconSizeEnum}
       */

    }, {
      key: "load",

      /**
       Loads the SVG icons. It's requesting the icons based on the JS file path by default.
        @param {String} [url] SVG icons url.
       */
      value: function load(url) {
        var resolveIconsPath = function resolveIconsPath(iconsPath) {
          var path = commons._script.src;

          if (iconsExternal === 'js') {
            iconsPath = iconsPath.replace('.svg', '.js');
          }

          return "".concat(path.split('/').slice(0, -iconsPath.split('/').length).join('/'), "/").concat(iconsPath);
        };

        if (url === SPECTRUM_ICONS) {
          url = resolveIconsPath(SPECTRUM_ICONS_PATH);
        } else if (url === SPECTRUM_ICONS_COLOR) {
          url = resolveIconsPath(SPECTRUM_ICONS_COLOR_PATH);
        } else if (url === SPECTRUM_CSS_ICONS) {
          url = resolveIconsPath(SPECTRUM_CSS_ICONS_PATH);
        }

        loadIcons(url);
      }
    }, {
      key: "size",
      get: function get() {
        return size;
      }
      /**
       Returns {@link Icon} autoAriaLabel options.
        @return {IconAutoAriaLabelEnum}
       */

    }, {
      key: "autoAriaLabel",
      get: function get() {
        return autoAriaLabel;
      }
    }, {
      key: "_attributePropertyMap",
      get: function get() {
        return commons.extend(_get(_getPrototypeOf(Icon), "_attributePropertyMap", this), {
          autoarialabel: 'autoAriaLabel'
        });
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(Icon), "observedAttributes", this).concat(['autoarialabel', 'icon', 'size', 'alt', 'title']);
      }
    }]);

    return Icon;
  }(BaseComponent(HTMLElement)); // Load icon collections by default


  var iconCollections = [SPECTRUM_ICONS_COLOR];
  var extension = '.svg';

  if (Icon._iconsExternal() === 'off' || Icon._iconsExternal() === 'js') {
    iconCollections.push(SPECTRUM_CSS_ICONS);
    iconCollections.push(SPECTRUM_ICONS);

    if (Icon._iconsExternal() === 'js') {
      extension = '.js';
    }
  }

  iconCollections.forEach(function (iconSet) {
    return Icon.load(resourcesPath ? "".concat(resourcesPath).concat(iconSet).concat(extension) : iconSet);
  });

  /**
   * Copyright 2020 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var translations = {
    "en-US": {
      "123/[translation hint:default icon alt text]": "123",
      "alert/[translation hint:default icon alt text]": "Alert",
      "arrow down/[translation hint:default icon alt text]": "Arrow Down",
      "arrow left/[translation hint:default icon alt text]": "Arrow Left",
      "arrow up/[translation hint:default icon alt text]": "Arrow Up",
      "asterisk/[translation hint:default icon alt text]": "Asterisk",
      "checkmark/[translation hint:default icon alt text]": "Checkmark",
      "chevron down/[translation hint:default icon alt text]": "Expand",
      "chevron left/[translation hint:default icon alt text]": "Back",
      "chevron right/[translation hint:default icon alt text]": "Expand",
      "chevron up/[translation hint:default icon alt text]": "Collapse",
      "corner triangle/[translation hint:default icon alt text]": "Expand",
      "cross/[translation hint:default icon alt text]": "Close",
      "dash/[translation hint:default icon alt text]": "Dash",
      "double gripper/[translation hint:default icon alt text]": "Double Gripper",
      "help/[translation hint:default icon alt text]": "Help",
      "info/[translation hint:default icon alt text]": "Info",
      "magnifier/[translation hint:default icon alt text]": "Magnifier",
      "skip left/[translation hint:default icon alt text]": "Skip Left",
      "skip right/[translation hint:default icon alt text]": "Skip Right",
      "star/[translation hint:default icon alt text]": "Star",
      "success/[translation hint:default icon alt text]": "Success",
      "triple gripper/[translation hint:default icon alt text]": "Triple Gripper",
      "3dmaterials/[translation hint:default icon alt text]": "3D Materials",
      "abc/[translation hint:default icon alt text]": "ABC",
      "actions/[translation hint:default icon alt text]": "Actions",
      "ad display/[translation hint:default icon alt text]": "Ad Display",
      "ad print/[translation hint:default icon alt text]": "Ad Print",
      "add/[translation hint:default icon alt text]": "Add",
      "add circle/[translation hint:default icon alt text]": "Add",
      "add to/[translation hint:default icon alt text]": "Add To",
      "add to selection/[translation hint:default icon alt text]": "Add To Selection",
      "adobe advertising cloud/[translation hint:default icon alt text]": "Adobe Advertising Cloud",
      "adobe analytics/[translation hint:default icon alt text]": "Adobe Analytics",
      "adobe analytics cloud/[translation hint:default icon alt text]": "Adobe Analytics Cloud",
      "adobe audience manager/[translation hint:default icon alt text]": "Adobe Audience Manager",
      "adobe campaign/[translation hint:default icon alt text]": "Adobe Campaign",
      "adobe connect/[translation hint:default icon alt text]": "Adobe Connect",
      "adobe document cloud/[translation hint:default icon alt text]": "Adobe Document Cloud",
      "adobe experience cloud/[translation hint:default icon alt text]": "Adobe Experience Cloud",
      "adobe experience manager/[translation hint:default icon alt text]": "Adobe Experience Manager",
      "adobe logo/[translation hint:default icon alt text]": "Adobe Logo",
      "adobe marketing cloud/[translation hint:default icon alt text]": "Adobe Marketing Cloud",
      "adobe media optimizer/[translation hint:default icon alt text]": "Adobe Media Optimizer",
      "adobe primetime/[translation hint:default icon alt text]": "Adobe Primetime",
      "adobe send now/[translation hint:default icon alt text]": "Adobe Send Now",
      "adobe sign/[translation hint:default icon alt text]": "Adobe Sign",
      "adobe social/[translation hint:default icon alt text]": "Adobe Social",
      "adobe target/[translation hint:default icon alt text]": "Adobe Target",
      "after effects/[translation hint:default icon alt text]": "After Effects",
      "alert add/[translation hint:default icon alt text]": "Alert Add",
      "alert check/[translation hint:default icon alt text]": "Alert Check",
      "alert circle/[translation hint:default icon alt text]": "Alert",
      "alias/[translation hint:default icon alt text]": "Alias",
      "align bottom/[translation hint:default icon alt text]": "Align Bottom",
      "align center/[translation hint:default icon alt text]": "Align Center",
      "align left/[translation hint:default icon alt text]": "Align Left",
      "align middle/[translation hint:default icon alt text]": "Align Middle",
      "align right/[translation hint:default icon alt text]": "Align Right",
      "align top/[translation hint:default icon alt text]": "Align Top",
      "amazon web services/[translation hint:default icon alt text]": "Amazon Web Services",
      "anchor/[translation hint:default icon alt text]": "Anchor",
      "anchor select/[translation hint:default icon alt text]": "Select Anchor",
      "android/[translation hint:default icon alt text]": "Android",
      "annotate/[translation hint:default icon alt text]": "Annotate",
      "annotate pen/[translation hint:default icon alt text]": "Annotate Pen",
      "answer/[translation hint:default icon alt text]": "Answer",
      "answer favorite/[translation hint:default icon alt text]": "Favorite Answer",
      "app/[translation hint:default icon alt text]": "App",
      "app refresh/[translation hint:default icon alt text]": "App Refresh",
      "apple/[translation hint:default icon alt text]": "Apple",
      "apple files/[translation hint:default icon alt text]": "Apple Files",
      "approve reject/[translation hint:default icon alt text]": "Approve Reject",
      "apps/[translation hint:default icon alt text]": "Apps",
      "archive/[translation hint:default icon alt text]": "Archive",
      "archive remove/[translation hint:default icon alt text]": "Remove Archive",
      "arrow right/[translation hint:default icon alt text]": "Arrow Right",
      "arrow up right/[translation hint:default icon alt text]": "Arrow Up Right",
      "artboard/[translation hint:default icon alt text]": "Artboard",
      "article/[translation hint:default icon alt text]": "Article",
      "asset/[translation hint:default icon alt text]": "Asset",
      "asset check/[translation hint:default icon alt text]": "Asset Check",
      "assets added/[translation hint:default icon alt text]": "Assets Added",
      "assets downloaded/[translation hint:default icon alt text]": "Assets Downloaded",
      "assets expired/[translation hint:default icon alt text]": "Assets Expired",
      "assets linked published/[translation hint:default icon alt text]": "Assets Linked Published",
      "assets modified/[translation hint:default icon alt text]": "Assets Modified",
      "assets published/[translation hint:default icon alt text]": "Assets Published",
      "at/[translation hint:default icon alt text]": "At",
      "attach/[translation hint:default icon alt text]": "Attach",
      "attachment exclude/[translation hint:default icon alt text]": "Attachment Exclude",
      "attributes/[translation hint:default icon alt text]": "Attributes",
      "audio/[translation hint:default icon alt text]": "Audio",
      "automated segment/[translation hint:default icon alt text]": "Automated Segment",
      "back/[translation hint:default icon alt text]": "Back",
      "back 30seconds/[translation hint:default icon alt text]": "Back 30 Seconds",
      "back android/[translation hint:default icon alt text]": "Back Android",
      "beaker/[translation hint:default icon alt text]": "Beaker",
      "beaker check/[translation hint:default icon alt text]": "Beaker Check",
      "beaker share/[translation hint:default icon alt text]": "Beaker Share",
      "behance/[translation hint:default icon alt text]": "Behance",
      "bell/[translation hint:default icon alt text]": "Bell",
      "bid rule/[translation hint:default icon alt text]": "Bid Rule",
      "bid rule add/[translation hint:default icon alt text]": "Bid Rule Add",
      "bitly/[translation hint:default icon alt text]": "Bitly",
      "blackberry/[translation hint:default icon alt text]": "Blackberry",
      "blog/[translation hint:default icon alt text]": "Blog",
      "blower/[translation hint:default icon alt text]": "Blower",
      "blur/[translation hint:default icon alt text]": "Blur",
      "book/[translation hint:default icon alt text]": "Book",
      "bookmark/[translation hint:default icon alt text]": "Bookmark",
      "boolean/[translation hint:default icon alt text]": "Boolean",
      "border/[translation hint:default icon alt text]": "Border",
      "box/[translation hint:default icon alt text]": "Box",
      "box add/[translation hint:default icon alt text]": "Box Add",
      "box export/[translation hint:default icon alt text]": "Box Export",
      "box import/[translation hint:default icon alt text]": "Box Import",
      "brackets/[translation hint:default icon alt text]": "Brackets",
      "brackets square/[translation hint:default icon alt text]": "Brackets Square",
      "branch 1/[translation hint:default icon alt text]": "Branch 1",
      "branch 2/[translation hint:default icon alt text]": "Branch 2",
      "branch 3/[translation hint:default icon alt text]": "Branch 3",
      "branch circle/[translation hint:default icon alt text]": "Branch",
      "breadcrumb navigation/[translation hint:default icon alt text]": "Breadcrumb Navigation",
      "breakdown/[translation hint:default icon alt text]": "Breakdown",
      "breakdown add/[translation hint:default icon alt text]": "Breakdown Add",
      "briefcase/[translation hint:default icon alt text]": "Briefcase",
      "browse/[translation hint:default icon alt text]": "Browse",
      "brush/[translation hint:default icon alt text]": "Brush",
      "bug/[translation hint:default icon alt text]": "Bug",
      "building/[translation hint:default icon alt text]": "Building",
      "bulk edit users/[translation hint:default icon alt text]": "Bulk Edit Users",
      "button/[translation hint:default icon alt text]": "Button",
      "cclibrary/[translation hint:default icon alt text]": "CC Library",
      "calculator/[translation hint:default icon alt text]": "Calculator",
      "calendar/[translation hint:default icon alt text]": "Calendar",
      "calendar add/[translation hint:default icon alt text]": "Calendar Add",
      "calendar locked/[translation hint:default icon alt text]": "Calendar Locked",
      "calendar unlocked/[translation hint:default icon alt text]": "Calendar Unlocked",
      "call center/[translation hint:default icon alt text]": "Call Center",
      "camera/[translation hint:default icon alt text]": "Camera",
      "camera flip/[translation hint:default icon alt text]": "Camera Flip",
      "camera refresh/[translation hint:default icon alt text]": "Camera Refresh",
      "campaign/[translation hint:default icon alt text]": "Campaign",
      "campaign add/[translation hint:default icon alt text]": "Campaign Add",
      "campaign close/[translation hint:default icon alt text]": "Campaign Close",
      "campaign delete/[translation hint:default icon alt text]": "Campaign Delete",
      "campaign edit/[translation hint:default icon alt text]": "Campaign Edit",
      "cancel/[translation hint:default icon alt text]": "Cancel",
      "capitals/[translation hint:default icon alt text]": "Capitals",
      "captcha/[translation hint:default icon alt text]": "Captcha",
      "card/[translation hint:default icon alt text]": "Card",
      "channel/[translation hint:default icon alt text]": "Channel",
      "chat/[translation hint:default icon alt text]": "Chat",
      "chat add/[translation hint:default icon alt text]": "Chat Add",
      "check pause/[translation hint:default icon alt text]": "Check Pause",
      "checkmark circle/[translation hint:default icon alt text]": "Checkmark",
      "chevron double left/[translation hint:default icon alt text]": "Back",
      "chevron double right/[translation hint:default icon alt text]": "Forward",
      "chevron up down/[translation hint:default icon alt text]": "Sortable",
      "chrome/[translation hint:default icon alt text]": "Chrome",
      "circle/[translation hint:default icon alt text]": "Circle",
      "classic grid view/[translation hint:default icon alt text]": "Classic Grid View",
      "clock/[translation hint:default icon alt text]": "Clock",
      "clock check/[translation hint:default icon alt text]": "Clock Check",
      "clone stamp/[translation hint:default icon alt text]": "Clone Stamp",
      "close/[translation hint:default icon alt text]": "Close",
      "close captions/[translation hint:default icon alt text]": "Close Captions",
      "close circle/[translation hint:default icon alt text]": "Close",
      "cloud/[translation hint:default icon alt text]": "Cloud",
      "cloud disconnected/[translation hint:default icon alt text]": "Cloud Disconnected",
      "cloud error/[translation hint:default icon alt text]": "Cloud Error",
      "code/[translation hint:default icon alt text]": "Code",
      "collection/[translation hint:default icon alt text]": "Collection",
      "collection add/[translation hint:default icon alt text]": "Collection Add",
      "collection add to/[translation hint:default icon alt text]": "Collection Add To",
      "collection check/[translation hint:default icon alt text]": "Collection Check",
      "collection edit/[translation hint:default icon alt text]": "Collection Edit",
      "collection exclude/[translation hint:default icon alt text]": "Collection Exclude",
      "collection link/[translation hint:default icon alt text]": "Collection Link",
      "color fill/[translation hint:default icon alt text]": "Color Fill",
      "color palette/[translation hint:default icon alt text]": "Color Palette",
      "color wheel/[translation hint:default icon alt text]": "Color Wheel",
      "column settings/[translation hint:default icon alt text]": "Column Settings",
      "column two a/[translation hint:default icon alt text]": "Column Two A",
      "column two b/[translation hint:default icon alt text]": "Column Two B",
      "column two c/[translation hint:default icon alt text]": "Column Two C",
      "comment/[translation hint:default icon alt text]": "Comment",
      "compare/[translation hint:default icon alt text]": "Compare",
      "compass/[translation hint:default icon alt text]": "Compass",
      "condition/[translation hint:default icon alt text]": "Condition",
      "confidence four/[translation hint:default icon alt text]": "Confidence Four",
      "confidence one/[translation hint:default icon alt text]": "Confidence One",
      "confidence three/[translation hint:default icon alt text]": "Confidence Three",
      "confidence two/[translation hint:default icon alt text]": "Confidence Two",
      "contrast/[translation hint:default icon alt text]": "Contrast",
      "conversion funnel/[translation hint:default icon alt text]": "Conversion Funnel",
      "copy/[translation hint:default icon alt text]": "Copy",
      "cover image/[translation hint:default icon alt text]": "Cover Image",
      "creative cloud/[translation hint:default icon alt text]": "Creative Cloud",
      "credit card/[translation hint:default icon alt text]": "Credit Card",
      "crop/[translation hint:default icon alt text]": "Crop",
      "crop lightning/[translation hint:default icon alt text]": "Crop Lightning",
      "crop rotate/[translation hint:default icon alt text]": "Crop Rotate",
      "crosshairs/[translation hint:default icon alt text]": "Crosshairs",
      "curate/[translation hint:default icon alt text]": "Curate",
      "cut/[translation hint:default icon alt text]": "Cut",
      "dps/[translation hint:default icon alt text]": "DPS",
      "dashboard/[translation hint:default icon alt text]": "Dashboard",
      "data/[translation hint:default icon alt text]": "Data",
      "data add/[translation hint:default icon alt text]": "Data Add",
      "data adobe/[translation hint:default icon alt text]": "Data Adobe",
      "data book/[translation hint:default icon alt text]": "Data Book",
      "data check/[translation hint:default icon alt text]": "Data Check",
      "data correlated/[translation hint:default icon alt text]": "Data Correlated",
      "data download/[translation hint:default icon alt text]": "Data Download",
      "data edit/[translation hint:default icon alt text]": "Data Edit",
      "data mapping/[translation hint:default icon alt text]": "Data Mapping",
      "data refresh/[translation hint:default icon alt text]": "Data Refresh",
      "data remove/[translation hint:default icon alt text]": "Data Remove",
      "data settings/[translation hint:default icon alt text]": "Data Settings",
      "data unavailable/[translation hint:default icon alt text]": "Data Unavailable",
      "data upload/[translation hint:default icon alt text]": "Data Upload",
      "data user/[translation hint:default icon alt text]": "Data User",
      "date/[translation hint:default icon alt text]": "Date",
      "date input/[translation hint:default icon alt text]": "Date Input",
      "deduplication/[translation hint:default icon alt text]": "Deduplication",
      "delegate/[translation hint:default icon alt text]": "Delegate",
      "delete/[translation hint:default icon alt text]": "Delete",
      "delivery fusion/[translation hint:default icon alt text]": "Delivery Fusion",
      "demographic/[translation hint:default icon alt text]": "Demographic",
      "deselect/[translation hint:default icon alt text]": "Deselect",
      "deselect circular/[translation hint:default icon alt text]": "Deselect",
      "desktop and mobile/[translation hint:default icon alt text]": "Desktop And Mobile",
      "device desktop/[translation hint:default icon alt text]": "Device Desktop",
      "device laptop/[translation hint:default icon alt text]": "Device Laptop",
      "device phone/[translation hint:default icon alt text]": "Device Phone",
      "device phone refresh/[translation hint:default icon alt text]": "Device Phone Refresh",
      "device preview/[translation hint:default icon alt text]": "Device Preview",
      "device rotate landscape/[translation hint:default icon alt text]": "Device Rotate Landscape",
      "device rotate portrait/[translation hint:default icon alt text]": "Device Rotate Portrait",
      "device tv/[translation hint:default icon alt text]": "Device TV",
      "device tablet/[translation hint:default icon alt text]": "Device Tablet",
      "devices/[translation hint:default icon alt text]": "Devices",
      "dimension/[translation hint:default icon alt text]": "Dimension",
      "disqus/[translation hint:default icon alt text]": "Disqus",
      "distribute bottom edge/[translation hint:default icon alt text]": "Distribute Bottom Edge",
      "distribute horizontal center/[translation hint:default icon alt text]": "Distribute Horizontal Center",
      "distribute horizontally/[translation hint:default icon alt text]": "Distribute Horizontally",
      "distribute left edge/[translation hint:default icon alt text]": "Distribute Left Edge",
      "distribute right edge/[translation hint:default icon alt text]": "Distribute Right Edge",
      "distribute space horiz/[translation hint:default icon alt text]": "Distribute Space Horizontally",
      "distribute space vert/[translation hint:default icon alt text]": "Distribute Space Vertically",
      "distribute top edge/[translation hint:default icon alt text]": "Distribute Top Edge",
      "distribute vertical center/[translation hint:default icon alt text]": "Distribute Vertical Center",
      "distribute vertically/[translation hint:default icon alt text]": "Distribute Vertically",
      "divide/[translation hint:default icon alt text]": "Divide",
      "divide path/[translation hint:default icon alt text]": "Divide Path",
      "document/[translation hint:default icon alt text]": "Document",
      "document fragment/[translation hint:default icon alt text]": "Document Fragment",
      "document fragment group/[translation hint:default icon alt text]": "Document Fragment Group",
      "document refresh/[translation hint:default icon alt text]": "Document Refresh",
      "dolly/[translation hint:default icon alt text]": "Dolly",
      "download/[translation hint:default icon alt text]": "Download",
      "download from cloud/[translation hint:default icon alt text]": "Download From Cloud",
      "draft/[translation hint:default icon alt text]": "Draft",
      "drag handle/[translation hint:default icon alt text]": "Drag Handle",
      "draw/[translation hint:default icon alt text]": "Draw",
      "dropdown/[translation hint:default icon alt text]": "Dropdown",
      "duplicate/[translation hint:default icon alt text]": "Duplicate",
      "edit/[translation hint:default icon alt text]": "Edit",
      "edit circle/[translation hint:default icon alt text]": "Edit",
      "edit exclude/[translation hint:default icon alt text]": "Edit Exclude",
      "edit in/[translation hint:default icon alt text]": "Edit In",
      "education/[translation hint:default icon alt text]": "Education",
      "effects/[translation hint:default icon alt text]": "Effects",
      "efficient/[translation hint:default icon alt text]": "Efficient",
      "ellipse/[translation hint:default icon alt text]": "Ellipse",
      "email/[translation hint:default icon alt text]": "Email",
      "email cancel/[translation hint:default icon alt text]": "Email Cancel",
      "email check/[translation hint:default icon alt text]": "Email Check",
      "email exclude/[translation hint:default icon alt text]": "Email Exclude",
      "email gear/[translation hint:default icon alt text]": "Email Gear",
      "email key/[translation hint:default icon alt text]": "Email Key",
      "email lightning/[translation hint:default icon alt text]": "Email Lightning",
      "email notification/[translation hint:default icon alt text]": "Email Notification",
      "email refresh/[translation hint:default icon alt text]": "Email Refresh",
      "email schedule/[translation hint:default icon alt text]": "Email Schedule",
      "engagement/[translation hint:default icon alt text]": "Engagement",
      "erase/[translation hint:default icon alt text]": "Erase",
      "event/[translation hint:default icon alt text]": "Event",
      "event exclude/[translation hint:default icon alt text]": "Event Exclude",
      "event share/[translation hint:default icon alt text]": "Event Share",
      "events/[translation hint:default icon alt text]": "Events",
      "exclude overlap/[translation hint:default icon alt text]": "Exclude Overlap",
      "experience/[translation hint:default icon alt text]": "Experience",
      "experience add/[translation hint:default icon alt text]": "Experience Add",
      "experience add to/[translation hint:default icon alt text]": "Experience Add To",
      "experience export/[translation hint:default icon alt text]": "Experience Export",
      "experience import/[translation hint:default icon alt text]": "Experience Import",
      "export/[translation hint:default icon alt text]": "Export",
      "export original/[translation hint:default icon alt text]": "Export Original",
      "exposure/[translation hint:default icon alt text]": "Exposure",
      "extension/[translation hint:default icon alt text]": "Extension",
      "facebook/[translation hint:default icon alt text]": "Facebook",
      "facebook cover image/[translation hint:default icon alt text]": "Facebook Cover Image",
      "fast/[translation hint:default icon alt text]": "Fast",
      "fast forward/[translation hint:default icon alt text]": "Fast Forward",
      "fast forward circle/[translation hint:default icon alt text]": "Fast Forward",
      "feed/[translation hint:default icon alt text]": "Feed",
      "feed add/[translation hint:default icon alt text]": "Feed Add",
      "feed management/[translation hint:default icon alt text]": "Feed Management",
      "feedback/[translation hint:default icon alt text]": "Feedback",
      "file add/[translation hint:default icon alt text]": "File Add",
      "file csv/[translation hint:default icon alt text]": "File CSV",
      "file campaign/[translation hint:default icon alt text]": "File Campaign",
      "file chart/[translation hint:default icon alt text]": "File Chart",
      "file checked out/[translation hint:default icon alt text]": "File Checked Out",
      "file code/[translation hint:default icon alt text]": "File Code",
      "file data/[translation hint:default icon alt text]": "File Data",
      "file email/[translation hint:default icon alt text]": "File Email",
      "file excel/[translation hint:default icon alt text]": "File Excel",
      "file folder/[translation hint:default icon alt text]": "File Folder",
      "file gear/[translation hint:default icon alt text]": "File Gear",
      "file globe/[translation hint:default icon alt text]": "File Globe",
      "file html/[translation hint:default icon alt text]": "File HTML",
      "file important/[translation hint:default icon alt text]": "File Important",
      "file json/[translation hint:default icon alt text]": "File JSON",
      "file key/[translation hint:default icon alt text]": "File Key",
      "file mobile/[translation hint:default icon alt text]": "File Mobile",
      "file pdf/[translation hint:default icon alt text]": "File PDF",
      "file share/[translation hint:default icon alt text]": "File Share",
      "file single web page/[translation hint:default icon alt text]": "File Single Web Page",
      "file space/[translation hint:default icon alt text]": "File Space",
      "file template/[translation hint:default icon alt text]": "File Template",
      "file txt/[translation hint:default icon alt text]": "File Txt",
      "file user/[translation hint:default icon alt text]": "File User",
      "file word/[translation hint:default icon alt text]": "File Word",
      "file workflow/[translation hint:default icon alt text]": "File Workflow",
      "file xml/[translation hint:default icon alt text]": "File XML",
      "file zip/[translation hint:default icon alt text]": "File Zip",
      "filing cabinet/[translation hint:default icon alt text]": "Filing Cabinet",
      "fill sign/[translation hint:default icon alt text]": "Fill Sign",
      "filmroll/[translation hint:default icon alt text]": "Filmroll",
      "filmroll auto add/[translation hint:default icon alt text]": "Filmroll Auto Add",
      "filter/[translation hint:default icon alt text]": "Filter",
      "filter add/[translation hint:default icon alt text]": "Filter Add",
      "filter check/[translation hint:default icon alt text]": "Filter Check",
      "filter delete/[translation hint:default icon alt text]": "Filter Delete",
      "filter edit/[translation hint:default icon alt text]": "Filter Edit",
      "filter heart/[translation hint:default icon alt text]": "Filter Heart",
      "filter remove/[translation hint:default icon alt text]": "Filter Remove",
      "filter star/[translation hint:default icon alt text]": "Filter Star",
      "find and replace/[translation hint:default icon alt text]": "Find And Replace",
      "firefox/[translation hint:default icon alt text]": "Firefox",
      "flag/[translation hint:default icon alt text]": "Flag",
      "flag exclude/[translation hint:default icon alt text]": "Flag Exclude",
      "flash/[translation hint:default icon alt text]": "Flash",
      "flash auto/[translation hint:default icon alt text]": "Flash Auto",
      "flash off/[translation hint:default icon alt text]": "Flash Off",
      "flash on/[translation hint:default icon alt text]": "Flash On",
      "flashlight off/[translation hint:default icon alt text]": "Flashlight Off",
      "flashlight on/[translation hint:default icon alt text]": "Flashlight On",
      "flickr/[translation hint:default icon alt text]": "Flickr",
      "flip horizontal/[translation hint:default icon alt text]": "Flip Horizontal",
      "flip vertical/[translation hint:default icon alt text]": "Flip Vertical",
      "folder/[translation hint:default icon alt text]": "Folder",
      "folder 2/[translation hint:default icon alt text]": "Folder",
      "folder add/[translation hint:default icon alt text]": "Folder Add",
      "folder add to/[translation hint:default icon alt text]": "Folder Add To",
      "folder adobe/[translation hint:default icon alt text]": "Folder Adobe",
      "folder archive/[translation hint:default icon alt text]": "Folder Archive",
      "folder delete/[translation hint:default icon alt text]": "Folder Delete",
      "folder gear/[translation hint:default icon alt text]": "Folder Gear",
      "folder locked/[translation hint:default icon alt text]": "Folder Locked",
      "folder locked adobe/[translation hint:default icon alt text]": "Folder Locked Adobe",
      "folder open/[translation hint:default icon alt text]": "Folder Open",
      "folder remove/[translation hint:default icon alt text]": "Folder Remove",
      "folder search/[translation hint:default icon alt text]": "Folder Search",
      "folder user/[translation hint:default icon alt text]": "Folder User",
      "follow/[translation hint:default icon alt text]": "Follow",
      "follow off/[translation hint:default icon alt text]": "Follow Off",
      "for placement only/[translation hint:default icon alt text]": "For Placement Only",
      "forecast/[translation hint:default icon alt text]": "Forecast",
      "form/[translation hint:default icon alt text]": "Form",
      "forward/[translation hint:default icon alt text]": "Forward",
      "full screen/[translation hint:default icon alt text]": "Full Screen",
      "full screen exit/[translation hint:default icon alt text]": "Full Screen Exit",
      "function/[translation hint:default icon alt text]": "Function",
      "game/[translation hint:default icon alt text]": "Game",
      "gauge 1/[translation hint:default icon alt text]": "Gauge 1",
      "gauge 2/[translation hint:default icon alt text]": "Gauge 2",
      "gauge 3/[translation hint:default icon alt text]": "Gauge 3",
      "gauge 4/[translation hint:default icon alt text]": "Gauge 4",
      "gauge 5/[translation hint:default icon alt text]": "Gauge 5",
      "gears/[translation hint:default icon alt text]": "Gears",
      "gears add/[translation hint:default icon alt text]": "Gears Add",
      "gears delete/[translation hint:default icon alt text]": "Gears Delete",
      "gears edit/[translation hint:default icon alt text]": "Gears Edit",
      "gender female/[translation hint:default icon alt text]": "Gender Female",
      "gender male/[translation hint:default icon alt text]": "Gender Male",
      "gift/[translation hint:default icon alt text]": "Gift",
      "git hub/[translation hint:default icon alt text]": "Git Hub",
      "globe/[translation hint:default icon alt text]": "Globe",
      "globe check/[translation hint:default icon alt text]": "Globe Check",
      "globe clock/[translation hint:default icon alt text]": "Globe Clock",
      "globe enter/[translation hint:default icon alt text]": "Globe Enter",
      "globe exit/[translation hint:default icon alt text]": "Globe Exit",
      "globe grid/[translation hint:default icon alt text]": "Globe Grid",
      "globe remove/[translation hint:default icon alt text]": "Globe Remove",
      "globe search/[translation hint:default icon alt text]": "Globe Search",
      "globe strike/[translation hint:default icon alt text]": "Globe Strike",
      "globe strike clock/[translation hint:default icon alt text]": "Globe Strike Clock",
      "google/[translation hint:default icon alt text]": "Google",
      "google analytics/[translation hint:default icon alt text]": "Google Analytics",
      "google play store/[translation hint:default icon alt text]": "Google Play Store",
      "google plus/[translation hint:default icon alt text]": "Google Plus",
      "google plus 1/[translation hint:default icon alt text]": "Google Plus",
      "gradient/[translation hint:default icon alt text]": "Gradient",
      "graph area/[translation hint:default icon alt text]": "Graph Area",
      "graph area stacked/[translation hint:default icon alt text]": "Graph Area Stacked",
      "graph bar horizontal/[translation hint:default icon alt text]": "Graph Bar Horizontal",
      "graph bar horizontal add/[translation hint:default icon alt text]": "Graph Bar Horizontal Add",
      "graph bar horizontal stacked/[translation hint:default icon alt text]": "Graph Bar Horizontal Stacked",
      "graph bar vertical/[translation hint:default icon alt text]": "Graph Bar Vertical",
      "graph bar vertical add/[translation hint:default icon alt text]": "Graph Bar Vertical Add",
      "graph bar vertical stacked/[translation hint:default icon alt text]": "Graph Bar Vertical Stacked",
      "graph bubble/[translation hint:default icon alt text]": "Graph Bubble",
      "graph bullet/[translation hint:default icon alt text]": "Graph Bullet",
      "graph confidence bands/[translation hint:default icon alt text]": "Graph Confidence Bands",
      "graph donut/[translation hint:default icon alt text]": "Graph Donut",
      "graph donut add/[translation hint:default icon alt text]": "Graph Donut Add",
      "graph gantt/[translation hint:default icon alt text]": "Graph Gantt",
      "graph histogram/[translation hint:default icon alt text]": "Graph Histogram",
      "graph pathing/[translation hint:default icon alt text]": "Graph Pathing",
      "graph pie/[translation hint:default icon alt text]": "Graph Pie",
      "graph profit curve/[translation hint:default icon alt text]": "Graph Profit Curve",
      "graph scatter/[translation hint:default icon alt text]": "Graph Scatter",
      "graph stream/[translation hint:default icon alt text]": "Graph Stream",
      "graph stream ranked/[translation hint:default icon alt text]": "Graph Stream Ranked",
      "graph stream ranked add/[translation hint:default icon alt text]": "Graph Stream Ranked Add",
      "graph sunburst/[translation hint:default icon alt text]": "Graph Sunburst",
      "graph tree/[translation hint:default icon alt text]": "Graph Tree",
      "graph trend/[translation hint:default icon alt text]": "Graph Trend",
      "graph trend add/[translation hint:default icon alt text]": "Graph Trend Add",
      "graph trend alert/[translation hint:default icon alt text]": "Graph Trend Alert",
      "graphic/[translation hint:default icon alt text]": "Graphic",
      "group/[translation hint:default icon alt text]": "Group",
      "html5/[translation hint:default icon alt text]": "HTML5",
      "hammer/[translation hint:default icon alt text]": "Hammer",
      "hand/[translation hint:default icon alt text]": "Hand",
      "hand 0/[translation hint:default icon alt text]": "Hand 0",
      "hand 1/[translation hint:default icon alt text]": "Hand 1",
      "hand 2/[translation hint:default icon alt text]": "Hand 2",
      "hand 3/[translation hint:default icon alt text]": "Hand 3",
      "hand 4/[translation hint:default icon alt text]": "Hand 4",
      "heal/[translation hint:default icon alt text]": "Heal",
      "heart/[translation hint:default icon alt text]": "Heart",
      "histogram/[translation hint:default icon alt text]": "Histogram",
      "history/[translation hint:default icon alt text]": "History",
      "home/[translation hint:default icon alt text]": "Home",
      "homepage/[translation hint:default icon alt text]": "Homepage",
      "illustrator/[translation hint:default icon alt text]": "Illustrator",
      "image/[translation hint:default icon alt text]": "Image",
      "image add/[translation hint:default icon alt text]": "Image Add",
      "image album/[translation hint:default icon alt text]": "Image Album",
      "image auto mode/[translation hint:default icon alt text]": "Image Auto Mode",
      "image carousel/[translation hint:default icon alt text]": "Image Carousel",
      "image check/[translation hint:default icon alt text]": "Image Check",
      "image checked out/[translation hint:default icon alt text]": "Image Checked Out",
      "image map circle/[translation hint:default icon alt text]": "Image Map Circle",
      "image map polygon/[translation hint:default icon alt text]": "Image Map Polygon",
      "image map rectangle/[translation hint:default icon alt text]": "Image Map Rectangle",
      "image next/[translation hint:default icon alt text]": "Image Next",
      "image profile/[translation hint:default icon alt text]": "Image Profile",
      "image search/[translation hint:default icon alt text]": "Image Search",
      "image text/[translation hint:default icon alt text]": "Image Text",
      "images/[translation hint:default icon alt text]": "Images",
      "import/[translation hint:default icon alt text]": "Import",
      "in design/[translation hint:default icon alt text]": "In Design",
      "inbox/[translation hint:default icon alt text]": "Inbox",
      "individual/[translation hint:default icon alt text]": "Individual",
      "instagram/[translation hint:default icon alt text]": "Instagram",
      "internet explorer/[translation hint:default icon alt text]": "Internet Explorer",
      "intersect overlap/[translation hint:default icon alt text]": "Intersect Overlap",
      "invert adj/[translation hint:default icon alt text]": "Invert Adj",
      "journey/[translation hint:default icon alt text]": "Journey",
      "journey action/[translation hint:default icon alt text]": "Journey Action",
      "journey data/[translation hint:default icon alt text]": "Journey Data",
      "journey event/[translation hint:default icon alt text]": "Journey Event",
      "journey event 2/[translation hint:default icon alt text]": "Journey Event",
      "journey reports/[translation hint:default icon alt text]": "Journey Reports",
      "journey voyager/[translation hint:default icon alt text]": "Journey Voyager",
      "jump to top/[translation hint:default icon alt text]": "Jump To Top",
      "key/[translation hint:default icon alt text]": "Key",
      "key clock/[translation hint:default icon alt text]": "Key Clock",
      "key exclude/[translation hint:default icon alt text]": "Key Exclude",
      "keyboard/[translation hint:default icon alt text]": "Keyboard",
      "label/[translation hint:default icon alt text]": "Label",
      "label exclude/[translation hint:default icon alt text]": "Label Exclude",
      "labels/[translation hint:default icon alt text]": "Labels",
      "landscape/[translation hint:default icon alt text]": "Landscape",
      "launch/[translation hint:default icon alt text]": "Launch",
      "layers/[translation hint:default icon alt text]": "Layers",
      "layers backward/[translation hint:default icon alt text]": "Layers Backward",
      "layers bring to front/[translation hint:default icon alt text]": "Layers Bring To Front",
      "layers forward/[translation hint:default icon alt text]": "Layers Forward",
      "layers send to back/[translation hint:default icon alt text]": "Layers Send To Back",
      "lightroom/[translation hint:default icon alt text]": "Lightroom",
      "line/[translation hint:default icon alt text]": "Line",
      "line height/[translation hint:default icon alt text]": "Line Height",
      "linear gradient/[translation hint:default icon alt text]": "Linear Gradient",
      "link/[translation hint:default icon alt text]": "Link",
      "link check/[translation hint:default icon alt text]": "Link Check",
      "link facebook/[translation hint:default icon alt text]": "Link Facebook",
      "link globe/[translation hint:default icon alt text]": "Link Globe",
      "link nav/[translation hint:default icon alt text]": "Link Nav",
      "link off/[translation hint:default icon alt text]": "Link Off",
      "link out/[translation hint:default icon alt text]": "Link Out",
      "link page/[translation hint:default icon alt text]": "Link Page",
      "link user/[translation hint:default icon alt text]": "Link User",
      "linked in/[translation hint:default icon alt text]": "LinkedIn",
      "linux/[translation hint:default icon alt text]": "Linux",
      "location/[translation hint:default icon alt text]": "Location",
      "location based date/[translation hint:default icon alt text]": "Location Based Date",
      "location based event/[translation hint:default icon alt text]": "Location Based Event",
      "location contribution/[translation hint:default icon alt text]": "Location Contribution",
      "lock closed/[translation hint:default icon alt text]": "Lock Closed",
      "lock open/[translation hint:default icon alt text]": "Lock Open",
      "log out/[translation hint:default icon alt text]": "Log Out",
      "login/[translation hint:default icon alt text]": "Login",
      "looks/[translation hint:default icon alt text]": "Looks",
      "loupe view/[translation hint:default icon alt text]": "Loupe View",
      "mbox/[translation hint:default icon alt text]": "MBox",
      "magento commerce/[translation hint:default icon alt text]": "Magento Commerce",
      "magic wand/[translation hint:default icon alt text]": "Magic Wand",
      "magnify/[translation hint:default icon alt text]": "Magnify",
      "mailbox/[translation hint:default icon alt text]": "Mailbox",
      "map view/[translation hint:default icon alt text]": "Map View",
      "margin bottom/[translation hint:default icon alt text]": "Margin Bottom",
      "margin left/[translation hint:default icon alt text]": "Margin Left",
      "margin right/[translation hint:default icon alt text]": "Margin Right",
      "margin top/[translation hint:default icon alt text]": "Margin Top",
      "marketing activities/[translation hint:default icon alt text]": "Marketing Activities",
      "maximize/[translation hint:default icon alt text]": "Maximize",
      "measure/[translation hint:default icon alt text]": "Measure",
      "menu/[translation hint:default icon alt text]": "Menu",
      "merge/[translation hint:default icon alt text]": "Merge",
      "merge layers/[translation hint:default icon alt text]": "Merge Layers",
      "messenger/[translation hint:default icon alt text]": "Messenger",
      "minimize/[translation hint:default icon alt text]": "Minimize",
      "mobile services/[translation hint:default icon alt text]": "Mobile Services",
      "modern grid view/[translation hint:default icon alt text]": "Modern Grid View",
      "money/[translation hint:default icon alt text]": "Money",
      "moon/[translation hint:default icon alt text]": "Moon",
      "more/[translation hint:default icon alt text]": "More",
      "more circle/[translation hint:default icon alt text]": "More",
      "more small list/[translation hint:default icon alt text]": "More Small List",
      "more small list vert/[translation hint:default icon alt text]": "More Small List Vert",
      "more vertical/[translation hint:default icon alt text]": "More Vertical",
      "move/[translation hint:default icon alt text]": "Move",
      "move left right/[translation hint:default icon alt text]": "Move Left or Right",
      "move to/[translation hint:default icon alt text]": "Move To",
      "move up down/[translation hint:default icon alt text]": "Move Up or Down",
      "movie camera/[translation hint:default icon alt text]": "Movie Camera",
      "multiple/[translation hint:default icon alt text]": "Multiple",
      "multiple add/[translation hint:default icon alt text]": "Multiple Add",
      "multiple check/[translation hint:default icon alt text]": "Multiple Check",
      "multiple exclude/[translation hint:default icon alt text]": "Multiple Exclude",
      "muse/[translation hint:default icon alt text]": "Muse",
      "naming order/[translation hint:default icon alt text]": "Naming Order",
      "new item/[translation hint:default icon alt text]": "New Item",
      "news/[translation hint:default icon alt text]": "News",
      "news add/[translation hint:default icon alt text]": "News Add",
      "newsgator/[translation hint:default icon alt text]": "Newsgator",
      "nielsen/[translation hint:default icon alt text]": "Nielsen",
      "no edit/[translation hint:default icon alt text]": "No Edit",
      "note/[translation hint:default icon alt text]": "Note",
      "note add/[translation hint:default icon alt text]": "Note Add",
      "os/[translation hint:default icon alt text]": "OS",
      "offer/[translation hint:default icon alt text]": "Offer",
      "offer delete/[translation hint:default icon alt text]": "Delete Offer",
      "on air/[translation hint:default icon alt text]": "On Air",
      "one drive/[translation hint:default icon alt text]": "One Drive",
      "open in/[translation hint:default icon alt text]": "Open In",
      "open recent/[translation hint:default icon alt text]": "Open Recent",
      "opera/[translation hint:default icon alt text]": "Opera",
      "orbit/[translation hint:default icon alt text]": "Orbit",
      "organisations/[translation hint:default icon alt text]": "Organisations",
      "organize/[translation hint:default icon alt text]": "Organize",
      "outline path/[translation hint:default icon alt text]": "Outline Path",
      "pdfchecked out/[translation hint:default icon alt text]": "PDF Checked Out",
      "padding bottom/[translation hint:default icon alt text]": "Padding Bottom",
      "padding left/[translation hint:default icon alt text]": "Padding Left",
      "padding right/[translation hint:default icon alt text]": "Padding Right",
      "padding top/[translation hint:default icon alt text]": "Padding Top",
      "page break/[translation hint:default icon alt text]": "Page Break",
      "page exclude/[translation hint:default icon alt text]": "Page Exclude",
      "page gear/[translation hint:default icon alt text]": "Page Gear",
      "page rule/[translation hint:default icon alt text]": "Page Rule",
      "page share/[translation hint:default icon alt text]": "Page Share",
      "page tag/[translation hint:default icon alt text]": "Page Tag",
      "pages exclude/[translation hint:default icon alt text]": "Pages Exclude",
      "pan/[translation hint:default icon alt text]": "Pan",
      "panel/[translation hint:default icon alt text]": "Panel",
      "paste/[translation hint:default icon alt text]": "Paste",
      "paste html/[translation hint:default icon alt text]": "Paste HTML",
      "paste list/[translation hint:default icon alt text]": "Paste List",
      "paste text/[translation hint:default icon alt text]": "Paste Text",
      "pattern/[translation hint:default icon alt text]": "Pattern",
      "pause/[translation hint:default icon alt text]": "Pause",
      "pause circle/[translation hint:default icon alt text]": "Pause",
      "pawn/[translation hint:default icon alt text]": "Pawn",
      "pending/[translation hint:default icon alt text]": "Pending",
      "people group/[translation hint:default icon alt text]": "People Group",
      "personalization field/[translation hint:default icon alt text]": "Personalization Field",
      "perspective/[translation hint:default icon alt text]": "Perspective",
      "phone gap/[translation hint:default icon alt text]": "PhoneGap",
      "phone gap builder/[translation hint:default icon alt text]": "PhoneGap Builder",
      "photoshop/[translation hint:default icon alt text]": "Photoshop",
      "pin off/[translation hint:default icon alt text]": "Pin Off",
      "pin on/[translation hint:default icon alt text]": "Pin On",
      "pinterest/[translation hint:default icon alt text]": "Pinterest",
      "pivot/[translation hint:default icon alt text]": "Pivot",
      "platform data mapping/[translation hint:default icon alt text]": "Platform Data Mapping",
      "play/[translation hint:default icon alt text]": "Play",
      "play circle/[translation hint:default icon alt text]": "Play",
      "plug/[translation hint:default icon alt text]": "Plug",
      "polygon/[translation hint:default icon alt text]": "Polygon",
      "polygon select/[translation hint:default icon alt text]": "Polygon Select",
      "pop in/[translation hint:default icon alt text]": "Pop In",
      "portrait/[translation hint:default icon alt text]": "Portrait",
      "premiere pro/[translation hint:default icon alt text]": "Premiere Pro",
      "preset/[translation hint:default icon alt text]": "Preset",
      "preview/[translation hint:default icon alt text]": "Preview",
      "print/[translation hint:default icon alt text]": "Print",
      "print preview/[translation hint:default icon alt text]": "Print Preview",
      "project/[translation hint:default icon alt text]": "Project",
      "project add/[translation hint:default icon alt text]": "Project Add",
      "project edit/[translation hint:default icon alt text]": "Project Edit",
      "project name edit/[translation hint:default icon alt text]": "Project Name Edit",
      "promote/[translation hint:default icon alt text]": "Promote",
      "properties/[translation hint:default icon alt text]": "Properties",
      "properties copy/[translation hint:default icon alt text]": "Properties Copy",
      "public/[translation hint:default icon alt text]": "Public",
      "publish check/[translation hint:default icon alt text]": "Publish Check",
      "publish pending/[translation hint:default icon alt text]": "Publish Pending",
      "publish reject/[translation hint:default icon alt text]": "Publish Reject",
      "publish remove/[translation hint:default icon alt text]": "Publish Remove",
      "publish schedule/[translation hint:default icon alt text]": "Publish Schedule",
      "push notification/[translation hint:default icon alt text]": "Push Notification",
      "question/[translation hint:default icon alt text]": "Question",
      "quick select/[translation hint:default icon alt text]": "Quick Select",
      "rss/[translation hint:default icon alt text]": "RSS",
      "radial gradient/[translation hint:default icon alt text]": "Radial Gradient",
      "rail/[translation hint:default icon alt text]": "Rail",
      "rail bottom/[translation hint:default icon alt text]": "Rail Bottom",
      "rail left/[translation hint:default icon alt text]": "Rail Left",
      "rail right/[translation hint:default icon alt text]": "Rail Right",
      "rail right close/[translation hint:default icon alt text]": "Close Rail Right",
      "rail right open/[translation hint:default icon alt text]": "Open Rail Right",
      "rail top/[translation hint:default icon alt text]": "Rail Top",
      "range mask/[translation hint:default icon alt text]": "Range Mask",
      "rect select/[translation hint:default icon alt text]": "Rect Select",
      "rectangle/[translation hint:default icon alt text]": "Rectangle",
      "redo/[translation hint:default icon alt text]": "Redo",
      "refresh/[translation hint:default icon alt text]": "Refresh",
      "region select/[translation hint:default icon alt text]": "Region Select",
      "relevance/[translation hint:default icon alt text]": "Relevance",
      "remove/[translation hint:default icon alt text]": "Remove",
      "remove circle/[translation hint:default icon alt text]": "Remove",
      "rename/[translation hint:default icon alt text]": "Rename",
      "reorder/[translation hint:default icon alt text]": "Reorder",
      "replay/[translation hint:default icon alt text]": "Replay",
      "replies/[translation hint:default icon alt text]": "Replies",
      "reply/[translation hint:default icon alt text]": "Reply",
      "reply all/[translation hint:default icon alt text]": "Reply All",
      "report/[translation hint:default icon alt text]": "Report",
      "report add/[translation hint:default icon alt text]": "Report Add",
      "resize/[translation hint:default icon alt text]": "Resize",
      "retweet/[translation hint:default icon alt text]": "Retweet",
      "reuse/[translation hint:default icon alt text]": "Reuse",
      "revenue/[translation hint:default icon alt text]": "Revenue",
      "revert/[translation hint:default icon alt text]": "Revert",
      "rewind/[translation hint:default icon alt text]": "Rewind",
      "rewind circle/[translation hint:default icon alt text]": "Rewind",
      "ribbon/[translation hint:default icon alt text]": "Ribbon",
      "rotate ccw/[translation hint:default icon alt text]": "Rotate CCW",
      "rotate ccwbold/[translation hint:default icon alt text]": "Rotate CCW",
      "rotate cw/[translation hint:default icon alt text]": "Rotate CW",
      "rotate cwbold/[translation hint:default icon alt text]": "Rotate CW",
      "rotate left/[translation hint:default icon alt text]": "Rotate Left",
      "rotate right/[translation hint:default icon alt text]": "Rotate Right",
      "sms/[translation hint:default icon alt text]": "SMS",
      "smskey/[translation hint:default icon alt text]": "SMS Key",
      "smslightning/[translation hint:default icon alt text]": "SMS Lightning",
      "smsrefresh/[translation hint:default icon alt text]": "SMS Refresh",
      "sqlquery/[translation hint:default icon alt text]": "SQL Query",
      "safari/[translation hint:default icon alt text]": "Safari",
      "sampler/[translation hint:default icon alt text]": "Sampler",
      "save as floppy/[translation hint:default icon alt text]": "Save As Floppy",
      "save floppy/[translation hint:default icon alt text]": "Save Floppy",
      "save to/[translation hint:default icon alt text]": "Save To",
      "scribble/[translation hint:default icon alt text]": "Scribble",
      "search/[translation hint:default icon alt text]": "Search",
      "seat/[translation hint:default icon alt text]": "Seat",
      "seat add/[translation hint:default icon alt text]": "Seat Add",
      "segments/[translation hint:default icon alt text]": "Segments",
      "select/[translation hint:default icon alt text]": "Select",
      "select add/[translation hint:default icon alt text]": "Select Add",
      "select box/[translation hint:default icon alt text]": "Select Box",
      "select box all/[translation hint:default icon alt text]": "Select Box All",
      "select circular/[translation hint:default icon alt text]": "Select Circular",
      "select container/[translation hint:default icon alt text]": "Select Container",
      "select gear/[translation hint:default icon alt text]": "Select Gear",
      "select intersect/[translation hint:default icon alt text]": "Select Intersect",
      "select substract/[translation hint:default icon alt text]": "Select Substract",
      "selection/[translation hint:default icon alt text]": "Selection",
      "selection checked/[translation hint:default icon alt text]": "Selection Checked",
      "selection move/[translation hint:default icon alt text]": "Selection Move",
      "send/[translation hint:default icon alt text]": "Send",
      "send for signature/[translation hint:default icon alt text]": "Send For Signature",
      "sentiment negative/[translation hint:default icon alt text]": "Sentiment Negative",
      "sentiment neutral/[translation hint:default icon alt text]": "Sentiment Neutral",
      "sentiment positive/[translation hint:default icon alt text]": "Sentiment Positive",
      "separator/[translation hint:default icon alt text]": "Separator",
      "servers/[translation hint:default icon alt text]": "Servers",
      "settings/[translation hint:default icon alt text]": "Settings",
      "shapes/[translation hint:default icon alt text]": "Shapes",
      "share/[translation hint:default icon alt text]": "Share",
      "share android/[translation hint:default icon alt text]": "Share",
      "share check/[translation hint:default icon alt text]": "Share Check",
      "share windows/[translation hint:default icon alt text]": "Share",
      "sharpen/[translation hint:default icon alt text]": "Sharpen",
      "shield/[translation hint:default icon alt text]": "Shield",
      "shopping cart/[translation hint:default icon alt text]": "Shopping Cart",
      "show all layers/[translation hint:default icon alt text]": "Show All Layers",
      "show menu/[translation hint:default icon alt text]": "Show Menu",
      "show one layer/[translation hint:default icon alt text]": "Show One Layer",
      "shuffle/[translation hint:default icon alt text]": "Shuffle",
      "sina weibo/[translation hint:default icon alt text]": "Sina Weibo",
      "slice/[translation hint:default icon alt text]": "Slice",
      "slow/[translation hint:default icon alt text]": "Slow",
      "small caps/[translation hint:default icon alt text]": "Small Caps",
      "snapshot/[translation hint:default icon alt text]": "Snapshot",
      "social network/[translation hint:default icon alt text]": "Social Network",
      "sort order down/[translation hint:default icon alt text]": "Sort Order Down",
      "sort order up/[translation hint:default icon alt text]": "Sort Order Up",
      "spam/[translation hint:default icon alt text]": "Spam",
      "spellcheck/[translation hint:default icon alt text]": "Spellcheck",
      "spin/[translation hint:default icon alt text]": "Spin",
      "split view/[translation hint:default icon alt text]": "Split View",
      "spot heal/[translation hint:default icon alt text]": "Spot Heal",
      "stage/[translation hint:default icon alt text]": "Stage",
      "stamp/[translation hint:default icon alt text]": "Stamp",
      "starburst/[translation hint:default icon alt text]": "Starburst",
      "step backward/[translation hint:default icon alt text]": "Step Backward",
      "step backward circle/[translation hint:default icon alt text]": "Step Backward",
      "step forward/[translation hint:default icon alt text]": "Step Forward",
      "step forward circle/[translation hint:default icon alt text]": "Step Forward",
      "stock/[translation hint:default icon alt text]": "Stock",
      "stop/[translation hint:default icon alt text]": "Stop",
      "stop circle/[translation hint:default icon alt text]": "Stop",
      "stopwatch/[translation hint:default icon alt text]": "Stopwatch",
      "straighten/[translation hint:default icon alt text]": "Straighten",
      "stroke width/[translation hint:default icon alt text]": "Stroke Width",
      "subscribe/[translation hint:default icon alt text]": "Subscribe",
      "substract back path/[translation hint:default icon alt text]": "Substract Back Path",
      "substract from selection/[translation hint:default icon alt text]": "Substract From Selection",
      "subtract front path/[translation hint:default icon alt text]": "Subtract Front Path",
      "success metric/[translation hint:default icon alt text]": "Success Metric",
      "summarize/[translation hint:default icon alt text]": "Summarize",
      "survey/[translation hint:default icon alt text]": "Survey",
      "switch/[translation hint:default icon alt text]": "Switch",
      "sync/[translation hint:default icon alt text]": "Sync",
      "sync remove/[translation hint:default icon alt text]": "Sync Remove",
      "table/[translation hint:default icon alt text]": "Table",
      "table add/[translation hint:default icon alt text]": "Table Add",
      "table and chart/[translation hint:default icon alt text]": "Table And Chart",
      "table column add left/[translation hint:default icon alt text]": "Table Column Add Left",
      "table column add right/[translation hint:default icon alt text]": "Table Column Add Right",
      "table column merge/[translation hint:default icon alt text]": "Table Column Merge",
      "table column remove center/[translation hint:default icon alt text]": "Table Column Remove Center",
      "table column split/[translation hint:default icon alt text]": "Table Column Split",
      "table edit/[translation hint:default icon alt text]": "Table Edit",
      "table histogram/[translation hint:default icon alt text]": "Table Histogram",
      "table merge cells/[translation hint:default icon alt text]": "Table Merge Cells",
      "table row add bottom/[translation hint:default icon alt text]": "Table Row Add Bottom",
      "table row add top/[translation hint:default icon alt text]": "Table Row Add Top",
      "table row merge/[translation hint:default icon alt text]": "Table Row Merge",
      "table row remove center/[translation hint:default icon alt text]": "Table Row Remove Center",
      "table row split/[translation hint:default icon alt text]": "Table Row Split",
      "table select column/[translation hint:default icon alt text]": "Table Select Column",
      "table select row/[translation hint:default icon alt text]": "Table Select Row",
      "tableau/[translation hint:default icon alt text]": "Tableau",
      "tag bold/[translation hint:default icon alt text]": "Tag Bold",
      "tag italic/[translation hint:default icon alt text]": "Tag Italic",
      "tag underline/[translation hint:default icon alt text]": "Tag Underline",
      "target/[translation hint:default icon alt text]": "Target",
      "targeted/[translation hint:default icon alt text]": "Targeted",
      "task list/[translation hint:default icon alt text]": "Task List",
      "teapot/[translation hint:default icon alt text]": "Teapot",
      "temperature/[translation hint:default icon alt text]": "Temperature",
      "test ab/[translation hint:default icon alt text]": "Test AB",
      "test abedit/[translation hint:default icon alt text]": "Test AB Edit",
      "test abgear/[translation hint:default icon alt text]": "Test AB Gear",
      "test abremove/[translation hint:default icon alt text]": "Test AB Remove",
      "test profile/[translation hint:default icon alt text]": "Test Profile",
      "text/[translation hint:default icon alt text]": "Text",
      "text add/[translation hint:default icon alt text]": "Text Add",
      "text align center/[translation hint:default icon alt text]": "Text Align Center",
      "text align justify/[translation hint:default icon alt text]": "Text Align Justify",
      "text align left/[translation hint:default icon alt text]": "Text Align Left",
      "text align right/[translation hint:default icon alt text]": "Text Align Right",
      "text baseline shift/[translation hint:default icon alt text]": "Text Baseline Shift",
      "text bold/[translation hint:default icon alt text]": "Text Bold",
      "text bulleted/[translation hint:default icon alt text]": "Text Bulleted",
      "text bulleted attach/[translation hint:default icon alt text]": "Text Bulleted Attach",
      "text bulleted hierarchy/[translation hint:default icon alt text]": "Text Bulleted Hierarchy",
      "text bulleted hierarchy exclude/[translation hint:default icon alt text]": "Text Bulleted Hierarchy Exclude",
      "text decrease/[translation hint:default icon alt text]": "Text Decrease",
      "text edit/[translation hint:default icon alt text]": "Text Edit",
      "text exclude/[translation hint:default icon alt text]": "Text Exclude",
      "text increase/[translation hint:default icon alt text]": "Text Increase",
      "text indent decrease/[translation hint:default icon alt text]": "Text Indent Decrease",
      "text indent increase/[translation hint:default icon alt text]": "Text Indent Increase",
      "text italic/[translation hint:default icon alt text]": "Text Italic",
      "text kerning/[translation hint:default icon alt text]": "Text Kerning",
      "text lettered lower case/[translation hint:default icon alt text]": "Text Lettered Lower Case",
      "text lettered upper case/[translation hint:default icon alt text]": "Text Lettered Upper Case",
      "text numbered/[translation hint:default icon alt text]": "Text Numbered",
      "text paragraph/[translation hint:default icon alt text]": "Text Paragraph",
      "text roman lowercase/[translation hint:default icon alt text]": "Text Roman Lowercase",
      "text roman uppercase/[translation hint:default icon alt text]": "Text Roman Uppercase",
      "text size/[translation hint:default icon alt text]": "Text Size",
      "text size add/[translation hint:default icon alt text]": "Text Size Add",
      "text space after/[translation hint:default icon alt text]": "Text Space After",
      "text space before/[translation hint:default icon alt text]": "Text Space Before",
      "text strikethrough/[translation hint:default icon alt text]": "Text Strikethrough",
      "text stroke/[translation hint:default icon alt text]": "Text Stroke",
      "text style/[translation hint:default icon alt text]": "Text Style",
      "text subscript/[translation hint:default icon alt text]": "Text Subscript",
      "text superscript/[translation hint:default icon alt text]": "Text Superscript",
      "text tracking/[translation hint:default icon alt text]": "Text Tracking",
      "text underline/[translation hint:default icon alt text]": "Text Underline",
      "thumb down/[translation hint:default icon alt text]": "Thumb Down",
      "thumb up/[translation hint:default icon alt text]": "Thumb Up",
      "tips/[translation hint:default icon alt text]": "Tips",
      "transfer to platform/[translation hint:default icon alt text]": "Transfer To Platform",
      "transparency/[translation hint:default icon alt text]": "Transparency",
      "trap/[translation hint:default icon alt text]": "Trap",
      "tree collapse/[translation hint:default icon alt text]": "Tree Collapse",
      "tree collapse all/[translation hint:default icon alt text]": "Tree Collapse All",
      "tree expand/[translation hint:default icon alt text]": "Tree Expand",
      "tree expand all/[translation hint:default icon alt text]": "Tree Expand All",
      "trend inspect/[translation hint:default icon alt text]": "Trend Inspect",
      "trim path/[translation hint:default icon alt text]": "Trim Path",
      "trophy/[translation hint:default icon alt text]": "Trophy",
      "tumblr/[translation hint:default icon alt text]": "Tumblr",
      "twitter/[translation hint:default icon alt text]": "Twitter",
      "type/[translation hint:default icon alt text]": "Type",
      "usa/[translation hint:default icon alt text]": "USA",
      "underline/[translation hint:default icon alt text]": "Underline",
      "undo/[translation hint:default icon alt text]": "Undo",
      "ungroup/[translation hint:default icon alt text]": "Ungroup",
      "unlink/[translation hint:default icon alt text]": "Unlink",
      "unmerge/[translation hint:default icon alt text]": "Unmerge",
      "upload to cloud/[translation hint:default icon alt text]": "Upload To Cloud",
      "user/[translation hint:default icon alt text]": "User",
      "user activity/[translation hint:default icon alt text]": "User Activity",
      "user add/[translation hint:default icon alt text]": "User Add",
      "user admin/[translation hint:default icon alt text]": "User Admin",
      "user arrow/[translation hint:default icon alt text]": "User Arrow",
      "user checked out/[translation hint:default icon alt text]": "User Checked Out",
      "user edit/[translation hint:default icon alt text]": "User Edit",
      "user exclude/[translation hint:default icon alt text]": "User Exclude",
      "user group/[translation hint:default icon alt text]": "User Group",
      "user lock/[translation hint:default icon alt text]": "User Lock",
      "user share/[translation hint:default icon alt text]": "User Share",
      "users add/[translation hint:default icon alt text]": "Users Add",
      "users exclude/[translation hint:default icon alt text]": "Users Exclude",
      "users lock/[translation hint:default icon alt text]": "Users Lock",
      "users share/[translation hint:default icon alt text]": "Users Share",
      "vk/[translation hint:default icon alt text]": "VK",
      "variable/[translation hint:default icon alt text]": "Variable",
      "vector draw/[translation hint:default icon alt text]": "Vector Draw",
      "video checked out/[translation hint:default icon alt text]": "Video Checked Out",
      "video/[translation hint:default icon alt text]": "Video",
      "view all tags/[translation hint:default icon alt text]": "View All Tags",
      "view bi week/[translation hint:default icon alt text]": "View Bi-Week",
      "view card/[translation hint:default icon alt text]": "View Card",
      "view column/[translation hint:default icon alt text]": "View Column",
      "view day/[translation hint:default icon alt text]": "View Day",
      "view detail/[translation hint:default icon alt text]": "View Detail",
      "view grid/[translation hint:default icon alt text]": "View Grid",
      "view list/[translation hint:default icon alt text]": "View List",
      "view row/[translation hint:default icon alt text]": "View Row",
      "view single/[translation hint:default icon alt text]": "View Single",
      "view stack/[translation hint:default icon alt text]": "View Stack",
      "view week/[translation hint:default icon alt text]": "View Week",
      "viewed mark as/[translation hint:default icon alt text]": "Viewed Mark As",
      "vignette/[translation hint:default icon alt text]": "Vignette",
      "visibility/[translation hint:default icon alt text]": "Visibility",
      "visibility off/[translation hint:default icon alt text]": "Visibility Off",
      "visit/[translation hint:default icon alt text]": "Visit",
      "visit share/[translation hint:default icon alt text]": "Visit Share",
      "voice over/[translation hint:default icon alt text]": "Voice Over",
      "volume mute/[translation hint:default icon alt text]": "Volume Mute",
      "volume one/[translation hint:default icon alt text]": "Volume One",
      "volume three/[translation hint:default icon alt text]": "Volume Three",
      "volume two/[translation hint:default icon alt text]": "Volume Two",
      "watch/[translation hint:default icon alt text]": "Watch",
      "web page/[translation hint:default icon alt text]": "Web Page",
      "web pages/[translation hint:default icon alt text]": "Web Pages",
      "whats app/[translation hint:default icon alt text]": "Whats App",
      "windows 7/[translation hint:default icon alt text]": "Windows 7",
      "windows 8/[translation hint:default icon alt text]": "Windows 8",
      "wordpress/[translation hint:default icon alt text]": "Wordpress",
      "workflow/[translation hint:default icon alt text]": "Workflow",
      "workflow add/[translation hint:default icon alt text]": "Workflow Add",
      "wrench/[translation hint:default icon alt text]": "Wrench",
      "xd/[translation hint:default icon alt text]": "XD",
      "you tube/[translation hint:default icon alt text]": "YouTube",
      "zoom in/[translation hint:default icon alt text]": "Zoom In",
      "zoom out/[translation hint:default icon alt text]": "Zoom Out",
      "adobe experience platform/[translation hint:default icon alt text]": "Adobe Experience Platform",
      "calendar check/[translation hint:default icon alt text]": "Calendar Check",
      "emotion admiration/[translation hint:default icon alt text]": "Emotion: Admiration",
      "emotion anger/[translation hint:default icon alt text]": "Emotion: Anger",
      "emotion anticipation/[translation hint:default icon alt text]": "Emotion: Anticipation",
      "emotion disgust/[translation hint:default icon alt text]": "Emotion: Disgust",
      "emotion fear/[translation hint:default icon alt text]": "Emotion: Fear",
      "emotion joy/[translation hint:default icon alt text]": "Emotion: Joy",
      "emotion sadness/[translation hint:default icon alt text]": "Emotion: Sadness",
      "emotion surprise/[translation hint:default icon alt text]": "Emotion: Surprise",
      "facebook circle/[translation hint:default icon alt text]": "Facebook",
      "google plus circle/[translation hint:default icon alt text]": "Google Plus",
      "instagram circle/[translation hint:default icon alt text]": "Instagram",
      "linked in circle/[translation hint:default icon alt text]": "LinkedIn",
      "mc marketo engage/[translation hint:default icon alt text]": "Marketo Engage",
      "project camera/[translation hint:default icon alt text]": "Project Camera",
      "project play/[translation hint:default icon alt text]": "Project Play",
      "project refresh/[translation hint:default icon alt text]": "Project Refresh",
      "sina weibo circle/[translation hint:default icon alt text]": "Sina Weibo",
      "table cell merge/[translation hint:default icon alt text]": "Table Cell Merge",
      "target check/[translation hint:default icon alt text]": "Target Check",
      "twitter circle/[translation hint:default icon alt text]": "Twitter",
      "user circle/[translation hint:default icon alt text]": "User",
      "user group circle/[translation hint:default icon alt text]": "User Group",
      "windows/[translation hint:default icon alt text]": "Windows",
      "you tube circle/[translation hint:default icon alt text]": "YouTube"
    }
  };

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons.extend(strings, {
    'coral-component-icon': translations
  }); // Expose component on the Coral namespace

  commons._define('coral-icon', Icon);

  /**
   Enumeration for {@link Button}, {@link AnchorButton} icon sizes.

   @typedef {Object} ButtonIconSizeEnum

   @property {String} EXTRA_EXTRA_SMALL
   Extra extra small size icon, typically 9px size.
   @property {String} EXTRA_SMALL
   Extra small size icon, typically 12px size.
   @property {String} SMALL
   Small size icon, typically 18px size. This is the default size.
   @property {String} MEDIUM
   Medium size icon, typically 24px size.
   */

  var iconSize = {};
  var excludedIconSizes = [Icon.size.LARGE, Icon.size.EXTRA_LARGE, Icon.size.EXTRA_EXTRA_LARGE];

  for (var key in Icon.size) {
    // Populate button icon sizes by excluding the largest icon sizes
    if (excludedIconSizes.indexOf(Icon.size[key]) === -1) {
      iconSize[key] = Icon.size[key];
    }
  }
  /**
   Enumeration for {@link Button}, {@link AnchorButton} variants.

   @typedef {Object} ButtonVariantEnum

   @property {String} CTA
   A button that is meant to grab the user's attention.
   @property {String} PRIMARY
   A button that is meant to grab the user's attention.
   @property {String} QUIET
   A quiet button that indicates that the button's action is the primary action.
   @property {String} SECONDARY
   A button that indicates that the button's action is the secondary action.
   @property {String} QUIET_SECONDARY
   A quiet secondary button.
   @property {String} ACTION
   An action button.
   @property {String} QUIET_ACTION
   A quiet action button.
   @property {String} MINIMAL
   A quiet minimalistic button.
   @property {String} WARNING
   A button that indicates that the button's action is dangerous.
   @property {String} QUIET_WARNING
   A quiet warning button,
   @property {String} OVER_BACKGROUND
   A button to be placed on top of colored background.
   @property {String} DEFAULT
   The default button look and feel.
   */


  var variant$1 = {
    CTA: 'cta',
    PRIMARY: 'primary',
    SECONDARY: 'secondary',
    QUIET: 'quiet',
    MINIMAL: 'minimal',
    WARNING: 'warning',
    ACTION: 'action',
    QUIET_ACTION: 'quietaction',
    QUIET_SECONDARY: 'quietsecondary',
    QUIET_WARNING: 'quietwarning',
    OVER_BACKGROUND: 'overbackground',
    DEFAULT: 'default',
    // Private to be used for custom Button classes like field buttons
    _CUSTOM: '_custom'
  }; // the button's base classname

  var CLASSNAME$2 = '_coral-Button';
  var ACTION_CLASSNAME = '_coral-ActionButton';
  var ALL_VARIANT_CLASSES$1 = ["".concat(CLASSNAME$2, "--cta"), "".concat(CLASSNAME$2, "--primary"), "".concat(CLASSNAME$2, "--secondary"), "".concat(CLASSNAME$2, "--warning"), "".concat(CLASSNAME$2, "--quiet"), "".concat(ACTION_CLASSNAME, "--quiet"), "".concat(CLASSNAME$2, "--overBackground")];
  var VARIANT_MAP = {
    cta: [CLASSNAME$2, ALL_VARIANT_CLASSES$1[0]],
    primary: [CLASSNAME$2, ALL_VARIANT_CLASSES$1[0]],
    secondary: [CLASSNAME$2, ALL_VARIANT_CLASSES$1[2]],
    warning: [CLASSNAME$2, ALL_VARIANT_CLASSES$1[3]],
    quiet: [CLASSNAME$2, ALL_VARIANT_CLASSES$1[1], ALL_VARIANT_CLASSES$1[4]],
    minimal: [CLASSNAME$2, ALL_VARIANT_CLASSES$1[2], ALL_VARIANT_CLASSES$1[4]],
    default: [CLASSNAME$2, ALL_VARIANT_CLASSES$1[1]],
    action: [ACTION_CLASSNAME],
    quietaction: [ACTION_CLASSNAME, ALL_VARIANT_CLASSES$1[5]],
    quietsecondary: [CLASSNAME$2, ALL_VARIANT_CLASSES$1[2], ALL_VARIANT_CLASSES$1[4]],
    quietwarning: [CLASSNAME$2, ALL_VARIANT_CLASSES$1[3], ALL_VARIANT_CLASSES$1[4]],
    overbackground: [CLASSNAME$2, ALL_VARIANT_CLASSES$1[6]]
  };
  /**
   Enumeration for {@link BaseButton} sizes.

   @typedef {Object} ButtonSizeEnum

   @property {String} MEDIUM
   A medium button is the default, normal sized button.
   @property {String} LARGE
   Not supported. Falls back to MEDIUM.
   */

  var size$1 = {
    MEDIUM: 'M',
    LARGE: 'L'
  };
  /**
   Enumeration for {@link BaseButton} icon position options.

   @typedef {Object} ButtonIconPositionEnum

   @property {String} RIGHT
   Position should be right of the button label.
   @property {String} LEFT
   Position should be left of the button label.
   */

  var iconPosition = {
    RIGHT: 'right',
    LEFT: 'left'
  };
  /**
   @base BaseButton
   @classdesc The base element for Button components
   */

  var BaseButton = function BaseButton(superClass) {
    return /*#__PURE__*/function (_BaseLabellable) {
      _inherits(_class, _BaseLabellable);

      var _super = _createSuper(_class);

      /** @ignore */
      function _class() {
        var _thisSuper, _this;

        _classCallCheck(this, _class);

        _this = _super.call(this); // Templates

        _this._elements = {
          // Create or fetch the label element
          label: _this.querySelector(_this._contentZoneTagName) || document.createElement(_this._contentZoneTagName),
          icon: _this.querySelector('coral-icon')
        }; // Events

        _this._events = {
          mousedown: '_onMouseDown',
          click: '_onClick'
        };

        _get((_thisSuper = _assertThisInitialized(_this), _getPrototypeOf(_class.prototype)), "_observeLabel", _thisSuper).call(_thisSuper);

        return _this;
      }
      /**
       The label of the button.
       @type {HTMLElement}
       @contentzone
       */


      _createClass(_class, [{
        key: "_onClick",
        value: function _onClick(event) {
          if (!this.disabled) {
            this._trackEvent('click', this.getAttribute('is'), event);
          }
        }
        /** @ignore */

      }, {
        key: "_updateIcon",
        value: function _updateIcon(value) {
          if (!this._updatedIcon && this._elements.icon) {
            return;
          }

          this._updatedIcon = true;
          var iconSizeValue = this.iconSize;
          var iconAutoAriaLabelValue = this.iconAutoAriaLabel;

          var iconElement = this._getIconElement();

          iconElement.icon = value; // Update size as well

          iconElement.size = iconSizeValue; // Update autoAriaLabel as well

          iconElement.autoAriaLabel = iconAutoAriaLabelValue; // removes the icon element from the DOM.

          if (this.icon === '') {
            iconElement.remove();
          } // add or adjust the icon. Add it back since it was blown away by textContent
          else if (!iconElement.parentNode || this._iconPosition) {
              if (this.contains(this.label)) {
                // insertBefore with <code>null</code> appends
                this.insertBefore(iconElement, this.iconPosition === iconPosition.LEFT ? this.label : this.label.nextElementSibling);
              }
            }

          _get(_getPrototypeOf(_class.prototype), "_toggleIconAriaHidden", this).call(this);
        }
        /** @ignore */

      }, {
        key: "_getIconElement",
        value: function _getIconElement() {
          if (!this._elements.icon) {
            this._elements.icon = new Icon();
            this._elements.icon.size = this.iconSize;
          }

          return this._elements.icon;
        }
        /**
         Forces button to receive focus on mousedown
         @param {MouseEvent} event mousedown event
         @ignore
         */

      }, {
        key: "_onMouseDown",
        value: function _onMouseDown(event) {
          var target = event.matchedTarget; // Wait a frame or button won't receive focus in Safari.

          window.requestAnimationFrame(function () {
            if (target !== document.activeElement) {
              target.focus();
            }
          });
        }
      }, {
        key: "_updateLabel",
        value: function _updateLabel(label) {
          label = label || this._elements.label;
          label.classList.remove("".concat(CLASSNAME$2, "-label"), "".concat(ACTION_CLASSNAME, "-label"));

          if (this._variant !== variant$1._CUSTOM) {
            if (this._variant === variant$1.ACTION || this._variant === variant$1.QUIET_ACTION) {
              label.classList.add("".concat(ACTION_CLASSNAME, "-label"));
            } else {
              label.classList.add("".concat(CLASSNAME$2, "-label"));
            }
          }
        }
        /** @private */

      }, {
        key: "render",

        /** @ignore */
        value: function render() {
          _get(_getPrototypeOf(_class.prototype), "render", this).call(this); // Default reflected attributes


          if (!this._variant) {
            this.variant = variant$1.DEFAULT;
          }

          if (!this._size) {
            this.size = size$1.MEDIUM;
          } // Create a fragment


          var fragment = document.createDocumentFragment();
          var label = this._elements.label;
          var contentZoneProvided = label.parentNode; // Remove it so we can process children

          if (contentZoneProvided) {
            this.removeChild(label);
          }

          var iconAdded = false; // Process remaining elements as necessary

          while (this.firstChild) {
            var child = this.firstChild;

            if (child.nodeName === 'CORAL-ICON') {
              // Don't add duplicated icons
              if (iconAdded) {
                this.removeChild(child);
              } else {
                // Conserve existing icon element to content
                this._elements.icon = child;
                fragment.appendChild(child);
                iconAdded = true;
              }
            } // Avoid content zone to be voracious
            else if (contentZoneProvided) {
                fragment.appendChild(child);
              } else {
                // Move anything else into the label
                label.appendChild(child);
              }
          } // Add the frag to the component


          this.appendChild(fragment); // Assign the content zones, moving them into place in the process

          this.label = label; // Make sure the icon is well positioned

          this._updatedIcon = true;

          this._updateIcon(this.icon);
        }
        /**
         Triggered when {@link BaseButton#selected} changed.
          @typedef {CustomEvent} coral-button:_selectedchanged
          @private
         */

        /**
         Triggered when {@link BaseButton#value} changed.
          @typedef {CustomEvent} coral-button:_valuechanged
          @private
         */

      }, {
        key: "label",
        get: function get() {
          return this._getContentZone(this._elements.label);
        },
        set: function set(value) {
          this._setContentZone('label', value, {
            handle: 'label',
            tagName: this._contentZoneTagName,
            insert: function insert(label) {
              // Update label styles
              this._updateLabel(label); // Ensure there's no extra space left for icon only buttons


              if (label.innerHTML.trim() === '') {
                label.textContent = '';
              }

              if (this.iconPosition === iconPosition.LEFT) {
                this.appendChild(label);
              } else {
                this.insertBefore(label, this.firstChild);
              }
            }
          });
        }
        /**
         Position of the icon relative to the label. If no <code>iconPosition</code> is provided, it will be set on the
         left side by default.
         See {@link ButtonIconPositionEnum}.
          @type {String}
         @default ButtonIconPositionEnum.LEFT
         @htmlattribute iconposition
         @htmlattributereflected
         */

      }, {
        key: "iconPosition",
        get: function get() {
          return this._iconPosition || iconPosition.LEFT;
        },
        set: function set(value) {
          value = transform.string(value).toLowerCase();
          this._iconPosition = validate.enumeration(iconPosition)(value) && value || iconPosition.LEFT;

          this._reflectAttribute('iconposition', this._iconPosition);

          this._updateIcon(this.icon);
        }
        /**
         Specifies the icon name used inside the button. See {@link Icon} for valid icon names.
          @type {String}
         @default ""
         @htmlattribute icon
         */

      }, {
        key: "icon",
        get: function get() {
          if (this._elements.icon) {
            return this._elements.icon.getAttribute('icon') || '';
          }

          return this._icon || '';
        },
        set: function set(value) {
          this._icon = transform.string(value);

          this._updateIcon(value);
        }
        /**
         Size of the icon. It accepts both lower and upper case sizes. See {@link ButtonIconSizeEnum}.
          @type {String}
         @default ButtonIconSizeEnum.SMALL
         @htmlattribute iconsize
         */

      }, {
        key: "iconSize",
        get: function get() {
          if (this._elements.icon) {
            return this._elements.icon.getAttribute('size') || Icon.size.SMALL;
          }

          return this._iconSize || Icon.size.SMALL;
        },
        set: function set(value) {
          value = transform.string(value).toUpperCase();
          this._iconSize = validate.enumeration(Icon.size)(value) && value || Icon.size.SMALL;

          if (this._updatedIcon) {
            this._getIconElement().setAttribute('size', value);
          }
        }
        /**
         Whether aria-label is set automatically. See {@link IconAutoAriaLabelEnum}.
          @type {String}
         @default IconAutoAriaLabelEnum.OFF
         @htmlattribute autoarialabel
         */

      }, {
        key: "iconAutoAriaLabel",
        get: function get() {
          if (this._elements.icon) {
            return this._elements.icon.getAttribute('autoarialabel') || Icon.autoAriaLabel.OFF;
          }

          return this._iconAutoAriaLabel || Icon.autoAriaLabel.OFF;
        },
        set: function set(value) {
          value = transform.string(value).toLowerCase();
          this._iconAutoAriaLabel = validate.enumeration(Icon.autoAriaLabel)(value) && value || Icon.autoAriaLabel.OFF;

          if (this._updatedIcon) {
            this._getIconElement().setAttribute('autoarialabel', value);
          }
        }
        /**
         The size of the button. It accepts both lower and upper case sizes. See {@link ButtonSizeEnum}.
         Currently only "MEDIUM" is supported.
          @type {String}
         @default ButtonSizeEnum.MEDIUM
         @htmlattribute size
         @htmlattributereflected
         */

      }, {
        key: "size",
        get: function get() {
          return this._size || size$1.MEDIUM;
        },
        set: function set(value) {
          value = transform.string(value).toUpperCase();
          this._size = validate.enumeration(size$1)(value) && value || size$1.MEDIUM;

          this._reflectAttribute('size', this._size);
        }
        /**
         Whether the button is selected.
          @type {Boolean}
         @default false
         @htmlattribute selected
         @htmlattributereflected
         */

      }, {
        key: "selected",
        get: function get() {
          return this._selected || false;
        },
        set: function set(value) {
          this._selected = transform.booleanAttr(value);

          this._reflectAttribute('selected', this._selected);

          this.classList.toggle('is-selected', this._selected);
          this.trigger('coral-button:_selectedchanged');
        } // We just reflect it but we also trigger an event to be used by button group

        /** @ignore */

      }, {
        key: "value",
        get: function get() {
          return this.getAttribute('value');
        },
        set: function set(value) {
          this._reflectAttribute('value', value);

          this.trigger('coral-button:_valuechanged');
        }
        /**
         Expands the button to the full width of the parent.
          @type {Boolean}
         @default false
         @htmlattribute block
         @htmlattributereflected
         */

      }, {
        key: "block",
        get: function get() {
          return this._block || false;
        },
        set: function set(value) {
          this._block = transform.booleanAttr(value);

          this._reflectAttribute('block', this._block);

          this.classList.toggle("".concat(CLASSNAME$2, "--block"), this._block);
        }
        /**
         The button's variant. See {@link ButtonVariantEnum}.
          @type {String}
         @default ButtonVariantEnum.DEFAULT
         @htmlattribute variant
         @htmlattributereflected
         */

      }, {
        key: "variant",
        get: function get() {
          return this._variant || variant$1.DEFAULT;
        },
        set: function set(value) {
          var _this$classList;

          value = transform.string(value).toLowerCase();
          this._variant = validate.enumeration(variant$1)(value) && value || variant$1.DEFAULT;

          this._reflectAttribute('variant', this._variant); // removes every existing variant


          this.classList.remove(CLASSNAME$2, ACTION_CLASSNAME);

          (_this$classList = this.classList).remove.apply(_this$classList, ALL_VARIANT_CLASSES$1);

          if (this._variant === variant$1._CUSTOM) {
            this.classList.remove(CLASSNAME$2);
          } else {
            var _this$classList2;

            (_this$classList2 = this.classList).add.apply(_this$classList2, _toConsumableArray(VARIANT_MAP[this._variant]));

            if (this._variant === variant$1.ACTION || this._variant === variant$1.QUIET_ACTION) {
              this.classList.remove(CLASSNAME$2);
            }
          } // Update label styles


          this._updateLabel();
        }
        /**
         Inherited from {@link BaseComponent#trackingElement}.
         */

      }, {
        key: "trackingElement",
        get: function get() {
          return typeof this._trackingElement === 'undefined' ? // keep spaces to only 1 max and trim. this mimics native html behaviors
          (this.label || this).textContent.replace(/\s{2,}/g, ' ').trim() || this.icon : this._trackingElement;
        },
        set: function set(value) {
          _set(_getPrototypeOf(_class.prototype), "trackingElement", value, this, true);
        }
      }, {
        key: "_contentZoneTagName",
        get: function get() {
          return Object.keys(this._contentZones)[0];
        }
      }, {
        key: "_contentZones",
        get: function get() {
          return {
            'coral-button-label': 'label'
          };
        }
        /**
         Returns {@link BaseButton} sizes.
          @return {ButtonSizeEnum}
         */

      }], [{
        key: "size",
        get: function get() {
          return size$1;
        }
        /**
         Returns {@link BaseButton} variants.
          @return {ButtonVariantEnum}
         */

      }, {
        key: "variant",
        get: function get() {
          return variant$1;
        }
        /**
         Returns {@link BaseButton} icon positions.
          @return {ButtonIconPositionEnum}
         */

      }, {
        key: "iconPosition",
        get: function get() {
          return iconPosition;
        }
        /**
         Returns {@link BaseButton} icon sizes.
          @return {ButtonIconSizeEnum}
         */

      }, {
        key: "iconSize",
        get: function get() {
          return iconSize;
        }
      }, {
        key: "_attributePropertyMap",
        get: function get() {
          return commons.extend(_get(_getPrototypeOf(_class), "_attributePropertyMap", this), {
            iconposition: 'iconPosition',
            iconsize: 'iconSize',
            iconautoarialabel: 'iconAutoAriaLabel'
          });
        }
        /** @ignore */

      }, {
        key: "observedAttributes",
        get: function get() {
          return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['iconposition', 'iconsize', 'icon', 'iconautoarialabel', 'size', 'selected', 'block', 'variant', 'value']);
        }
      }]);

      return _class;
    }(BaseLabellable(superClass));
  };

  /**
   @class Coral.Button
   @classdesc A Button component containing text and/or an icon.
   @htmltag coral-button
   @htmlbasetag button
   @extends {HTMLButtonElement}
   @extends {BaseComponent}
   @extends {BaseButton}
   */

  var Button = /*#__PURE__*/function (_BaseButton) {
    _inherits(Button, _BaseButton);

    var _super = _createSuper(Button);

    /** @ignore */
    function Button() {
      var _this;

      _classCallCheck(this, Button);

      _this = _super.call(this); // Events

      _this._delegateEvents(_this._events);

      return _this;
    }

    return Button;
  }(BaseButton(BaseComponent(HTMLButtonElement)));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Button.Label
   @classdesc The Button label content
   @htmltag coral-button-label
   @return {HTMLElement}
   */
  var ButtonLabel = (function () {
    return document.createElement('coral-button-label');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons._define('coral-button', Button, {
    extends: 'button'
  });

  Button.Label = ButtonLabel;

  var CLASSNAME$3 = '_coral-Textfield';
  /**
   Enumeration for {@link Textarea} variants.

   @typedef {Object} TextareaVariantEnum

   @property {String} DEFAULT
   A default textarea.
   @property {String} QUIET
   A textarea with no border or background.
   */

  var variant$2 = {
    DEFAULT: 'default',
    QUIET: 'quiet'
  }; // Builds a string containing all possible variant classnames. This will be used to remove classnames when the variant
  // changes

  var ALL_VARIANT_CLASSES$2 = [];

  for (var variantValue$1 in variant$2) {
    ALL_VARIANT_CLASSES$2.push("".concat(CLASSNAME$3, "--").concat(variant$2[variantValue$1]));
  }
  /**
   @class Coral.Textarea
   @classdesc A Textarea component is the default multi-line text form field.
   @htmltag coral-textarea
   @htmlbasetag textarea
   @extends {HTMLTextAreaElement}
   @extends {BaseComponent}
   @extends {BaseFormField}
   */


  var Textarea = /*#__PURE__*/function (_BaseFormField) {
    _inherits(Textarea, _BaseFormField);

    var _super = _createSuper(Textarea);

    /** @ignore */
    function Textarea() {
      var _this;

      _classCallCheck(this, Textarea);

      _this = _super.call(this);

      _this._delegateEvents(commons.extend(_this._events, {
        input: '_onInput'
      }));

      return _this;
    }
    /**
     The textarea's variant. See {@link TextareaVariantEnum}.
      @type {String}
     @default TextareaVariantEnum.DEFAULT
     @htmlattribute variant
     @htmlattributereflected
     */


    _createClass(Textarea, [{
      key: "reset",

      /**
       Inherited from {@link BaseFormField#reset}.
       */
      value: function reset() {
        // The textarea uses the textContent to save the old value and not the value attribute

        /** @ignore */
        this.value = this.textContent; // Reset height if quiet variant

        this._onInput();
      }
      /** @private */

    }, {
      key: "_onInput",
      value: function _onInput() {
        var _this2 = this;

        if (this.variant === variant$2.QUIET) {
          requestAnimationFrame(function () {
            _this2.style.height = 'auto';
            _this2.style.height = "".concat(_this2.scrollHeight, "px");
          });
        }
      }
      /**
       Returns {@link Textarea} variants.
        @return {TextareaVariantEnum}
       */

    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(Textarea.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$3, "".concat(CLASSNAME$3, "--multiline")); // Default reflected attributes

        if (!this._variant) {
          this.variant = variant$2.DEFAULT;
        }
      }
    }, {
      key: "variant",
      get: function get() {
        return this._variant || variant$2.DEFAULT;
      },
      set: function set(value) {
        var _this$classList;

        value = transform.string(value).toLowerCase();
        this._variant = validate.enumeration(variant$2)(value) && value || variant$2.DEFAULT;

        this._reflectAttribute('variant', this._variant); // removes every existing variant


        (_this$classList = this.classList).remove.apply(_this$classList, ALL_VARIANT_CLASSES$2);

        if (this._variant !== variant$2.DEFAULT) {
          this.classList.add("".concat(CLASSNAME$3, "--").concat(this._variant));
        } // Restore the original height


        if (this._variant === variant$2.QUIET) {
          this._defaultHeight = this._defaultHeight || this.style.height;
        } else {
          this.style.height = this._defaultHeight;
          this._defaultHeight = undefined;
        }

        this._onInput();
      }
    }], [{
      key: "variant",
      get: function get() {
        return variant$2;
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(Textarea), "_nativeObservedAttributes", this).concat(['variant']);
      }
    }]);

    return Textarea;
  }(BaseFormField(BaseComponent(HTMLTextAreaElement)));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons._define('coral-textarea', Textarea, {
    extends: 'textarea'
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var translations$1 = {
    "en-US": {
      "Select": "Select",
      "invalid": "invalid"
    },
    "fr-FR": {
      "Select": "SÃ©lectionner",
      "invalid": "Non valide"
    },
    "de-DE": {
      "Select": "AuswÃ¤hlen",
      "invalid": "UngÃ¼ltig"
    },
    "it-IT": {
      "Select": "Seleziona",
      "invalid": "Non valido"
    },
    "es-ES": {
      "Select": "Seleccionar",
      "invalid": "No vÃ¡lido"
    },
    "pt-BR": {
      "Select": "Selecionar",
      "invalid": "InvÃ¡lido"
    },
    "ja-JP": {
      "Select": "é¸æ",
      "invalid": "ç¡å¹ã§ã"
    },
    "ko-KR": {
      "Select": "ì í",
      "invalid": "ì¬ë°ë¥´ì§ ìì"
    },
    "zh-CN": {
      "Select": "éæ©",
      "invalid": "æ æ"
    },
    "zh-TW": {
      "Select": "é¸å",
      "invalid": "ç¡æ"
    },
    "nl-NL": {
      "Select": "Selecteren",
      "invalid": "Ongeldig"
    },
    "da-DK": {
      "Select": "VÃ¦lg",
      "invalid": "Ugyldig"
    },
    "fi-FI": {
      "Select": "Valitse",
      "invalid": "Virheellinen"
    },
    "nb-NO": {
      "Select": "Velg",
      "invalid": "Ugyldig"
    },
    "sv-SE": {
      "Select": "VÃ¤lj",
      "invalid": "Ogiltig"
    },
    "cs-CZ": {
      "Select": "Vybrat",
      "invalid": "NeplatnÃ½"
    },
    "pl-PL": {
      "Select": "Wybierz",
      "invalid": "NieprawidÅowy"
    },
    "ru-RU": {
      "Select": "ÐÑÐ±ÐµÑÐ¸ÑÐµ",
      "invalid": "ÐÐµÐ´Ð¾Ð¿ÑÑÑÐ¸Ð¼ÑÐ¹"
    },
    "tr-TR": {
      "Select": "SeÃ§",
      "invalid": "GeÃ§ersiz"
    }
  };

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /** @private */
  function listToArray(list) {
    var res = [];

    for (var i = 0, listCount = res.length = list.length; i < listCount; i++) {
      res[i] = list[i];
    }

    return res;
  }

  /**
   Unique id used to idenfity the collection.

   @private
   */

  var nextID$1 = 0;
  /**
   Attribute used to identify the items of a collection.

   @private
   */

  var COLLECTION_ID = 'coral-collection-id-';
  /**
   Selector used to determine if nested items should be allowed.

   @private
   */

  var SCOPE_SELECTOR = ':scope > ';
  /** @private */

  function getTagSelector(tag, nativeTag) {
    return nativeTag ? "".concat(nativeTag, "[is=\"").concat(tag, "\"]") : tag;
  }
  /**
   Helper function used to determine if the item should be filtered. If the filter is <code>undefined</code>, then the
   item will pass the filter.

   @param {HTMLElement} item
   The item that should be filtered.
   @param {Function} filter
   Function used to filter the item

   @returns {Boolean} true if the item passes the filter, otherwise false.

   @private
   */


  function filterItem(item, filter) {
    return typeof filter !== 'function' || filter(item);
  }
  /**
   Collection provides a standardized way to manipulate items in a component.
   */


  var Collection$1 = /*#__PURE__*/function () {
    /**
     @param {HTMLElement} options.host
     The element that hosts the collection.
     @param {String} options.itemTagName
     The tag name of the elements that constitute a collection item.
     @param {String} options.itemBaseTagName
     The optional base tag name of the elements that constitute a collection item. This is required for elements that
     extend native elements, like Button.
     @param {String} [options.itemSelector]
     Optional, derived from itemTagName and itemBaseTagName by default. Used to query the host element for its
     collection items.
     @param {HTMLElement} [options.container]
     Optional element that wraps the collection. Defines where the new items will be added when <code>add</code> method
     is called. Is the same as options.host by default.
     @param {CollectionFilter} [options.filter]
     Optional function used to filter the results.
     @param {CollectionOnItemAdded} [options.onItemAdded]
     Function called once an item is added to the DOM. If the Collection has been configured to handle the items
     automatically, the callback will be called once the collection detects that the item has been added to the DOM and
     not synchronously with <code>add()</code>.
     @param {CollectionOnItemRemoved} [options.onItemRemoved]
     Function called once an item is removed from the DOM. If the Collection has been configured to handle the items
     automatically, the callback will be called once the collection detects that the item has been removed from the DOM
     not synchronously with <code>add()</code>.
     @param {CollectionOnChange} [options.onCollectionChange]
     Function called after there has been a change in the collection. This allows components to handle state changes
     after an item(s) has been added or removed. This callback will only be called if the Collection is configured to
     handle the items automatically.
     is <code>true</code>.
     */
    function Collection(options) {
      _classCallCheck(this, Collection);

      options = options || {}; // we create an unique collection identifier

      this._id = nextID$1++;
      this._host = options.host;
      this._itemTagName = options.itemTagName;
      this._itemBaseTagName = options.itemBaseTagName;
      this._itemSelector = options.itemSelector || getTagSelector(this._itemTagName, this._itemBaseTagName); // the container where the new items are added

      this._container = options.container || this._host;
      this._filter = options.filter; // internal variable to determine if collection events will be handled internally

      this._handleItems = false; // we provide support for the :scope selector and swap it for an id

      if (this._itemSelector && this._itemSelector.indexOf(SCOPE_SELECTOR) === 0) {
        this._container.id = this._container.id || COLLECTION_ID + this._id; // we create a special selector to make sure that the items are direct children of the container. given that
        // :scope is not fully supported by all browsers, we use an id to query

        this._allItemsSelector = this._itemSelector.replace(SCOPE_SELECTOR, "#".concat(this._container.id, " > ")); // we remove the :scope from the selector to be able to use it to determine if the item matches the collection

        this._itemSelector = this._itemSelector.replace(SCOPE_SELECTOR, ''); // in case they match, we enable this optimization

        if (this._itemSelector === this._itemTagName) {
          this._useItemTagName = this._itemSelector.toUpperCase();
        }
      } // live collections are not supported when nested items is used
      else {
          this._allItemsSelector = this._itemSelector; // live collections can only be used when a tagname is used to query the items

          if (this._container && this._allItemsSelector === this._itemTagName) {
            this._liveCollection = true;
            this._useItemTagName = this._allItemsSelector.toUpperCase();
          }
        }

      this._onItemAdded = options.onItemAdded;
      this._onItemRemoved = options.onItemRemoved;
      this._onCollectionChange = options.onCollectionChange;
    }
    /**
     Number of items inside the Collection.
      @type {Number}
     @default 0
     */


    _createClass(Collection, [{
      key: "add",

      /**
       Adds an item to the Collection. The item can be either a <code>HTMLElement</code> or an Object with the item
       properties. If the index is not provided the element appended to the end. If <code>options.onItemAdded</code> was
       provided, it will be called after the element is added from the DOM.
        @param {HTMLElement|Object} item
       The item to add to the Collection.
       @param {HTMLElement} [insertBefore]
       Existing item used as a reference to insert the new item before. If the value is <code>null</code>, then the new
       item will be added at the end.
        @emits {coral-collection:add}
        @returns {HTMLElement} the item added.
       */
      value: function add(item, insertBefore) {
        // container and itemtagname are the minimum options that need to be provided to automatically handle this function
        if (this._container && this._itemTagName) {
          if (!(item instanceof HTMLElement)) {
            // creates an instance of an item from the object
            if (this._itemBaseTagName) {
              item = document.createElement(this._itemBaseTagName, {
                is: this._itemTagName
              }).set(item, true);
            } else {
              item = document.createElement(this._itemTagName).set(item, true);
            }
          } // inserts the element in the specified container


          this._container.insertBefore(item, insertBefore || null); // when items are handled automatically there is no need to call this immediately


          if (!this._handleItems && typeof this._onItemAdded === 'function' && this._host && filterItem(item, this._filter)) {
            this._onItemAdded.call(this._host, item);
          }

          return item;
        }

        throw new Error('Please provide host and itemTagName or override add() to provide your own implementation.');
      }
      /**
       Removes all the items from the Collection.
        @returns {Array.<HTMLElement>} an Array with all the removed items.
       */

    }, {
      key: "clear",
      value: function clear() {
        var items = this.getAll();
        var removed = [];

        for (var i = items.length - 1; i > -1; i--) {
          removed.push(this.remove(items[i]));
        }

        return removed;
      }
      /**
       Returns an array with all the items inside the Collection. Each element is of type <code>HTMLElement</code>.
        @returns {Array.<HTMLElement>} an Array with all the items inside the collection.
       */

    }, {
      key: "getAll",
      value: function getAll() {
        // in order to perform the automatic getAll query, the _host and _allItemsSelector must be provided
        if (this._container && this._allItemsSelector) {
          var items = this._liveCollection ? // instead of querying the DOM, we just convert the live collection to an array, this way we obtain a
          // "snapshot" of the DOM
          listToArray(this._container.getElementsByTagName(this._allItemsSelector)) : listToArray(this._container.querySelectorAll(this._allItemsSelector));

          if (this._filter) {
            items = items.filter(this._filter);
          }

          return items;
        }

        throw new Error('Please provide host and itemTagName or override getAll() to provide your own implementation.');
      }
      /**
       Removes the given item from the Collection. If <code>options.onItemRemoved</code> was provided, it will be called
       after the element is removed from the DOM.
        @param {HTMLElement} item
       The item to add to the Collection.
        @emits {coral-collection:remove}
        @returns {HTMLElement} the item removed.
       */

    }, {
      key: "remove",
      value: function remove(item) {
        if (item.parentNode) {
          item.parentNode.removeChild(item); // when items are handled automatically there is no need to call this immediatelly

          if (!this._handleItems && typeof this._onItemRemoved === 'function' && this._host && filterItem(item, this._filter)) {
            this._onItemRemoved.call(this._host, item);
          }
        }

        return item;
      }
      /**
       Returns the first item of the collection.
        @returns {?HTMLElement} the first item of the collection.
       */

    }, {
      key: "first",
      value: function first() {
        // Use getAll() so filter() is applied
        return this.getAll()[0] || null;
      }
      /**
       Returns the last item of the collection.
        @returns {?HTMLElement} the last item of the collection.
       */

    }, {
      key: "last",
      value: function last() {
        // Use getAll() so filter() is applied
        var all = this.getAll();
        return all[all.length - 1] || null;
      }
      /**
       Checks if the given Node belongs to the current collection. It is said that a Node belongs to a given collection
       if it passes <code>options.filter</code> and it matches <code>options.itemSelector</code>.
        @param {Node} node
       The node to check if it belongs to the collection.
        @returns {Boolean} true if the node is part of the collection, otherwise false.
        @protected
       */

    }, {
      key: "_isPartOfCollection",
      value: function _isPartOfCollection(node) {
        // Only element nodes are allowed
        return node.nodeType === Node.ELEMENT_NODE && filterItem(node, this._filter) && ( // this is an optimization to avoid using matches
        this._useItemTagName ? this._useItemTagName === node.tagName : node.matches(this._itemSelector));
      }
      /**
       Handles the attachment of an item to the collection. It triggers automatically the collection event.
        @param {HTMLElement} item
       The item that was attached to the collection.
        @emits {coral-collection:add}
        @protected
       */

    }, {
      key: "_onItemAttached",
      value: function _onItemAttached(item) {
        // if options.onItemAdded was provided, we call the function
        if (typeof this._onItemAdded === 'function') {
          this._onItemAdded.call(this._host, item);
        } // the usage of trigger assumes that the host is a coral component


        this._host.trigger('coral-collection:add', {
          item: item
        });
      }
      /**
       Handles the detachment of a item to the collection. It triggers automatically the collection event.
        @param {HTMLElement} item
       The item that was detached of the collection
        @emits {coral-collection:remove}
        @protected
       */

    }, {
      key: "_onItemDetached",
      value: function _onItemDetached(item) {
        // if options.onItemRemoved was provided, we call the function
        if (typeof this._onItemRemoved === 'function') {
          this._onItemRemoved.call(this._host, item);
        } // the usage of trigger assumes that the host is a coral component


        this._host.trigger('coral-collection:remove', {
          item: item
        });
      }
      /**
       Enables the automatic detection of collection items. The collection will take care of triggering the appropriate
       collection event when an item is added or removed, as well the related callbacks. Components can decide to skip the
       initialization of the starting items by providing <code>skipInitialItems</code> as <code>false</code>.
        @param {Boolean} [skipInitialItems=false]
       If <code>true</code>, <code>onItemAdded</code> will be called for every starting item. A collection event will not
       be triggered for these items.
        @protected
       */

    }, {
      key: "_startHandlingItems",
      value: function _startHandlingItems(skipInitialItems) {
        if (this._host && this._container) {
          // we reuse the observer if it already exists, this way we do not need to disconnect it if this function is called
          // again
          this._observer = this._observer || new MutationObserver(this._handleMutation.bind(this)); // this changes the way that _onItemAdded and _onItemRemoved behave, since they well be delayed until a mutation
          // detects them

          this._handleItems = true;

          this._observer.observe(this._container, {
            // we only need to observe for items that were added and removed, no need to check attributes and contents
            childList: true,
            // we need to listen to subtree mutations as items may not be direct children
            subtree: true
          }); // by default we handle the initial items unless otherwise indicated


          if (skipInitialItems !== true) {
            // since we are handling the items for the component, we need to make sure the _onItemAdded is called for the
            // initial items. collection events will not be triggered for these items as they represent the initial state
            var items;
            var itemCount = 0;

            if (typeof this._onItemAdded === 'function' || typeof this._onCollectionChange === 'function') {
              items = this.getAll();
              itemCount = items.length;
            }

            if (typeof this._onItemAdded === 'function') {
              for (var i = 0; i < itemCount; i++) {
                this._onItemAdded.call(this._host, items[i]);
              }
            } // we only call the _onCollectionChange callback if there are items inside the collection


            if (itemCount > 0 && typeof this._onCollectionChange === 'function') {
              this._onCollectionChange.call(this._host, items, []);
            }
          }
        } else {
          throw new Error('Please provide options.host and/or options.container to enable handling the items.');
        }
      }
      /**
       Stops handling the items.
        @protected
       */

    }, {
      key: "_stopHandlingItems",
      value: function _stopHandlingItems() {
        if (this._observer) {
          this._observer.disconnect();
        }
      }
      /**
       Handles every time that an element is added or removed from the <code>options.container</code>. By default the
       collection events will be triggered. If <code>options.onItemAdded</code> or <code>options.onItemRemoved</code> were
       provided, they will be called where it applies.
        @param Array.<Object> mutations
       Array that contains the <code>MutationRecord> relevant to every registered mutation.
        @protected
       */

    }, {
      key: "_handleMutation",
      value: function _handleMutation(mutations) {
        var mutation;
        var mutationsCount = mutations.length;
        var item;
        var addedNodes;
        var addedNodesCount;
        var removedNodes;
        var removedNodesCount;
        var validAddedNodes = [];
        var validRemovedNodes = []; // we need to count every addition and removal to notify the component that the collection changed

        var itemChanges = 0;

        for (var i = 0; i < mutationsCount; i++) {
          mutation = mutations[i];
          addedNodes = mutation.addedNodes;
          addedNodesCount = addedNodes.length;

          for (var j = 0; j < addedNodesCount; j++) {
            item = addedNodes[j]; // filters the item

            if (this._isPartOfCollection(item)) {
              itemChanges++;
              validAddedNodes.push(item);

              this._onItemAttached(item);
            }
          }

          removedNodes = mutation.removedNodes;
          removedNodesCount = removedNodes.length;

          for (var k = 0; k < removedNodesCount; k++) {
            item = removedNodes[k]; // filters the item

            if (this._isPartOfCollection(item)) {
              itemChanges++;
              validRemovedNodes.push(item);

              this._onItemDetached(item);
            }
          }
        } // if changes were done to the collection we need to notify the component. we do this after all the mutations were
        // processed to make sure we only do it once


        if (itemChanges !== 0 && typeof this._onCollectionChange === 'function' && this._host) {
          this._onCollectionChange.call(this._host, validAddedNodes, validRemovedNodes);
        }
      }
      /**
       Triggered when an item is added to the {@link Collection}. {@link Collection} events are not synchronous so the DOM
       may reflect a different reality although every addition or removal will be reported.
        @typedef {CustomEvent} coral-collection:add
        @property {HTMLElement} detail.item
       The item that was added.
       */

      /**
       Triggered when an item is removed from a {@link Collection}. {@link Collection} events are not synchronous so the DOM
       may reflect a different reality although every addition or removal will be reported.
        @typedef {CustomEvent} coral-collection:remove
        @property {HTMLElement} detail.item
       The item that was removed.
       */

      /**
       Signature of the function called to determine if an element should be included in the {@link Collection}. If the function
       returns <code>true</code> for the given element it will be part of the collection, otherwise it will be excluded.
        @typedef {function} CollectionFilter
        @param {HTMLElement} element
       The item to check whether it should be part of the collection.
        @returns {Boolean} true if should be part of the collection, otherwise false.
       */

      /**
       Signature of the function called when ever an item is added to the {@link Collection}.
        @typedef {function} CollectionOnItemAdded
        @param {HTMLElement} item
       The item that was added to the collection.
       */

      /**
       Signature of the function called when ever an item is removed from the {@link Collection}.
        @typedef {function} CollectionOnItemRemoved
        @param {HTMLElement} item
       The item that was added to the collection.
       */

      /**
       Signature of the function called when there is a change in the {@link Collection}. The items that where added and removed
       will be provided.
        @typedef {function} CollectionOnChange
        @param {Array.<HTMLElement>} addedNodes
       An array that contains the items that were added to the collection.
       @param {Array.<HTMLElement>} removedNodes
       An array that contains the items that were removed from the collection.
       */

    }, {
      key: "length",
      get: function get() {
        return this.getAll().length;
      }
    }]);

    return Collection;
  }();

  /**
   Collection capable of handling non-nested items with a selected attribute. It is useful to manage the
   internal state of selection. It currently does not support options.filter for the selection related functions.
   */

  var SelectableCollection = /*#__PURE__*/function (_Collection) {
    _inherits(SelectableCollection, _Collection);

    var _super = _createSuper(SelectableCollection);

    function SelectableCollection(options) {
      var _this;

      _classCallCheck(this, SelectableCollection);

      _this = _super.call(this, options);

      if (_this._filter) {
        commons._log('warn', 'Coral.SelectableCollection does not support the options.filter');
      } // disabled items will not be a selection candicate although hidden items might


      _this._selectableItemSelector = _this._allItemsSelector.split(',').map(function (selector) {
        return "".concat(selector, ":not([disabled])");
      }).join(',');
      _this._selectedItemSelector = _this._allItemsSelector.split(',').map(function (selector) {
        return "".concat(selector, "[selected]");
      }).join(',');
      _this._deselectAllExceptSelector = _this._selectedItemSelector;
      return _this;
    }
    /**
     Returns the selectable items. Items that are disabled quality for selection. On the other hand, hidden items
     can be selected as this is the default behavior in HTML. Please note that an already selected item could be
     returned, since the selection could be toggled.
      @returns {Array.<HTMLElement>}
     an array of items whose selection could be toggled.
      @protected
     */


    _createClass(SelectableCollection, [{
      key: "_getSelectableItems",
      value: function _getSelectableItems() {
        return listToArray(this._container.querySelectorAll(this._selectableItemSelector));
      }
      /**
       Returns the first selectable item. Items that are disabled quality for selection. On the other hand, hidden items
       can be selected as this is the default behavior in HTML. Please note that an already selected item could be
       returned, since the selection could be toggled.
        @returns {HTMLElement}
       an item whose selection could be toggled.
        @protected
       */

    }, {
      key: "_getFirstSelectable",
      value: function _getFirstSelectable() {
        return this._container.querySelector(this._selectableItemSelector) || null;
      }
      /**
       Returns the last selectable item. Items that are disabled quality for selection. On the other hand, hidden items
       can be selected as this is the default behavior in HTML. Please note that an already selected item could be
       returned, since the selection could be toggled.
        @returns {HTMLElement}
       an item whose selection could be toggled.
        @protected
       */

    }, {
      key: "_getLastSelectable",
      value: function _getLastSelectable() {
        var items = this._container.querySelectorAll(this._selectableItemSelector);

        return items[items.length - 1] || null;
      }
      /**
       Returns the previous selectable item.
        @param {HTMLElement} item
       The reference item.
        @returns {HTMLElement}
       an item whose selection could be toggled.
        @protected
       */

    }, {
      key: "_getPreviousSelectable",
      value: function _getPreviousSelectable(item) {
        var items = this.getAll();
        var index = items.indexOf(item);
        var sibling = index > 0 ? items[index - 1] : null;

        while (sibling) {
          if (sibling.matches(this._selectableItemSelector)) {
            break;
          } else {
            index--;
            sibling = index > 0 ? items[index - 1] : null;
          }
        } // in case the item is not specified, or it is not inside the collection, we need to return the first selectable


        return sibling || (item.matches(this._selectableItemSelector) ? item : this._getFirstSelectable());
      }
      /**
       Returns the next selectable item.
        @param {HTMLElement} item
       The reference item.
        @returns {HTMLElement}
       an item whose selection could be toggled.
        @protected
       */

    }, {
      key: "_getNextSelectable",
      value: function _getNextSelectable(item) {
        var items = this.getAll();
        var index = items.indexOf(item);
        var sibling = index < items.length - 1 ? items[index + 1] : null;

        while (sibling) {
          if (sibling.matches(this._selectableItemSelector)) {
            break;
          } else {
            index++;
            sibling = index < items.length - 1 ? items[index + 1] : null;
          }
        }

        return sibling || item;
      }
      /**
       Returns the first item that is selected in the Collection. It allows to configure the attribute used for selection
       so that components that use 'selected' and 'active' can share the same implementation.
        @param {String} [selectedAttribute=selected]
       the attribute that will be used to check for selection.
        @returns HTMLElement the first selected item.
        @protected
       */

    }, {
      key: "_getFirstSelected",
      value: function _getFirstSelected(selectedAttribute) {
        var selector = this._selectedItemSelector;

        if (typeof selectedAttribute === 'string') {
          selector = selector.replace('[selected]', "[".concat(selectedAttribute, "]"));
        }

        return this._container.querySelector(selector) || null;
      }
      /**
       Returns the last item that is selected in the Collection. It allows to configure the attribute used for selection
       so that components that use 'selected' and 'active' can share the same implementation.
        @param {String} [selectedAttribute=selected]
       the attribute that will be used to check for selection.
        @returns HTMLElment the last selected item.
        @protected
       */

    }, {
      key: "_getLastSelected",
      value: function _getLastSelected(selectedAttribute) {
        var selector = this._selectedItemSelector;

        if (typeof selectedAttribute === 'string') {
          selector = selector.replace('[selected]', "[".concat(selectedAttribute, "]"));
        } // last-of-type did not work so we need to query all


        var items = this._container.querySelectorAll(selector);

        return items[items.length - 1] || null;
      }
      /**
       Returns an array that contains all the items that are selected.
        @param {String} [selectedAttribute=selected]
       the attribute that will be used to check for selection.
        @protected
        @returns Array.<HTMLElement> an array with all the selected items.
       */

    }, {
      key: "_getAllSelected",
      value: function _getAllSelected(selectedAttribute) {
        var selector = this._selectedItemSelector;

        if (typeof selectedAttribute === 'string') {
          selector = selector.replace('[selected]', "[".concat(selectedAttribute, "]"));
        }

        return listToArray(this._container.querySelectorAll(selector));
      }
      /**
       Deselects all the items except the first selected item in the Collection. By default the <code>selected</code>
       attribute will be removed. The attribute to remove is configurable via the <code>selectedAttribute</code> parameter.
       The selected attribute will be removed no matter if the item is <code>disabled</code> or <code>hidden</code>.
        @param {String} [selectedAttribute=selected]
       the attribute that will be used to check for selection. This attribute will be removed from the matching elements.
        @protected
       */

    }, {
      key: "_deselectAllExceptFirst",
      value: function _deselectAllExceptFirst(selectedAttribute) {
        var selector = this._deselectAllExceptSelector;
        var attributeToRemove = selectedAttribute || 'selected';

        if (typeof selectedAttribute === 'string') {
          selector = selector.replace('[selected]', "[".concat(selectedAttribute, "]"));
        } // we select all the selected attributes except the last one


        var items = this._container.querySelectorAll(selector);

        var itemsCount = items.length; // ignores the first item of the list, everything else is deselected

        for (var i = 1; i < itemsCount; i++) {
          // we use remoteAttribute since we do not know if the element is upgraded
          items[i].removeAttribute(attributeToRemove);
        }
      }
      /**
       Deselects all the items except the last selected item in the Collecton. By default the <code>selected</code>
       attribute will be removed. The attribute to remove is configurable via the <code>selectedAttribute</code> parameter.
        @param {String} [selectedAttribute=selected]
       the attribute that will be used to check for selection. This attribute will be removed from the matching elements.
        @protected
       */

    }, {
      key: "_deselectAllExceptLast",
      value: function _deselectAllExceptLast(selectedAttribute) {
        var selector = this._deselectAllExceptSelector;
        var attributeToRemove = selectedAttribute || 'selected';

        if (typeof selectedAttribute === 'string') {
          selector = selector.replace('[selected]', "[".concat(selectedAttribute, "]"));
        } // we query for all matching items with the given attribute


        var items = this._container.querySelectorAll(selector); // we ignore the last item


        var itemsCount = items.length - 1;

        for (var i = 0; i < itemsCount; i++) {
          // we use remoteAttribute since we do not know if the element is upgraded
          items[i].removeAttribute(attributeToRemove);
        }
      }
      /**
       Deselects all the items except the given item. The provided attribute will be remove from all matching items. By
       default the <code>selected</code> attribute will be removed. The attribute to remove is configurable via the
       <code>selectedAttribute</code> parameter.
        @name Coral.SelectableCollection#_deselectAllExcept
       @function
        @param {HTMLElement} [itemOrSelectedAttribute]
       The item to keep selected. If the item is not provided, all elements will be deselected.
        @param {String} [selectedAttribute=selected]
       the attribute that will be used to check for selection. This attribute will be removed from the matching elements.
        @protected
       */

    }, {
      key: "_deselectAllExcept",
      value: function _deselectAllExcept(itemOrSelectedAttribute, selectedAttribute) {
        // if no selectedAttribute we use the unmodified selector as default
        var selector = this._deselectAllExceptSelector;
        var item;
        var attributeToRemove; // an item was not provided so we use it as 'selectedAttribute'

        if (typeof itemOrSelectedAttribute === 'string') {
          item = null;
          attributeToRemove = itemOrSelectedAttribute || 'selected';
          selector = selector.replace('[selected]', "[".concat(attributeToRemove, "]"));
        } else {
          item = itemOrSelectedAttribute;
          attributeToRemove = selectedAttribute || 'selected';

          if (typeof selectedAttribute === 'string') {
            selector = selector.replace('[selected]', "[".concat(attributeToRemove, "]"));
          }
        } // we query for all matching items with the given attribute


        var items = this._container.querySelectorAll(selector);

        var itemsCount = items.length;

        for (var i = 0; i < itemsCount; i++) {
          // we use remoteAttribute since we do not know if the element is upgraded
          if (item !== items[i]) {
            items[i].removeAttribute(attributeToRemove);
          }
        }
      }
    }]);

    return SelectableCollection;
  }(Collection$1);

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var translations$2 = {
    "en-US": {
      "Remove": "Remove"
    },
    "fr-FR": {
      "Remove": "Supprimer"
    },
    "de-DE": {
      "Remove": "Entfernen"
    },
    "it-IT": {
      "Remove": "Rimuovi"
    },
    "es-ES": {
      "Remove": "Eliminar"
    },
    "pt-BR": {
      "Remove": "Remover"
    },
    "ja-JP": {
      "Remove": "åé¤"
    },
    "ko-KR": {
      "Remove": "ì ê±°"
    },
    "zh-CN": {
      "Remove": "å é¤"
    },
    "zh-TW": {
      "Remove": "ç§»é¤"
    },
    "nl-NL": {
      "Remove": "Verwijderen"
    },
    "da-DK": {
      "Remove": "Fjern"
    },
    "fi-FI": {
      "Remove": "Poista"
    },
    "nb-NO": {
      "Remove": "Fjern"
    },
    "sv-SE": {
      "Remove": "Ta bort"
    },
    "cs-CZ": {
      "Remove": "Odebrat"
    },
    "pl-PL": {
      "Remove": "UsuÅ"
    },
    "ru-RU": {
      "Remove": "Ð£Ð´Ð°Ð»Ð¸ÑÑ"
    },
    "tr-TR": {
      "Remove": "KaldÄ±r"
    }
  };

  var template = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var data = data_0 = typeof data_0 === "undefined" ? {} : data_0;
    var el0 = this["buttonCell"] = document.createElement("span");
    el0.setAttribute("handle", "buttonCell");
    el0.setAttribute("hidden", "");
    var el1 = document.createTextNode("\n  ");
    el0.appendChild(el1);
    var el2 = this["button"] = document.createElement("button", "coral-button");
    el2.setAttribute("tracking", "off");
    el2.setAttribute("handle", "button");
    el2.setAttribute("is", "coral-button");
    el2.setAttribute("type", "button");
    el2.setAttribute("variant", "_custom");
    el2.className += " _coral-ClearButton _coral-ClearButton--small _coral-Tags-item-removeButton";
    el2.setAttribute("title", data_0["i18n"]["get"]('Remove'));
    el2.setAttribute("hidden", "");
    el2.setAttribute("tabindex", "-1");
    el2.setAttribute("coral-close", "");
    var el3 = document.createTextNode("\n    ");
    el2.appendChild(el3);
    var el4 = this["buttonLabel"] = document.createElement("coral-button-label");
    el4.setAttribute("handle", "buttonLabel");
    el2.appendChild(el4);
    var el5 = document.createTextNode("\n  ");
    el2.appendChild(el5);
    el0.appendChild(el2);
    var el6 = document.createTextNode("\n");
    el0.appendChild(el6);
    frag.appendChild(el0);
    var el7 = document.createTextNode("\n");
    frag.appendChild(el7);
    data = data_0; // Don't wait for button MO to pick up the label

    this.button._elements.label = this.buttonLabel; // Render close icon

    this.button.insertAdjacentHTML('beforeend', data.Icon._renderSVG('spectrum-css-icon-CrossSmall', ['_coral-UIIcon-CrossSmall']));
    data_0 = data;
    var el9 = document.createTextNode("\n");
    frag.appendChild(el9);
    return frag;
  };

  var CLASSNAME$4 = '_coral-Tags-item';
  var LABEL_CLASSNAME = '_coral-Label';
  /**
   Enumeration for {@link Tag} sizes. Only colored tags can have different sizes.

   @typedef {Object} TagSizeEnum

   @property {String} SMALL
   A small sized tag.
   @property {String} MEDIUM
   A default sized tag.
   @property {String} LARGE
   A large sized tag.
   */

  var size$2 = {
    SMALL: 'S',
    MEDIUM: 'M',
    LARGE: 'L'
  };
  /**
   Enumeration for {@link Tag} colors.

   @typedef {Object} TagColorEnum

   @property {String} DEFAULT
   @property {String} GREY
   @property {String} BLUE
   @property {String} RED
   @property {String} ORANGE
   @property {String} GREEN
   @property {String} YELLOW
   @property {String} SEA_FOAM
   @property {String} FUCHSIA
   @property {String} LIGHT_BLUE
   Not supported. Falls back to BLUE.
   @property {String} PERIWINKLE
   Not supported. Falls back to BLUE.
   @property {String} CYAN
   Not supported. Falls back to BLUE.
   @property {String} PLUM
   Not supported. Falls back to RED.
   @property {String} MAGENTA
   Not supported. Falls back to RED.
   @property {String} TANGERINE
   Not supported. Falls back to ORANGE.
   @property {String} CHARTREUSE
   Not supported. Falls back to GREEN.
   @property {String} KELLY_GREEN
   Not supported. Falls back to GREEN.
   */

  var color = {
    DEFAULT: '',
    GREY: 'grey',
    BLUE: 'blue',
    RED: 'red',
    ORANGE: 'orange',
    GREEN: 'green',
    LIGHT_BLUE: 'lightblue',
    PERIWINKLE: 'periwinkle',
    PLUM: 'plum',
    FUCHSIA: 'fuchsia',
    MAGENTA: 'magenta',
    TANGERINE: 'tangerine',
    YELLOW: 'yellow',
    CHARTREUSE: 'chartreuse',
    KELLY_GREEN: 'kellygreen',
    SEA_FOAM: 'seafoam',
    CYAN: 'cyan'
  };
  var colorMap = {
    lightblue: 'blue',
    periwinkle: 'blue',
    cyan: 'blue',
    plum: 'red',
    magenta: 'red',
    tangerine: 'orange',
    chartreuse: 'green',
    kelly_green: 'green'
  };
  var swappedSize = commons.swapKeysAndValues(size$2); // builds a string containing all possible color classnames. this will be used to remove classnames when the color
  // changes

  var ALL_COLOR_CLASSES = [];

  for (var colorValue in color) {
    ALL_COLOR_CLASSES.push("".concat(LABEL_CLASSNAME, "--").concat(color[colorValue]));
  } // builds a string containing all possible size classnames. this will be used to remove classnames when the size
  // changes


  var ALL_SIZE_CLASSES$1 = [];

  for (var sizeValue$1 in Object.keys(size$2)) {
    ALL_SIZE_CLASSES$1.push("".concat(LABEL_CLASSNAME, "--").concat(sizeValue$1));
  }

  var QUIET_CLASSNAME = "".concat(CLASSNAME$4, "--quiet");
  var MULTILINE_CLASSNAME = "".concat(CLASSNAME$4, "--multiline"); // Store coordinates of a mouse down event to compare against mouseup coordinates.
  /**
   @class Coral.Tag
   @classdesc A Tag component
   @htmltag coral-tag
   @extends {HTMLElement}
   @extends {BaseComponent}
   */


  var Tag = /*#__PURE__*/function (_BaseComponent) {
    _inherits(Tag, _BaseComponent);

    var _super = _createSuper(Tag);

    /** @ignore */
    function Tag() {
      var _this;

      _classCallCheck(this, Tag);

      _this = _super.call(this); // Attach events

      _this._delegateEvents({
        'click [handle="button"]': '_onRemoveButtonClick',
        'key:backspace': '_onRemoveButtonClick',
        'key:delete': '_onRemoveButtonClick'
      }); // Prepare templates


      _this._elements = {
        // Create or fetch the label element.
        label: _this.querySelector('coral-tag-label') || document.createElement('coral-tag-label')
      };
      template.call(_this._elements, {
        i18n: i18n,
        Icon: Icon
      });
      return _this;
    }
    /**
     The tag's label element.
      @type {TagLabel}
     @contentzone
     */


    _createClass(Tag, [{
      key: "_toggleTagVariant",

      /**
       Toggle between Tag and Label styles
        @private
       */
      value: function _toggleTagVariant() {
        var _this$classList, _this$classList2;

        var isColored = this.color !== color.DEFAULT; // Base

        this.classList.toggle(CLASSNAME$4, !isColored);
        this.classList.toggle(LABEL_CLASSNAME, isColored); // Closable

        this.classList.toggle("".concat(CLASSNAME$4, "--deletable"), !isColored); // Quiet

        this.classList.toggle(QUIET_CLASSNAME, !isColored && this.quiet); // Size

        (_this$classList = this.classList).remove.apply(_this$classList, ALL_SIZE_CLASSES$1);

        this.classList.toggle("".concat(LABEL_CLASSNAME, "--").concat(swappedSize[this.size].toLowerCase()), isColored); // Color

        (_this$classList2 = this.classList).remove.apply(_this$classList2, ALL_COLOR_CLASSES);

        this.classList.toggle("".concat(LABEL_CLASSNAME, "--").concat(this.color), isColored);
      }
      /**
       Inherited from {@link BaseComponent#trackingElement}.
       */

    }, {
      key: "_onRemoveButtonClick",

      /** @private */
      value: function _onRemoveButtonClick(event) {
        event.preventDefault();

        if (this.closable && !this._elements.button.disabled) {
          event.stopPropagation();
          this.focus();
          var host = this._host;
          this.remove();

          if (host) {
            host._onTagButtonClicked(this, event);
          }
        }
      }
      /**
       Updates the aria-label property from the button and label elements.
        @ignore
       */

    }, {
      key: "_updateAriaLabel",
      value: function _updateAriaLabel() {
        var button = this._elements.button;
        var buttonCell = this._elements.buttonCell;
        var label = this._elements.label; // In the edge case that this is a Tag without a TagList,
        // just treat the Tag as a container element without special labelling.

        if (this.getAttribute('role') !== 'row') {
          buttonCell.removeAttribute('role');
          label.removeAttribute('role');

          if (this.getAttribute('aria-labelledby') === label.id) {
            this.removeAttribute('aria-labelledby');
          }

          return;
        }

        buttonCell.setAttribute('role', 'gridcell');
        label.setAttribute('role', this._closable ? 'rowheader' : 'gridcell');
        var buttonAriaLabel = button.getAttribute('title');
        var labelTextContent = label.textContent; // button should be labelled, "Remove: labelTextContent".

        button.setAttribute('aria-label', "".concat(buttonAriaLabel, ": ").concat(labelTextContent));

        if (!label.id) {
          label.id = commons.getUID();
        }

        this.setAttribute('aria-labelledby', label.id);
      }
    }, {
      key: "attributeChangedCallback",

      /** @ignore */
      value: function attributeChangedCallback(name, oldValue, value) {
        // This is required by TagList but we don't need to expose disabled publicly as API
        if (name === 'disabled') {
          this._elements.button.disabled = value;
        } // This is required by TagList but we don't need to expose disabled publicly as API
        else if (name === 'role') {
            this._updateAriaLabel();
          } else {
            _get(_getPrototypeOf(Tag.prototype), "attributeChangedCallback", this).call(this, name, oldValue, value);
          }
      }
      /** @ignore */

    }, {
      key: "connectedCallback",
      value: function connectedCallback() {
        if (this._skipConnectedCallback()) {
          return;
        }

        _get(_getPrototypeOf(Tag.prototype), "connectedCallback", this).call(this); // Used to inform the tag list that it's added


        this.trigger('coral-tag:_connected');
      }
      /** @ignore */

    }, {
      key: "render",
      value: function render() {
        _get(_getPrototypeOf(Tag.prototype), "render", this).call(this); // Default reflected attributes


        if (!this._size) {
          this.size = size$2.MEDIUM;
        }

        if (!this._color) {
          this.color = color.DEFAULT;
        }

        var templateHandleNames = ['input', 'button', 'buttonCell'];
        var label = this._elements.label; // Remove it so we can process children

        if (label.parentNode) {
          this.removeChild(label);
        } // Process remaining elements as necessary


        while (this.firstChild) {
          var child = this.firstChild;

          if (child.nodeType === Node.TEXT_NODE || templateHandleNames.indexOf(child.getAttribute('handle')) === -1) {
            // Add non-template elements to the label
            label.appendChild(child);
          } else {
            // Remove anything else
            this.removeChild(child);
          }
        } // Assign the content zones, moving them into place in the process


        this.label = label;
      }
      /** @ignore */

    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        _get(_getPrototypeOf(Tag.prototype), "disconnectedCallback", this).call(this); // Used to inform the tag list that it's removed synchronously


        if (this._host) {
          this._host._onItemDisconnected(this);
        }
      }
      /**
       Triggered when the {@link Tag} value is changed.
        @typedef {CustomEvent} coral-tag:_valuechanged
        @private
       */

      /**
       Triggered when the {@link Tag} is added to the document.
        @typedef {CustomEvent} coral-tag:_connected
        @private
       */

    }, {
      key: "label",
      get: function get() {
        return this._getContentZone(this._elements.label);
      },
      set: function set(value) {
        this._setContentZone('label', value, {
          handle: 'label',
          tagName: 'coral-tag-label',
          insert: function insert(label) {
            label.classList.add("".concat(CLASSNAME$4, "Label"));
            this.insertBefore(label, this.firstChild);

            this._updateAriaLabel();
          }
        });
      }
      /**
       Whether this component can be closed.
        @type {Boolean}
       @default false
       @htmlattribute closable
       @htmlattributereflected
       */

    }, {
      key: "closable",
      get: function get() {
        return this._closable || false;
      },
      set: function set(value) {
        this._closable = transform.booleanAttr(value);

        this._reflectAttribute('closable', this._closable); // Only tags are closable


        this._toggleTagVariant();

        if (this._closable && !this.contains(this._elements.buttonCell)) {
          // Insert the buttonCell if it was not added to the DOM
          this.appendChild(this._elements.buttonCell);
        }

        this._elements.button.hidden = !this._closable;
        this._elements.buttonCell.hidden = !this._closable;

        this._updateAriaLabel();
      }
      /**
       Value of the tag. If not explicitly set, the value of <code>Node.textContent</code> is returned.
        @type {String}
       @default ""
       @htmlattribute value
       @htmlattributereflected
       */

    }, {
      key: "value",
      get: function get() {
        return typeof this._value === 'string' ? this._value : this.textContent.replace(/\s{2,}/g, ' ').trim();
      },
      set: function set(value) {
        var _value = transform.string(value);

        if (this._value === _value) {
          return;
        }

        this._value = _value;

        this._reflectAttribute('value', this._value);

        this.trigger('coral-tag:_valuechanged');
      }
      /**
       A quiet tag to differentiate it from default tag.
        @type {Boolean}
       @default false
       @htmlattribute quiet
       @htmlattributereflected
       */

    }, {
      key: "quiet",
      get: function get() {
        return this._quiet || false;
      },
      set: function set(value) {
        this._quiet = transform.booleanAttr(value);

        this._reflectAttribute('quiet', this._quiet); // Only tags are quiet


        this._toggleTagVariant();
      }
      /**
       A multiline tag for block-level layout with multiline text.
        @type {Boolean}
       @default false
       @htmlattribute multiline
       @htmlattributereflected
       */

    }, {
      key: "multiline",
      get: function get() {
        return this._multiline || false;
      },
      set: function set(value) {
        this._multiline = transform.booleanAttr(value);

        this._reflectAttribute('multiline', this._multiline);

        this.classList.toggle(MULTILINE_CLASSNAME, this._multiline);
      }
      /**
       The tag's size. See {@link {TagSizeEnum}. Only colored tags can have different sizes.
        @type {String}
       @default TagSizeEnum.MEDIUM
       @htmlattribute size
       @htmlattributereflected
       */

    }, {
      key: "size",
      get: function get() {
        return this._size || size$2.MEDIUM;
      },
      set: function set(value) {
        value = this._host ? size$2.MEDIUM : transform.string(value).toUpperCase();
        this._size = validate.enumeration(size$2)(value) && value || size$2.MEDIUM;

        this._reflectAttribute('size', this._size);

        this._toggleTagVariant();
      }
      /**
       The tags's color. See {@link TagColorEnum}.
        @type {String}
       @default Coral.Tag.color.DEFAULT
       @htmlattribute color
       @htmlattributereflected
       */

    }, {
      key: "color",
      get: function get() {
        return this._color || color.DEFAULT;
      },
      set: function set(value) {
        value = this._host ? color.DEFAULT : transform.string(value).toLowerCase();
        this._color = validate.enumeration(color)(value) && value || color.DEFAULT; // Map unsupported colors

        if (Object.keys(colorMap).indexOf(this._color) !== -1) {
          this._color = colorMap[this._color];
        }

        this._reflectAttribute('color', this._color);

        this._toggleTagVariant();
      }
    }, {
      key: "trackingElement",
      get: function get() {
        // it uses the name as the first fallback since it is not localized, otherwise it uses the label
        return typeof this._trackingElement === 'undefined' ? // keep spaces to only 1 max and trim. this mimics native html behaviors
        this.value || (this.label || this).textContent.replace(/\s{2,}/g, ' ').trim() : this._trackingElement;
      },
      set: function set(value) {
        _set(_getPrototypeOf(Tag.prototype), "trackingElement", value, this, true);
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-tag-label': 'label'
        };
      }
      /**
       Returns {@link Tag} sizes.
        @return {TagSizeEnum}
       */

    }], [{
      key: "size",
      get: function get() {
        return size$2;
      }
      /**
       Returns {@link Tag} colors.
        @return {TagColorEnum}
       */

    }, {
      key: "color",
      get: function get() {
        return color;
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(Tag), "observedAttributes", this).concat(['closable', 'value', 'quiet', 'multiline', 'size', 'color', 'disabled', 'role']);
      }
    }]);

    return Tag;
  }(BaseComponent(HTMLElement));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Tag.Label
   @classdesc Tag's label component
   @htmltag coral-tag-label
   @return {HTMLElement}
   */
  var TagLabel = (function () {
    return document.createElement('coral-tag-label');
  });

  var CLASSNAME$5 = '_coral-Tags'; // Collection

  var ITEM_TAGNAME = 'coral-tag';
  /**
   Extracts the value from the item in case no explicit value was provided.
   @param {HTMLElement} item
   the item whose value will be extracted.
   @returns {String} the value that will be submitted for this item.
   @private
   */

  var itemValueFromDOM = function itemValueFromDOM(item) {
    var attr = item.getAttribute('value'); // checking explicitly for null allows to differentiate between non set values and empty strings

    return attr !== null ? attr : item.textContent.replace(/\s{2,}/g, ' ').trim();
  };
  /**
   @class Coral.TagList
   @classdesc A TagList component is a form field container to manipulate tags.
   @htmltag coral-taglist
   @extends {HTMLElement}
   @extends {BaseComponent}
   @extends {BaseFormField}
   */


  var TagList = /*#__PURE__*/function (_BaseFormField) {
    _inherits(TagList, _BaseFormField);

    var _super = _createSuper(TagList);

    /** @ignore */
    function TagList() {
      var _this;

      _classCallCheck(this, TagList);

      _this = _super.call(this); // Attach events

      _this._delegateEvents(commons.extend(_this._events, {
        'capture:focus coral-tag': '_onItemFocus',
        'capture:blur coral-tag': '_onItemBlur',
        'key:right coral-tag': '_onNextItemFocus',
        'key:down coral-tag': '_onNextItemFocus',
        'key:pagedown coral-tag': '_onNextItemFocus',
        'key:left coral-tag': '_onPreviousItemFocus',
        'key:up coral-tag': '_onPreviousItemFocus',
        'key:pageup coral-tag': '_onPreviousItemFocus',
        'key:home coral-tag': '_onFirstItemFocus',
        'key:end coral-tag': '_onLastItemFocus',
        // Accessibility
        'capture:focus coral-tag:not(.is-disabled)': '_onItemFocusIn',
        'capture:blur coral-tag:not(.is-disabled)': '_onItemFocusOut',
        // Private
        'coral-tag:_valuechanged': '_onTagValueChanged',
        'coral-tag:_connected': '_onTagConnected'
      })); // Pre-define labellable element


      _this._labellableElement = _assertThisInitialized(_this);
      _this._itemToFocusAfterDelete = null;
      return _this;
    }
    /**
     Changing the values will redefine the component's items.
      @type {Array.<String>}
     @emits {change}
     */


    _createClass(TagList, [{
      key: "_attachInputToItem",

      /** @private */
      value: function _attachInputToItem(item) {
        if (!item._input) {
          item._input = document.createElement('input');
          item._input.type = 'hidden'; // We do this so it is recognized by Coral.Tag and handled if cloned

          item._input.setAttribute('handle', 'input');
        }

        var input = item._input;
        input.disabled = this.disabled;
        input.name = this.name;
        input.value = item.value;

        if (!item.contains(input)) {
          item.appendChild(input);
        }
      }
      /** @private */

    }, {
      key: "_prepareItem",
      value: function _prepareItem(attachedItem) {
        var items = this.items.getAll(); // Prevents to add duplicates based on the tag value

        var duplicate = items.some(function (tag) {
          if (itemValueFromDOM(tag) === itemValueFromDOM(attachedItem) && tag !== attachedItem) {
            (items.indexOf(tag) < items.indexOf(attachedItem) ? attachedItem : tag).remove();
            return true;
          }

          return false;
        });

        if (duplicate) {
          return;
        } // create corresponding input field


        this._attachInputToItem(attachedItem); // Set tag defaults


        attachedItem.setAttribute('color', Tag.color.DEFAULT);
        attachedItem.setAttribute('size', Tag.size.SMALL); // adds the role to support accessibility

        attachedItem.setAttribute('role', 'row');

        if (!this.disabled) {
          attachedItem.setAttribute('tabindex', '-1');
        }

        attachedItem[this.readOnly ? 'removeAttribute' : 'setAttribute']('closable', ''); // add tabindex to first item if none existing

        if (!this.disabled && !this.querySelector("".concat(ITEM_TAGNAME, "[tabindex=\"0\"]"))) {
          var first = items[0];

          if (first) {
            first.setAttribute('tabindex', '0');
          }
        } // Keep a reference on the host in case the tag gets removed


        attachedItem._host = this; // triggers the Coral.Collection event

        this.trigger('coral-collection:add', {
          item: attachedItem
        });
      }
      /** @private */

    }, {
      key: "_onItemDisconnected",
      value: function _onItemDisconnected(detachedItem) {
        var _this2 = this;

        // Cleans the tag from TagList specific values
        detachedItem.removeAttribute('role');
        detachedItem.removeAttribute('tabindex');
        detachedItem._host = undefined;
        var parentElement = this.parentElement;

        if (this.items.length === 0 && parentElement) {
          // If all tags are removed, call focus method on parent element
          if (typeof parentElement.focus === 'function') {
            parentElement.focus();
          }

          var self = this;
          commons.nextFrame(function () {
            // if the parentElement did not receive focus or move focus to some other element
            if (document.activeElement.tagName === 'BODY') {
              if (_this2.items.length > 0) {
                self.items.first().focus();
              } else {
                // make the TagList focusable
                self.tabIndex = -1;
                self.classList.add('u-coral-screenReaderOnly');
                self.style.outline = '0';
                self.innerHTML = ' ';

                var onBlurFocusManagement = function onBlurFocusManagement() {
                  self.removeAttribute('tabindex');
                  self.classList.remove('u-coral-screenReaderOnly');
                  self.style.outline = '';
                  self.innerHTML = '';

                  self._vent.off('blur.focusManagement');
                };

                self._vent.on('blur.focusManagement', null, onBlurFocusManagement);

                if (!parentElement.contains(document.activeElement)) {
                  self.focus();
                } else {
                  onBlurFocusManagement();
                }
              }
            }
          });
        } else if (this._itemToFocusAfterDelete) {
          this._itemToFocusAfterDelete.focus();
        } // triggers the Coral.Collection event


        this.trigger('coral-collection:remove', {
          item: detachedItem
        });
      }
      /** @private */

    }, {
      key: "_onItemFocus",
      value: function _onItemFocus(event) {
        if (!this.disabled) {
          this.setAttribute('aria-live', 'polite');
          var tag = event.matchedTarget; // add tabindex to first item and remove from previous focused item

          this.items.getAll().forEach(function (item) {
            if (item !== tag) {
              item.setAttribute('tabindex', '-1');
            }
          });
          tag.setAttribute('tabindex', '0');

          this._setItemToFocusOnDelete(tag);
        }
      }
      /** @private */

    }, {
      key: "_onItemBlur",
      value: function _onItemBlur(event) {
        if (!this.disabled) {
          this.setAttribute('aria-live', 'off');
          var tag = event.matchedTarget;

          this._setItemToFocusOnDelete(tag);
        }
      }
      /** @private */

    }, {
      key: "_onSiblingItemFocus",
      value: function _onSiblingItemFocus(event, sibling) {
        if (!this.disabled) {
          event.preventDefault();
          var item = event.target[sibling];

          while (item) {
            if (item.tagName.toLowerCase() === ITEM_TAGNAME && !item.hidden) {
              item.focus();
              break;
            } else {
              item = item[sibling];
            }
          }
        }
      }
      /** @private */

    }, {
      key: "_onNextItemFocus",
      value: function _onNextItemFocus(event) {
        this._onSiblingItemFocus(event, 'nextElementSibling');
      }
      /** @private */

    }, {
      key: "_onPreviousItemFocus",
      value: function _onPreviousItemFocus(event) {
        this._onSiblingItemFocus(event, 'previousElementSibling');
      }
      /** @private */

    }, {
      key: "_onFirstItemFocus",
      value: function _onFirstItemFocus(event) {
        event.preventDefault();
        var length = this.items.length;

        if (length > 0) {
          this.items.getAll()[0].focus();
        }
      }
      /** @private */

    }, {
      key: "_onLastItemFocus",
      value: function _onLastItemFocus(event) {
        event.preventDefault();
        var length = this.items.length;

        if (length > 0) {
          this.items.getAll()[length - 1].focus();
        }
      }
    }, {
      key: "_onItemFocusIn",
      value: function _onItemFocusIn(event) {
        event.matchedTarget.classList.add('focus-ring');
      }
    }, {
      key: "_onItemFocusOut",
      value: function _onItemFocusOut(event) {
        event.matchedTarget.classList.remove('focus-ring');
      }
      /** @private */

    }, {
      key: "_onTagButtonClicked",
      value: function _onTagButtonClicked(item, event) {
        this.trigger('change');

        this._trackEvent('remove', 'coral-tag', event, item);
      }
      /** @private */

    }, {
      key: "_onTagValueChanged",
      value: function _onTagValueChanged(event) {
        event.stopImmediatePropagation();
        var tag = event.target;

        if (tag._input) {
          tag._input.value = tag.value;
        }
      }
      /** @private */

    }, {
      key: "_setItemToFocusOnDelete",
      value: function _setItemToFocusOnDelete(tag) {
        var _this3 = this;

        var itemToFocusAfterDelete = tag.nextElementSibling; // Next item will be focusable if the focused tag is removed

        while (itemToFocusAfterDelete) {
          if (itemToFocusAfterDelete.tagName.toLowerCase() === ITEM_TAGNAME && !itemToFocusAfterDelete.hidden) {
            this._itemToFocusAfterDelete = itemToFocusAfterDelete;
            return;
          }

          itemToFocusAfterDelete = itemToFocusAfterDelete.nextElementSibling;
        }

        itemToFocusAfterDelete = tag.previousElementSibling; // Previous item will be focusable if the focused tag is removed

        while (itemToFocusAfterDelete) {
          if (itemToFocusAfterDelete.tagName.toLowerCase() === ITEM_TAGNAME && !itemToFocusAfterDelete.hidden) {
            this._itemToFocusAfterDelete = itemToFocusAfterDelete;
            break;
          } else {
            itemToFocusAfterDelete = itemToFocusAfterDelete.previousElementSibling;
          }
        }

        window.requestAnimationFrame(function () {
          if (tag.parentElement !== null && !_this3.contains(document.activeElement)) {
            itemToFocusAfterDelete = undefined;
          }
        });
      }
      /** @private */

    }, {
      key: "_onTagConnected",
      value: function _onTagConnected(event) {
        event.stopImmediatePropagation();
        var item = event.target;

        this._prepareItem(item);
      }
      /**
       Inherited from {@link BaseFormField#reset}.
       */

    }, {
      key: "reset",
      value: function reset() {
        // reset the values to the initial values
        this.values = this._initialValues;
      }
      /** @ignore */

    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        var _this4 = this;

        _get(_getPrototypeOf(TagList.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$5); // adds the role to support accessibility

        this.setAttribute('role', 'grid');
        this.setAttribute('aria-live', 'off');
        this.setAttribute('aria-atomic', 'false');
        this.setAttribute('aria-relevant', 'additions'); // Since tagList can have multiple values, we have to store them all to be able to reset them

        if (this.hasAttribute('value')) {
          this._initialValues = [this.getAttribute('value')];
        } else {
          this._initialValues = this.items.getAll().map(function (item) {
            return itemValueFromDOM(item);
          });
        } // Prepare items


        this.items.getAll().forEach(function (item) {
          _this4._prepareItem(item);
        });
      }
    }, {
      key: "values",
      get: function get() {
        return this.items.getAll().map(function (item) {
          return item.value;
        });
      },
      set: function set(values) {
        var _this5 = this;

        if (Array.isArray(values)) {
          this.items.clear();
          values.forEach(function (value) {
            var item = new Tag().set({
              label: {
                innerHTML: value
              },
              value: value
            });

            _this5._attachInputToItem(item);

            _this5.items.add(item);
          });
        }
      }
      /**
       The Collection Interface that allows interacting with the items that the component contains.
        @type {Collection}
       @readonly
       */

    }, {
      key: "items",
      get: function get() {
        // just init on demand
        if (!this._items) {
          this._items = new Collection$1({
            host: this,
            itemTagName: ITEM_TAGNAME
          });
        }

        return this._items;
      }
      /**
       Name used to submit the data in a form.
       @type {String}
       @default ""
       @htmlattribute name
       @htmlattributereflected
       */

    }, {
      key: "name",
      get: function get() {
        return this._name || '';
      },
      set: function set(value) {
        var _this6 = this;

        this._name = transform.string(value);

        this._reflectAttribute('name', value);

        this.items.getAll().forEach(function (item) {
          if (item._input) {
            item._input.name = _this6._name;
          }
        });
      }
      /**
       This field's current value.
       @type {String}
       @default ""
       @htmlattribute value
       */

    }, {
      key: "value",
      get: function get() {
        var all = this.items.getAll();
        return all.length ? all[0].value : '';
      },
      set: function set(value) {
        this.items.clear();

        if (value) {
          var item = new Tag().set({
            label: {
              innerHTML: value
            },
            value: value
          });

          this._attachInputToItem(item);

          this.items.add(item);
        }
      }
      /**
       Whether this field is disabled or not.
       @type {Boolean}
       @default false
       @htmlattribute disabled
       @htmlattributereflected
       */

    }, {
      key: "disabled",
      get: function get() {
        return this._disabled || false;
      },
      set: function set(value) {
        var _this7 = this;

        this._disabled = transform.booleanAttr(value);

        this._reflectAttribute('disabled', this._disabled);

        this.items.getAll().forEach(function (item) {
          item.classList.toggle('is-disabled', _this7._disabled);

          if (item._input) {
            item._input.disabled = _this7._disabled;
          }
        }); // a11y

        this[this._disabled ? 'setAttribute' : 'removeAttribute']('aria-disabled', this._disabled);
      } // JSDoc inherited

    }, {
      key: "invalid",
      get: function get() {
        return _get(_getPrototypeOf(TagList.prototype), "invalid", this);
      },
      set: function set(value) {
        var _this8 = this;

        _set(_getPrototypeOf(TagList.prototype), "invalid", value, this, true);

        this.items.getAll().forEach(function (item) {
          item.classList.toggle('is-invalid', _this8._invalid);
        });
      }
      /**
       Whether this field is readOnly or not. Indicating that the user cannot modify the value of the control.
       @type {Boolean}
       @default false
       @htmlattribute readonly
       @htmlattributereflected
       */

    }, {
      key: "readOnly",
      get: function get() {
        return this._readOnly || false;
      },
      set: function set(value) {
        var _this9 = this;

        this._readOnly = transform.booleanAttr(value);

        this._reflectAttribute('readonly', this._readOnly);

        this.items.getAll().forEach(function (item) {
          item.closable = !_this9._readOnly;
        });
      }
      /**
       Whether this field is required or not.
       @type {Boolean}
       @default false
       @htmlattribute required
       @htmlattributereflected
       */

    }, {
      key: "required",
      get: function get() {
        return this._required || false;
      },
      set: function set(value) {
        this._required = transform.booleanAttr(value);

        this._reflectAttribute('required', this._required);
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(TagList), "observedAttributes", this).concat(['closable', 'value', 'quiet', 'multiline', 'size', 'color']);
      }
    }]);

    return TagList;
  }(BaseFormField(BaseComponent(HTMLElement)));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons.extend(strings, {
    'coral-component-taglist': translations$2
  }); // Expose component on the Coral namespace

  commons._define('coral-tag', Tag);

  commons._define('coral-taglist', TagList);

  Tag.Label = TagLabel;

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var translations$3 = {
    "en-US": {
      "List": "List"
    },
    "fr-FR": {
      "List": "Liste"
    },
    "de-DE": {
      "List": "Liste"
    },
    "it-IT": {
      "List": "Elenco"
    },
    "es-ES": {
      "List": "Mostrar"
    },
    "pt-BR": {
      "List": "Lista"
    },
    "ja-JP": {
      "List": "ãªã¹ã"
    },
    "ko-KR": {
      "List": "ëª©ë¡"
    },
    "zh-CN": {
      "List": "åè¡¨"
    },
    "zh-TW": {
      "List": "æ¸å®"
    },
    "nl-NL": {
      "List": "Lijst"
    },
    "da-DK": {
      "List": "Liste"
    },
    "fi-FI": {
      "List": "Lista"
    },
    "nb-NO": {
      "List": "Liste"
    },
    "sv-SE": {
      "List": "Lista"
    },
    "cs-CZ": {
      "List": "Seznam"
    },
    "pl-PL": {
      "List": "Lista"
    },
    "ru-RU": {
      "List": "ÑÐ¿Ð¸ÑÐ¾Ðº"
    },
    "tr-TR": {
      "List": "Liste"
    }
  };

  var CLASSNAME$6 = '_coral-Menu';
  /**
   Enumeration for {@link BaseList} interactions.

   @typedef {Object} ListInteractionEnum

   @property {String} ON
   Keyboard interaction is enabled.
   @property {String} OFF
   Keyboard interaction is disabled.
   */

  var interaction = {
    ON: 'on',
    OFF: 'off'
  };
  /**
   @base BaseList
   @classdesc The base element for List components
   */

  var BaseList = function BaseList(superClass) {
    return /*#__PURE__*/function (_superClass) {
      _inherits(_class, _superClass);

      var _super = _createSuper(_class);

      /** @ignore */
      function _class() {
        var _this;

        _classCallCheck(this, _class);

        _this = _super.call(this);
        _this._events = {
          'mouseenter': '_onMouseEnter',
          // Keyboard interaction
          'key:down [coral-list-item]': '_focusNextItem',
          'key:right [coral-list-item]': '_focusNextItem',
          'key:left [coral-list-item]': '_focusPreviousItem',
          'key:up [coral-list-item]': '_focusPreviousItem',
          'key:pageup [coral-list-item]': '_focusPreviousItem',
          'key:pagedown [coral-list-item]': '_focusNextItem',
          'key:home [coral-list-item]': '_focusFirstItem',
          'key:end [coral-list-item]': '_focusLastItem'
        };
        return _this;
      }
      /**
       The Collection Interface that allows interacting with the items that the component contains.
        @type {SelectableCollection}
       @readonly
       */


      _createClass(_class, [{
        key: "_eventIsAtTarget",

        /**
         Returns true if the event is at the matched target.
          @private
         */
        value: function _eventIsAtTarget(event) {
          var target = event.target;
          var listItem = event.matchedTarget;
          var isAtTarget = target === listItem;

          if (isAtTarget) {
            // Don't let arrow keys etc scroll the page
            event.preventDefault();
          }

          return isAtTarget;
        }
      }, {
        key: "_onMouseEnter",
        value: function _onMouseEnter() {
          if (this.contains(document.activeElement)) {
            document.activeElement.blur();
          }
        }
        /** @private */

      }, {
        key: "_focusFirstItem",
        value: function _focusFirstItem(event) {
          if (this.interaction === interaction.OFF || !this._eventIsAtTarget(event)) {
            return;
          }

          var items = this._getSelectableItems();

          items[0].focus();
        }
        /** @private */

      }, {
        key: "_focusLastItem",
        value: function _focusLastItem(event) {
          if (this.interaction === interaction.OFF || !this._eventIsAtTarget(event)) {
            return;
          }

          var items = this._getSelectableItems();

          items[items.length - 1].focus();
        }
        /** @private */

      }, {
        key: "_focusNextItem",
        value: function _focusNextItem(event) {
          if (this.interaction === interaction.OFF || !this._eventIsAtTarget(event)) {
            return;
          }

          var target = event.matchedTarget;

          var items = this._getSelectableItems();

          var index = items.indexOf(target);

          if (index === -1) {
            // Invalid state
            return;
          }

          if (index < items.length - 1) {
            items[index + 1].focus();
          } else {
            items[0].focus();
          }
        }
        /** @private */

      }, {
        key: "_focusPreviousItem",
        value: function _focusPreviousItem(event) {
          if (this.interaction === interaction.OFF || !this._eventIsAtTarget(event)) {
            return;
          }

          var target = event.matchedTarget;

          var items = this._getSelectableItems();

          var index = items.indexOf(target);

          if (index === -1) {
            // Invalid state
            return;
          }

          if (index > 0) {
            items[index - 1].focus();
          } else {
            items[items.length - 1].focus();
          }
        }
        /** @private */

      }, {
        key: "_getSelectableItems",
        value: function _getSelectableItems() {
          // Also checks if item is visible
          return this.items._getSelectableItems().filter(function (item) {
            return !item.hasAttribute('hidden') && item.offsetParent;
          });
        }
        /** @ignore */

      }, {
        key: "focus",
        value: function focus() {
          if (!this.contains(document.activeElement)) {
            var items = this._getSelectableItems();

            if (items.length > 0) {
              items[0].focus();
            }
          }
        }
        /**
         Returns {@link BaseList} interaction options.
          @return {ListInteractionEnum}
         */

      }, {
        key: "render",

        /** @ignore */
        value: function render() {
          _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

          this.classList.add(CLASSNAME$6); // Default reflected attributes

          if (!this._interaction) {
            this.interaction = interaction.ON;
          }
        }
      }, {
        key: "items",
        get: function get() {
          // Construct the collection on first request:
          if (!this._items) {
            this._items = new SelectableCollection({
              itemTagName: this._itemTagName,
              itemBaseTagName: this._itemBaseTagName,
              itemSelector: 'coral-list-item, button[is="coral-buttonlist-item"], a[is="coral-anchorlist-item"]',
              host: this
            });
          }

          return this._items;
        }
        /** @private */

      }, {
        key: "_itemTagName",
        get: function get() {
          // Used for Collection
          return 'coral-list-item';
        }
        /**
         Whether interaction with the component is enabled. See {@link ListInteractionEnum}.
          @type {String}
         @default ListInteractionEnum.ON
         @htmlattribute interaction
         @htmlattributereflected
         */

      }, {
        key: "interaction",
        get: function get() {
          return this._interaction || interaction.ON;
        },
        set: function set(value) {
          value = transform.string(value).toLowerCase();
          this._interaction = validate.enumeration(interaction)(value) && value || interaction.ON;

          this._reflectAttribute('interaction', this._interaction);
        }
      }], [{
        key: "interaction",
        get: function get() {
          return interaction;
        }
        /** @ignore */

      }, {
        key: "observedAttributes",
        get: function get() {
          return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['interaction']);
        }
      }]);

      return _class;
    }(superClass);
  };

  var CLASSNAME$7 = '_coral-Menu-item';
  /**
   @base BaseListItem
   @classdesc The base element for List Item components
   */

  var BaseListItem = function BaseListItem(superClass) {
    return /*#__PURE__*/function (_BaseLabellable) {
      _inherits(_class, _BaseLabellable);

      var _super = _createSuper(_class);

      /** @ignore */
      function _class() {
        var _thisSuper, _this;

        _classCallCheck(this, _class);

        _this = _super.call(this); // Templates

        _this._elements = {
          // Fetch or create the content zone element
          content: _this.querySelector('coral-list-item-content') || document.createElement('coral-list-item-content')
        };

        _get((_thisSuper = _assertThisInitialized(_this), _getPrototypeOf(_class.prototype)), "_observeLabel", _thisSuper).call(_thisSuper);

        return _this;
      }
      /**
       The content of the help item.
        @type {ListItemContent}
       @contentzone
       */


      _createClass(_class, [{
        key: "_getIconElement",
        value: function _getIconElement() {
          if (!this._elements.icon) {
            this._elements.icon = this.querySelector('._coral-Menu-item-icon') || new Icon();
            this._elements.icon.size = Icon.size.SMALL;

            this._elements.icon.classList.add('_coral-Menu-item-icon');
          }

          return this._elements.icon;
        }
      }, {
        key: "render",

        /** @ignore */
        value: function render() {
          _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

          this.classList.add(CLASSNAME$7); // The attribute that makes different types of list items co-exist
          // This is also used for event delegation

          this.setAttribute('coral-list-item', ''); // Fetch or create the content content zone element

          var content = this._elements.content; // This stops the content zone from being voracious

          if (!content.parentNode) {
            // move the contents of the item into the content zone
            while (this.firstChild) {
              content.appendChild(this.firstChild);
            }
          } // Assign the content zones, moving them into place in the process


          this.icon = this.icon;
          this.content = content;
        }
      }, {
        key: "content",
        get: function get() {
          return this._getContentZone(this._elements.content);
        },
        set: function set(value) {
          var _this2 = this;

          this._setContentZone('content', value, {
            handle: 'content',
            tagName: 'coral-list-item-content',
            insert: function insert(content) {
              content.classList.add("".concat(CLASSNAME$7, "Label"));

              _this2.appendChild(content);

              _get(_getPrototypeOf(_class.prototype), "_toggleIconAriaHidden", _this2).call(_this2);
            }
          });
        }
        /**
         Whether this item is disabled.
          @default false
         @type {Boolean}
         @htmlattribute disabled
         @htmlattributereflected
         */

      }, {
        key: "disabled",
        get: function get() {
          return this._disabled || false;
        },
        set: function set(value) {
          this._disabled = transform.booleanAttr(value);

          this._reflectAttribute('disabled', this._disabled);

          this.classList.toggle('is-disabled', this._disabled);
          this[this._disabled ? 'setAttribute' : 'removeAttribute']('aria-disabled', this._disabled);
        }
        /**
         The icon to display. See {@link Icon}.
          @type {String}
         @default ""
         @htmlattribute icon
         */

      }, {
        key: "icon",
        get: function get() {
          var el = this._getIconElement();

          return el.icon;
        },
        set: function set(value) {
          var el = this._getIconElement();

          if (transform.string(value) === '') {
            el.remove();
          } else {
            this.insertBefore(el, this.firstChild);
          }

          el.icon = value;

          _get(_getPrototypeOf(_class.prototype), "_toggleIconAriaHidden", this).call(this);
        }
      }, {
        key: "_contentZones",
        get: function get() {
          return {
            'coral-list-item-content': 'content'
          };
        }
        /** @ignore */

      }], [{
        key: "observedAttributes",
        get: function get() {
          return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['disabled', 'icon']);
        }
      }]);

      return _class;
    }(BaseLabellable(superClass));
  };

  /**
   @class Coral.List
   @classdesc A List component that supports multi-line text, icons, and text wrapping with ellipsis.
   @htmltag coral-list
   @extends {HTMLElement}
   @extends {BaseComponent}
   @extends {BaseList}
   */

  var List = /*#__PURE__*/function (_BaseList) {
    _inherits(List, _BaseList);

    var _super = _createSuper(List);

    /** @ignore */
    function List() {
      var _this;

      _classCallCheck(this, List);

      _this = _super.call(this); // Events

      _this._delegateEvents(_this._events);

      return _this;
    }

    return List;
  }(BaseList(BaseComponent(HTMLElement)));

  var CLASSNAME$8 = '_coral-Menu-divider';
  /**
   @class Coral.List.Divider
   @classdesc The List divider
   @htmltag coral-list-divider
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var ListDivider = /*#__PURE__*/function (_BaseComponent) {
    _inherits(ListDivider, _BaseComponent);

    var _super = _createSuper(ListDivider);

    function ListDivider() {
      _classCallCheck(this, ListDivider);

      return _super.apply(this, arguments);
    }

    _createClass(ListDivider, [{
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(ListDivider.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$8); // a11y

        this.setAttribute('role', 'separator');
      }
    }]);

    return ListDivider;
  }(BaseComponent(HTMLElement));

  /**
   @class Coral.List.Item
   @classdesc A List item component
   @htmltag coral-list-item
   @extends {HTMLElement}
   @extends {BaseComponent}
   @extends {BaseListItem}
   */

  var ListItem = /*#__PURE__*/function (_BaseListItem) {
    _inherits(ListItem, _BaseListItem);

    var _super = _createSuper(ListItem);

    /** @ignore */
    function ListItem() {
      var _this;

      _classCallCheck(this, ListItem);

      _this = _super.call(this); // Events

      _this._delegateEvents(_this._events);

      return _this;
    }

    return ListItem;
  }(BaseListItem(BaseComponent(HTMLElement)));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.List.Item.Content
   @classdesc The List item content
   @htmltag coral-list-item-content
   @return {HTMLElement}
   */
  var ListItemContent = (function () {
    return document.createElement('coral-list-item-content');
  });

  var CLASSNAME$9 = '_coral-AnchorList';
  /**
   @class Coral.AnchorList
   @classdesc An AnchorList component that supports multi-line text, icons, and text wrapping with ellipsis.
   @htmltag coral-anchorlist
   @extends {HTMLElement}
   @extends {BaseComponent}
   @extends {BaseList}
   */

  var AnchorList = /*#__PURE__*/function (_BaseList) {
    _inherits(AnchorList, _BaseList);

    var _super = _createSuper(AnchorList);

    /** @ignore */
    function AnchorList() {
      var _this;

      _classCallCheck(this, AnchorList);

      _this = _super.call(this); // Events

      _this._delegateEvents(commons.extend(_this._events, {
        'click [coral-list-item]': '_onItemClick'
      }));

      return _this;
    }
    /** @private */


    _createClass(AnchorList, [{
      key: "_onItemClick",
      value: function _onItemClick(event) {
        this._trackEvent('click', 'coral-anchorlist-item', event, event.matchedTarget);
      }
      /** @ignore */

    }, {
      key: "render",
      value: function render() {
        _get(_getPrototypeOf(AnchorList.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$9);
      }
    }, {
      key: "_itemTagName",
      get: function get() {
        // Used for Collection
        return 'coral-anchorlist-item';
      }
      /** @private */

    }, {
      key: "_itemBaseTagName",
      get: function get() {
        // Used for Collection
        return 'a';
      }
    }]);

    return AnchorList;
  }(BaseList(BaseComponent(HTMLElement)));

  var CLASSNAME$a = '_coral-AnchorList-item';
  /**
   @class Coral.AnchorList.Item
   @classdesc An AnchorList item component
   @htmltag coral-anchorlist-item
   @extends {HTMLAnchorElement}
   @extends {BaseComponent}
   @extends {BaseListItem}
   */

  var AnchorListItem = /*#__PURE__*/function (_BaseListItem) {
    _inherits(AnchorListItem, _BaseListItem);

    var _super = _createSuper(AnchorListItem);

    /** @ignore */
    function AnchorListItem() {
      var _this;

      _classCallCheck(this, AnchorListItem);

      _this = _super.call(this); // Events

      _this._delegateEvents({
        click: '_onClick'
      });

      return _this;
    }
    /**
     Whether this field is disabled or not.
     @type {Boolean}
     @default false
     @htmlattribute disabled
     @htmlattributereflected
     */


    _createClass(AnchorListItem, [{
      key: "_onClick",

      /** @private */
      value: function _onClick(event) {
        // Support disabled property
        if (this.disabled) {
          event.preventDefault();
        }
      }
      /** @ignore */

    }, {
      key: "render",
      value: function render() {
        _get(_getPrototypeOf(AnchorListItem.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$a);
      }
    }, {
      key: "disabled",
      get: function get() {
        return _get(_getPrototypeOf(AnchorListItem.prototype), "disabled", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(AnchorListItem.prototype), "disabled", value, this, true);

        if (this.disabled) {
          // It's not tabbable anymore
          this.setAttribute('tabindex', '-1');
        } else {
          // Now it's tabbable
          this.setAttribute('tabindex', '0');
        }
      }
      /**
       Inherited from {@link BaseComponent#trackingElement}.
       */

    }, {
      key: "trackingElement",
      get: function get() {
        return typeof this._trackingElement === 'undefined' ? // keep spaces to only 1 max and trim. this mimics native html behaviors
        (this.content || this).textContent.replace(/\s{2,}/g, ' ').trim() : this._trackingElement;
      },
      set: function set(value) {
        _set(_getPrototypeOf(AnchorListItem.prototype), "trackingElement", value, this, true);
      }
    }]);

    return AnchorListItem;
  }(BaseListItem(BaseComponent(HTMLAnchorElement)));

  var CLASSNAME$b = '_coral-ButtonList';
  /**
   @class Coral.ButtonList
   @classdesc A ButtonList component that supports multi-line text, icons, and text wrapping with ellipsis.
   @htmltag coral-buttonlist
   @extends {HTMLElement}
   @extends {BaseComponent}
   @extends {BaseList}
   */

  var ButtonList = /*#__PURE__*/function (_BaseList) {
    _inherits(ButtonList, _BaseList);

    var _super = _createSuper(ButtonList);

    /** @ignore */
    function ButtonList() {
      var _this;

      _classCallCheck(this, ButtonList);

      _this = _super.call(this); // Events

      _this._delegateEvents(commons.extend(_this._events, {
        'click [coral-list-item]': '_onItemClick'
      }));

      return _this;
    }
    /** @private */


    _createClass(ButtonList, [{
      key: "_onItemClick",
      value: function _onItemClick(event) {
        this._trackEvent('click', 'coral-buttonlist-item', event, event.matchedTarget);
      }
      /** @ignore */

    }, {
      key: "render",
      value: function render() {
        _get(_getPrototypeOf(ButtonList.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$b);
      }
    }, {
      key: "_itemTagName",
      get: function get() {
        // Used for Collection
        return 'coral-buttonlist-item';
      }
      /** @private */

    }, {
      key: "_itemBaseTagName",
      get: function get() {
        // Used for Collection
        return 'button';
      }
    }]);

    return ButtonList;
  }(BaseList(BaseComponent(HTMLElement)));

  var CLASSNAME$c = '_coral-ButtonList-item';
  /**
   @class Coral.ButtonList.Item
   @classdesc An ButtonList item component
   @htmltag coral-buttonlist-item
   @extends {HTMLButtonElement}
   @extends {BaseComponent}
   @extends {BaseListItem}
   */

  var ButtonListItem = /*#__PURE__*/function (_BaseListItem) {
    _inherits(ButtonListItem, _BaseListItem);

    var _super = _createSuper(ButtonListItem);

    function ButtonListItem() {
      _classCallCheck(this, ButtonListItem);

      return _super.apply(this, arguments);
    }

    _createClass(ButtonListItem, [{
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(ButtonListItem.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$c);
      }
    }, {
      key: "trackingElement",

      /**
       Inherited from {@link BaseComponent#trackingElement}.
       */
      get: function get() {
        return typeof this._trackingElement === 'undefined' ? // keep spaces to only 1 max and trim. this mimics native html behaviors
        (this.content || this).textContent.replace(/\s{2,}/g, ' ').trim() : this._trackingElement;
      },
      set: function set(value) {
        _set(_getPrototypeOf(ButtonListItem.prototype), "trackingElement", value, this, true);
      }
    }]);

    return ButtonListItem;
  }(BaseListItem(BaseComponent(HTMLButtonElement)));

  var template$1 = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["track"] = document.createElement("div");
    el0.setAttribute("handle", "track");
    el0.className += " _coral-CircleLoader-track";
    frag.appendChild(el0);
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    var el2 = this["fills"] = document.createElement("div");
    el2.setAttribute("handle", "fills");
    el2.className += " _coral-CircleLoader-fills";
    var el3 = document.createTextNode("\n  ");
    el2.appendChild(el3);
    var el4 = document.createElement("div");
    el4.className += " _coral-CircleLoader-fillMask1";
    var el5 = document.createTextNode("\n    ");
    el4.appendChild(el5);
    var el6 = this["subMask1"] = document.createElement("div");
    el6.setAttribute("handle", "subMask1");
    el6.className += " _coral-CircleLoader-fillSubMask1";
    var el7 = document.createTextNode("\n      ");
    el6.appendChild(el7);
    var el8 = document.createElement("div");
    el8.className += " _coral-CircleLoader-fill";
    el6.appendChild(el8);
    var el9 = document.createTextNode("\n    ");
    el6.appendChild(el9);
    el4.appendChild(el6);
    var el10 = document.createTextNode("\n  ");
    el4.appendChild(el10);
    el2.appendChild(el4);
    var el11 = document.createTextNode("\n  ");
    el2.appendChild(el11);
    var el12 = document.createElement("div");
    el12.className += " _coral-CircleLoader-fillMask2";
    var el13 = document.createTextNode("\n    ");
    el12.appendChild(el13);
    var el14 = this["subMask2"] = document.createElement("div");
    el14.setAttribute("handle", "subMask2");
    el14.className += " _coral-CircleLoader-fillSubMask2";
    var el15 = document.createTextNode("\n      ");
    el14.appendChild(el15);
    var el16 = document.createElement("div");
    el16.className += " _coral-CircleLoader-fill";
    el14.appendChild(el16);
    var el17 = document.createTextNode("\n    ");
    el14.appendChild(el17);
    el12.appendChild(el14);
    var el18 = document.createTextNode("\n  ");
    el12.appendChild(el18);
    el2.appendChild(el12);
    var el19 = document.createTextNode("\n");
    el2.appendChild(el19);
    frag.appendChild(el2);
    var el20 = document.createTextNode("\n\n");
    frag.appendChild(el20);
    return frag;
  };

  /**
   Enumeration for {@link Wait} variants.

   @typedef {Object} WaitVariantEnum

   @property {String} DEFAULT
   The default variant.
   @property {String} DOTS
   Not supported. Falls back to DEFAULT.
   */

  var variant$3 = {
    DEFAULT: 'default',
    DOTS: 'dots'
  };
  /**
   Enumeration for {@link Wait} sizes.

   @typedef {Object} WaitSizeEnum

   @property {String} SMALL
   A small wait indicator.
   @property {String} MEDIUM
   A medium wait indicator. This is the default size.
   @property {String} LARGE
   A large wait indicator.
   */

  var size$3 = {
    SMALL: 'S',
    MEDIUM: 'M',
    LARGE: 'L'
  }; // the waits's base classname

  var CLASSNAME$d = '_coral-CircleLoader';
  /**
   @class Coral.Wait
   @classdesc A Wait component to be used to indicate a process that is in-progress for an indefinite amount of time.
   When the time is known, {@link Progress} should be used instead.
   @htmltag coral-wait
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var Wait = /*#__PURE__*/function (_BaseComponent) {
    _inherits(Wait, _BaseComponent);

    var _super = _createSuper(Wait);

    function Wait() {
      var _this;

      _classCallCheck(this, Wait);

      _this = _super.call(this); // Prepare templates

      _this._elements = {};
      template$1.call(_this._elements);
      return _this;
    }
    /**
     The size of the wait indicator. Currently 'S' (the default), 'M' and 'L' are available.
     See {@link WaitSizeEnum}.
      @type {String}
     @default WaitSizeEnum.MEDIUM
     @htmlattribute size
     @htmlattributereflected
     */


    _createClass(Wait, [{
      key: "attributeChangedCallback",

      /** @ignore */
      value: function attributeChangedCallback(name, oldValue, value) {
        if (name === 'indeterminate' && transform.booleanAttr(value)) {
          // Remember current value in case indeterminate is toggled back
          this._oldValue = this._value || 0;
        }

        _get(_getPrototypeOf(Wait.prototype), "attributeChangedCallback", this).call(this, name, oldValue, value);
      }
      /** @ignore */

    }, {
      key: "render",
      value: function render() {
        _get(_getPrototypeOf(Wait.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$d); // ARIA

        this.setAttribute('role', 'progressbar'); // Default reflected attributes

        if (!this._size) {
          this.size = size$3.MEDIUM;
        }

        if (!this._variant) {
          this.variant = variant$3.DEFAULT;
        } // If no value is specified, indeterminate is set


        if (!this._value) {
          this.indeterminate = true;
        } // Centering reads the size


        if (this.centered) {
          this.centered = this.centered;
        } // Support cloneNode


        var template = this.querySelectorAll('._coral-CircleLoader-track, ._coral-CircleLoader-fills');

        for (var i = 0; i < template.length; i++) {
          template[i].remove();
        } // Render template


        this.appendChild(this._elements.track);
        this.appendChild(this._elements.fills);
      }
      /**
       Triggered when the {@link Wait} value is changed.
        @typedef {CustomEvent} coral-wait:change
       */

    }, {
      key: "size",
      get: function get() {
        return this._size || size$3.MEDIUM;
      },
      set: function set(value) {
        value = transform.string(value).toUpperCase();
        this._size = validate.enumeration(size$3)(value) && value || size$3.MEDIUM;

        this._reflectAttribute('size', this._size); // large css change


        this.classList.toggle("".concat(CLASSNAME$d, "--large"), this._size === size$3.LARGE); // small css change

        this.classList.toggle("".concat(CLASSNAME$d, "--small"), this._size === size$3.SMALL);
      }
      /**
       Whether the component is centered or not. The container needs to have the style <code>position: relative</code>
       for the centering to work correctly.
       @type {Boolean}
       @default false
       @htmlattribute centered
       @htmlattributereflected
       */

    }, {
      key: "centered",
      get: function get() {
        return this._centered || false;
      },
      set: function set(value) {
        this._centered = transform.booleanAttr(value);

        this._reflectAttribute('centered', this._centered);

        this.classList.toggle("".concat(CLASSNAME$d, "--centered"), this._centered);
      }
      /**
       The wait's variant. See {@link WaitVariantEnum}.
        @type {String}
       @default WaitVariantEnum.DEFAULT
       @htmlattribute variant
       @htmlattributereflected
       */

    }, {
      key: "variant",
      get: function get() {
        return this._variant || variant$3.DEFAULT;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        this._variant = validate.enumeration(variant$3)(value) && value || variant$3.DEFAULT;

        this._reflectAttribute('variant', this._variant);
      }
      /**
       Whether to hide the current value and show an animation. Set to true for operations whose progress cannot be
       determined.
        @type {Boolean}
       @default false
       @htmlattribute indeterminate
       @htmlattributereflected
       */

    }, {
      key: "indeterminate",
      get: function get() {
        return this._indeterminate || false;
      },
      set: function set(value) {
        this._indeterminate = transform.booleanAttr(value);

        this._reflectAttribute('indeterminate', this._indeterminate);

        if (this._indeterminate) {
          this.classList.add("".concat(CLASSNAME$d, "--indeterminate")); // ARIA: Remove attributes

          this.removeAttribute('aria-valuenow');
          this.removeAttribute('aria-valuemin');
          this.removeAttribute('aria-valuemax');
          this.value = 0;
        } else {
          this.classList.remove("".concat(CLASSNAME$d, "--indeterminate")); // ARIA: Add attributes

          this.setAttribute('aria-valuemin', '0');
          this.setAttribute('aria-valuemax', '100');
          this.value = this._oldValue;
        }
      }
      /**
       The current progress in percent. If no value is set on initialization, wait is forced into indeterminate state.
        @type {Number}
       @default 0
       @emits {coral-wait:change}
       @htmlattribute value
       @htmlattributereflected
       */

    }, {
      key: "value",
      get: function get() {
        return this.hasAttribute('indeterminate') ? 0 : this._value || 0;
      },
      set: function set(value) {
        value = transform.number(value) || 0; // Stay within bounds

        if (value > 100) {
          value = 100;
        } else if (value < 0) {
          value = 0;
        }

        this._value = value;

        this._reflectAttribute('value', this._value);

        var subMask1 = this._elements.subMask1;
        var subMask2 = this._elements.subMask2;

        if (!this.hasAttribute('indeterminate')) {
          var angle;

          if (value > 0 && value <= 50) {
            angle = -180 + value / 50 * 180;
            subMask1.style.transform = "rotate(".concat(angle, "deg)");
            subMask2.style.transform = 'rotate(-180deg)';
          } else if (value > 50) {
            angle = -180 + (value - 50) / 50 * 180;
            subMask1.style.transform = 'rotate(0deg)';
            subMask2.style.transform = "rotate(".concat(angle, "deg)");
          } else {
            subMask1.style.transform = '';
            subMask2.style.transform = '';
          } // ARIA: Reflect value for screenreaders


          this.setAttribute('aria-valuenow', this._value);
          this.setAttribute('aria-valuemin', '0');
          this.setAttribute('aria-valuemax', '100');
        } else {
          subMask1.style.transform = '';
          subMask2.style.transform = '';
        }

        this.trigger('coral-wait:change');
      }
      /**
       Returns {@link Wait} sizes.
        @return {WaitSizeEnum}
       */

    }], [{
      key: "size",
      get: function get() {
        return size$3;
      }
      /**
       Returns {@link Wait} variants.
        @return {WaitVariantEnum}
       */

    }, {
      key: "variant",
      get: function get() {
        return variant$3;
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(Wait), "observedAttributes", this).concat(['size', 'centered', 'variant', 'value', 'indeterminate']);
      }
    }]);

    return Wait;
  }(BaseComponent(HTMLElement));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons._define('coral-wait', Wait);

  var template$2 = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["loadIndicator"] = document.createElement("div");
    el0.setAttribute("handle", "loadIndicator");
    el0.className += " _coral-SelectList-loading";
    var el1 = document.createTextNode("\n  ");
    el0.appendChild(el1);
    var el2 = document.createElement("coral-wait");
    el2.setAttribute("centered", "");
    el0.appendChild(el2);
    var el3 = document.createTextNode("\n");
    el0.appendChild(el3);
    frag.appendChild(el0);
    var el4 = document.createTextNode("\n");
    frag.appendChild(el4);
    return frag;
  };

  var KEYPRESS_TIMEOUT_DURATION = 1000;
  /**
   The distance, in pixels, from the bottom of the SelectList at which we trigger a scrollbottom event. For example, a
   value of 50 would indicate a scrollbottom event should be triggered when the user scrolls to within 50 pixels of the
   bottom.

   @type {Number}
   @ignore
   */

  var SCROLL_BOTTOM_THRESHOLD = 50;
  /**
   The number of milliseconds for which scroll events should be debounced.

   @type {Number}
   @ignore
   */

  var SCROLL_DEBOUNCE = 100;
  /** @ignore */

  var ITEM_TAG_NAME = 'coral-selectlist-item';
  /** @ignore */

  var GROUP_TAG_NAME = 'coral-selectlist-group';
  var CLASSNAME$e = '_coral-Menu';
  /**
   @class Coral.SelectList
   @classdesc A SelectList component is a selectable list of items.
   @htmltag coral-selectlist
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var SelectList = /*#__PURE__*/function (_BaseComponent) {
    _inherits(SelectList, _BaseComponent);

    var _super = _createSuper(SelectList);

    /** @ignore */
    function SelectList() {
      var _this;

      _classCallCheck(this, SelectList);

      _this = _super.call(this); // Attach events

      _this._delegateEvents({
        'scroll': '_onScroll',
        'mouseenter': '_onMouseEnter',
        'capture:blur': '_onBlur',
        'click coral-selectlist-item': '_onItemClick',
        'key:space coral-selectlist-item': '_onToggleItemKey',
        'key:return coral-selectlist-item': '_onToggleItemKey',
        'key:pageup coral-selectlist-item': '_focusPreviousItem',
        'key:left coral-selectlist-item': '_focusPreviousItem',
        'key:up coral-selectlist-item': '_focusPreviousItem',
        'key:pagedown coral-selectlist-item': '_focusNextItem',
        'key:right coral-selectlist-item': '_focusNextItem',
        'key:down coral-selectlist-item': '_focusNextItem',
        'key:home coral-selectlist-item': '_onHomeKey',
        'key:end coral-selectlist-item': '_onEndKey',
        'keypress coral-selectlist-item': '_onKeyPress',
        // private
        'coral-selectlist-item:_selectedchanged': '_onItemSelectedChanged'
      });

      _this._keypressTimeoutDuration = KEYPRESS_TIMEOUT_DURATION; // Templates

      _this._elements = {};
      template$2.call(_this._elements); // Used for eventing

      _this._oldSelection = []; // Used for interaction

      _this._keypressTimeoutID = null;
      _this._keypressSearchString = ''; // we correctly bind the scroll event

      _this._onDebouncedScroll = _this._onDebouncedScroll.bind(_assertThisInitialized(_this)); // Init the collection mutation observer

      _this.items._startHandlingItems(true);

      return _this;
    }
    /**
     The Collection Interface that allows interacting with the {@link SelectListGroup} elements that the
     SelectList contains. This includes items nested inside groups. To manage items contained within a specific
     group, see {@link SelectListGroup#items}.
      @type {SelectableCollection}
     @readonly
     */


    _createClass(SelectList, [{
      key: "_toggleItemSelection",

      /** @private */
      value: function _toggleItemSelection(item) {
        if (item) {
          var beforeChangeEvent = this.trigger('coral-selectlist:beforechange', {
            item: item
          });

          if (!beforeChangeEvent.defaultPrevented) {
            item[item.hasAttribute('selected') ? 'removeAttribute' : 'setAttribute']('selected', '');
          }
        }
      }
      /** @private */

    }, {
      key: "_onBlur",
      value: function _onBlur() {
        // required otherwise the latest item that had the focus would get it again instead of the selected item
        this._resetTabTarget();
      }
      /** @private */

    }, {
      key: "_onItemClick",
      value: function _onItemClick(event) {
        event.preventDefault();
        event.stopPropagation();
        var item = event.matchedTarget;

        this._toggleItemSelection(item);

        this._focusItem(item);
      }
      /** @private */

    }, {
      key: "_focusItem",
      value: function _focusItem(item) {
        if (item) {
          item.focus();
        }

        this._tabTarget = item;
      }
      /** @private */

    }, {
      key: "_onToggleItemKey",
      value: function _onToggleItemKey(event) {
        event.preventDefault();
        event.stopPropagation();
        var item = event.target;

        this._toggleItemSelection(item);

        this._focusItem(item);
      }
      /** @private */

    }, {
      key: "_focusPreviousItem",
      value: function _focusPreviousItem(event) {
        event.preventDefault();

        this._focusItem(this.items._getPreviousSelectable(event.target));
      }
      /** @private */

    }, {
      key: "_focusNextItem",
      value: function _focusNextItem(event) {
        event.preventDefault();

        this._focusItem(this.items._getNextSelectable(event.target));
      }
    }, {
      key: "_focusFirstItem",
      value: function _focusFirstItem() {
        this._focusItem(this.items._getFirstSelectable());
      }
    }, {
      key: "_focusLastItem",
      value: function _focusLastItem() {
        this._focusItem(this.items._getLastSelectable());
      }
      /** @private */

    }, {
      key: "_onHomeKey",
      value: function _onHomeKey(event) {
        event.preventDefault();

        this._focusFirstItem();
      }
      /** @private */

    }, {
      key: "_onEndKey",
      value: function _onEndKey(event) {
        event.preventDefault();

        this._focusLastItem();
      }
      /**
       Handles keypress event for alphanumeric search.
        @param {KeyboardEvent} event
       The keyboard event.
       @private
       */

    }, {
      key: "_onKeyPress",
      value: function _onKeyPress(event) {
        var _this2 = this;

        // The string entered when the key was pressed
        var newString = String.fromCharCode(event.which); // Clear the timeout before the _keypressSearchString is cleared

        window.clearTimeout(this._keypressTimeoutID); // If the character entered does not match the last character entered, append it to the _keypressSearchString

        if (newString !== this._keypressSearchString) {
          this._keypressSearchString += newString;
        } // Set a timeout so that _keypressSearchString is cleared after 1 second


        this._keypressTimeoutID = window.setTimeout(function () {
          _this2._keypressSearchString = '';
        }, this._keypressTimeoutDuration); // Search within selectable items

        var selectableItems = this.items._getSelectableItems().filter(function (item) {
          return !item.hasAttribute('hidden') && item.offsetParent;
        }); // Remember the index of the focused item within the array of selectable items


        var currentIndex = selectableItems.indexOf(this._tabTarget);
        this._keypressSearchString = this._keypressSearchString.trim().toLowerCase();
        var start; // If the currentIndex is -1, meaning no item has focus, start from the beginning

        if (currentIndex === -1) {
          start = 0;
        } else if (this._keypressSearchString.length === 1) {
          // Otherwise, if there is only one character to compare, start comparing from the next item after the currently
          // focused item. This allows us to iterate through items beginning with the same character
          start = currentIndex + 1;
        } else {
          start = currentIndex;
        }

        var newFocusItem;
        var comparison;
        var item; // Compare _keypressSearchString against item text until a match is found

        for (var i = start; i < selectableItems.length; i++) {
          item = selectableItems[i];
          comparison = item.textContent.trim().toLowerCase();

          if (comparison.indexOf(this._keypressSearchString) === 0) {
            newFocusItem = item;
            break;
          }
        } // If no match is found, continue searching for a match starting from the top


        if (!newFocusItem) {
          for (var j = 0; j < start; j++) {
            item = selectableItems[j];
            comparison = item.textContent.trim().toLowerCase();

            if (comparison.indexOf(this._keypressSearchString) === 0) {
              newFocusItem = item;
              break;
            }
          }
        } // If a match has been found, focus the matched item


        if (newFocusItem !== undefined) {
          this._focusItem(newFocusItem); // Keyboard is being used so apply focus-ring


          var focusedItem = this.querySelector('.focus-ring');

          if (focusedItem) {
            focusedItem.classList.remove('focus-ring');
          }

          newFocusItem.classList.add('focus-ring');
        }
      }
      /**
       Determine what item should get focus (if any) when the user tries to tab into the SelectList. This should be the
       first selected item, or the first selectable item otherwise. When neither is available, it cannot be tabbed into
       the SelectList.
        @private
       */

    }, {
      key: "_resetTabTarget",
      value: function _resetTabTarget() {
        var forceFirst = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

        var items = this.items._getAllSelected().filter(function (item) {
          return !item.hasAttribute('hidden') && item.offsetParent;
        });

        if (items.length === 0) {
          items = this.items._getSelectableItems().filter(function (item) {
            return !item.hasAttribute('hidden') && item.offsetParent;
          });
        }

        this._tabTarget = forceFirst ? items[0] : items.find(function (item) {
          return item.tabIndex === 0;
        }) || items[0];
      }
      /** @private */

    }, {
      key: "_onScroll",
      value: function _onScroll() {
        window.clearTimeout(this._scrollTimeout);
        this._scrollTimeout = window.setTimeout(this._onDebouncedScroll, SCROLL_DEBOUNCE);
      }
    }, {
      key: "_onMouseEnter",
      value: function _onMouseEnter() {
        if (this.contains(document.activeElement)) {
          document.activeElement.blur();
        }
      }
      /**
       @emits {coral-selectlist:scrollbottom}
        @private
       */

    }, {
      key: "_onDebouncedScroll",
      value: function _onDebouncedScroll() {
        if (this.scrollTop >= this.scrollHeight - this.clientHeight - SCROLL_BOTTOM_THRESHOLD) {
          this.trigger('coral-selectlist:scrollbottom');
        }
      }
      /** @private */

    }, {
      key: "_onItemSelectedChanged",
      value: function _onItemSelectedChanged(event) {
        event.stopImmediatePropagation();

        this._validateSelection(event.target);
      }
      /** @private */

    }, {
      key: "_validateSelection",
      value: function _validateSelection(item) {
        var _this3 = this;

        var selectedItems = this.selectedItems;

        if (!this.multiple) {
          // Last selected item wins if multiple selection while not allowed
          item = item || selectedItems[selectedItems.length - 1];

          if (item && item.hasAttribute('selected') && selectedItems.length > 1) {
            selectedItems.forEach(function (selectedItem) {
              if (selectedItem !== item) {
                // Don't trigger change events
                _this3._preventTriggeringEvents = true;
                selectedItem.removeAttribute('selected');
              }
            }); // We can trigger change events again

            this._preventTriggeringEvents = false;
          }
        }

        this._resetTabTarget();

        this._triggerChangeEvent();
      }
      /** @private */

    }, {
      key: "_triggerChangeEvent",
      value: function _triggerChangeEvent() {
        var selectedItems = this.selectedItems;
        var oldSelection = this._oldSelection;

        if (!this._preventTriggeringEvents && this._arraysAreDifferent(selectedItems, oldSelection)) {
          // We differentiate whether multiple is on or off and return an array or HTMLElement respectively
          if (this.multiple) {
            this.trigger('coral-selectlist:change', {
              oldSelection: oldSelection,
              selection: selectedItems
            });
          } else {
            // Return all items if we just switched from multiple=true to multiple=false and we had >1 selected items
            this.trigger('coral-selectlist:change', {
              oldSelection: oldSelection.length > 1 ? oldSelection : oldSelection[0] || null,
              selection: selectedItems[0] || null
            });
          }

          this._oldSelection = selectedItems;
        }
      }
      /** @private */

    }, {
      key: "_arraysAreDifferent",
      value: function _arraysAreDifferent(selection, oldSelection) {
        var diff = [];

        if (oldSelection.length === selection.length) {
          diff = oldSelection.filter(function (item) {
            return selection.indexOf(item) === -1;
          });
        } // since we guarantee that they are arrays, we can start by comparing their size


        return oldSelection.length !== selection.length || diff.length !== 0;
      }
      /** @ignore */

    }, {
      key: "focus",
      value: function focus() {
        // Avoids moving the focus once it is already inside the component
        if (!this.contains(document.activeElement)) {
          this._resetTabTarget();

          this._focusItem(this._tabTarget);
        }
      }
      /** @ignore */

    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        this.classList.add(CLASSNAME$e); // adds the role to support accessibility

        if (!this.hasAttribute('role')) {
          this.setAttribute('role', 'listbox');
        }

        if (!this.hasAttribute('aria-label')) {
          this.setAttribute('aria-label', i18n.get('List'));
        } // Don't trigger events once connected


        this._preventTriggeringEvents = true;

        this._validateSelection();

        this._preventTriggeringEvents = false;
        this._oldSelection = this.selectedItems;
      }
      /**
       Triggered when the user scrolls to near the bottom of the {@link SelectList}. This can be useful for when additional items can
       be loaded asynchronously (i.e., infinite scrolling).
        @typedef {CustomEvent} coral-selectlist:scrollbottom
       */

      /**
       Triggered before the {@link SelectList} selected item is changed on user interaction. Can be used to cancel selection.
        @typedef {CustomEvent} coral-selectlist:change
        @property {SelectListItem} event.detail.item
       The selected item.
       */

      /**
       Triggered when the {@link SelectList} selected item has changed.
        @typedef {CustomEvent} coral-selectlist:change
        @property {SelectListItem} detail.oldSelection
       The prior selected item(s).
       @property {SelectListItem} detail.selection
       The newly selected item(s).
       */

    }, {
      key: "groups",
      get: function get() {
        // just init on demand
        if (!this._groups) {
          this._groups = new SelectableCollection({
            host: this,
            itemTagName: GROUP_TAG_NAME,
            onItemAdded: this._validateSelection,
            onItemRemoved: this._validateSelection
          });
        }

        return this._groups;
      }
      /**
       The Collection Interface that allows interacting with the items that the component contains.
        @type {SelectableCollection}
       @readonly
       */

    }, {
      key: "items",
      get: function get() {
        // just init on demand
        if (!this._items) {
          this._items = new SelectableCollection({
            host: this,
            itemTagName: ITEM_TAG_NAME,
            onItemAdded: this._validateSelection,
            onItemRemoved: this._validateSelection
          });
        }

        return this._items;
      }
      /**
       The selected item in the SelectList.
        @type {HTMLElement}
       @readonly
       */

    }, {
      key: "selectedItem",
      get: function get() {
        return this.items._getAllSelected()[0] || null;
      }
      /**
       The selected items of the SelectList.
        @type {Array.<HTMLElement>}
       @readonly
       */

    }, {
      key: "selectedItems",
      get: function get() {
        return this.items._getAllSelected();
      }
      /**
       Indicates whether the SelectList accepts multiple selected items.
       @type {Boolean}
       @default false
       @htmlattribute multiple
       @htmlattributereflected
       */

    }, {
      key: "multiple",
      get: function get() {
        return this._multiple || false;
      },
      set: function set(value) {
        this._multiple = transform.booleanAttr(value);

        this._reflectAttribute('multiple', this._multiple);

        this[this._multiple ? 'setAttribute' : 'removeAttribute']('aria-multiselectable', this._multiple);

        this._validateSelection();
      }
      /**
       Whether items are being loaded for the SelectList. Toggling this merely shows or hides a loading indicator.
        @default false
       @type {Boolean}
       @htmlattribute loading
       @htmlattributereflected
       */

    }, {
      key: "loading",
      get: function get() {
        return this._loading || false;
      },
      set: function set(value) {
        this._loading = transform.booleanAttr(value);

        this._reflectAttribute('loading', this._loading);

        var load = this._elements.loadIndicator;

        if (this.loading) {
          // we decide first if we need to scroll to the bottom since adding the load will change the dimentions
          var scrollToBottom = this.scrollTop >= this.scrollHeight - this.clientHeight; // inserts the item at the end

          this.appendChild(load); // we make the load indicator visible

          if (scrollToBottom) {
            /** @ignore */
            this.scrollTop = this.scrollHeight;
          }
        } else {
          load.remove();
        }
      }
      /** @private **/

    }, {
      key: "_tabTarget",
      get: function get() {
        return this.__tabTarget || null;
      },
      set: function set(value) {
        this.__tabTarget = value; // Set all but the current set _tabTarget to not be a tab target:

        this.items._getSelectableItems().forEach(function (item) {
          item.setAttribute('tabindex', !value || item === value ? 0 : -1);
        });
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(SelectList), "observedAttributes", this).concat(['loading', 'multiple']);
      }
    }]);

    return SelectList;
  }(BaseComponent(HTMLElement));

  var CLASSNAME$f = '_coral-SelectList-group';
  /**
   @class Coral.SelectList.Group
   @classdesc A SelectList group component
   @htmltag coral-selectlist-group
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var SelectListGroup = /*#__PURE__*/function (_BaseComponent) {
    _inherits(SelectListGroup, _BaseComponent);

    var _super = _createSuper(SelectListGroup);

    function SelectListGroup() {
      _classCallCheck(this, SelectListGroup);

      return _super.apply(this, arguments);
    }

    _createClass(SelectListGroup, [{
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(SelectListGroup.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$f);
        this.setAttribute('role', 'group');
      }
    }, {
      key: "label",

      /**
       The label of the group. It reflects the <code>label</code> attribute to the DOM.
        @type {String}
       @default ""
       @htmlattribute label
       @htmlattributereflected
       */
      get: function get() {
        return this._label || '';
      },
      set: function set(value) {
        this._label = transform.string(value);

        this._reflectAttribute('label', this._label);

        this.setAttribute('aria-label', this._label);
      }
      /**
       The Collection Interface that allows interacting with the items that the component contains.
        @type {SelectableCollection}
       @readonly
       */

    }, {
      key: "items",
      get: function get() {
        // just init on demand
        if (!this._items) {
          this._items = new SelectableCollection({
            host: this,
            itemTagName: 'coral-selectlist-item'
          });
        }

        return this._items;
      }
      /** @ignore */

    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(SelectListGroup), "observedAttributes", this).concat(['label']);
      }
    }]);

    return SelectListGroup;
  }(BaseComponent(HTMLElement));

  var template$3 = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var data = data_0 = typeof data_0 === "undefined" ? {} : data_0;
    var el0 = this["checkIcon"] = document.createElement("span");
    el0.className += " _coral-SelectList-icon";
    el0.setAttribute("handle", "checkIcon");
    el0.setAttribute("hidden", "");
    var el1 = document.createTextNode("\n  ");
    el0.appendChild(el1);
    data = data_0;
    this.checkIcon.innerHTML = data.Icon._renderSVG('spectrum-css-icon-CheckmarkMedium', ['_coral-UIIcon-CheckmarkMedium', '_coral-Menu-checkmark']);
    data_0 = data;
    var el3 = document.createTextNode("\n");
    el0.appendChild(el3);
    frag.appendChild(el0);
    var el4 = document.createTextNode("\n");
    frag.appendChild(el4);
    return frag;
  };

  var CLASSNAME$g = '_coral-Menu-item';
  var VALID_ARIA_SELECTED_ROLES = ['columnheader', 'gridcell', 'option', 'row', 'rowheader', 'tab', 'treeitem'];
  var VALID_ARIA_SELECTED_ROLES_REGEXP = new RegExp("^(".concat(VALID_ARIA_SELECTED_ROLES.join('|'), ")$"));
  /**
   @class Coral.SelectList.Item
   @classdesc A SelectList item component
   @htmltag coral-selectlist-item
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var SelectListItem = /*#__PURE__*/function (_BaseComponent) {
    _inherits(SelectListItem, _BaseComponent);

    var _super = _createSuper(SelectListItem);

    /** @ignore */
    function SelectListItem() {
      var _this;

      _classCallCheck(this, SelectListItem);

      _this = _super.call(this); // Templates

      _this._elements = {
        // Fetch or create the content zone element
        content: _this.querySelector('coral-selectlist-item-content') || document.createElement('coral-selectlist-item-content')
      };
      template$3.call(_this._elements, {
        Icon: Icon
      });
      return _this;
    }
    /**
     Value of the item. If not explicitly set, the value of <code>Node.textContent</code> is returned.
      @type {String}
     @default ""
     @htmlattribute value
     @htmlattributereflected
     */


    _createClass(SelectListItem, [{
      key: "_getIconElement",
      value: function _getIconElement() {
        if (!this._elements.icon) {
          this._elements.icon = this.querySelector('._coral-Menu-item-icon') || new Icon();
          this._elements.icon.size = Icon.size.SMALL;

          this._elements.icon.classList.add('_coral-Menu-item-icon');
        }

        return this._elements.icon;
      }
      /**
       Whether the item is selected.
        @type {Boolean}
       @default false
       @htmlattribute selected
       @htmlattributereflected
       */

    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(SelectListItem.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$g);

        if (!this.hasAttribute('role')) {
          this.setAttribute('role', 'option');
        } // Support cloneNode


        var template = this.querySelector('._coral-SelectList-icon');

        if (template) {
          template.remove();
        } // Fetch or create the content content zone element


        var content = this._elements.content; // Move any remaining elements into the content sub-component

        if (!content.parentNode) {
          while (this.firstChild) {
            content.appendChild(this.firstChild);
          }
        } // Add template


        this.appendChild(this._elements.checkIcon); // Assign the content zones, moving them into place in the process

        this.content = content;
      }
    }, {
      key: "value",
      get: function get() {
        return typeof this._value === 'string' ? this._value : this.textContent.replace(/\s{2,}/g, ' ').trim();
      },
      set: function set(value) {
        this._value = transform.string(value);

        this._reflectAttribute('value', this._value);
      }
      /**
       The content element for the item.
        @type {SelectListItemContent}
       @contentzone
       */

    }, {
      key: "content",
      get: function get() {
        return this._getContentZone(this._elements.content);
      },
      set: function set(value) {
        this._setContentZone('content', value, {
          handle: 'content',
          tagName: 'coral-selectlist-item-content',
          insert: function insert(content) {
            content.classList.add("".concat(CLASSNAME$g, "Label")); // Remove content icon before processing content zone

            var checkIcon = this._elements.checkIcon;
            var contentIcon; // @polyfill ie11
            // IE11 throws syntax error because of the "not()" in the selector if the element is not in the DOM.

            if (navigator.userAgent.indexOf('MSIE') !== -1 || navigator.appVersion.includes('Trident/')) {
              var allContentIcons = Array.prototype.slice.call(content.querySelectorAll('coral-icon'));
              var allContentMenuIcons = Array.prototype.slice.call(content.querySelectorAll('coral-icon._coral-Menu-item-icon'));
              var contentIcons = allContentIcons.filter(function (icon) {
                return allContentMenuIcons.indexOf(icon) === -1;
              });
              contentIcon = contentIcons.length > 0 ? contentIcons[0] : undefined;
            } else {
              contentIcon = content.querySelector('coral-icon:not(._coral-Menu-item-icon)');
            }

            if (contentIcon && contentIcon.icon) {
              contentIcon.remove();
              this.icon = contentIcon.icon;

              var iconElement = this._getIconElement();

              if (contentIcon.alt || contentIcon.title) {
                if (contentIcon.title) {
                  iconElement.title = contentIcon.title;
                }

                if (contentIcon.alt) {
                  iconElement.alt = contentIcon.alt;
                }
              } else {
                iconElement.alt = '';
              }
            }

            this.insertBefore(content, this.contains(checkIcon) ? checkIcon : null);
          }
        });
      }
      /**
       The icon to display. See {@link Icon}.
        @type {String}
       @default ""
       @htmlattribute icon
       */

    }, {
      key: "icon",
      get: function get() {
        var el = this._getIconElement();

        return el.icon;
      },
      set: function set(value) {
        var el = this._getIconElement();

        if (transform.string(value) === '') {
          el.remove();
        } else {
          this.insertBefore(el, this.firstChild);
        }

        el.icon = value;
      }
    }, {
      key: "selected",
      get: function get() {
        return this._selected || false;
      },
      set: function set(value) {
        var _selected = transform.booleanAttr(value);

        if (this._selected === _selected) {
          return;
        }

        this._selected = _selected;

        this._reflectAttribute('selected', this.disabled ? false : this._selected);

        this.classList.toggle('is-selected', this._selected);

        if (this.hasAttribute('role') && VALID_ARIA_SELECTED_ROLES_REGEXP.test(this.getAttribute('role'))) {
          this.setAttribute('aria-selected', this._selected);
        } // Toggle check icon


        this._elements.checkIcon.hidden = !this._selected;
        this.trigger('coral-selectlist-item:_selectedchanged');
      }
      /**
       Whether this item is disabled.
        @type {Boolean}
       @default false
       @htmlattribute disabled
       @htmlattributereflected
       */

    }, {
      key: "disabled",
      get: function get() {
        return this._disabled || false;
      },
      set: function set(value) {
        this._disabled = transform.booleanAttr(value);

        this._reflectAttribute('disabled', this._disabled);

        this.classList.toggle('is-disabled', this._disabled);
        this[this._disabled ? 'setAttribute' : 'removeAttribute']('aria-disabled', this._disabled);
        this.selected = this.selected;
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-selectlist-item-content': 'content'
        };
      }
      /** @ignore */

    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(SelectListItem), "observedAttributes", this).concat(['selected', 'disabled', 'value']);
      }
    }]);

    return SelectListItem;
  }(BaseComponent(HTMLElement));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.SelectList.Item.Content
   @classdesc The SelectList Item content
   @htmltag coral-selectlist-item-content
   @return {HTMLElement}
   */
  var SelectListItemContent = (function () {
    return document.createElement('coral-selectlist-item-content');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons.extend(strings, {
    'coral-component-selectlist': translations$3
  }); // Expose component on the Coral namespace

  commons._define('coral-anchorlist-item', AnchorListItem, {
    extends: 'a'
  });

  commons._define('coral-anchorlist', AnchorList);

  commons._define('coral-buttonlist-item', ButtonListItem, {
    extends: 'button'
  });

  commons._define('coral-buttonlist', ButtonList);

  commons._define('coral-selectlist-group', SelectListGroup);

  commons._define('coral-selectlist-item', SelectListItem);

  commons._define('coral-selectlist', SelectList);

  commons._define('coral-list-divider', ListDivider);

  commons._define('coral-list-item', ListItem);

  commons._define('coral-list', List);

  List.Divider = ListDivider;
  List.Item = ListItem;
  List.Item.Content = ListItemContent;
  AnchorList.Item = AnchorListItem;
  ButtonList.Item = ButtonListItem;
  SelectList.Group = SelectListGroup;
  SelectList.Item = SelectListItem;
  SelectList.Item.Content = SelectListItemContent;

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var translations$4 = {
    "en-US": {
      "Close": "Close"
    },
    "de-DE": {
      "Close": "SchlieÃen"
    },
    "fr-FR": {
      "Close": "Fermer"
    },
    "it-IT": {
      "Close": "Chiudi"
    },
    "ja-JP": {
      "Close": "éãã"
    },
    "es-ES": {
      "Close": "Cerrar"
    },
    "ko-KR": {
      "Close": "ë«ê¸°"
    },
    "zh-CN": {
      "Close": "å³é­"
    },
    "zh-TW": {
      "Close": "éé"
    },
    "pt-BR": {
      "Close": "Fechar"
    },
    "nl-NL": {
      "Close": "Sluiten"
    },
    "da-DK": {
      "Close": "Luk"
    },
    "fi-FI": {
      "Close": "Sulje"
    },
    "nb-NO": {
      "Close": "Lukk"
    },
    "sv-SE": {
      "Close": "StÃ¤ng"
    },
    "cs-CZ": {
      "Close": "ZavÅÃ­t"
    },
    "pl-PL": {
      "Close": "Zamknij"
    },
    "ru-RU": {
      "Close": "ÐÐ°ÐºÑÑÑÑ"
    },
    "tr-TR": {
      "Close": "Kapat"
    }
  };

  var template$4 = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["topTabCapture"] = document.createElement("div");
    el0.setAttribute("handle", "topTabCapture");
    el0.setAttribute("coral-tabcapture", "top");
    el0.setAttribute("tabindex", "0");
    el0.setAttribute("role", "presentation");
    frag.appendChild(el0);
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    var el2 = this["intermediateTabCapture"] = document.createElement("div");
    el2.setAttribute("handle", "intermediateTabCapture");
    el2.setAttribute("coral-tabcapture", "intermediate");
    el2.setAttribute("tabindex", "0");
    el2.setAttribute("role", "presentation");
    frag.appendChild(el2);
    var el3 = document.createTextNode("\n");
    frag.appendChild(el3);
    var el4 = this["bottomTabCapture"] = document.createElement("div");
    el4.setAttribute("handle", "bottomTabCapture");
    el4.setAttribute("coral-tabcapture", "bottom");
    el4.setAttribute("tabindex", "0");
    el4.setAttribute("role", "presentation");
    frag.appendChild(el4);
    var el5 = document.createTextNode("\n");
    frag.appendChild(el5);
    return frag;
  };

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   Enumeration for {@link BaseOverlay} trap options.

   @typedef {Object} OverlayTrapFocusEnum

   @property {String} ON
   Focus is trapped such that the use cannot focus outside of the overlay.
   @property {String} OFF
   The user can focus outside the overlay as normal.
   */
  var trapFocus = {
    ON: 'on',
    OFF: 'off'
  };
  /**
   Enumeration for {@link BaseOverlay} scroll focus options.

   @typedef {Object} OverlayScrollOnFocusEnum

   @property {String} ON
   Scroll the document to bring the newly-focused element into view.
   @property {String} OFF
   Document will not scroll on focus.
   */

  var scrollOnFocus = {
    ON: 'on',
    OFF: 'off'
  };
  /**
   Enumeration for {@link BaseOverlay} return focus options.

   @typedef {Object} OverlayReturnFocusEnum

   @property {String} ON
   When the overlay is closed, the element that was focused before the it was shown will be focused again.
   @property {String} OFF
   Nothing will be focused when the overlay is closed.
   */

  var returnFocus = {
    ON: 'on',
    OFF: 'off'
  };
  /**
   Enumeration for {@link BaseOverlay} focus behavior options.

   @typedef {Object} OverlayFocusOnShowEnum

   @property {String} ON
   When the overlay is opened, it will be focused.
   @property {String} OFF
   The overlay will not focus itself when opened.
   */

  var focusOnShow = {
    ON: 'on',
    OFF: 'off'
  };
  /**
   The time it should take for {@link BaseOverlay} to fade in milliseconds.
   Important: This should be greater than or equal to the CSS transition time.

   @typedef {Number} OverlayFadeTime
   */

  var FADETIME = 350;

  var CLASSNAME$h = '_coral-BaseOverlay'; // Includes overlay itself

  var COMPONENTS_WITH_OVERLAY = "\n  coral-actionbar,\n  coral-autocomplete,\n  coral-colorinput,\n  coral-cyclebutton,\n  coral-datepicker,\n  coral-dialog,\n  coral-overlay,\n  coral-popover,\n  coral-quickactions,\n  coral-select,\n  coral-tooltip\n"; // The tab capture element that lives at the top of the body

  var topTabCaptureEl;
  var bottomTabCaptureEl; // A reference to the backdrop element

  var backdropEl; // The starting zIndex for overlays

  var startZIndex = 10000; // Tab keycode

  var TAB_KEY = 9; // A stack interface for overlays

  var overlayStack = [];
  var OverlayManager = {};
  /**
   Return focus option
   */

  function preventScroll(instance) {
    return {
      preventScroll: instance.scrollOnFocus === scrollOnFocus.OFF
    };
  }
  /**
   Cancel the backdrop hide mid-animation.
   */


  var fadeTimeout;

  function cancelBackdropHide() {
    window.clearTimeout(fadeTimeout);
  }
  /**
   Set aria-hidden on every immediate child except the one passed, which should not be hidden.
   */


  function hideEverythingBut(instance) {
    // ARIA: Hide all the things
    var children = document.body.children;

    for (var i = 0; i < children.length; i++) {
      var child = children[i]; // If it's not a parent of or not the instance itself, it needs to be hidden

      if (child !== instance && child.contains && !child.contains(instance)) {
        var currentAriaHidden = child.getAttribute('aria-hidden');

        if (currentAriaHidden) {
          // Store the previous value of aria-hidden if present
          // Don't blow away the previously stored value
          child._previousAriaHidden = child._previousAriaHidden || currentAriaHidden;

          if (currentAriaHidden === 'true') {
            // It's already true, don't bother setting
            continue;
          }
        } else {
          // Nothing is hidden by default, store that
          child._previousAriaHidden = 'false';
        } // Hide it


        child.setAttribute('aria-hidden', 'true');
      }
    } // Always show ourselves


    instance.setAttribute('aria-hidden', 'false');
  }
  /**
   Actually reposition the backdrop to be under the topmost overlay.
   */


  function doRepositionBackdrop() {
    // Position under the topmost overlay
    var top = OverlayManager.top();

    if (top) {
      // The backdrop, if shown, should be positioned under the topmost overlay that does have a backdrop
      for (var i = overlayStack.length - 1; i > -1; i--) {
        if (overlayStack[i].backdrop) {
          backdropEl.style.zIndex = overlayStack[i].zIndex - 1;
          break;
        }
      } // ARIA: Set hidden properly


      hideEverythingBut(top.instance);
    }
  }

  OverlayManager = {
    pop: function pop(instance) {
      // Get overlay index
      var index = this.indexOf(instance);

      if (index === -1) {
        return null;
      } // Get the overlay


      var overlay = overlayStack[index]; // Remove from the stack

      overlayStack.splice(index, 1); // Return the passed overlay or the found overlay

      return overlay;
    },
    push: function push(instance) {
      // Pop overlay
      var overlay = this.pop(instance) || {
        instance: instance
      }; // Get the new highest zIndex

      var zIndex = this.getHighestZIndex() + 10; // Store the zIndex

      overlay.zIndex = zIndex;
      instance.style.zIndex = zIndex; // Push it

      overlayStack.push(overlay);

      if (overlay.backdrop) {
        // If the backdrop is shown, we'll need to reposition it
        // Generally, a component will not call _pushOverlay unnecessarily
        // However, attachedCallback is asynchronous in polyfilld environments,
        // so _pushOverlay will be called when shown and when attached
        doRepositionBackdrop();
      }

      return overlay;
    },
    indexOf: function indexOf(instance) {
      // Loop over stack
      // Find overlay
      // Return index
      for (var i = 0; i < overlayStack.length; i++) {
        if (overlayStack[i].instance === instance) {
          return i;
        }
      }

      return -1;
    },
    get: function get(instance) {
      // Get overlay index
      var index = this.indexOf(instance); // Return overlay

      return index === -1 ? null : overlayStack[index];
    },
    top: function top() {
      var length = overlayStack.length;
      return length === 0 ? null : overlayStack[length - 1];
    },
    getHighestZIndex: function getHighestZIndex() {
      var overlay = this.top();
      return overlay ? overlay.zIndex : startZIndex;
    },
    some: function some() {
      return overlayStack.some.apply(overlayStack, arguments);
    },
    forEach: function forEach() {
      return overlayStack.forEach.apply(overlayStack, arguments);
    }
  };
  /**
   Create the global tab capture element.
   */

  function createDocumentTabCaptureEls() {
    if (!topTabCaptureEl) {
      topTabCaptureEl = document.createElement('div');
      topTabCaptureEl.setAttribute('coral-tabcapture', '');
      topTabCaptureEl.setAttribute('role', 'presentation');
      topTabCaptureEl.tabIndex = 0;
      document.body.insertBefore(topTabCaptureEl, document.body.firstChild);
      topTabCaptureEl.addEventListener('focus', function () {
        var top = OverlayManager.top();

        if (top && top.instance.trapFocus === trapFocus.ON) {
          // Focus on the first tabbable element of the top overlay
          Array.prototype.some.call(top.instance.querySelectorAll(commons.TABBABLE_ELEMENT_SELECTOR), function (item) {
            if (item.offsetParent !== null && !item.hasAttribute('coral-tabcapture')) {
              item.focus(preventScroll(top));
              return true;
            }

            return false;
          });
        }
      });
      bottomTabCaptureEl = document.createElement('div');
      bottomTabCaptureEl.setAttribute('coral-tabcapture', '');
      bottomTabCaptureEl.setAttribute('role', 'presentation');
      bottomTabCaptureEl.tabIndex = 0;
      document.body.appendChild(bottomTabCaptureEl);
      bottomTabCaptureEl.addEventListener('focus', function () {
        var top = OverlayManager.top();

        if (top && top.instance.trapFocus === trapFocus.ON) {
          var tabbableElement = Array.prototype.filter.call(top.instance.querySelectorAll(commons.TABBABLE_ELEMENT_SELECTOR), function (item) {
            return item.offsetParent !== null && !item.hasAttribute('coral-tabcapture');
          }).pop(); // Focus on the last tabbable element of the top overlay

          if (tabbableElement) {
            tabbableElement.focus(preventScroll(top));
          }
        }
      });
    } else {
      if (document.body.firstElementChild !== topTabCaptureEl) {
        // Make sure we stay at the very top
        document.body.insertBefore(topTabCaptureEl, document.body.firstChild);
      }

      if (document.body.lastElementChild !== bottomTabCaptureEl) {
        // Make sure we stay at the very bottom
        document.body.appendChild(bottomTabCaptureEl);
      }
    } // Make sure the tab capture elemenst are shown


    topTabCaptureEl.style.display = 'inline';
    bottomTabCaptureEl.style.display = 'inline';
  }
  /**
   Called after all overlays are hidden and we shouldn't capture the first tab into the page.
   */


  function hideDocumentTabCaptureEls() {
    if (topTabCaptureEl) {
      topTabCaptureEl.style.display = 'none';
      bottomTabCaptureEl.style.display = 'none';
    }
  }
  /**
   Show or restore the aria-hidden state of every child of body.
   */


  function showEverything() {
    // ARIA: Show all the things
    var children = document.body.children;

    for (var i = 0; i < children.length; i++) {
      var child = children[i]; // Restore the previous aria-hidden value

      child.setAttribute('aria-hidden', child._previousAriaHidden || 'false');
    }
  }
  /**
   Actually hide the backdrop.
   */


  function doBackdropHide() {
    document.body.classList.remove('u-coral-noscroll'); // Start animation

    window.requestAnimationFrame(function () {
      backdropEl.classList.remove('is-open');
      cancelBackdropHide();
      fadeTimeout = window.setTimeout(function () {
        backdropEl.style.display = 'none';
      }, FADETIME);
    }); // Set flag for testing

    backdropEl._isOpen = false; // Wait for animation to complete

    showEverything();
  }
  /**
   Hide the backdrop if no overlays are using it.
   */


  function hideOrRepositionBackdrop() {
    if (!backdropEl || !backdropEl._isOpen) {
      // Do nothing if the backdrop isn't shown
      return;
    } // Loop over all overlays


    var keepBackdrop = OverlayManager.some(function (overlay) {
      // Check for backdrop usage
      return !!overlay.backdrop;
    });

    if (!keepBackdrop) {
      // Hide the backdrop
      doBackdropHide();
    } else {
      // Reposition the backdrop
      doRepositionBackdrop();
    } // Hide/create the document-level tab capture element as necessary
    // This only applies to modal overlays (those that have backdrops)


    var top = OverlayManager.top();

    if (!top || !(top.instance.trapFocus === trapFocus.ON && top.instance._requestedBackdrop)) {
      hideDocumentTabCaptureEls();
    } else if (top && top.instance.trapFocus === trapFocus.ON && top.instance._requestedBackdrop) {
      createDocumentTabCaptureEls();
    }
  }
  /**
   Handles clicks to the backdrop, calling backdropClickedCallback for every overlay
   */


  function handleBackdropClick(event) {
    OverlayManager.forEach(function (overlay) {
      if (typeof overlay.instance.backdropClickedCallback === 'function') {
        overlay.instance.backdropClickedCallback(event);
      }
    });
  }
  /**
   Actually show the backdrop.
   */


  function doBackdropShow(zIndex, instance) {
    document.body.classList.add('u-coral-noscroll');

    if (!backdropEl) {
      backdropEl = document.createElement('div');
      backdropEl.className = '_coral-Underlay';
      document.body.appendChild(backdropEl);
      backdropEl.addEventListener('click', handleBackdropClick);
    } // Show just under the provided zIndex
    // Since we always increment by 10, this will never collide


    backdropEl.style.zIndex = zIndex - 1; // Set flag for testing

    backdropEl._isOpen = true; // Start animation

    backdropEl.style.display = '';
    window.requestAnimationFrame(function () {
      // Add the class on the next animation frame so backdrop has time to exist
      // Otherwise, the animation for opacity will not work.
      backdropEl.classList.add('is-open');
      cancelBackdropHide();
    });
    hideEverythingBut(instance);
  }
  /**
   @base BaseOverlay
   @classdesc The base element for Overlay components
   */


  var BaseOverlay = function BaseOverlay(superClass) {
    return /*#__PURE__*/function (_superClass) {
      _inherits(_class, _superClass);

      var _super = _createSuper(_class);

      /** @ignore */
      function _class() {
        var _this;

        _classCallCheck(this, _class);

        _this = _super.call(this); // Templates

        _this._elements = {};
        template$4.call(_this._elements);
        return _this;
      }
      /**
       Whether to trap tabs and keep them within the overlay. See {@link OverlayTrapFocusEnum}.
        @type {String}
       @default OverlayTrapFocusEnum.OFF
       @htmlattribute trapfocus
       */


      _createClass(_class, [{
        key: "_closeChildOverlays",
        value: function _closeChildOverlays() {
          var components = this.querySelectorAll(COMPONENTS_WITH_OVERLAY); // Close all children overlays and components with overlays

          for (var i = 0; i < components.length; i++) {
            var component = components[i]; // Overlay component

            if (component.hasAttribute('open')) {
              component.removeAttribute('open');
            } // Component that uses an overlay
            else if (component._elements && component._elements.overlay && component._elements.overlay.hasAttribute('open')) {
                component._elements.overlay.removeAttribute('open');
              }
          }
        }
        /** @private */

      }, {
        key: "_debounce",
        value: function _debounce(f) {
          // Used to avoid triggering open/close event continuously
          window.clearTimeout(this._debounceId);
          this._debounceId = window.setTimeout(function () {
            f();
          }, 10);
        }
        /**
         Check if this overlay is the topmost.
          @protected
         */

      }, {
        key: "_isTopOverlay",
        value: function _isTopOverlay() {
          var top = OverlayManager.top();
          return top && top.instance === this;
        }
        /**
         Push the overlay to the top of the stack.
          @protected
         */

      }, {
        key: "_pushOverlay",
        value: function _pushOverlay() {
          OverlayManager.push(this);
        }
        /**
         Remove the overlay from the stack.
          @protected
         */

      }, {
        key: "_popOverlay",
        value: function _popOverlay() {
          OverlayManager.pop(this); // Automatically hide the backdrop if required

          hideOrRepositionBackdrop();
        }
        /**
         Show the backdrop.
          @protected
         */

      }, {
        key: "_showBackdrop",
        value: function _showBackdrop() {
          var overlay = OverlayManager.get(this); // Overlay is not tracked unless the component is in the DOM
          // Hence, we need to check

          if (overlay) {
            overlay.backdrop = true;
            doBackdropShow(overlay.zIndex, this);
          } // Mark on the instance that the backdrop has been requested for this overlay


          this._requestedBackdrop = true; // Mark that the backdrop was requested when not attached to the DOM
          // This allows us to know whether to push the overlay when the component is attached

          if (!this.parentNode) {
            this._showBackdropOnAttached = true;
          }

          if (this.trapFocus === trapFocus.ON) {
            createDocumentTabCaptureEls();
          }
        }
        /**
         Show the backdrop.
          @protected
         */

      }, {
        key: "_hideBackdrop",
        value: function _hideBackdrop() {
          var overlay = OverlayManager.get(this);

          if (overlay) {
            overlay.backdrop = false; // If that was the last overlay using the backdrop, hide it

            hideOrRepositionBackdrop();
          } // Mark on the instance that the backdrop is no longer needed


          this._requestedBackdrop = false;
        }
        /**
         Handles keypresses on the root of the overlay and marshalls focus accordingly.
          @protected
         */

      }, {
        key: "_handleRootKeypress",
        value: function _handleRootKeypress(event) {
          if (event.target === this && event.keyCode === TAB_KEY) {
            // Skip the top tabcapture and focus on the first focusable element
            this._focusOn('first'); // Stop the normal tab behavior


            event.preventDefault();
          }
        }
        /**
         Handles focus events on tab capture elements.
          @protected
         */

      }, {
        key: "_handleTabCaptureFocus",
        value: function _handleTabCaptureFocus(event) {
          // Avoid moving around if we're trying to focus on coral-tabcapture
          if (this._ignoreTabCapture) {
            this._ignoreTabCapture = false;
            return;
          } // Focus on the correct tabbable element


          var target = event.target;
          var which = target === this._elements.intermediateTabCapture ? 'first' : 'last';

          this._focusOn(which);
        }
        /**
         Handles the focus behavior. When "on" is specified it would try to find the first tababble descendent in the
         content and if there are no valid candidates it will focus the element itself.
          @protected
         */

      }, {
        key: "_handleFocus",
        value: function _handleFocus() {
          // ON handles the focusing per accessibility recommendations
          if (this.focusOnShow === focusOnShow.ON) {
            this._focusOn('first');
          } else if (this.focusOnShow instanceof HTMLElement) {
            this.focusOnShow.focus(preventScroll(this));
          } else if (typeof this.focusOnShow === 'string' && this.focusOnShow !== focusOnShow.OFF) {
            // we need to add :not([coral-tabcapture]) to avoid selecting the tab captures
            var selectedElement = this.querySelector("".concat(this.focusOnShow, ":not([coral-tabcapture])"));

            if (selectedElement) {
              selectedElement.focus(preventScroll(this));
            } // in case the selector does not match, it should fallback to the default behavior
            else {
                this._focusOn('first');
              }
          }
        }
        /**
         @protected
         */

      }, {
        key: "_handleReturnFocus",
        value: function _handleReturnFocus() {
          if (this.returnFocus === returnFocus.ON && this._elementToFocusWhenHidden) {
            if (document.activeElement && !this.contains(document.activeElement)) {
              // Don't return focus if the user focused outside of the overlay
              return;
            } // Return focus, ignoring tab capture if it is an overlay


            this._elementToFocusWhenHidden._ignoreTabCapture = true;

            this._elementToFocusWhenHidden.focus(preventScroll(this));

            this._elementToFocusWhenHidden._ignoreTabCapture = false; // Drop the reference to avoid memory leaks

            this._elementToFocusWhenHidden = null;
          }
        }
        /**
         Focus on the first or last element.
          @param {String} which
         one of "first" or "last"
         @protected
         */

      }, {
        key: "_focusOn",
        value: function _focusOn(which) {
          var focusableTarget = this._getFocusableElement(which); // if we found a focusing target we focus it


          if (focusableTarget) {
            focusableTarget.focus(preventScroll(this));
          } // otherwise the element itself should get focus
          else {
              this.focus(preventScroll(this));
            }
        }
      }, {
        key: "_getFocusableElements",
        value: function _getFocusableElements() {
          return Array.prototype.filter.call(this.querySelectorAll(commons.FOCUSABLE_ELEMENT_SELECTOR), function (item) {
            return item.offsetParent !== null && !item.hasAttribute('coral-tabcapture');
          });
        }
      }, {
        key: "_getFocusableElement",
        value: function _getFocusableElement(which) {
          var focusableTarget;

          if (which === 'first' || which === 'last') {
            var focusableElements = this._getFocusableElements();

            focusableTarget = focusableElements[which === 'first' ? 'shift' : 'pop']();
          }

          return focusableTarget;
        }
        /**
         Open the overlay and set the z-index accordingly.
          @returns {BaseOverlay} this, chainable
         */

      }, {
        key: "show",
        value: function show() {
          this.open = true;
          return this;
        }
        /**
         Close the overlay.
          @returns {BaseOverlay} this, chainable
         */

      }, {
        key: "hide",
        value: function hide() {
          this.open = false;
          return this;
        }
        /**
         Set the element that focus should be returned to when the overlay is hidden.
          @param {HTMLElement} element
         The element to return focus to. This must be a DOM element, not a jQuery object or selector.
          @returns {BaseOverlay} this, chainable
         */

      }, {
        key: "returnFocusTo",
        value: function returnFocusTo(element) {
          if (this.returnFocus === returnFocus.OFF) {
            // Switch on returning focus if it's off
            this.returnFocus = returnFocus.ON;
          } // If the element is not focusable,


          if (!element.matches(commons.FOCUSABLE_ELEMENT_SELECTOR)) {
            // add tabindex so that it is programmatically focusable.
            element.setAttribute('tabindex', -1); // On blur, restore element to its prior, not-focusable state

            var tempVent = new vent(element);
            tempVent.on('blur.afterFocus', function (event) {
              // Wait a frame before testing whether focus has moved to an open overlay or to some other element.
              window.requestAnimationFrame(function () {
                // If overlay remains open, don't remove tabindex event handler until after it has been closed
                var top = OverlayManager.top();

                if (top && top.instance.contains(document.activeElement)) {
                  return;
                }

                tempVent.off('blur.afterFocus');
                event.matchedTarget.removeAttribute('tabindex');
              });
            }, true);
          }

          this._returnFocusToElement = element;
          return this;
        }
      }, {
        key: "connectedCallback",

        /** @ignore */
        value: function connectedCallback() {
          _get(_getPrototypeOf(_class.prototype), "connectedCallback", this).call(this);

          if (!this.hasAttribute('trapfocus')) {
            this.trapFocus = this.trapFocus;
          }

          if (!this.hasAttribute('returnfocus')) {
            this.returnFocus = this.returnFocus;
          }

          if (!this.hasAttribute('focusonshow')) {
            this.focusOnShow = this.focusOnShow;
          }

          if (!this.hasAttribute('scrollonfocus')) {
            this.scrollOnFocus = this.scrollOnFocus;
          }

          if (this.open) {
            this._pushOverlay();

            if (this._showBackdropOnAttached) {
              // Show the backdrop again
              this._showBackdrop();
            }
          } else {
            // If overlay is closed, make sure that it is hidden with `display: none`,
            // but set `visibility: visible` to ensure that the overlay will be included in accessibility name or description
            // of an element that references it using `aria-labelledby` or `aria-describedby`.
            this.style.display = 'none';
            this.style.visibility = 'visible';
          }
        }
        /** @ignore */

      }, {
        key: "render",
        value: function render() {
          _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

          this.classList.add(CLASSNAME$h);
        }
        /** @ignore */

      }, {
        key: "disconnectedCallback",
        value: function disconnectedCallback() {
          _get(_getPrototypeOf(_class.prototype), "disconnectedCallback", this).call(this);

          if (this.open) {
            // Release zIndex as we're not in the DOM any longer
            // When we're re-added, we'll get a new zIndex
            this._popOverlay();

            if (this._requestedBackdrop) {
              // Mark that we'll need to show the backdrop when attached
              this._showBackdropOnAttached = true;
            }
          }
        }
        /**
         Called when the {@link BaseOverlay} is clicked.
          @function backdropClickedCallback
         @protected
         */

        /**
         Triggered before the {@link BaseOverlay} is opened with <code>show()</code> or <code>instance.open = true</code>.
          @typedef {CustomEvent} coral-overlay:beforeopen
          @property {function} preventDefault
         Call to stop the overlay from opening.
         */

        /**
         Triggered after the {@link BaseOverlay} is opened with <code>show()</code> or <code>instance.open = true</code>
          @typedef {CustomEvent} coral-overlay:open
         */

        /**
         Triggered before the {@link BaseOverlay} is closed with <code>hide()</code> or <code>instance.open = false</code>.
          @typedef {CustomEvent} coral-overlay:beforeclose
          @property {function} preventDefault
         Call to stop the overlay from closing.
         */

        /**
         Triggered after the {@link BaseOverlay} is closed with <code>hide()</code> or <code>instance.open = false</code>
          @typedef {CustomEvent} coral-overlay:close
         */

      }, {
        key: "trapFocus",
        get: function get() {
          return this._trapFocus || trapFocus.OFF;
        },
        set: function set(value) {
          value = transform.string(value).toLowerCase();
          this._trapFocus = validate.enumeration(trapFocus)(value) && value || trapFocus.OFF;

          if (this._trapFocus === trapFocus.ON) {
            // Give ourselves tabIndex if we are not focusable
            if (this.tabIndex < 0) {
              /** @ignore */
              this.tabIndex = 0;
            } // Insert elements


            this.insertBefore(this._elements.topTabCapture, this.firstElementChild);
            this.appendChild(this._elements.intermediateTabCapture);
            this.appendChild(this._elements.bottomTabCapture); // Add listeners

            this._handleTabCaptureFocus = this._handleTabCaptureFocus.bind(this);
            this._handleRootKeypress = this._handleRootKeypress.bind(this);

            this._vent.on('keydown', this._handleRootKeypress);

            this._vent.on('focus', '[coral-tabcapture]', this._handleTabCaptureFocus);
          } else if (this._trapFocus === trapFocus.OFF) {
            // Remove elements
            this._elements.topTabCapture && this._elements.topTabCapture.remove();
            this._elements.intermediateTabCapture && this._elements.intermediateTabCapture.remove();
            this._elements.bottomTabCapture && this._elements.bottomTabCapture.remove(); // Remove listeners

            this._vent.off('keydown', this._handleRootKeypress);

            this._vent.off('focus', '[coral-tabcapture]', this._handleTabCaptureFocus);
          }
        }
        /**
         Whether to return focus to the previously focused element when closed. See {@link OverlayReturnFocusEnum}.
          @type {String}
         @default OverlayReturnFocusEnum.OFF
         @htmlattribute returnfocus
         */

      }, {
        key: "returnFocus",
        get: function get() {
          return this._returnFocus || returnFocus.OFF;
        },
        set: function set(value) {
          value = transform.string(value).toLowerCase();
          this._returnFocus = validate.enumeration(returnFocus)(value) && value || returnFocus.OFF;
        }
        /**
         returns element that will receive focus when overlay is closed
         @returns {HTMLElement}element passed via returnFocusTo()
         */

      }, {
        key: "returnFocusToElement",
        get: function get() {
          return this._returnFocusToElement;
        }
        /**
         returns element that will receive focus when overlay is hidden
         @returns {HTMLElement} element cached
         */

      }, {
        key: "elementToFocusWhenHidden",
        get: function get() {
          return this._elementToFocusWhenHidden;
        }
        /**
         Whether the browser should scroll the document to bring the newly-focused element into view. See {@link OverlayScrollOnFocusEnum}.
          @type {String}
         @default OverlayScrollOnFocusEnum.ON
         @htmlattribute scrollonfocus
         */

      }, {
        key: "scrollOnFocus",
        get: function get() {
          return this._scrollOnFocus || scrollOnFocus.ON;
        },
        set: function set(value) {
          value = transform.string(value).toLowerCase();
          this._scrollOnFocus = validate.enumeration(scrollOnFocus)(value) && value || scrollOnFocus.ON;
        }
        /**
         Whether to focus the overlay, when opened or not. By default the overlay itself will get the focus. It also accepts
         an instance of HTMLElement or a selector like ':first-child' or 'button:last-of-type'. If the selector returns
         multiple elements, it will focus the first element inside the overlay that matches the selector.
         See {@link OverlayFocusOnShowEnum}.
          @type {HTMLElement|String}
         @default OverlayFocusOnShowEnum.ON
         @htmlattribute focusonshow
         */

      }, {
        key: "focusOnShow",
        get: function get() {
          return this._focusOnShow || focusOnShow.ON;
        },
        set: function set(value) {
          if (typeof value === 'string' || value instanceof HTMLElement) {
            this._focusOnShow = value;
          }
        }
        /**
         Whether this overlay is open or not.
          @type {Boolean}
         @default false
         @htmlattribute open
         @htmlattributereflected
         @emits {coral-overlay:open}
         @emits {coral-overlay:close}
         @emits {coral-overlay:beforeopen}
         @emits {coral-overlay:beforeclose}
         */

      }, {
        key: "open",
        get: function get() {
          return this._open || false;
        },
        set: function set(value) {
          var _this2 = this;

          var silenced = this._silenced;
          value = transform.booleanAttr(value); // Used for global animations

          this.trigger('coral-overlay:_animate');
          var beforeEvent = this.trigger(value ? 'coral-overlay:beforeopen' : 'coral-overlay:beforeclose');

          if (!beforeEvent.defaultPrevented) {
            var open = this._open = value;

            this._reflectAttribute('open', open); // Remove aria-hidden attribute before we show.
            // Otherwise, screen readers will not announce
            // Doesn't matter when we set aria-hidden true (nothing being announced)


            if (open) {
              this.removeAttribute('aria-hidden');
            } else {
              this.setAttribute('aria-hidden', !open);
            } // Don't do anything if we're not in the DOM yet
            // This prevents errors related to allocating a zIndex we don't need


            if (this.parentNode) {
              // Do this check afterwards as we may have been appended inside of _show()
              if (open) {
                // Set z-index
                this._pushOverlay();

                if (this.returnFocus === returnFocus.ON) {
                  this._elementToFocusWhenHidden = // cached element
                  this._elementToFocusWhenHidden || // element passed via returnFocusTo()
                  this._returnFocusToElement || ( // element that had focus before opening the overlay
                  document.activeElement === document.body ? null : document.activeElement);
                }
              } else {
                // Release zIndex
                this._popOverlay();
              }
            } // Don't force reflow


            window.requestAnimationFrame(function () {
              // Keep it silenced
              _this2._silenced = silenced;

              if (open) {
                if (_this2.trapFocus === trapFocus.ON) {
                  // Make sure tab capture elements are positioned correctly
                  if ( // Tab capture elements are no longer at the bottom
                  _this2._elements.topTabCapture !== _this2.firstElementChild || _this2._elements.bottomTabCapture !== _this2.lastElementChild || // Tab capture elements have been separated
                  _this2._elements.bottomTabCapture.previousElementSibling !== _this2._elements.intermediateTabCapture) {
                    _this2.insertBefore(_this2._elements.intermediateTabCapture, _this2.firstElementChild);

                    _this2.appendChild(_this2._elements.intermediateTabCapture);

                    _this2.appendChild(_this2._elements.bottomTabCapture);
                  }
                } // visibility should revert to whatever is specified in CSS, so that transition renders.


                _this2.style.visibility = ''; // The default style should be display: none for overlays
                // Show ourselves first for centering calculations etc

                _this2.style.display = ''; // Do it in the next frame to make the animation happen

                window.requestAnimationFrame(function () {
                  _this2.classList.add('is-open');
                });

                var openComplete = function openComplete() {
                  if (_this2.open) {
                    _this2._debounce(function () {
                      // handles the focus behavior based on accessibility recommendations
                      _this2._handleFocus();

                      _this2.trigger('coral-overlay:open');

                      _this2._silenced = false;
                    });
                  }
                };

                if (_this2._overlayAnimationTime) {
                  // Wait for animation to complete
                  commons.transitionEnd(_this2, openComplete);
                } else {
                  // Execute immediately
                  openComplete();
                }
              } else {
                // Fade out
                _this2.classList.remove('is-open');

                var closeComplete = function closeComplete() {
                  if (!_this2.open) {
                    // When the CSS transition has finished, set visibility to browser default, `visibility: visible`,
                    // to ensure that the overlay will be included in accessibility name or description
                    // of an element that references it using `aria-labelledby` or `aria-describedby`.
                    _this2.style.visibility = 'visible'; // makes sure the focus is returned per accessibility recommendations

                    _this2._handleReturnFocus(); // Hide self


                    _this2.style.display = 'none';

                    _this2._debounce(function () {
                      // Inform child overlays that we're closing
                      _this2._closeChildOverlays();

                      _this2.trigger('coral-overlay:close');

                      _this2._silenced = false;
                    });
                  }
                };

                if (_this2._overlayAnimationTime) {
                  // Wait for animation to complete
                  commons.transitionEnd(_this2, closeComplete);
                } else {
                  // Execute immediately
                  closeComplete();
                }
              }
            });
          }
        }
      }], [{
        key: "_OverlayManager",
        get: function get() {
          return OverlayManager;
        }
        /**
         Returns {@link BaseOverlay} trap focus options.
          @return {OverlayTrapFocusEnum}
         */

      }, {
        key: "trapFocus",
        get: function get() {
          return trapFocus;
        }
        /**
         Returns {@link BaseOverlay} return focus options.
          @return {OverlayReturnFocusEnum}
         */

      }, {
        key: "returnFocus",
        get: function get() {
          return returnFocus;
        }
        /**
         Returns {@link BaseOverlay} scroll focus options.
          @return {OverlayScrollOnFocusEnum}
         */

      }, {
        key: "scrollOnFocus",
        get: function get() {
          return scrollOnFocus;
        }
        /**
         Returns {@link BaseOverlay} focus on show options.
          @return {OverlayFocusOnShowEnum}
         */

      }, {
        key: "focusOnShow",
        get: function get() {
          return focusOnShow;
        }
        /**
         Returns {@link BaseOverlay} fadetime in milliseconds.
          @return {Number}
         */

      }, {
        key: "FADETIME",
        get: function get() {
          return FADETIME;
        }
      }, {
        key: "_attributePropertyMap",
        get: function get() {
          return commons.extend(_get(_getPrototypeOf(_class), "_attributePropertyMap", this), {
            trapfocus: 'trapFocus',
            returnfocus: 'returnFocus',
            focusonshow: 'focusOnShow'
          });
        }
        /** @ignore */

      }, {
        key: "observedAttributes",
        get: function get() {
          return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['trapfocus', 'returnfocus', 'focusonshow', 'open']);
        }
      }]);

      return _class;
    }(superClass);
  };

  /**!
   * @fileOverview Kickass library to create and place poppers near their reference elements.
   * @version 1.16.1
   * @license
   * Copyright (c) 2016 Federico Zivolo and contributors
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   */
  var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && typeof navigator !== 'undefined';

  var timeoutDuration = function () {
    var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];

    for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
      if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
        return 1;
      }
    }

    return 0;
  }();

  function microtaskDebounce(fn) {
    var called = false;
    return function () {
      if (called) {
        return;
      }

      called = true;
      window.Promise.resolve().then(function () {
        called = false;
        fn();
      });
    };
  }

  function taskDebounce(fn) {
    var scheduled = false;
    return function () {
      if (!scheduled) {
        scheduled = true;
        setTimeout(function () {
          scheduled = false;
          fn();
        }, timeoutDuration);
      }
    };
  }

  var supportsMicroTasks = isBrowser && window.Promise;
  /**
  * Create a debounced version of a method, that's asynchronously deferred
  * but called in the minimum time possible.
  *
  * @method
  * @memberof Popper.Utils
  * @argument {Function} fn
  * @returns {Function}
  */

  var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;
  /**
   * Check if the given variable is a function
   * @method
   * @memberof Popper.Utils
   * @argument {Any} functionToCheck - variable to check
   * @returns {Boolean} answer to: is a function?
   */

  function isFunction$1(functionToCheck) {
    var getType = {};
    return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
  }
  /**
   * Get CSS computed property of the given element
   * @method
   * @memberof Popper.Utils
   * @argument {Eement} element
   * @argument {String} property
   */


  function getStyleComputedProperty(element, property) {
    if (element.nodeType !== 1) {
      return [];
    } // NOTE: 1 DOM access here


    var window = element.ownerDocument.defaultView;
    var css = window.getComputedStyle(element, null);
    return property ? css[property] : css;
  }
  /**
   * Returns the parentNode or the host of the element
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @returns {Element} parent
   */


  function getParentNode(element) {
    if (element.nodeName === 'HTML') {
      return element;
    }

    return element.parentNode || element.host;
  }
  /**
   * Returns the scrolling parent of the given element
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @returns {Element} scroll parent
   */


  function getScrollParent$1(element) {
    // Return body, `getScroll` will take care to get the correct `scrollTop` from it
    if (!element) {
      return document.body;
    }

    switch (element.nodeName) {
      case 'HTML':
      case 'BODY':
        return element.ownerDocument.body;

      case '#document':
        return element.body;
    } // Firefox want us to check `-x` and `-y` variations as well


    var _getStyleComputedProp = getStyleComputedProperty(element),
        overflow = _getStyleComputedProp.overflow,
        overflowX = _getStyleComputedProp.overflowX,
        overflowY = _getStyleComputedProp.overflowY;

    if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
      return element;
    }

    return getScrollParent$1(getParentNode(element));
  }
  /**
   * Returns the reference node of the reference object, or the reference object itself.
   * @method
   * @memberof Popper.Utils
   * @param {Element|Object} reference - the reference element (the popper will be relative to this)
   * @returns {Element} parent
   */


  function getReferenceNode(reference) {
    return reference && reference.referenceNode ? reference.referenceNode : reference;
  }

  var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
  var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);
  /**
   * Determines if the browser is Internet Explorer
   * @method
   * @memberof Popper.Utils
   * @param {Number} version to check
   * @returns {Boolean} isIE
   */

  function isIE(version) {
    if (version === 11) {
      return isIE11;
    }

    if (version === 10) {
      return isIE10;
    }

    return isIE11 || isIE10;
  }
  /**
   * Returns the offset parent of the given element
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @returns {Element} offset parent
   */


  function getOffsetParent(element) {
    if (!element) {
      return document.documentElement;
    }

    var noOffsetParent = isIE(10) ? document.body : null; // NOTE: 1 DOM access here

    var offsetParent = element.offsetParent || null; // Skip hidden elements which don't have an offsetParent

    while (offsetParent === noOffsetParent && element.nextElementSibling) {
      offsetParent = (element = element.nextElementSibling).offsetParent;
    }

    var nodeName = offsetParent && offsetParent.nodeName;

    if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
      return element ? element.ownerDocument.documentElement : document.documentElement;
    } // .offsetParent will return the closest TH, TD or TABLE in case
    // no offsetParent is present, I hate this job...


    if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
      return getOffsetParent(offsetParent);
    }

    return offsetParent;
  }

  function isOffsetContainer(element) {
    var nodeName = element.nodeName;

    if (nodeName === 'BODY') {
      return false;
    }

    return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
  }
  /**
   * Finds the root node (document, shadowDOM root) of the given element
   * @method
   * @memberof Popper.Utils
   * @argument {Element} node
   * @returns {Element} root node
   */


  function getRoot(node) {
    if (node.parentNode !== null) {
      return getRoot(node.parentNode);
    }

    return node;
  }
  /**
   * Finds the offset parent common to the two provided nodes
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element1
   * @argument {Element} element2
   * @returns {Element} common offset parent
   */


  function findCommonOffsetParent(element1, element2) {
    // This check is needed to avoid errors in case one of the elements isn't defined for any reason
    if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
      return document.documentElement;
    } // Here we make sure to give as "start" the element that comes first in the DOM


    var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
    var start = order ? element1 : element2;
    var end = order ? element2 : element1; // Get common ancestor container

    var range = document.createRange();
    range.setStart(start, 0);
    range.setEnd(end, 0);
    var commonAncestorContainer = range.commonAncestorContainer; // Both nodes are inside #document

    if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
      if (isOffsetContainer(commonAncestorContainer)) {
        return commonAncestorContainer;
      }

      return getOffsetParent(commonAncestorContainer);
    } // one of the nodes is inside shadowDOM, find which one


    var element1root = getRoot(element1);

    if (element1root.host) {
      return findCommonOffsetParent(element1root.host, element2);
    } else {
      return findCommonOffsetParent(element1, getRoot(element2).host);
    }
  }
  /**
   * Gets the scroll value of the given element in the given side (top and left)
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @argument {String} side `top` or `left`
   * @returns {number} amount of scrolled pixels
   */


  function getScroll(element) {
    var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';
    var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
    var nodeName = element.nodeName;

    if (nodeName === 'BODY' || nodeName === 'HTML') {
      var html = element.ownerDocument.documentElement;
      var scrollingElement = element.ownerDocument.scrollingElement || html;
      return scrollingElement[upperSide];
    }

    return element[upperSide];
  }
  /*
   * Sum or subtract the element scroll values (left and top) from a given rect object
   * @method
   * @memberof Popper.Utils
   * @param {Object} rect - Rect object you want to change
   * @param {HTMLElement} element - The element from the function reads the scroll values
   * @param {Boolean} subtract - set to true if you want to subtract the scroll values
   * @return {Object} rect - The modifier rect object
   */


  function includeScroll(rect, element) {
    var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var scrollTop = getScroll(element, 'top');
    var scrollLeft = getScroll(element, 'left');
    var modifier = subtract ? -1 : 1;
    rect.top += scrollTop * modifier;
    rect.bottom += scrollTop * modifier;
    rect.left += scrollLeft * modifier;
    rect.right += scrollLeft * modifier;
    return rect;
  }
  /*
   * Helper to detect borders of a given element
   * @method
   * @memberof Popper.Utils
   * @param {CSSStyleDeclaration} styles
   * Result of `getStyleComputedProperty` on the given element
   * @param {String} axis - `x` or `y`
   * @return {number} borders - The borders size of the given axis
   */


  function getBordersSize(styles, axis) {
    var sideA = axis === 'x' ? 'Left' : 'Top';
    var sideB = sideA === 'Left' ? 'Right' : 'Bottom';
    return parseFloat(styles['border' + sideA + 'Width']) + parseFloat(styles['border' + sideB + 'Width']);
  }

  function getSize(axis, body, html, computedStyle) {
    return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? parseInt(html['offset' + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')]) : 0);
  }

  function getWindowSizes(document) {
    var body = document.body;
    var html = document.documentElement;
    var computedStyle = isIE(10) && getComputedStyle(html);
    return {
      height: getSize('Height', body, html, computedStyle),
      width: getSize('Width', body, html, computedStyle)
    };
  }

  var classCallCheck = function classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  var createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  var defineProperty$2 = function defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  };

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  /**
   * Given element offsets, generate an output similar to getBoundingClientRect
   * @method
   * @memberof Popper.Utils
   * @argument {Object} offsets
   * @returns {Object} ClientRect like output
   */


  function getClientRect(offsets) {
    return _extends({}, offsets, {
      right: offsets.left + offsets.width,
      bottom: offsets.top + offsets.height
    });
  }
  /**
   * Get bounding client rect of given element
   * @method
   * @memberof Popper.Utils
   * @param {HTMLElement} element
   * @return {Object} client rect
   */


  function getBoundingClientRect(element) {
    var rect = {}; // IE10 10 FIX: Please, don't ask, the element isn't
    // considered in DOM in some circumstances...
    // This isn't reproducible in IE10 compatibility mode of IE11

    try {
      if (isIE(10)) {
        rect = element.getBoundingClientRect();
        var scrollTop = getScroll(element, 'top');
        var scrollLeft = getScroll(element, 'left');
        rect.top += scrollTop;
        rect.left += scrollLeft;
        rect.bottom += scrollTop;
        rect.right += scrollLeft;
      } else {
        rect = element.getBoundingClientRect();
      }
    } catch (e) {}

    var result = {
      left: rect.left,
      top: rect.top,
      width: rect.right - rect.left,
      height: rect.bottom - rect.top
    }; // subtract scrollbar size from sizes

    var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};
    var width = sizes.width || element.clientWidth || result.width;
    var height = sizes.height || element.clientHeight || result.height;
    var horizScrollbar = element.offsetWidth - width;
    var vertScrollbar = element.offsetHeight - height; // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
    // we make this check conditional for performance reasons

    if (horizScrollbar || vertScrollbar) {
      var styles = getStyleComputedProperty(element);
      horizScrollbar -= getBordersSize(styles, 'x');
      vertScrollbar -= getBordersSize(styles, 'y');
      result.width -= horizScrollbar;
      result.height -= vertScrollbar;
    }

    return getClientRect(result);
  }

  function getOffsetRectRelativeToArbitraryNode(children, parent) {
    var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var isIE10 = isIE(10);
    var isHTML = parent.nodeName === 'HTML';
    var childrenRect = getBoundingClientRect(children);
    var parentRect = getBoundingClientRect(parent);
    var scrollParent = getScrollParent$1(children);
    var styles = getStyleComputedProperty(parent);
    var borderTopWidth = parseFloat(styles.borderTopWidth);
    var borderLeftWidth = parseFloat(styles.borderLeftWidth); // In cases where the parent is fixed, we must ignore negative scroll in offset calc

    if (fixedPosition && isHTML) {
      parentRect.top = Math.max(parentRect.top, 0);
      parentRect.left = Math.max(parentRect.left, 0);
    }

    var offsets = getClientRect({
      top: childrenRect.top - parentRect.top - borderTopWidth,
      left: childrenRect.left - parentRect.left - borderLeftWidth,
      width: childrenRect.width,
      height: childrenRect.height
    });
    offsets.marginTop = 0;
    offsets.marginLeft = 0; // Subtract margins of documentElement in case it's being used as parent
    // we do this only on HTML because it's the only element that behaves
    // differently when margins are applied to it. The margins are included in
    // the box of the documentElement, in the other cases not.

    if (!isIE10 && isHTML) {
      var marginTop = parseFloat(styles.marginTop);
      var marginLeft = parseFloat(styles.marginLeft);
      offsets.top -= borderTopWidth - marginTop;
      offsets.bottom -= borderTopWidth - marginTop;
      offsets.left -= borderLeftWidth - marginLeft;
      offsets.right -= borderLeftWidth - marginLeft; // Attach marginTop and marginLeft because in some circumstances we may need them

      offsets.marginTop = marginTop;
      offsets.marginLeft = marginLeft;
    }

    if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
      offsets = includeScroll(offsets, parent);
    }

    return offsets;
  }

  function getViewportOffsetRectRelativeToArtbitraryNode(element) {
    var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var html = element.ownerDocument.documentElement;
    var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
    var width = Math.max(html.clientWidth, window.innerWidth || 0);
    var height = Math.max(html.clientHeight, window.innerHeight || 0);
    var scrollTop = !excludeScroll ? getScroll(html) : 0;
    var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;
    var offset = {
      top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
      left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
      width: width,
      height: height
    };
    return getClientRect(offset);
  }
  /**
   * Check if the given element is fixed or is inside a fixed parent
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @argument {Element} customContainer
   * @returns {Boolean} answer to "isFixed?"
   */


  function isFixed(element) {
    var nodeName = element.nodeName;

    if (nodeName === 'BODY' || nodeName === 'HTML') {
      return false;
    }

    if (getStyleComputedProperty(element, 'position') === 'fixed') {
      return true;
    }

    var parentNode = getParentNode(element);

    if (!parentNode) {
      return false;
    }

    return isFixed(parentNode);
  }
  /**
   * Finds the first parent of an element that has a transformed property defined
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @returns {Element} first transformed parent or documentElement
   */


  function getFixedPositionOffsetParent(element) {
    // This check is needed to avoid errors in case one of the elements isn't defined for any reason
    if (!element || !element.parentElement || isIE()) {
      return document.documentElement;
    }

    var el = element.parentElement;

    while (el && getStyleComputedProperty(el, 'transform') === 'none') {
      el = el.parentElement;
    }

    return el || document.documentElement;
  }
  /**
   * Computed the boundaries limits and return them
   * @method
   * @memberof Popper.Utils
   * @param {HTMLElement} popper
   * @param {HTMLElement} reference
   * @param {number} padding
   * @param {HTMLElement} boundariesElement - Element used to define the boundaries
   * @param {Boolean} fixedPosition - Is in fixed position mode
   * @returns {Object} Coordinates of the boundaries
   */


  function getBoundaries(popper, reference, padding, boundariesElement) {
    var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false; // NOTE: 1 DOM access here

    var boundaries = {
      top: 0,
      left: 0
    };
    var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference)); // Handle viewport case

    if (boundariesElement === 'viewport') {
      boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
    } else {
      // Handle other cases based on DOM element used as boundaries
      var boundariesNode = void 0;

      if (boundariesElement === 'scrollParent') {
        boundariesNode = getScrollParent$1(getParentNode(reference));

        if (boundariesNode.nodeName === 'BODY') {
          boundariesNode = popper.ownerDocument.documentElement;
        }
      } else if (boundariesElement === 'window') {
        boundariesNode = popper.ownerDocument.documentElement;
      } else {
        boundariesNode = boundariesElement;
      }

      var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition); // In case of HTML, we need a different computation

      if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
        var _getWindowSizes = getWindowSizes(popper.ownerDocument),
            height = _getWindowSizes.height,
            width = _getWindowSizes.width;

        boundaries.top += offsets.top - offsets.marginTop;
        boundaries.bottom = height + offsets.top;
        boundaries.left += offsets.left - offsets.marginLeft;
        boundaries.right = width + offsets.left;
      } else {
        // for all the other DOM elements, this one is good
        boundaries = offsets;
      }
    } // Add paddings


    padding = padding || 0;
    var isPaddingNumber = typeof padding === 'number';
    boundaries.left += isPaddingNumber ? padding : padding.left || 0;
    boundaries.top += isPaddingNumber ? padding : padding.top || 0;
    boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
    boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;
    return boundaries;
  }

  function getArea(_ref) {
    var width = _ref.width,
        height = _ref.height;
    return width * height;
  }
  /**
   * Utility used to transform the `auto` placement to the placement with more
   * available space.
   * @method
   * @memberof Popper.Utils
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */


  function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
    var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

    if (placement.indexOf('auto') === -1) {
      return placement;
    }

    var boundaries = getBoundaries(popper, reference, padding, boundariesElement);
    var rects = {
      top: {
        width: boundaries.width,
        height: refRect.top - boundaries.top
      },
      right: {
        width: boundaries.right - refRect.right,
        height: boundaries.height
      },
      bottom: {
        width: boundaries.width,
        height: boundaries.bottom - refRect.bottom
      },
      left: {
        width: refRect.left - boundaries.left,
        height: boundaries.height
      }
    };
    var sortedAreas = Object.keys(rects).map(function (key) {
      return _extends({
        key: key
      }, rects[key], {
        area: getArea(rects[key])
      });
    }).sort(function (a, b) {
      return b.area - a.area;
    });
    var filteredAreas = sortedAreas.filter(function (_ref2) {
      var width = _ref2.width,
          height = _ref2.height;
      return width >= popper.clientWidth && height >= popper.clientHeight;
    });
    var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;
    var variation = placement.split('-')[1];
    return computedPlacement + (variation ? '-' + variation : '');
  }
  /**
   * Get offsets to the reference element
   * @method
   * @memberof Popper.Utils
   * @param {Object} state
   * @param {Element} popper - the popper element
   * @param {Element} reference - the reference element (the popper will be relative to this)
   * @param {Element} fixedPosition - is in fixed position mode
   * @returns {Object} An object containing the offsets which will be applied to the popper
   */


  function getReferenceOffsets(state, popper, reference) {
    var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));
    return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
  }
  /**
   * Get the outer sizes of the given element (offset size + margins)
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @returns {Object} object containing width and height properties
   */


  function getOuterSizes(element) {
    var window = element.ownerDocument.defaultView;
    var styles = window.getComputedStyle(element);
    var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);
    var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);
    var result = {
      width: element.offsetWidth + y,
      height: element.offsetHeight + x
    };
    return result;
  }
  /**
   * Get the opposite placement of the given one
   * @method
   * @memberof Popper.Utils
   * @argument {String} placement
   * @returns {String} flipped placement
   */


  function getOppositePlacement(placement) {
    var hash = {
      left: 'right',
      right: 'left',
      bottom: 'top',
      top: 'bottom'
    };
    return placement.replace(/left|right|bottom|top/g, function (matched) {
      return hash[matched];
    });
  }
  /**
   * Get offsets to the popper
   * @method
   * @memberof Popper.Utils
   * @param {Object} position - CSS position the Popper will get applied
   * @param {HTMLElement} popper - the popper element
   * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
   * @param {String} placement - one of the valid placement options
   * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
   */


  function getPopperOffsets(popper, referenceOffsets, placement) {
    placement = placement.split('-')[0]; // Get popper node sizes

    var popperRect = getOuterSizes(popper); // Add position, width and height to our offsets object

    var popperOffsets = {
      width: popperRect.width,
      height: popperRect.height
    }; // depending by the popper placement we have to compute its offsets slightly differently

    var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
    var mainSide = isHoriz ? 'top' : 'left';
    var secondarySide = isHoriz ? 'left' : 'top';
    var measurement = isHoriz ? 'height' : 'width';
    var secondaryMeasurement = !isHoriz ? 'height' : 'width';
    popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;

    if (placement === secondarySide) {
      popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
    } else {
      popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
    }

    return popperOffsets;
  }
  /**
   * Mimics the `find` method of Array
   * @method
   * @memberof Popper.Utils
   * @argument {Array} arr
   * @argument prop
   * @argument value
   * @returns index or -1
   */


  function find(arr, check) {
    // use native find if supported
    if (Array.prototype.find) {
      return arr.find(check);
    } // use `filter` to obtain the same behavior of `find`


    return arr.filter(check)[0];
  }
  /**
   * Return the index of the matching object
   * @method
   * @memberof Popper.Utils
   * @argument {Array} arr
   * @argument prop
   * @argument value
   * @returns index or -1
   */


  function findIndex(arr, prop, value) {
    // use native findIndex if supported
    if (Array.prototype.findIndex) {
      return arr.findIndex(function (cur) {
        return cur[prop] === value;
      });
    } // use `find` + `indexOf` if `findIndex` isn't supported


    var match = find(arr, function (obj) {
      return obj[prop] === value;
    });
    return arr.indexOf(match);
  }
  /**
   * Loop trough the list of modifiers and run them in order,
   * each of them will then edit the data object.
   * @method
   * @memberof Popper.Utils
   * @param {dataObject} data
   * @param {Array} modifiers
   * @param {String} ends - Optional modifier name used as stopper
   * @returns {dataObject}
   */


  function runModifiers(modifiers, data, ends) {
    var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));
    modifiersToRun.forEach(function (modifier) {
      if (modifier['function']) {
        // eslint-disable-line dot-notation
        console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
      }

      var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation

      if (modifier.enabled && isFunction$1(fn)) {
        // Add properties to offsets to make them a complete clientRect object
        // we do this before each modifier to make sure the previous one doesn't
        // mess with these values
        data.offsets.popper = getClientRect(data.offsets.popper);
        data.offsets.reference = getClientRect(data.offsets.reference);
        data = fn(data, modifier);
      }
    });
    return data;
  }
  /**
   * Updates the position of the popper, computing the new offsets and applying
   * the new style.<br />
   * Prefer `scheduleUpdate` over `update` because of performance reasons.
   * @method
   * @memberof Popper
   */


  function update() {
    // if popper is destroyed, don't perform any further update
    if (this.state.isDestroyed) {
      return;
    }

    var data = {
      instance: this,
      styles: {},
      arrowStyles: {},
      attributes: {},
      flipped: false,
      offsets: {}
    }; // compute reference element offsets

    data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed); // compute auto placement, store placement inside the data object,
    // modifiers will be able to edit `placement` if needed
    // and refer to originalPlacement to know the original value

    data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding); // store the computed placement inside `originalPlacement`

    data.originalPlacement = data.placement;
    data.positionFixed = this.options.positionFixed; // compute the popper offsets

    data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);
    data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute'; // run the modifiers

    data = runModifiers(this.modifiers, data); // the first `update` will call `onCreate` callback
    // the other ones will call `onUpdate` callback

    if (!this.state.isCreated) {
      this.state.isCreated = true;
      this.options.onCreate(data);
    } else {
      this.options.onUpdate(data);
    }
  }
  /**
   * Helper used to know if the given modifier is enabled.
   * @method
   * @memberof Popper.Utils
   * @returns {Boolean}
   */


  function isModifierEnabled(modifiers, modifierName) {
    return modifiers.some(function (_ref) {
      var name = _ref.name,
          enabled = _ref.enabled;
      return enabled && name === modifierName;
    });
  }
  /**
   * Get the prefixed supported property name
   * @method
   * @memberof Popper.Utils
   * @argument {String} property (camelCase)
   * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
   */


  function getSupportedPropertyName(property) {
    var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
    var upperProp = property.charAt(0).toUpperCase() + property.slice(1);

    for (var i = 0; i < prefixes.length; i++) {
      var prefix = prefixes[i];
      var toCheck = prefix ? '' + prefix + upperProp : property;

      if (typeof document.body.style[toCheck] !== 'undefined') {
        return toCheck;
      }
    }

    return null;
  }
  /**
   * Destroys the popper.
   * @method
   * @memberof Popper
   */


  function destroy() {
    this.state.isDestroyed = true; // touch DOM only if `applyStyle` modifier is enabled

    if (isModifierEnabled(this.modifiers, 'applyStyle')) {
      this.popper.removeAttribute('x-placement');
      this.popper.style.position = '';
      this.popper.style.top = '';
      this.popper.style.left = '';
      this.popper.style.right = '';
      this.popper.style.bottom = '';
      this.popper.style.willChange = '';
      this.popper.style[getSupportedPropertyName('transform')] = '';
    }

    this.disableEventListeners(); // remove the popper if user explicitly asked for the deletion on destroy
    // do not use `remove` because IE11 doesn't support it

    if (this.options.removeOnDestroy) {
      this.popper.parentNode.removeChild(this.popper);
    }

    return this;
  }
  /**
   * Get the window associated with the element
   * @argument {Element} element
   * @returns {Window}
   */


  function getWindow(element) {
    var ownerDocument = element.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView : window;
  }

  function attachToScrollParents(scrollParent, event, callback, scrollParents) {
    var isBody = scrollParent.nodeName === 'BODY';
    var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
    target.addEventListener(event, callback, {
      passive: true
    });

    if (!isBody) {
      attachToScrollParents(getScrollParent$1(target.parentNode), event, callback, scrollParents);
    }

    scrollParents.push(target);
  }
  /**
   * Setup needed event listeners used to update the popper position
   * @method
   * @memberof Popper.Utils
   * @private
   */


  function setupEventListeners(reference, options, state, updateBound) {
    // Resize event listener on window
    state.updateBound = updateBound;
    getWindow(reference).addEventListener('resize', state.updateBound, {
      passive: true
    }); // Scroll event listener on scroll parents

    var scrollElement = getScrollParent$1(reference);
    attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
    state.scrollElement = scrollElement;
    state.eventsEnabled = true;
    return state;
  }
  /**
   * It will add resize/scroll events and start recalculating
   * position of the popper element when they are triggered.
   * @method
   * @memberof Popper
   */


  function enableEventListeners() {
    if (!this.state.eventsEnabled) {
      this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
    }
  }
  /**
   * Remove event listeners used to update the popper position
   * @method
   * @memberof Popper.Utils
   * @private
   */


  function removeEventListeners(reference, state) {
    // Remove resize event listener on window
    getWindow(reference).removeEventListener('resize', state.updateBound); // Remove scroll event listener on scroll parents

    state.scrollParents.forEach(function (target) {
      target.removeEventListener('scroll', state.updateBound);
    }); // Reset state

    state.updateBound = null;
    state.scrollParents = [];
    state.scrollElement = null;
    state.eventsEnabled = false;
    return state;
  }
  /**
   * It will remove resize/scroll events and won't recalculate popper position
   * when they are triggered. It also won't trigger `onUpdate` callback anymore,
   * unless you call `update` method manually.
   * @method
   * @memberof Popper
   */


  function disableEventListeners() {
    if (this.state.eventsEnabled) {
      cancelAnimationFrame(this.scheduleUpdate);
      this.state = removeEventListeners(this.reference, this.state);
    }
  }
  /**
   * Tells if a given input is a number
   * @method
   * @memberof Popper.Utils
   * @param {*} input to check
   * @return {Boolean}
   */


  function isNumeric(n) {
    return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
  }
  /**
   * Set the style to the given popper
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element - Element to apply the style to
   * @argument {Object} styles
   * Object with a list of properties and values which will be applied to the element
   */


  function setStyles(element, styles) {
    Object.keys(styles).forEach(function (prop) {
      var unit = ''; // add unit if the value is numeric and is one of the following

      if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
        unit = 'px';
      }

      element.style[prop] = styles[prop] + unit;
    });
  }
  /**
   * Set the attributes to the given popper
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element - Element to apply the attributes to
   * @argument {Object} styles
   * Object with a list of properties and values which will be applied to the element
   */


  function setAttributes(element, attributes) {
    Object.keys(attributes).forEach(function (prop) {
      var value = attributes[prop];

      if (value !== false) {
        element.setAttribute(prop, attributes[prop]);
      } else {
        element.removeAttribute(prop);
      }
    });
  }
  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} data.styles - List of style properties - values to apply to popper element
   * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The same data object
   */


  function applyStyle(data) {
    // any property present in `data.styles` will be applied to the popper,
    // in this way we can make the 3rd party modifiers add custom styles to it
    // Be aware, modifiers could override the properties defined in the previous
    // lines of this modifier!
    setStyles(data.instance.popper, data.styles); // any property present in `data.attributes` will be applied to the popper,
    // they will be set as HTML attributes of the element

    setAttributes(data.instance.popper, data.attributes); // if arrowElement is defined and arrowStyles has some properties

    if (data.arrowElement && Object.keys(data.arrowStyles).length) {
      setStyles(data.arrowElement, data.arrowStyles);
    }

    return data;
  }
  /**
   * Set the x-placement attribute before everything else because it could be used
   * to add margins to the popper margins needs to be calculated to get the
   * correct popper offsets.
   * @method
   * @memberof Popper.modifiers
   * @param {HTMLElement} reference - The reference element used to position the popper
   * @param {HTMLElement} popper - The HTML element used as popper
   * @param {Object} options - Popper.js options
   */


  function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
    // compute reference element offsets
    var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed); // compute auto placement, store placement inside the data object,
    // modifiers will be able to edit `placement` if needed
    // and refer to originalPlacement to know the original value

    var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);
    popper.setAttribute('x-placement', placement); // Apply `position` to popper before anything else because
    // without the position applied we can't guarantee correct computations

    setStyles(popper, {
      position: options.positionFixed ? 'fixed' : 'absolute'
    });
    return options;
  }
  /**
   * @function
   * @memberof Popper.Utils
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Boolean} shouldRound - If the offsets should be rounded at all
   * @returns {Object} The popper's position offsets rounded
   *
   * The tale of pixel-perfect positioning. It's still not 100% perfect, but as
   * good as it can be within reason.
   * Discussion here: https://github.com/FezVrasta/popper.js/pull/715
   *
   * Low DPI screens cause a popper to be blurry if not using full pixels (Safari
   * as well on High DPI screens).
   *
   * Firefox prefers no rounding for positioning and does not have blurriness on
   * high DPI screens.
   *
   * Only horizontal placement and left/right values need to be considered.
   */


  function getRoundedOffsets(data, shouldRound) {
    var _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;
    var round = Math.round,
        floor = Math.floor;

    var noRound = function noRound(v) {
      return v;
    };

    var referenceWidth = round(reference.width);
    var popperWidth = round(popper.width);
    var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;
    var isVariation = data.placement.indexOf('-') !== -1;
    var sameWidthParity = referenceWidth % 2 === popperWidth % 2;
    var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;
    var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;
    var verticalToInteger = !shouldRound ? noRound : round;
    return {
      left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),
      top: verticalToInteger(popper.top),
      bottom: verticalToInteger(popper.bottom),
      right: horizontalToInteger(popper.right)
    };
  }

  var isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);
  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */

  function computeStyle(data, options) {
    var x = options.x,
        y = options.y;
    var popper = data.offsets.popper; // Remove this legacy support in Popper.js v2

    var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
      return modifier.name === 'applyStyle';
    }).gpuAcceleration;

    if (legacyGpuAccelerationOption !== undefined) {
      console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
    }

    var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;
    var offsetParent = getOffsetParent(data.instance.popper);
    var offsetParentRect = getBoundingClientRect(offsetParent); // Styles

    var styles = {
      position: popper.position
    };
    var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);
    var sideA = x === 'bottom' ? 'top' : 'bottom';
    var sideB = y === 'right' ? 'left' : 'right'; // if gpuAcceleration is set to `true` and transform is supported,
    //  we use `translate3d` to apply the position to the popper we
    // automatically use the supported prefixed version if needed

    var prefixedProperty = getSupportedPropertyName('transform'); // now, let's make a step back and look at this code closely (wtf?)
    // If the content of the popper grows once it's been positioned, it
    // may happen that the popper gets misplaced because of the new content
    // overflowing its reference element
    // To avoid this problem, we provide two options (x and y), which allow
    // the consumer to define the offset origin.
    // If we position a popper on top of a reference element, we can set
    // `x` to `top` to make the popper grow towards its top instead of
    // its bottom.

    var left = void 0,
        top = void 0;

    if (sideA === 'bottom') {
      // when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)
      // and not the bottom of the html element
      if (offsetParent.nodeName === 'HTML') {
        top = -offsetParent.clientHeight + offsets.bottom;
      } else {
        top = -offsetParentRect.height + offsets.bottom;
      }
    } else {
      top = offsets.top;
    }

    if (sideB === 'right') {
      if (offsetParent.nodeName === 'HTML') {
        left = -offsetParent.clientWidth + offsets.right;
      } else {
        left = -offsetParentRect.width + offsets.right;
      }
    } else {
      left = offsets.left;
    }

    if (gpuAcceleration && prefixedProperty) {
      styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
      styles[sideA] = 0;
      styles[sideB] = 0;
      styles.willChange = 'transform';
    } else {
      // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
      var invertTop = sideA === 'bottom' ? -1 : 1;
      var invertLeft = sideB === 'right' ? -1 : 1;
      styles[sideA] = top * invertTop;
      styles[sideB] = left * invertLeft;
      styles.willChange = sideA + ', ' + sideB;
    } // Attributes


    var attributes = {
      'x-placement': data.placement
    }; // Update `data` attributes, styles and arrowStyles

    data.attributes = _extends({}, attributes, data.attributes);
    data.styles = _extends({}, styles, data.styles);
    data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);
    return data;
  }
  /**
   * Helper used to know if the given modifier depends from another one.<br />
   * It checks if the needed modifier is listed and enabled.
   * @method
   * @memberof Popper.Utils
   * @param {Array} modifiers - list of modifiers
   * @param {String} requestingName - name of requesting modifier
   * @param {String} requestedName - name of requested modifier
   * @returns {Boolean}
   */


  function isModifierRequired(modifiers, requestingName, requestedName) {
    var requesting = find(modifiers, function (_ref) {
      var name = _ref.name;
      return name === requestingName;
    });
    var isRequired = !!requesting && modifiers.some(function (modifier) {
      return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
    });

    if (!isRequired) {
      var _requesting = '`' + requestingName + '`';

      var requested = '`' + requestedName + '`';
      console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
    }

    return isRequired;
  }
  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */


  function arrow(data, options) {
    var _data$offsets$arrow; // arrow depends on keepTogether in order to work


    if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
      return data;
    }

    var arrowElement = options.element; // if arrowElement is a string, suppose it's a CSS selector

    if (typeof arrowElement === 'string') {
      arrowElement = data.instance.popper.querySelector(arrowElement); // if arrowElement is not found, don't run the modifier

      if (!arrowElement) {
        return data;
      }
    } else {
      // if the arrowElement isn't a query selector we must check that the
      // provided DOM node is child of its popper node
      if (!data.instance.popper.contains(arrowElement)) {
        console.warn('WARNING: `arrow.element` must be child of its popper element!');
        return data;
      }
    }

    var placement = data.placement.split('-')[0];
    var _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;
    var isVertical = ['left', 'right'].indexOf(placement) !== -1;
    var len = isVertical ? 'height' : 'width';
    var sideCapitalized = isVertical ? 'Top' : 'Left';
    var side = sideCapitalized.toLowerCase();
    var altSide = isVertical ? 'left' : 'top';
    var opSide = isVertical ? 'bottom' : 'right';
    var arrowElementSize = getOuterSizes(arrowElement)[len]; //
    // extends keepTogether behavior making sure the popper and its
    // reference have enough pixels in conjunction
    //
    // top/left side

    if (reference[opSide] - arrowElementSize < popper[side]) {
      data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
    } // bottom/right side


    if (reference[side] + arrowElementSize > popper[opSide]) {
      data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
    }

    data.offsets.popper = getClientRect(data.offsets.popper); // compute center of the popper

    var center = reference[side] + reference[len] / 2 - arrowElementSize / 2; // Compute the sideValue using the updated popper offsets
    // take popper margin in account because we don't have this info available

    var css = getStyleComputedProperty(data.instance.popper);
    var popperMarginSide = parseFloat(css['margin' + sideCapitalized]);
    var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width']);
    var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide; // prevent arrowElement from being placed not contiguously to its popper

    sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);
    data.arrowElement = arrowElement;
    data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty$2(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty$2(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);
    return data;
  }
  /**
   * Get the opposite placement variation of the given one
   * @method
   * @memberof Popper.Utils
   * @argument {String} placement variation
   * @returns {String} flipped placement variation
   */


  function getOppositeVariation(variation) {
    if (variation === 'end') {
      return 'start';
    } else if (variation === 'start') {
      return 'end';
    }

    return variation;
  }
  /**
   * List of accepted placements to use as values of the `placement` option.<br />
   * Valid placements are:
   * - `auto`
   * - `top`
   * - `right`
   * - `bottom`
   * - `left`
   *
   * Each placement can have a variation from this list:
   * - `-start`
   * - `-end`
   *
   * Variations are interpreted easily if you think of them as the left to right
   * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
   * is right.<br />
   * Vertically (`left` and `right`), `start` is top and `end` is bottom.
   *
   * Some valid examples are:
   * - `top-end` (on top of reference, right aligned)
   * - `right-start` (on right of reference, top aligned)
   * - `bottom` (on bottom, centered)
   * - `auto-end` (on the side with more space available, alignment depends by placement)
   *
   * @static
   * @type {Array}
   * @enum {String}
   * @readonly
   * @method placements
   * @memberof Popper
   */


  var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start']; // Get rid of `auto` `auto-start` and `auto-end`

  var validPlacements = placements.slice(3);
  /**
   * Given an initial placement, returns all the subsequent placements
   * clockwise (or counter-clockwise).
   *
   * @method
   * @memberof Popper.Utils
   * @argument {String} placement - A valid placement (it accepts variations)
   * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
   * @returns {Array} placements including their variations
   */

  function clockwise(placement) {
    var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var index = validPlacements.indexOf(placement);
    var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
    return counter ? arr.reverse() : arr;
  }

  var BEHAVIORS = {
    FLIP: 'flip',
    CLOCKWISE: 'clockwise',
    COUNTERCLOCKWISE: 'counterclockwise'
  };
  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */

  function flip(data, options) {
    // if `inner` modifier is enabled, we can't use the `flip` modifier
    if (isModifierEnabled(data.instance.modifiers, 'inner')) {
      return data;
    }

    if (data.flipped && data.placement === data.originalPlacement) {
      // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
      return data;
    }

    var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);
    var placement = data.placement.split('-')[0];
    var placementOpposite = getOppositePlacement(placement);
    var variation = data.placement.split('-')[1] || '';
    var flipOrder = [];

    switch (options.behavior) {
      case BEHAVIORS.FLIP:
        flipOrder = [placement, placementOpposite];
        break;

      case BEHAVIORS.CLOCKWISE:
        flipOrder = clockwise(placement);
        break;

      case BEHAVIORS.COUNTERCLOCKWISE:
        flipOrder = clockwise(placement, true);
        break;

      default:
        flipOrder = options.behavior;
    }

    flipOrder.forEach(function (step, index) {
      if (placement !== step || flipOrder.length === index + 1) {
        return data;
      }

      placement = data.placement.split('-')[0];
      placementOpposite = getOppositePlacement(placement);
      var popperOffsets = data.offsets.popper;
      var refOffsets = data.offsets.reference; // using floor because the reference offsets may contain decimals we are not going to consider here

      var floor = Math.floor;
      var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);
      var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
      var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
      var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
      var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);
      var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom; // flip the variation if required

      var isVertical = ['top', 'bottom'].indexOf(placement) !== -1; // flips variation if reference element overflows boundaries

      var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom); // flips variation if popper content overflows boundaries

      var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === 'start' && overflowsRight || isVertical && variation === 'end' && overflowsLeft || !isVertical && variation === 'start' && overflowsBottom || !isVertical && variation === 'end' && overflowsTop);
      var flippedVariation = flippedVariationByRef || flippedVariationByContent;

      if (overlapsRef || overflowsBoundaries || flippedVariation) {
        // this boolean to detect any flip loop
        data.flipped = true;

        if (overlapsRef || overflowsBoundaries) {
          placement = flipOrder[index + 1];
        }

        if (flippedVariation) {
          variation = getOppositeVariation(variation);
        }

        data.placement = placement + (variation ? '-' + variation : ''); // this object contains `position`, we want to preserve it along with
        // any additional property we may add in the future

        data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));
        data = runModifiers(data.instance.modifiers, data, 'flip');
      }
    });
    return data;
  }
  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */


  function keepTogether(data) {
    var _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;
    var placement = data.placement.split('-')[0];
    var floor = Math.floor;
    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
    var side = isVertical ? 'right' : 'bottom';
    var opSide = isVertical ? 'left' : 'top';
    var measurement = isVertical ? 'width' : 'height';

    if (popper[side] < floor(reference[opSide])) {
      data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
    }

    if (popper[opSide] > floor(reference[side])) {
      data.offsets.popper[opSide] = floor(reference[side]);
    }

    return data;
  }
  /**
   * Converts a string containing value + unit into a px value number
   * @function
   * @memberof {modifiers~offset}
   * @private
   * @argument {String} str - Value + unit string
   * @argument {String} measurement - `height` or `width`
   * @argument {Object} popperOffsets
   * @argument {Object} referenceOffsets
   * @returns {Number|String}
   * Value in pixels, or original string if no values were extracted
   */


  function toValue(str, measurement, popperOffsets, referenceOffsets) {
    // separate value from unit
    var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
    var value = +split[1];
    var unit = split[2]; // If it's not a number it's an operator, I guess

    if (!value) {
      return str;
    }

    if (unit.indexOf('%') === 0) {
      var element = void 0;

      switch (unit) {
        case '%p':
          element = popperOffsets;
          break;

        case '%':
        case '%r':
        default:
          element = referenceOffsets;
      }

      var rect = getClientRect(element);
      return rect[measurement] / 100 * value;
    } else if (unit === 'vh' || unit === 'vw') {
      // if is a vh or vw, we calculate the size based on the viewport
      var size = void 0;

      if (unit === 'vh') {
        size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
      } else {
        size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
      }

      return size / 100 * value;
    } else {
      // if is an explicit pixel unit, we get rid of the unit and keep the value
      // if is an implicit unit, it's px, and we return just the value
      return value;
    }
  }
  /**
   * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
   * @function
   * @memberof {modifiers~offset}
   * @private
   * @argument {String} offset
   * @argument {Object} popperOffsets
   * @argument {Object} referenceOffsets
   * @argument {String} basePlacement
   * @returns {Array} a two cells array with x and y offsets in numbers
   */


  function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
    var offsets = [0, 0]; // Use height if placement is left or right and index is 0 otherwise use width
    // in this way the first offset will use an axis and the second one
    // will use the other one

    var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1; // Split the offset string to obtain a list of values and operands
    // The regex addresses values with the plus or minus sign in front (+10, -20, etc)

    var fragments = offset.split(/(\+|\-)/).map(function (frag) {
      return frag.trim();
    }); // Detect if the offset string contains a pair of values or a single one
    // they could be separated by comma or space

    var divider = fragments.indexOf(find(fragments, function (frag) {
      return frag.search(/,|\s/) !== -1;
    }));

    if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
      console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
    } // If divider is found, we divide the list of values and operands to divide
    // them by ofset X and Y.


    var splitRegex = /\s*,\s*|\s+/;
    var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments]; // Convert the values with units to absolute pixels to allow our computations

    ops = ops.map(function (op, index) {
      // Most of the units rely on the orientation of the popper
      var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
      var mergeWithPrevious = false;
      return op // This aggregates any `+` or `-` sign that aren't considered operators
      // e.g.: 10 + +5 => [10, +, +5]
      .reduce(function (a, b) {
        if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
          a[a.length - 1] = b;
          mergeWithPrevious = true;
          return a;
        } else if (mergeWithPrevious) {
          a[a.length - 1] += b;
          mergeWithPrevious = false;
          return a;
        } else {
          return a.concat(b);
        }
      }, []) // Here we convert the string values into number values (in px)
      .map(function (str) {
        return toValue(str, measurement, popperOffsets, referenceOffsets);
      });
    }); // Loop trough the offsets arrays and execute the operations

    ops.forEach(function (op, index) {
      op.forEach(function (frag, index2) {
        if (isNumeric(frag)) {
          offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
        }
      });
    });
    return offsets;
  }
  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @argument {Number|String} options.offset=0
   * The offset value as described in the modifier description
   * @returns {Object} The data object, properly modified
   */


  function offset(data, _ref) {
    var offset = _ref.offset;
    var placement = data.placement,
        _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;
    var basePlacement = placement.split('-')[0];
    var offsets = void 0;

    if (isNumeric(+offset)) {
      offsets = [+offset, 0];
    } else {
      offsets = parseOffset(offset, popper, reference, basePlacement);
    }

    if (basePlacement === 'left') {
      popper.top += offsets[0];
      popper.left -= offsets[1];
    } else if (basePlacement === 'right') {
      popper.top += offsets[0];
      popper.left += offsets[1];
    } else if (basePlacement === 'top') {
      popper.left += offsets[0];
      popper.top -= offsets[1];
    } else if (basePlacement === 'bottom') {
      popper.left += offsets[0];
      popper.top += offsets[1];
    }

    data.popper = popper;
    return data;
  }
  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */


  function preventOverflow(data, options) {
    var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper); // If offsetParent is the reference element, we really want to
    // go one step up and use the next offsetParent as reference to
    // avoid to make this modifier completely useless and look like broken

    if (data.instance.reference === boundariesElement) {
      boundariesElement = getOffsetParent(boundariesElement);
    } // NOTE: DOM access here
    // resets the popper's position so that the document size can be calculated excluding
    // the size of the popper element itself


    var transformProp = getSupportedPropertyName('transform');
    var popperStyles = data.instance.popper.style; // assignment to help minification

    var top = popperStyles.top,
        left = popperStyles.left,
        transform = popperStyles[transformProp];
    popperStyles.top = '';
    popperStyles.left = '';
    popperStyles[transformProp] = '';
    var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed); // NOTE: DOM access here
    // restores the original style properties after the offsets have been computed

    popperStyles.top = top;
    popperStyles.left = left;
    popperStyles[transformProp] = transform;
    options.boundaries = boundaries;
    var order = options.priority;
    var popper = data.offsets.popper;
    var check = {
      primary: function primary(placement) {
        var value = popper[placement];

        if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
          value = Math.max(popper[placement], boundaries[placement]);
        }

        return defineProperty$2({}, placement, value);
      },
      secondary: function secondary(placement) {
        var mainSide = placement === 'right' ? 'left' : 'top';
        var value = popper[mainSide];

        if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
          value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
        }

        return defineProperty$2({}, mainSide, value);
      }
    };
    order.forEach(function (placement) {
      var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
      popper = _extends({}, popper, check[side](placement));
    });
    data.offsets.popper = popper;
    return data;
  }
  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */


  function shift(data) {
    var placement = data.placement;
    var basePlacement = placement.split('-')[0];
    var shiftvariation = placement.split('-')[1]; // if shift shiftvariation is specified, run the modifier

    if (shiftvariation) {
      var _data$offsets = data.offsets,
          reference = _data$offsets.reference,
          popper = _data$offsets.popper;
      var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
      var side = isVertical ? 'left' : 'top';
      var measurement = isVertical ? 'width' : 'height';
      var shiftOffsets = {
        start: defineProperty$2({}, side, reference[side]),
        end: defineProperty$2({}, side, reference[side] + reference[measurement] - popper[measurement])
      };
      data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
    }

    return data;
  }
  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */


  function hide(data) {
    if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
      return data;
    }

    var refRect = data.offsets.reference;
    var bound = find(data.instance.modifiers, function (modifier) {
      return modifier.name === 'preventOverflow';
    }).boundaries;

    if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
      // Avoid unnecessary DOM access if visibility hasn't changed
      if (data.hide === true) {
        return data;
      }

      data.hide = true;
      data.attributes['x-out-of-boundaries'] = '';
    } else {
      // Avoid unnecessary DOM access if visibility hasn't changed
      if (data.hide === false) {
        return data;
      }

      data.hide = false;
      data.attributes['x-out-of-boundaries'] = false;
    }

    return data;
  }
  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */


  function inner(data) {
    var placement = data.placement;
    var basePlacement = placement.split('-')[0];
    var _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;
    var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;
    var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;
    popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);
    data.placement = getOppositePlacement(placement);
    data.offsets.popper = getClientRect(popper);
    return data;
  }
  /**
   * Modifier function, each modifier can have a function of this type assigned
   * to its `fn` property.<br />
   * These functions will be called on each update, this means that you must
   * make sure they are performant enough to avoid performance bottlenecks.
   *
   * @function ModifierFn
   * @argument {dataObject} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {dataObject} The data object, properly modified
   */

  /**
   * Modifiers are plugins used to alter the behavior of your poppers.<br />
   * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
   * needed by the library.
   *
   * Usually you don't want to override the `order`, `fn` and `onLoad` props.
   * All the other properties are configurations that could be tweaked.
   * @namespace modifiers
   */


  var modifiers = {
    /**
     * Modifier used to shift the popper on the start or end of its reference
     * element.<br />
     * It will read the variation of the `placement` property.<br />
     * It can be one either `-end` or `-start`.
     * @memberof modifiers
     * @inner
     */
    shift: {
      /** @prop {number} order=100 - Index used to define the order of execution */
      order: 100,

      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,

      /** @prop {ModifierFn} */
      fn: shift
    },

    /**
     * The `offset` modifier can shift your popper on both its axis.
     *
     * It accepts the following units:
     * - `px` or unit-less, interpreted as pixels
     * - `%` or `%r`, percentage relative to the length of the reference element
     * - `%p`, percentage relative to the length of the popper element
     * - `vw`, CSS viewport width unit
     * - `vh`, CSS viewport height unit
     *
     * For length is intended the main axis relative to the placement of the popper.<br />
     * This means that if the placement is `top` or `bottom`, the length will be the
     * `width`. In case of `left` or `right`, it will be the `height`.
     *
     * You can provide a single value (as `Number` or `String`), or a pair of values
     * as `String` divided by a comma or one (or more) white spaces.<br />
     * The latter is a deprecated method because it leads to confusion and will be
     * removed in v2.<br />
     * Additionally, it accepts additions and subtractions between different units.
     * Note that multiplications and divisions aren't supported.
     *
     * Valid examples are:
     * ```
     * 10
     * '10%'
     * '10, 10'
     * '10%, 10'
     * '10 + 10%'
     * '10 - 5vh + 3%'
     * '-10px + 5vh, 5px - 6%'
     * ```
     * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
     * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
     * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).
     *
     * @memberof modifiers
     * @inner
     */
    offset: {
      /** @prop {number} order=200 - Index used to define the order of execution */
      order: 200,

      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,

      /** @prop {ModifierFn} */
      fn: offset,

      /** @prop {Number|String} offset=0
       * The offset value as described in the modifier description
       */
      offset: 0
    },

    /**
     * Modifier used to prevent the popper from being positioned outside the boundary.
     *
     * A scenario exists where the reference itself is not within the boundaries.<br />
     * We can say it has "escaped the boundaries" â or just "escaped".<br />
     * In this case we need to decide whether the popper should either:
     *
     * - detach from the reference and remain "trapped" in the boundaries, or
     * - if it should ignore the boundary and "escape with its reference"
     *
     * When `escapeWithReference` is set to`true` and reference is completely
     * outside its boundaries, the popper will overflow (or completely leave)
     * the boundaries in order to remain attached to the edge of the reference.
     *
     * @memberof modifiers
     * @inner
     */
    preventOverflow: {
      /** @prop {number} order=300 - Index used to define the order of execution */
      order: 300,

      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,

      /** @prop {ModifierFn} */
      fn: preventOverflow,

      /**
       * @prop {Array} [priority=['left','right','top','bottom']]
       * Popper will try to prevent overflow following these priorities by default,
       * then, it could overflow on the left and on top of the `boundariesElement`
       */
      priority: ['left', 'right', 'top', 'bottom'],

      /**
       * @prop {number} padding=5
       * Amount of pixel used to define a minimum distance between the boundaries
       * and the popper. This makes sure the popper always has a little padding
       * between the edges of its container
       */
      padding: 5,

      /**
       * @prop {String|HTMLElement} boundariesElement='scrollParent'
       * Boundaries used by the modifier. Can be `scrollParent`, `window`,
       * `viewport` or any DOM element.
       */
      boundariesElement: 'scrollParent'
    },

    /**
     * Modifier used to make sure the reference and its popper stay near each other
     * without leaving any gap between the two. Especially useful when the arrow is
     * enabled and you want to ensure that it points to its reference element.
     * It cares only about the first axis. You can still have poppers with margin
     * between the popper and its reference element.
     * @memberof modifiers
     * @inner
     */
    keepTogether: {
      /** @prop {number} order=400 - Index used to define the order of execution */
      order: 400,

      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,

      /** @prop {ModifierFn} */
      fn: keepTogether
    },

    /**
     * This modifier is used to move the `arrowElement` of the popper to make
     * sure it is positioned between the reference element and its popper element.
     * It will read the outer size of the `arrowElement` node to detect how many
     * pixels of conjunction are needed.
     *
     * It has no effect if no `arrowElement` is provided.
     * @memberof modifiers
     * @inner
     */
    arrow: {
      /** @prop {number} order=500 - Index used to define the order of execution */
      order: 500,

      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,

      /** @prop {ModifierFn} */
      fn: arrow,

      /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
      element: '[x-arrow]'
    },

    /**
     * Modifier used to flip the popper's placement when it starts to overlap its
     * reference element.
     *
     * Requires the `preventOverflow` modifier before it in order to work.
     *
     * **NOTE:** this modifier will interrupt the current update cycle and will
     * restart it if it detects the need to flip the placement.
     * @memberof modifiers
     * @inner
     */
    flip: {
      /** @prop {number} order=600 - Index used to define the order of execution */
      order: 600,

      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,

      /** @prop {ModifierFn} */
      fn: flip,

      /**
       * @prop {String|Array} behavior='flip'
       * The behavior used to change the popper's placement. It can be one of
       * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
       * placements (with optional variations)
       */
      behavior: 'flip',

      /**
       * @prop {number} padding=5
       * The popper will flip if it hits the edges of the `boundariesElement`
       */
      padding: 5,

      /**
       * @prop {String|HTMLElement} boundariesElement='viewport'
       * The element which will define the boundaries of the popper position.
       * The popper will never be placed outside of the defined boundaries
       * (except if `keepTogether` is enabled)
       */
      boundariesElement: 'viewport',

      /**
       * @prop {Boolean} flipVariations=false
       * The popper will switch placement variation between `-start` and `-end` when
       * the reference element overlaps its boundaries.
       *
       * The original placement should have a set variation.
       */
      flipVariations: false,

      /**
       * @prop {Boolean} flipVariationsByContent=false
       * The popper will switch placement variation between `-start` and `-end` when
       * the popper element overlaps its reference boundaries.
       *
       * The original placement should have a set variation.
       */
      flipVariationsByContent: false
    },

    /**
     * Modifier used to make the popper flow toward the inner of the reference element.
     * By default, when this modifier is disabled, the popper will be placed outside
     * the reference element.
     * @memberof modifiers
     * @inner
     */
    inner: {
      /** @prop {number} order=700 - Index used to define the order of execution */
      order: 700,

      /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
      enabled: false,

      /** @prop {ModifierFn} */
      fn: inner
    },

    /**
     * Modifier used to hide the popper when its reference element is outside of the
     * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
     * be used to hide with a CSS selector the popper when its reference is
     * out of boundaries.
     *
     * Requires the `preventOverflow` modifier before it in order to work.
     * @memberof modifiers
     * @inner
     */
    hide: {
      /** @prop {number} order=800 - Index used to define the order of execution */
      order: 800,

      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,

      /** @prop {ModifierFn} */
      fn: hide
    },

    /**
     * Computes the style that will be applied to the popper element to gets
     * properly positioned.
     *
     * Note that this modifier will not touch the DOM, it just prepares the styles
     * so that `applyStyle` modifier can apply it. This separation is useful
     * in case you need to replace `applyStyle` with a custom implementation.
     *
     * This modifier has `850` as `order` value to maintain backward compatibility
     * with previous versions of Popper.js. Expect the modifiers ordering method
     * to change in future major versions of the library.
     *
     * @memberof modifiers
     * @inner
     */
    computeStyle: {
      /** @prop {number} order=850 - Index used to define the order of execution */
      order: 850,

      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,

      /** @prop {ModifierFn} */
      fn: computeStyle,

      /**
       * @prop {Boolean} gpuAcceleration=true
       * If true, it uses the CSS 3D transformation to position the popper.
       * Otherwise, it will use the `top` and `left` properties
       */
      gpuAcceleration: true,

      /**
       * @prop {string} [x='bottom']
       * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
       * Change this if your popper should grow in a direction different from `bottom`
       */
      x: 'bottom',

      /**
       * @prop {string} [x='left']
       * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
       * Change this if your popper should grow in a direction different from `right`
       */
      y: 'right'
    },

    /**
     * Applies the computed styles to the popper element.
     *
     * All the DOM manipulations are limited to this modifier. This is useful in case
     * you want to integrate Popper.js inside a framework or view library and you
     * want to delegate all the DOM manipulations to it.
     *
     * Note that if you disable this modifier, you must make sure the popper element
     * has its position set to `absolute` before Popper.js can do its work!
     *
     * Just disable this modifier and define your own to achieve the desired effect.
     *
     * @memberof modifiers
     * @inner
     */
    applyStyle: {
      /** @prop {number} order=900 - Index used to define the order of execution */
      order: 900,

      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,

      /** @prop {ModifierFn} */
      fn: applyStyle,

      /** @prop {Function} */
      onLoad: applyStyleOnLoad,

      /**
       * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
       * @prop {Boolean} gpuAcceleration=true
       * If true, it uses the CSS 3D transformation to position the popper.
       * Otherwise, it will use the `top` and `left` properties
       */
      gpuAcceleration: undefined
    }
  };
  /**
   * The `dataObject` is an object containing all the information used by Popper.js.
   * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
   * @name dataObject
   * @property {Object} data.instance The Popper.js instance
   * @property {String} data.placement Placement applied to popper
   * @property {String} data.originalPlacement Placement originally defined on init
   * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
   * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper
   * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
   * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)
   * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)
   * @property {Object} data.boundaries Offsets of the popper boundaries
   * @property {Object} data.offsets The measurements of popper, reference and arrow elements
   * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
   * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
   * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
   */

  /**
   * Default options provided to Popper.js constructor.<br />
   * These can be overridden using the `options` argument of Popper.js.<br />
   * To override an option, simply pass an object with the same
   * structure of the `options` object, as the 3rd argument. For example:
   * ```
   * new Popper(ref, pop, {
   *   modifiers: {
   *     preventOverflow: { enabled: false }
   *   }
   * })
   * ```
   * @type {Object}
   * @static
   * @memberof Popper
   */

  var Defaults = {
    /**
     * Popper's placement.
     * @prop {Popper.placements} placement='bottom'
     */
    placement: 'bottom',

    /**
     * Set this to true if you want popper to position it self in 'fixed' mode
     * @prop {Boolean} positionFixed=false
     */
    positionFixed: false,

    /**
     * Whether events (resize, scroll) are initially enabled.
     * @prop {Boolean} eventsEnabled=true
     */
    eventsEnabled: true,

    /**
     * Set to true if you want to automatically remove the popper when
     * you call the `destroy` method.
     * @prop {Boolean} removeOnDestroy=false
     */
    removeOnDestroy: false,

    /**
     * Callback called when the popper is created.<br />
     * By default, it is set to no-op.<br />
     * Access Popper.js instance with `data.instance`.
     * @prop {onCreate}
     */
    onCreate: function onCreate() {},

    /**
     * Callback called when the popper is updated. This callback is not called
     * on the initialization/creation of the popper, but only on subsequent
     * updates.<br />
     * By default, it is set to no-op.<br />
     * Access Popper.js instance with `data.instance`.
     * @prop {onUpdate}
     */
    onUpdate: function onUpdate() {},

    /**
     * List of modifiers used to modify the offsets before they are applied to the popper.
     * They provide most of the functionalities of Popper.js.
     * @prop {modifiers}
     */
    modifiers: modifiers
  };
  /**
   * @callback onCreate
   * @param {dataObject} data
   */

  /**
   * @callback onUpdate
   * @param {dataObject} data
   */
  // Utils
  // Methods

  var Popper = function () {
    /**
     * Creates a new Popper.js instance.
     * @class Popper
     * @param {Element|referenceObject} reference - The reference element used to position the popper
     * @param {Element} popper - The HTML / XML element used as the popper
     * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
     * @return {Object} instance - The generated Popper.js instance
     */
    function Popper(reference, popper) {
      var _this = this;

      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      classCallCheck(this, Popper);

      this.scheduleUpdate = function () {
        return requestAnimationFrame(_this.update);
      }; // make update() debounced, so that it only runs at most once-per-tick


      this.update = debounce(this.update.bind(this)); // with {} we create a new object with the options inside it

      this.options = _extends({}, Popper.Defaults, options); // init state

      this.state = {
        isDestroyed: false,
        isCreated: false,
        scrollParents: []
      }; // get reference and popper elements (allow jQuery wrappers)

      this.reference = reference && reference.jquery ? reference[0] : reference;
      this.popper = popper && popper.jquery ? popper[0] : popper; // Deep merge modifiers options

      this.options.modifiers = {};
      Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
        _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
      }); // Refactoring modifiers' list (Object => Array)

      this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
        return _extends({
          name: name
        }, _this.options.modifiers[name]);
      }) // sort the modifiers by order
      .sort(function (a, b) {
        return a.order - b.order;
      }); // modifiers have the ability to execute arbitrary code when Popper.js get inited
      // such code is executed in the same order of its modifier
      // they could add new properties to their options configuration
      // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!

      this.modifiers.forEach(function (modifierOptions) {
        if (modifierOptions.enabled && isFunction$1(modifierOptions.onLoad)) {
          modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
        }
      }); // fire the first update to position the popper in the right place

      this.update();
      var eventsEnabled = this.options.eventsEnabled;

      if (eventsEnabled) {
        // setup event listeners, they will take care of update the position in specific situations
        this.enableEventListeners();
      }

      this.state.eventsEnabled = eventsEnabled;
    } // We can't use class properties because they don't get listed in the
    // class prototype and break stuff like Sinon stubs


    createClass(Popper, [{
      key: 'update',
      value: function update$$1() {
        return update.call(this);
      }
    }, {
      key: 'destroy',
      value: function destroy$$1() {
        return destroy.call(this);
      }
    }, {
      key: 'enableEventListeners',
      value: function enableEventListeners$$1() {
        return enableEventListeners.call(this);
      }
    }, {
      key: 'disableEventListeners',
      value: function disableEventListeners$$1() {
        return disableEventListeners.call(this);
      }
      /**
       * Schedules an update. It will run on the next UI update available.
       * @method scheduleUpdate
       * @memberof Popper
       */

      /**
       * Collection of utilities useful when writing custom modifiers.
       * Starting from version 1.7, this method is available only if you
       * include `popper-utils.js` before `popper.js`.
       *
       * **DEPRECATION**: This way to access PopperUtils is deprecated
       * and will be removed in v2! Use the PopperUtils module directly instead.
       * Due to the high instability of the methods contained in Utils, we can't
       * guarantee them to follow semver. Use them at your own risk!
       * @static
       * @private
       * @type {Object}
       * @deprecated since version 1.8
       * @member Utils
       * @memberof Popper
       */

    }]);
    return Popper;
  }();
  /**
   * The `referenceObject` is an object that provides an interface compatible with Popper.js
   * and lets you use it as replacement of a real DOM node.<br />
   * You can use this method to position a popper relatively to a set of coordinates
   * in case you don't have a DOM node to use as reference.
   *
   * ```
   * new Popper(referenceObject, popperNode);
   * ```
   *
   * NB: This feature isn't supported in Internet Explorer 10.
   * @name referenceObject
   * @property {Function} data.getBoundingClientRect
   * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
   * @property {number} data.clientWidth
   * An ES6 getter that will return the width of the virtual reference element.
   * @property {number} data.clientHeight
   * An ES6 getter that will return the height of the virtual reference element.
   */


  Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
  Popper.placements = placements;
  Popper.Defaults = Defaults;

  var DEPRECATED_ALIGN = 'Coral.Overlay: alignAt and alignMy have been deprecated. Please use the offset, inner and placement properties instead.';
  var DEPRECATED_FLIP_FIT = 'Coral.Overlay.collision.FLIP_FIT has been deprecated. Please use Coral.Overlay.collision.FLIP instead.';
  /**
   Enumeration for {@link Overlay} alignment pairs.
   @deprecated

   @typedef {Object} OverlayAlignEnum

   @property {String} LEFT_TOP
   Use the top of the left side as an anchor point.
   @property {String} LEFT_CENTER
   Use the center of the left side as an anchor point.
   @property {String} LEFT_BOTTOM
   Use the bottom of the left side as an anchor point.
   @property {String} CENTER_TOP
   Use the center of the top side as an anchor point.
   @property {String} CENTER_CENTER
   Use the center as an anchor point.
   @property {String} CENTER_BOTTOM
   Use the center of the bottom side as an anchor point.
   @property {String} RIGHT_TOP
   Use the top of the right side as an anchor point.
   @property {String} RIGHT_CENTER
   Use the center of the right side as an anchor point.
   @property {String} RIGHT_BOTTOM
   Use the bottom of the right side as an anchor point.
   */

  var align = {
    LEFT_TOP: 'left top',
    LEFT_CENTER: 'left center',
    LEFT_BOTTOM: 'left bottom',
    CENTER_TOP: 'center top',
    CENTER_CENTER: 'center center',
    CENTER_BOTTOM: 'center bottom',
    RIGHT_TOP: 'right top',
    RIGHT_CENTER: 'right center',
    RIGHT_BOTTOM: 'right bottom'
  };
  /**
   Enumeration for {@link Overlay} collision detection strategies.

   @typedef {Object} OverlayCollisionEnum

   @property {String} FLIP
   Flips the element to the opposite side of the target and the collision detection is run again to see if it will fit. Whichever side allows more of the element to be visible will be used.
   @property {String} FIT
   Shift the element away from the edge of the window.
   @property {String} FLIP_FIT
   Deprecated. First applies the flip logic, placing the element on whichever side allows more of the element to be visible. Then the fit logic is applied to ensure as much of the element is visible as possible.
   @property {String} NONE
   Does not apply any collision detection.
   */

  var collision = {
    FLIP: 'flip',
    FIT: 'fit',
    FLIP_FIT: 'flipfit',
    NONE: 'none'
  };
  /**
   Enumeration for {@link Overlay} anchored overlay targets.

   @typedef {Object} OverlayTargetEnum

   @property {String} PREVIOUS
   Use the previous sibling element in the DOM.
   @property {String} NEXT
   Use the next sibling element in the DOM.
   */

  var target = {
    PREVIOUS: '_prev',
    NEXT: '_next'
  };
  /**
   Enumeration for {@link Overlay} placement values.

   @typedef {Object} OverlayPlacementEnum

   @property {String} LEFT
   An overlay anchored to the left of the target.
   @property {String} RIGHT
   An overlay anchored to the right of the target.
   @property {String} BOTTOM
   An overlay anchored at the bottom the target.
   @property {String} TOP
   An overlay anchored at the top target.
   */

  var placement = {
    LEFT: 'left',
    RIGHT: 'right',
    BOTTOM: 'bottom',
    TOP: 'top'
  };
  /**
   Enumeration for {@link Overlay} interaction values.

   @typedef {Object} OverlayInteractionEnum

   @property {String} ON
   Keyboard interaction is enabled.
   @property {String} OFF
   Keyboard interaction is disabled.
   */

  var interaction$1 = {
    ON: 'on',
    OFF: 'off'
  };
  var CLASSNAME$i = '_coral-Overlay';
  /**
   @class Coral.Overlay
   @classdesc A generic Overlay component.
   @htmltag coral-overlay
   @extends {HTMLElement}
   @extends {BaseComponent}
   @extends {BaseOverlay}
   */

  var Overlay = /*#__PURE__*/function (_BaseOverlay) {
    _inherits(Overlay, _BaseOverlay);

    var _super = _createSuper(Overlay);

    /** @ignore */
    function Overlay() {
      var _this;

      _classCallCheck(this, Overlay);

      _this = _super.call(this); // Override from BaseOverlay

      _this._overlayAnimationTime = 0; // Popper default

      _this._withinOffset = 5; // Events

      _this._delegateEvents({
        'global:key:escape': '_handleEscape',
        'click [coral-close]': '_handleCloseClick'
      });

      return _this;
    }
    /**
     The element the overlay should position relative to. It accepts values from {@link OverlayTargetEnum}, as
     well as a DOM element or a CSS selector. If a CSS selector is provided, the first matching element will be used.
      @type {?HTMLElement|String}
     @default null
     */


    _createClass(Overlay, [{
      key: "_toggleSmartBehavior",
      value: function _toggleSmartBehavior(toggle) {
        var _this2 = this;

        if (toggle) {
          if (this.smart) {
            this._validateParentOverflow();
          }

          this._togglePopperEventListener(true); // We need an additional frame to help popper read the correct offsets


          window.requestAnimationFrame(function () {
            _this2.reposition();
          });
        } else {
          this._togglePopperEventListener(false);
        }
      }
    }, {
      key: "_togglePopperEventListener",
      value: function _togglePopperEventListener(toggle) {
        if (this._popper) {
          this._popper[toggle ? 'enableEventListeners' : 'disableEventListeners']();
        }
      }
      /** @ignore */

    }, {
      key: "_validateParentOverflow",
      value: function _validateParentOverflow() {
        var reposition = false; // Check parents if they potentially truncate the overlay

        var parent = this.parentElement;

        while (!reposition && parent) {
          if (parent !== document.body) {
            var computedStyle = window.getComputedStyle(parent);

            if (computedStyle.overflow === 'auto' || computedStyle.overflow === 'hidden' || parent.clientHeight === 0 || parent.clientWidth === 0) {
              reposition = true;
            }

            parent = parent.parentElement;
          } else {
            parent = null;
          }
        } // If it's the case then we move the overlay to make sure it's not truncated


        if (reposition) {
          this._ignoreConnectedCallback = true;
          this._repositioned = true;
          document.body.appendChild(this);
          this._ignoreConnectedCallback = false;
        }
      }
      /** @ignore */

    }, {
      key: "_onUpdate",
      value: function _onUpdate(data) {
        var _this3 = this;

        // Trigger once positioned the first time
        if (!this._oldPosition) {
          this._oldPosition = data.styles.transform; // Do it in the next frame to avoid triggering the event too early

          window.requestAnimationFrame(function () {
            _this3.trigger('coral-overlay:positioned', data);
          });
        } // Trigger again only if position changed
        else {
            this._oldPosition = this._oldPosition || data.styles.transform;

            if (this._oldPosition !== data.styles.transform) {
              this.trigger('coral-overlay:positioned', data);
            }

            this._oldPosition = data.styles.transform;
          }
      }
      /**
       @todo maybe this should be base or something
       @ignore
       */

    }, {
      key: "_handleCloseClick",
      value: function _handleCloseClick(event) {
        var dismissTarget = event.matchedTarget;
        var dismissValue = dismissTarget.getAttribute('coral-close');

        if (!dismissValue || this.matches(dismissValue)) {
          this.hide();
          event.stopPropagation();

          this._trackEvent('close', this.tagName.toLowerCase(), event);
        }
      }
      /**
       Hides the overlay if it's on the top. When <code>interaction</code> is OFF it is ignored.
        @ignore
       */

    }, {
      key: "_handleEscape",
      value: function _handleEscape(event) {
        if (this.interaction === interaction$1.ON && this.open && this._isTopOverlay()) {
          event.stopPropagation();
          this.hide();
        }
      }
    }, {
      key: "_getTarget",
      value: function _getTarget(targetValue) {
        return this.constructor._getTarget(this, targetValue);
      }
      /**
       Re-position the overlay if it's currently open.
        @function
       @param {Boolean} forceReposition
       Whether to force repositioning even if closed.
       */

    }, {
      key: "reposition",
      value: function reposition(forceReposition) {
        var _this4 = this;

        if (this._popper) {
          var targetElement = this._getTarget(); // Update target only if valid


          if (targetElement) {
            this._popper.reference = targetElement;
          }

          this._popper.options.placement = this.placement;

          this._popper.modifiers.forEach(function (modifier) {
            if (modifier.name === 'offset') {
              modifier.offset = "".concat(_this4.breadthOffset, ", ").concat(_this4.lengthOffset);
            } else if (modifier.name === 'flip') {
              modifier.enabled = _this4.collision !== collision.FIT && _this4.collision !== collision.NONE;
            } else if (modifier.name === 'inner') {
              modifier.enabled = _this4.inner;
            } else if (modifier.name === 'preventOverflow') {
              modifier.enabled = _this4.collision !== collision.NONE;
              var within = _this4.within;
              var boundary; // Check for allowed PopperJS strings

              if (within instanceof HTMLElement || ['scrollParent', 'window', 'viewport'].indexOf(within) !== -1) {
                boundary = within;
              } else if (typeof within === 'string') {
                boundary = document.querySelector(within); // Fallback to default if element is not found in the document

                if (!(boundary instanceof HTMLElement)) {
                  boundary = 'scrollParent';
                }
              }

              modifier.boundariesElement = boundary;
              modifier.padding = _this4.withinOffset;
            }
          });

          if (this.open || forceReposition) {
            this._popper.update();
          }
        }
      }
      /**
       Get the element the overlay is anchored to.
        @param {HTMLElement} [el]
       The reference element.
       @param {HTMLElement|String} [target]
       A specific target value to use.
       If not provided, the current target of the element will be used.
       @returns {HTMLElement|null}
       */

    }, {
      key: "connectedCallback",

      /** @ignore */
      value: function connectedCallback() {
        var _this5 = this;

        if (this._skipConnectedCallback()) {
          return;
        }

        _get(_getPrototypeOf(Overlay.prototype), "connectedCallback", this).call(this); // In case it was not added to the DOM, make sure popper is initialized by setting target


        this.target = this.target; // We need an additional frame to help popper read the correct offsets

        window.requestAnimationFrame(function () {
          // Force repositioning
          _this5.reposition(true);

          if (!_this5.open) {
            _this5._togglePopperEventListener(false);
          }
        });
      }
      /** @ignore */

    }, {
      key: "render",
      value: function render() {
        this.classList.add(CLASSNAME$i); // Hidden by default

        this.style.display = 'none';
      }
      /** @ignore */

    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        if (this._ignoreConnectedCallback) {
          return;
        }

        _get(_getPrototypeOf(Overlay.prototype), "disconnectedCallback", this).call(this);
      }
      /**
       Triggered after the {@link Overlay} is positioned.
        @typedef {CustomEvent} coral-overlay:positioned
       */

    }, {
      key: "target",
      get: function get() {
        return this._target || null;
      },
      set: function set(value) {
        // We don't want to validate that the value must change here
        // If a selector is provided, we'll take the first element matching that selector
        // If the DOM is modified and the user wants a new target with the same selector,
        // They should be able to set target = 'selector' again and get a different element
        if (value === null || typeof value === 'string' || value instanceof Node) {
          this._target = value;

          var targetElement = this._getTarget();

          if (targetElement) {
            // To make it return focus to the right item, change the target
            if (this._returnFocus === this.constructor.returnFocus.ON) {
              this.returnFocusTo(targetElement);
            } // Initialize popper only if we have a target


            this._popper = this._popper || new Popper(targetElement, this, {
              onUpdate: this._onUpdate.bind(this)
            }); // Make sure popper options modifiers are up to date

            this.reposition();
          }
        }
      }
      /**
       The point on the overlay we should anchor from when positioning. See {@link OverlayAlignEnum}.
        @type {String}
       @default OverlayAlignEnum.CENTER_CENTER
       @htmlattribute alignmy
        @deprecated
       */

    }, {
      key: "alignMy",
      get: function get() {
        return this._alignMy || align.CENTER_CENTER;
      },
      set: function set(value) {
        commons._log('warn', DEPRECATED_ALIGN);

        value = transform.string(value).toLowerCase();
        this._alignMy = validate.enumeration(align)(value) && value || align.CENTER_CENTER;
      }
      /**
       The point on the target we should anchor to when positioning. See {@link OverlayAlignEnum}.
        @type {String}
       @default Coral.Overlay.align.CENTER_CENTER
       @htmlattribute alignat
        @deprecated
       */

    }, {
      key: "alignAt",
      get: function get() {
        return this._alignAt || align.CENTER_CENTER;
      },
      set: function set(value) {
        commons._log('warn', DEPRECATED_ALIGN);

        value = transform.string(value).toLowerCase();
        this._alignAt = validate.enumeration(align)(value) && value || align.CENTER_CENTER;
      }
      /**
       The distance the overlay should be from its target.
        @type {Number}
       @default 0
       @htmlattribute offset
       */

    }, {
      key: "offset",
      get: function get() {
        return transform.number(this.lengthOffset);
      },
      set: function set(value) {
        value = transform.number(value);

        if (typeof value === 'number') {
          this.lengthOffset = "".concat(value, "px");
          this.breadthOffset = '0px';
          this.reposition();
        }
      }
      /**
       Whether the overlay flows toward the inner of the target element. By default, it's placed outside the target element.
        @type {Boolean}
       @default false
       @htmlattribute inner
       */

    }, {
      key: "inner",
      get: function get() {
        return this._inner || false;
      },
      set: function set(value) {
        this._inner = transform.booleanAttr(value);
        this.reposition();
      }
      /**
       The distance the overlay should be from its target along the length axis.
        @type {String}
       @default '0px'
       @htmlattribute lengthoffset
       */

    }, {
      key: "lengthOffset",
      get: function get() {
        return this._lengthOffset || '0px';
      },
      set: function set(value) {
        this._lengthOffset = transform.string(value) || '0px';
        this.reposition();
      }
      /**
       The distance the overlay should be from its target along the breadth axis.
        @type {String}
       @default '0px'
       @htmlattribute breadthoffset
       */

    }, {
      key: "breadthOffset",
      get: function get() {
        return this._breadthOffset || '0px';
      },
      set: function set(value) {
        this._breadthOffset = transform.string(value) || '0px';
        this.reposition();
      }
      /**
       The placement of the overlay. See {@link OverlayPlacementEnum}.
        @type {String}
       @default OverlayPlacementEnum.RIGHT
       @htmlattribute placement
       */

    }, {
      key: "placement",
      get: function get() {
        return this._placement || placement.RIGHT;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        this._placement = validate.enumeration(placement)(value) && value || placement.RIGHT;
        this.reposition();
      }
      /**
       The bounding element for the overlay. The overlay will be sized and positioned such that it is contained within
       this element. It accepts both a DOM Element or a CSS selector. If a CSS selector is provided, the first matching
       element will be used.
        @type {HTMLElement|String}
       @default 'scrollParent'
       */

    }, {
      key: "within",
      get: function get() {
        return this._within || 'scrollParent';
      },
      set: function set(value) {
        if (value instanceof HTMLElement || typeof value === 'string') {
          this._within = value;
          this.reposition();
        }
      }
      /**
       Amount of pixel used to define a minimum distance between the boundaries and the overlay.
       This makes sure the overlay always has a little padding between the edges of its container.
        @type {Number}
       @default 5
       @htmlattribute withinOffset
       */

    }, {
      key: "withinOffset",
      get: function get() {
        return this._withinOffset;
      },
      set: function set(value) {
        value = transform.number(value);

        if (typeof value === 'number') {
          this._withinOffset = value;
          this.reposition();
        }
      }
      /**
       The collision handling strategy when positioning the overlay relative to a target. See {@link OverlayCollisionEnum}.
        @type {String}
       @default OverlayCollisionEnum.FLIP
       @htmlattribute collision
       */

    }, {
      key: "collision",
      get: function get() {
        return this._collision || collision.FLIP;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        this._collision = validate.enumeration(collision)(value) && value || collision.FLIP;

        if (this._collision === collision.FLIP_FIT) {
          commons._log('warn', DEPRECATED_FLIP_FIT);
        }

        this.reposition();
      }
      /**
       Whether keyboard interaction is enabled. See {@link OverlayInteractionEnum}.
        @type {String}
       @default OverlayInteractionEnum.ON
       */

    }, {
      key: "interaction",
      get: function get() {
        return this._interaction || interaction$1.ON;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        this._interaction = validate.enumeration(interaction$1)(value) && value || interaction$1.ON;
      }
      /**
       Whether the overlay is allowed to change its DOM position for better positioning based on its context.
        @type {Boolean}
       @default false
       */

    }, {
      key: "smart",
      get: function get() {
        return this._smart || false;
      },
      set: function set(value) {
        this._smart = transform.booleanAttr(value);

        this._toggleSmartBehavior(this.open);
      }
      /**
       Inherited from {@link BaseOverlay#open}.
       */

    }, {
      key: "open",
      get: function get() {
        return _get(_getPrototypeOf(Overlay.prototype), "open", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(Overlay.prototype), "open", value, this, true);

        this._toggleSmartBehavior(this.open);
      }
    }], [{
      key: "_getTarget",
      value: function _getTarget(el, targetValue) {
        // Use passed target
        targetValue = targetValue || el.target;

        if (targetValue instanceof Node) {
          // Just return the provided Node
          return targetValue;
        } // Dynamically get the target node based on target


        var newTarget = null;

        if (typeof targetValue === 'string') {
          if (targetValue === target.PREVIOUS) {
            newTarget = el.previousElementSibling;
          } else if (targetValue === target.NEXT) {
            newTarget = el.nextElementSibling;
          } else {
            newTarget = document.querySelector(targetValue);
          }
        }

        return newTarget;
      }
      /**
       @deprecated
        Returns {@link Overlay} align options.
        @return {OverlayAlignEnum}
       */

    }, {
      key: "align",
      get: function get() {
        return align;
      }
      /**
       Returns {@link Overlay} collision options.
        @return {OverlayCollisionEnum}
       */

    }, {
      key: "collision",
      get: function get() {
        return collision;
      }
      /**
       Returns {@link Overlay} target options.
        @return {OverlayTargetEnum}
       */

    }, {
      key: "target",
      get: function get() {
        return target;
      }
      /**
       Returns {@link Overlay} placement options.
        @return {OverlayPlacementEnum}
       */

    }, {
      key: "placement",
      get: function get() {
        return placement;
      }
      /**
       Returns {@link Overlay} interaction options.
        @return {OverlayInteractionEnum}
       */

    }, {
      key: "interaction",
      get: function get() {
        return interaction$1;
      }
    }, {
      key: "_attributePropertyMap",
      get: function get() {
        return commons.extend(_get(_getPrototypeOf(Overlay), "_attributePropertyMap", this), {
          alignmy: 'alignMy',
          alignat: 'alignAt',
          lengthoffset: 'lengthOffset',
          breadthoffset: 'breadthOffset',
          withinoffset: 'withinOffset'
        });
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(Overlay), "observedAttributes", this).concat(['alignmy', 'alignat', 'offset', 'lengthoffset', 'breadthoffset', 'placement', 'within', 'withinoffset', 'collision', 'interaction', 'target', 'inner', 'smart']);
      }
    }]);

    return Overlay;
  }(BaseOverlay(BaseComponent(HTMLElement)));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons._define('coral-overlay', Overlay);

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var translations$5 = {
    "en-US": {
      "Close": "Close"
    },
    "de-DE": {
      "Close": "SchlieÃen"
    },
    "fr-FR": {
      "Close": "Fermer"
    },
    "it-IT": {
      "Close": "Chiudi"
    },
    "ja-JP": {
      "Close": "éãã"
    },
    "es-ES": {
      "Close": "Cerrar"
    },
    "ko-KR": {
      "Close": "ë«ê¸°"
    },
    "zh-CN": {
      "Close": "å³é­"
    },
    "zh-TW": {
      "Close": "éé"
    },
    "pt-BR": {
      "Close": "Fechar"
    },
    "nl-NL": {
      "Close": "Sluiten"
    },
    "da-DK": {
      "Close": "Luk"
    },
    "fi-FI": {
      "Close": "Sulje"
    },
    "nb-NO": {
      "Close": "Lukk"
    },
    "sv-SE": {
      "Close": "StÃ¤ng"
    },
    "cs-CZ": {
      "Close": "ZavÅÃ­t"
    },
    "pl-PL": {
      "Close": "Zamknij"
    },
    "ru-RU": {
      "Close": "ÐÐ°ÐºÑÑÑÑ"
    },
    "tr-TR": {
      "Close": "Kapat"
    }
  };

  var DROP_ZONE_ATTRIBUTE = 'coral-dragaction-dropzone';
  var HANDLE_ATTRIBUTE = 'coral-dragaction-handle';
  var AXIS_ATTRIBUTE = 'coral-dragaction-axis';
  var SCROLL_ATTRIBUTE = 'coral-dragaction-scroll';
  var CONTAINMENT_ATTRIBUTE = 'coral-dragaction-containment'; // Classes

  var OPEN_HAND_CLASS = 'u-coral-openHand';
  var CLOSE_HAND_CLASS = 'u-coral-closedHand';
  var IS_DRAGGING_CLASS = 'is-dragging'; // Scroll offset default values

  var DEFAULT_SCROLL_OFFSET = 20;
  var DEFAULT_SCROLL_BY = 10;
  /**
   Enumeration for {@link DragAction} axis restrictions.

   @typedef {Object} DragActionAxisEnum

   @property {String} FREE
   Allows vertically and horizontally dragging.
   @property {String} VERTICAL
   Allows vertically dragging only.
   @property {String} HORIZONTAL
   Allows horizontally dragging only.
   */

  var axis = {
    FREE: 'free',
    VERTICAL: 'vertical',
    HORIZONTAL: 'horizontal'
  };
  /**
   @ignore
   @param {HTMLElement} element
   @returns {HTMLElement}
   First parent element with overflow [hidden|scroll|auto]
   */

  function getViewContainer(element) {
    while (element) {
      var p = element.parentNode;

      if (!p) {
        return p;
      }

      if (p.matches('body')) {
        return p;
      }

      var computedStyle = window.getComputedStyle(p);
      var overflow = computedStyle.overflow; // IE11 can return a value for overflow even if it was not set compared to other browsers so we check for X and Y.

      var overflowX = computedStyle.overflowX;
      var overflowY = computedStyle.overflowY;

      if ((overflow === 'hidden' || overflow === 'auto' || overflow === 'scroll') && // @polyfill IE11
      overflow === overflowX && overflow === overflowY) {
        return p;
      }

      element = p;
    }
  }
  /**
   @ignore
   @param {String|HTMLElement|NodeList} el
   @returns {Array.<HTMLElement>}
   X and y position whether event was generated by a click or a touch
   */


  function transformToArray(el) {
    if (typeof el === 'string') {
      return Array.prototype.slice.call(document.querySelectorAll(el));
    } else if (el instanceof HTMLElement) {
      return [el];
    } else if (Object.prototype.toString.call(el) === '[object NodeList]') {
      return Array.prototype.slice.call(el);
    }
  }
  /**
   @ignore
   @param {Object} event
   @returns {Object}
   X and y position whether event was generated by a click or a touch
   */


  function getPagePosition(event) {
    var touch = {};

    if (event.changedTouches && event.changedTouches.length > 0) {
      touch = event.changedTouches[0];
    } else if (event.touches && event.touches.length > 0) {
      touch = event.touches[0];
    }

    return {
      x: touch.pageX || event.pageX,
      y: touch.pageY || event.pageY
    };
  }
  /**
   @ignore
   @param {HTMLElement} scrollingElement
   element that scrolls the document
   @param {HTMLElement} a
   @param {HTMLElement} b
   @returns {Boolean}
   Whether a is within b bounds
   */


  function within(scrollingElement, a, b) {
    var aBoundingClientRect = a.getBoundingClientRect();
    var bBoundingClientRect = b.getBoundingClientRect();
    var documentScrollTop = scrollingElement.scrollTop;
    var documentScrollLeft = scrollingElement.scrollLeft;
    var al = aBoundingClientRect.left + documentScrollLeft;
    var ar = al + aBoundingClientRect.width;
    var bl = bBoundingClientRect.left + documentScrollLeft;
    var br = bl + bBoundingClientRect.width;
    var at = aBoundingClientRect.top + documentScrollTop;
    var ab = at + aBoundingClientRect.height;
    var bt = bBoundingClientRect.top + documentScrollTop;
    var bb = bt + bBoundingClientRect.height;
    return !(bl > ar || br < al || bt > ab || bb < at);
  }
  /**
   @ignore
   @param {DragAction} dragAction
   Coral.DragAction instance
   @returns {HTMLElement}
   The dropzone that is being hovered by the dragged element or null if none
   */


  function isOverDropZone(dragAction) {
    var el = null;

    if (dragAction._dropZones && dragAction._dropZones.length) {
      dragAction._dropZones.some(function (dropZone) {
        if (within(dragAction._scrollingElement, dragAction._dragElement, dropZone)) {
          el = dropZone;
          return true;
        }

        return false;
      });
    }

    return el;
  }
  /**
   @class Coral.DragAction
   @classdesc This a decorator which adds draggable functionality to elements.
   To define draggable actions on specific elements, handles can be used.
   A handle is given a special attribute :
   - <code>coral-dragaction</code> attribute adds draggable functionality to the corresponding element.
   - <code>coral-dragaction-handle</code> attribute allows dragging only by dragging the specified handle.
   - <code>coral-dragaction-dropzone</code> attribute is used to indicate possible dropzones making it possible
   to build drag-and-drop enabled interfaces in conjunction with <code>DragAction</code> events.
   - <code>coral-dragaction-axis</code> and setting it to either <code>horizontal</code> or <code>vertical</code>,
   it is possible to restrict the drag'n'drop to a single axis.
   - <code>coral-dragaction-scroll</code> attribute will scroll the container when the draggable is moved beyond the viewport.
   - <code>coral-dragaction-containment</code>, the draggable element will be constrained to its container.
   @param {String|HTMLElement} dragElement
   The draggable element.
   */


  var DragAction = /*#__PURE__*/function () {
    /**
     Takes the {HTMLElement} to be dragged as argument.
      @param {HTMLElement} dragElement
     */
    function DragAction(dragElement) {
      _classCallCheck(this, DragAction);

      if (!dragElement) {
        throw new Error('Coral.DragAction: dragElement is missing');
      }

      var el = null;

      if (dragElement instanceof HTMLElement) {
        el = dragElement;
      } else if (typeof dragElement === 'string') {
        el = document.querySelector(dragElement);

        if (!el) {
          throw new Error('Coral.DragAction: dragElement is null');
        }
      }

      this._id = commons.getUID();
      this._dragElementValue = dragElement;
      this._dragElement = el; // Destroy instance if existing

      if (this._dragElement.dragAction) {
        this._dragElement.dragAction.destroy();
      }

      var computedStyle = window.getComputedStyle(this._dragElement); // Store initial position

      this._initialPosition = {
        position: computedStyle.position,
        left: computedStyle.left,
        top: computedStyle.top
      }; // Prepare Vent

      this._dragEvents = new vent(this._dragElement); // Handle options. Binds events to dragElement if no handles defined or found

      this.handle = this._dragElement.getAttribute(HANDLE_ATTRIBUTE); // DropZone options

      this.dropZone = this._dragElement.getAttribute(DROP_ZONE_ATTRIBUTE); // Axis horizontal|vertical

      this.axis = this._dragElement.getAttribute(AXIS_ATTRIBUTE); // Scroll options

      this.scroll = this._dragElement.matches("[".concat(SCROLL_ATTRIBUTE, "]")); // Restriction to container

      this.containment = this._dragElement.matches("[".concat(CONTAINMENT_ATTRIBUTE, "]"));
      this._drag = this._drag.bind(this);
      this._dragEnd = this._dragEnd.bind(this);
      events.on("touchmove.DragAction".concat(this._id), this._drag);
      events.on("mousemove.DragAction".concat(this._id), this._drag);
      events.on("touchend.DragAction".concat(this._id), this._dragEnd);
      events.on("mouseup.DragAction".concat(this._id), this._dragEnd); // Store reference on dragElement

      this._dragElement.dragAction = this;
    }
    /**
     The draggable element.
      @name dragElement
     @readonly
     @type {String|HTMLElement}
     @htmlattribute coral-dragaction
     */


    _createClass(DragAction, [{
      key: "_dragStart",

      /** @private */
      value: function _dragStart(event) {
        // Container
        this._container = getViewContainer(this._dragElement) || document.body; // Prevent dragging ghost image

        if (event.target.tagName === 'IMG') {
          event.preventDefault();
        } // Prevent touchscreen windows to scroll while dragging


        events.on('touchmove.DragAction', function (e) {
          e.preventDefault();
        });
        document.body._overflow = window.getComputedStyle(document.body).overflow;
        document.body.style.overflow = 'hidden';

        if (!this._container.matches('body')) {
          this._container._overflow = window.getComputedStyle(this._container).overflow;
          this._container.style.overflow = this.scroll ? 'scroll' : 'hidden';
        }

        var pagePosition = getPagePosition(event);

        var dragElementBoundingClientRect = this._dragElement.getBoundingClientRect();

        this._dragPosition = getPagePosition(event);
        this._dragPosition.y -= dragElementBoundingClientRect.top + this._scrollingElement.scrollTop;
        this._dragPosition.x -= dragElementBoundingClientRect.left + this._scrollingElement.scrollLeft; // Handle classes

        document.body.classList.add(CLOSE_HAND_CLASS);

        if (this._handles && this._handles.length) {
          this._handles.forEach(function (handle) {
            handle.classList.remove(OPEN_HAND_CLASS);
          });
        } else {
          this._dragElement.classList.remove(OPEN_HAND_CLASS);
        }

        this._dragElement.classList.add(IS_DRAGGING_CLASS); // Apply relative position by default


        if (window.getComputedStyle(this._dragElement).position === 'static') {
          this._dragElement.style.position = 'relative';
        }

        this._dragEvents.dispatch('coral-dragaction:dragstart', {
          detail: {
            dragElement: this._dragElement,
            pageX: pagePosition.x,
            pageY: pagePosition.y
          }
        });
      }
      /** @private */

    }, {
      key: "_drag",
      value: function _drag(event) {
        if (this._dragElement.classList.contains(IS_DRAGGING_CLASS)) {
          var pagePosition = getPagePosition(event);
          var documentScrollTop = this._scrollingElement.scrollTop;
          var documentScrollLeft = this._scrollingElement.scrollLeft;

          var dragElementBoundingClientRect = this._dragElement.getBoundingClientRect();

          var dragElementHeight = dragElementBoundingClientRect.height;
          var dragElementWidth = dragElementBoundingClientRect.width;
          var dragElementPosition = {
            top: dragElementBoundingClientRect.top + documentScrollTop,
            left: dragElementBoundingClientRect.left + documentScrollLeft
          };
          var dragElementComputedStyle = window.getComputedStyle(this._dragElement);
          var dragElementCSSPosition = {
            top: parseFloat(dragElementComputedStyle.top) || 0,
            left: parseFloat(dragElementComputedStyle.left) || 0
          };

          var containerBoundingClientRect = this._container.getBoundingClientRect();

          var containerWidth = containerBoundingClientRect.width;
          var containerHeight = containerBoundingClientRect.height;
          var containerPosition = {
            top: containerBoundingClientRect.top + documentScrollTop,
            left: containerBoundingClientRect.left + documentScrollLeft
          };

          this._dragEvents.dispatch('coral-dragaction:drag', {
            detail: {
              dragElement: this._dragElement,
              pageX: pagePosition.x,
              pageY: pagePosition.y
            }
          }); // Remove selection


          if (document.selection) {
            document.selection.empty();
          } else if (window.getSelection) {
            // @polyfill ie
            if (window.getSelection().removeAllRanges) {
              window.getSelection().removeAllRanges();
            }
          } // Need to scroll ?


          if (this.scroll) {
            // Scroll element is the document
            if (this._container === document.body) {
              // Scroll to the top
              if (dragElementBoundingClientRect.top < DEFAULT_SCROLL_OFFSET) {
                this._scrollingElement.scrollTop = documentScrollTop - DEFAULT_SCROLL_BY;
              } // Scroll to the bottom but don't go further than the maximum scroll position of the document
              else if (dragElementBoundingClientRect.top + dragElementBoundingClientRect.height > window.innerHeight - DEFAULT_SCROLL_OFFSET && dragElementPosition.top + dragElementBoundingClientRect.height + DEFAULT_SCROLL_OFFSET < this._scrollingElement.scrollHeight) {
                  this._scrollingElement.scrollTop = documentScrollTop + DEFAULT_SCROLL_BY;
                } // Scroll to the left


              if (dragElementBoundingClientRect.left < DEFAULT_SCROLL_OFFSET) {
                this._scrollingElement.scrollLeft = documentScrollLeft - DEFAULT_SCROLL_BY;
              } // Scroll to the right but don't go further than the maximum scroll position of the document
              else if (dragElementBoundingClientRect.left + dragElementBoundingClientRect.width > window.innerWidth - DEFAULT_SCROLL_OFFSET && dragElementPosition.left + dragElementBoundingClientRect.width + DEFAULT_SCROLL_OFFSET < this._scrollingElement.scrollWidth) {
                  this._scrollingElement.scrollLeft = documentScrollLeft + DEFAULT_SCROLL_BY;
                }
            } // Scroll element is an element other than the document
            else {
                // Scroll to the top
                if (dragElementBoundingClientRect.top - containerBoundingClientRect.top < DEFAULT_SCROLL_OFFSET) {
                  this._container.scrollTop = this._container.scrollTop - DEFAULT_SCROLL_BY;
                } // Scroll to the bottom but don't go further than the maximum scroll position of the container
                else if (dragElementBoundingClientRect.top - containerBoundingClientRect.top + dragElementBoundingClientRect.height > containerBoundingClientRect.height - DEFAULT_SCROLL_OFFSET && dragElementBoundingClientRect.top - containerBoundingClientRect.top + dragElementBoundingClientRect.height < containerBoundingClientRect.height) {
                    this._container.scrollTop = this._container.scrollTop + DEFAULT_SCROLL_BY;
                  } // Scroll to the left


                if (dragElementBoundingClientRect.left - containerBoundingClientRect.left < DEFAULT_SCROLL_OFFSET) {
                  this._container.scrollLeft = this._container.scrollLeft - DEFAULT_SCROLL_BY;
                } // Scroll to the bottom but don't go further than the maximum scroll position of the container
                else if (dragElementBoundingClientRect.left - containerBoundingClientRect.left + dragElementBoundingClientRect.width > containerBoundingClientRect.width - DEFAULT_SCROLL_OFFSET && dragElementBoundingClientRect.left - containerBoundingClientRect.left + dragElementBoundingClientRect.width < containerBoundingClientRect.width) {
                    this._container.scrollLeft = this._container.scrollLeft + DEFAULT_SCROLL_BY;
                  }
              }
          } // Set drag element's new position


          var newPosition = {};

          if (this.axis !== 'horizontal') {
            var top = pagePosition.y - this._dragPosition.y; // Applying container containment for y movements

            if (this.containment) {
              if (top >= containerPosition.top && top + dragElementHeight <= containerPosition.top + containerHeight) {
                newPosition.top = top;
              } // put the drag element to the container's top
              else if (pagePosition.y <= containerPosition.top) {
                  newPosition.top = containerPosition.top;
                } // put the drag element to the container's bottom
                else if (pagePosition.y >= containerPosition.top + containerHeight) {
                    newPosition.top = containerPosition.top + containerHeight - dragElementHeight;
                  }
            } else {
              newPosition.top = top;
            }
          }

          if (this.axis !== 'vertical') {
            var left = pagePosition.x - this._dragPosition.x; // Applying container containment for x movements

            if (this.containment) {
              if (left >= containerPosition.left && left + dragElementWidth <= containerPosition.left + containerWidth) {
                newPosition.left = left;
              } // put the drag element to the container's left
              else if (pagePosition.x <= containerPosition.left) {
                  newPosition.left = containerPosition.left;
                } // put the drag element to the container's right
                else if (pagePosition.x >= containerPosition.left + containerWidth) {
                    newPosition.left = containerPosition.left + containerWidth - dragElementWidth;
                  }
            } else {
              newPosition.left = left;
            }
          } // Set the new position


          this._dragElement.style.top = "".concat(newPosition.top - dragElementPosition.top + dragElementCSSPosition.top, "px");
          this._dragElement.style.left = "".concat(newPosition.left - dragElementPosition.left + dragElementCSSPosition.left, "px"); // Trigger dropzone related events

          var dropZone = isOverDropZone(this);

          if (dropZone) {
            this._dropElement = dropZone;

            if (!this._dropZoneEntered) {
              this._dropZoneEntered = true;

              this._dragEvents.dispatch('coral-dragaction:dragenter', {
                detail: {
                  dragElement: this._dragElement,
                  pageX: pagePosition.x,
                  pageY: pagePosition.y,
                  dropElement: this._dropElement
                }
              });
            }

            this._dragEvents.dispatch('coral-dragaction:dragover', {
              detail: {
                dragElement: this._dragElement,
                pageX: pagePosition.x,
                pageY: pagePosition.y,
                dropElement: this._dropElement
              }
            });
          } else if (this._dropZoneEntered) {
            this._dragEvents.dispatch('coral-dragaction:dragleave', {
              detail: {
                dragElement: this._dragElement,
                pageX: pagePosition.x,
                pageY: pagePosition.y,
                dropElement: this._dropElement
              }
            });

            this._dropZoneEntered = false;
          }
        }
      }
      /** @private */

    }, {
      key: "_dragEnd",
      value: function _dragEnd(event) {
        if (this._dragElement.classList.contains(IS_DRAGGING_CLASS)) {
          var pagePosition = getPagePosition(event); // Restore overflow

          document.body.style.overflow = document.body._overflow;
          document.body._overflow = undefined;

          if (!this._container.matches('body')) {
            this._container.style.overflow = this._container._overflow;
            this._container._overflow = undefined;
          }

          document.body.classList.remove(CLOSE_HAND_CLASS);

          this._dragElement.classList.remove(IS_DRAGGING_CLASS);

          if (this._handles && this._handles.length) {
            this._handles.forEach(function (handle) {
              handle.classList.add(OPEN_HAND_CLASS);
            });
          } else {
            this._dragElement.classList.add(OPEN_HAND_CLASS);
          }

          if (this._dropZoneEntered) {
            var dropZone = isOverDropZone(this);

            if (dropZone) {
              this._dropElement = dropZone;

              this._dragEvents.dispatch('coral-dragaction:drop', {
                detail: {
                  dragElement: this._dragElement,
                  pageX: pagePosition.x,
                  pageY: pagePosition.y,
                  dropElement: this._dropElement
                }
              });
            }
          }

          this._dragEvents.dispatch('coral-dragaction:dragend', {
            detail: {
              dragElement: this._dragElement,
              pageX: pagePosition.x,
              pageY: pagePosition.y
            }
          });
        }
      }
      /**
       Remove draggable actions
        @function destroy
       @param {Boolean} restorePosition
       Whether to restore the draggable element to its initial position
       */

    }, {
      key: "destroy",
      value: function destroy(restorePosition) {
        // Unbind events and remove classes
        document.body.classList.remove(CLOSE_HAND_CLASS);

        this._dragElement.classList.remove(IS_DRAGGING_CLASS);

        if (this._handles && this._handles.length) {
          this._handles.forEach(function (handle) {
            handle._dragEvents.off('.DragAction');

            handle.classList.remove(OPEN_HAND_CLASS);
          });
        } else {
          this._dragEvents.off('.DragAction');

          this._dragElement.classList.remove(OPEN_HAND_CLASS);
        }

        events.off(".DragAction".concat(this._id)); // Restore overflow

        if (document.body._overflow) {
          document.body.style.overflow = document.body._overflow;
          document.body._overflow = undefined;
        } // Container might not have been initialized


        if (this._container) {
          if (!this._container.matches('body') && this._container._overflow) {
            this._container.style.overflow = this._container._overflow;
            this._container._overflow = undefined;
          }
        } // Set to initial position


        if (restorePosition) {
          this._dragElement.style.position = this._initialPosition.position;
          this._dragElement.style.top = this._initialPosition.top;
          this._dragElement.style.left = this._initialPosition.left;
        } // Remove reference


        this._dragElement.dragAction = undefined;
      }
      /**
       Returns {@link DragAction} axis restrictions.
        @return {DragActionAxisEnum}
       */

    }, {
      key: "dragElement",
      get: function get() {
        return this._dragElementValue;
      }
      /**
       The handle allowing to drag the element.
        @name handle
       @type {String|HTMLElement}
       @htmlattribute coral-dragaction-handle
       */

    }, {
      key: "handle",
      get: function get() {
        return this._handle;
      },
      set: function set(value) {
        var _this = this;

        // Set new value
        this._handle = value; // Unbind events

        this._dragEvents.off('.DragAction'); // Remove classes


        document.body.classList.remove(CLOSE_HAND_CLASS);

        this._dragElement.classList.remove(IS_DRAGGING_CLASS);

        if (this._handles && this._handles.length) {
          this._handles.forEach(function (handle) {
            handle._dragEvents.off('.DragAction');

            handle.classList.remove(OPEN_HAND_CLASS);
          });
        } else {
          this._dragElement.classList.remove(OPEN_HAND_CLASS);
        }

        if (typeof value === 'string' || value instanceof HTMLElement || Object.prototype.toString.call(value) === '[object NodeList]') {
          this._handles = transformToArray(value); // Bind events

          if (this._handles && this._handles.length) {
            this._handles.forEach(function (handle) {
              handle._dragEvents = handle._dragEvents || new vent(handle);

              handle._dragEvents.on('mousedown.DragAction', _this._dragStart.bind(_this));

              handle._dragEvents.on('touchstart.DragAction', _this._dragStart.bind(_this));

              handle.classList.add(OPEN_HAND_CLASS);
            });
          } else {
            this._dragEvents.on('touchstart.DragAction', this._dragStart.bind(this));

            this._dragEvents.on('mousedown.DragAction', this._dragStart.bind(this));

            this._dragElement.classList.add(OPEN_HAND_CLASS);
          }
        } else {
          // Defaults to the dragElement
          this._handles = [];

          this._dragEvents.on('touchstart.DragAction', this._dragStart.bind(this));

          this._dragEvents.on('mousedown.DragAction', this._dragStart.bind(this));

          this._dragElement.classList.add(OPEN_HAND_CLASS);
        }
      }
      /**
       The dropZone to drop the dragged element.
        @name dropZone
       @type {String|HTMLElement}
       @htmlattribute coral-dragaction-dropzone
       */

    }, {
      key: "dropZone",
      get: function get() {
        return this._dropZone;
      },
      set: function set(value) {
        // Set new value
        this._dropZone = value;
        this._dropZoneEntered = false;

        if (typeof value === 'string' || value instanceof HTMLElement || Object.prototype.toString.call(value) === '[object NodeList]') {
          this._dropZones = transformToArray(value);
        } else {
          this._dropZones = [];
        }
      }
      /**
       The axis to constrain drag movement. See {@link DragActionAxisEnum}.
        @name axis
       @type {String}
       @default DragActionAxisEnum.FREE
       @htmlattribute coral-dragaction-axis
       */

    }, {
      key: "axis",
      get: function get() {
        return this._axis;
      },
      set: function set(value) {
        value = transform.string(value);
        this._axis = validate.enumeration(axis)(value) && value || axis.FREE;
      }
      /**
       Whether to scroll the container when the draggable element is moved beyond the viewport.
        @name scroll
       @default false
       @type {Boolean}
       @htmlattribute coral-dragaction-scroll
       */

    }, {
      key: "scroll",
      get: function get() {
        return this._scroll;
      },
      set: function set(value) {
        this._scroll = transform.boolean(value);
      }
      /**
       Whether to constrain the draggable element to its container viewport.
        @name containment
       @default false
       @type {Boolean}
       @htmlattribute coral-dragaction-containment
       */

    }, {
      key: "containment",
      get: function get() {
        return this._containment;
      },
      set: function set(value) {
        this._containment = transform.boolean(value);
      }
    }, {
      key: "_scrollingElement",

      /** @private */
      get: function get() {
        // @polyfill ie11
        // Element that scrolls the document.
        return document.scrollingElement || document.documentElement;
      }
      /**
       Triggered when the {@link DragAction#dragElement} starts to be dragged.
        @typedef {CustomEvent} coral-dragaction:dragstart
        @property {HTMLElement} dragElement
       The dragged element
       @property {Number} pageX
       The mouse position relative to the left edge of the document.
       @property {Number} pageY
       The mouse position relative to the top edge of the document.
       */

      /**
       Triggered when the {@link DragAction#dragElement} is being dragged.
        @typedef {CustomEvent} coral-dragaction:drag
        @property {HTMLElement} dragElement
       The dragged element
       @property {Number} pageX
       The mouse position relative to the left edge of the document.
       @property {Number} pageY
       The mouse position relative to the top edge of the document.
       */

      /**
       Triggered when the {@link DragAction#dragElement} stops to be dragged.
        @typedef {CustomEvent} coral-dragaction:dragend
        @property {HTMLElement} dragElement
       The dragged element
       @property {Number} pageX
       The mouse position relative to the left edge of the document.
       @property {Number} pageY
       The mouse position relative to the top edge of the document.
       */

      /**
       Triggered when the {@link DragAction#dragElement} enters a drop element.
        @typedef {CustomEvent} coral-dragaction:dragenter
        @property {HTMLElement} dragElement
       The dragged element
       @property {HTMLElement} dropElement
       The drop element
       @property {Number} pageX
       The mouse position relative to the left edge of the document.
       @property {Number} pageY
       The mouse position relative to the top edge of the document.
       */

      /**
       Triggered when the {@link DragAction#dragElement} is over a drop element.
        @typedef {CustomEvent} coral-dragaction:dragover
        @property {HTMLElement} dragElement
       The dragged element
       @property {HTMLElement} dropElement
       The drop element
       @property {Number} pageX
       The mouse position relative to the left edge of the document.
       @property {Number} pageY
       The mouse position relative to the top edge of the document.
       */

      /**
       Triggered when the {@link DragAction#dragElement} leaves a drop element.
        @typedef {CustomEvent} coral-dragaction:dragleave
        @property {HTMLElement} dragElement
       The dragged element
       @property {HTMLElement} dropElement
       The drop element
       @property {Number} pageX
       The mouse position relative to the left edge of the document.
       @property {Number} pageY
       The mouse position relative to the top edge of the document.
       */

      /**
       Triggered when the {@link DragAction#dragElement} is dropped on a drop element.
        @typedef {CustomEvent} coral-dragaction:drop
        @property {HTMLElement} dragElement
       The dragged element
       @property {HTMLElement} dropElement
       The drop element
       @property {Number} pageX
       The mouse position relative to the left edge of the document.
       @property {Number} pageY
       The mouse position relative to the top edge of the document.
       */

    }], [{
      key: "axis",
      get: function get() {
        return axis;
      }
    }]);

    return DragAction;
  }();

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  document.addEventListener('DOMContentLoaded', function () {
    var elements = document.body.querySelectorAll('[coral-dragaction]');

    for (var i = 0; i < elements.length; i++) {
      new DragAction(elements[i]);
    }
  });

  var template$5 = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["headerWrapper"] = document.createElement("div");
    el0.className += " _coral-Dialog-header";
    el0.setAttribute("handle", "headerWrapper");
    var el1 = document.createTextNode("\n  ");
    el0.appendChild(el1);
    var el2 = this["dragZone"] = document.createElement("div");
    el2.className += " _coral-Dialog-dragZone";
    el2.setAttribute("handle", "dragZone");
    el0.appendChild(el2);
    var el3 = document.createTextNode("\n");
    el0.appendChild(el3);
    frag.appendChild(el0);
    var el4 = document.createTextNode("\n");
    frag.appendChild(el4);
    var el5 = this["wrapper"] = document.createElement("div");
    el5.setAttribute("handle", "wrapper");
    var el6 = document.createTextNode("\n  ");
    el5.appendChild(el6);
    var el7 = this["closeButton"] = document.createElement("button", "coral-button");
    el7.setAttribute("tracking", "off");
    el7.setAttribute("handle", "closeButton");
    el7.className += " _coral-Dialog-closeButton";
    el7.setAttribute("type", "button");
    el7.setAttribute("is", "coral-button");
    el7.setAttribute("variant", "quietaction");
    el7.setAttribute("title", data_0["i18n"]["get"]('Close'));
    el7.setAttribute("tabindex", "-1");
    el7.setAttribute("coral-close", "");
    el7.setAttribute("coral-tabcapture", "");
    var el8 = document.createTextNode("\n    ");
    el7.appendChild(el8);
    var el9 = document.createElement("coral-icon");
    el9.setAttribute("icon", "spectrum-css-icon-CrossLarge");
    el9.className += " _coral-UIIcon-CrossLarge";
    el7.appendChild(el9);
    var el10 = document.createTextNode("\n  ");
    el7.appendChild(el10);
    el5.appendChild(el7);
    var el11 = document.createTextNode("\n");
    el5.appendChild(el11);
    frag.appendChild(el5);
    var el12 = document.createTextNode("\n");
    frag.appendChild(el12);
    return frag;
  };

  /**
   Enumeration for {@link Dialog} closable options.

   @typedef {Object} DialogClosableEnum

   @property {String} ON
   Show a close button on the dialog and close the dialog when clicked.
   @property {String} OFF
   Do not show a close button. Elements with the <code>coral-close</code> attribute will still close the dialog.
   */

  var closable = {
    ON: 'on',
    OFF: 'off'
  };
  /**
   Enumeration for {@link Dialog} keyboard interaction options.

   @typedef {Object} DialogInteractionEnum

   @property {String} ON
   Keyboard interaction is enabled.
   @property {String} OFF
   Keyboard interaction is disabled.
   */

  var interaction$2 = {
    ON: 'on',
    OFF: 'off'
  };
  /**
   Enumeration for {@link Dialog} variants.

   @typedef {Object} DialogVariantEnum

   @property {String} DEFAULT
   A default dialog without header icon.
   @property {String} ERROR
   A dialog with an error header and icon, indicating that an error has occurred.
   @property {String} WARNING
   A dialog with a warning header and icon, notifying the user of something important.
   @property {String} SUCCESS
   A dialog with a success header and icon, indicates to the user that an operation was successful.
   @property {String} HELP
   A dialog with a question header and icon, provides the user with help.
   @property {String} INFO
   A dialog with an info header and icon, informs the user of non-critical information.
   */

  var variant$4 = {
    DEFAULT: 'default',
    ERROR: 'error',
    WARNING: 'warning',
    SUCCESS: 'success',
    HELP: 'help',
    INFO: 'info'
  };
  /**
   Enumeration for {@link Dialog} backdrops.

   @typedef {Object} DialogBackdropEnum

   @property {String} NONE
   No backdrop.
   @property {String} MODAL
   A backdrop that hides the dialog when clicked.
   @property {String} STATIC
   A backdrop that does not hide the dialog when clicked.
   */

  var backdrop = {
    NONE: 'none',
    MODAL: 'modal',
    STATIC: 'static'
  }; // Used to map icon with variant

  var capitalize$1 = function capitalize(s) {
    return s.charAt(0).toUpperCase() + s.slice(1);
  }; // The dialog's base classname


  var CLASSNAME$j = '_coral-Dialog'; // Modifier classnames

  var FULLSCREEN_CLASSNAME = "".concat(CLASSNAME$j, "--fullscreenTakeover"); // A string of all possible variant classnames

  var ALL_VARIANT_CLASSES$3 = [];

  for (var variantValue$2 in variant$4) {
    ALL_VARIANT_CLASSES$3.push("".concat(CLASSNAME$j, "--").concat(variant$4[variantValue$2]));
  }
  /**
   @class Coral.Dialog
   @classdesc A Dialog component that supports various use cases with custom content. The Dialog can be given a size by
   using the special attribute <code>[coral-dialog-size]</code> as selector.
   @htmltag coral-dialog
   @extends {HTMLElement}
   @extends {BaseComponent}
   @extends {BaseOverlay}
   */


  var Dialog = /*#__PURE__*/function (_BaseOverlay) {
    _inherits(Dialog, _BaseOverlay);

    var _super = _createSuper(Dialog);

    /** @ignore */
    function Dialog() {
      var _this;

      _classCallCheck(this, Dialog);

      _this = _super.call(this); // Prepare templates

      _this._elements = commons.extend(_this._elements, {
        // Fetch or create the content zone elements
        header: _this.querySelector('coral-dialog-header') || document.createElement('coral-dialog-header'),
        content: _this.querySelector('coral-dialog-content') || document.createElement('coral-dialog-content'),
        footer: _this.querySelector('coral-dialog-footer') || document.createElement('coral-dialog-footer')
      });
      template$5.call(_this._elements, {
        i18n: i18n
      }); // Events

      _this._delegateEvents({
        'coral-overlay:open': '_handleOpen',
        'click [coral-close]': '_handleCloseClick',
        // Since we cover the backdrop with ourself for positioning purposes, this is implemented as a click listener
        // instead of using backdropClickedCallback
        'click': '_handleClick',
        // Handle resize events
        'global:resize': 'center',
        'global:key:escape': '_handleEscape'
      }); // Override defaults from Overlay


      _this._trapFocus = _this.constructor.trapFocus.ON;
      _this._returnFocus = _this.constructor.returnFocus.ON;
      _this._overlayAnimationTime = _this.constructor.FADETIME; // Listen for mutations

      _this._headerObserver = new MutationObserver(_this._hideHeaderIfEmpty.bind(_assertThisInitialized(_this))); // Watch for changes to the header element's children

      _this._observeHeader();

      return _this;
    }
    /**
     Whether keyboard interaction is enabled. See {@link DialogInteractionEnum}.
      @type {DialogInteractionEnum}
     @default DialogInteractionEnum.ON
     */


    _createClass(Dialog, [{
      key: "_observeHeader",

      /** @ignore */
      value: function _observeHeader() {
        if (this._headerObserver) {
          this._headerObserver.disconnect();

          if (this._elements.header) {
            this._headerObserver.observe(this._elements.header, {
              // Catch changes to childList
              childList: true,
              // Catch changes to textContent
              characterData: true,
              // Monitor any child node
              subtree: true
            });
          }
        }
      }
      /**
       Hide the header wrapper if the header content zone is empty.
       @ignore
       */

    }, {
      key: "_hideHeaderIfEmpty",
      value: function _hideHeaderIfEmpty() {
        var header = this._elements.header;

        if (header) {
          var headerWrapper = this._elements.headerWrapper; // If it's empty and has no non-textnode children, hide the header

          var hiddenValue = header.children.length === 0 && header.textContent.replace(/\s*/g, '') === ''; // Only bother if the hidden status has changed

          if (hiddenValue !== headerWrapper.hidden) {
            headerWrapper.hidden = hiddenValue;
          }

          this.variant = this.variant;
        }
      }
    }, {
      key: "_handleOpen",
      value: function _handleOpen(event) {
        this._trackEvent('display', 'coral-dialog', event);
      }
      /** @ignore */

    }, {
      key: "_handleEscape",
      value: function _handleEscape(event) {
        // When escape is pressed, hide ourselves
        if (this.interaction === interaction$2.ON && this.open && this._isTopOverlay()) {
          event.stopPropagation();
          this.open = false;
        }
      }
      /**
       @ignore
       @todo maybe this should be base or something
       */

    }, {
      key: "_handleCloseClick",
      value: function _handleCloseClick(event) {
        var dismissTarget = event.matchedTarget;
        var dismissValue = dismissTarget.getAttribute('coral-close');

        if (!dismissValue || this.matches(dismissValue)) {
          this.open = false;
          event.stopPropagation();

          this._trackEvent('close', 'coral-dialog', event);
        }
      }
    }, {
      key: "_handleClick",
      value: function _handleClick(event) {
        // When we're modal, we close when our outer area (over the backdrop) is clicked
        if (event.target === this && this.backdrop === backdrop.MODAL && this._isTopOverlay()) {
          this.open = false;

          this._trackEvent('close', 'coral-dialog', event);
        }
      }
      /** @ignore */

    }, {
      key: "_moveToDocumentBody",
      value: function _moveToDocumentBody() {
        // Not in the DOM
        if (!document.body.contains(this)) {
          document.body.appendChild(this);
        } // In the DOM but not a direct child of body
        else if (this.parentNode !== document.body) {
            this._ignoreConnectedCallback = true;
            this._repositioned = true;
            document.body.appendChild(this);
            this._ignoreConnectedCallback = false;
          }
      }
    }, {
      key: "_insertTypeIcon",
      value: function _insertTypeIcon() {
        if (this._elements.icon) {
          this._elements.icon.remove();
        }

        var variantValue = this.variant; // Warning icon is same as ERROR icon

        if (variantValue === variant$4.WARNING || variantValue === variant$4.ERROR) {
          variantValue = 'alert';
        } // Inject the SVG icon


        if (variantValue !== variant$4.DEFAULT) {
          var iconName = capitalize$1(variantValue);

          this._elements.headerWrapper.insertAdjacentHTML('beforeend', Icon._renderSVG("spectrum-css-icon-".concat(iconName, "Medium"), ['_coral-Dialog-typeIcon', "_coral-UIIcon-".concat(iconName, "Medium")]));

          this._elements.icon = this._elements.headerWrapper.querySelector('._coral-Dialog-typeIcon');
        }
      }
      /** @ignore */

    }, {
      key: "backdropClickedCallback",
      value: function backdropClickedCallback() {
        // When we're modal, we close when the backdrop is clicked
        if (this.backdrop === backdrop.MODAL && this._isTopOverlay()) {
          this.open = false;
        }
      }
      /**
       Centers the dialog in the middle of the screen.
        @returns {Dialog} this, chainable.
       */

    }, {
      key: "center",
      value: function center() {
        // We're already centered in fullscreen mode
        if (this.fullscreen) {
          return;
        } // If moved we reset the position


        this.style.top = '';
        this.style.left = '';
        return this;
      }
    }, {
      key: "connectedCallback",

      /** @ignore */
      value: function connectedCallback() {
        if (this._ignoreConnectedCallback) {
          return;
        }

        _get(_getPrototypeOf(Dialog.prototype), "connectedCallback", this).call(this);
      }
      /** @ignore */

    }, {
      key: "render",
      value: function render() {
        var _this2 = this;

        _get(_getPrototypeOf(Dialog.prototype), "render", this).call(this);

        this.classList.add("".concat(CLASSNAME$j, "-wrapper")); // Default reflected attributes

        if (!this._variant) {
          this.variant = variant$4.DEFAULT;
        }

        if (!this._backdrop) {
          this.backdrop = backdrop.MODAL;
        }

        if (!this._closable) {
          this.closable = closable.OFF;
        }

        if (!this._interaction) {
          this.interaction = interaction$2.ON;
        } // Fetch the content zones


        var header = this._elements.header;
        var content = this._elements.content;
        var footer = this._elements.footer; // Verify if a content zone is provided

        var contentZoneProvided = this.contains(content) && content || this.contains(footer) && footer || this.contains(header) && header; // Verify if the internal wrapper exists

        var wrapper = this.querySelector(".".concat(CLASSNAME$j)); // Case where the dialog was rendered already - cloneNode support

        if (wrapper) {
          // Remove tab captures
          Array.prototype.filter.call(this.children, function (child) {
            return child.hasAttribute('coral-tabcapture');
          }).forEach(function (tabCapture) {
            _this2.removeChild(tabCapture);
          }); // Assign internal elements

          this._elements.headerWrapper = this.querySelector('._coral-Dialog-header');
          this._elements.closeButton = this.querySelector('._coral-Dialog-closeButton');
          this._elements.wrapper = wrapper;
        } // Case where the dialog needs to be rendered
        else {
            // Create default wrapper
            wrapper = this._elements.wrapper; // Create default header wrapper

            var headerWrapper = this._elements.headerWrapper; // Case where the dialog needs to be rendered and content zones are provided

            if (contentZoneProvided) {
              // Check if user wrapper is provided
              if (contentZoneProvided.parentNode === this) {
                // Content zone target defaults to default wrapper if no user wrapper element is provided
                this._elements.wrapper = wrapper;
              } else {
                // Content zone target defaults to user wrapper element if provided
                this._elements.wrapper = contentZoneProvided.parentNode;
              } // Move everything in the wrapper


              while (this.firstChild) {
                wrapper.appendChild(this.firstChild);
              } // Add the dialog header before the content


              this._elements.wrapper.insertBefore(headerWrapper, content);
            } // Case where the dialog needs to be rendered and content zones need to be created
            else {
                // Default content zone target is wrapper
                this._elements.wrapper = wrapper; // Move everything in the "content" content zone

                while (this.firstChild) {
                  content.appendChild(this.firstChild);
                } // Add the content zones in the wrapper


                wrapper.appendChild(headerWrapper);
                wrapper.appendChild(content);
                wrapper.appendChild(footer);
              } // Add the wrapper to the dialog


            this.appendChild(wrapper);
          } // Only the wrapper gets the dialog class


        this._elements.wrapper.classList.add(CLASSNAME$j); // Mark the dialog with a public attribute for sizing


        this._elements.wrapper.setAttribute('coral-dialog-size', ''); // Close button should stay under the dialog


        this._elements.wrapper.appendChild(this._elements.closeButton); // Copy styles over to new wrapper


        if (this._elements.wrapper.parentNode !== this) {
          var contentWrapper = this.querySelector('[handle="wrapper"]');
          Array.prototype.forEach.call(contentWrapper.classList, function (style) {
            return _this2._elements.wrapper.classList.add(style);
          });
          contentWrapper.removeAttribute('class');
        } // Assign content zones


        this.header = header;
        this.footer = footer;
        this.content = content;
      }
      /** @ignore */

    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        if (this._ignoreConnectedCallback) {
          return;
        }

        _get(_getPrototypeOf(Dialog.prototype), "disconnectedCallback", this).call(this);
      }
    }, {
      key: "interaction",
      get: function get() {
        return this._interaction || interaction$2.ON;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        this._interaction = validate.enumeration(interaction$2)(value) && value || interaction$2.ON;
      }
      /**
       The dialog header element.
        @type {DialogHeader}
       @contentzone
       */

    }, {
      key: "header",
      get: function get() {
        return this._getContentZone(this._elements.header);
      },
      set: function set(value) {
        this._setContentZone('header', value, {
          handle: 'header',
          tagName: 'coral-dialog-header',
          insert: function insert(header) {
            header.classList.add("".concat(CLASSNAME$j, "-title")); // Position the header between the drag zone and the type icon

            this._elements.headerWrapper.insertBefore(header, this._elements.dragZone.nextElementSibling);
          },
          set: function set() {
            // Stop observing the old header and observe the new one
            this._observeHeader(); // Check if header needs to be hidden


            this._hideHeaderIfEmpty();
          }
        });
      }
      /**
       The dialog content element.
        @type {DialogContent}
       @contentzone
       */

    }, {
      key: "content",
      get: function get() {
        return this._getContentZone(this._elements.content);
      },
      set: function set(value) {
        this._setContentZone('content', value, {
          handle: 'content',
          tagName: 'coral-dialog-content',
          insert: function insert(content) {
            content.classList.add("".concat(CLASSNAME$j, "-content"));
            var footer = this.footer; // The content should always be before footer

            this._elements.wrapper.insertBefore(content, this.contains(footer) && footer || null);
          }
        });
      }
      /**
       The dialog footer element.
        @type {DialogFooter}
       @contentzone
       */

    }, {
      key: "footer",
      get: function get() {
        return this._getContentZone(this._elements.footer);
      },
      set: function set(value) {
        this._setContentZone('footer', value, {
          handle: 'footer',
          tagName: 'coral-dialog-footer',
          insert: function insert(footer) {
            footer.classList.add("".concat(CLASSNAME$j, "-footer")); // The footer should always be after content

            this._elements.wrapper.appendChild(footer);
          }
        });
      }
      /**
       The backdrop configuration for this dialog. See {@link DialogBackdropEnum}.
        @type {String}
       @default DialogBackdropEnum.MODAL
       @htmlattribute backdrop
       */

    }, {
      key: "backdrop",
      get: function get() {
        return this._backdrop || backdrop.MODAL;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        this._backdrop = validate.enumeration(backdrop)(value) && value || backdrop.MODAL;
        var showBackdrop = this._backdrop !== backdrop.NONE;

        this._elements.wrapper.classList.toggle("".concat(CLASSNAME$j, "--noBackdrop"), !showBackdrop); // We're visible now, so hide or show the modal accordingly


        if (this.open && showBackdrop) {
          this._showBackdrop();
        }
      }
      /**
       The dialog's variant. See {@link DialogVariantEnum}.
        @type {String}
       @default DialogVariantEnum.DEFAULT
       @htmlattribute variant
       @htmlattributereflected
       */

    }, {
      key: "variant",
      get: function get() {
        return this._variant || variant$4.DEFAULT;
      },
      set: function set(value) {
        var _this$_elements$wrapp;

        value = transform.string(value).toLowerCase();
        this._variant = validate.enumeration(variant$4)(value) && value || variant$4.DEFAULT;

        this._reflectAttribute('variant', this._variant); // Insert SVG icon


        this._insertTypeIcon(); // Remove all variant classes


        (_this$_elements$wrapp = this._elements.wrapper.classList).remove.apply(_this$_elements$wrapp, ALL_VARIANT_CLASSES$3);

        if (this._variant === variant$4.DEFAULT) {
          // ARIA
          this.setAttribute('role', 'dialog');
        } else {
          // Set new variant class
          this._elements.wrapper.classList.add("".concat(CLASSNAME$j, "--").concat(this._variant)); // ARIA


          this.setAttribute('role', 'alertdialog');
        }

        var hasHeader = this.header && this.header.textContent !== ''; // If the dialog has a header and is not otherwise labelled,

        if (hasHeader && !(this.hasAttribute('aria-labelledby') || this.hasAttribute('aria-label'))) {
          this.header.id = this.header.id || commons.getUID(); // label the dialog with a reference to the header

          this.setAttribute('aria-labelledby', this.header.id);
        } // If the dialog has no content, or the content is empty, do nothing further.


        if (!this.content || this.content.textContent === '') {
          return;
        } // If the dialog has a content,


        this.content.id = this.content.id || commons.getUID(); // In an alertdialog with a content region, if the alertdialog is not otherwise described.

        if (this._variant !== variant$4.DEFAULT) {
          // with no header,
          if (!hasHeader) {
            // label the alertdialog with a reference to the content
            this.setAttribute('aria-labelledby', this.content.id);
          } // otherwise, if the alertdialog is not otherwise described,
          else if (!this.hasAttribute('aria-describedby')) {
              // ensure that the alertdialog is described by the content.
              this.setAttribute('aria-describedby', this.content.id);
            }
        } else if (this.getAttribute('aria-labelledby') === this.content.id) {
          this.removeAttribute('aria-labelledby');
        }
      }
      /**
       Whether the dialog should be displayed full screen (without borders or margin).
        @type {Boolean}
       @default false
       @htmlattribute fullscreen
       @htmlattributereflected
       */

    }, {
      key: "fullscreen",
      get: function get() {
        return this._fullscreen || false;
      },
      set: function set(value) {
        this._fullscreen = transform.booleanAttr(value);

        this._reflectAttribute('fullscreen', this._fullscreen);

        if (this._fullscreen) {
          // Full screen and movable are not compatible
          this.movable = false;

          this._elements.wrapper.classList.add(FULLSCREEN_CLASSNAME);
        } else {
          this._elements.wrapper.classList.remove(FULLSCREEN_CLASSNAME);
        }
      }
      /**
       Inherited from {@link BaseOverlay#open}.
       */

    }, {
      key: "open",
      get: function get() {
        return _get(_getPrototypeOf(Dialog.prototype), "open", this);
      },
      set: function set(value) {
        var _this3 = this;

        _set(_getPrototypeOf(Dialog.prototype), "open", value, this, true); // Ensure we're in the DOM


        if (this.open) {
          // If not child of document.body, we have to move it there
          this._moveToDocumentBody(); // Show the backdrop, if necessary


          if (this.backdrop !== backdrop.NONE) {
            this._showBackdrop();
          }
        } // Support animation


        requestAnimationFrame(function () {
          // Support wrapped dialog
          _this3._elements.wrapper.classList.toggle('is-open', _this3.open); // Handles what to focus based on focusOnShow


          if (_this3.open) {
            commons.transitionEnd(_this3._elements.wrapper, function () {
              _this3._handleFocus();

              _this3._elements.closeButton.tabIndex = 0;

              _this3._elements.closeButton.removeAttribute('coral-tabcapture');
            });
          } else {
            _this3._elements.closeButton.tabIndex = -1;

            _this3._elements.closeButton.setAttribute('coral-tabcapture', '');
          }
        });
      }
      /**
       The dialog's icon.
        @type {String}
       @default ""
       @htmlattribute icon
       */

    }, {
      key: "icon",
      get: function get() {
        return this._elements.icon;
      },
      set: function set(value) {
        this._elements.icon = value;
      }
      /**
       Whether the dialog should have a close button. See {@link DialogClosableEnum}.
        @type {String}
       @default DialogClosableEnum.OFF
       @htmlattribute closable
       @htmlattributereflected
       */

    }, {
      key: "closable",
      get: function get() {
        return this._closable || closable.OFF;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        this._closable = validate.enumeration(closable)(value) && value || closable.OFF;

        this._reflectAttribute('closable', this._closable);

        this._elements.wrapper.classList.toggle("".concat(CLASSNAME$j, "--dismissible"), this._closable === closable.ON);
      }
      /**
       Whether the dialog can moved around by dragging the title.
        @type {Boolean}
       @default false
       @htmlattribute movable
       @htmlattributereflected
       */

    }, {
      key: "movable",
      get: function get() {
        return this._movable || false;
      },
      set: function set(value) {
        this._movable = transform.booleanAttr(value);

        this._reflectAttribute('movable', this._movable); // Movable and fullscreen are not compatible


        if (this._movable) {
          this.fullscreen = false;
        }

        if (this._movable) {
          var dragAction = new DragAction(this);
          dragAction.handle = this._elements.headerWrapper;
        } else {
          // Disables any dragging interaction
          if (this.dragAction) {
            this.dragAction.destroy();
          } // Recenter the dialog once it's not movable anymore


          this.center();
        }
      }
      /**
       Inherited from {@link BaseComponent#trackingElement}.
       */

    }, {
      key: "trackingElement",
      get: function get() {
        return typeof this._trackingElement === 'undefined' ? this.header && this.header.textContent && this.header.textContent.replace(/\s{2,}/g, ' ').trim() || '' : this._trackingElement;
      },
      set: function set(value) {
        _set(_getPrototypeOf(Dialog.prototype), "trackingElement", value, this, true);
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-dialog-header': 'header',
          'coral-dialog-content': 'content',
          'coral-dialog-footer': 'footer'
        };
      }
      /**
       Returns {@link Dialog} variants.
        @return {DialogVariantEnum}
       */

    }], [{
      key: "variant",
      get: function get() {
        return variant$4;
      }
      /**
       Returns {@link Dialog} backdrops.
        @return {DialogBackdropEnum}
       */

    }, {
      key: "backdrop",
      get: function get() {
        return backdrop;
      }
      /**
       Returns {@link Dialog} close options.
        @return {DialogClosableEnum}
       */

    }, {
      key: "closable",
      get: function get() {
        return closable;
      }
      /**
       Returns {@link Dialog} interaction options.
        @return {DialogInteractionEnum}
       */

    }, {
      key: "interaction",
      get: function get() {
        return interaction$2;
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(Dialog), "observedAttributes", this).concat(['interaction', 'backdrop', 'variant', 'fullscreen', 'icon', 'closable', 'movable']);
      }
    }]);

    return Dialog;
  }(BaseOverlay(BaseComponent(HTMLElement)));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Dialog.Header
   @classdesc The Dialog header content
   @htmltag coral-dialog-header
   @return {HTMLElement}
   */
  var DialogHeader = (function () {
    return document.createElement('coral-dialog-header');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Dialog.Content
   @classdesc The Dialog default content
   @htmltag coral-dialog-content
   @return {HTMLElement}
   */
  var DialogContent = (function () {
    return document.createElement('coral-dialog-content');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Dialog.Footer
   @classdesc The Dialog footer content
   @htmltag coral-dialog-footer
   @return {HTMLElement}
   */
  var DialogFooter = (function () {
    return document.createElement('coral-dialog-footer');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons.extend(strings, {
    'coral-component-dialog': translations$5
  }); // Expose component on the Coral namespace

  commons._define('coral-dialog', Dialog);

  Dialog.Header = DialogHeader;
  Dialog.Content = DialogContent;
  Dialog.Footer = DialogFooter;

  var template$6 = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["headerWrapper"] = document.createElement("div");
    el0.className += " _coral-Dialog-header";
    el0.setAttribute("handle", "headerWrapper");
    el0.setAttribute("role", "presentation");
    frag.appendChild(el0);
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    var el2 = this["closeButton"] = document.createElement("button", "coral-button");
    el2.setAttribute("tracking", "off");
    el2.setAttribute("handle", "closeButton");
    el2.className += " _coral-Dialog-closeButton _coral-ClearButton";
    el2.setAttribute("type", "button");
    el2.setAttribute("is", "coral-button");
    el2.setAttribute("variant", "_custom");
    el2.setAttribute("icon", "close");
    el2.setAttribute("title", data_0["i18n"]["get"]('Close'));
    el2.setAttribute("tabindex", "-1");
    el2.setAttribute("coral-close", "");
    frag.appendChild(el2);
    var el3 = document.createTextNode("\n");
    frag.appendChild(el3);
    var el4 = this["tip"] = document.createElement("div");
    el4.className += " _coral-Popover-tip";
    el4.setAttribute("handle", "tip");
    frag.appendChild(el4);
    var el5 = document.createTextNode("\n");
    frag.appendChild(el5);
    return frag;
  };

  var CLASSNAME$k = '_coral-Popover';
  var OFFSET = 5; // Used to map icon with variant

  var capitalize$2 = function capitalize(s) {
    return s.charAt(0).toUpperCase() + s.slice(1);
  }; // If it's empty and has no non-textnode children


  var _isEmpty = function _isEmpty(el) {
    return !el || el.children.length === 0 && el.textContent.replace(/\s*/g, '') === '';
  };
  /**
   Enumeration for {@link Popover} closable state.

   @typedef {Object} PopoverClosableEnum

   @property {String} ON
   Show a close button on the popover and close the popover when clicked.
   @property {String} OFF
   Do not show a close button. Elements with the <code>coral-close</code> attributes will still close the
   popover.
   */


  var closable$1 = {
    ON: 'on',
    OFF: 'off'
  };
  /**
   Enumeration for {@link Popover} variants.

   @typedef {Object} PopoverVariantEnum

   @property {String} DEFAULT
   A default popover without header icon.
   @property {String} ERROR
   A popover with an error header and icon, indicating that an error has occurred.
   @property {String} WARNING
   A popover with a warning header and icon, notifying the user of something important.
   @property {String} SUCCESS
   A popover with a success header and icon, indicates to the user that an operation was successful.
   @property {String} HELP
   A popover with a question header and icon, provides the user with help.
   @property {String} INFO
   A popover with an info header and icon, informs the user of non-critical information.
   */

  var variant$5 = {
    DEFAULT: 'default',
    ERROR: 'error',
    WARNING: 'warning',
    SUCCESS: 'success',
    HELP: 'help',
    INFO: 'info',
    _COACHMARK: '_coachmark'
  }; // A string of all possible variant classnames

  var ALL_VARIANT_CLASSES$4 = [];

  for (var variantValue$3 in variant$5) {
    if (variantValue$3 !== 'COACHMARK') {
      ALL_VARIANT_CLASSES$4.push("_coral-Dialog--".concat(variant$5[variantValue$3]));
    }
  } // A string of all possible placement classnames


  var placement$1 = Overlay.placement;
  var ALL_PLACEMENT_CLASSES = [];

  for (var placementKey in placement$1) {
    ALL_PLACEMENT_CLASSES.push("".concat(CLASSNAME$k, "--").concat(placement$1[placementKey]));
  }
  /**
   @class Coral.Popover
   @classdesc A Popover component for small overlay content.
   @htmltag coral-popover
   @extends {Overlay}
   */


  var Popover = /*#__PURE__*/function (_Overlay) {
    _inherits(Popover, _Overlay);

    var _super = _createSuper(Popover);

    /** @ignore */
    function Popover() {
      var _this;

      _classCallCheck(this, Popover);

      _this = _super.call(this); // Prepare templates

      _this._elements = commons.extend(_this._elements, {
        // Fetch or create the content zone elements
        header: _this.querySelector('coral-popover-header') || document.createElement('coral-popover-header'),
        content: _this.querySelector('coral-popover-content') || document.createElement('coral-popover-content'),
        footer: _this.querySelector('coral-popover-footer') || document.createElement('coral-popover-footer')
      });
      template$6.call(_this._elements, {
        i18n: i18n
      }); // Events

      _this._delegateEvents({
        'global:capture:click': '_handleClick',
        'coral-overlay:positioned': '_onPositioned',
        'coral-overlay:_animate': '_onAnimate'
      }); // Override defaults from Overlay


      _this._focusOnShow = _this.constructor.focusOnShow.ON;
      _this._trapFocus = _this.constructor.trapFocus.ON;
      _this._returnFocus = _this.constructor.returnFocus.ON;
      _this._overlayAnimationTime = _this.constructor.FADETIME;
      _this._lengthOffset = OFFSET; // Listen for mutations

      ['header', 'footer'].forEach(function (name) {
        _this["_".concat(name, "Observer")] = new MutationObserver(function () {
          _this._hideContentZoneIfEmpty(name);

          _this._toggleFlyout();
        }); // Watch for changes

        _this._observeContentZone(name);
      });
      return _this;
    }
    /**
     The popover's content element.
      @contentzone
     @name content
     @type {PopoverContent}
     */


    _createClass(Popover, [{
      key: "_setAriaExpandedOnTarget",
      value: function _setAriaExpandedOnTarget() {
        var _this2 = this;

        var target = this._getTarget();

        if (target) {
          var hasPopupAttribute = target.hasAttribute('aria-haspopup');

          if (hasPopupAttribute || target.querySelector('[aria-haspopup]') !== null) {
            var targetElements = hasPopupAttribute ? [target] : target.querySelectorAll('[aria-haspopup]');
            targetElements.forEach(function (targetElement) {
              return targetElement.setAttribute('aria-expanded', _this2.open);
            });
          }
        }
      }
    }, {
      key: "_onPositioned",
      value: function _onPositioned(event) {
        if (this.open) {
          var _this$classList;

          // Set arrow placement
          (_this$classList = this.classList).remove.apply(_this$classList, ALL_PLACEMENT_CLASSES);

          this.classList.add("".concat(CLASSNAME$k, "--").concat(event.detail.placement));
        }
      }
    }, {
      key: "_onAnimate",
      value: function _onAnimate() {
        // popper attribute
        var popperPlacement = this.getAttribute('x-placement'); // popper takes care of setting left, top to 0 on positioning

        if (popperPlacement === 'left') {
          this.style.left = '8px';
        } else if (popperPlacement === 'top') {
          this.style.top = '8px';
        } else if (popperPlacement === 'right') {
          this.style.left = '-8px';
        } else if (popperPlacement === 'bottom') {
          this.style.top = '-8px';
        }
      }
    }, {
      key: "_insertTypeIcon",
      value: function _insertTypeIcon() {
        if (this._elements.icon) {
          this._elements.icon.remove();
        }

        var variantValue = this.variant; // Warning icon is same as ERROR icon

        if (variantValue === variant$5.WARNING || variantValue === variant$5.ERROR) {
          variantValue = 'alert';
        } // Inject the SVG icon


        if (variantValue !== variant$5.DEFAULT && variantValue !== variant$5._COACHMARK) {
          var iconName = capitalize$2(variantValue);

          this._elements.headerWrapper.insertAdjacentHTML('beforeend', Icon._renderSVG("spectrum-css-icon-".concat(iconName, "Medium"), ['_coral-Dialog-typeIcon', "_coral-UIIcon-".concat(iconName, "Medium")]));

          this._elements.icon = this.querySelector('._coral-Dialog-typeIcon');
        }
      }
    }, {
      key: "_observeContentZone",
      value: function _observeContentZone(name) {
        var observer = this["_".concat(name, "Observer")];

        if (observer) {
          observer.disconnect();
          observer.observe(this._elements[name], {
            // Catch changes to childList
            childList: true,
            // Catch changes to textContent
            characterData: true,
            // Monitor any child node
            subtree: true
          });
        }
      }
    }, {
      key: "_hideContentZoneIfEmpty",
      value: function _hideContentZoneIfEmpty(name) {
        var contentZone = this._elements[name];
        var target = name === 'header' ? this._elements.headerWrapper : contentZone; // If it's empty and has no non-textnode children, hide the header

        var hiddenValue = _isEmpty(contentZone); // Only bother if the hidden status has changed


        if (hiddenValue !== target.hidden) {
          target.hidden = hiddenValue; // Reposition as the height has changed

          this.reposition();
        }
      }
    }, {
      key: "_toggleCoachMark",
      value: function _toggleCoachMark(isCoachMark) {
        var _this3 = this;

        this.classList.toggle('_coral-CoachMarkPopover', isCoachMark);

        this._elements.headerWrapper.classList.toggle('_coral-Dialog-header', !isCoachMark);

        this._elements.headerWrapper.classList.toggle('_coral-CoachMarkPopover-header', isCoachMark);

        ['header', 'content', 'footer'].forEach(function (contentZone, i) {
          var el = _this3[contentZone];
          var type = i === 0 ? 'title' : contentZone;

          if (el) {
            el.classList.toggle("_coral-Dialog-".concat(type), !isCoachMark);
            el.classList.toggle("_coral-CoachMarkPopover-".concat(type), isCoachMark);
          }
        });
      }
    }, {
      key: "_toggleFlyout",
      value: function _toggleFlyout() {
        // Flyout mode is when there's only content in default variant
        var isFlyout = this._variant === variant$5._COACHMARK || this._variant === variant$5.DEFAULT && _isEmpty(this.header) && _isEmpty(this.footer);

        this.classList.toggle("".concat(CLASSNAME$k, "--dialog"), !isFlyout);
        this._elements.tip.hidden = isFlyout;
      }
      /** @private */

    }, {
      key: "_handleClick",
      value: function _handleClick(event) {
        if (this.interaction === this.constructor.interaction.OFF) {
          // Since we use delegation, just ignore clicks if interaction is off
          return;
        }

        var eventTarget = event.target;

        var targetEl = this._getTarget();

        var eventIsWithinTarget = targetEl ? targetEl.contains(eventTarget) : false;

        if (eventIsWithinTarget) {
          // When target is clicked
          if (!this.open && !targetEl.disabled) {
            // Open if we're not already open and target element is not disabled
            this.show();

            this._trackEvent('display', 'coral-popover', event);
          } else {
            this.hide();

            this._trackEvent('close', 'coral-popover', event);
          }
        } else if (this.open && !this.contains(eventTarget)) {
          var target = eventTarget.closest('._coral-Overlay'); // Also check if the click element is inside an overlay which target could be inside of this popover

          if (target && this.contains(target._getTarget())) {
            return;
          } // Close if we're open and the click was outside of the target and outside of the popover


          this.hide();

          this._trackEvent('close', 'coral-popover', event);
        }
      }
    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        var _this4 = this;

        _get(_getPrototypeOf(Popover.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$k); // ARIA

        if (!this.hasAttribute('role')) {
          this.setAttribute('role', 'dialog');
        }

        if (!this.hasAttribute('aria-live')) {
          // This helped announcements in certain screen readers
          this.setAttribute('aria-live', 'assertive');
        } // Default reflected attributes


        if (!this._variant) {
          this.variant = variant$5.DEFAULT;
        }

        if (!this._closable) {
          this.closable = closable$1.OFF;
        } // // Fetch the content zones


        var header = this._elements.header;
        var content = this._elements.content;
        var footer = this._elements.footer; // Verify if a content zone is provided

        var contentZoneProvided = this.contains(content) && content || this.contains(footer) && footer || this.contains(header) && header; // Remove content zones so we can process children

        if (header.parentNode) {
          header.remove();
        }

        if (content.parentNode) {
          content.remove();
        }

        if (footer.parentNode) {
          footer.remove();
        } // Remove tab captures


        Array.prototype.filter.call(this.children, function (child) {
          return child.hasAttribute('coral-tabcapture');
        }).forEach(function (tabCapture) {
          _this4.removeChild(tabCapture);
        }); // Support cloneNode

        var template = this.querySelectorAll('._coral-Dialog-header, ._coral-Dialog-closeButton, ._coral-Popover-tip');

        for (var i = 0; i < template.length; i++) {
          template[i].remove();
        } // Move everything in the content


        if (!contentZoneProvided) {
          while (this.firstChild) {
            content.appendChild(this.firstChild);
          }
        } // Insert template


        var frag = document.createDocumentFragment();
        frag.appendChild(this._elements.headerWrapper);
        frag.appendChild(this._elements.closeButton);
        frag.appendChild(this._elements.tip);
        this.appendChild(frag); // Assign content zones

        this.header = header;
        this.content = content;
        this.footer = footer;
      }
    }, {
      key: "content",
      get: function get() {
        return this._getContentZone(this._elements.content);
      },
      set: function set(value) {
        this._setContentZone('content', value, {
          handle: 'content',
          tagName: 'coral-popover-content',
          insert: function insert(content) {
            content.classList.add('_coral-Dialog-content');
            var footer = this.footer; // The content should always be before footer

            this.insertBefore(content, this.contains(footer) && footer || null);
          }
        });
      }
      /**
       The popover's header element.
        @contentzone
       @name header
       @type {PopoverHeader}
       */

    }, {
      key: "header",
      get: function get() {
        return this._getContentZone(this._elements.header);
      },
      set: function set(value) {
        this._setContentZone('header', value, {
          handle: 'header',
          tagName: 'coral-popover-header',
          insert: function insert(header) {
            header.classList.add('_coral-Dialog-title');

            this._elements.headerWrapper.insertBefore(header, this._elements.headerWrapper.firstChild);
          },
          set: function set() {
            // Stop observing the old header and observe the new one
            this._observeContentZone('header'); // Check if header needs to be hidden


            this._hideContentZoneIfEmpty('header');
          }
        });
      }
      /**
       The popover's footer element.
        @type {PopoverFooter}
       @contentzone
       */

    }, {
      key: "footer",
      get: function get() {
        return this._getContentZone(this._elements.footer);
      },
      set: function set(value) {
        this._setContentZone('footer', value, {
          handle: 'footer',
          tagName: 'coral-popover-footer',
          insert: function insert(footer) {
            footer.classList.add('_coral-Dialog-footer'); // The footer should always be after content

            this.appendChild(footer);
          },
          set: function set() {
            // Stop observing the old header and observe the new one
            this._observeContentZone('footer'); // Check if header needs to be hidden


            this._hideContentZoneIfEmpty('footer');
          }
        });
      }
      /**
       The popover's variant. See {@link PopoverVariantEnum}.
        @type {String}
       @default PopoverVariantEnum.DEFAULT
       @htmlattribute variant
       @htmlattributereflected
       */

    }, {
      key: "variant",
      get: function get() {
        return this._variant || variant$5.DEFAULT;
      },
      set: function set(value) {
        var _this$classList2;

        value = transform.string(value).toLowerCase();
        this._variant = validate.enumeration(variant$5)(value) && value || variant$5.DEFAULT;

        this._reflectAttribute('variant', this._variant); // Insert SVG icon


        this._insertTypeIcon(); // Remove all variant classes


        (_this$classList2 = this.classList).remove.apply(_this$classList2, ALL_VARIANT_CLASSES$4); // Toggle dialog mode


        this._toggleFlyout();

        if (this._variant === variant$5._COACHMARK) {
          // ARIA
          this.setAttribute('role', 'dialog');

          this._toggleCoachMark(true);
        } else {
          this._toggleCoachMark(false);

          if (this._variant === variant$5.DEFAULT) {
            // ARIA
            if (!this.hasAttribute('role')) {
              this.setAttribute('role', 'dialog');
            }
          } else {
            // Set new variant class
            this.classList.add("_coral-Dialog--".concat(this._variant)); // ARIA

            this.setAttribute('role', 'alertdialog');
          }
        }
      }
      /**
       Whether the popover should have a close button. See {@link PopoverClosableEnum}.
        @type {String}
       @default PopoverClosableEnum.OFF
       @htmlattribute closable
       @htmlattributereflected
       */

    }, {
      key: "closable",
      get: function get() {
        return this._closable || closable$1.OFF;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        this._closable = validate.enumeration(closable$1)(value) && value || closable$1.OFF;

        this._reflectAttribute('closable', this._closable);

        this._elements.closeButton.style.display = this._closable === closable$1.ON ? 'block' : 'none';
      }
      /**
       Inherited from {@link Overlay#target}.
       */

    }, {
      key: "target",
      get: function get() {
        return _get(_getPrototypeOf(Popover.prototype), "target", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(Popover.prototype), "target", value, this, true); // Coach Mark specific


        var target = this._getTarget();

        if (target && target.tagName === 'CORAL-COACHMARK') {
          this.setAttribute('variant', variant$5._COACHMARK);
        }

        this._setAriaExpandedOnTarget();
      }
      /**
       Inherited from {@link Overlay#open}.
       */

    }, {
      key: "open",
      get: function get() {
        return _get(_getPrototypeOf(Popover.prototype), "open", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(Popover.prototype), "open", value, this, true);

        var target = this._getTarget();

        if (target) {
          var is = target.getAttribute('is');

          if (is === 'coral-button' || is === 'coral-anchorbutton') {
            target.classList.toggle('is-selected', this.open);
          }

          this._setAriaExpandedOnTarget();
        }
      }
      /**
       @ignore
        Not supported anymore.
       */

    }, {
      key: "icon",
      get: function get() {
        return this._icon || '';
      },
      set: function set(value) {
        this._icon = transform.string(value);
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-popover-header': 'header',
          'coral-popover-content': 'content',
          'coral-popover-footer': 'footer'
        };
      }
      /**
       Returns {@link Popover} variants.
        @return {PopoverVariantEnum}
       */

    }], [{
      key: "variant",
      get: function get() {
        return variant$5;
      }
      /**
       Returns {@link Popover} close options.
        @return {PopoverClosableEnum}
       */

    }, {
      key: "closable",
      get: function get() {
        return closable$1;
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(Popover), "observedAttributes", this).concat(['closable', 'variant']);
      }
    }]);

    return Popover;
  }(Overlay);

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Popover.Header
   @classdesc The Popover header content
   @htmltag coral-popover-header
   @return {HTMLElement}
   */
  var PopoverHeader = (function () {
    return document.createElement('coral-popover-header');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Popover.Content
   @classdesc The Popover default content
   @htmltag coral-popover-content
   @return {HTMLElement}
   */
  var PopoverContent = (function () {
    return document.createElement('coral-popover-content');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Popover.Footer
   @classdesc The Popover footer content
   @htmltag coral-popover-footer
   @return {HTMLElement}
   */
  var PopoverFooter = (function () {
    return document.createElement('coral-popover-footer');
  });

  var CLASSNAMES = ['coral-Rule', 'coral-Rule--subsection2'];
  /**
   @class Coral.Popover.Separator
   @classdesc The Popover separator
   @htmltag coral-popover-separator
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var PopoverSeparator = /*#__PURE__*/function (_BaseComponent) {
    _inherits(PopoverSeparator, _BaseComponent);

    var _super = _createSuper(PopoverSeparator);

    function PopoverSeparator() {
      _classCallCheck(this, PopoverSeparator);

      return _super.apply(this, arguments);
    }

    _createClass(PopoverSeparator, [{
      key: "connectedCallback",

      /** @ignore */
      value: function connectedCallback() {
        var _this$classList;

        (_this$classList = this.classList).add.apply(_this$classList, CLASSNAMES);
      }
    }]);

    return PopoverSeparator;
  }(BaseComponent(HTMLElement));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons.extend(strings, {
    'coral-component-popover': translations$4
  }); // Expose component on the Coral namespace

  commons._define('coral-popover-separator', PopoverSeparator);

  commons._define('coral-popover', Popover);

  Popover.Header = PopoverHeader;
  Popover.Content = PopoverContent;
  Popover.Footer = PopoverFooter;
  Popover.Separator = PopoverSeparator;

  var template$7 = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var data = data_0 = typeof data_0 === "undefined" ? {} : data_0;
    data = data_0;
    var buttonId = data.commons.getUID();
    var listId = data.commons.getUID();
    data_0 = data;
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    var el2 = this["button"] = document.createElement("button", "coral-button");
    el2.setAttribute("tracking", "off");
    el2.setAttribute("variant", "_custom");
    el2.setAttribute("iconposition", "right");
    el2.setAttribute("handle", "button");
    el2.setAttribute("type", "button");
    el2.setAttribute("is", "coral-button");
    el2.setAttribute("aria-haspopup", "listbox");
    el2.id = buttonId;
    el2.setAttribute("aria-controls", listId);
    el2.setAttribute("aria-expanded", "false");
    el2.className += " _coral-FieldButton _coral-Dropdown-trigger";
    var el3 = document.createTextNode("\n  ");
    el2.appendChild(el3);
    var el4 = this["label"] = document.createElement("coral-button-label");
    el4.className += " _coral-Dropdown-label";
    el4.setAttribute("handle", "label");
    el4.id = data_0["commons"]["getUID"]();
    el4.textContent = "â";
    el2.appendChild(el4);
    var el5 = document.createTextNode("\n  ");
    el2.appendChild(el5);
    var el6 = this["invalidIcon"] = document.createElement("coral-icon");
    el6.setAttribute("icon", "alert");
    el6.setAttribute("hidden", "");
    el6.setAttribute("handle", "invalidIcon");
    el6.className += " _coral-Dropdown-invalidIcon";
    el6.setAttribute("alt", data_0["i18n"]["get"]('invalid'));
    el6.id = data_0["commons"]["getUID"]();
    el2.appendChild(el6);
    var el7 = document.createTextNode("\n");
    el2.appendChild(el7);
    frag.appendChild(el2);
    var el8 = document.createTextNode("\n");
    frag.appendChild(el8);
    data = data_0; // Don't wait for button MO to pick up the label

    this.button._elements.label = this.label; // Render invalid icon

    this.button.insertAdjacentHTML('beforeend', data.Icon._renderSVG('spectrum-css-icon-ChevronDownMedium', ['_coral-Dropdown-icon', '_coral-UIIcon-ChevronDownMedium']));
    data_0 = data;
    var el10 = document.createTextNode("\n");
    frag.appendChild(el10);
    var el11 = this["overlay"] = document.createElement("coral-popover");
    el11.setAttribute("withinoffset", "0");
    el11.setAttribute("tracking", "off");
    el11.className += " _coral-Select-overlay";
    el11.setAttribute("smart", "");
    el11.id = data_0["commons"]["getUID"]();
    el11.setAttribute("handle", "overlay");
    el11.setAttribute("placement", "bottom");
    el11.setAttribute("focusonshow", "coral-selectlist");
    el11.setAttribute("role", "presentation");
    var el12 = document.createTextNode("\n  ");
    el11.appendChild(el12);
    data = data_0; // Constrains the size of the list to 6 items.
    // @todo move this to theme

    var maxHeight = 'max-height:' + 32 * 6 + 'px';
    data_0 = data;
    var el14 = document.createTextNode("\n  ");
    el11.appendChild(el14);
    var el15 = this["list"] = document.createElement("coral-selectlist");
    el15.setAttribute("tracking", "off");
    el15.setAttribute("style", maxHeight);
    el15.setAttribute("handle", "list");
    el15.setAttribute("role", "listbox");
    el15.id = listId;
    el11.appendChild(el15);
    var el16 = document.createTextNode("\n");
    el11.appendChild(el16);
    frag.appendChild(el11);
    var el17 = document.createTextNode("\n");
    frag.appendChild(el17);
    var el18 = this["input"] = document.createElement("input");
    el18.setAttribute("handle", "input");
    el18.setAttribute("type", "hidden");
    frag.appendChild(el18);
    var el19 = document.createTextNode("\n");
    frag.appendChild(el19);
    var el20 = this["nativeSelect"] = document.createElement("select");
    el20.setAttribute("handle", "nativeSelect");
    el20.className += " _coral-Dropdown-select";
    el20.setAttribute("tabindex", "-1");
    frag.appendChild(el20);
    var el21 = document.createTextNode("\n");
    frag.appendChild(el21);
    var el22 = this["taglist"] = document.createElement("coral-taglist");
    el22.setAttribute("tracking", "off");
    el22.setAttribute("handle", "taglist");
    el22.className += " _coral-Dropdown-tagList";
    frag.appendChild(el22);
    var el23 = document.createTextNode("\n");
    frag.appendChild(el23);
    return frag;
  };

  /**
   Enumeration for {@link Select} variants.

   @typedef {Object} SelectVariantEnum

   @property {String} DEFAULT
   A default, gray Select.
   @property {String} QUIET
   A Select with no border or background.
   */

  var variant$6 = {
    DEFAULT: 'default',
    QUIET: 'quiet'
  };
  var CLASSNAME$l = '_coral-Dropdown'; // used in 'auto' mode to determine if the client is on mobile.

  var IS_MOBILE_DEVICE = navigator.userAgent.match(/iPhone|iPad|iPod|Android/i) !== null;
  /**
   Extracts the value from the item in case no explicit value was provided.

   @param {HTMLElement} item
   the item whose value will be extracted.

   @returns {String} the value that will be submitted for this item.

   @private
   */

  var itemValueFromDOM$1 = function itemValueFromDOM(item) {
    var attr = item.getAttribute('value'); // checking explicitely for null allows to differenciate between non set values and empty strings

    return attr !== null ? attr : item.textContent.replace(/\s{2,}/g, ' ').trim();
  };
  /**
   Calculates the difference between two given arrays. It returns the items that are in a that are not in b.

   @param {Array.<String>} a
   @param {Array.<String>} b

   @returns {Array.<String>}
   the difference between the arrays.
   */


  var arrayDiff = function arrayDiff(a, b) {
    return a.filter(function (item) {
      return !b.some(function (item2) {
        return item === item2;
      });
    });
  };
  /**
   @class Coral.Select
   @classdesc A Select component is a form field that allows users to select from a list of options. If this component is
   shown on a mobile device, it will show a native select list, instead of the select list styled via Coral Spectrum.
   @htmltag coral-select
   @extends {HTMLElement}
   @extends {BaseComponent}
   @extends {BaseFormField}
   */


  var Select = /*#__PURE__*/function (_BaseFormField) {
    _inherits(Select, _BaseFormField);

    var _super = _createSuper(Select);

    /** @ignore */
    function Select() {
      var _this;

      _classCallCheck(this, Select);

      _this = _super.call(this); // Templates

      _this._elements = {};
      template$7.call(_this._elements, {
        commons: commons,
        Icon: Icon,
        i18n: i18n
      });
      var events = {
        'global:click': '_onGlobalClick',
        'global:touchstart': '_onGlobalClick',
        'coral-collection:add coral-taglist': '_onInternalEvent',
        'coral-collection:remove coral-taglist': '_onInternalEvent',
        // item events
        'coral-select-item:_valuechanged coral-select-item': '_onItemValueChange',
        'coral-select-item:_contentchanged coral-select-item': '_onItemContentChange',
        'coral-select-item:_disabledchanged coral-select-item': '_onItemDisabledChange',
        'coral-select-item:_selectedchanged coral-select-item': '_onItemSelectedChange',
        'change coral-taglist': '_onTagListChange',
        'change select': '_onNativeSelectChange',
        'click select': '_onNativeSelectClick',
        'click > ._coral-Dropdown-trigger': '_onButtonClick',
        'key:space > ._coral-Dropdown-trigger': '_onSpaceKey',
        'key:enter > ._coral-Dropdown-trigger': '_onSpaceKey',
        'key:return > ._coral-Dropdown-trigger': '_onSpaceKey',
        'key:down > ._coral-Dropdown-trigger': '_onSpaceKey'
      }; // Overlay

      var overlayId = _this._elements.overlay.id;
      events["global:capture:coral-collection:add #".concat(overlayId, " coral-selectlist")] = '_onSelectListItemAdd';
      events["global:capture:coral-collection:remove #".concat(overlayId, " coral-selectlist")] = '_onInternalEvent';
      events["global:capture:coral-selectlist:beforechange #".concat(overlayId)] = '_onSelectListBeforeChange';
      events["global:capture:coral-selectlist:change #".concat(overlayId)] = '_onSelectListChange';
      events["global:capture:coral-selectlist:scrollbottom #".concat(overlayId)] = '_onSelectListScrollBottom';
      events["global:capture:coral-overlay:close #".concat(overlayId)] = '_onOverlayToggle';
      events["global:capture:coral-overlay:open #".concat(overlayId)] = '_onOverlayToggle';
      events["global:capture:coral-overlay:positioned #".concat(overlayId)] = '_onOverlayPositioned';
      events["global:capture:coral-overlay:beforeopen #".concat(overlayId)] = '_onBeforeOpen';
      events["global:capture:coral-overlay:beforeclose #".concat(overlayId)] = '_onInternalEvent'; // Keyboard interaction

      events["global:keypress #".concat(overlayId)] = '_onOverlayKeyPress'; // TODO for some reason this disables tabbing into the select
      // events[`global:key:tab #${overlayId} coral-selectlist-item`] = '_onTabKey';
      // events[`global:key:tab+shift #${overlayId} coral-selectlist-item`] = '_onTabKey';
      // Attach events

      _this._delegateEvents(commons.extend(_this._events, events)); // Pre-define labellable element


      _this._labellableElement = _this._elements.button; // default value of inner flag to process events

      _this._bulkSelectionChange = false; // we only have AUTO mode.

      _this._useNativeInput = IS_MOBILE_DEVICE;

      _this._elements.taglist.reset = function () {// since reseting a form will call the reset on every component, we need to kill the behavior of the taglist
        // otherwise the state will not be accurate
      };

      _this._initialValues = []; // Init the collection mutation observer

      _this.items._startHandlingItems();

      return _this;
    }
    /**
     Returns the inner overlay to allow customization.
      @type {Popover}
     @readonly
     */


    _createClass(Select, [{
      key: "_setName",

      /** @ignore */
      value: function _setName(value) {
        if (this.multiple) {
          this._elements.input.name = '';

          this._elements.taglist.setAttribute('name', value);
        } else {
          this._elements.taglist.setAttribute('name', '');

          this._elements.input.name = value;
        }
      }
      /**
       @param {Boolean} [checkAvailableSpace=false]
       If <code>true</code>, the event is triggered based on the available space.
        @private
       */

    }, {
      key: "_showOptions",
      value: function _showOptions(checkAvailableSpace) {
        var _this2 = this;

        if (checkAvailableSpace) {
          // threshold in pixels
          var ITEM_SIZE_THRESHOLD = 30;
          var scrollHeight = this._elements.list.scrollHeight;
          var viewportHeight = this._elements.list.clientHeight;
          var scrollTop = this._elements.list.scrollTop; // we should not do this, but it increases performance since we do not need to find the item

          var loadIndicator = this._elements.list._elements.loadIndicator; // we remove the size of the load indicator

          if (loadIndicator && loadIndicator.parentNode) {
            var outerHeight = function outerHeight(el) {
              var height = el.offsetHeight;
              var style = getComputedStyle(el);
              height += parseInt(style.marginTop, 10) + parseInt(style.marginBottom, 10);
              return height;
            };

            scrollHeight -= outerHeight(loadIndicator);
          } // if we are not close to the bottom scroll, we cancel triggering the event


          if (scrollTop + viewportHeight < scrollHeight - ITEM_SIZE_THRESHOLD) {
            return;
          }
        } // we do not show the list with native


        if (!this._useNativeInput) {
          if (!this._elements.overlay.open) {
            // Show the overlay
            this._elements.overlay.open = true;
          } // Force overlay repositioning (remote loading)


          requestAnimationFrame(function () {
            _this2._elements.overlay._onAnimate();

            _this2._elements.overlay.reposition();
          });
        } // Trigger an event
        // @todo: maybe we should only trigger this event when the button is toggled and we have space for more items


        var event = this.trigger('coral-select:showitems', {
          // amount of items in the select
          start: this.items.length
        }); // while using native there is no need to show the loading

        if (!this._useNativeInput) {
          // if the default is prevented, we should the loading indicator
          this._elements.list.loading = event.defaultPrevented;
        } // communicate expanded state to assistive technology


        this._elements.button.setAttribute('aria-expanded', true);
      }
      /** @private */

    }, {
      key: "_hideOptions",
      value: function _hideOptions() {
        // Don't close the overlay if selection = multiple
        if (!this.multiple) {
          this._elements.overlay.open = false;
          this.trigger('coral-select:hideitems');
        } // communicate collapsed state to assistive technology


        this._elements.button.setAttribute('aria-expanded', false);
      }
      /** @ignore */

    }, {
      key: "_onGlobalClick",
      value: function _onGlobalClick(event) {
        if (!this._elements.overlay.open) {
          return;
        }

        var eventTargetWithinOverlayTarget = this._elements.button.contains(event.target);

        var eventTargetWithinItself = this._elements.overlay.contains(event.target);

        if (!eventTargetWithinOverlayTarget && !eventTargetWithinItself) {
          this._hideOptions();
        }
      }
      /** @private */

    }, {
      key: "_onSelectListItemAdd",
      value: function _onSelectListItemAdd(event) {
        // stops propagation cause the event is internal to the component
        event.stopImmediatePropagation(); // When items have been added, we are no longer loading

        this.loading = false; // Reset height

        this._elements.list.style.height = ''; // Measure actual height

        var style = window.getComputedStyle(this._elements.list);
        var height = parseInt(style.height, 10);
        var maxHeight = parseInt(style.maxHeight, 10);

        if (height < maxHeight) {
          // Make it scrollable
          this._elements.list.style.height = "".concat(height - 1, "px");
        }
      }
    }, {
      key: "_onBeforeOpen",
      value: function _onBeforeOpen(event) {
        event.stopImmediatePropagation(); // Prevent opening the overlay if select is readonly

        if (this.readOnly) {
          event.preventDefault();
        } // focus first selected or tabbable item when the list expands


        this._elements.list._resetTabTarget(true);
      }
      /** @private */

    }, {
      key: "_onInternalEvent",
      value: function _onInternalEvent(event) {
        // stops propagation cause the event is internal to the component
        event.stopImmediatePropagation();
      }
      /** @ignore */

    }, {
      key: "_onItemAdded",
      value: function _onItemAdded(item) {
        var selectListItemParent = this._elements.list;
        var selectListItem = item._selectListItem || new SelectList.Item(); // @todo: Make sure it is added at the right index.

        selectListItemParent.appendChild(selectListItem);
        selectListItem.set({
          value: item.value,
          content: {
            innerHTML: item.innerHTML
          },
          disabled: item.disabled,
          selected: item.selected,
          trackingElement: item.trackingElement
        }, true);
        var nativeOption = item._nativeOption || new Option(); // @todo: make sure it is added at the right index.

        this._elements.nativeSelect.appendChild(nativeOption); // Need to store the initially selected values in the native select so that it can be reset


        if (this._initialValues.indexOf(item.value) !== -1) {
          nativeOption.setAttribute('selected', 'selected');
        }

        nativeOption.selected = item.selected;
        nativeOption.value = item.value;
        nativeOption.disabled = item.disabled;
        nativeOption.innerHTML = item.innerHTML;

        if (this.multiple) {
          // in case it was selected before it was added
          if (item.selected) {
            this._addTagToTagList(item);
          }
        } // Make sure the input value is set to the selected item
        else if (item.selected) {
            this._elements.input.value = item.value;
          }

        item._selectListItem = selectListItem;
        item._nativeOption = nativeOption;
        selectListItem._selectItem = item;
        nativeOption._selectItem = item;
      }
      /** @private */

    }, {
      key: "_onItemRemoved",
      value: function _onItemRemoved(item) {
        if (item._selectListItem) {
          item._selectListItem.remove();

          item._selectListItem._selectItem = undefined;
          item._selectListItem = undefined;
        }

        if (item._nativeOption) {
          this._elements.nativeSelect.removeChild(item._nativeOption);

          item._nativeOption._selectItem = undefined;
          item._nativeOption = undefined;
        }

        this._removeTagFromTagList(item, true);
      }
      /** @private */

    }, {
      key: "_onItemSelected",
      value: function _onItemSelected(item) {
        // in case the component is not in the DOM or the internals have not been created we force it
        if (!item._selectListItem || !item._selectListItem.parentNode) {
          this._onItemAdded(item);
        }

        item._selectListItem.selected = true;
        item._nativeOption.selected = true;

        if (this.multiple) {
          this._addTagToTagList(item); // @todo: what happens when ALL items have been selected
          //  1. a message is disabled (i18n?)
          //  2. we don't try to open the selectlist (native behavior).

        } else {
          this._elements.input.value = item.value;
        }
      }
      /** @private */

    }, {
      key: "_onItemDeselected",
      value: function _onItemDeselected(item) {
        // in case the component is not in the DOM or the internals have not been created we force it
        if (!item._selectListItem || !item._selectListItem.parentNode) {
          this._onItemAdded(item);
        }

        item._selectListItem.selected = false;
        item._nativeOption.selected = false;

        if (this.multiple) {
          // we use the internal reference to remove the related tag from the taglist
          this._removeTagFromTagList(item);
        }
      }
      /**
       Detects when something is about to change inside the select.
        @private
       */

    }, {
      key: "_onSelectListBeforeChange",
      value: function _onSelectListBeforeChange(event) {
        // stops propagation cause the event is internal to the component
        event.stopImmediatePropagation(); // We prevent the selection to change if we're in single selection and the clicked item is already selected

        if (!this.multiple && event.detail.item.selected) {
          event.preventDefault();
          this._elements.overlay.open = false;
        }
      }
      /**
       Detects when something inside the select list changes.
        @private
       */

    }, {
      key: "_onSelectListChange",
      value: function _onSelectListChange(event) {
        // stops propagation cause the event is internal to the component
        event.stopImmediatePropagation(); // avoids triggering unnecessary changes in the selectist because selecting items programatically will trigger
        // a change event

        if (this._bulkSelectionChange) {
          return;
        }

        var oldSelection = event.detail.oldSelection || [];
        oldSelection = !Array.isArray(oldSelection) ? [oldSelection] : oldSelection;
        var selection = event.detail.selection || [];
        selection = !Array.isArray(selection) ? [selection] : selection; // if the arrays are the same, there is no point in calculating the selection changes

        if (event.detail.oldSelection !== event.detail.selection) {
          this._bulkSelectionChange = true; // we deselect first the ones that have to go

          var removedSelection = arrayDiff(oldSelection, selection);
          removedSelection.forEach(function (listItem) {
            // selectlist will report on removed items
            if (listItem._selectItem) {
              listItem._selectItem.removeAttribute('selected');
            }
          }); // we only sync the items that changed

          var newSelection = arrayDiff(selection, oldSelection);
          newSelection.forEach(function (listItem) {
            if (listItem._selectItem) {
              listItem._selectItem.setAttribute('selected', '');
            }
          });
          this._bulkSelectionChange = false; // hides the list since something was selected. if the overlay was open, it means there was user interaction so
          // the necessary events need to be triggered

          if (this._elements.overlay.open) {
            // closes and triggers the hideitems event
            this._hideOptions(); // if there is a change in the added or removed selection, we trigger a change event


            if (newSelection.length || removedSelection.length) {
              this.trigger('change');
            }
          }
        } // in case they are the same, we just need to trigger the hideitems event when appropiate, and that is when the
        // overlay was previously open
        else if (this._elements.overlay.open) {
            // closes and triggers the hideitems event
            this._hideOptions();
          }

        if (!this.multiple) {
          this._trackEvent('change', 'coral-select-item', event, this.selectedItem);
        }
      }
      /** @private */

    }, {
      key: "_onTagListChange",
      value: function _onTagListChange(event) {
        // cancels the change event from the taglist
        event.stopImmediatePropagation(); // avoids triggering unnecessary changes in the selectist because selecting items programatically will trigger
        // a change event

        if (this._bulkSelectionChange) {
          return;
        }

        this._bulkSelectionChange = true;
        var values = event.target.values; // we use the selected items, because they are the only possible items that may change

        var itemValue;

        this.items._getAllSelected().forEach(function (item) {
          // we use DOM API instead of properties in case the item is not yet initialized
          itemValue = itemValueFromDOM$1(item); // if the item is inside the values array, then it has to be selected

          item[values.indexOf(itemValue) !== -1 ? 'setAttribute' : 'removeAttribute']('selected', '');
        });

        this._bulkSelectionChange = false; // if the taglist is empty, we should return the focus to the button

        if (!values.length) {
          this._elements.button.focus();
        } // reparents the change event with the select as the target


        this.trigger('change');
      }
      /** @private */

    }, {
      key: "_addTagToTagList",
      value: function _addTagToTagList(item) {
        // we prepare the tag
        item._tag = item._tag || new Tag();

        item._tag.set({
          value: item.value,
          label: {
            innerHTML: item.innerHTML
          }
        }, true); // we add the new tag at the end


        this._elements.taglist.items.add(item._tag);
      }
      /** @private */

    }, {
      key: "_removeTagFromTagList",
      value: function _removeTagFromTagList(item, destroy) {
        if (item._tag) {
          item._tag.remove(); // we only remove the reference if destroy is passed, this allow us to recycle the tags when possible


          item._tag = destroy ? undefined : item._tag;
        }
      }
      /** @private */

    }, {
      key: "_onSelectListScrollBottom",
      value: function _onSelectListScrollBottom(event) {
        // stops propagation cause the event is internal to the component
        event.stopImmediatePropagation();

        if (this._elements.overlay.open) {
          // Checking if the overlay is open guards against debounced scroll events being handled after an overlay has
          // already been closed (e.g. clicking the last element in a selectlist always reopened the overlay emediately
          // after closing)
          // triggers the corresponding event
          // since we got the the event from select list we need to trigger the event
          this._showOptions();
        }
      }
      /** @private */

    }, {
      key: "_onButtonClick",
      value: function _onButtonClick(event) {
        event.preventDefault();

        if (this.disabled || this.readOnly) {
          return;
        } // if native is required, we do not need to do anything


        if (!this._useNativeInput) {
          // @todo: this was removed cause otherwise the coral-select:showitems event is never triggered.
          // if this is a multiselect and all items are selected, there should be nothing in the list to focus so do
          // nothing.
          // if (this.multiple && this.selectedItems.length === this.items.length) {
          //   return;
          // }
          // Toggle openness
          if (this._elements.overlay.classList.contains('is-open')) {
            this._hideOptions();
          } else {
            // event should be triggered based on the contents
            this._showOptions(true);
          }
        }
      }
      /** @private */

    }, {
      key: "_onNativeSelectClick",
      value: function _onNativeSelectClick() {
        this._showOptions(false);
      }
    }, {
      key: "_onOverlayKeyPress",
      value: function _onOverlayKeyPress(event) {
        // Focus on item which text starts with pressed keys
        this._elements.list._onKeyPress(event);
      }
      /** @private */

    }, {
      key: "_onSpaceKey",
      value: function _onSpaceKey(event) {
        if (this.disabled || this.readOnly) {
          return;
        }

        event.preventDefault();

        if (this._useNativeInput) {
          // we try to open the native select
          this._elements.nativeSelect.dispatchEvent(new MouseEvent('mousedown'));
        } else if (!this._elements.overlay.open || event.keyCode === Keys.keyToCode('space')) {
          this._elements.button.click();
        }
      }
      /**
       Prevents tab key default handling on selectList Items.
        @private
       */
      // _onTabKey(event) {
      // event.preventDefault();
      // }

      /** @private */

    }, {
      key: "_onOverlayToggle",
      value: function _onOverlayToggle(event) {
        // stops propagation cause the event is internal to the component
        event.stopImmediatePropagation(); // Trigger private event instead

        var type = event.type.split(':').pop();
        this.trigger("coral-select:_overlay".concat(type));

        this._elements.button.classList.toggle('is-selected', event.target.open); // communicate expanded state to assistive technology


        this._elements.button.setAttribute('aria-expanded', event.target.open);

        if (!event.target.open) {
          this.classList.remove('is-openAbove', 'is-openBelow');
        }
      }
      /** @private */

    }, {
      key: "_onOverlayPositioned",
      value: function _onOverlayPositioned(event) {
        // stops propagation cause the event is internal to the component
        event.stopImmediatePropagation();

        if (this._elements.overlay.open) {
          this._elements.overlay.style.width = "".concat(this.offsetWidth, "px");
        }
      } // @todo: while the select is multiple, if everything is deselected no change event will be triggered.

    }, {
      key: "_onNativeSelectChange",
      value: function _onNativeSelectChange(event) {
        // stops propagation cause the event is internal to the component
        event.stopImmediatePropagation(); // avoids triggering unnecessary changes in the selectist because selecting items programatically will trigger
        // a change event

        if (this._bulkSelectionChange) {
          return;
        }

        this._bulkSelectionChange = true; // extracts the native options for the selected items. We use the selected options, instead of the complete
        // options to make the diff since it will normally be a smaller set

        var oldSelectedOptions = this.selectedItems.map(function (element) {
          return element._nativeOption;
        }); // we convert the HTMLCollection to an array

        var selectedOptions = Array.prototype.slice.call(event.target.querySelectorAll(':checked'));
        var diff = arrayDiff(oldSelectedOptions, selectedOptions);
        diff.forEach(function (item) {
          item._selectItem.selected = false;
        }); // we only sync the items that changed

        var newSelection = arrayDiff(selectedOptions, oldSelectedOptions);
        newSelection.forEach(function (item) {
          item._selectItem.selected = true;
        });
        this._bulkSelectionChange = false; // since multiple keeps the select open, we cannot return the focus to the button otherwise the user cannot
        // continue selecting values

        if (!this.multiple) {
          // returns the focus to the button, otherwise the select will keep it
          this._elements.button.focus(); // since selecting an item closes the native select, we need to trigger an event


          this.trigger('coral-select:hideitems');
        } // if the native change event was triggered, then it means there is some new value


        this.trigger('change');
      }
      /**
       This handles content change of coral-select-item and updates its associatives.
        @private
       */

    }, {
      key: "_onItemContentChange",
      value: function _onItemContentChange(event) {
        // stops propagation cause the event is internal to the component
        event.stopImmediatePropagation();
        var item = event.target;

        if (item._selectListItem) {
          var content = new SelectList.Item.Content();
          content.innerHTML = item.innerHTML;
          item._selectListItem.content = content;
        }

        if (item._nativeOption) {
          item._nativeOption.innerHTML = item.innerHTML;
        }

        if (item._tag && item._tag.label) {
          item._tag.label.innerHTML = item.innerHTML;
        } // since the content changed, we need to sync the placeholder in case it was the selected item


        this._syncSelectedItemPlaceholder();
      }
      /** @private */

    }, {
      key: "_syncSelectedItemPlaceholder",
      value: function _syncSelectedItemPlaceholder() {
        this.placeholder = this.getAttribute('placeholder'); // case 3: !p + !m +  se = se
        // case 5:  p + !m +  se = se

        if (this.selectedItem && !this.multiple) {
          this._elements.label.classList.remove('is-placeholder');

          this._elements.label.innerHTML = this.selectedItem.innerHTML;
        }
      }
      /**
       This handles value change of coral-select-item and updates its associatives.
        @private
       */

    }, {
      key: "_onItemValueChange",
      value: function _onItemValueChange(event) {
        // stops propagation cause the event is internal to the component
        event.stopImmediatePropagation();
        var item = event.target;

        if (item._selectListItem) {
          item._selectListItem.value = item.value;
        }

        if (item._nativeOption) {
          item._nativeOption.value = item.value;
        }

        if (item._tag) {
          item._tag.value = item.value;
        }
      }
      /**
       This handles disabled change of coral-select-item and updates its associatives.
        @private
       */

    }, {
      key: "_onItemDisabledChange",
      value: function _onItemDisabledChange(event) {
        // stops propagation cause the event is internal to the component
        event.stopImmediatePropagation();
        var item = event.target;

        if (item._selectListItem) {
          item._selectListItem.disabled = item.disabled;
        }

        if (item._nativeOption) {
          item._nativeOption.disabled = item.disabled;
        }
      }
      /**
       In case an item from the initial selection is removed, we need to remove it from the initial values.
        @private
       */

    }, {
      key: "_validateInitialState",
      value: function _validateInitialState(nodes) {
        var item;
        var index; // we iterate over all the nodes, checking if they matched the initial value

        for (var i = 0, nodeCount = nodes.length; i < nodeCount; i++) {
          // since we are not sure if the item has been upgraded, we try first the attribute, otherwise we extract the
          // value from the textContent
          item = nodes[i];
          index = this._initialValues.indexOf(item.value);

          if (index !== -1) {
            this._initialValues.splice(index, 1);
          }
        }
      }
      /** @private */
      // eslint-disable-next-line no-unused-vars

    }, {
      key: "_onCollectionChange",
      value: function _onCollectionChange(addedNodes, removedNodes) {
        // we make sure that items that were part of the initial selection are removed from the internal representation
        this._validateInitialState(removedNodes); // makes sure that the selection state matches the multiple variable


        this._setStateFromDOM();
      }
      /**
       Updates the label to reflect the current state. The label needs to be updated when the placeholder changes and
       when the selection changes.
        @private
       */

    }, {
      key: "_updateLabel",
      value: function _updateLabel() {
        this._syncSelectedItemPlaceholder();
      }
      /**
       Handles the selection state.
        @ignore
       */

    }, {
      key: "_setStateFromDOM",
      value: function _setStateFromDOM() {
        // if it is not multiple, we need to be sure only one item is selected
        if (!this.hasAttribute('multiple')) {
          // makes sure that only one is selected
          this.items._deselectAllExceptLast(); // we execute _getFirstSelected instead of _getSelected because it is faster


          var selectedItem = this.items._getFirstSelected(); // case 1. there is a selected item, so no further change is required
          // case 2. no selected item and no placeholder. an item will be automatically selected
          // case 3. no selected item and a placehoder. we just make sure the value is really empty


          if (!selectedItem) {
            // we clean the value because there is no selected item
            this._elements.input.value = ''; // when there is no placeholder, we need to force a selection to behave like the native select

            if (transform.string(this.getAttribute('placeholder')) === '') {
              // gets the first candidate for selection
              var selectable = this.items._getFirstSelectable();

              if (selectable) {
                // selects using the attribute in case the item is not yet initialized
                selectable.setAttribute('selected', ''); // we set the value explicitely, so we do not need to wait for the MO

                this._elements.input.value = itemValueFromDOM$1(selectable);
              }
            }
          } else {
            // we set the value explicitely, so we do not need to wait for the MO
            this._elements.input.value = itemValueFromDOM$1(selectedItem);
          }
        } // handles the initial item in the select


        this._updateLabel();
      }
      /**
       Handles selecting multiple items. Selection could result a single or multiple selected items.
        @private
       */

    }, {
      key: "_onItemSelectedChange",
      value: function _onItemSelectedChange(event) {
        // we stop propagation since it is a private event
        event.stopImmediatePropagation(); // the item that was selected

        var item = event.target; // setting this to true will ignore any changes from the selectlist al

        this._bulkSelectionChange = true; // when the item is selected, we need to enforce the selection mode

        if (item.selected) {
          this._onItemSelected(item);

          if (this.multiple) {
            this._trackEvent('select', 'coral-select-item', event, item);
          } // enforces the selection mode


          if (!this.hasAttribute('multiple')) {
            this.items._deselectAllExcept(item);
          }
        } else {
          this._onItemDeselected(item);

          if (this.multiple) {
            this._trackEvent('deselect', 'coral-select-item', event, item);
          }
        }

        this._bulkSelectionChange = false; // since there is a change in selection, we need to update the placeholder

        this._updateLabel();
      }
      /**
       Inherited from {@link BaseFormField#clear}.
       */

    }, {
      key: "clear",
      value: function clear() {
        this.value = '';
      }
      /**
       Focuses the component.
        @ignore
       */

    }, {
      key: "focus",
      value: function focus() {
        if (!this.contains(document.activeElement)) {
          this._elements.button.focus();
        }
      }
      /**
       Inherited from {@link BaseFormField#reset}.
       */

    }, {
      key: "reset",
      value: function reset() {
        // reset the values to the initial values
        this.values = this._initialValues;
      }
      /**
       Returns {@link Select} variants.
        @return {SelectVariantEnum}
       */

    }, {
      key: "connectedCallback",

      /** @ignore */
      value: function connectedCallback() {
        _get(_getPrototypeOf(Select.prototype), "connectedCallback", this).call(this);

        var overlay = this._elements.overlay; // Cannot be open by default when rendered

        overlay.removeAttribute('open'); // Restore in DOM

        if (overlay._parent) {
          overlay._parent.appendChild(overlay);
        }
      }
      /** @ignore */

    }, {
      key: "render",
      value: function render() {
        var _this3 = this;

        _get(_getPrototypeOf(Select.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$l); // Default reflected attributes

        if (!this._variant) {
          this.variant = variant$6.DEFAULT;
        }

        this.classList.toggle("".concat(CLASSNAME$l, "--native"), this._useNativeInput);

        if (!this._useNativeInput && this.contains(this._elements.nativeSelect)) {
          this.removeChild(this._elements.nativeSelect);
        } // handles the initial selection


        this._setStateFromDOM(); // we need to keep a state of the initial items to be able to reset the component. values is not reliable during
        // initialization since items are not yet initialized


        this.selectedItems.forEach(function (item) {
          // we use DOM API instead of properties in case the item is not yet initialized
          _this3._initialValues.push(itemValueFromDOM$1(item));
        }); // Cleanup template elements (supporting cloneNode)

        var templateElements = this.querySelectorAll('[handle]');

        for (var i = 0; i < templateElements.length; ++i) {
          var currentElement = templateElements[i];

          if (currentElement.parentNode === this) {
            this.removeChild(currentElement);
          }
        } // Render the main template


        var frag = document.createDocumentFragment();
        frag.appendChild(this._elements.button);
        frag.appendChild(this._elements.input);
        frag.appendChild(this._elements.nativeSelect);
        frag.appendChild(this._elements.taglist);
        frag.appendChild(this._elements.overlay); // Assign the button as the target for the overlay

        this._elements.overlay.target = this._elements.button; // handles the focus allocation every time the overlay closes

        this._elements.overlay.returnFocusTo(this._elements.button);

        this.appendChild(frag);
      }
      /** @ignore */

    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        _get(_getPrototypeOf(Select.prototype), "disconnectedCallback", this).call(this);

        var overlay = this._elements.overlay; // In case it was moved out don't forget to remove it

        if (!this.contains(overlay)) {
          overlay._parent = overlay._repositioned ? document.body : this;
          overlay.remove();
        }
      }
      /**
       Triggered when the {@link Select} could accept external data to be loaded by the user. If <code>preventDefault()</code> is
       called, then a loading indicator will be shown. {@link Select#loading} should be set to false to indicate
       that the data has been successfully loaded.
        @typedef {CustomEvent} coral-select:showitems
        @property {Number} detail.start
       The count of existing items, which is the index where new items should start.
       */

      /**
       Triggered when the {@link Select} hides the UI used to select items. This is typically used to cancel a load request
       because the items will not be shown anymore.
        @typedef {CustomEvent} coral-select:hideitems
       */

    }, {
      key: "overlay",
      get: function get() {
        return this._elements.overlay;
      }
      /**
       The item collection.
        @type {SelectableCollection}
       @readonly
       */

    }, {
      key: "items",
      get: function get() {
        // we do lazy initialization of the collection
        if (!this._items) {
          this._items = new SelectableCollection({
            host: this,
            itemTagName: 'coral-select-item',
            onItemAdded: this._onItemAdded,
            onItemRemoved: this._onItemRemoved,
            onCollectionChange: this._onCollectionChange
          });
        }

        return this._items;
      }
      /**
       Indicates whether the select accepts multiple selected values.
        @type {Boolean}
       @default false
       @htmlattribute multiple
       @htmlattributereflected
       */

    }, {
      key: "multiple",
      get: function get() {
        return this._multiple || false;
      },
      set: function set(value) {
        var _this4 = this;

        this._multiple = transform.booleanAttr(value);

        this._reflectAttribute('multiple', this._multiple); // taglist should not be in DOM if multiple === false


        if (!this._multiple) {
          this.removeChild(this._elements.taglist);
        } else {
          this.appendChild(this._elements.taglist);
        } // we need to remove and re-add the native select to loose the selection


        if (this._nativeInput) {
          this.removeChild(this._elements.nativeSelect);
        }

        this._elements.nativeSelect.multiple = this._multiple;
        this._elements.nativeSelect.selectedIndex = -1;

        if (this._nativeInput) {
          if (this._multiple) {
            // We might not be rendered yet
            if (this._elements.nativeSelect.parentNode) {
              this.insertBefore(this._elements.nativeSelect, this._elements.taglist);
            }
          } else {
            this.appendChild(this._elements.nativeSelect);
          }
        }

        this._elements.list.multiple = this._multiple; // sets the correct name for value submission

        this._setName(this.getAttribute('name') || ''); // we need to make sure the selection is valid


        this._setStateFromDOM(); // everytime multiple changes, the state of the selectlist and taglist need to be updated


        this.items.getAll().forEach(function (item) {
          if (_this4._multiple && item.hasAttribute('selected')) {
            _this4._addTagToTagList(item);
          } else {
            // taglist is never used for multiple = false
            _this4._removeTagFromTagList(item); // when multiple = false and the item is selected, the value needs to be updated in the input


            if (item.hasAttribute('selected')) {
              _this4._elements.input.value = itemValueFromDOM$1(item);
            }
          }
        });
      }
      /**
       Contains a hint to the user of what can be selected in the component. If no placeholder is provided, the first
       option will be displayed in the component.
        @type {String}
       @default ""
       @htmlattribute placeholder
       @htmlattributereflected
       */
      // p = placeholder, m = multiple, se = selected
      // case 1:  p +  m +  se = p
      // case 2:  p +  m + !se = p
      // case 3: !p + !m +  se = se
      // case 4: !p + !m + !se = firstSelectable (native behavior)
      // case 5:  p + !m +  se = se
      // case 6:  p + !m + !se = p
      // case 7: !p +  m +  se = 'Select'
      // case 8: !p +  m + !se = 'Select'

    }, {
      key: "placeholder",
      get: function get() {
        return this._placeholder || '';
      },
      set: function set(value) {
        this._placeholder = transform.string(value);

        this._reflectAttribute('placeholder', this._placeholder); // case 1:  p +  m +  se = p
        // case 2:  p +  m + !se = p
        // case 6:  p + !m + !se = p


        if (this._placeholder && (this.hasAttribute('multiple') || !this.selectedItem)) {
          this._elements.label.classList.add('is-placeholder');

          this._elements.label.textContent = this._placeholder;
        } // case 7: !p +  m +  se = 'Select'
        // case 8: !p +  m + !se = 'Select'
        else if (this.hasAttribute('multiple')) {
            this._elements.label.classList.add('is-placeholder');

            this._elements.label.textContent = i18n.get('Select');
          } // case 4: !p + !m + !se = firstSelectable (native behavior)
          else if (!this.selectedItem) {
              // we clean the value because there is no selected item
              this._elements.input.value = ''; // gets the first candidate for selection

              var placeholderItem = this.items._getFirstSelectable();

              this._elements.label.classList.remove('is-placeholder');

              if (placeholderItem) {
                // selects using the attribute in case the item is not yet initialized
                placeholderItem.setAttribute('selected', '');
                this._elements.label.innerHTML = placeholderItem.innerHTML;
              } else {
                // label must be cleared when there is no placeholder and no item to select
                this._elements.label.textContent = '';
              }
            }
      }
      /**
       Name used to submit the data in a form.
       @type {String}
       @default ""
       @htmlattribute name
       @htmlattributereflected
       */

    }, {
      key: "name",
      get: function get() {
        return this.multiple ? this._elements.taglist.name : this._elements.input.name;
      },
      set: function set(value) {
        this._setName(value);

        this._reflectAttribute('name', this.name);
      }
      /**
       This field's current value.
       @type {String}
       @default ""
       @htmlattribute value
       */

    }, {
      key: "value",
      get: function get() {
        // we leverage the internal elements to know the value, this way we are always sure that the server submission
        // will be correct
        return this.multiple ? this._elements.taglist.value : this._elements.input.value;
      },
      set: function set(value) {
        // we rely on the the values property to handle this correctly
        this.values = [value];
      }
      /**
       The current selected values, as submitted during form submission. When {@link Coral.Select#multiple} is
       <code>false</code>, this will be an array of length 1.
        @type {Array.<String>}
       */

    }, {
      key: "values",
      get: function get() {
        if (this.multiple) {
          return this._elements.taglist.values;
        } // if there is a selection, we return whatever value it has assigned


        return this.selectedItem ? [this._elements.input.value] : [];
      },
      set: function set(values) {
        if (Array.isArray(values)) {
          // when multiple = false, we explicitely ignore the other values and just set the first one
          if (!this.multiple && values.length > 1) {
            values = [values[0]];
          } // gets all the items


          var items = this.items.getAll();
          var itemValue; // if multiple, we need to explicitely set the selection state of every item

          if (this.multiple) {
            items.forEach(function (item) {
              // we use DOM API instead of properties in case the item is not yet initialized
              itemValue = itemValueFromDOM$1(item); // if the value is located inside the values array, then we set the item as selected

              item[values.indexOf(itemValue) !== -1 ? 'setAttribute' : 'removeAttribute']('selected', '');
            });
          } // if single selection, we find the first item that matches the value and deselect everything else. in case,
          // no item matches the value, we may need to find a selection candidate
          else {
              var targetItem; // since multiple = false, there is only 1 value value

              var value = values[0] || '';
              items.forEach(function (item) {
                // small optimization to avoid calculating the value from every item
                if (!targetItem) {
                  itemValue = itemValueFromDOM$1(item);

                  if (itemValue === value) {
                    // selecting the item will cause the taglist or input to be updated
                    item.setAttribute('selected', ''); // we store the first ocurrence, afterwards we deselect all items

                    targetItem = item; // since we found our target item, we continue to avoid removing the selected attribute

                    return;
                  }
                } // every-non targetItem must be deselected


                item.removeAttribute('selected');
              }); // if no targetItem was found, _setStateFromDOM will make sure that the state is valid

              if (!targetItem) {
                this._setStateFromDOM();
              }
            }
        }
      }
      /**
       Whether this field is disabled or not.
       @type {Boolean}
       @default false
       @htmlattribute disabled
       @htmlattributereflected
       */

    }, {
      key: "disabled",
      get: function get() {
        return this._disabled || false;
      },
      set: function set(value) {
        this._disabled = transform.booleanAttr(value);

        this._reflectAttribute('disabled', this._disabled);

        this[this._disabled ? 'setAttribute' : 'removeAttribute']('aria-disabled', this._disabled);
        this.classList.toggle('is-disabled', this._disabled);
        this._elements.button.disabled = this._disabled;
        this._elements.input.disabled = this._disabled;
        this._elements.taglist.disabled = this._disabled;
      }
      /**
       Inherited from {@link BaseFormField#invalid}.
       */

    }, {
      key: "invalid",
      get: function get() {
        return _get(_getPrototypeOf(Select.prototype), "invalid", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(Select.prototype), "invalid", value, this, true);

        this.classList.toggle('is-invalid', this.invalid);

        this._elements.button.classList.toggle('is-invalid', this.invalid);

        this._elements.invalidIcon.hidden = !this.invalid;
      }
      /**
       Whether this field is required or not.
       @type {Boolean}
       @default false
       @htmlattribute required
       @htmlattributereflected
       */

    }, {
      key: "required",
      get: function get() {
        return this._required || false;
      },
      set: function set(value) {
        this._required = transform.booleanAttr(value);

        this._reflectAttribute('required', this._required);

        this._elements.input.required = this._required;
        this._elements.taglist.required = this._required;
      }
      /**
       Whether this field is readOnly or not. Indicating that the user cannot modify the value of the control.
       @type {Boolean}
       @default false
       @htmlattribute readonly
       @htmlattributereflected
       */

    }, {
      key: "readOnly",
      get: function get() {
        return this._readOnly || false;
      },
      set: function set(value) {
        this._readOnly = transform.booleanAttr(value);

        this._reflectAttribute('readonly', this._readOnly);

        this._elements.input.readOnly = this._readOnly;
        this._elements.taglist.readOnly = this._readOnly;
        this._elements.taglist.disabled = this._readOnly;
      }
      /**
       Inherited from {@link BaseFormField#labelled}.
       */

    }, {
      key: "labelled",
      get: function get() {
        return _get(_getPrototypeOf(Select.prototype), "labelled", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(Select.prototype), "labelled", value, this, true);

        if (this.labelled) {
          if (!this.labelledBy) {
            this._elements.button.setAttribute('aria-labelledby', "".concat(this._elements.button.id, " ").concat(this._elements.label.id, " ").concat(this.invalid ? this._elements.invalidIcon.id : ''));
          }

          this._elements.nativeSelect.setAttribute('aria-label', value);
        } else {
          this._elements.button.removeAttribute('aria-label');

          this._elements.nativeSelect.removeAttribute('aria-label');

          if (!this.labelledBy) {
            this._elements.button.removeAttribute('aria-labelledby');
          }
        }

        this._elements.taglist.labelled = value;
      }
      /**
       Inherited from {@link BaseFormField#labelledBy}.
       */

    }, {
      key: "labelledBy",
      get: function get() {
        return this._labelledBy;
      },
      set: function set(value) {
        _set(_getPrototypeOf(Select.prototype), "labelledBy", value, this, true);

        this._labelledBy = _get(_getPrototypeOf(Select.prototype), "labelledBy", this);

        if (this._labelledBy) {
          this._elements.button.setAttribute('aria-labelledby', "".concat(this._labelledBy, " ").concat(this._elements.label.id, " ").concat(this.invalid ? this._elements.invalidIcon.id : ''));

          this._elements.nativeSelect.setAttribute('aria-labelledby', this._labelledBy);
        } else {
          this._elements.nativeSelect.removeAttribute('aria-labelledby'); // if the select is also labelled, make sure that aria-labelledby gets restored


          if (this.labelled) {
            this.labelled = this.labelled;
          }
        }

        this._elements.taglist.labelledBy = this._labelledBy;
      }
      /**
       Returns the first selected item in the Select. The value <code>null</code> is returned if no element is
       selected.
        @type {?HTMLElement}
       @readonly
       */

    }, {
      key: "selectedItem",
      get: function get() {
        return this.hasAttribute('multiple') ? this.items._getFirstSelected() : this.items._getLastSelected();
      }
      /**
       Returns an Array containing the set selected items.
        @type {Array.<HTMLElement>}
       @readonly
       */

    }, {
      key: "selectedItems",
      get: function get() {
        if (this.hasAttribute('multiple')) {
          return this.items._getAllSelected();
        }

        var item = this.selectedItem;
        return item ? [item] : [];
      }
      /**
       Indicates that the Select is currently loading remote data. This will set the wait indicator inside the list.
        @type {Boolean}
       @default false
       @htmlattribute loading
       */

    }, {
      key: "loading",
      get: function get() {
        return this._elements.list.loading;
      },
      set: function set(value) {
        this._elements.list.loading = value;
      }
      /**
       The Select's variant. See {@link SelectVariantEnum}.
        @type {SelectVariantEnum}
       @default SelectVariantEnum.DEFAULT
       @htmlattribute variant
       @htmlattributereflected
       */

    }, {
      key: "variant",
      get: function get() {
        return this._variant || variant$6.DEFAULT;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        this._variant = validate.enumeration(variant$6)(value) && value || variant$6.DEFAULT;

        this._reflectAttribute('variant', this._variant);

        this._elements.button.classList.toggle('_coral-FieldButton--quiet', this._variant === variant$6.QUIET);
      }
    }], [{
      key: "variant",
      get: function get() {
        return variant$6;
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(Select), "observedAttributes", this).concat(['variant', 'multiple', 'placeholder', 'loading']);
      }
    }]);

    return Select;
  }(BaseFormField(BaseComponent(HTMLElement)));

  /**
   @class Coral.Select.Item
   @classdesc A Select item component
   @htmltag coral-select-item
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var SelectItem = /*#__PURE__*/function (_BaseComponent) {
    _inherits(SelectItem, _BaseComponent);

    var _super = _createSuper(SelectItem);

    /** @ignore */
    function SelectItem() {
      var _this;

      _classCallCheck(this, SelectItem);

      _this = _super.call(this);
      _this._observer = new MutationObserver(_this._handleMutation.bind(_assertThisInitialized(_this)));

      _this._observer.observe(_assertThisInitialized(_this), {
        characterData: true,
        childList: true,
        subtree: true
      });

      return _this;
    } // @compat


    _createClass(SelectItem, [{
      key: "_handleMutation",

      /** @private */
      value: function _handleMutation() {
        this.trigger('coral-select-item:_contentchanged', {
          content: this.textContent
        });
      }
      /** @ignore */

    }, {
      key: "content",
      get: function get() {
        return this;
      },
      set: function set(value) {
        // Support configs
        if (_typeof(value) === 'object') {
          for (var prop in value) {
            /** @ignore */
            this[prop] = value[prop];
          }
        }
      }
      /**
       Whether this item is disabled. When set to <code>true</code>, this will prevent every user interaction with the
       item. If disabled is set to <code>true</code> for a selected item it will be deselected.
        @type {Boolean}
       @default false
       @htmlattribute disabled
       @htmlattributereflected
       */

    }, {
      key: "disabled",
      get: function get() {
        return this._disabled || false;
      },
      set: function set(value) {
        this._disabled = transform.booleanAttr(value);

        this._reflectAttribute('disabled', this._disabled);

        this.trigger('coral-select-item:_disabledchanged');
      }
      /**
       Whether the item is selected. Selected cannot be set to <code>true</code> if the item is disabled.
        @type {Boolean}
       @default false
       @htmlattribute selected
       @htmlattributereflected
       */

    }, {
      key: "selected",
      get: function get() {
        return this._selected || false;
      },
      set: function set(value) {
        var _selected = transform.booleanAttr(value);

        if (this._selected === _selected) {
          return;
        }

        this._selected = _selected;

        this._reflectAttribute('selected', this._selected);

        this.trigger('coral-select-item:_selectedchanged');
      }
      /**
       Value of the item. If not explicitly set, the value of <code>Node.textContent</code> is returned.
        @type {String}
       @default ""
       @htmlattribute value
       @htmlattributereflected
       */

    }, {
      key: "value",
      get: function get() {
        var val = this._value;

        if (typeof this._value === 'undefined') {
          if (this.getAttribute('value') === null) {
            // keep spaces to only 1 max and trim to mimic native select option behavior
            val = this.textContent.replace(/\s{2,}/g, ' ').trim();
          } else {
            val = this.getAttribute('value');
          }
        }

        return val;
      },
      set: function set(value) {
        var _value = transform.string(value);

        if (this._value === _value) {
          return;
        }

        this._value = _value;

        this._reflectAttribute('value', this._value);

        this.trigger('coral-select-item:_valuechanged');
      }
      /**
       Inherited from {@link BaseComponent#trackingElement}.
       */

    }, {
      key: "trackingElement",
      get: function get() {
        return typeof this._trackingElement === 'undefined' ? // keep spaces to only 1 max and trim. this mimics native html behaviors
        this.value || this.textContent.replace(/\s{2,}/g, ' ').trim() : this._trackingElement;
      },
      set: function set(value) {
        _set(_getPrototypeOf(SelectItem.prototype), "trackingElement", value, this, true);
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(SelectItem), "observedAttributes", this).concat(['selected', 'disabled', 'value']);
      }
    }]);

    return SelectItem;
  }(BaseComponent(HTMLElement));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons.extend(strings, {
    'coral-component-select': translations$1
  }); // Expose component on the Coral namespace

  commons._define('coral-select-item', SelectItem);

  commons._define('coral-select', Select);

  Select.Item = SelectItem;

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var translations$6 = {
    "en-US": {
      "Select": "Select"
    },
    "fr-FR": {
      "Select": "SÃ©lectionner"
    },
    "de-DE": {
      "Select": "AuswÃ¤hlen"
    },
    "it-IT": {
      "Select": "Seleziona"
    },
    "es-ES": {
      "Select": "Seleccionar"
    },
    "pt-BR": {
      "Select": "Selecionar"
    },
    "ja-JP": {
      "Select": "é¸æ"
    },
    "ko-KR": {
      "Select": "ì í"
    },
    "zh-CN": {
      "Select": "éæ©"
    },
    "zh-TW": {
      "Select": "é¸å"
    },
    "nl-NL": {
      "Select": "Selecteren"
    },
    "da-DK": {
      "Select": "VÃ¦lg"
    },
    "fi-FI": {
      "Select": "Valitse"
    },
    "nb-NO": {
      "Select": "Velg"
    },
    "sv-SE": {
      "Select": "VÃ¤lj"
    },
    "cs-CZ": {
      "Select": "Vybrat"
    },
    "pl-PL": {
      "Select": "Wybierz"
    },
    "ru-RU": {
      "Select": "ÐÑÐ±ÐµÑÐ¸ÑÐµ"
    },
    "tr-TR": {
      "Select": "SeÃ§"
    }
  };

  var template$8 = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["input"] = document.createElement("input");
    el0.setAttribute("type", "radio");
    el0.setAttribute("handle", "input");
    el0.className += " _coral-Radio-input";
    el0.id = data_0["commons"]["getUID"]();
    frag.appendChild(el0);
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    var el2 = this["checkmark"] = document.createElement("span");
    el2.className += " _coral-Radio-button";
    el2.setAttribute("handle", "checkmark");
    frag.appendChild(el2);
    var el3 = document.createTextNode("\n");
    frag.appendChild(el3);
    var el4 = this["labelWrapper"] = document.createElement("label");
    el4.className += " _coral-Radio-label";
    el4.setAttribute("handle", "labelWrapper");
    el4.setAttribute("for", this["input"]["id"]);
    var el5 = document.createTextNode("\n  ");
    el4.appendChild(el5);
    var el6 = this["screenReaderOnly"] = document.createElement("span");
    el6.className += " u-coral-screenReaderOnly";
    el6.setAttribute("handle", "screenReaderOnly");
    el6.textContent = data_0["i18n"]["get"]('Select');
    el4.appendChild(el6);
    var el7 = document.createTextNode("\n");
    el4.appendChild(el7);
    frag.appendChild(el4);
    var el8 = document.createTextNode("\n");
    frag.appendChild(el8);
    return frag;
  };

  var CLASSNAME$m = '_coral-Radio';
  /**
   @class Coral.Radio
   @classdesc A Radio component to be used as a form field.
   @htmltag coral-radio
   @extends {HTMLElement}
   @extends {BaseComponent}
   @extends {BaseFormField}
   */

  var Radio = /*#__PURE__*/function (_BaseFormField) {
    _inherits(Radio, _BaseFormField);

    var _super = _createSuper(Radio);

    /** @ignore */
    function Radio() {
      var _this;

      _classCallCheck(this, Radio);

      _this = _super.call(this);

      _this._delegateEvents(commons.extend(_this._events, {
        click: '_onClick',
        mousedown: '_onMouseDown'
      })); // Prepare templates


      _this._elements = {
        // Try to find the label content zone
        label: _this.querySelector('coral-radio-label') || document.createElement('coral-radio-label')
      };
      template$8.call(_this._elements, {
        commons: commons,
        i18n: i18n
      }); // Pre-define labellable element

      _this._labellableElement = _this._elements.input; // Check if the label is empty whenever we get a mutation

      _this._observer = new MutationObserver(_this._hideLabelIfEmpty.bind(_assertThisInitialized(_this))); // Watch for changes to the label element's children

      _this._observer.observe(_this._elements.labelWrapper, {
        // Catch changes to childList
        childList: true,
        // Catch changes to textContent
        characterData: true,
        // Monitor any child node
        subtree: true
      });

      return _this;
    }
    /**
     Checked state for the radio, <code>true</code> is checked and <code>false</code> is unchecked.
      @type {Boolean}
     @default false
     @htmlattribute checked
     @htmlattributereflected
     @emits {change}
     */


    _createClass(Radio, [{
      key: "_syncRelatedRadios",

      /**
       Takes care of keeping the checked property up to date, by unchecking every radio that has the same name. This is
       only done if the radio is already in the DOM, it has a name and it is checked, otherwise this is not needed.
        @ignore
       */
      value: function _syncRelatedRadios() {
        // if the radio has a name defined and it is checked, we need to ensure that other radios that share the name
        // are not checked.
        if (this.parentNode !== null && this.name && this.checked) {
          // queries the document for all the coral-radios with the same name
          var items = document.querySelectorAll("".concat(this.tagName, "[name=").concat(JSON.stringify(this.name), "]"));
          var itemCount = items.length;

          for (var i = 0; i < itemCount; i++) {
            if (items[i] !== this) {
              // we uncheck all other radios with the same name
              items[i].removeAttribute('checked');
            }
          }
        }
      }
      /**
       Hide the label if it's empty.
        @ignore
       */

    }, {
      key: "_hideLabelIfEmpty",
      value: function _hideLabelIfEmpty() {
        var label = this._elements.label; // If it's empty and has no non-textnode children, hide the label

        var hiddenValue = !(label.children.length === 0 && label.textContent.replace(/\s*/g, '') === ''); // Toggle the screen reader text

        this._elements.labelWrapper.style.margin = !hiddenValue ? '0' : '';
        this._elements.screenReaderOnly.hidden = hiddenValue || this.labelled;
      }
      /**
       @private
       */

    }, {
      key: "_onClick",
      value: function _onClick(event) {
        // Handle the click() just like the native radio
        if (!this.checked) {
          if (event.target === this) {
            this.checked = true;
            this.trigger('change');
          }

          this._trackEvent('checked', 'coral-radio', event);
        }
      }
      /**
       Forces radio to receive focus on mousedown
       @ignore
       */

    }, {
      key: "_onMouseDown",
      value: function _onMouseDown() {
        var target = this._elements.input;
        requestAnimationFrame(function () {
          if (target !== document.activeElement) {
            target.focus();
          }
        });
      }
      /**
       Inherited from {@link BaseFormField#clear}.
       */

    }, {
      key: "clear",
      value: function clear() {
        this.checked = false;
      }
      /**
       Inherited from {@link BaseFormField#reset}.
       */

    }, {
      key: "reset",
      value: function reset() {
        this.checked = this._initialCheckedState;
      }
    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(Radio.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$m); // Create a fragment

        var frag = document.createDocumentFragment();
        var templateHandleNames = ['input', 'checkmark', 'labelWrapper']; // Render the main template

        frag.appendChild(this._elements.input);
        frag.appendChild(this._elements.checkmark);
        frag.appendChild(this._elements.labelWrapper);
        var label = this._elements.label; // Remove it so we can process children

        if (label && label.parentNode) {
          label.parentNode.removeChild(label);
        }

        while (this.firstChild) {
          var child = this.firstChild;

          if (child.nodeType === Node.TEXT_NODE || child.nodeType === Node.ELEMENT_NODE && templateHandleNames.indexOf(child.getAttribute('handle')) === -1) {
            // Add non-template elements to the label
            label.appendChild(child);
          } else {
            // Remove anything else (e.g labelWrapper)
            this.removeChild(child);
          }
        } // Add the frag to the component


        this.appendChild(frag); // Assign the content zones, moving them into place in the process

        this.label = label; // Cache the initial checked state of the radio button (in order to implement reset)

        this._initialCheckedState = this.checked; // handles the case where the attached component was checked

        this._syncRelatedRadios(); // Check if we need to hide the label
        // We must do this because IE does not catch mutations when nodes are not in the DOM


        this._hideLabelIfEmpty();
      }
    }, {
      key: "checked",
      get: function get() {
        return this._checked || false;
      },
      set: function set(value) {
        this._checked = transform.booleanAttr(value);

        this._reflectAttribute('checked', this._checked);

        this._elements.input.checked = this._checked; // handles related radios

        this._syncRelatedRadios();
      }
      /**
       The radios's label element.
        @type {RadioLabel}
       @contentzone
       */

    }, {
      key: "label",
      get: function get() {
        return this._getContentZone(this._elements.label);
      },
      set: function set(value) {
        this._setContentZone('label', value, {
          handle: 'label',
          tagName: 'coral-radio-label',
          insert: function insert(label) {
            this._elements.labelWrapper.appendChild(label);
          }
        });
      }
      /**
       Name used to submit the data in a form.
       @type {String}
       @default ""
       @htmlattribute name
       @htmlattributereflected
       */

    }, {
      key: "name",
      get: function get() {
        return this._elements.input.name;
      },
      set: function set(value) {
        this._reflectAttribute('name', value);

        this._elements.input.name = value;
      }
      /**
       The value this radio should submit when checked. Changing this value will not trigger an event.
        @type {String}
       @default "on"
       @htmlattribute value
       */

    }, {
      key: "value",
      get: function get() {
        return this._elements.input.value || 'on';
      },
      set: function set(value) {
        this._elements.input.value = value;
      }
      /**
       Whether this field is disabled or not.
       @type {Boolean}
       @default false
       @htmlattribute disabled
       @htmlattributereflected
       */

    }, {
      key: "disabled",
      get: function get() {
        return this._disabled || false;
      },
      set: function set(value) {
        this._disabled = transform.booleanAttr(value);

        this._reflectAttribute('disabled', this._disabled);

        this[this._disabled ? 'setAttribute' : 'removeAttribute']('aria-disabled', this._disabled);
        this.classList.toggle('is-disabled', this._disabled);
        this._elements.input.disabled = this._disabled;
      }
      /**
       Whether this field is required or not.
       @type {Boolean}
       @default false
       @htmlattribute required
       @htmlattributereflected
       */

    }, {
      key: "required",
      get: function get() {
        return this._required || false;
      },
      set: function set(value) {
        this._required = transform.booleanAttr(value);

        this._reflectAttribute('required', this._required);

        this._elements.input.required = this._required;
      }
      /**
       Whether this field is readOnly or not. Indicating that the user cannot modify the value of the control.
       @type {Boolean}
       @default false
       @htmlattribute readonly
       @htmlattributereflected
       */

    }, {
      key: "readOnly",
      get: function get() {
        return this._readOnly || false;
      },
      set: function set(value) {
        this._readOnly = transform.booleanAttr(value);

        this._reflectAttribute('readonly', this._readOnly);

        this.classList.toggle('is-readOnly', this._readOnly);
        this._elements.input.tabIndex = this._readOnly ? -1 : 0;
      }
      /**
       Inherited from {@link BaseFormField#labelled}.
       */

    }, {
      key: "labelled",
      get: function get() {
        return _get(_getPrototypeOf(Radio.prototype), "labelled", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(Radio.prototype), "labelled", value, this, true);

        this._hideLabelIfEmpty();
      }
      /**
       Inherited from {@link BaseComponent#trackingElement}.
       */

    }, {
      key: "trackingElement",
      get: function get() {
        // it uses the name as the first fallback since it is not localized, otherwise it uses the label
        return typeof this._trackingElement === 'undefined' ? // keep spaces to only 1 max and trim. this mimics native html behaviors
        (this.name ? "".concat(this.name, "=").concat(this.value) : '') || (this.label || this).textContent.replace(/\s{2,}/g, ' ').trim() : this._trackingElement;
      },
      set: function set(value) {
        _set(_getPrototypeOf(Radio.prototype), "trackingElement", value, this, true);
      }
      /*
       Indicates to the formField that the 'checked' property needs to be set in this component.
        @protected
       */

    }, {
      key: "_componentTargetProperty",
      get: function get() {
        return 'checked';
      }
      /*
       Indicates to the formField that the 'checked' property has to be extracted from the event.
        @protected
       */

    }, {
      key: "_eventTargetProperty",
      get: function get() {
        return 'checked';
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-radio-label': 'label'
        };
      }
      /** @ignore */

    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(Radio), "observedAttributes", this).concat(['checked']);
      }
    }]);

    return Radio;
  }(BaseFormField(BaseComponent(HTMLElement)));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Radio.Label
   @classdesc The Radio label
   @htmltag coral-radio-label
   @return {HTMLElement}
   */
  var RadioLabel = (function () {
    return document.createElement('coral-radio-label');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons.extend(strings, {
    'coral-component-radio': translations$6
  }); // Expose component on the Coral namespace

  commons._define('coral-radio', Radio);

  Radio.Label = RadioLabel;

  var CLASSNAME$n = 'coral-RadioGroup';
  /**
   Enumeration for {@link BaseFieldGroup} orientations.

   @typedef {Object} BaseFieldGroupOrientationEnum

   @property {String} HORIZONTAL
   Horizontal default orientation.
   @property {String} VERTICAL
   Vertical orientation.
   */

  var orientation = {
    HORIZONTAL: 'horizontal',
    VERTICAL: 'vertical'
  };
  /**
   @base BaseFieldGroup
   @classdesc The base element for FieldGroup components
   */

  var BaseFieldGroup = function BaseFieldGroup(superClass) {
    return /*#__PURE__*/function (_superClass) {
      _inherits(_class, _superClass);

      var _super = _createSuper(_class);

      function _class() {
        _classCallCheck(this, _class);

        return _super.apply(this, arguments);
      }

      _createClass(_class, [{
        key: "render",

        /** @ignore */
        value: function render() {
          _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

          this.classList.add(CLASSNAME$n); // a11y

          this.setAttribute('role', 'group'); // Default reflected attributes

          if (!this._orientation) {
            this.orientation = orientation.HORIZONTAL;
          }
        }
      }, {
        key: "items",

        /**
         The Collection Interface that allows interacting with the items that the component contains.
          @type {SelectableCollection}
         @readonly
         */
        get: function get() {
          // Construct the collection on first request:
          if (!this._items) {
            this._items = new SelectableCollection({
              itemTagName: this._itemTagName,
              host: this
            });
          }

          return this._items;
        }
        /**
         Orientation of the field group. See {@link BaseFieldGroupOrientationEnum}.
          @type {String}
         @default BaseFieldGroupOrientationEnum.HORIZONTAL
         @htmlattribute orientation
         @htmlattributereflected
         */

      }, {
        key: "orientation",
        get: function get() {
          return this._orientation || orientation.HORIZONTAL;
        },
        set: function set(value) {
          value = transform.string(value).toLowerCase();
          this._orientation = validate.enumeration(this.constructor.orientation)(value) && value || orientation.HORIZONTAL;

          this._reflectAttribute('orientation', this._orientation);

          this.classList.toggle("".concat(CLASSNAME$n, "--vertical"), this._orientation === orientation.VERTICAL);
        }
        /**
         Returns the first selected field group item in the Field Group. The value <code>null</code> is returned if no item is
         selected.
          @type {HTMLElement}
         @readonly
         */

      }, {
        key: "selectedItem",
        get: function get() {
          return this.items._getFirstSelected('checked');
        }
        /** @private */

      }, {
        key: "_itemTagName",
        get: function get() {
          // Used for Collection
          return 'coral-fieldgroup-item';
        }
        /**
         Returns {@link BaseFieldGroup} orientation options.
          @return {BaseFieldGroupEnum}
         */

      }], [{
        key: "orientation",
        get: function get() {
          return orientation;
        }
        /** @ignore */

      }, {
        key: "observedAttributes",
        get: function get() {
          return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['orientation']);
        }
      }]);

      return _class;
    }(superClass);
  };

  /**
   Enumeration for {@link RadioGroup} orientations.

   @typedef {Object} RadioGroupOrientationEnum

   @property {String} HORIZONTAL
   Horizontal default orientation.
   @property {String} VERTICAL
   Vertical orientation.
   @property {String} LABELS_BELOW
   Renders labels below items.
   */

  var orientation$1 = {
    HORIZONTAL: 'horizontal',
    VERTICAL: 'vertical',
    LABELS_BELOW: 'labelsbelow'
  };
  /**
   @class Coral.RadioGroup
   @classdesc A RadioGroup component to group radio fields
   @htmltag coral-radiogroup
   @extends {HTMLElement}
   @extends {BaseComponent}
   @extends {BaseFieldGroup}
   */

  var RadioGroup = /*#__PURE__*/function (_BaseFieldGroup) {
    _inherits(RadioGroup, _BaseFieldGroup);

    var _super = _createSuper(RadioGroup);

    function RadioGroup() {
      _classCallCheck(this, RadioGroup);

      return _super.apply(this, arguments);
    }

    _createClass(RadioGroup, [{
      key: "orientation",

      /**
       Orientation of the radio group. See {@link RadioGroupOrientationEnum}.
        @type {String}
       @default RadioGroupOrientationEnum.HORIZONTAL
       @htmlattribute orientation
       @htmlattributereflected
       */
      get: function get() {
        return _get(_getPrototypeOf(RadioGroup.prototype), "orientation", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(RadioGroup.prototype), "orientation", value, this, true);

        this.classList.toggle("coral-RadioGroup--labelsBelow", this._orientation === orientation$1.LABELS_BELOW);
      }
      /** @private */

    }, {
      key: "_itemTagName",
      get: function get() {
        // Used for Collection
        return 'coral-radio';
      }
      /**
       Returns {@link RadioGroup} orientation options.
        @return {RadioGroupEnum}
       */

    }], [{
      key: "orientation",
      get: function get() {
        return orientation$1;
      }
    }]);

    return RadioGroup;
  }(BaseFieldGroup(BaseComponent(HTMLElement)));

  /**
   * Copyright 2020 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons._define('coral-radiogroup', RadioGroup);

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var translations$7 = {
    "en-US": {
      "Decrement": "Decrement",
      "Increment": "Increment"
    },
    "fr-FR": {
      "Decrement": "DÃ©crÃ©menter",
      "Increment": "IncrÃ©menter"
    },
    "de-DE": {
      "Decrement": "Reduzieren",
      "Increment": "ErhÃ¶hen"
    },
    "it-IT": {
      "Decrement": "Decrementare",
      "Increment": "Incrementare"
    },
    "es-ES": {
      "Decrement": "Reducir",
      "Increment": "Aumentar"
    },
    "pt-BR": {
      "Decrement": "Decrementar",
      "Increment": "Incrementar"
    },
    "ja-JP": {
      "Decrement": "æ¸ãã",
      "Increment": "å¢ãã"
    },
    "ko-KR": {
      "Decrement": "ê°ì",
      "Increment": "ì¦ê°"
    },
    "zh-CN": {
      "Decrement": "åé",
      "Increment": "å¢é"
    },
    "zh-TW": {
      "Decrement": "æ¸é",
      "Increment": "å¢é"
    },
    "nl-NL": {
      "Decrement": "Verlagen",
      "Increment": "Verhogen"
    },
    "da-DK": {
      "Decrement": "Reduktion",
      "Increment": "DataÃ¦ndring"
    },
    "fi-FI": {
      "Decrement": "VÃ¤hennys",
      "Increment": "LisÃ¤ys"
    },
    "nb-NO": {
      "Decrement": "Reduser",
      "Increment": "Ãk"
    },
    "sv-SE": {
      "Decrement": "Minskning",
      "Increment": "Ãkning"
    },
    "cs-CZ": {
      "Decrement": "OdpoÄet",
      "Increment": "PÅÃ­rÅ¯stek"
    },
    "pl-PL": {
      "Decrement": "Zmniejsz",
      "Increment": "ZwiÄksz"
    },
    "ru-RU": {
      "Decrement": "Ð¡Ð½Ð¸Ð¶ÐµÐ½Ð¸Ðµ",
      "Increment": "ÐÑÐ¸ÑÐ¾ÑÑ"
    },
    "tr-TR": {
      "Decrement": "Azaltma",
      "Increment": "ArtÄ±rma"
    }
  };

  var template$9 = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var data = data_0 = typeof data_0 === "undefined" ? {} : data_0;
    data = data_0;
    data.uid = data.commons.getUID();
    data_0 = data;
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    var el2 = this["input"] = document.createElement("input", "coral-textfield");
    el2.setAttribute("is", "coral-textfield");
    el2.setAttribute("handle", "input");
    el2.setAttribute("type", "number");
    el2.className += " _coral-Stepper-input";
    el2.id = data_0["uid"];
    el2.setAttribute("step", "1");
    frag.appendChild(el2);
    var el3 = document.createTextNode("\n");
    frag.appendChild(el3);
    var el4 = this["presentation"] = document.createElement("span");
    el4.className += " _coral-Stepper-buttons";
    el4.setAttribute("role", "presentation");
    el4.setAttribute("handle", "presentation");
    var el5 = document.createTextNode("\n  ");
    el4.appendChild(el5);
    var el6 = this["stepUp"] = document.createElement("button", "coral-button");
    el6.setAttribute("variant", "action");
    el6.className += " _coral-Stepper-stepUp";
    el6.setAttribute("type", "button");
    el6.setAttribute("is", "coral-button");
    el6.setAttribute("handle", "stepUp");
    el6.setAttribute("title", data_0["i18n"]["get"]('Increment'));
    el6.setAttribute("aria-label", data_0["i18n"]["get"]('Increment'));
    el6.setAttribute("tabindex", "-1");
    el6.setAttribute("aria-controls", data_0["uid"]);
    var el7 = document.createTextNode("\n    ");
    el6.appendChild(el7);
    data = data_0;
    this.stepUp.innerHTML = data.Icon._renderSVG('spectrum-css-icon-ChevronUpSmall', ['_coral-Stepper-stepUpIcon', '_coral-UIIcon-ChevronUpSmall']);
    data_0 = data;
    var el9 = document.createTextNode("\n  ");
    el6.appendChild(el9);
    el4.appendChild(el6);
    var el10 = document.createTextNode("\n  ");
    el4.appendChild(el10);
    var el11 = this["stepDown"] = document.createElement("button", "coral-button");
    el11.setAttribute("variant", "action");
    el11.className += " _coral-Stepper-stepDown";
    el11.setAttribute("type", "button");
    el11.setAttribute("is", "coral-button");
    el11.setAttribute("handle", "stepDown");
    el11.setAttribute("title", data_0["i18n"]["get"]('Decrement'));
    el11.setAttribute("aria-label", data_0["i18n"]["get"]('Decrement'));
    el11.setAttribute("tabindex", "-1");
    el11.setAttribute("aria-controls", data_0["uid"]);
    var el12 = document.createTextNode("\n    ");
    el11.appendChild(el12);
    data = data_0;
    this.stepDown.innerHTML = data.Icon._renderSVG('spectrum-css-icon-ChevronDownSmall', ['_coral-Stepper-stepDownIcon', '_coral-UIIcon-ChevronDownSmall']);
    data_0 = data;
    var el14 = document.createTextNode("\n  ");
    el11.appendChild(el14);
    el4.appendChild(el11);
    var el15 = document.createTextNode("\n  ");
    el4.appendChild(el15);
    var el16 = this["liveregion"] = document.createElement("span");
    el16.setAttribute("role", "presentation");
    el16.setAttribute("handle", "liveregion");
    el16.setAttribute("aria-live", "assertive");
    el16.setAttribute("aria-atomic", "true");
    el16.setAttribute("aria-relevant", "additions text");
    el16.className += " u-coral-screenReaderOnly";
    el16.setAttribute("hidden", "");
    el4.appendChild(el16);
    var el17 = document.createTextNode("\n");
    el4.appendChild(el17);
    frag.appendChild(el4);
    var el18 = document.createTextNode("\n");
    frag.appendChild(el18);
    return frag;
  };

  var CLASSNAME$o = '_coral-Stepper';
  var clearLiveRegionTimeout;
  var LIVEREGION_TIMEOUT_DELAY = 3000;
  var MSPOINTER_TYPE_MOUSE = 0x00000004;
  var flagTouchStart = false;
  var flagStepButtonClick = false;

  var exponentialToDecimalString = function exponentialToDecimalString(value) {
    var notation = value.toString();

    if (notation.indexOf('e') !== -1) {
      var negative = notation.indexOf('-') === 0;
      var exponent = parseInt(notation.split('-')[negative ? 2 : 1], 10);
      return value.toFixed(exponent).toString();
    }

    return value.toString();
  };

  var handleDecimalOperation = function handleDecimalOperation(operator, value1, value2) {
    var result;

    var operation = function operation(operator, value1, value2) {
      if (operator === '+') {
        return value1 + value2;
      } else if (operator === '-') {
        return value1 - value2;
      } else if (operator === '%') {
        return value1 % value2;
      }
    }; // Check if we have decimals


    if (value1 % 1 !== 0 || value2 % 1 !== 0) {
      var value1Decimal = exponentialToDecimalString(value1).split('.');
      var value2Decimal = exponentialToDecimalString(value2).split('.');
      var value1DecimalLength = value1Decimal[1] && value1Decimal[1].length || 0;
      var value2DecimalLength = value2Decimal[1] && value2Decimal[1].length || 0;
      var multiplier = Math.pow(10, Math.max(value1DecimalLength, value2DecimalLength)); // Transform the decimals to integers based on the multiplier

      value1 = Math.round(value1 * multiplier);
      value2 = Math.round(value2 * multiplier); // Perform the operation on integers values to make sure we don't get a fancy decimal value

      result = operation(operator, value1, value2); // Transform the integer result back to decimal

      result /= multiplier;
    } else {
      result = operation(operator, value1, value2);
    }

    return result;
  };
  /**
   @class Coral.NumberInput
   @classdesc A NumberInput component is a numeric control form field. It follows the ARIA specification for spinbutton.
   This means the following keys are valid for interacting with it: <code>up</code>, <code>down</code>, <code>left</code>,
   <code>right</code>, <code>pageup</code>, <code>pagedown</code>, <code>home</code>, <code>end</code> and the Mouse Wheel.
   @htmltag coral-numberinput
   @extends {HTMLElement}
   @extends {BaseComponent}
   @extends {BaseFormField}
   */


  var NumberInput = /*#__PURE__*/function (_BaseFormField) {
    _inherits(NumberInput, _BaseFormField);

    var _super = _createSuper(NumberInput);

    /** @ignore */
    function NumberInput() {
      var _this;

      _classCallCheck(this, NumberInput);

      _this = _super.call(this);

      _this._delegateEvents(commons.extend(_this._events, {
        'key:up': '_onKeyUp',
        'key:pageup': '_onKeyUp',
        'key:down': '_onKeyDown',
        'key:pagedown': '_onKeyDown',
        'key:home': '_onKeyHome',
        'key:end': '_onKeyEnd',
        'touchstart [handle=stepUp], [handle=stepDown]': '_onTouchStart',
        'pointerdown [handle=stepUp], [handle=stepDown]': '_onTouchStart',
        'MSPointerDown [handle=stepUp], [handle=stepUp]': '_onTouchStart',
        'MSPointerDown [handle=stepDown], [handle=stepDown]': '_onTouchStart',
        'click [handle=stepUp]': '_onStepUpButtonClick',
        'click [handle=stepDown]': '_onStepDownButtonClick',
        'mousewheel [handle="input"]': '_onInputMouseWheel',
        'DOMMouseScroll [handle="input"]': '_onInputMouseWheel',
        'capture:focus': '_onFocus',
        'capture:blur': '_onBlur'
      })); // Prepare templates


      _this._elements = {};
      template$9.call(_this._elements, {
        i18n: i18n,
        commons: commons,
        Icon: Icon
      }); // Pre-define labellable element

      _this._labellableElement = _this._elements.input; // Default is null

      _this._min = _this._max = null;
      return _this;
    }
    /**
     This field's current value.
     @type {String}
     @default ""
     @htmlattribute value
     */


    _createClass(NumberInput, [{
      key: "reset",
      // overrides the behavior from BaseFormField
      value: function reset() {
        // since there is an internal value, this one handles the reset
        this._elements.input.reset();
      } // overrides the behavior from BaseFormField

    }, {
      key: "clear",
      value: function clear() {
        // since there is an internal value, this one handles the clear
        this._elements.input.clear();
      }
      /**
       Increments the value by <code>step</code>. If the current value is <code>null</code> or <code>''</code>, it is
       considered as 0. The new value will always respect the <code>min</code> and <code>max</code> values if available.
       */

    }, {
      key: "stepUp",
      value: function stepUp() {
        // uses the Number representation since it simplifies the calculations
        var value = this.valueAsNumber;

        var step = this._getActualStep();

        if (isNaN(value)) {
          this.value = this.max !== null ? Math.min(step, this.max) : step;
        } else {
          var newValue = handleDecimalOperation('+', value, step);
          this.value = this.max !== null ? Math.min(newValue, this.max) : newValue;
        }
      }
      /**
       Decrements the value by <code>step</code>. If the current value is <code>null</code> or <code>''</code>, it is
       considered as 0. The new value will always respect the <code>min</code> and <code>max</code> values if available.
       */

    }, {
      key: "stepDown",
      value: function stepDown() {
        // uses the Number representation since it simplifies the calculations
        var value = this.valueAsNumber;

        var step = this._getActualStep();

        if (isNaN(value)) {
          this.value = this.min !== null ? Math.max(-step, this.min) : -step;
        } else {
          var newValue = handleDecimalOperation('-', value, step);
          this.value = this.min !== null ? Math.max(newValue, this.min) : newValue;
        }
      }
      /**
       If the value is 'any' there is no allowed step, that means we incremenet with the default (as if the step was not
       defined).
        @returns {Number} the valid step according to the specs.
        @ignore
       */

    }, {
      key: "_getActualStep",
      value: function _getActualStep() {
        return this.step === 'any' ? 1 : this.step;
      }
      /**
       Checks if the current NumberInput is valid or not. This is done by checking that the current value is between the
       provided <code>min</code> and <code>max</code> values. This check is only performed on user interaction.
        @ignore
       */

    }, {
      key: "_validateInputValue",
      value: function _validateInputValue() {
        this.invalid = this.value !== '' && (isNaN(Number(this.value)) || this.max !== null && this.value > this.max || this.min !== null && this.value < this.min || this.step !== 'any' && handleDecimalOperation('%', Number(this.value), this._getActualStep()) !== 0);
      }
      /**
       Sets the correct state of the buttons based on <code>disabled</code>, <code>min</code>, <code>max</code> and
       <code>readOnly</code> properties.
        @ignore
       */

    }, {
      key: "_setButtonState",
      value: function _setButtonState() {
        this._elements.stepUp.disabled = this.disabled || this.max !== null && this.value >= this.max || this.readOnly;
        this._elements.stepDown.disabled = this.disabled || this.min !== null && this.value <= this.min || this.readOnly;
      }
      /**
       Triggers a change event. This is only done if the provided values are different.
        @param {String} newValue
       The new value of the component.
       @param {String} oldValue
       The old value of the component.
        @private
       */

    }, {
      key: "_triggerChange",
      value: function _triggerChange(newValue, oldValue) {
        // if the underlaying value stayed the same, there no need to trigger an event
        if (newValue !== oldValue) {
          this.trigger('change');
        }
      }
      /**
       Flags a touchstart or pointer event so that we can determine if an event originates from a touch screen interaction
       or from a mouse interaction. An event originating from a mouse interaction should shift the focus to the input,
       while an event originating from a touch interaction should not change the focus. On a touch screen, if the user
       presses the increment or decrement button, focus should not shift to the input and open the software keyboard.
        @ignore
       */

    }, {
      key: "_onTouchStart",
      value: function _onTouchStart(event) {
        if (event.type === 'touchstart' || event.pointerType !== 'mouse' && event.pointerType !== MSPOINTER_TYPE_MOUSE) {
          flagTouchStart = true;
        }
      }
      /**
       Per WAI-ARIA spinbutton design pattern, http://www.w3.org/TR/wai-aria-practices/#spinbutton, shift focus to the
       input if it does not currently have focus. We make an exception for touch devices, because a better user
       experience is for the focus to remain on an increment or decrement button without shifting focus and opening the
       soft keyboard.
        @ignore
       */

    }, {
      key: "_setFocusToInput",
      value: function _setFocusToInput() {
        if (!flagTouchStart && document.activeElement !== this._elements.input) {
          this._elements.input.focus();
        }

        flagTouchStart = false;
      }
      /**
       Handles the click on the step up button. It causes the NumberInput to step up its value and returns the focus back
       to the input. This way the clicked button does not get focus.
        @emits {change}
       @ignore
       */

    }, {
      key: "_onStepUpButtonClick",
      value: function _onStepUpButtonClick(event) {
        event.preventDefault(); // stores the old value before stepup

        var oldValue = this.value;
        flagStepButtonClick = event.type === 'click';

        this._setFocusToInput();

        this.stepUp(); // we only do this on user interaction

        this._validateInputValue(); // checks if we need to trigger a change event


        this._triggerChange(this.value, oldValue);
      }
      /**
       Handles the click on the step down button. It causes the NumberInput to step down its value and returns the focus
       back to the input. This way the clicked button does not get focus.
        @emits {change}
       @ignore
       */

    }, {
      key: "_onStepDownButtonClick",
      value: function _onStepDownButtonClick(event) {
        event.preventDefault(); // stores the old value before stepdown

        var oldValue = this.value;
        flagStepButtonClick = event.type === 'click';

        this._setFocusToInput();

        this.stepDown(); // we only do this on user interaction

        this._validateInputValue(); // checks if we need to trigger a change event


        this._triggerChange(this.value, oldValue);
      }
      /**
       Handles the home key press. If a max has been set, the value will be modified to match it, otherwise the key is
       ignored.
        @ignore
       */

    }, {
      key: "_onKeyHome",
      value: function _onKeyHome(event) {
        event.preventDefault(); // stops interaction if the numberinput is disabled or readonly

        if (this.disabled || this.readOnly) {
          return;
        } // sets the max value only if it exists


        if (this.max !== null) {
          // stores the old value before setting the max
          var oldValue = this.value; // When appropriate flagStepButtonClick will trigger a live region update.

          flagStepButtonClick = true;
          this.value = this.max; // checks if we need to trigger a change event

          this._triggerChange(this.value, oldValue);
        }

        this._setFocusToInput();
      }
      /**
       Handles the end key press. If a min has been set, the value will be modified to match it, otherwise the key is
       ignored.
        @ignore
       */

    }, {
      key: "_onKeyEnd",
      value: function _onKeyEnd(event) {
        event.preventDefault(); // stops interaction if the numberinput is disabled or readonly

        if (this.disabled || this.readOnly) {
          return;
        } // sets the min value only if it exists


        if (this.min !== null) {
          // stores the old value before setting the min
          var oldValue = this.value; // When appropriate, flagStepButtonClick will trigger a live region update.

          flagStepButtonClick = true;
          this.value = this.min; // checks if we need to trigger a change event

          this._triggerChange(this.value, oldValue);
        }

        this._setFocusToInput();
      }
      /**
       Handles the up action by steping up the NumberInput. It prevents the default action.
        @ignore
       */

    }, {
      key: "_onKeyUp",
      value: function _onKeyUp(event) {
        event.preventDefault(); // stops interaction if the numberinput is disabled or readonly

        if (this.disabled || this.readOnly) {
          return;
        }

        this._onStepUpButtonClick(event);
      }
      /**
       Handles the down action by steping down the NumberInput. It prevents the default action.
        @ignore
       */

    }, {
      key: "_onKeyDown",
      value: function _onKeyDown(event) {
        event.preventDefault(); // stops interaction if the numberinput is disabled or readonly

        if (this.disabled || this.readOnly) {
          return;
        }

        this._onStepDownButtonClick(event);
      }
      /**
       Handles the Mousewheel to increment/decrement values.
        @ignore
       */

    }, {
      key: "_onInputMouseWheel",
      value: function _onInputMouseWheel(event) {
        // stops interaction if the numberinput is disabled or readonly or is not focused (this is the case where its hovered but not focused)
        if (this.disabled || this.readOnly || this._elements.input !== document.activeElement) {
          return;
        } // else we prevent the default event like user scrolling the page and handle the mouse wheel input


        event.preventDefault(); // stores the old value to calculate the change

        var oldValue = this.value;
        var delta = Math.max(-1, Math.min(1, event.wheelDelta || -event.detail || event.deltaY));

        if (delta < 0) {
          this.stepDown();
        } else {
          this.stepUp();
        } // checks if we need to trigger a change event


        this._triggerChange(this.value, oldValue);
      }
      /**
       Overrides the method from formField to be able to add validation after the user has changed the value.
        @private
       */

    }, {
      key: "_onInputChange",
      value: function _onInputChange(event) {
        // stops the current event
        event.stopPropagation(); // we only do this on user interaction

        this._validateInputValue(); // we force the sync of the value,invalid and disabled properties


        this.value = this.value;
        this.invalid = this.invalid;
        this.disabled = this.disabled; // we always trigger a change since it came from user interaction

        this.trigger('change');
      }
      /**
       Handles focus event.
        @ignore
       */

    }, {
      key: "_onFocus",
      value: function _onFocus() {
        this.classList.add('is-focused');

        this._elements.input.classList.add('is-focused');

        this._elements.liveregion.removeAttribute('role');

        this._elements.liveregion.removeAttribute('aria-hidden');
      }
      /**
       Handles blur event.
        @ignore
       */

    }, {
      key: "_onBlur",
      value: function _onBlur() {
        this.classList.remove('is-focused');

        this._elements.input.classList.remove('is-focused'); // clear liveregion


        this._elements.liveregion.setAttribute('role', 'presentation');

        this._elements.liveregion.setAttribute('aria-hidden', true);

        this._clearLiveRegion();
      }
      /** @ignore */

    }, {
      key: "_clearLiveRegion",
      value: function _clearLiveRegion() {
        var liveregion = this._elements.liveregion;

        if (liveregion.firstChild) {
          liveregion.removeChild(liveregion.firstChild);
        }
      }
      /** @ignore */

    }, {
      key: "_updateLiveRegion",
      value: function _updateLiveRegion(value) {
        var _this2 = this;

        var textNode;
        clearTimeout(clearLiveRegionTimeout);

        this._clearLiveRegion();

        if (value && value !== '') {
          textNode = document.createTextNode(value);
          window.requestAnimationFrame(function () {
            _this2._elements.liveregion.appendChild(textNode);

            clearLiveRegionTimeout = window.setTimeout(function () {
              _this2._clearLiveRegion();
            }, LIVEREGION_TIMEOUT_DELAY);
          });
        }
      }
      /** @ignore */

    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(NumberInput.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$o); // Default reflected attributes

        if (!this._step) {
          this.step = 1;
        } // a11y


        this.setAttribute('role', 'group');

        if (this._elements.input.type === 'text') {
          this._elements.input.setAttribute('role', 'spinbutton');
        }

        var frag = document.createDocumentFragment();
        var templateHandleNames = ['presentation', 'input']; // Render main template

        frag.appendChild(this._elements.input);
        frag.appendChild(this._elements.presentation);

        while (this.firstChild) {
          var child = this.firstChild;

          if (child.nodeType === Node.TEXT_NODE || child.nodeType === Node.ELEMENT_NODE && templateHandleNames.indexOf(child.getAttribute('handle')) === -1) {
            // Add non-template elements to the frag
            frag.appendChild(child);
          } else {
            // Remove anything else
            this.removeChild(child);
          }
        }

        this.appendChild(frag);
      }
    }, {
      key: "value",
      get: function get() {
        return this._elements.input.value;
      },
      set: function set(value) {
        value = isNaN(value) ? '' : String(value); // sets the value immediately so it is picked up in form submits

        this._elements.input.value = value; // in order to keep the reset value in sync, we need to handle the "value" attribute of the inner input

        var valueAttribute = this.getAttribute('value');

        this._elements.input[valueAttribute ? 'setAttribute' : 'removeAttribute']('value', valueAttribute); // @a11y: aria-valuetext is used so that VoiceOver does not announce a percentage


        if (this.value) {
          this._elements.input.setAttribute('aria-valuenow', this.value);

          this._elements.input.setAttribute('aria-valuetext', this.value);
        } else {
          this._elements.input.removeAttribute('aria-valuenow');

          this._elements.input.removeAttribute('aria-valuetext');
        } // If the event triggering a value change is a click on a +/- button,
        // announce the new value using the live region.


        if (flagStepButtonClick || !!window.chrome) {
          this._updateLiveRegion(this.value); // Otherwise, clear the live region.

        } else {
          this._updateLiveRegion();
        }

        flagStepButtonClick = false;
        this.invalid = this.hasAttribute('invalid');
        this.disabled = this.hasAttribute('disabled');
      }
      /**
       The value returned as a Number. Value is <code>NaN</code> if conversion to Number is not possible.
        @type {Number}
       @default NaN
       */

    }, {
      key: "valueAsNumber",
      get: function get() {
        var valueAsNumber = this._valueAsNumber;

        if (typeof valueAsNumber !== 'undefined' && valueAsNumber !== null) {
          return valueAsNumber;
        }

        valueAsNumber = transform.number(this.value);

        if (valueAsNumber !== null) {
          return valueAsNumber;
        }

        return NaN;
      },
      set: function set(value) {
        this._valueAsNumber = transform.number(value);
        this.value = this._valueAsNumber;
        this.invalid = this.hasAttribute('invalid');
        this.disabled = this.hasAttribute('disabled');
      }
      /**
       The minimum value for the NumberInput. If a value below the minimum is set, the NumberInput will be marked as
       invalid but the value will be preserved. Stepping down the NumberInput via {@link Coral.NumberInput#stepDown}
       or the decrement button respects the minimum value. It reflects the <code>min</code> attribute to the DOM.
        @type {?Number}
       @default null
       @htmlattribute min
       @htmlattributereflected
       */

    }, {
      key: "min",
      get: function get() {
        return this._min;
      },
      set: function set(value) {
        value = transform.number(value);
        this._min = isNaN(value) ? null : value;

        if (this._min === null) {
          this._reflectAttribute('min', false);

          this._elements.input.removeAttribute('aria-valuemin');

          this._elements.input.removeAttribute('min');
        } else {
          this._reflectAttribute('min', this._min); // sets the min in the input so that keyboard handles this component


          this._elements.input.setAttribute('aria-valuemin', this._min);

          this._elements.input.min = this._min;
        }

        this.invalid = this.hasAttribute('invalid');
        this.disabled = this.hasAttribute('disabled');
      }
      /**
       The maximum value for the NumberInput. If a value above the maximum is set, the NumberInput will be marked as
       invalid but the value will be preserved. Stepping up the NumberInput via {@link Coral.NumberInput#stepUp} or
       the increment button respects the maximum value. It reflects the <code>max</code> attribute to the DOM.
        @type {?Number}
       @default null
       @htmlattribute max
       @htmlattributereflected
       */

    }, {
      key: "max",
      get: function get() {
        return this._max;
      },
      set: function set(value) {
        value = transform.number(value);
        this._max = isNaN(value) ? null : value;

        if (this.max === null) {
          this._reflectAttribute('max', false);

          this._elements.input.removeAttribute('aria-valuemax');

          this._elements.input.removeAttribute('max');
        } else {
          this._reflectAttribute('max', this._max); // sets the max in the input so that keyboard handles this component


          this._elements.input.setAttribute('aria-valuemax', this._max);

          this._elements.input.max = this._max;
        }

        this.invalid = this.hasAttribute('invalid');
        this.disabled = this.hasAttribute('disabled');
      }
      /**
       The amount to increment by when stepping up or down. It can be the string <code>any</code> or any positive
       floating point number. If this is not set to <code>any<code>, the control accepts only values at multiples of
       the step value greater than the minimum.
        @type {Number|String}
       @default 1
       @htmlattribute step
       @htmlattributereflected
       */

    }, {
      key: "step",
      get: function get() {
        return this._step || 1;
      },
      set: function set(value) {
        if (value !== null && (value > 0 || value === 'any')) {
          this._step = value === 'any' ? value : transform.number(value);

          this._reflectAttribute('step', this._step);

          this._elements.input.step = this._step;
        }
      }
      /**
       Name used to submit the data in a form.
       @type {String}
       @default ""
       @htmlattribute name
       @htmlattributereflected
       */

    }, {
      key: "name",
      get: function get() {
        return this._elements.input.name;
      },
      set: function set(value) {
        this._reflectAttribute('name', value);

        this._elements.input.name = value;
      }
      /**
       Whether this field is disabled or not.
       @type {Boolean}
       @default false
       @htmlattribute disabled
       @htmlattributereflected
       */

    }, {
      key: "disabled",
      get: function get() {
        return this._disabled || false;
      },
      set: function set(value) {
        this._disabled = transform.booleanAttr(value);

        this._reflectAttribute('disabled', this._disabled);

        this[this._disabled ? 'setAttribute' : 'removeAttribute']('aria-disabled', this._disabled);
        this.classList.toggle('is-disabled', this._disabled);
        this._elements.input.disabled = this._disabled;

        this._setButtonState();
      }
      /**
       Whether this field is required or not.
       @type {Boolean}
       @default false
       @htmlattribute required
       @htmlattributereflected
       */

    }, {
      key: "required",
      get: function get() {
        return this._required || false;
      },
      set: function set(value) {
        this._required = transform.booleanAttr(value);

        this._reflectAttribute('required', this._required);

        this._elements.input.required = this._required;
      }
      /**
       Whether this field is readOnly or not. Indicating that the user cannot modify the value of the control.
       @type {Boolean}
       @default false
       @htmlattribute readonly
       @htmlattributereflected
       */

    }, {
      key: "readOnly",
      get: function get() {
        return this._readOnly || false;
      },
      set: function set(value) {
        this._readOnly = transform.booleanAttr(value);

        this._reflectAttribute('readonly', this._readOnly);

        this._elements.input.readOnly = this._readOnly;

        this._setButtonState();
      }
      /**
       Inherited from {@link BaseFormField#invalid}.
       */

    }, {
      key: "invalid",
      get: function get() {
        return _get(_getPrototypeOf(NumberInput.prototype), "invalid", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(NumberInput.prototype), "invalid", value, this, true);

        this._elements.input.invalid = this._invalid;
      }
      /**
       Inherited from {@link BaseFormField#labelledBy}.
       */

    }, {
      key: "labelledBy",
      get: function get() {
        return _get(_getPrototypeOf(NumberInput.prototype), "labelledBy", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(NumberInput.prototype), "labelledBy", value, this, true); // in case the user focuses the buttons, he will still get a notion of the usage of the component


        this[this.labelledBy ? 'setAttribute' : 'removeAttribute']('aria-labelledby', this.labelledBy);
      }
      /**
       Short hint that describes the expected value of the NumberInput. It is displayed when the NumberInput is empty.
        @type {String}
       @default ""
       @htmlattribute placeholder
       @htmlattributereflected
       */

    }, {
      key: "placeholder",
      get: function get() {
        return this._elements.input.placeholder || '';
      },
      set: function set(value) {
        value = transform.string(value);

        this._reflectAttribute('placeholder', value);

        this._elements.input.placeholder = value;
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(NumberInput), "observedAttributes", this).concat(['min', 'max', 'step', 'placeholder']);
      }
    }]);

    return NumberInput;
  }(BaseFormField(BaseComponent(HTMLElement)));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons.extend(strings, {
    'coral-component-numberinput': translations$7
  }); // Expose component on the Coral namespace

  commons._define('coral-numberinput', NumberInput);

  var template$a = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["tip"] = document.createElement("span");
    el0.className += " _coral-Tooltip-tip";
    el0.setAttribute("handle", "tip");
    frag.appendChild(el0);
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    return frag;
  };

  var arrowMap = {
    left: 'left',
    right: 'right',
    top: 'top',
    bottom: 'bottom'
  };
  var CLASSNAME$p = '_coral-Tooltip';
  var OFFSET$1 = 5;
  /**
   Enumeration for {@link Tooltip} variants.

   @typedef {Object} TooltipVariantEnum

   @property {String} DEFAULT
   A default tooltip that provides additional information.
   @property {String} INFO
   A tooltip that informs the user of non-critical information.
   @property {String} SUCCESS
   A tooltip that indicates an operation was successful.
   @property {String} ERROR
   A tooltip that indicates an error has occurred.
   @property {String} WARNING
   Not supported. Falls back to DEFAULT.
   @property {String} INSPECT
   Not supported. Falls back to DEFAULT.
   */

  var variant$7 = {
    DEFAULT: 'default',
    INFO: 'info',
    SUCCESS: 'success',
    ERROR: 'error',
    WARNING: 'warning',
    INSPECT: 'inspect'
  }; // A string of all possible variant classnames

  var ALL_VARIANT_CLASSES$5 = [];

  for (var variantName in variant$7) {
    ALL_VARIANT_CLASSES$5.push("".concat(CLASSNAME$p, "--").concat(variant$7[variantName]));
  } // A string of all position placement classnames


  var ALL_PLACEMENT_CLASSES$1 = []; // A map of lowercase directions to their corresponding classname

  var placementClassMap = {};

  for (var key$1 in Overlay.placement) {
    var direction = Overlay.placement[key$1];
    var placementClass = "".concat(CLASSNAME$p, "--").concat(arrowMap[direction]); // Store in map

    placementClassMap[direction] = placementClass; // Store in list

    ALL_PLACEMENT_CLASSES$1.push(placementClass);
  }
  /**
   @class Coral.Tooltip
   @classdesc A Tooltip component that can be attached to any element and may be displayed immediately or on hovering the
   target element.
   @htmltag coral-tooltip
   @extends {Overlay}
   */


  var Tooltip = /*#__PURE__*/function (_Overlay) {
    _inherits(Tooltip, _Overlay);

    var _super = _createSuper(Tooltip);

    /** @ignore */
    function Tooltip() {
      var _this;

      _classCallCheck(this, Tooltip);

      _this = _super.call(this); // Override defaults

      _this._lengthOffset = OFFSET$1;
      _this._overlayAnimationTime = Overlay.FADETIME;
      _this._focusOnShow = Overlay.focusOnShow.OFF; // Fetch or create the content zone element

      _this._elements = commons.extend(_this._elements, {
        content: _this.querySelector('coral-tooltip-content') || document.createElement('coral-tooltip-content')
      }); // Generate template

      template$a.call(_this._elements); // Used for events

      _this._id = commons.getUID();

      _this._delegateEvents({
        'coral-overlay:positioned': '_onPositioned',
        'coral-overlay:_animate': '_onAnimate'
      });

      return _this;
    }
    /**
     The variant of tooltip. See {@link TooltipVariantEnum}.
      @type {String}
     @default TooltipVariantEnum.DEFAULT
     @htmlattribute variant
     @htmlattributereflected
     */


    _createClass(Tooltip, [{
      key: "_onPositioned",

      /** @ignore */
      value: function _onPositioned(event) {
        var _this$classList;

        // Set arrow placement
        (_this$classList = this.classList).remove.apply(_this$classList, ALL_PLACEMENT_CLASSES$1);

        this.classList.add(placementClassMap[event.detail.placement]);
      }
    }, {
      key: "_onAnimate",
      value: function _onAnimate() {
        // popper attribute
        var popperPlacement = this.getAttribute('x-placement'); // popper takes care of setting left, top to 0 on positioning

        if (popperPlacement === 'left') {
          this.style.left = '8px';
        } else if (popperPlacement === 'top') {
          this.style.top = '8px';
        } else if (popperPlacement === 'right') {
          this.style.left = '-8px';
        } else if (popperPlacement === 'bottom') {
          this.style.top = '-8px';
        }
      }
      /** @ignore */

    }, {
      key: "_handleFocusOut",
      value: function _handleFocusOut() {
        var _this2 = this;

        // The item that should have focus will get it on the next frame
        window.requestAnimationFrame(function () {
          var targetIsFocused = document.activeElement === _this2._getTarget();

          if (!targetIsFocused) {
            _this2._cancelShow();

            _this2.open = false;
          }
        });
      }
      /** @ignore */

    }, {
      key: "_cancelShow",
      value: function _cancelShow() {
        window.clearTimeout(this._showTimeout);
      }
      /** @ignore */

    }, {
      key: "_cancelHide",
      value: function _cancelHide() {
        window.clearTimeout(this._hideTimeout);
      }
      /** @ignore */

    }, {
      key: "_startHide",
      value: function _startHide() {
        var _this3 = this;

        if (this.delay === 0) {
          // Hide immediately
          this._handleFocusOut();
        } else {
          this._hideTimeout = window.setTimeout(function () {
            _this3._handleFocusOut();
          }, this.delay);
        }
      }
      /** @ignore */

    }, {
      key: "_addTargetListeners",
      value: function _addTargetListeners(target) {
        var _this4 = this;

        // Make sure we don't add listeners twice to the same element for this particular tooltip
        if (target["_hasTooltipListeners".concat(this._id)]) {
          return;
        }

        target["_hasTooltipListeners".concat(this._id)] = true; // Remove listeners from the old target

        if (this._oldTarget) {
          var oldTarget = this._getTarget(this._oldTarget);

          if (oldTarget) {
            this._removeTargetListeners(oldTarget);
          }
        } // Store the current target value


        this._oldTarget = target; // Use Vent to bind events on the target

        this._targetEvents = new vent(target);

        var handleEventToShow = function handleEventToShow() {
          // Don't let the tooltip hide
          _this4._cancelHide();

          if (!_this4.open) {
            _this4._cancelShow();

            if (_this4.delay === 0) {
              // Show immediately
              _this4.show();
            } else {
              _this4._showTimeout = window.setTimeout(function () {
                _this4.show();
              }, _this4.delay);
            }
          }
        };

        this._targetEvents.on("mouseenter.Tooltip".concat(this._id), handleEventToShow);

        this._targetEvents.on("focusin.Tooltip".concat(this._id), handleEventToShow);

        this._targetEvents.on("mouseenter.Tooltip".concat(this._id), this._handleOpenTooltip.bind(this));

        this._targetEvents.on("focusin.Tooltip".concat(this._id), this._handleOpenTooltip.bind(this));

        this._targetEvents.on("mouseleave.Tooltip".concat(this._id), function () {
          if (_this4.interaction === _this4.constructor.interaction.ON) {
            _this4._startHide();
          }
        });

        this._targetEvents.on("focusout.Tooltip".concat(this._id), function () {
          if (_this4.interaction === _this4.constructor.interaction.ON) {
            _this4._handleFocusOut();
          }
        });
      }
    }, {
      key: "_handleOpenTooltip",
      value: function _handleOpenTooltip() {
        var _this5 = this;

        // Don't let the tooltip hide
        this._cancelHide();

        if (!this.open) {
          this._cancelShow();

          if (this.delay === 0) {
            // Show immediately
            this.show();
          } else {
            this._showTimeout = window.setTimeout(function () {
              _this5.show();
            }, this.delay);
          }
        }
      }
      /** @ignore */

    }, {
      key: "_removeTargetListeners",
      value: function _removeTargetListeners(target) {
        // Remove listeners for this tooltip and mark that the element doesn't have them
        // Use the ID so we can support multiple tooltips on the same element
        if (this._targetEvents) {
          this._targetEvents.off(".Tooltip".concat(this._id));
        }

        target["_hasTooltipListeners".concat(this._id)] = false;
      }
    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(Tooltip.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$p); // ARIA

        this.setAttribute('role', 'tooltip'); // Let the tooltip be focusable
        // We'll marshall focus around when its focused

        this.setAttribute('tabindex', '-1'); // Default reflected attributes

        if (!this._variant) {
          this.variant = variant$7.DEFAULT;
        } // Support cloneNode


        var tip = this.querySelector('._coral-Tooltip-tip');

        if (tip) {
          tip.remove();
        }

        var content = this._elements.content; // Move the content into the content zone if none specified

        if (!content.parentNode) {
          while (this.firstChild) {
            content.appendChild(this.firstChild);
          }
        } // Append template


        this.appendChild(this._elements.tip); // Assign the content zone so the insert function will be called

        this.content = content;
      }
    }, {
      key: "variant",
      get: function get() {
        return this._variant || variant$7.DEFAULT;
      },
      set: function set(value) {
        var _this$classList2;

        value = transform.string(value).toLowerCase();
        this._variant = validate.enumeration(variant$7)(value) && value || variant$7.DEFAULT;

        this._reflectAttribute('variant', this._variant);

        (_this$classList2 = this.classList).remove.apply(_this$classList2, ALL_VARIANT_CLASSES$5);

        this.classList.add("".concat(CLASSNAME$p, "--").concat(this._variant));
      }
      /**
       The amount of time in miliseconds to wait before showing the tooltip when the target is interacted with.
        @type {Number}
       @default 500
       @htmlattribute delay
       */

    }, {
      key: "delay",
      get: function get() {
        return typeof this._delay === 'number' ? this._delay : 500;
      },
      set: function set(value) {
        this._delay = transform.number(value);
      }
      /**
       The Tooltip content element.
        @type {TooltipContent}
       @contentzone
       */

    }, {
      key: "content",
      get: function get() {
        return this._getContentZone(this._elements.content);
      },
      set: function set(value) {
        this._setContentZone('content', value, {
          handle: 'content',
          tagName: 'coral-tooltip-content',
          insert: function insert(content) {
            content.classList.add("".concat(CLASSNAME$p, "-label"));
            this.appendChild(content);
          }
        });
      }
      /**
       Inherited from {@link Overlay#open}.
       */

    }, {
      key: "open",
      get: function get() {
        return _get(_getPrototypeOf(Tooltip.prototype), "open", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(Tooltip.prototype), "open", value, this, true);

        if (!this.open) {
          // Stop previous show operations from happening
          this._cancelShow();
        }
      }
      /**
       Inherited from {@link Overlay#target}.
       */

    }, {
      key: "target",
      get: function get() {
        return _get(_getPrototypeOf(Tooltip.prototype), "target", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(Tooltip.prototype), "target", value, this, true);

        var target = this._getTarget(value);

        if (target) {
          this._elements.tip.hidden = false;

          if (this.interaction === this.constructor.interaction.ON) {
            // Add listeners to the target
            this._addTargetListeners(target);
          }
        } else {
          this._elements.tip.hidden = true;
        }
      }
      /**
       Inherited from {@link Overlay#interaction}.
       */

    }, {
      key: "interaction",
      get: function get() {
        return _get(_getPrototypeOf(Tooltip.prototype), "interaction", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(Tooltip.prototype), "interaction", value, this, true);

        var target = this._getTarget();

        if (target) {
          if (value === this.constructor.interaction.ON) {
            this._addTargetListeners(target);
          } else {
            this._removeTargetListeners(target);
          }
        }
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-tooltip-content': 'content'
        };
      }
      /**
       Returns {@link Tooltip} variants.
        @return {TooltipVariantEnum}
       */

    }], [{
      key: "variant",
      get: function get() {
        return variant$7;
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(Tooltip), "observedAttributes", this).concat(['variant', 'delay']);
      }
    }]);

    return Tooltip;
  }(Overlay);

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Tooltip.Content
   @classdesc Tooltip's content component
   @htmltag coral-tooltip-content
   @return {HTMLElement}
   */
  var TooltipContent = (function () {
    return document.createElement('coral-tooltip-content');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons._define('coral-tooltip', Tooltip);

  Tooltip.Content = TooltipContent;

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var translations$8 = {
    "en-US": {
      "Select": "Select"
    },
    "fr-FR": {
      "Select": "SÃ©lectionner"
    },
    "de-DE": {
      "Select": "AuswÃ¤hlen"
    },
    "it-IT": {
      "Select": "Seleziona"
    },
    "es-ES": {
      "Select": "Seleccionar"
    },
    "pt-BR": {
      "Select": "Selecionar"
    },
    "ja-JP": {
      "Select": "é¸æ"
    },
    "ko-KR": {
      "Select": "ì í"
    },
    "zh-CN": {
      "Select": "éæ©"
    },
    "zh-TW": {
      "Select": "é¸å"
    },
    "nl-NL": {
      "Select": "Selecteren"
    },
    "da-DK": {
      "Select": "VÃ¦lg"
    },
    "fi-FI": {
      "Select": "Valitse"
    },
    "nb-NO": {
      "Select": "Velg"
    },
    "sv-SE": {
      "Select": "VÃ¤lj"
    },
    "cs-CZ": {
      "Select": "Vybrat"
    },
    "pl-PL": {
      "Select": "Wybierz"
    },
    "ru-RU": {
      "Select": "ÐÑÐ±ÐµÑÐ¸ÑÐµ"
    },
    "tr-TR": {
      "Select": "SeÃ§"
    }
  };

  var template$b = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var data = data_0 = typeof data_0 === "undefined" ? {} : data_0;
    var el0 = this["input"] = document.createElement("input");
    el0.setAttribute("type", "checkbox");
    el0.setAttribute("handle", "input");
    el0.className += " _coral-Checkbox-input";
    el0.id = data_0["commons"]["getUID"]();
    frag.appendChild(el0);
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    var el2 = this["checkbox"] = document.createElement("span");
    el2.className += " _coral-Checkbox-box";
    el2.setAttribute("handle", "checkbox");
    var el3 = document.createTextNode("\n  ");
    el2.appendChild(el3);
    data = data_0;
    this.checkbox.innerHTML = data.Icon._renderSVG('spectrum-css-icon-CheckmarkSmall', ['_coral-Checkbox-checkmark', '_coral-UIIcon-CheckmarkSmall']);
    this.checkbox.innerHTML += data.Icon._renderSVG('spectrum-css-icon-DashSmall', ['_coral-Checkbox-partialCheckmark', '_coral-UIIcon-DashSmall']);
    data_0 = data;
    var el5 = document.createTextNode("\n");
    el2.appendChild(el5);
    frag.appendChild(el2);
    var el6 = document.createTextNode("\n");
    frag.appendChild(el6);
    var el7 = this["labelWrapper"] = document.createElement("label");
    el7.className += " _coral-Checkbox-label";
    el7.setAttribute("handle", "labelWrapper");
    el7.setAttribute("for", this["input"]["id"]);
    var el8 = document.createTextNode("\n  ");
    el7.appendChild(el8);
    var el9 = this["screenReaderOnly"] = document.createElement("span");
    el9.className += " u-coral-screenReaderOnly";
    el9.setAttribute("handle", "screenReaderOnly");
    el9.textContent = data_0["i18n"]["get"]('Select');
    el7.appendChild(el9);
    var el10 = document.createTextNode("\n");
    el7.appendChild(el10);
    frag.appendChild(el7);
    var el11 = document.createTextNode("\n");
    frag.appendChild(el11);
    return frag;
  };

  var IS_IE_OR_EDGE = navigator.userAgent.indexOf('MSIE') !== -1 || navigator.appVersion.indexOf('Trident/') > 0 || window.navigator.userAgent.indexOf('Edge') !== -1;
  var CLASSNAME$q = '_coral-Checkbox';
  /**
   @class Coral.Checkbox
   @classdesc A Checkbox component to be used as a form field.
   @htmltag coral-checkbox
   @extends {HTMLElement}
   @extends {BaseComponent}
   @extends {BaseFormField}
   */

  var Checkbox = /*#__PURE__*/function (_BaseFormField) {
    _inherits(Checkbox, _BaseFormField);

    var _super = _createSuper(Checkbox);

    /** @ignore */
    function Checkbox() {
      var _this;

      _classCallCheck(this, Checkbox);

      _this = _super.call(this); // @polyfill ie

      _this._delegateEvents(commons.extend(_this._events, {
        click: '_onClick',
        mousedown: '_onMouseDown'
      })); // Prepare templates


      _this._elements = {
        // Try to find the label content zone or create one
        label: _this.querySelector('coral-checkbox-label') || document.createElement('coral-checkbox-label')
      };
      template$b.call(_this._elements, {
        commons: commons,
        i18n: i18n,
        Icon: Icon
      }); // Pre-define labellable element

      _this._labellableElement = _this._elements.input; // Check if the label is empty whenever we get a mutation

      _this._observer = new MutationObserver(_this._hideLabelIfEmpty.bind(_assertThisInitialized(_this))); // Watch for changes to the label element's children

      _this._observer.observe(_this._elements.labelWrapper, {
        // Catch changes to childList
        childList: true,
        // Catch changes to textContent
        characterData: true,
        // Monitor any child node
        subtree: true
      });

      return _this;
    }
    /**
     Checked state for the checkbox.
      @type {Boolean}
     @default false
     @htmlattribute checked
     @htmlattributereflected
     @emits {change}
     */


    _createClass(Checkbox, [{
      key: "_onInputChange",

      /** @private */
      value: function _onInputChange(event) {
        var _this2 = this;

        // stops the current event
        event.stopPropagation();
        /** @ignore */

        this[this._componentTargetProperty] = event.target[this._eventTargetProperty]; // resets the indeterminate state after user interaction

        this.indeterminate = false; // Explicitly re-emit the change event after the property has been set

        if (this._triggerChangeEvent) {
          // @polyfill ie/edge
          if (IS_IE_OR_EDGE) {
            // We need 1 additional frame in case the indeterminate state is set manually on change event
            window.requestAnimationFrame(function () {
              _this2.trigger('change');
            });
          } else {
            this.trigger('change');
          }
        }
      }
      /**
       @private
       @polyfill ie/edge
       */

    }, {
      key: "_onClick",
      value: function _onClick(event) {
        // Force the check/uncheck and trigger the change event since IE won't.
        if (IS_IE_OR_EDGE && this.indeterminate) {
          // Other browsers like Chrome and Firefox will trigger the change event and set indeterminate = false. So we
          // verify if indeterminate was changed and if not, we manually check/uncheck and trigger the change event.
          this.checked = !this.checked;

          this._onInputChange(event);
        } // Handle the click() just like the native checkbox
        else if (event.target === this) {
            this.indeterminate = false;
            this.checked = !this.checked;
            this.trigger('change');
          }

        this._trackEvent(this.checked ? 'checked' : 'unchecked', 'coral-checkbox', event);
      }
      /**
       Forces checkbox to receive focus on mousedown
       @ignore
       */

    }, {
      key: "_onMouseDown",
      value: function _onMouseDown() {
        var target = this._elements.input;
        window.requestAnimationFrame(function () {
          if (target !== document.activeElement) {
            target.focus();
          }
        });
      }
      /**
       Hide the label if it's empty
       @ignore
       */

    }, {
      key: "_hideLabelIfEmpty",
      value: function _hideLabelIfEmpty() {
        var label = this._elements.label; // If it's empty and has no non-textnode children, hide the label

        var hiddenValue = !(label.children.length === 0 && label.textContent.replace(/\s*/g, '') === ''); // Toggle the screen reader text

        this._elements.labelWrapper.style.margin = !hiddenValue ? '0' : '';
        this._elements.screenReaderOnly.hidden = !!hiddenValue || !!this.labelledBy || !!this.labelled;
      }
      /**
       Inherited from {@link BaseFormField#clear}.
       */

    }, {
      key: "clear",
      value: function clear() {
        this.checked = false;
      }
      /**
       Inherited from {@link BaseFormField#reset}.
       */

    }, {
      key: "reset",
      value: function reset() {
        this.checked = this._initialCheckedState;
      }
    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(Checkbox.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$q); // Create a fragment

        var frag = document.createDocumentFragment();
        var templateHandleNames = ['input', 'checkbox', 'labelWrapper']; // Render the main template

        frag.appendChild(this._elements.input);
        frag.appendChild(this._elements.checkbox);
        frag.appendChild(this._elements.labelWrapper);
        var label = this._elements.label; // Remove it so we can process children

        if (label.parentNode) {
          label.parentNode.removeChild(label);
        }

        while (this.firstChild) {
          var child = this.firstChild;

          if (child.nodeType === Node.TEXT_NODE || child.nodeType === Node.ELEMENT_NODE && templateHandleNames.indexOf(child.getAttribute('handle')) === -1) {
            // Add non-template elements to the label
            label.appendChild(child);
          } else {
            // Remove anything else (e.g labelWrapper)
            this.removeChild(child);
          }
        } // Add the frag to the component


        this.appendChild(frag); // Assign the content zones, moving them into place in the process

        this.label = label; // Cache the initial checked state of the checkbox (in order to implement reset)

        this._initialCheckedState = this.checked; // Check if we need to hide the label
        // We must do this because IE does not catch mutations when nodes are not in the DOM

        this._hideLabelIfEmpty();
      }
    }, {
      key: "checked",
      get: function get() {
        return this._checked || false;
      },
      set: function set(value) {
        this._checked = transform.booleanAttr(value);

        this._reflectAttribute('checked', this._checked);

        this._elements.input.checked = this._checked;
      }
      /**
       Indicates that the checkbox is neither on nor off.
        @type {Boolean}
       @default false
       @htmlattribute indeterminate
       @htmlattributereflected
       */

    }, {
      key: "indeterminate",
      get: function get() {
        return this._indeterminate || false;
      },
      set: function set(value) {
        this._indeterminate = transform.booleanAttr(value);

        this._reflectAttribute('indeterminate', this._indeterminate);

        this.classList.toggle('is-indeterminate', this._indeterminate);
        this._elements.input.indeterminate = this._indeterminate;

        this._elements.input[this._indeterminate ? 'setAttribute' : 'removeAttribute']('aria-checked', 'mixed');
      }
      /**
       The checkbox's label element.
        @type {CheckboxLabel}
       @contentzone
       */

    }, {
      key: "label",
      get: function get() {
        return this._getContentZone(this._elements.label);
      },
      set: function set(value) {
        this._setContentZone('label', value, {
          handle: 'label',
          tagName: 'coral-checkbox-label',
          insert: function insert(label) {
            this._elements.labelWrapper.appendChild(label);
          }
        });
      }
      /**
       Name used to submit the data in a form.
       @type {String}
       @default ""
       @htmlattribute name
       @htmlattributereflected
       */

    }, {
      key: "name",
      get: function get() {
        return this._elements.input.name;
      },
      set: function set(value) {
        this._reflectAttribute('name', value);

        this._elements.input.name = value;
      }
      /**
       The value that will be submitted when the checkbox is checked. Changing this value will not trigger an event.
        @type {String}
       @default "on"
       @htmlattribute value
       */

    }, {
      key: "value",
      get: function get() {
        return this._elements.input.value || 'on';
      },
      set: function set(value) {
        this._elements.input.value = value;
      }
      /**
       Whether this field is disabled or not.
       @type {Boolean}
       @default false
       @htmlattribute disabled
       @htmlattributereflected
       */

    }, {
      key: "disabled",
      get: function get() {
        return this._disabled || false;
      },
      set: function set(value) {
        this._disabled = transform.booleanAttr(value);

        this._reflectAttribute('disabled', this._disabled);

        this[this._disabled ? 'setAttribute' : 'removeAttribute']('aria-disabled', this._disabled);
        this.classList.toggle('is-disabled', this._disabled);
        this._elements.input.disabled = this._disabled;
      }
      /**
       Whether this field is required or not.
       @type {Boolean}
       @default false
       @htmlattribute required
       @htmlattributereflected
       */

    }, {
      key: "required",
      get: function get() {
        return this._required || false;
      },
      set: function set(value) {
        this._required = transform.booleanAttr(value);

        this._reflectAttribute('required', this._required);

        this._elements.input.required = this._required;
      }
      /**
       Whether this field is readOnly or not. Indicating that the user cannot modify the value of the control.
       @type {Boolean}
       @default false
       @htmlattribute readonly
       @htmlattributereflected
       */

    }, {
      key: "readOnly",
      get: function get() {
        return this._readOnly || false;
      },
      set: function set(value) {
        this._readOnly = transform.booleanAttr(value);

        this._reflectAttribute('readonly', this._readOnly);

        this.classList.toggle('is-readOnly', this._readOnly);
        this._elements.input.tabIndex = this._readOnly ? -1 : 0;
      }
      /**
       Inherited from {@link BaseFormField#labelled}.
       */

    }, {
      key: "labelled",
      get: function get() {
        return _get(_getPrototypeOf(Checkbox.prototype), "labelled", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(Checkbox.prototype), "labelled", value, this, true);

        this._hideLabelIfEmpty();
      }
      /**
       Inherited from {@link BaseFormField#labelledBy}.
       */

    }, {
      key: "labelledBy",
      get: function get() {
        return _get(_getPrototypeOf(Checkbox.prototype), "labelledBy", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(Checkbox.prototype), "labelledBy", value, this, true);

        this._hideLabelIfEmpty();
      }
      /**
       Inherited from {@link BaseComponent#trackingElement}.
       */

    }, {
      key: "trackingElement",
      get: function get() {
        // it uses the name as the first fallback since it is not localized, otherwise it uses the label
        return typeof this._trackingElement === 'undefined' ? // keep spaces to only 1 max and trim. this mimics native html behaviors
        (this.name ? "".concat(this.name, "=").concat(this.value) : '') || (this.label || this).textContent.replace(/\s{2,}/g, ' ').trim() : this._trackingElement;
      },
      set: function set(value) {
        _set(_getPrototypeOf(Checkbox.prototype), "trackingElement", value, this, true);
      }
      /*
       Indicates to the formField that the 'checked' property needs to be set in this component.
        @protected
       */

    }, {
      key: "_componentTargetProperty",
      get: function get() {
        return 'checked';
      }
      /*
       Indicates to the formField that the 'checked' property has to be extracted from the event.
        @protected
       */

    }, {
      key: "_eventTargetProperty",
      get: function get() {
        return 'checked';
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-checkbox-label': 'label'
        };
      }
      /** @ignore */

    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(Checkbox), "observedAttributes", this).concat(['indeterminate', 'checked']);
      }
    }]);

    return Checkbox;
  }(BaseFormField(BaseComponent(HTMLElement)));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Checkbox.Label
   @classdesc The Checkbox label
   @htmltag coral-checkbox-label
   @return {HTMLElement}
   */
  var CheckboxLabel = (function () {
    return document.createElement('coral-checkbox-label');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons.extend(strings, {
    'coral-component-checkbox': translations$8
  }); // Expose component on the Coral namespace

  commons._define('coral-checkbox', Checkbox);

  Checkbox.Label = CheckboxLabel;

  /**
   @class Coral.CheckboxGroup
   @classdesc A CheckboxGroup component to group checkbox fields
   @htmltag coral-checkboxgroup
   @extends {HTMLElement}
   @extends {BaseComponent}
   @extends {BaseFieldGroup}
   */

  var CheckboxGroup = /*#__PURE__*/function (_BaseFieldGroup) {
    _inherits(CheckboxGroup, _BaseFieldGroup);

    var _super = _createSuper(CheckboxGroup);

    function CheckboxGroup() {
      _classCallCheck(this, CheckboxGroup);

      return _super.apply(this, arguments);
    }

    _createClass(CheckboxGroup, [{
      key: "_itemTagName",

      /** @private */
      get: function get() {
        // Used for Collection
        return 'coral-checkbox';
      }
      /**
       Returns an Array containing the selected field group items.
        @type {Array.<HTMLElement>}
       @readonly
       */

    }, {
      key: "selectedItems",
      get: function get() {
        return this.items._getAllSelected('checked');
      }
    }]);

    return CheckboxGroup;
  }(BaseFieldGroup(BaseComponent(HTMLElement)));

  /**
   * Copyright 2020 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons._define('coral-checkboxgroup', CheckboxGroup);

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  // todo add tests
  // Used to store DateTimeFormat
  var dateTimeFormats = {}; // Default supported format

  var DEFAULT_FORMAT = 'YYYY-MM-DD';

  var transform2digit = function transform2digit(value) {
    var s = value.toString();
    return s.length === 1 ? "0".concat(s) : s;
  }; // Default locale


  var globalLocale = document.documentElement.lang || window.navigator.language || 'en-US'; // Uses Intl.DateTimeFormat to return a formatted date string

  var formatDate = function formatDate(date, locale, options) {
    var formattedDateString = '';

    try {
      var key = "".concat(JSON.stringify(locale)).concat(JSON.stringify(options));
      var dateTimeFormat = dateTimeFormats[key]; // Use existing DateTimeFormat or create new one

      if (!dateTimeFormat) {
        dateTimeFormats[key] = new window.Intl.DateTimeFormat(locale, options);
      } // Format to string


      formattedDateString = dateTimeFormats[key].format(date);
    } catch (e) {
      console.warn(e.message);
    }

    return formattedDateString;
  };
  /**
   The DateTime API is used as fallback to {@link momentJS}.

   @param {DateTime|Date|Array<Number>|String} value
   The initial date value. If none provided, the current day is used instead.
   */


  var DateTime = /*#__PURE__*/function () {
    /**
     @see https://momentjs.com/docs/#/parsing/now/
     */
    function DateTime(value) {
      _classCallCheck(this, DateTime);

      if (value instanceof this.constructor) {
        // Copy properties
        this._locale = value._locale;
        this._value = value._value;
        this._date = value._date;
      } else {
        this._locale = globalLocale;
        this._value = value; // Support Array

        if (Array.isArray(value)) {
          this._date = value.length ? new Date(value[0], value[1] || 0, value[2] || 1) : new Date();
        } else if (typeof value === 'string') {
          var isTime = value.indexOf(':') === 2; // For time, we only need to set hours and minutes using current date

          if (isTime) {
            var time = value.split(':');
            var hours = parseInt(time[0], 10);
            var minutes = parseInt(time[1], 10);

            if (hours >= 0 && hours <= 23 && minutes >= 0 && minutes <= 59) {
              this._date = new Date();

              this._date.setHours(time[0]);

              this._date.setMinutes(time[1]);
            } else {
              this._date = new Date('Invalid Date');
            }
          } else {
            // If string is invalid, the date will be invalid too
            // "replace" fixes the one day off issue
            this._date = new Date(this._value.replace(/-/g, '/').replace(/T.+/, ''));
          }
        } else if (this._value === null) {
          this._date = new Date('Invalid Date');
        } else {
          // Create a Date instance from the value or use current day if value is missing
          this._date = this._value ? new Date(this._value) : new Date();
        }
      }
    }
    /**
     @see https://momentjs.com/docs/#/i18n/instance-locale/
     */


    _createClass(DateTime, [{
      key: "locale",
      value: function locale(value) {
        if (value) {
          this._locale = value;
        }

        return this._locale;
      }
      /**
       @see https://momentjs.com/docs/#/displaying/as-javascript-date/
       */

    }, {
      key: "toDate",
      value: function toDate() {
        return this._date;
      }
      /**
       @see https://momentjs.com/docs/#/parsing/moment-clone/
       */

    }, {
      key: "clone",
      value: function clone() {
        var clone = new this.constructor(this._value);
        clone._date = this._date;
        return clone;
      }
      /**
       @see https://momentjs.com/docs/#/displaying/format/
       */

    }, {
      key: "format",
      value: function format(_format) {
        var formattedDateString = '';

        if (!_format) {
          _format = DEFAULT_FORMAT;
        }

        if (_format === DEFAULT_FORMAT) {
          formattedDateString += this._date.getFullYear();
          formattedDateString += '-';
          formattedDateString += transform2digit(this._date.getMonth() + 1);
          formattedDateString += '-';
          formattedDateString += transform2digit(this._date.getDate());
        } else if (_format === 'MMMM YYYY') {
          formattedDateString += formatDate(this._date, this._locale, {
            month: 'long'
          });
          formattedDateString += ' ';
          formattedDateString += this._date.getFullYear();
        } else if (_format === 'LL') {
          formattedDateString += formatDate(this._date, this._locale, {
            month: 'long',
            year: 'numeric',
            day: '2-digit'
          });
        } else if (_format === 'dd') {
          formattedDateString += formatDate(this._date, this._locale, {
            weekday: 'short'
          });
        } else if (_format === 'dddd') {
          formattedDateString += formatDate(this._date, this._locale, {
            weekday: 'long'
          });
        } else if (_format === 'HH:mm') {
          formattedDateString += transform2digit(this._date.getHours());
          formattedDateString += ':';
          formattedDateString += transform2digit(this._date.getMinutes());
        } else if (_format === 'HH') {
          formattedDateString += transform2digit(this._date.getHours());
        } else if (_format === 'mm') {
          formattedDateString += transform2digit(this._date.getMinutes());
        } else if (_format === 'YYYY-MM-DD[T]HH:mmZ') {
          formattedDateString += this._date.getFullYear();
          formattedDateString += '-';
          formattedDateString += transform2digit(this._date.getMonth() + 1);
          formattedDateString += '-';
          formattedDateString += transform2digit(this._date.getDate());
          formattedDateString += 'T';
          formattedDateString += transform2digit(this._date.getHours());
          formattedDateString += ':';
          formattedDateString += transform2digit(this._date.getMinutes());
          var timezone = -1 * (this._date.getTimezoneOffset() / 60);
          var abs = Math.abs(timezone);
          abs = abs < 10 ? "0".concat(abs) : abs.toString();
          formattedDateString += timezone < 0 ? "-".concat(abs, ":00") : "+".concat(abs, ":00");
        } else {
          _format = _typeof(_format) === 'object' ? _format : {};
          formattedDateString = formatDate(this._date, this._locale, _format);
        }

        return formattedDateString;
      }
      /**
       @see https://momentjs.com/docs/#/get-set/year/
       */

    }, {
      key: "year",
      value: function year() {
        return this._date.getFullYear();
      }
      /**
       @see https://momentjs.com/docs/#/get-set/month/
       */

    }, {
      key: "month",
      value: function month() {
        return this._date.getMonth();
      }
      /**
       @see https://momentjs.com/docs/#/get-set/week/
       */

    }, {
      key: "week",
      value: function week() {
        // Source : https://stackoverflow.com/questions/6117814/get-week-of-year-in-javascript-like-in-php
        var date = new Date(Date.UTC(this._date.getFullYear(), this._date.getMonth(), this._date.getDate()));
        var dayNum = date.getUTCDay() || 7;
        date.setUTCDate(date.getUTCDate() + 4 - dayNum);
        var yearStart = new Date(Date.UTC(date.getUTCFullYear(), 0, 1));
        return Math.ceil(((date - yearStart) / 86400000 + 1) / 7);
      }
      /**
       @see https://momentjs.com/docs/#/get-set/day/
       */

    }, {
      key: "day",
      value: function day(_day) {
        if (typeof _day === 'number') {
          this._date.setDate(this._date.getDate() - (this._date.getDay() || 7) + _day);

          return this;
        }

        return this._date.getDay();
      }
      /**
       @see https://momentjs.com/docs/#/get-set/hour/
       */

    }, {
      key: "hours",
      value: function hours(_hours) {
        if (typeof _hours === 'number') {
          this._date.setHours(_hours);

          return this;
        }

        return this._date.getHours();
      }
      /**
       @see https://momentjs.com/docs/#/get-set/minute/
       */

    }, {
      key: "minutes",
      value: function minutes(_minutes) {
        if (typeof _minutes === 'number') {
          this._date.setMinutes(_minutes);

          return this;
        }

        return this._date.getMinutes();
      }
      /**
       @see https://momentjs.com/docs/#/get-set/date/
       */

    }, {
      key: "date",
      value: function date() {
        return this._date.getDate();
      }
      /**
       @see https://momentjs.com/docs/#/manipulating/add/
       */

    }, {
      key: "add",
      value: function add(value, type) {
        if (type.indexOf('month') === 0) {
          this._date.setMonth(this._date.getMonth() + value);
        } else if (type.indexOf('day') === 0) {
          this._date.setDate(this._date.getDate() + value);
        }

        return this;
      }
      /**
       @see https://momentjs.com/docs/#/manipulating/subtract/
       */

    }, {
      key: "subtract",
      value: function subtract(value, type) {
        if (type.indexOf('month') === 0) {
          this._date.setMonth(this._date.getMonth() - value);
        } else if (type.indexOf('day') === 0) {
          this._date.setDate(this._date.getDate() - value);
        }

        return this;
      }
      /**
       @see https://momentjs.com/docs/#/displaying/difference/
       */

    }, {
      key: "diff",
      value: function diff(obj) {
        var diff = this._date.getTime() - obj._date.getTime();

        return diff / 86400000;
      }
      /**
       @see https://momentjs.com/docs/#/manipulating/start-of/
       */

    }, {
      key: "startOf",
      value: function startOf(value) {
        if (value === 'day') {
          // Today
          this._date = new Date(this._date.getFullYear(), this._date.getMonth(), this._date.getDate());
        } else if (value === 'month') {
          this._date = new Date(this._date.getFullYear(), this._date.getMonth(), 1);
        } else if (value === 'year') {
          this._date = new Date(new Date().getFullYear(), 0, 1);
        }

        return this;
      }
      /**
       @see https://momentjs.com/docs/#/query/is-before/
       */

    }, {
      key: "isBefore",
      value: function isBefore(coralDate, unit) {
        if (coralDate && coralDate._date) {
          return unit ? coralDate[unit]() > this[unit]() : coralDate._date > this._date;
        }

        return false;
      }
      /**
       @see https://momentjs.com/docs/#/query/is-after/
       */

    }, {
      key: "isAfter",
      value: function isAfter(coralDate, unit) {
        if (coralDate && coralDate._date) {
          return unit ? coralDate[unit]() < this[unit]() : coralDate._date < this._date;
        }

        return false;
      }
      /**
       @see https://momentjs.com/docs/#/query/is-same/
       */

    }, {
      key: "isSame",
      value: function isSame(obj, type) {
        if (type === 'hour') {
          return obj && obj.clone()._date.getHours() === this.clone()._date.getHours();
        } else if (type === 'minute') {
          return obj && obj.clone()._date.getMinutes() === this.clone()._date.getMinutes();
        } else if (type === 'day') {
          return obj && obj.clone().startOf('day')._date.getTime() === this.clone().startOf('day')._date.getTime();
        }

        return obj && obj.clone()._date.getTime() === this.clone()._date.getTime();
      }
      /**
       @see https://momentjs.com/docs/#/parsing/is-valid/
       */

    }, {
      key: "isValid",
      value: function isValid() {
        return this._date.toString() !== 'Invalid Date';
      }
      /**
       @ignore
       Not supported so we return an empty object
       */

    }], [{
      key: "localeData",
      value: function localeData() {
        return {};
      }
      /**
       @see https://momentjs.com/docs/#/i18n/changing-locale/
       */

    }, {
      key: "locale",
      value: function locale(value) {
        if (value) {
          globalLocale = value;
        }

        return globalLocale;
      }
      /**
       @see https://momentjs.com/docs/#/query/is-a-moment/
       */

    }, {
      key: "isMoment",
      value: function isMoment(obj) {
        return obj instanceof this;
      }
      /**
       @return {momentJS|DateTime}
       */

    }, {
      key: "Moment",
      get: function get() {
        return window.moment || this;
      }
    }]);

    return DateTime;
  }();

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  if (typeof window.moment !== 'undefined') {
    window.moment.locale(document.documentElement.lang || window.navigator.language || 'en');
  }

  var PAGE_UP = 33;
  var PAGE_DOWN = 34;
  var LEFT_ARROW = 37;
  var UP_ARROW = 38;
  /**
   Enumeration for {@link Accordion} variants.

   @typedef {Object} AccordionVariantEnum

   @property {String} DEFAULT
   Default look and feel.
   @property {String} QUIET
   Not supported. Falls back to DEFAULT.
   @property {String} LARGE
   Not supported. Falls back to DEFAULT.
   */

  var variant$8 = {
    DEFAULT: 'default',
    QUIET: 'quiet',
    LARGE: 'large'
  }; // the accordions's base classname

  var CLASSNAME$r = '_coral-Accordion';
  /**
   @class Coral.Accordion
   @classdesc An Accordion component consisting of multiple collapsible items.
   @htmltag coral-accordion
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var Accordion = /*#__PURE__*/function (_BaseComponent) {
    _inherits(Accordion, _BaseComponent);

    var _super = _createSuper(Accordion);

    /** @ignore */
    function Accordion() {
      var _this;

      _classCallCheck(this, Accordion);

      _this = _super.call(this); // Attach events

      _this._delegateEvents({
        'click coral-accordion-item:not([disabled]) ._coral-Accordion-itemHeader': '_onItemClick',
        'key:space ._coral-Accordion-itemHeader': '_onToggleItemKey',
        'key:return ._coral-Accordion-itemHeader': '_onToggleItemKey',
        'key:pageup ._coral-Accordion-itemHeader': '_focusPreviousItem',
        'key:left ._coral-Accordion-itemHeader': '_focusPreviousItem',
        'key:up ._coral-Accordion-itemHeader': '_focusPreviousItem',
        'key:pagedown ._coral-Accordion-itemHeader': '_focusNextItem',
        'key:right ._coral-Accordion-itemHeader': '_focusNextItem',
        'key:down ._coral-Accordion-itemHeader': '_focusNextItem',
        'key:home ._coral-Accordion-itemHeader': '_onHomeKey',
        'key:end ._coral-Accordion-itemHeader': '_onEndKey',
        'keydown ._coral-Accordion-itemHeader': '_onItemContentKeyDown',
        // private
        'coral-accordion-item:_selectedchanged': '_onItemSelectedChanged'
      }); // Used for eventing


      _this._oldSelection = []; // Init the collection mutation observer

      _this.items._startHandlingItems(true);

      return _this;
    }
    /**
     The Accordion's variant. See {@link AccordionVariantEnum}.
      @type {String}
     @default AccordionVariantEnum.DEFAULT
     @htmlattribute variant
     @htmlattributereflected
     */


    _createClass(Accordion, [{
      key: "_onHomeKey",

      /** @private */
      value: function _onHomeKey(event) {
        event.preventDefault();
        event.stopPropagation();

        this._focusItem(this.items._getFirstSelectable());
      }
      /** @private */

    }, {
      key: "_onEndKey",
      value: function _onEndKey(event) {
        event.preventDefault();
        event.stopPropagation();

        this._focusItem(this.items._getLastSelectable());
      }
      /**
       References:
       http://www.w3.org/WAI/PF/aria-practices/#accordion &
        Handlers for when focus is on an element inside of the panel:
       http://test.cita.illinois.edu/aria/tabpanel/tabpanel2.php
        @private
       */

    }, {
      key: "_onItemContentKeyDown",
      value: function _onItemContentKeyDown(event) {
        // Required since sometimes the value is a number
        var key = parseFloat(event.keyCode);
        var item = event.matchedTarget.parentNode;

        switch (key) {
          case UP_ARROW:
          case LEFT_ARROW:
            // Set focus on the tab button for the currently displayed tab.
            if ((event.metaKey || event.ctrlKey) && Keys.filterInputs(event)) {
              event.preventDefault();
              event.stopPropagation();

              this._focusItem(item);
            }

            break;

          case PAGE_UP:
            // Show the previous tab and set focus on its corresponding tab button. Shows the last tab in the panel if
            // current tab is the first one.
            if (event.metaKey || event.ctrlKey) {
              event.preventDefault();
              event.stopPropagation();

              var prevItem = this.items._getPreviousSelectable(item);

              this._toggleItemSelection(prevItem);

              this._focusItem(prevItem);
            }

            break;

          case PAGE_DOWN:
            // Show the next tab and set focus on its corresponding tab button. Shows the first tab in the panel if current
            // tab is the last one.
            if (event.metaKey || event.ctrlKey) {
              event.preventDefault();
              event.stopPropagation();

              var nextItem = this.items._getNextSelectable(item);

              this._toggleItemSelection(nextItem);

              this._focusItem(nextItem);
            }

            break;
        }
      }
      /** @private */

    }, {
      key: "_focusPreviousItem",
      value: function _focusPreviousItem(event) {
        event.preventDefault();
        event.stopPropagation();

        this._focusItem(this.items._getPreviousSelectable(event.target.closest('coral-accordion-item')));
      }
      /** @private */

    }, {
      key: "_focusNextItem",
      value: function _focusNextItem(event) {
        event.preventDefault();
        event.stopPropagation();

        this._focusItem(this.items._getNextSelectable(event.target.closest('coral-accordion-item')));
      }
      /** @private */

    }, {
      key: "_onItemClick",
      value: function _onItemClick(event) {
        // Clickable elements included in an item header shouldn't automatically trigger the selection of that item
        if (event.target.hasAttribute('coral-interactive') || event.target.closest('[coral-interactive]')) {
          return;
        } // The click was performed on the header so we select the item (parentNode) the selection is toggled


        var item = event.target.closest('coral-accordion-item');

        if (item) {
          event.preventDefault();
          event.stopPropagation();

          this._toggleItemSelection(item);

          this._focusItem(item);
        }
      }
      /** @private */

    }, {
      key: "_onToggleItemKey",
      value: function _onToggleItemKey(event) {
        event.preventDefault();
        event.stopPropagation();
        var item = event.target.closest('coral-accordion-item');

        this._toggleItemSelection(item);

        this._focusItem(item);
      }
      /** @private */

    }, {
      key: "_onItemSelectedChanged",
      value: function _onItemSelectedChanged(event) {
        event.stopImmediatePropagation();

        this._validateSelection(event.target);
      }
      /** @private */

    }, {
      key: "_validateSelection",
      value: function _validateSelection(item) {
        var _this2 = this;

        var selectedItems = this.selectedItems;

        if (!this.multiple) {
          // Last selected item wins if multiple selection while not allowed
          item = item || selectedItems[selectedItems.length - 1];

          if (item && item.hasAttribute('selected') && selectedItems.length > 1) {
            selectedItems.forEach(function (selectedItem) {
              if (selectedItem !== item) {
                // Don't trigger change events
                _this2._preventTriggeringEvents = true;
                selectedItem.removeAttribute('selected');
              }
            }); // We can trigger change events again

            this._preventTriggeringEvents = false;
          }
        } // set items level appropriately


        if (item && item.getAttribute('level') !== this.level) {
          item.setAttribute('level', this.level);
        }

        this._resetTabTarget();

        this._triggerChangeEvent();
      }
      /** @private */

    }, {
      key: "_triggerChangeEvent",
      value: function _triggerChangeEvent() {
        var selectedItems = this.selectedItems;
        var oldSelection = this._oldSelection;

        if (!this._preventTriggeringEvents && this._arraysAreDifferent(selectedItems, oldSelection)) {
          // We differentiate whether multiple is on or off and return an array or HTMLElement respectively
          if (this.multiple) {
            this.trigger('coral-accordion:change', {
              oldSelection: oldSelection,
              selection: selectedItems
            });
          } else {
            // Return all items if we just switched from multiple=true to multiple=false and we had >1 selected items
            this.trigger('coral-accordion:change', {
              oldSelection: oldSelection.length > 1 ? oldSelection : oldSelection[0] || null,
              selection: selectedItems[0] || null
            });
          }

          this._oldSelection = selectedItems;
        }
      }
      /** @private */

    }, {
      key: "_arraysAreDifferent",
      value: function _arraysAreDifferent(selection, oldSelection) {
        var diff = [];

        if (oldSelection.length === selection.length) {
          diff = oldSelection.filter(function (item) {
            return selection.indexOf(item) === -1;
          });
        } // since we guarantee that they are arrays, we can start by comparing their size


        return oldSelection.length !== selection.length || diff.length !== 0;
      }
      /**
       Determine what item should get focus (if any) when the user tries to tab into the accordion. This should be the
       first selected panel, or the first selectable panel otherwise. When neither is available, to Accordion cannot be
       tabbed into.
        @private
       */

    }, {
      key: "_resetTabTarget",
      value: function _resetTabTarget() {
        var _this3 = this;

        if (!this._resetTabTargetScheduled) {
          this._resetTabTargetScheduled = true;
          window.requestAnimationFrame(function () {
            _this3._resetTabTargetScheduled = false; // since hidden items cannot have focus, we need to make sure the tabTarget is not hidden

            var selectedItems = _this3.items._getAllSelected();

            _this3._tabTarget = selectedItems.length ? selectedItems[0] : _this3.items._getFirstSelectable();
          });
        }
      }
      /** @private */

    }, {
      key: "_toggleItemSelection",
      value: function _toggleItemSelection(item) {
        if (item) {
          item[item.hasAttribute('selected') ? 'removeAttribute' : 'setAttribute']('selected', '');
        }
      }
      /** @private */

    }, {
      key: "_focusItem",
      value: function _focusItem(item) {
        if (item) {
          item._elements.button.focus();
        }

        this._tabTarget = item;
      }
      /**
       Returns {@link Accordion} variants.
        @return {AccordionVariantEnum}
       */

    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        var _this4 = this;

        _get(_getPrototypeOf(Accordion.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$r); // Default reflected attributes

        if (!this._variant) {
          this.variant = variant$8.DEFAULT;
        } // WAI-ARIA 1.1


        this.setAttribute('role', 'region'); // Don't trigger events once connected

        this._preventTriggeringEvents = true;

        this._validateSelection();

        this._preventTriggeringEvents = false;
        this._oldSelection = this.selectedItems; // Don't trigger animations on rendering

        window.requestAnimationFrame(function () {
          _this4.classList.add("".concat(CLASSNAME$r, "--animated"));
        });
      }
      /**
       Triggered when {@link Accordion} selected item has changed.
        @typedef {CustomEvent} coral-accordion:change
        @property {AccordionItem} detail.oldSelection
       The prior selected item(s).
       @property {AccordionItem} detail.selection
       The newly selected item(s).
       */

    }, {
      key: "variant",
      get: function get() {
        return this._variant || variant$8.DEFAULT;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        this._variant = validate.enumeration(variant$8)(value) && value || variant$8.DEFAULT;

        this._reflectAttribute('variant', this._variant);
      }
      /**
       The Collection Interface that allows interacting with the items that the component contains.
        @type {Collection}
       @readonly
       */

    }, {
      key: "items",
      get: function get() {
        // just init on demand
        if (!this._items) {
          this._items = new SelectableCollection({
            host: this,
            itemTagName: 'coral-accordion-item',
            // allows accordions to be nested
            itemSelector: ':scope > coral-accordion-item',
            onItemAdded: this._validateSelection,
            onItemRemoved: this._validateSelection
          });
        }

        return this._items;
      }
      /**
       Indicates whether the accordion accepts multiple selected items.
       @type {Boolean}
       @default false
       @htmlattribute multiple
       @htmlattributereflected
       */

    }, {
      key: "multiple",
      get: function get() {
        return this._multiple || false;
      },
      set: function set(value) {
        this._multiple = transform.booleanAttr(value);

        this._reflectAttribute('multiple', this._multiple);

        this._validateSelection();
      }
      /**
       Returns an Array containing the set selected items.
       @type {Array.<AccordionItem>}
       @readonly
       */

    }, {
      key: "selectedItems",
      get: function get() {
        return this.items._getAllSelected();
      }
      /**
       Returns the first selected item in the Accordion. The value <code>null</code> is returned if no element is
       selected.
       @type {AccordionItem}
       @readonly
       */

    }, {
      key: "selectedItem",
      get: function get() {
        return this.items._getFirstSelected();
      }
      /**
       The heading level for Accordion items within the Accordion
        @type {Number}
       @default 3
       @htmlattribute level
       @htmlattributereflected
       */

    }, {
      key: "level",
      get: function get() {
        return this._level || 3;
      },
      set: function set(value) {
        var _this5 = this;

        value = transform.number(value);

        if (validate.valueMustChange(value, this._level) && value > 0 && value < 7) {
          this._level = value;

          this._reflectAttribute('level', this._level);

          this.items.getAll().forEach(function (item) {
            return item.setAttribute('level', _this5._level);
          });
        }
      }
      /** @private **/

    }, {
      key: "_tabTarget",
      get: function get() {
        return this.__tabTarget || null;
      },
      set: function set(value) {
        this.__tabTarget = value; // Set all but the current set _tabTarget to not be a tab target:

        this.items.getAll().forEach(function (item) {
          item._isTabTarget = item === value;
        });
      }
    }], [{
      key: "variant",
      get: function get() {
        return variant$8;
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(Accordion), "observedAttributes", this).concat(['variant', 'multiple', 'level']);
      }
    }]);

    return Accordion;
  }(BaseComponent(HTMLElement));

  var template$c = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var data = data_0 = typeof data_0 === "undefined" ? {} : data_0;
    var el0 = this["heading"] = document.createElement("h3");
    el0.setAttribute("handle", "heading");
    el0.className += " _coral-Accordion-itemHeading";
    var el1 = document.createTextNode("\n  ");
    el0.appendChild(el1);
    var el2 = this["button"] = document.createElement("button");
    el2.setAttribute("handle", "button");
    el2.className += " _coral-Accordion-itemHeader";
    el2.setAttribute("type", "button");
    el0.appendChild(el2);
    var el3 = document.createTextNode("\n  ");
    el0.appendChild(el3);
    data = data_0;
    var iconId = 'spectrum-css-icon-ChevronRightMedium';
    var classes = ['_coral-Accordion-itemIndicator', '_coral-UIIcon-ChevronRightMedium'];
    this.button.insertAdjacentHTML('afterend', data.Icon._renderSVG(iconId, classes));
    data_0 = data;
    var el5 = document.createTextNode("\n");
    el0.appendChild(el5);
    frag.appendChild(el0);
    var el6 = document.createTextNode("\n");
    frag.appendChild(el6);
    return frag;
  };

  var CLASSNAME$s = '_coral-Accordion-item';
  /**
   @class Coral.Accordion.Item
   @classdesc A Accordion item component
   @htmltag coral-accordion-item
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var AccordionItem = /*#__PURE__*/function (_BaseComponent) {
    _inherits(AccordionItem, _BaseComponent);

    var _super = _createSuper(AccordionItem);

    /** @ignore */
    function AccordionItem() {
      var _this;

      _classCallCheck(this, AccordionItem);

      _this = _super.call(this); // Prepare templates

      _this._elements = {
        // Create or fetch the content zones
        label: _this.querySelector('coral-accordion-item-label') || document.createElement('coral-accordion-item-label'),
        content: _this.querySelector('coral-accordion-item-content') || document.createElement('coral-accordion-item-content')
      };
      template$c.call(_this._elements, {
        Icon: Icon
      });
      return _this;
    }
    /**
     The label of this accordion item.
      @type {AccordionItemLabel}
     @contentzone
     */


    _createClass(AccordionItem, [{
      key: "_setAria",
      value: function _setAria(button, content) {
        button.id = button.id || commons.getUID();
        content.id = content.id || commons.getUID();
        button.setAttribute('aria-controls', content.id);
        content.setAttribute('aria-labelledby', button.id);
      }
      /**
       Handles the focus of the item.
        @ignore
       */

    }, {
      key: "focus",
      value: function focus() {
        this._elements.label.focus();
      }
    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(AccordionItem.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$s); // a11y

        this.setAttribute('role', 'presentation'); // Support cloneNode

        var template = this.querySelector('._coral-Accordion-itemHeading');

        if (template) {
          template.remove();
        } // Move content into the content zone if not specified


        if (!this._elements.content.parentNode) {
          while (this.firstChild) {
            this._elements.content.appendChild(this.firstChild);
          }
        }

        this.appendChild(this._elements.heading); // Assign the content zones, moving them into place in the process

        this.label = this._elements.label;
        this.content = this._elements.content; // Defaults

        this.selected = this.selected;
      }
    }, {
      key: "label",
      get: function get() {
        return this._getContentZone(this._elements.label);
      },
      set: function set(value) {
        this._setContentZone('label', value, {
          handle: 'label',
          tagName: 'coral-accordion-item-label',
          insert: function insert(label) {
            this._setAria(this._elements.button, this._elements.content);

            this._elements.button.appendChild(label);
          }
        });
      }
      /**
       The content of this accordion item.
        @type {AccordionItemContent}
       @contentzone
       */

    }, {
      key: "content",
      get: function get() {
        return this._getContentZone(this._elements.content);
      },
      set: function set(value) {
        this._setContentZone('content', value, {
          handle: 'content',
          tagName: 'coral-accordion-item-content',
          insert: function insert(content) {
            content.classList.add("".concat(CLASSNAME$s, "Content")); // WAI-ARIA 1.1

            content.setAttribute('role', 'region');

            this._setAria(this._elements.button, content);

            this.appendChild(content);
          }
        });
      }
      /**
       Whether the item is selected. If the item has an element with the `coral-interactive` attribute and is clicked,
       then the toggling of the accordion item will not occur.
        @type {Boolean}
       @default false
       @htmlattribute selected
       @htmlattributereflected
       */

    }, {
      key: "selected",
      get: function get() {
        return this._selected || false;
      },
      set: function set(value) {
        var _this2 = this;

        var _value = transform.booleanAttr(value);

        var _selected = this.hasAttribute('disabled') ? false : _value;

        if (this._selected === _selected) {
          return;
        }

        this._selected = _selected;

        this._reflectAttribute('selected', this._selected); // Read it before applying is-open which adds additional padding


        var scrollHeight = this._elements.content.scrollHeight;
        this.classList.toggle('is-open', this._selected);

        this._elements.button.setAttribute('aria-expanded', this._selected);

        if (!this._selected) {
          this._elements.content.style.height = "".concat(scrollHeight, "px"); // We read the offset height to force a reflow, this is needed to start the transition between absolute values
          // https://blog.alexmaccaw.com/css-transitions under Redrawing
          // eslint-disable-next-line no-unused-vars

          var offsetHeight = this._elements.content.offsetHeight;
        }

        this._elements.content.style.height = this._selected ? "".concat(scrollHeight, "px") : '0';

        if (this._selected) {
          commons.transitionEnd(this._elements.content, function () {
            _this2._elements.content.style.height = '';
          });
        }

        this.trigger('coral-accordion-item:_selectedchanged');
      }
      /**
       Whether this item is disabled.
       @type {Boolean}
       @default false
       @htmlattribute disabled
       @htmlattributereflected
       */

    }, {
      key: "disabled",
      get: function get() {
        return this._disabled || false;
      },
      set: function set(value) {
        this._disabled = transform.booleanAttr(value);

        this._reflectAttribute('disabled', this._disabled);

        this.classList.toggle('is-disabled', this._disabled);

        this._elements.button[this._disabled ? 'setAttribute' : 'removeAttribute']('disabled', '');

        this.selected = this.selected;
      }
      /**
       The heading level for the Accordion item
        @type {Number}
       @default 3
       @htmlattribute level
       @htmlattributereflected
       */

    }, {
      key: "level",
      get: function get() {
        return this._level || 3;
      },
      set: function set(value) {
        value = transform.number(value); // If the value has changed,

        if (!validate.valueMustChange(value, this._level)) {
          return;
        } // and the value is greater than 0


        if (value > 0) {
          // set the value and reflect the attribute.
          this._level = value;

          this._reflectAttribute('level', this._level); // If the new value is not equal to the default,


          if (value !== 3) {
            // override the aria-level on the h3 element.
            this._elements.heading.setAttribute('aria-level', this._level);

            return;
          }
        } // If the value is the default or invalid, remove the aria-level override from the h3 element.


        this._elements.heading.removeAttribute('aria-level');
      }
      /** @private **/

    }, {
      key: "_isTabTarget",
      get: function get() {
        return this.__isTabTarget || false;
      },
      set: function set(value) {
        this.__isTabTarget = value;

        if (this.disabled) {
          this._elements.button.removeAttribute('tabindex');
        } else {
          this._elements.button.setAttribute('tabindex', this.__isTabTarget ? '0' : '-1');
        }
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-accordion-item-label': 'label',
          'coral-accordion-item-content': 'content'
        };
      }
      /** @ignore */

    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(AccordionItem), "observedAttributes", this).concat(['selected', 'disabled', 'level']);
      }
    }]);

    return AccordionItem;
  }(BaseComponent(HTMLElement));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Accordion.Item.Label
   @classdesc Accordion item's label component
   @htmltag coral-accordion-item-label
   @return {HTMLElement}
   */
  var AccordionItemLabel = (function () {
    return document.createElement('coral-accordion-item-label');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Accordion.Item.Content
   @classdesc Accordion item's content component
   @htmltag coral-accordion-item-content
   @return {HTMLElement}
   */
  var AccordionItemContent = (function () {
    return document.createElement('coral-accordion-item-content');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons._define('coral-accordion-item', AccordionItem);

  commons._define('coral-accordion', Accordion);

  Accordion.Item = AccordionItem;
  Accordion.Item.Label = AccordionItemLabel;
  Accordion.Item.Content = AccordionItemContent;

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var translations$9 = {
    "en-US": {
      "More": "More"
    },
    "de-DE": {
      "More": "Mehr"
    },
    "fr-FR": {
      "More": "Plus"
    },
    "it-IT": {
      "More": "Altro"
    },
    "ja-JP": {
      "More": "ãã®ä»"
    },
    "es-ES": {
      "More": "MÃ¡s"
    },
    "ko-KR": {
      "More": "ìì¸í"
    },
    "zh-CN": {
      "More": "æ´å¤"
    },
    "zh-TW": {
      "More": "æ´å¤"
    },
    "pt-BR": {
      "More": "Mais"
    },
    "nl-NL": {
      "More": "Meer"
    },
    "da-DK": {
      "More": "Mere"
    },
    "fi-FI": {
      "More": "LisÃ¤Ã¤"
    },
    "nb-NO": {
      "More": "Mer"
    },
    "sv-SE": {
      "More": "Mer"
    },
    "cs-CZ": {
      "More": "VÃ­ce"
    },
    "pl-PL": {
      "More": "WiÄcej"
    },
    "ru-RU": {
      "More": "ÐÐ¾Ð¿Ð¾Ð»Ð½Ð¸ÑÐµÐ»ÑÐ½Ð¾"
    },
    "tr-TR": {
      "More": "Daha Fazla"
    }
  };

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  /** @ignore */

  function getFirstSelectableWrappedItem(wrapperItem) {
    // util method to get first selectable item inside a wrapper item
    if (!wrapperItem) {
      return null;
    }

    if (wrapperItem.hasAttribute('coral-actionbar-more')) {
      // more buttons are no 'real' actionbar items => not wrapped
      return wrapperItem;
    }

    var child = null;

    for (var i = 0; i < wrapperItem.children.length; i++) {
      child = wrapperItem.children[i]; // maybe filter even more elements? (opacity, display='none', position='absolute' ...)

      if (child.offsetParent && (child.matches(commons.FOCUSABLE_ELEMENT_SELECTOR) || child.matches('a:not([href])'))) {
        return child;
      }
    } // search at 2nd level, some elements like coral-fileupload has selectable items inside them


    for (var _i = 0; _i < wrapperItem.children.length; _i++) {
      child = wrapperItem.children[_i];

      for (var j = 0; j < child.children.length; j++) {
        var subChild = child.children[j]; // maybe filter even more elements? (opacity, display='none', position='absolute' ...)

        if (subChild.offsetParent && (subChild.matches(commons.FOCUSABLE_ELEMENT_SELECTOR) || child.matches('a:not([href])'))) {
          return subChild;
        }
      }
    }

    return null;
  }

  var CLASSNAME$t = '_coral-ActionBar';
  /**
   @class Coral.ActionBar
   @classdesc An ActionBar component containing arbitrary items. An item can either be added to the left or the right side
   of the bar. All items that do not fit into the bar are hidden but still accessible.
   @htmltag coral-actionbar
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var ActionBar = /*#__PURE__*/function (_BaseComponent) {
    _inherits(ActionBar, _BaseComponent);

    var _super = _createSuper(ActionBar);

    /** @ignore */
    function ActionBar() {
      var _this;

      _classCallCheck(this, ActionBar);

      _this = _super.call(this); // Attach events

      _this._delegateEvents({
        'key:up': '_onFocusPreviousItem',
        'key:left': '_onFocusPreviousItem',
        'key:down': '_onFocusNextItem',
        'key:right': '_onFocusNextItem',
        'global:resize': '_onResizeWindow'
      }); // Prepare templates


      _this._elements = {
        // Fetch or create the content zone elements
        primary: _this.querySelector('coral-actionbar-primary') || document.createElement('coral-actionbar-primary'),
        secondary: _this.querySelector('coral-actionbar-secondary') || document.createElement('coral-actionbar-secondary')
      }; // Reference on all items

      _this._items = _this.getElementsByTagName('coral-actionbar-item'); // Debounce wait time in milliseconds

      _this._wait = 50; // bind this._onLayout so it can be removed again

      _this._onLayout = _this._onLayout.bind(_assertThisInitialized(_this));
      _this._debounceOnLayout = _this._debounceOnLayout.bind(_assertThisInitialized(_this)); // use the smart strategy instead of re-rendering every frame

      _this._recalculateLayoutOnMutation();

      return _this;
    }
    /**
     The primary (left) container of the ActionBar.
      @type {ActionBarPrimary}
     @contentzone
     */


    _createClass(ActionBar, [{
      key: "_recalculateLayoutOnMutation",

      /** @ignore */
      value: function _recalculateLayoutOnMutation() {
        var _this2 = this;

        // recalculate layout on dom element size change + on dom mutation
        // http://www.backalleycoder.com/2013/03/18/cross-browser-event-based-element-resize-detection/
        // relayout any time the dom changes
        this._observer = new MutationObserver(function () {
          _this2._debounceOnLayout();
        }); // Watch for changes

        this._observer.observe(this, {
          attributes: true,
          childList: true,
          characterData: true,
          subtree: true
        });
      }
      /** @ignore */

    }, {
      key: "_onFocusPreviousItem",
      value: function _onFocusPreviousItem(event) {
        // stops the page from scrolling
        event.preventDefault();

        var previousItem = this._getPreviousSelectableWrappedItem(event.target);

        if (previousItem !== null) {
          previousItem.focus();
        }
      }
      /** @ignore */

    }, {
      key: "_onFocusNextItem",
      value: function _onFocusNextItem(event) {
        // stops the page from scrolling
        event.preventDefault();

        var nextWrappedItem = this._getNextSelectableWrappedItem(event.target);

        if (nextWrappedItem !== null) {
          nextWrappedItem.focus();
        }
      }
      /** @ignore */

    }, {
      key: "_onResizeWindow",
      value: function _onResizeWindow() {
        // just close all popovers for now when screen is resized
        // there might be more popovers, then the 'more' popovers
        var popovers = this.getElementsByTagName('coral-popover');

        for (var i = 0; i < popovers.length; i++) {
          popovers[i].removeAttribute('open');
        } // force a relayout (needed especially if framerate during resize drops e.g.: in FF)


        this._debounceOnLayout();
      }
      /** @ignore */

    }, {
      key: "_onLayout",
      value: function _onLayout() {
        if (!this.primary || !this.primary._elements || !this.primary._elements.overlay || !this.secondary || !this.secondary._elements || !this.secondary._elements.overlay) {
          // while containers are not cached or no items are rendered do nothing
          return;
        }

        if (this.primary._elements.overlay.open === true || this.secondary._elements.overlay.open === true) {
          // while popovers are open do not relayout
          return;
        }

        var ERROR_MARGIN = 78;
        var primaryMore = this.primary._elements.moreButton;
        var secondaryMore = this.secondary._elements.moreButton;
        var leftItems = this.primary.items.getAll();
        var rightItems = this.secondary.items.getAll().reverse();
        var itemLeft = null;
        var itemRight = null;

        var widthCache = this._newWidthCache();

        var leftMoreButtonWidth = leftItems.length > 0 ? widthCache.getOuterWidth(primaryMore) : 0;
        var rightMoreButtonWidth = rightItems.length > 0 ? widthCache.getOuterWidth(secondaryMore) : 0; // Make it possible to set left/right padding to the containers

        var borderWidthLeftContainer = this.primary.offsetWidth - this.primary.getBoundingClientRect().width;
        var borderWidthRightContainer = this.secondary.offsetWidth - this.secondary.getBoundingClientRect().width;
        var primaryLeftOffset = this.primary.offsetLeft;
        var secondaryRightOffset = this.offsetWidth - (this.secondary.offsetLeft + this.secondary.offsetWidth);
        var availableWidth = this.offsetWidth - primaryLeftOffset - secondaryRightOffset - leftMoreButtonWidth - rightMoreButtonWidth - borderWidthLeftContainer - borderWidthRightContainer - ERROR_MARGIN;
        var currentUsedWidth = 0;
        var leftVisibleItems = 0;
        var rightVisibleItems = 0;
        var moreButtonLeftVisible = false;
        var moreButtonRightVisible = false;
        var showItem = false;
        var itemWidth = 0;

        for (var i = 0; i < leftItems.length || i < rightItems.length; i++) {
          itemLeft = i < leftItems.length ? leftItems[i] : null;
          itemRight = i < rightItems.length ? rightItems[i] : null; // first calculate visibility of left item

          showItem = false;

          if (itemLeft !== null) {
            if (itemLeft.hidden || itemLeft.style.display === 'none') {
              // item is hidden on purpose (we don't use it for layouting but do also not move offscreen) needed as it
              // might already have been moved offscreen before
              this._moveToScreen(itemLeft);
            } else {
              // if item is not hidden on purpose (hiding by actionBar due to space problems does not count) => layout
              // element
              if (!moreButtonLeftVisible && (this.primary.threshold <= 0 || leftVisibleItems < this.primary.threshold)) {
                // if threshold is not reached so far
                itemWidth = widthCache.getOuterWidth(itemLeft);

                if (currentUsedWidth + itemWidth < availableWidth) {
                  // if there is still enough space to show another item
                  showItem = true;
                } else if (leftVisibleItems === leftItems.length - 1 && currentUsedWidth + itemWidth < availableWidth + leftMoreButtonWidth) {
                  // if this is the last item and so far there have been no items hidden => don't show more button
                  showItem = true;
                }
              }

              if (showItem) {
                leftVisibleItems += 1;
                currentUsedWidth += itemWidth;

                this._moveToScreen(itemLeft);
              } else {
                this._hideItem(itemLeft);

                moreButtonLeftVisible = true;
              }

              if (leftVisibleItems === leftItems.length) {
                // left more button not needed => more free space available
                availableWidth += leftMoreButtonWidth;
                moreButtonLeftVisible = false;
              }
            }
          } // then calculate visibility of right item


          showItem = false;

          if (itemRight !== null) {
            if (itemRight.hidden || itemRight.style.display === 'none') {
              // item is hidden on purpose (we don't use it for layouting but do also not move offscreen) needed as it
              // might already have been moved offscreen before
              this._moveToScreen(itemRight);
            } else {
              // if item is not hidden on purpose (hiding by actionBar due to space problems does not count) => layout
              // element
              if (!moreButtonRightVisible && (this.secondary.threshold <= 0 || rightVisibleItems < this.secondary.threshold)) {
                // if threshold is not reached so far
                itemWidth = widthCache.getOuterWidth(itemRight);

                if (currentUsedWidth + itemWidth < availableWidth) {
                  // if there is still enough space to show another item
                  showItem = true;
                } else if (rightVisibleItems === rightItems.length - 1 && currentUsedWidth + itemWidth < availableWidth + rightMoreButtonWidth) {
                  // if this is the last item and so far there have been no items hidden => don't show more button
                  showItem = true;
                }
              }

              if (showItem) {
                rightVisibleItems += 1;
                currentUsedWidth += itemWidth;

                this._moveToScreen(itemRight);
              } else {
                this._hideItem(itemRight);

                moreButtonRightVisible = true;
              }

              if (rightVisibleItems === rightItems.length) {
                // left more button not needed => more free space available
                availableWidth += rightMoreButtonWidth;
                moreButtonRightVisible = false;
              }
            }
          }
        } // Handle tabs


        var primarySelectable = this.primary.items._getAllSelectable();

        var secondarySelectable = this.secondary.items._getAllSelectable();

        for (var _i = 0; _i < this._items.length; _i++) {
          this._toggleItemTabbable(this._items[_i], false);
        } // LEFT: Show or hide more buttons


        if (moreButtonLeftVisible) {
          this._moveToScreen(primaryMore, true);

          if (primarySelectable.length === 0) {
            this._toggleItemTabbable(primaryMore, true);
          } else {
            this._toggleItemTabbable(primaryMore, false);

            this._toggleItemTabbable(primarySelectable[0], true);
          }
        } else {
          this._moveToScreen(primaryMore, false);

          this._toggleItemTabbable(primaryMore, false);

          this._toggleItemTabbable(primarySelectable[0], true);
        } // RIGHT: Show or hide more buttons


        if (moreButtonRightVisible) {
          this._moveToScreen(secondaryMore, true);

          if (secondarySelectable.length === 0) {
            this._toggleItemTabbable(secondaryMore, true);
          } else {
            this._toggleItemTabbable(secondaryMore, false);

            this._toggleItemTabbable(secondarySelectable[0], true);
          }
        } else {
          this._moveToScreen(secondaryMore, false);

          this._toggleItemTabbable(secondaryMore, false);

          var tabbableItem = this.secondary.items._getAllSelectable()[0];

          if (tabbableItem) {
            this._toggleItemTabbable(tabbableItem, true);
          }
        } // re-calculate layout on element resize


        if (!this._resizeListenerAttached) {
          commons.addResizeListener(this, this._debounceOnLayout);
          commons.addResizeListener(this.primary, this._debounceOnLayout);
          commons.addResizeListener(this.secondary, this._debounceOnLayout);
          this._resizeListenerAttached = true;
        }
      }
      /** @ignore */

    }, {
      key: "_getNextSelectableWrappedItem",
      value: function _getNextSelectableWrappedItem(currentItem) {
        if (currentItem.parentNode.tagName === 'CORAL-ACTIONBAR-ITEM') {
          // currentItem is wrapped
          currentItem = currentItem.parentNode;
        }

        var selectableItems = this._getAllSelectableItems(currentItem);

        var length = selectableItems.length;
        var index = selectableItems.indexOf(currentItem);

        if (index >= 0 && length > index + 1) {
          // if there is a next selectable element return it
          return getFirstSelectableWrappedItem(selectableItems[index + 1]);
        } else {
          for (var i = 0; i < length; i++) {
            if (selectableItems[i].contains(currentItem) && length > i + 1) {
              return getFirstSelectableWrappedItem(selectableItems[i + 1]);
            }
          }
        }

        return null;
      }
      /** @ignore */

    }, {
      key: "_getPreviousSelectableWrappedItem",
      value: function _getPreviousSelectableWrappedItem(currentItem) {
        if (currentItem.parentNode.tagName === 'CORAL-ACTIONBAR-ITEM') {
          // currentItem is wrapped
          currentItem = currentItem.parentNode;
        }

        var selectableItems = this._getAllSelectableItems(currentItem);

        var index = selectableItems.indexOf(currentItem);

        if (index > 0) {
          // if there is a previous selectable element return it
          return getFirstSelectableWrappedItem(selectableItems[index - 1]);
        } else {
          for (var i = 1; i < selectableItems.length; i++) {
            if (selectableItems[i].contains(currentItem)) {
              return getFirstSelectableWrappedItem(selectableItems[i - 1]);
            }
          }
        }

        return null;
      }
      /** @ignore */

    }, {
      key: "_getAllSelectableItems",
      value: function _getAllSelectableItems(currentItem) {
        var selectableItems = [];

        if (this.primary._elements.overlay.open === true || this.secondary._elements.overlay.open === true) {
          // if popover is open only items in popover can be selected
          var popoverItems = this.primary._elements.overlay.open === true ? this.primary._itemsInPopover : this.secondary._itemsInPopover;
          var item = null;

          for (var i = 0; i < popoverItems.length; i++) {
            item = popoverItems[i];

            if (!item.hasAttribute('disabled') && !item.hasAttribute('hidden') && item.style.display !== 'none' && getFirstSelectableWrappedItem(item)) {
              selectableItems.push(item);
            }
          }
        } else {
          // concat selectable items from left side of the bar and right side of the bar
          var leftSelectableItems = this.primary.items._getAllSelectable();

          var rightSelectableItems = this.secondary.items._getAllSelectable();

          if (currentItem) {
            if (this.primary.contains(currentItem)) {
              selectableItems = leftSelectableItems;
            } else if (this.secondary.contains(currentItem)) {
              selectableItems = rightSelectableItems;
            }
          } else {
            selectableItems = leftSelectableItems.concat(rightSelectableItems);
          }
        }

        return selectableItems;
      }
      /** @ignore */

    }, {
      key: "_newWidthCache",
      value: function _newWidthCache() {
        return {
          _items: [],
          _outerWidth: [],
          getOuterWidth: function getOuterWidth(item) {
            var index = this._items.indexOf(item);

            if (index < 0) {
              // if item was not cached in current frame => cache it
              this._items.push(item);

              var width = item.offsetWidth;

              this._outerWidth.push(width);

              index = this._outerWidth.length - 1;
            }

            return this._outerWidth[index];
          }
        };
      }
      /** @ignore */

    }, {
      key: "_forceWebkitRedraw",
      value: function _forceWebkitRedraw(el) {
        var isWebkit = ('WebkitAppearance' in document.documentElement.style);

        if (isWebkit && el.style.display !== 'none') {
          el.style.display = 'none'; // no need to store this anywhere, the reference would be enough

          this._cachedOffsetHeight = el.offsetHeight;
          el.style.display = '';
        }
      }
      /** @ignore */

    }, {
      key: "_hideItem",
      value: function _hideItem(item, hide) {
        if (hide === false) {
          this._moveToScreen(item);
        } else if (!item.hasAttribute('coral-actionbar-offscreen')) {
          // actually just move element offscreen to be able to measure the size while calculating the layout
          item.setAttribute('coral-actionbar-offscreen', '');
          item.style.visibility = 'hidden'; // if I do not force a browser redraw webkit has layouting problems

          this._forceWebkitRedraw(item);
        }
      }
      /** @ignore */

    }, {
      key: "_moveToScreen",
      value: function _moveToScreen(item, show) {
        if (show === false) {
          this._hideItem(item);
        } else if (item.hasAttribute('coral-actionbar-offscreen')) {
          // actually just move element onscreen again (see _hideItem)
          item.removeAttribute('coral-actionbar-offscreen');
          item.style.visibility = ''; // if I do not force a browser redraw webkit has layouting problems

          this._forceWebkitRedraw(item);
        }
      }
      /** @ignore */

    }, {
      key: "_toggleItemTabbable",
      value: function _toggleItemTabbable(item, tabbable) {
        this._ignoreLayout = true; // item might be wrapped (for now remove/add tabindex only on the first wrapped item)

        item = getFirstSelectableWrappedItem(item);

        if (item !== null) {
          item.setAttribute('tabindex', tabbable ? 0 : -1);
        }
      }
      /** @ignore */

    }, {
      key: "_debounceOnLayout",
      value: function _debounceOnLayout() {
        var _this3 = this;

        if (this._ignoreLayout) {
          this._ignoreLayout = false;
          return;
        } // Debounce


        if (this._timeout !== null) {
          window.clearTimeout(this._timeout);
        }

        this._timeout = window.setTimeout(function () {
          _this3._timeout = null;

          _this3._onLayout();
        }, this._wait);
      }
    }, {
      key: "_moveDirectItemChildren",
      value: function _moveDirectItemChildren() {
        var items = Array.prototype.filter.call(this.children, function (child) {
          return child.nodeName === 'CORAL-ACTIONBAR-ITEM';
        });
        var frag = document.createDocumentFragment(); // Move them to the frag

        items.forEach(function (item) {
          frag.appendChild(item);
        }); // Add the frag to primary content zone

        this._elements.primary.appendChild(frag);
      }
    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(ActionBar.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$t); // Move direct items into primary content zone

        this._moveDirectItemChildren(); // Cleanup resize helpers object (cloneNode support)


        var resizeHelpers = this.querySelectorAll('object');

        for (var i = 0; i < resizeHelpers.length; ++i) {
          var resizeElement = resizeHelpers[i];

          if (resizeElement.parentNode === this) {
            this.removeChild(resizeElement);
          }
        }

        var primary = this._elements.primary;
        var secondary = this._elements.secondary;

        if (!primary.getAttribute('role')) {
          primary.setAttribute('role', 'toolbar');
        }

        if (!secondary.getAttribute('role')) {
          secondary.setAttribute('role', 'toolbar');
        } // we need to know if the content zone was provided to stop the voracious behavior


        var primaryProvided = primary.parentNode === this; // as a way to transition to the new content zones, we need to provide support for the old container tag. we copy
        // everything from these containers into the corresponding content zones, including the configurations

        var containers = Array.prototype.slice.call(this.getElementsByTagName('coral-actionbar-container'));
        var legacyContainer;
        var targetContainer;

        for (var j = 0, containersCount = containers.length; j < containersCount; j++) {
          legacyContainer = containers[j]; // move first container content to new primary element

          if (j === 0) {
            targetContainer = primary; // overrides the previous configuration as we support older containers

            primaryProvided = true;
          } else if (j === 1) {
            targetContainer = secondary;
          } // it may happen that more than 2 containers were provided, in such case we simply ignore it


          if (targetContainer) {
            // we need to copy the existing configuration to the new content zone
            if (legacyContainer.hasAttribute('threshold')) {
              targetContainer.setAttribute('threshold', legacyContainer.getAttribute('threshold'));
            }

            if (legacyContainer.hasAttribute('morebuttontext')) {
              targetContainer.setAttribute('morebuttontext', legacyContainer.getAttribute('morebuttontext'));
            } // @todo: are we copying the more button?


            while (legacyContainer.firstChild) {
              targetContainer.appendChild(legacyContainer.firstChild);
            }
          }

          this.removeChild(legacyContainer);
        } // to prevent the content zone being voracious, we only move the children if primary was not explicitely provided


        if (!primaryProvided) {
          while (this.firstChild) {
            primary.appendChild(this.firstChild);
          }
        } // Call content zone inserts


        this.primary = this._elements.primary;
        this.secondary = this._elements.secondary; // force one layout

        this._onLayout();
      }
    }, {
      key: "primary",
      get: function get() {
        return this._getContentZone(this._elements.primary);
      },
      set: function set(value) {
        this._setContentZone('primary', value, {
          handle: 'primary',
          tagName: 'coral-actionbar-primary',
          insert: function insert(content) {
            // primary has to be before secondary if available
            this.insertBefore(content, this.secondary);
          }
        });
      }
      /**
       The secondary (right) container of the ActionBar.
        @type {ActionBarSecondary}
       @contentzone
       */

    }, {
      key: "secondary",
      get: function get() {
        return this._getContentZone(this._elements.secondary);
      },
      set: function set(value) {
        this._setContentZone('secondary', value, {
          handle: 'secondary',
          tagName: 'coral-actionbar-secondary',
          insert: function insert(content) {
            this.appendChild(content);
          }
        });
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-actionbar-primary': 'primary',
          'coral-actionbar-secondary': 'secondary'
        };
      }
    }]);

    return ActionBar;
  }(BaseComponent(HTMLElement));

  var CLASSNAME$u = '_coral-ActionBar-item';
  /**
   @class Coral.ActionBar.Item
   @classdesc An ActionBar item component
   @htmltag coral-actionbar-item
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var ActionBarItem = /*#__PURE__*/function (_BaseComponent) {
    _inherits(ActionBarItem, _BaseComponent);

    var _super = _createSuper(ActionBarItem);

    function ActionBarItem() {
      _classCallCheck(this, ActionBarItem);

      return _super.apply(this, arguments);
    }

    _createClass(ActionBarItem, [{
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(ActionBarItem.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$u);
      }
    }, {
      key: "content",
      // @compat
      get: function get() {
        return this;
      },
      set: function set(value) {
        // Support configs
        if (_typeof(value) === 'object') {
          for (var prop in value) {
            /** @ignore */
            this[prop] = value[prop];
          }
        }
      }
    }]);

    return ActionBarItem;
  }(BaseComponent(HTMLElement));

  /**
   @class Coral.ActionBar.Container.Collection
   @classdesc The ActionBar container collection
   @extends {SelectableCollection}
   */

  var ActionBarContainerCollection = /*#__PURE__*/function (_SelectableCollection) {
    _inherits(ActionBarContainerCollection, _SelectableCollection);

    var _super = _createSuper(ActionBarContainerCollection);

    function ActionBarContainerCollection() {
      _classCallCheck(this, ActionBarContainerCollection);

      return _super.apply(this, arguments);
    }

    _createClass(ActionBarContainerCollection, [{
      key: "add",
      value: function add(item, before) {
        // in the left actionBar container always insert elements before the 'more' button in right actionBar always append
        // at the end
        if (!before && this._host.tagName === 'CORAL-ACTIONBAR-PRIMARY') {
          var moreButton = this._host._elements.moreButton;
          before = this._host.contains(moreButton) ? moreButton : null;
        }

        return _get(_getPrototypeOf(ActionBarContainerCollection.prototype), "add", this).call(this, item, before);
      }
    }, {
      key: "clear",
      value: function clear() {
        var items = _get(_getPrototypeOf(ActionBarContainerCollection.prototype), "clear", this).call(this);

        this._host._itemsInPopover = [];
        return items;
      }
    }, {
      key: "_getAllSelectable",
      value: function _getAllSelectable() {
        var selectableItems = [];
        var child = null;

        for (var i = 0; i < this._host.children.length; i++) {
          child = this._host.children[i];

          if (!child.hasAttribute('disabled') && !child.hasAttribute('hidden') && !child.hasAttribute('coral-actionbar-offscreen') && child !== this._host._elements.overlay && getFirstSelectableWrappedItem(child)) {
            selectableItems.push(child);
          }
        }

        return selectableItems;
      }
    }, {
      key: "_getAllOffScreen",
      value: function _getAllOffScreen() {
        return Array.prototype.slice.call(this._host.querySelectorAll("".concat(this._itemTagName, "[coral-actionbar-offscreen]")));
      }
    }]);

    return ActionBarContainerCollection;
  }(SelectableCollection);

  var SPACE = 32;
  /**
   @class Coral.AnchorButton
   @classdesc A Link component rendering as a button allowing us to style an anchor element that both looks and behaves
   like a button rather than a link. It can receive keyboard focus regardless of whether or not it has an <code>href</code>
   attribute, can be activated using either the <code>SPACE</code> key or the <code>ENTER</code> key, and is identified to
   assistive technology as a button element.
   @htmltag coral-anchorbutton
   @htmlbasetag a
   @extends {HTMLAnchorElement}
   @extends {BaseComponent}
   @extends {BaseButton}
   */

  var AnchorButton = /*#__PURE__*/function (_BaseButton) {
    _inherits(AnchorButton, _BaseButton);

    var _super = _createSuper(AnchorButton);

    /** @ignore */
    function AnchorButton() {
      var _this;

      _classCallCheck(this, AnchorButton);

      _this = _super.call(this); // Events

      _this._delegateEvents(commons.extend(_this._events, {
        keydown: '_onKeyDown',
        keyup: '_onKeyUp'
      })); // cannot use the events hash because events on disabled items are not reported


      _this.addEventListener('click', _this._onDisabledClick.bind(_assertThisInitialized(_this)));

      return _this;
    }
    /**
     Disables the button from user interaction.
      @type {Boolean}
     @default false
     @htmlattribute disabled
     @htmlattributereflected
     */


    _createClass(AnchorButton, [{
      key: "_onKeyDown",

      /**
       Keyboard handling per the WAI-ARIA button widget design pattern:
       https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_button_role
        @ignore
       */
      value: function _onKeyDown(event) {
        if (event.keyCode === SPACE) {
          event.preventDefault();
          this.click();
          this.classList.add('is-selected');
        }
      }
      /** @ignore */

    }, {
      key: "_onKeyUp",
      value: function _onKeyUp(event) {
        if (event.keyCode === SPACE) {
          event.preventDefault();
          this.classList.remove('is-selected');
        }
      }
      /** @ignore */

    }, {
      key: "_onDisabledClick",
      value: function _onDisabledClick(event) {
        if (this.disabled) {
          event.preventDefault();
        }
      } // Override content zone name

    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(AnchorButton.prototype), "render", this).call(this); // a11y


        this.setAttribute('role', 'button');

        if (!this.disabled) {
          // Force tabindex and aria-disabled attribute reflection
          this.setAttribute('tabindex', '0');
          this.removeAttribute('aria-disabled');
        }
      }
    }, {
      key: "disabled",
      get: function get() {
        return this._disabled || false;
      },
      set: function set(value) {
        this._disabled = transform.booleanAttr(value);

        this._reflectAttribute('disabled', this._disabled);

        this.classList.toggle('is-disabled', this._disabled);
        this.setAttribute('tabindex', this._disabled ? '-1' : '0');
        this[this._disabled ? 'setAttribute' : 'removeAttribute']('aria-disabled', this._disabled);
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-anchorbutton-label': 'label'
        };
      }
      /** @ignore */

    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(AnchorButton), "observedAttributes", this).concat(['disabled']);
      }
    }]);

    return AnchorButton;
  }(BaseButton(BaseComponent(HTMLAnchorElement)));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.AnchorButton.Label
   @classdesc The AnchorButton label content
   @htmltag coral-anchorbutton-label
   @return {HTMLElement}
   */
  var AnchorButtonLabel = (function () {
    return document.createElement('coral-anchorbutton-label');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons._define('coral-anchorbutton', AnchorButton, {
    extends: 'a'
  });

  AnchorButton.Label = AnchorButtonLabel;

  var template$d = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["overlay"] = document.createElement("coral-popover");
    el0.setAttribute("smart", "");
    el0.id = data_0["commons"]["getUID"]();
    el0.setAttribute("handle", "overlay");
    el0.setAttribute("placement", "bottom");
    el0.setAttribute("breadthoffset", "-50%r + 50%p");
    el0.setAttribute("coral-actionbar-popover", "");
    el0.setAttribute("tabindex", "-1");
    el0.setAttribute("role", "presentation");
    frag.appendChild(el0);
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    return frag;
  };

  var template$e = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["moreButton"] = document.createElement("button", "coral-button");
    el0.setAttribute("is", "coral-button");
    el0.setAttribute("handle", "moreButton");
    el0.setAttribute("type", "button");
    el0.setAttribute("variant", "quietaction");
    el0.className += " _coral-ActionBar-button";
    el0.setAttribute("icon", "more");
    el0.setAttribute("coral-actionbar-more", "");
    el0.setAttribute("aria-expanded", "false");
    el0.setAttribute("aria-haspopup", "true");
    var el1 = document.createTextNode("\n  ");
    el0.appendChild(el1);
    var el2 = this["moreButtonLabel"] = document.createElement("coral-button-label");
    el2.setAttribute("handle", "moreButtonLabel");
    el0.appendChild(el2);
    var el3 = document.createTextNode("\n");
    el0.appendChild(el3);
    frag.appendChild(el0);
    var el4 = document.createTextNode("\n");
    frag.appendChild(el4);
    return frag;
  };

  var template$f = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var data = data_0 = typeof data_0 === "undefined" ? {} : data_0;
    data = data_0;
    var copyAttributes = data.copyAttributes;
    data_0 = data;
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);

    if (data_0["items"]["isButtonList"]) {
      var el3 = document.createTextNode("\n  ");
      frag.appendChild(el3);
      var el4 = this["buttonList"] = document.createElement("coral-buttonlist");
      el4.className += " _coral-ActionBar-buttonList";
      el4.setAttribute("tabindex", "0");
      el4.setAttribute("role", "menu");
      el4.setAttribute("coral-actionbar-offscreen", "");
      el4.setAttribute("handle", "buttonList");
      var el5 = document.createTextNode("\n    ");
      el4.appendChild(el5);
      var iterated_1 = data_0["items"];

      for (var i1 = 0, ni1 = iterated_1.length; i1 < ni1; i1++) {
        var data_1 = data = iterated_1[i1];
        var el7 = document.createTextNode("\n      ");
        el4.appendChild(el7);
        var el8 = this["buttonListItem"] = document.createElement("button", "coral-buttonlist-item");
        el8.setAttribute("is", "coral-buttonlist-item");
        el8.setAttribute("role", "menuitem");
        el8.setAttribute("handle", "buttonListItem");
        var el9 = document.createTextNode("\n        ");
        el8.appendChild(el9);
        data = data_1;
        copyAttributes(data._button, this.buttonListItem);
        data_1 = data;
        var el11 = document.createTextNode("\n        ");
        el8.appendChild(el11);
        var el12 = document.createElement("coral-list-item-content");
        var el13 = document.createTextNode("\n          ");
        el12.appendChild(el13);
        var el14 = this["buttonListItemContent"] = document.createElement("coral-action-bar-item");
        el14.setAttribute("coral-actionbar-offscreen", "");
        el14.setAttribute("handle", "buttonListItemContent");
        el12.appendChild(el14);
        var el15 = document.createTextNode("\n        ");
        el12.appendChild(el15);
        el8.appendChild(el12);
        var el16 = document.createTextNode("\n        ");
        el8.appendChild(el16);
        data = data_1;
        this.buttonListItemContent.innerHTML = data._button.label.innerHTML;
        data_1 = data;
        var el18 = document.createTextNode("\n      ");
        el8.appendChild(el18);
        el4.appendChild(el8);
        var el19 = document.createTextNode("\n      ");
        el4.appendChild(el19);

        if (data_1["_popover"]) {
          var el21 = document.createTextNode("\n        ");
          el4.appendChild(el21);
          data = data_1;

          var popover = data._popover.cloneNode(true);

          data._popover.removeAttribute('id'); //set target to the new button


          if (popover.target) {
            popover.removeAttribute('target');
            popover.target = this.buttonListItem;
          }

          this.buttonList.items.add(popover);
          data_1 = data;
          var el23 = document.createTextNode("\n      ");
          el4.appendChild(el23);
        }

        var el24 = document.createTextNode("\n    ");
        el4.appendChild(el24);
      }

      var el25 = document.createTextNode("\n  ");
      el4.appendChild(el25);
      frag.appendChild(el4);
      var el26 = document.createTextNode("\n  ");
      frag.appendChild(el26);
      var el27 = document.createTextNode("\n");
      frag.appendChild(el27);
    } else {
      var el28 = document.createTextNode("\n    ");
      frag.appendChild(el28);

      if (data_0["items"]["isAnchorList"]) {
        var el30 = document.createTextNode("\n      ");
        frag.appendChild(el30);
        var el31 = this["anchorList"] = document.createElement("coral-anchorlist");
        el31.setAttribute("tabindex", "0");
        el31.setAttribute("role", "menu");
        el31.setAttribute("coral-actionbar-offscreen", "");
        el31.setAttribute("handle", "anchorList");
        var el32 = document.createTextNode("\n        ");
        el31.appendChild(el32);
        var iterated_1 = data_0["items"];

        for (var i1 = 0, ni1 = iterated_1.length; i1 < ni1; i1++) {
          var data_1 = data = iterated_1[i1];
          var el34 = document.createTextNode("\n          ");
          el31.appendChild(el34);
          var el35 = this["anchorListItem"] = document.createElement("a", "coral-anchorlist-item");
          el35.setAttribute("is", "coral-anchorlist-item");
          el35.setAttribute("role", "menuitem");
          el35.setAttribute("handle", "anchorListItem");
          var el36 = document.createTextNode("\n            ");
          el35.appendChild(el36);
          data = data_1;
          copyAttributes(data._button, this.anchorListItem);
          data_1 = data;
          var el38 = document.createTextNode("\n            ");
          el35.appendChild(el38);
          var el39 = document.createElement("coral-list-item-content");
          var el40 = document.createTextNode("\n              ");
          el39.appendChild(el40);
          var el41 = this["anchorListItemContent"] = document.createElement("coral-action-bar-item");
          el41.setAttribute("coral-actionbar-offscreen", "");
          el41.setAttribute("handle", "anchorListItemContent");
          el39.appendChild(el41);
          var el42 = document.createTextNode("\n            ");
          el39.appendChild(el42);
          el35.appendChild(el39);
          var el43 = document.createTextNode("\n            ");
          el35.appendChild(el43);
          data = data_1;
          this.anchorListItemContent.innerHTML = data._button.label.innerHTML;
          data_1 = data;
          var el45 = document.createTextNode("\n          ");
          el35.appendChild(el45);
          el31.appendChild(el35);
          var el46 = document.createTextNode("\n          ");
          el31.appendChild(el46);

          if (data_1["_popover"]) {
            var el48 = document.createTextNode("\n            ");
            el31.appendChild(el48);
            data = data_1;

            var popover = data._popover.cloneNode(true);

            data._popover.removeAttribute('id'); //set target to the new button


            if (popover.target) {
              popover.removeAttribute('target');
              popover.target = this.anchorListItem;
            }

            this.anchorList.items.add(popover);
            data_1 = data;
            var el50 = document.createTextNode("\n          ");
            el31.appendChild(el50);
          }

          var el51 = document.createTextNode("\n        ");
          el31.appendChild(el51);
        }

        var el52 = document.createTextNode("\n      ");
        el31.appendChild(el52);
        frag.appendChild(el31);
        var el53 = document.createTextNode("\n      ");
        frag.appendChild(el53);
        var el54 = document.createTextNode("\n    ");
        frag.appendChild(el54);
      } else {
        var el55 = document.createTextNode("\n        ");
        frag.appendChild(el55);
        var el56 = document.createElement("ul");
        el56.className += " _coral-ActionBar-list";
        var el57 = document.createTextNode("\n          ");
        el56.appendChild(el57);
        var iterated_1 = data_0["items"];

        for (var i1 = 0, ni1 = iterated_1.length; i1 < ni1; i1++) {
          var data_1 = data = iterated_1[i1];
          var el59 = document.createTextNode("\n            ");
          el56.appendChild(el59);
          var el60 = document.createElement("li");
          el60.className += " _coral-ActionBar-list-item";
          var el61 = document.createTextNode("\n              ");
          el60.appendChild(el61);
          el60.appendChild(data_1);
          var el63 = document.createTextNode("\n            ");
          el60.appendChild(el63);
          el56.appendChild(el60);
          var el64 = document.createTextNode("\n          ");
          el56.appendChild(el64);
        }

        var el65 = document.createTextNode("\n        ");
        el56.appendChild(el65);
        frag.appendChild(el56);
        var el66 = document.createTextNode("\n      ");
        frag.appendChild(el66);
      }

      var el67 = document.createTextNode("\n  ");
      frag.appendChild(el67);
    }

    var el68 = document.createTextNode("\n\n\n");
    frag.appendChild(el68);
    return frag;
  };

  var REG_EXP = /_coral([^\s]+)/g;

  var copyAttributes = function copyAttributes(from, to) {
    var excludedAttributes = ['is', 'id', 'variant', 'size'];

    for (var i = 0; i < from.attributes.length; i++) {
      var attr = from.attributes[i];

      if (excludedAttributes.indexOf(attr.nodeName) === -1) {
        if (attr.nodeName === 'class') {
          // Filter out private Coral classes
          to.setAttribute(attr.nodeName, "".concat(to.className, " ").concat(attr.nodeValue.replace(REG_EXP, '')));
        } else {
          to.setAttribute(attr.nodeName, attr.nodeValue);
        }
      }
    }
  };
  /**
   @base BaseActionBarContainer
   @classdesc The base element for action bar containers
   */


  var BaseActionBarContainer = function BaseActionBarContainer(superClass) {
    return /*#__PURE__*/function (_superClass) {
      _inherits(_class, _superClass);

      var _super = _createSuper(_class);

      /** @ignore */
      function _class() {
        var _this;

        _classCallCheck(this, _class);

        _this = _super.call(this); // Templates

        _this._elements = {};
        _this._itemsInPopover = [];
        template$e.call(_this._elements);
        template$d.call(_this._elements, {
          commons: commons
        });
        template$f.call(_this._elements, {
          items: _this._itemsInPopover,
          copyAttributes: copyAttributes
        }); // Return focus to overlay by default

        _this._elements.overlay.focusOnShow = _this._elements.overlay;
        var overlayId = _this._elements.overlay.id;
        var events = {};
        events["global:capture:coral-overlay:beforeopen #".concat(overlayId)] = '_onOverlayBeforeOpen';
        events["global:capture:coral-overlay:beforeclose #".concat(overlayId)] = '_onOverlayBeforeClose'; // Keyboard interaction

        events["global:key:down #".concat(overlayId)] = '_onOverlayKeyDown';
        events["global:key:up #".concat(overlayId)] = '_onOverlayKeyUp'; // Events

        _this._delegateEvents(events); // Init the collection mutation observer


        _this.items._startHandlingItems(true);

        return _this;
      }
      /**
       Returns the inner overlay to allow customization.
        @type {Popover}
       @readonly
       */


      _createClass(_class, [{
        key: "_styleItem",

        /**
         Style item content
         */
        value: function _styleItem(item) {
          var button = item.querySelector('button[is="coral-button"]') || item.querySelector('a[is="coral-anchorbutton"]');

          if (button) {
            button.classList.add('_coral-ActionBar-button');
            var oldVariant = button.getAttribute('variant');

            if (oldVariant === Button.variant.ACTION || oldVariant === Button.variant.QUIET_ACTION) {
              return;
            }

            button.setAttribute('variant', oldVariant === Button.variant.QUIET ? Button.variant.QUIET_ACTION : Button.variant.ACTION);
          }
        }
        /**
         Called after popover.open is set to true, but before the transition of the popover is done. Show elements inside
         the actionbar, that are hidden due to space problems.
          @ignore
         */

      }, {
        key: "_onOverlayBeforeOpen",
        value: function _onOverlayBeforeOpen(event) {
          // there might be popovers in popover => ignore them
          if (event.target !== this._elements.overlay) {
            return;
          }

          this._itemsInPopover = this.items._getAllOffScreen();

          if (this._itemsInPopover.length < 1) {
            return;
          } // Set focus to first focusable descendant of the overlay by default


          this._elements.overlay.focusOnShow = 'on';

          this._itemsInPopover.forEach(function (item) {
            item.style.visibility = ''; // Store the button and popover on the item

            item._button = item.querySelector('button[is="coral-button"]') || item.querySelector('a[is="coral-anchorbutton"]');
            item._popover = item.querySelector('coral-popover');

            if (item._popover) {
              item._popoverId = item._popover.id;
            }
          }); // Whether a ButtonList or AnchorList should be rendered


          this._itemsInPopover.isButtonList = this._itemsInPopover.every(function (item) {
            return item._button && item._button.tagName === 'BUTTON';
          });
          this._itemsInPopover.isAnchorList = this._itemsInPopover.every(function (item) {
            return item._button && item._button.tagName === 'A';
          }); // show the current popover (hidden needed to disable fade time of popover)

          this._elements.overlay.hidden = false; // render popover content

          var popover = this._elements.overlay;
          popover.content.innerHTML = '';
          popover.content.appendChild(template$f.call(this._elements, {
            items: this._itemsInPopover,
            copyAttributes: copyAttributes
          }));
        }
        /**
         Called after popover.open is set to false, but before the transition of the popover is done.
         Make items visible again, that now do fit into the actionbar.
         @ignore
         */

      }, {
        key: "_onOverlayBeforeClose",
        value: function _onOverlayBeforeClose(event) {
          // there might be popovers in popover => ignore them
          if (event.target !== this._elements.overlay) {
            return;
          }

          var focusedItem = document.activeElement.parentNode; // we need to check if item has 'hasAttribute' because it is not present on the document

          var isFocusedItemInsideActionBar = this.parentNode.contains(focusedItem);
          var isFocusedItemOffscreen = focusedItem.hasAttribute && focusedItem.hasAttribute('coral-actionbar-offscreen');

          if (isFocusedItemInsideActionBar && isFocusedItemOffscreen) {
            // if currently an element is focused, that should not be visible (or is no actionbar-item) => select 'more'
            // button
            this._elements.moreButton.focus();
          } // hide the popover(needed to disable fade time of popover)


          this._elements.overlay.hidden = true;
          this._elements.overlay.focusOnShow = this._elements.overlay; // close any popovers, that might be inside the 'more' popover

          var childPopovers = this._elements.overlay.getElementsByTagName('coral-popover');

          for (var i = 0; i < childPopovers.length; i++) {
            childPopovers[i].open = false;
          } // return all elements from popover


          this._returnElementsFromPopover(); // clear cached items from popover


          this._itemsInPopover = []; // clear overlay

          this._elements.overlay.content.innerHTML = '';
        }
      }, {
        key: "_onOverlayKeyDown",
        value: function _onOverlayKeyDown(event) {
          event.preventDefault(); // Focus first item

          this._elements.anchorList && this._elements.anchorList._focusFirstItem(event);
          this._elements.buttonList && this._elements.buttonList._focusFirstItem(event);
        }
      }, {
        key: "_onOverlayKeyUp",
        value: function _onOverlayKeyUp(event) {
          event.preventDefault(); // Focus last item

          this._elements.anchorList && this._elements.anchorList._focusLastItem(event);
          this._elements.buttonList && this._elements.buttonList._focusLastItem(event);
        }
      }, {
        key: "connectedCallback",

        /** @ignore */
        value: function connectedCallback() {
          _get(_getPrototypeOf(_class.prototype), "connectedCallback", this).call(this);

          var overlay = this._elements.overlay; // Cannot be open by default when rendered

          overlay.removeAttribute('open'); // Restore in DOM

          if (overlay._parent) {
            overlay._parent.appendChild(overlay);
          }
        }
        /** @ignore */

      }, {
        key: "render",
        value: function render() {
          var _this2 = this;

          _get(_getPrototypeOf(_class.prototype), "render", this).call(this); // Cleanup resize helpers object (cloneNode support)


          var resizeHelpers = this.getElementsByTagName('object');

          for (var i = 0; i < resizeHelpers.length; ++i) {
            var resizeElement = resizeHelpers[i];

            if (resizeElement.parentNode === this) {
              this.removeChild(resizeElement);
            }
          } // Cleanup 'More' button


          var more = this.querySelector('[coral-actionbar-more]');

          if (more) {
            this.removeChild(more);
          } // Cleanup 'More' popover


          var popover = this.querySelector('[coral-actionbar-popover]');

          if (popover) {
            this.removeChild(popover);
          } // Copy more text


          this._elements.moreButton.label.textContent = this.moreButtonText; // Init 'More' popover

          this._elements.overlay.target = this._elements.moreButton; // Create empty frag

          var frag = document.createDocumentFragment(); // 'More' button might be moved later in dom when Container is attached to parent

          frag.appendChild(this._elements.moreButton);
          frag.appendChild(this._elements.overlay); // Render template

          this.appendChild(frag); // Style the items to match action items

          this.items.getAll().forEach(function (item) {
            return _this2._styleItem(item);
          });
        }
        /** @ignore */

      }, {
        key: "disconnectedCallback",
        value: function disconnectedCallback() {
          _get(_getPrototypeOf(_class.prototype), "disconnectedCallback", this).call(this);

          var overlay = this._elements.overlay; // In case it was moved out don't forget to remove it

          if (!this.contains(overlay)) {
            overlay._parent = overlay._repositioned ? document.body : this;
            overlay.remove();
          }
        }
      }, {
        key: "overlay",
        get: function get() {
          return this._elements.overlay;
        }
        /**
         The Collection Interface that allows interacting with the items that the component contains.
          @type {ActionBarContainerCollection}
         @readonly
         */

      }, {
        key: "items",
        get: function get() {
          // Construct the collection on first request:
          if (!this._items) {
            this._items = new ActionBarContainerCollection({
              host: this,
              itemTagName: 'coral-actionbar-item',
              onItemAdded: this._styleItem
            });
          }

          return this._items;
        }
        /**
         The amount of items that are maximally visible inside the container. Using a value <= 0 will disable this
         feature and show as many items as possible.
          @type {Number}
         @default -1
         @htmlattribute threshold
         @htmlattributereflected
         */

      }, {
        key: "threshold",
        get: function get() {
          return typeof this._threshold === 'number' ? this._threshold : -1;
        },
        set: function set(value) {
          this._threshold = transform.number(value);

          this._reflectAttribute('threshold', this._threshold);
        }
        /**
         If there are more ActionBarItems inside the ActionBar than currently can be shown, then a "more" Button with the
         following text will be rendered (and some ActionBarItems will be hidden inside of a Popover).
          @type {String}
         @default ""
         @htmlattribute morebuttontext
         */

      }, {
        key: "moreButtonText",
        get: function get() {
          return this._moreButtonText || '';
        },
        set: function set(value) {
          this._moreButtonText = transform.string(value);

          if (this._elements.moreButton) {
            // moreButton might not have been created so far
            this._elements.moreButtonLabel.innerHTML = this._moreButtonText;

            this._elements.moreButton[this._moreButtonText.trim() === '' ? 'setAttribute' : 'removeAttribute']('title', i18n.get('More'));
          }
        }
      }], [{
        key: "_attributePropertyMap",
        get: function get() {
          return commons.extend(_get(_getPrototypeOf(_class), "_attributePropertyMap", this), {
            morebuttontext: 'moreButtonText'
          });
        }
        /** @ignore */

      }, {
        key: "observedAttributes",
        get: function get() {
          return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['morebuttontext', 'threshold']);
        }
      }]);

      return _class;
    }(superClass);
  };

  var CLASSNAME$v = '_coral-ActionBar-primary';
  /**
   @class Coral.ActionBar.Primary
   @classdesc An ActionBar primary component
   @htmltag coral-actionbar-primary
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var ActionBarPrimary = /*#__PURE__*/function (_ActionBarContainer) {
    _inherits(ActionBarPrimary, _ActionBarContainer);

    var _super = _createSuper(ActionBarPrimary);

    function ActionBarPrimary() {
      _classCallCheck(this, ActionBarPrimary);

      return _super.apply(this, arguments);
    }

    _createClass(ActionBarPrimary, [{
      key: "_returnElementsFromPopover",

      /** @ignore */
      value: function _returnElementsFromPopover() {
        var item = null;
        var wrappedItem = null;

        for (var i = 0; i < this._itemsInPopover.length; i++) {
          item = this._itemsInPopover[i];
          item.style.visibility = 'hidden'; // remove tabindex again

          wrappedItem = getFirstSelectableWrappedItem(item);

          if (wrappedItem && wrappedItem.hasAttribute('tabindex')) {
            wrappedItem.setAttribute('tabindex', -1);
          }

          this.insertBefore(item, this._elements.moreButton); // Reset popover id, target

          if (item._button && item._popover) {
            item._popover.id = item._popoverId;

            if (item._popover.target) {
              item._popover.target = item._button;
            }
          }
        }
      }
      /** @ignore */

    }, {
      key: "_attachMoreButtonToContainer",
      value: function _attachMoreButtonToContainer() {
        // add the button to the left/primary contentzone
        this.appendChild(this._elements.moreButton);
      }
      /** @ignore */

    }, {
      key: "render",
      value: function render() {
        _get(_getPrototypeOf(ActionBarPrimary.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$v);

        this._attachMoreButtonToContainer();
      }
    }]);

    return ActionBarPrimary;
  }(BaseActionBarContainer(BaseComponent(HTMLElement)));

  var CLASSNAME$w = '_coral-ActionBar-secondary';
  /**
   @class Coral.ActionBar.Secondary
   @classdesc An ActionBar secondary component
   @htmltag coral-actionbar-secondary
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var ActionBarSecondary = /*#__PURE__*/function (_ActionBarContainer) {
    _inherits(ActionBarSecondary, _ActionBarContainer);

    var _super = _createSuper(ActionBarSecondary);

    function ActionBarSecondary() {
      _classCallCheck(this, ActionBarSecondary);

      return _super.apply(this, arguments);
    }

    _createClass(ActionBarSecondary, [{
      key: "_returnElementsFromPopover",

      /** @ignore */
      value: function _returnElementsFromPopover() {
        var item = null;
        var wrappedItem = null;

        for (var i = this._itemsInPopover.length - 1; i >= 0; i--) {
          item = this._itemsInPopover[i];
          item.style.visibility = 'hidden'; // remove tabindex again

          wrappedItem = getFirstSelectableWrappedItem(item);

          if (wrappedItem && wrappedItem.hasAttribute('tabindex')) {
            wrappedItem.setAttribute('tabindex', -1);
          }

          this.insertBefore(item, this.firstChild.nextSibling); // Reset popover id, target

          if (item._button && item._popover) {
            item._popover.id = item._popoverId;

            if (item._popover.target) {
              item._popover.target = item._button;
            }
          }
        }
      }
      /** @ignore */

    }, {
      key: "_attachMoreButtonToContainer",
      value: function _attachMoreButtonToContainer() {
        this.insertBefore(this._elements.moreButton, this.firstChild);
      }
      /** @ignore */

    }, {
      key: "render",
      value: function render() {
        _get(_getPrototypeOf(ActionBarSecondary.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$w);

        this._attachMoreButtonToContainer();
      }
    }]);

    return ActionBarSecondary;
  }(BaseActionBarContainer(BaseComponent(HTMLElement)));

  var CLASSNAME$x = '_coral-ActionBar-container';
  /**
   Enumeration for {@link ActionBarContainer} positions.

   @typedef {Object} ActionBarContainerPositionEnum

   @property {String} PRIMARY
   Primary (left) ActionBar container.
   @property {String} SECONDARY
   Secondary (right) ActionBar container.
   @property {String} INVALID
   Invalid ActionBar container.
   */

  var position = {
    PRIMARY: 'primary',
    SECONDARY: 'secondary',
    INVALID: 'invalid'
  };
  /**
   @class Coral.ActionBar.Container
   @classdesc An ActionBar container component
   @htmltag coral-actionbar-container
   @extends {HTMLElement}
   @extends {BaseComponent}

   @deprecated
   */

  var ActionBarContainer = /*#__PURE__*/function (_BaseActionBarContain) {
    _inherits(ActionBarContainer, _BaseActionBarContain);

    var _super = _createSuper(ActionBarContainer);

    /** @ignore */
    function ActionBarContainer() {
      var _this;

      _classCallCheck(this, ActionBarContainer);

      _this = _super.call(this);

      commons._log('warn', "Coral.ActionBar.Container: coral-actionbar-container has been deprecated.\n    Please use coral-actionbar-primary and coral-actionbar-secondary instead");

      return _this;
    }
    /**
     The container position inside the actionbar.
      @private
     @type {String}
     @readonly
     @default ActionBarContainerPositionEnum.INVALID
     */


    _createClass(ActionBarContainer, [{
      key: "_attachMoreButtonToContainer",

      /** @ignore */
      value: function _attachMoreButtonToContainer() {
        if (this.parentNode && this.parentNode.secondary === this) {
          this.insertBefore(this._elements.moreButton, this.firstChild);
        } else {
          // add the button to the left/primary contentzone
          this.appendChild(this._elements.moreButton);
        }
      }
      /**
       Returns {@link ActionBarContainer} positions.
        @return {ActionBarContainerPositionEnum}
       */

    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(ActionBarContainer.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$x); // Cleanup resize helpers object (cloneNode support)

        var resizeHelpers = this.getElementsByTagName('object');

        for (var i = 0; i < resizeHelpers.length; ++i) {
          var resizeElement = resizeHelpers[i];

          if (resizeElement.parentNode === this) {
            this.removeChild(resizeElement);
          }
        } // Cleanup 'More' button


        this._elements.moreButton = this.querySelector('[coral-actionbar-more]');

        if (this._elements.moreButton) {
          this.removeChild(this._elements.moreButton);
        } // Cleanup 'More' popover


        this._elements.overlay = this.querySelector('[coral-actionbar-popover]');

        if (this._elements.overlay) {
          this.removeChild(this._elements.overlay);
        } // Init 'More' button


        this._elements.moreButton.label.textContent = this.moreButtonText; // 'More' button might be moved later in dom when Container is attached to parent

        this.appendChild(this._elements.moreButton); // Init 'More' popover

        this._elements.overlay.target = this._elements.moreButton; // Insert popover always as firstChild to ensure element order (cloneNode support)

        this.insertBefore(this._elements.overlay, this.firstChild);

        this._attachMoreButtonToContainer();
      }
    }, {
      key: "_position",
      get: function get() {
        if (this.parentNode) {
          var containers = this.parentNode.getElementsByTagName('coral-actionbar-container');

          if (containers.length > 0 && containers[0] === this) {
            return position.PRIMARY;
          } else if (containers.length > 1 && containers[1] === this) {
            return position.SECONDARY;
          }
        }

        return position.INVALID;
      }
    }], [{
      key: "position",
      get: function get() {
        return position;
      }
    }]);

    return ActionBarContainer;
  }(BaseActionBarContainer(BaseComponent(HTMLElement)));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons.extend(strings, {
    'coral-component-actionbar': translations$9
  }); // Expose component on the Coral namespace

  commons._define('coral-actionbar-item', ActionBarItem);

  commons._define('coral-actionbar-primary', ActionBarPrimary);

  commons._define('coral-actionbar-secondary', ActionBarSecondary);

  commons._define('coral-actionbar-container', ActionBarContainer);

  commons._define('coral-actionbar', ActionBar);

  ActionBar.Item = ActionBarItem;
  ActionBar.Primary = ActionBarPrimary;
  ActionBar.Secondary = ActionBarSecondary;
  ActionBar.Container = ActionBarContainer;

  /**
   Enumeration for {@link Alert} variants.

   @typedef {Object} AlertVariantEnum

   @property {String} ERROR
   An alert with a warning icon to indicate that an error has occurred.
   @property {String} WARNING
   An alert with a warning icon to warn the user of something important.
   @property {String} SUCCESS
   An alert with a question mark icon to notify the user of a successful operation.
   @property {String} HELP
   A neutral alert with a question icon to help the user with non-critical information.
   @property {String} INFO
   An alert with an info icon to inform the user of non-critical information.
   */

  var variant$9 = {
    ERROR: 'error',
    WARNING: 'warning',
    SUCCESS: 'success',
    HELP: 'help',
    INFO: 'info'
  };
  /**
   Enumeration for {@link Alert} sizes.

   @typedef {Object} AlertSizeEnum

   @property {String} SMALL
   A small alert, usually employed for single line alerts without headers.
   @property {String} LARGE
   Not supported. Falls back to SMALL.
   */

  var size$4 = {
    SMALL: 'S',
    LARGE: 'L'
  };
  var CLASSNAME$y = '_coral-Alert'; // An array of all possible variant classnames

  var ALL_VARIANT_CLASSES$6 = [];

  for (var variantValue$4 in variant$9) {
    ALL_VARIANT_CLASSES$6.push("".concat(CLASSNAME$y, "--").concat(variant$9[variantValue$4]));
  } // Used to map icon with variant


  var capitalize$3 = function capitalize(s) {
    return s.charAt(0).toUpperCase() + s.slice(1);
  };
  /**
   @class Coral.Alert
   @classdesc An Alert component used as static indicators of an operation's result, or as messages to highlight
   information to the user. It does not include a close button by default, but you can add it manually by adding the
   <code>coral-close</code> attribute on an element contained by the Alert.
   @htmltag coral-alert
   @extends {HTMLElement}
   @extends {BaseComponent}
   */


  var Alert = /*#__PURE__*/function (_BaseComponent) {
    _inherits(Alert, _BaseComponent);

    var _super = _createSuper(Alert);

    /** @ignore */
    function Alert() {
      var _this;

      _classCallCheck(this, Alert);

      _this = _super.call(this); // Prepare templates

      _this._elements = {
        // Fetch or create the content zone elements
        header: _this.querySelector('coral-alert-header') || document.createElement('coral-alert-header'),
        content: _this.querySelector('coral-alert-content') || document.createElement('coral-alert-content'),
        footer: _this.querySelector('coral-alert-footer') || document.createElement('coral-alert-footer')
      }; // Events

      _this._delegateEvents({
        'click [coral-close]': '_onCloseClick'
      });

      return _this;
    }
    /**
     The alert variant style to use. See {@link AlertVariantEnum}.
      @type {String}
     @default AlertVariantEnum.INFO
     @htmlattribute variant
     @htmlattributereflected
     */


    _createClass(Alert, [{
      key: "_onCloseClick",

      /**
       @ignore
       @todo maybe this should be base or something
       */
      value: function _onCloseClick(event) {
        var dismissTarget = event.matchedTarget;
        var dismissValue = dismissTarget.getAttribute('coral-close');

        if (!dismissValue || this.matches(dismissValue)) {
          this.hidden = true;
          event.stopPropagation();
        }

        this._trackEvent('close', 'coral-alert', event);
      }
    }, {
      key: "_insertTemplate",
      value: function _insertTemplate() {
        if (this._elements.icon) {
          this._elements.icon.remove();
        }

        var variantValue = this.variant; // Warning icon is same as ERROR icon

        if (variantValue === variant$9.WARNING || variantValue === variant$9.ERROR) {
          variantValue = 'alert';
        } // Inject the SVG icon


        var iconName = capitalize$3(variantValue);
        this.insertAdjacentHTML('afterbegin', Icon._renderSVG("spectrum-css-icon-".concat(iconName, "Medium"), ['_coral-Alert-icon', "_coral-UIIcon-".concat(iconName, "Medium")]));
        this._elements.icon = this.querySelector('._coral-Alert-icon');
      }
    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(Alert.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$y); // a11y

        this.setAttribute('role', 'alert'); // Default reflected attributes

        if (!this._variant) {
          this.variant = variant$9.INFO;
        }

        if (!this._size) {
          this.size = size$4.SMALL;
        }

        for (var contentZone in this._contentZones) {
          var element = this._elements[this._contentZones[contentZone]]; // Remove it so we can process children

          if (element.parentNode) {
            element.parentNode.removeChild(element);
          }
        }

        while (this.firstChild) {
          var child = this.firstChild;

          if (child.nodeType === Node.TEXT_NODE || child.nodeType === Node.ELEMENT_NODE && !child.classList.contains('_coral-Alert-icon')) {
            // Add non-template elements to the content
            this._elements.content.appendChild(child);
          } else {
            // Remove anything else element
            this.removeChild(child);
          }
        }

        this._insertTemplate(); // Assign the content zones so the insert functions will be called


        for (var _contentZone in this._contentZones) {
          var contentZoneName = this._contentZones[_contentZone];
          /** @ignore */

          this[contentZoneName] = this._elements[contentZoneName];
        }
      }
    }, {
      key: "variant",
      get: function get() {
        return this._variant || variant$9.INFO;
      },
      set: function set(value) {
        var _this$classList;

        value = transform.string(value).toLowerCase();
        this._variant = validate.enumeration(variant$9)(value) && value || variant$9.INFO;

        this._reflectAttribute('variant', this._variant);

        this._insertTemplate(); // Remove all variant classes


        (_this$classList = this.classList).remove.apply(_this$classList, ALL_VARIANT_CLASSES$6); // Set new variant class
        // Don't use this._className; use the constant
        // This lets popover get our styles for free


        this.classList.add("".concat(CLASSNAME$y, "--").concat(this._variant));
      }
      /**
       The size of the alert. It accepts both lower and upper case sizes. See {@link AlertVariantEnum}.
        @type {String}
       @default AlertSizeEnum.SMALL
       @htmlattribute size
       @htmlattributereflected
       */

    }, {
      key: "size",
      get: function get() {
        return this._size || size$4.SMALL;
      },
      set: function set(value) {
        value = transform.string(value).toUpperCase();
        this._size = validate.enumeration(size$4)(value) && value || size$4.SMALL;

        this._reflectAttribute('size', this._size);
      }
      /**
       The alert header element.
        @type {AlertHeader}
       @contentzone
       */

    }, {
      key: "header",
      get: function get() {
        return this._getContentZone(this._elements.header);
      },
      set: function set(value) {
        this._setContentZone('header', value, {
          handle: 'header',
          tagName: 'coral-alert-header',
          insert: function insert(header) {
            header.classList.add("".concat(CLASSNAME$y, "-header"));
            this.insertBefore(header, this.firstChild);
          }
        });
      }
      /**
       The alert content element.
        @type {AlertContent}
       @contentzone
       */

    }, {
      key: "content",
      get: function get() {
        return this._getContentZone(this._elements.content);
      },
      set: function set(value) {
        this._setContentZone('content', value, {
          handle: 'content',
          tagName: 'coral-alert-content',
          insert: function insert(content) {
            content.classList.add("".concat(CLASSNAME$y, "-content")); // After the header

            this.insertBefore(content, this.header.nextElementSibling);
          }
        });
      }
      /**
       The alert footer element.
        @type {AlertFooter}
       @contentzone
       */

    }, {
      key: "footer",
      get: function get() {
        return this._getContentZone(this._elements.footer);
      },
      set: function set(value) {
        this._setContentZone('footer', value, {
          handle: 'footer',
          tagName: 'coral-alert-footer',
          insert: function insert(footer) {
            footer.classList.add("".concat(CLASSNAME$y, "-footer")); // After the content

            this.insertBefore(footer, this.content.nextElementSibling);
          }
        });
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-alert-header': 'header',
          'coral-alert-content': 'content',
          'coral-alert-footer': 'footer'
        };
      }
      /**
       Returns {@link Alert} variants.
        @return {AlertVariantEnum}
       */

    }], [{
      key: "variant",
      get: function get() {
        return variant$9;
      }
      /**
       Returns {@link Alert} sizes.
        @return {AlertSizeEnum}
       */

    }, {
      key: "size",
      get: function get() {
        return size$4;
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(Alert), "observedAttributes", this).concat(['variant', 'size']);
      }
    }]);

    return Alert;
  }(BaseComponent(HTMLElement));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Alert.Header
   @classdesc The Alert header content
   @htmltag coral-alert-header
   @return {HTMLElement}
   */
  var AlertHeader = (function () {
    return document.createElement('coral-alert-header');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Alert.Content
   @classdesc The Alert default content
   @htmltag coral-alert-content
   @return {HTMLElement}
   */
  var AlertContent = (function () {
    return document.createElement('coral-alert-content');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Alert.Footer
   @classdesc The Alert footer content
   @htmltag coral-alert-footer
   @return {HTMLElement}
   */
  var AlertFooter = (function () {
    return document.createElement('coral-alert-footer');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons._define('coral-alert', Alert);

  Alert.Header = AlertHeader;
  Alert.Content = AlertContent;
  Alert.Footer = AlertFooter;

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var translations$a = {
    "en-US": {
      "No matching results&period;": "No matching results.",
      "Show suggestion": "Show suggestion",
      "Show {0} suggestions": "Show {0} suggestions",
      "Show suggestions": "Show suggestions"
    },
    "de-DE": {
      "No matching results&period;": "Keine passenden Ergebnisse.",
      "Show suggestion": "Vorschlag anzeigen",
      "Show {0} suggestions": "{0} VorschlÃ¤ge anzeigen",
      "Show suggestions": "VorschlÃ¤ge anzeigen"
    },
    "es-ES": {
      "No matching results&period;": "No hay resultados coincidentes.",
      "Show suggestion": "Mostrar sugerencia",
      "Show {0} suggestions": "Mostrar {0} sugerencias",
      "Show suggestions": "Mostrar sugerencias"
    },
    "ko-KR": {
      "No matching results&period;": "ì¼ì¹íë ê²°ê³¼ê° ììµëë¤.",
      "Show suggestion": "ì ì ì¬í­ íì",
      "Show {0} suggestions": "{0}ì ì ì¬í­ íì",
      "Show suggestions": "ì ì ì¬í­ íì"
    },
    "fr-FR": {
      "No matching results&period;": "Aucun rÃ©sultat correspondant.",
      "Show suggestion": "Afficher la suggestion",
      "Show {0} suggestions": "Afficher {0} suggestions",
      "Show suggestions": "Afficher les suggestions"
    },
    "ja-JP": {
      "No matching results&period;": "ä¸è´ããçµæãããã¾ããã",
      "Show suggestion": "å¥ååè£ãè¡¨ç¤º",
      "Show {0} suggestions": "{0}å¥ååè£ãè¡¨ç¤º",
      "Show suggestions": "å¥ååè£ãè¡¨ç¤º"
    },
    "zh-CN": {
      "No matching results&period;": "æ å¹éçç»æã",
      "Show suggestion": "æ¾ç¤ºå»ºè®®",
      "Show {0} suggestions": "æ¾ç¤º {0} ä¸ªå»ºè®®",
      "Show suggestions": "æ¾ç¤ºå»ºè®®"
    },
    "zh-TW": {
      "No matching results&period;": "æ²æç¸ç¬¦ççµæã",
      "Show suggestion": "é¡¯ç¤ºå»ºè­°",
      "Show {0} suggestions": "é¡¯ç¤º {0} åå»ºè­°",
      "Show suggestions": "é¡¯ç¤ºå»ºè­°"
    },
    "pt-BR": {
      "No matching results&period;": "Nenhum resultado correspondente.",
      "Show suggestion": "Mostrar sugestÃ£o",
      "Show {0} suggestions": "Mostrar {0} sugestÃµes",
      "Show suggestions": "Mostrar sugestÃµes"
    },
    "it-IT": {
      "No matching results&period;": "Nessun risultato corrispondente.",
      "Show suggestion": "Mostra suggerimento",
      "Show {0} suggestions": "Mostra {0} suggerimenti",
      "Show suggestions": "Mostra suggerimenti"
    },
    "nl-NL": {
      "No matching results&period;": "Geen overeenkomende resultaten.",
      "Show suggestion": "Voorstel tonen",
      "Show {0} suggestions": "{0} voorstellen tonen",
      "Show suggestions": "Voorstellen tonen"
    },
    "da-DK": {
      "No matching results&period;": "Ingen matchende resultater.",
      "Show suggestion": "Vis forslag",
      "Show {0} suggestions": "Vis  {0} forslag",
      "Show suggestions": "Vis forslag"
    },
    "fi-FI": {
      "No matching results&period;": "Vastaavia tuloksia ei ole.",
      "Show suggestion": "NÃ¤ytÃ¤ ehdotus",
      "Show {0} suggestions": "NÃ¤ytÃ¤ {0} ehdotusta",
      "Show suggestions": "NÃ¤ytÃ¤ ehdotukset"
    },
    "nb-NO": {
      "No matching results&period;": "Ingen tilsvarende resultater.",
      "Show suggestion": "Vis forslag",
      "Show {0} suggestions": "Vis {0} forslag",
      "Show suggestions": "Vis forslag"
    },
    "sv-SE": {
      "No matching results&period;": "Inga matchande resultat.",
      "Show suggestion": "Visa fÃ¶rslag",
      "Show {0} suggestions": "Visa {0} fÃ¶rslag",
      "Show suggestions": "Visa fÃ¶rslag"
    },
    "cs-CZ": {
      "No matching results&period;": "NeodpovÃ­dajÃ­ Å¾Ã¡dnÃ© vÃ½sledky.",
      "Show suggestion": "Zobrazit doporuÄenÃ­",
      "Show {0} suggestions": "Zobrazit nÃ¡sledujÃ­cÃ­ poÄet nÃ¡vrhÅ¯: {0}",
      "Show suggestions": "Zobrazit doporuÄenÃ­"
    },
    "pl-PL": {
      "No matching results&period;": "Brak pasujÄcych wynikÃ³w.",
      "Show suggestion": "PokaÅ¼ sugestiÄ",
      "Show {0} suggestions": "WyÅwietl {0} sugestii",
      "Show suggestions": "PokaÅ¼ sugestie"
    },
    "ru-RU": {
      "No matching results&period;": "ÐÐµÑ ÑÐ¾Ð¾ÑÐ²ÐµÑÑÑÐ²ÑÑÑÐ¸Ñ ÑÐµÐ·ÑÐ»ÑÑÐ°ÑÐ¾Ð².",
      "Show suggestion": "ÐÐ¾ÐºÐ°Ð·Ð°ÑÑ Ð¿ÑÐµÐ´Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ",
      "Show {0} suggestions": "ÐÐ¾ÐºÐ°Ð·Ð°ÑÑ Ð¿ÑÐµÐ´Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ ({0})",
      "Show suggestions": "ÐÐ¾ÐºÐ°Ð·Ð°ÑÑ Ð¿ÑÐµÐ´Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ"
    },
    "tr-TR": {
      "No matching results&period;": "EÅleÅen sonuÃ§ yok.",
      "Show suggestion": "Ãneriyi gÃ¶ster",
      "Show {0} suggestions": "{0} Ã¶nerilerini gÃ¶ster",
      "Show suggestions": "Ãnerileri gÃ¶ster"
    }
  };

  /**
   @class Coral.Autocomplete.Item
   @classdesc The Autocomplete Item
   @htmltag coral-autocomplete-item
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var AutocompleteItem = /*#__PURE__*/function (_BaseComponent) {
    _inherits(AutocompleteItem, _BaseComponent);

    var _super = _createSuper(AutocompleteItem);

    /** @ignore */
    function AutocompleteItem() {
      var _this;

      _classCallCheck(this, AutocompleteItem);

      _this = _super.call(this);
      _this._observer = new MutationObserver(_this._handleMutation.bind(_assertThisInitialized(_this)));

      _this._observer.observe(_assertThisInitialized(_this), {
        characterData: true,
        childList: true,
        subtree: true
      });

      return _this;
    }
    /**
     Value of the item. <code>textContent</code> is used if not provided.
      @type {String}
     @default ""
     @htmlattribute value
     @htmlattributereflected
     */


    _createClass(AutocompleteItem, [{
      key: "_handleMutation",

      /** @private */
      value: function _handleMutation() {
        this.trigger('coral-autocomplete-item:_contentchanged', {
          content: this.textContent
        });
      }
      /** @ignore */

    }, {
      key: "value",
      get: function get() {
        // keep spaces to only 1 max and trim to mimic native select option behavior
        return typeof this._value === 'undefined' ? this.getAttribute('value') || this.textContent.replace(/\s{2,}/g, ' ').trim() : this._value;
      },
      set: function set(value) {
        var _value = transform.string(value);

        if (this._value === _value) {
          return;
        }

        this._value = _value;

        this._reflectAttribute('value', this._value);

        this.trigger('coral-autocomplete-item:_valuechanged');
      } // @compat

    }, {
      key: "content",
      get: function get() {
        return this;
      },
      set: function set(value) {
        // Support configs
        if (_typeof(value) === 'object') {
          for (var prop in value) {
            /** @ignore */
            this[prop] = value[prop];
          }
        }
      }
      /**
       Whether this item is selected.
        @type {Boolean}
       @default false
       @htmlattribute selected
       @htmlattributereflected
       */

    }, {
      key: "selected",
      get: function get() {
        return this._selected || false;
      },
      set: function set(value) {
        var _selected = transform.booleanAttr(value);

        if (this._selected === _selected) {
          return;
        }

        this._selected = _selected;

        this._reflectAttribute('selected', this._selected);

        this.trigger('coral-autocomplete-item:_selectedchanged');
      }
      /**
       Whether this item is disabled.
        @type {Boolean}
       @default false
       @htmlattribute disabled
       @htmlattributereflected
       */

    }, {
      key: "disabled",
      get: function get() {
        return this._disabled || false;
      },
      set: function set(value) {
        this._disabled = transform.booleanAttr(value);

        this._reflectAttribute('disabled', this._disabled);
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(AutocompleteItem), "observedAttributes", this).concat(['selected', 'disabled', 'value']);
      }
    }]);

    return AutocompleteItem;
  }(BaseComponent(HTMLElement));

  var template$g = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var data = data_0 = typeof data_0 === "undefined" ? {} : data_0;
    var el0 = this["overlay"] = document.createElement("coral-popover");
    el0.setAttribute("withinoffset", "0");
    el0.setAttribute("smart", "");
    el0.id = data_0["commons"]["getUID"]();
    el0.className += " _coral-Autocomplete-overlay";
    el0.setAttribute("focusonshow", "off");
    el0.setAttribute("returnfocus", "off");
    el0.setAttribute("placement", "bottom");
    el0.setAttribute("handle", "overlay");
    el0.setAttribute("role", "presentation");
    el0.setAttribute("breadthoffset", "50%r - 50%p");
    var el1 = document.createTextNode("\n  ");
    el0.appendChild(el1);
    data = data_0; // Constrains the size of the list to 6 items.
    // @todo move this to theme

    var maxHeight = 'max-height:' + 32 * 6 + 'px';
    data_0 = data;
    var el3 = document.createTextNode("\n  ");
    el0.appendChild(el3);
    var el4 = this["selectList"] = document.createElement("coral-buttonlist");
    el4.setAttribute("style", maxHeight);
    el4.id = data_0["commons"]["getUID"]();
    el4.className += " _coral-Autocomplete-selectList";
    el4.setAttribute("handle", "selectList");
    el4.setAttribute("role", "listbox");
    el4.setAttribute("interaction", "off");
    el0.appendChild(el4);
    var el5 = document.createTextNode("\n");
    el0.appendChild(el5);
    frag.appendChild(el0);
    var el6 = document.createTextNode("\n");
    frag.appendChild(el6);
    var el7 = this["field"] = document.createElement("input");
    el7.setAttribute("type", "hidden");
    el7.setAttribute("handle", "field");
    frag.appendChild(el7);
    var el8 = document.createTextNode("\n");
    frag.appendChild(el8);
    var el9 = this["inputGroup"] = document.createElement("div");
    el9.className += " _coral-InputGroup _coral-Autocomplete-inputGroup";
    el9.setAttribute("handle", "inputGroup");
    el9.setAttribute("role", "presentation");
    var el10 = document.createTextNode("\n  ");
    el9.appendChild(el10);
    var el11 = this["input"] = document.createElement("input", "coral-textfield");
    el11.className += " _coral-InputGroup-field _coral-Autocomplete-input";
    el11.setAttribute("type", "text");
    el11.setAttribute("autocomplete", "off");
    el11.setAttribute("handle", "input");
    el11.setAttribute("role", "combobox");
    el11.setAttribute("is", "coral-textfield");
    el9.appendChild(el11);
    var el12 = document.createTextNode("\n  ");
    el9.appendChild(el12);
    var el13 = this["trigger"] = document.createElement("button", "coral-button");
    el13.setAttribute("type", "button");
    el13.className += " _coral-FieldButton _coral-InputGroup-button _coral-Autocomplete-trigger";
    el13.setAttribute("is", "coral-button");
    el13.setAttribute("variant", "_custom");
    el13.setAttribute("handle", "trigger");
    el13.setAttribute("aria-label", data_0["i18n"]["get"]('Show suggestions'));
    el13.setAttribute("title", data_0["i18n"]["get"]('Show suggestions'));
    var el14 = document.createTextNode("\n    ");
    el13.appendChild(el14);
    var el15 = this["label"] = document.createElement("coral-button-label");
    el15.setAttribute("handle", "label");
    el13.appendChild(el15);
    var el16 = document.createTextNode("\n    ");
    el13.appendChild(el16);
    data = data_0; // Don't wait for button MO to pick up the label

    this.trigger._elements.label = this.label; // Render invalid icon

    this.trigger.insertAdjacentHTML('beforeend', data.Icon._renderSVG('spectrum-css-icon-ChevronDownMedium', ['_coral-InputGroup-icon', '_coral-UIIcon-ChevronDownMedium']));
    data_0 = data;
    var el18 = document.createTextNode("\n  ");
    el13.appendChild(el18);
    el9.appendChild(el13);
    var el19 = document.createTextNode("\n");
    el9.appendChild(el19);
    frag.appendChild(el9);
    var el20 = document.createTextNode("\n");
    frag.appendChild(el20);
    var el21 = this["tagList"] = document.createElement("coral-taglist");
    el21.className += " _coral-Autocomplete-tagList";
    el21.setAttribute("handle", "tagList");
    frag.appendChild(el21);
    var el22 = document.createTextNode("\n");
    frag.appendChild(el22);
    return frag;
  };

  var template$h = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["loadIndicator"] = document.createElement("div");
    el0.className += " _coral-SelectList-loading";
    el0.setAttribute("handle", "loadIndicator");
    var el1 = document.createTextNode("\n  ");
    el0.appendChild(el1);
    var el2 = document.createElement("coral-wait");
    el2.setAttribute("centered", "");
    el0.appendChild(el2);
    var el3 = document.createTextNode("\n");
    el0.appendChild(el3);
    frag.appendChild(el0);
    var el4 = document.createTextNode("\n");
    frag.appendChild(el4);
    return frag;
  };

  var CLASSNAME$z = '_coral-Autocomplete';
  /**
   The distance, in pixels, from the bottom of the List at which we assume the user has scrolled
   to the bottom of the list.
   @type {Number}
   @ignore
   */

  var SCROLL_BOTTOM_THRESHOLD$1 = 50;
  /**
   The number of milliseconds for which scroll events should be debounced.
   @type {Number}
   @ignore
   */

  var SCROLL_DEBOUNCE$1 = 100;
  /**
   Enumeration for {@link Autocomplete} variants.

   @typedef {Object} AutocompleteVariantEnum

   @property {String} DEFAULT
   A default, gray Autocomplete.
   @property {String} QUIET
   An Autocomplete with no border or background.
   */

  var variant$a = {
    DEFAULT: 'default',
    QUIET: 'quiet'
  };
  /**
   Enumeration for {@link Autocomplete} match options.

   @typedef {Object} AutocompleteMatchEnum

   @property {String} STARTSWITH
   Include only matches that start with the user provided value.
   @property {String} CONTAINS
   Include only matches that contain the user provided value.
   */

  var match$1 = {
    STARTSWITH: 'startswith',
    CONTAINS: 'contains'
  };
  /**
   @class Coral.Autocomplete
   @classdesc An Autocomplete component that allows users to search and select from a list of options.
   @htmltag coral-autocomplete
   @extends {HTMLElement}
   @extends {BaseComponent}
   @extends {BaseFormField}
   */

  var Autocomplete = /*#__PURE__*/function (_BaseFormField) {
    _inherits(Autocomplete, _BaseFormField);

    var _super = _createSuper(Autocomplete);

    /** @ignore */
    function Autocomplete() {
      var _this;

      _classCallCheck(this, Autocomplete);

      _this = _super.call(this); // Template

      _this._elements = {};
      template$g.call(_this._elements, {
        Icon: Icon,
        commons: commons,
        i18n: i18n
      });

      _this._elements.tagList.reset = function () {// Kill inner tagList reset so it doesn't interfer with the autocomplete reset
      }; // Pre-define labellable element


      _this._labellableElement = _this._elements.input;
      var overlayId = _this._elements.overlay.id;
      var events = {
        // ARIA Autocomplete role keyboard interaction
        // http://www.w3.org/TR/wai-aria-practices/#autocomplete
        'key:up [handle="input"]': '_handleInputUpKeypress',
        'key:alt+up [handle="input"]': '_handleInputUpKeypress',
        'key:down [handle="input"]': '_handleInputDownKeypress',
        'key:alt+down [handle="input"]': '_handleInputDownKeypress',
        'key:tab [handle="input"]': '_handleInputTabKeypress',
        'key:shift+tab [handle="input"]': '_handleListFocusShift',
        'capture:change [handle="input"]': '_handleInput',
        'input [handle="input"]': '_handleInputEvent',
        // Manually listen to keydown event due to CUI-3973
        'keydown': '_handleInputKeypressEnter',
        // Interaction
        'click [handle="trigger"]': '_handleTriggerClick',
        'mousedown [handle="trigger"]': '_handleTriggerMousedown',
        // Focus
        'capture:blur': '_handleFocusOut',
        'global:click': '_onGlobalClick',
        'global:touchstart': '_onGlobalClick',
        // Taglist
        'coral-collection:add [handle="tagList"]': '_handleTagAdded',
        'coral-collection:remove [handle="tagList"]': '_handleTagRemoved',
        'change [handle="tagList"]': '_preventTagListChangeEvent',
        // Items
        'coral-autocomplete-item:_valuechanged': '_handleItemValueChange',
        'coral-autocomplete-item:_selectedchanged': '_handleItemSelectedChange',
        'coral-autocomplete-item:_contentchanged': '_handleItemContentChange'
      }; // Interaction

      events["global:key:shift+tab #".concat(overlayId, " [is=\"coral-buttonlist-item\"]")] = '_handleListFocusShift';
      events["global:key:esc"] = '_handleListFocusShift'; // Overlay

      events["global:capture:coral-overlay:positioned #".concat(overlayId)] = '_onOverlayPositioned';
      events["global:capture:coral-overlay:open #".concat(overlayId)] = '_onOverlayOpenOrClose';
      events["global:capture:coral-overlay:close #".concat(overlayId)] = '_onOverlayOpenOrClose'; // SelectList

      events["global:key:enter #".concat(overlayId, " button[is=\"coral-buttonlist-item\"]")] = '_handleSelect';
      events["global:capture:mousedown #".concat(overlayId, " button[is=\"coral-buttonlist-item\"]")] = '_handleSelect';
      events["global:capture:scroll #".concat(overlayId, " [handle=\"selectList\"]")] = '_onScroll';
      events["global:capture:mousewheel #".concat(overlayId, " [handle=\"selectList\"]")] = '_onMouseWheel';
      events["global:capture:mousedown #".concat(overlayId, " [handle=\"selectList\"]")] = '_onMouseDown'; // Events

      _this._delegateEvents(events); // A map of values to tags


      _this._tagMap = {}; // A list of selected values

      _this._values = []; // A list of options objects

      _this._options = []; // A map of option values to their content

      _this._optionsMap = {}; // Used for reset

      _this._initialSelectedValues = []; // Bind the debounced scroll method

      _this._handleScrollBottom = _this._handleScrollBottom.bind(_assertThisInitialized(_this)); // Listen for mutations

      _this._observer = new MutationObserver(_this._handleMutation.bind(_assertThisInitialized(_this)));

      _this._startObserving();

      return _this;
    }
    /**
     Returns the inner overlay to allow customization.
      @type {Popover}
     @readonly
     */


    _createClass(Autocomplete, [{
      key: "_getName",

      /** @private */
      value: function _getName() {
        if (this.multiple) {
          return this._elements.tagList.name;
        }

        return this._elements.field.name;
      }
      /**
       Set the name accordingly for multiple/single mode so the form submits contain only the right fields.
        @private
       */

    }, {
      key: "_setName",
      value: function _setName(value) {
        if (this.multiple) {
          this._elements.tagList.name = value;
          this._elements.field.name = '';
        } else {
          this._elements.field.name = value;
          this._elements.tagList.name = '';
        }
      }
      /** @private */

    }, {
      key: "_startObserving",
      value: function _startObserving() {
        this._observer.observe(this, {
          // Only watch the childList
          // Items will tell us if selected/value/content changes
          childList: true
        });
      }
      /**
       Stop watching for mutations. This should be done before manually updating observed properties.
        @protected
       */

    }, {
      key: "_stopObserving",
      value: function _stopObserving() {
        this._observer.disconnect();
      } // Override to do nothing

    }, {
      key: "_onInputChange",
      value: function _onInputChange(event) {
        // stops the current event
        event.stopPropagation();

        if (!this.multiple) {
          var inputText = this._elements.input.value.toLowerCase();

          if (this.forceSelection || inputText === '') {
            // We need a way to deselect item in single selection mode
            // 1) by using an empty string if this.forceSelection === false
            // 2) by using an invalid string if this.forceSelection === true
            var items = this.items.getAll();

            for (var i = 0; i < items.length; i++) {
              if (items[i].value.toLowerCase() !== inputText) {
                items[i].selected = false;
              }
            }
          }
        }
      }
      /**
       Handle mutations to children and childList. This is used to keep the options in sync with DOM changes.
        @private
       */

    }, {
      key: "_handleMutation",
      value: function _handleMutation(mutations) {
        for (var i = 0; i < mutations.length; i++) {
          var mutation = mutations[i];
          var target = mutation.target;

          if (mutation.type === 'childList' && target === this) {
            this._setStateFromDOM();

            return;
          }
        }
      }
      /**
       Update the option set and selected options from the DOM.
        @private
       */

    }, {
      key: "_setStateFromDOM",
      value: function _setStateFromDOM() {
        this._createOptionsFromDOM();

        this._setSelectedFromDOM();
      }
      /**
       Create the set of options from nodes in the DOM.
        @private
       */

    }, {
      key: "_createOptionsFromDOM",
      value: function _createOptionsFromDOM() {
        var _this2 = this;

        // Reset options array and value to content map
        this._options.length = 0;
        this._optionsMap = {};
        this.items.getAll().forEach(function (item) {
          // Don't use properties as children may not be initialized yet
          var itemObj = {
            value: item.getAttribute('value'),
            icon: item.getAttribute('icon'),
            disabled: item.hasAttribute('disabled'),
            content: item.innerHTML.replace(/\s{2,}/g, ' ').trim(),
            text: item.innerText
          };

          _this2._options.push(itemObj);

          _this2._optionsMap[itemObj.value] = itemObj;
        }); // @todo update value in hidden field if changed value = old value?
      }
      /** @private */

    }, {
      key: "_setInputValues",
      value: function _setInputValues(value, content) {
        this._elements.field.value = value; // Set text into input if in "multiple selection mode" or in "single selection mode and content is not empty"
        // otherwise keep the current text for us (should be marked red)

        if (this.multiple || content !== '') {
          this._elements.input.value = content.trim();
        }
      }
      /** @private */

    }, {
      key: "_reflectCurrentValue",
      value: function _reflectCurrentValue() {
        // Use empty string if no values
        var value = this._values.length > 0 ? this._values[0] : ''; // Reflect the value in the field for form submit

        this._elements.field.value = value;
        var content = '';

        if (value !== '') {
          // Find the object with the corresponding content
          var itemObj = this._optionsMap[value];

          if (itemObj) {
            // Reflect the content in the input
            content = itemObj.content;
          } else {
            // Just use the provided value
            content = value;
          }
        }

        this._setInputValues(value, content);
      }
      /**
       Update the option set and selected options from the DOM
       @ignore
       */

    }, {
      key: "_setSelectedFromDOM",
      value: function _setSelectedFromDOM() {
        var selectedItems = this.selectedItems;

        if (selectedItems.length) {
          // Use this.hasAttribute('multiple') instead of this.multiple here, as this method is called from _render and element might not be ready
          if (this.hasAttribute('multiple')) {
            // Remove current tags
            this._resetValues(); // Add new ones


            for (var i = 0; i < selectedItems.length; i++) {
              var value = selectedItems[i].getAttribute('value');
              var content = selectedItems[i].innerHTML;

              this._addValue(value, content, true);
            }
          } else {
            // Select last
            var last = selectedItems[selectedItems.length - 1]; // Deselect others

            this._deselectExcept(last, selectedItems); // Set value from the attribute
            // We don't want to use the property as the sub-component may not have been upgraded yet


            this.value = last.getAttribute('value');
          }
        } else if (!this.hasAttribute('value')) {
          if (this.hasAttribute('multiple')) {
            this._resetValues();
          } else {
            this.value = '';
          }
        }
      }
      /**
       De-select every item except the provided item.
        @param {HTMLElement} exceptItem
       The item not to select
       @param {Array.<HTMLElement>} [items]
       The set of items to consider when deselecting. If not provided, the current set of selected items is used.
        @private
       */

    }, {
      key: "_deselectExcept",
      value: function _deselectExcept(exceptItem, items) {
        var selectedItems = items || this.selectedItems; // Deselect others

        this._stopObserving();

        for (var i = 0; i < selectedItems.length; i++) {
          if (selectedItems[i] !== exceptItem) {
            selectedItems[i].removeAttribute('selected');
          }
        }

        this._startObserving();
      }
      /**
       Add a tag to the taglist.
        @private
       */

    }, {
      key: "_addValue",
      value: function _addValue(value, content, asHTML) {
        if (!content) {
          // Find the content
          var itemObj = this._optionsMap[value];

          if (itemObj) {
            content = itemObj.content;
          } else {
            // Just use the value
            content = value;
          }
        } // Add to selected values


        var index = this._values.indexOf(value);

        if (index === -1) {
          this._values.push(value);
        }

        var labelContent = {};

        if (asHTML) {
          labelContent.innerHTML = content;
        } else {
          labelContent.textContent = content;
        } // Create a new tag


        var tag = new Tag().set({
          label: labelContent,
          value: value
        }); // Add to map

        this._tagMap[value] = tag; // Add to taglist

        this._elements.tagList.items.add(tag); // make sure to remove text from input box (to easily choose next item)


        this._setInputValues('', '');
      }
      /**
       Remove a tag from the taglist.
        @private
       */

    }, {
      key: "_removeValue",
      value: function _removeValue(value) {
        // Remove from selected values
        var index = this._values.indexOf(value);

        if (index === -1) {
          // Get out if we don't have the value
          return;
        }

        this._values.splice(index, 1); // Select autocomplete item


        var item = this.querySelector("coral-autocomplete-item[value=".concat(JSON.stringify(value), "]"));

        if (item) {
          if (item.hasAttribute('selected')) {
            this._stopObserving();

            item.removeAttribute('selected');

            this._startObserving();
          }
        } // Look up the tag by value


        var tag = this._tagMap[value];

        if (tag) {
          // Remove from map
          this._tagMap[value] = null; // Remove from taglist

          this._elements.tagList.items.remove(tag);
        }

        if (index !== -1) {
          // Emit the change event when a value is removed but only after a user interaction
          this.trigger('change');
        }
      }
      /**
       Remove all tags from the taglist.
        @private
       */

    }, {
      key: "_clearValues",
      value: function _clearValues() {
        this._resetValues(); // Deselect items


        this._stopObserving();

        var items = this.querySelectorAll('coral-autocomplete-item[selected]');

        for (var i = 0; i < items.length; i++) {
          items[i].removeAttribute('selected');
        }

        this._startObserving();
      }
      /**
       Reset values without affecting the DOM.
        @private
       */

    }, {
      key: "_resetValues",
      value: function _resetValues() {
        // Reset values
        this._values = []; // Drop references to tags

        this._tagMap = {}; // Clear taglist

        this._elements.tagList.items.clear();
      }
      /** @private */

    }, {
      key: "_focusNextItem",
      value: function _focusNextItem() {
        var _this3 = this;

        // Display focus on next item in the selectList
        var selectList = this._elements.selectList;
        var currentItem = selectList.querySelector('.is-focused');
        var input = this._elements.input;

        var items = selectList._getSelectableItems();

        var index;
        var item;

        if (currentItem) {
          index = items.indexOf(currentItem);

          if (index < items.length - 1) {
            item = items[index + 1];
          }
        } else if (items && items.length > 0) {
          item = items[0];
        }

        window.requestAnimationFrame(function () {
          if (item) {
            if (currentItem) {
              currentItem.classList.remove('is-focused');
            }

            _this3._scrollItemIntoView(item);

            item.classList.add('is-focused');
            input.setAttribute('aria-activedescendant', item.id);
          }

          if (!selectList.querySelector('.is-focused')) {
            input.removeAttribute('aria-activedescendant');
          }
        });
      }
      /** @private */

    }, {
      key: "_focusPreviousItem",
      value: function _focusPreviousItem() {
        var _this4 = this;

        // Display focus on previous item in the selectList
        var selectList = this._elements.selectList;
        var currentItem = selectList.querySelector('.is-focused');
        var input = this._elements.input;

        var items = selectList._getSelectableItems();

        var index;
        var item;

        if (currentItem) {
          index = items.indexOf(currentItem);

          if (index > 0) {
            item = items[index - 1];
          }

          currentItem.classList.remove('is-focused');
        } else if (items && items.length > 0) {
          item = items[items.length - 1];
        }

        window.requestAnimationFrame(function () {
          if (item) {
            _this4._scrollItemIntoView(item);

            item.classList.add('is-focused');
            input.setAttribute('aria-activedescendant', item.id);
          }

          if (!selectList.querySelector('.is-focused')) {
            input.removeAttribute('aria-activedescendant');
          }
        });
      }
      /** @private */

    }, {
      key: "_showSuggestions",
      value: function _showSuggestions() {
        // Get value from the input
        var inputValue = this._elements.input.value.toLowerCase().trim(); // Since we're showing fresh suggestions, clear the existing suggestions


        this.clearSuggestions(); // Trigger an event

        var event = this.trigger('coral-autocomplete:showsuggestions', {
          // Pass user input
          value: inputValue,
          // Started at zero here, always
          start: 0
        }); // Flag to indicate that the private method is called before public showSuggestions method

        this._showSuggestionsCalled = true;

        if (event.defaultPrevented) {
          // Set loading mode
          this.loading = true; // Show the menu

          this.showSuggestions();
        } else {
          // Show suggestions that match in the DOM
          this.addSuggestions(this._getMatches(inputValue, this._optionContainsValue));
          this.showSuggestions();
        }
      }
    }, {
      key: "_onOverlayPositioned",
      value: function _onOverlayPositioned(event) {
        // stops propagation cause the event is internal to the component
        event.stopImmediatePropagation();

        if (this._elements.overlay.open) {
          this._elements.overlay.style.width = "".concat(this.offsetWidth, "px");
        }
      }
    }, {
      key: "_onGlobalClick",
      value: function _onGlobalClick(event) {
        if (!this._elements.overlay.open) {
          return;
        }

        var eventTargetWithinOverlayTarget = this._elements.inputGroup.contains(event.target);

        var eventTargetWithinItself = this._elements.overlay.contains(event.target);

        if (!eventTargetWithinOverlayTarget && !eventTargetWithinItself) {
          this.hideSuggestions();
        }
      }
      /** @private */

    }, {
      key: "_onScroll",
      value: function _onScroll() {
        this._isOverlayScrolling = true;
        window.clearTimeout(this._scrollTimeout);
        this._scrollTimeout = window.setTimeout(this._handleScrollBottom, SCROLL_DEBOUNCE$1);
      }
      /** @private */

    }, {
      key: "_onMouseWheel",
      value: function _onMouseWheel(event) {
        var selectList = this._elements.selectList; // If scrolling with mouse wheel and if it has hit the top or bottom boundary
        // `SCROLL_BOTTOM_THRESHOLD` is ignored when hitting scroll bottom to allow debounced loading

        if (event.deltaY < 0 && selectList.scrollTop === 0 || event.deltaY > 0 && selectList.scrollTop >= selectList.scrollHeight - selectList.clientHeight) {
          event.preventDefault();
        }
      }
    }, {
      key: "_onMouseDown",
      value: function _onMouseDown(event) {
        this._isOverlayScrollBarClicked = event.matchedTarget.clientWidth <= event.offsetX;
      }
      /** @private */

    }, {
      key: "_handleScrollBottom",
      value: function _handleScrollBottom() {
        var selectList = this._elements.selectList;

        if (selectList.scrollTop >= selectList.scrollHeight - selectList.clientHeight - SCROLL_BOTTOM_THRESHOLD$1) {
          var inputValue = this._elements.input.value; // Do not clear the suggestions here, instead we'll expect them to append
          // Trigger an event

          var event = this.trigger('coral-autocomplete:showsuggestions', {
            // Pass user input
            value: inputValue,
            start: selectList.items.length
          });

          if (event.defaultPrevented) {
            // Set loading mode
            this.loading = true;
          }
        }
      }
      /** @private */

    }, {
      key: "_handleFocusOut",
      value: function _handleFocusOut(event) {
        var _this5 = this;

        var selectList = this._elements.selectList;
        var target = event.target;
        var inputBlur = target === this._elements.input;

        if (this._blurTimeout) {
          clearTimeout(this._blurTimeout);
        } // This is to hack around the fact that you cannot determine which element gets focus in a blur event
        // Firefox doesn't support focusout/focusin, so we're left doing awful things


        this._blurTimeout = window.setTimeout(function () {
          var relatedTarget = document.activeElement;
          var focusOutside = !_this5.contains(relatedTarget) && !_this5._elements.overlay.contains(relatedTarget); // If focus has moved out of the autocomplete, it's an input event

          if (inputBlur && focusOutside && !_this5.multiple) {
            _this5._handleInput(event);
          } // Nothing was focused
          else if (!relatedTarget || (inputBlur || relatedTarget !== document.body) && // Focus is now outside of the autocomplete component
            focusOutside || // Focus has shifted from the selectList to another element inside of the autocomplete component
            selectList.contains(target) && !selectList.contains(relatedTarget)) {
              _this5.hideSuggestions();
            }
        }, 0);
      }
      /** @private */

    }, {
      key: "_handleListFocusShift",
      value: function _handleListFocusShift(event) {
        if (this._elements.overlay.open) {
          // Stop focus shift
          event.preventDefault();
          event.stopImmediatePropagation();

          this._hideSuggestionsAndFocus();
        }
      }
      /** @private */

    }, {
      key: "_hideSuggestionsAndFocus",
      value: function _hideSuggestionsAndFocus() {
        // Hide the menu and focus on the input
        this.hideSuggestions();

        this._elements.input.focus();
      }
      /** @private */

    }, {
      key: "_handleTriggerClick",
      value: function _handleTriggerClick() {
        if (this._elements.overlay.classList.contains('is-open')) {
          this._hideSuggestionsAndFocus();
        } else {
          // Focus on the input so down arrow works as expected
          // Per @mijordan
          this._showSuggestions();

          this._elements.input.focus();
        }
      }
      /** @private */

    }, {
      key: "_handleTriggerMousedown",
      value: function _handleTriggerMousedown() {
        this._elements.trigger.focus();
      }
      /** @private */

    }, {
      key: "_handleListItemFocus",
      value: function _handleListItemFocus(event) {
        var item = event.matchedTarget;
        var selectList = this._elements.selectList;
        var currentItem = selectList.querySelector('.is-focused');
        var input = this._elements.input;

        if (currentItem) {
          currentItem.classList.remove('is-focused');
          input.removeAttribute('aria-activedescendant');
        }

        if (!item.disabled) {
          this._scrollItemIntoView(item);

          item.classList.add('is-focused');
          input.setAttribute('aria-activedescendant', item.id);
        }
      }
      /** @private */

    }, {
      key: "_scrollItemIntoView",
      value: function _scrollItemIntoView(item) {
        var itemRect = item.getBoundingClientRect();

        var selectListRect = this._elements.selectList.getBoundingClientRect();

        if (itemRect.top < selectListRect.top) {
          item.scrollIntoView();
        } else if (itemRect.bottom > selectListRect.bottom) {
          item.scrollIntoView(false);
        }
      }
      /** @private */

    }, {
      key: "_getMatches",
      value: function _getMatches(value, optionMatchesValue) {
        optionMatchesValue = optionMatchesValue || this._matchFunction;
        var matches = [];

        for (var i = 0; i < this._options.length; i++) {
          if (optionMatchesValue(this._options[i], value)) {
            matches.push(this._options[i]);
          }
        }

        if (!matches.length) {
          // If there are no matches in _options,
          // Check for matches in list, which could have been added after mounting the element
          var buttons = this._elements.selectList.items.getAll();

          for (var _i = 0; _i < buttons.length; _i++) {
            var option = {
              value: buttons[_i].value,
              content: buttons[_i].textContent.trim()
            };

            if (optionMatchesValue(option, value)) {
              matches.push(option);
            }
          }
        }

        return matches;
      }
      /** @private */

    }, {
      key: "_handleInputKeypressEnter",
      value: function _handleInputKeypressEnter(event) {
        // Sigh, CUI-3973 Hitting enter quickly after typing causes form to submit
        if (event.which === 13) {
          this._handleInput(event);
        }
      }
      /** @private */

    }, {
      key: "_handleInputEvent",
      value: function _handleInputEvent() {
        // Any input makes this valid again
        this.invalid = false;

        if (this.delay) {
          // Wait until the use has stopped typing for delay milliseconds before getting suggestions
          window.clearTimeout(this._timeout);
          this._timeout = window.setTimeout(this._showSuggestions.bind(this), this.delay);
        } else {
          // Immediately get suggestions
          this._showSuggestions();
        }
      }
      /** @private */

    }, {
      key: "_handleInput",
      value: function _handleInput(event) {
        // Don't set value and hide suggestions while scrolling overlay
        if (this._isOverlayScrolling || this._isOverlayScrollBarClicked) {
          this._isOverlayScrolling = false;
          this._isOverlayScrollBarClicked = false;
          return;
        } // Stop the event


        event.preventDefault();
        var focusedItemValue; // If a selectList item has focus, set the input value to the value of the selected item.

        if (this._elements.overlay.open && this._elements.input.getAttribute('aria-activedescendant')) {
          var focusedItem = this._elements.selectList.querySelector('.is-focused');

          if (focusedItem) {
            // Use the text content value of the item for comparison
            focusedItemValue = focusedItem.textContent.trim();
          }
        }

        var value = focusedItemValue || this._elements.input.value;
        var isChange = false; // Get all exact matches

        var exactMatches = this._getMatches(value, this._optionEqualsValue);

        if (exactMatches.length) {
          // Find perfect case sensitive match else defaults to first one
          var exactMatch = exactMatches.filter(function (option) {
            return option.content === value;
          })[0] || exactMatches[0];
          isChange = this.value !== exactMatch.value; // Select the matched item

          this._selectItem(exactMatch.value, exactMatch.content, false);

          if (this.multiple) {
            if (value.trim()) {
              // Add tag for non-empty values
              this._addValue(exactMatch.value, exactMatch.content, false);
            }
          } else {
            // Set value
            this.value = exactMatch.value;
          } // value can't be invalid as an exact match is selected


          if (this.forceSelection) {
            this.invalid = false;
          } // Hide the suggestions so the result can be seen


          this.hideSuggestions(); // Emit the change event when a selection is made from an exact match

          if (isChange === true) {
            this.trigger('change');
          }
        } else if (this.forceSelection) {
          // Invalid
          if (this.multiple) {
            this.invalid = value !== '' || this.values.length === 1 && this.values[0] === '' || this.values.length === 0;
          } else {
            this.invalid = true;
          } // Leave suggestions open if nothing matches

        } else {
          // DO NOT select the corresponding item, as this would add an item
          // This would result in adding items that match what the user typed, resulting in selections
          // this._selectItem(value);
          isChange = this.value !== value;

          if (this.multiple) {
            if (value.trim()) {
              // Add tag for non-empty values
              this._addValue(value, null, false);
            }
          } else {
            // Set value
            this.value = value;
          } // Hide the suggestions so the result can be seen


          this.hideSuggestions(); // Emit the change event when arbitrary data is entered

          if (isChange === true) {
            this.trigger('change');
          }
        }

        this._updateButtonAccessibilityLabel();
      }
      /**
       This ensures the collection API is up to date with selected items, even if they come from suggestions.
        @private
       */

    }, {
      key: "_selectItem",
      value: function _selectItem(value, content, asHTML) {
        // Don't get caught up with internal changes
        this._stopObserving(); // Select autocomplete item if it's there


        var item = this.querySelector("coral-autocomplete-item[value=".concat(JSON.stringify(value), "]"));

        if (item) {
          // Select the existing item
          item.setAttribute('selected', '');
        } else {
          var labelContent = {};
          content = typeof content === 'undefined' ? value : content;

          if (asHTML) {
            labelContent.innerHTML = content;
          } else {
            labelContent.textContent = content;
          } // Add a new, selected item


          this.items.add(new AutocompleteItem().set({
            value: value,
            content: labelContent,
            selected: true
          }));
        } // Resume watching for changes


        this._startObserving();
      }
      /** @private */

    }, {
      key: "_handleInputUpKeypress",
      value: function _handleInputUpKeypress(event) {
        // Stop any consequences of pressing the key
        event.preventDefault();

        if (this._elements.overlay.open) {
          if (event.altKey) {
            this.hideSuggestions();
          } else {
            this._focusPreviousItem();
          }
        } else {
          // Show the menu and do not focus on the first item
          // Implements behavior of http://www.w3.org/TR/wai-aria-practices/#autocomplete
          this._showSuggestions();
        }
      }
      /** @private */

    }, {
      key: "_handleInputDownKeypress",
      value: function _handleInputDownKeypress(event) {
        // Stop any consequences of pressing the key
        event.preventDefault();

        if (this._elements.overlay.open) {
          this._focusNextItem();
        } else {
          // Show the menu and do not focus on the first item
          // Implements behavior of http://www.w3.org/TR/wai-aria-practices/#autocomplete
          this._showSuggestions();
        }
      }
      /** @private */

    }, {
      key: "_handleInputTabKeypress",
      value: function _handleInputTabKeypress(event) {
        // if the select list is open and a list item has focus, prevent default to trap focus.
        if (this._elements.overlay.open && this._elements.input.getAttribute('aria-activedescendant')) {
          event.preventDefault();
        }
      }
      /**
       Handle selections in the selectList.
        @ignore
       */

    }, {
      key: "_handleSelect",
      value: function _handleSelect(event) {
        var _this6 = this;

        var selectListItem = event.matchedTarget;

        if (!selectListItem || selectListItem.disabled) {
          // @todo it doesn't seem like this should ever happen, but it does
          return;
        } // Select the corresponding item, or add one if it doesn't exist


        this._selectItem(selectListItem.value, selectListItem.content.innerHTML, true);

        if (!this.multiple) {
          this.value = selectListItem.value; // Make sure the value is changed
          // The setter won't run if we set the same value again
          // This forces the DOM to update

          this._setInputValues(this.value, selectListItem.content.textContent, false);
        } else {
          // Add to values
          this._addValue(selectListItem.value, selectListItem.content.innerHTML, true);
        } // Focus on the input element
        // We have to wait a frame here because the item steals focus when selected


        window.requestAnimationFrame(function () {
          _this6._elements.input.focus();
        }); // Hide the options when option is selected in all cases

        this.hideSuggestions(); // Emit the change event when a selection is made

        this.trigger('change');
      }
      /**
       Don't let the internal change event bubble and confuse users
        @ignore
       */

    }, {
      key: "_preventTagListChangeEvent",
      value: function _preventTagListChangeEvent(event) {
        event.stopImmediatePropagation();
      }
    }, {
      key: "_handleTagAdded",
      value: function _handleTagAdded() {
        // Forces tags to wrap
        this._elements.tagList.style.width = "".concat(this.offsetWidth, "px");
      }
      /**
       Handle tags that are removed by the user.
        @ignore
       */

    }, {
      key: "_handleTagRemoved",
      value: function _handleTagRemoved(event) {
        // Get the tag from the event
        var tagValue = event.detail.item.value; // Remove from values only if there is no other tags with the same value are attached (as this component constantly adds and removes tags)
        // this._elements.tagList.values does not seem to work so iterate over the tags to check values

        var removeValue = true;

        var tags = this._elements.tagList.items.getAll();

        for (var i = 0; i < tags.length; i++) {
          if (tags[i].value === tagValue) {
            removeValue = false;
            break;
          }
        }

        if (removeValue) {
          this._removeValue(tagValue);
        } // If all tags were removed, return focus to the input


        if (this.selectedItems.length === 0) {
          this._elements.input.focus();
        }

        this._updateButtonAccessibilityLabel();
      }
      /**
       Handles value changes on a child item.
        @private
       */

    }, {
      key: "_handleItemValueChange",
      value: function _handleItemValueChange(event) {
        // stop event propogation
        event.stopImmediatePropagation(); // Update option map from scratch
        // @todo use attributeOldValue mutationobserver option and update map instead of re-creating

        this._createOptionsFromDOM();
      }
      /**
       Handles content changes on a child item.
        @private
       */

    }, {
      key: "_handleItemContentChange",
      value: function _handleItemContentChange(event) {
        // stop event propogation
        event.stopImmediatePropagation(); // Update option map from scratch with new content

        this._createOptionsFromDOM();
      }
      /**
       Handles selected changes on a child item.
        @private
       */

    }, {
      key: "_handleItemSelectedChange",
      value: function _handleItemSelectedChange(event) {
        // stop event propogation
        event.stopImmediatePropagation();
        var target = event.target;
        var selected = target.hasAttribute('selected');

        if (this.multiple) {
          this[selected ? '_addValue' : '_removeValue'](target.value, target.content.innerHTML, true);
        } else if (selected) {
          // Set the input text accordingly
          this._elements.input.value = target.content.textContent.replace(/\s{2,}/g, ' ').trim(); // Set the value accordingly

          this.value = target.value; // value can't be invalid as an item is selected

          this.invalid = false; // Deselect the other elements if selected programatically changed

          this._deselectExcept(target);
        } // Remove values if deselected
        // Only do this if we're the current value
        // If the selected item was changed, this.value will be different
        else if (this.value === target.value) {
            this.value = ''; // CUI-5533 Since checks inside of _handleInput will assume the value hasn't change,
            // We need to trigger here

            this.trigger('change');
          }
      }
      /**
       Check if the given option partially matches the given value.
        @param {HTMLElement} option
       The option to test
       @param {String} value
       The value to test
        @returns {Boolean} true if the value matches, false if not.
        @protected
       */

    }, {
      key: "_optionContainsValue",
      value: function _optionContainsValue(option, value) {
        value = (typeof value === 'string' ? value : '').toLowerCase();
        return (option.text || option.content).toLowerCase().indexOf(value) !== -1;
      }
      /**
       Check if the given option starts with the given value.
        @param {HTMLElement} option
       The option to test
       @param {String} value
       The value to test
        @returns {Boolean} true if the value matches, false if not.
        @protected
       */

    }, {
      key: "_optionStartsWithValue",
      value: function _optionStartsWithValue(option, value) {
        value = (typeof value === 'string' ? value : '').toLowerCase();
        return option.content.toLowerCase().trim().indexOf(value) === 0;
      }
      /**
       Check if the given option exactly matches the given value.
        @param {HTMLElement} option
       The option to test
       @param {String} value
       The value to test
        @returns {Boolean} true if the value matches, false if not.
        @protected
       */

    }, {
      key: "_optionEqualsValue",
      value: function _optionEqualsValue(option, value) {
        value = (typeof value === 'string' ? value : '').toLowerCase();
        return option.content.toLowerCase().trim() === value;
      }
      /**
       Updates label on toggle button to communicate number of suggestions in list.
        @param {Number} num
       The number of suggestions available
       @private
       */

    }, {
      key: "_updateButtonAccessibilityLabel",
      value: function _updateButtonAccessibilityLabel(num) {
        var str = i18n.get('Show suggestions');

        if (num === 1) {
          str = i18n.get('Show suggestion');
        } else if (num > 1) {
          str = i18n.get('Show {0} suggestions', num);
        }

        this._elements.trigger.setAttribute('aria-label', str);

        this._elements.trigger.setAttribute('title', str);
      }
      /**
       Clears the current selected value or items.
       */

    }, {
      key: "clear",
      value: function clear() {
        this.value = '';

        this._elements.input.clear();

        if (this.multiple) {
          this._clearValues();
        }
      }
      /**
       Clear the list of suggestions.
       */

    }, {
      key: "clearSuggestions",
      value: function clearSuggestions() {
        this._elements.selectList.items.clear();

        this._updateButtonAccessibilityLabel();
      }
      /**
       A suggestion object.
        @typedef {Object} AutocompleteSuggestion
        @property {String} value
       The form submission value to use when this suggestion is selected.
       @property {String} [content=value]
       The content to disable in the suggestion dropdown.
       */

      /**
       Add the provided list of suggestions and clear loading status.
        @param {Array.<AutocompleteSuggestion>} suggestions
       The list of suggestions to show.
       @param {Boolean} clear
       If true, existing suggestions will be cleared.
       */

    }, {
      key: "addSuggestions",
      value: function addSuggestions(suggestions, clear) {
        // Disable loading mode
        this.loading = false;

        if (clear) {
          // Remove existing selectList items
          this.clearSuggestions();
        } // Add items to the selectlist


        for (var i = 0; i < suggestions.length; i++) {
          var value = suggestions[i].value;
          var content = suggestions[i].content;
          var icon = suggestions[i].icon;
          var disabled = !!suggestions[i].disabled; // Only add the item if it's not a selected value or we're in single mode

          if (!this.multiple || this.values.indexOf(value) === -1) {
            this._elements.selectList.items.add({
              value: value,
              type: 'button',
              icon: icon,
              disabled: disabled,
              id: commons.getUID(),
              tabIndex: -1,
              content: {
                innerHTML: content
              }
            });

            this._elements.selectList.items.last().setAttribute('role', 'option');
          }
        }

        if (!suggestions.length && !this._elements.selectList.items.length) {
          // Show "no results" when no suggestions are found at all
          this._elements.selectList.items.add({
            type: 'button',
            content: {
              innerHTML: "<em>".concat(i18n.get('No matching results.'), "</em>")
            },
            disabled: true
          });

          this._elements.selectList.items.last().setAttribute('role', 'status');

          this._elements.selectList.items.last().setAttribute('aria-live', 'polite');

          this._elements.input.removeAttribute('aria-activedescendant');

          this._updateButtonAccessibilityLabel();
        } else {
          this._updateButtonAccessibilityLabel(this._elements.selectList.items.length);
        }
      }
      /**
       Shows the suggestion UI.
       */

    }, {
      key: "showSuggestions",
      value: function showSuggestions() {
        var _this7 = this;

        if (!this._showSuggestionsCalled) {
          this._showSuggestions();
        } else {
          this._showSuggestionsCalled = false;
        } // Just show


        this._elements.overlay.open = true; // Force overlay repositioning (e.g because of remote loading)

        requestAnimationFrame(function () {
          _this7._elements.overlay._onAnimate();

          _this7._elements.overlay.reposition();
        });

        this._elements.input.setAttribute('aria-expanded', 'true');

        this._elements.trigger.setAttribute('aria-expanded', 'true');
      }
      /**
       Hides the suggestion UI.
       */

    }, {
      key: "hideSuggestions",
      value: function hideSuggestions() {
        this._elements.overlay.open = false;

        this._elements.input.setAttribute('aria-expanded', 'false');

        this._elements.trigger.setAttribute('aria-expanded', 'false');

        this._elements.input.removeAttribute('aria-activedescendant'); // Don't let the suggestions show


        window.clearTimeout(this._timeout); // Trigger an event

        this.trigger('coral-autocomplete:hidesuggestions');
      }
      /**
       Matches the accessibility to the state of the popover.
        @ignore
       */

    }, {
      key: "_onOverlayOpenOrClose",
      value: function _onOverlayOpenOrClose(event) {
        if (this._elements.overlay.open) {
          this._elements.input.setAttribute('aria-expanded', 'true');

          this._elements.trigger.setAttribute('aria-expanded', 'true');
        } else {
          this._elements.input.setAttribute('aria-expanded', 'false');

          this._elements.trigger.setAttribute('aria-expanded', 'false');

          this._elements.input.removeAttribute('aria-activedescendant');
        }
      }
      /**
       Inherited from {@link BaseFormField#reset}.
       */

    }, {
      key: "reset",
      value: function reset() {
        // reset the values to the initial values
        this.values = this._initialSelectedValues;
      }
      /**
       Returns {@link Autocomplete} match options.
        @return {AutocompleteMatchEnum}
       */

    }, {
      key: "connectedCallback",

      /** @ignore */
      value: function connectedCallback() {
        _get(_getPrototypeOf(Autocomplete.prototype), "connectedCallback", this).call(this);

        var overlay = this._elements.overlay; // Cannot be open by default when rendered

        overlay.removeAttribute('open'); // Restore in DOM

        if (overlay._parent) {
          overlay._parent.appendChild(overlay);
        }
      }
    }, {
      key: "render",
      value: function render() {
        _get(_getPrototypeOf(Autocomplete.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$z); // Container role per ARIA Autocomplete

        this.setAttribute('role', 'group'); // Input attributes per ARIA Autocomplete

        this._elements.input.setAttribute('role', 'combobox');

        this._elements.input.setAttribute('aria-autocomplete', 'list');

        this._elements.input.setAttribute('aria-haspopup', 'listbox');

        this._elements.input.setAttribute('aria-expanded', 'false');

        this._elements.input.setAttribute('aria-controls', this._elements.selectList.id); // Trigger button attributes per ARIA Autocomplete


        this._elements.trigger.setAttribute('aria-haspopup', 'listbox');

        this._elements.trigger.setAttribute('aria-expanded', 'false');

        this._elements.trigger.setAttribute('aria-controls', this._elements.selectList.id); // Default reflected attributes


        if (!this._variant) {
          this.variant = variant$a.DEFAULT;
        } // Create a fragment


        var frag = document.createDocumentFragment(); // Render the template

        frag.appendChild(this._elements.field);
        frag.appendChild(this._elements.inputGroup);
        frag.appendChild(this._elements.tagList);
        frag.appendChild(this._elements.overlay);
        this._elements.overlay.target = this._elements.trigger; // Clean up

        while (this.firstChild) {
          var child = this.firstChild; // Only works if all root template elements have a handle attribute

          if (child.nodeType === Node.TEXT_NODE || child.hasAttribute && !child.hasAttribute('handle')) {
            // Add non-template elements to the content
            frag.appendChild(child);
          } else {
            // Remove anything else
            this.removeChild(child);
          }
        } // Append the fragment to the component


        this.appendChild(frag); // Set the state from the DOM when initialized

        this._setStateFromDOM(); // save initial selection (used for reset)


        this._initialSelectedValues = this.values.slice(0);
      }
      /** @ignore */

    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        _get(_getPrototypeOf(Autocomplete.prototype), "disconnectedCallback", this).call(this);

        var overlay = this._elements.overlay; // In case it was moved out don't forget to remove it

        if (!this.contains(overlay)) {
          overlay._parent = overlay._repositioned ? document.body : this;
          overlay.remove();
        }
      }
      /**
       Triggered when the {@link Autocomplete} could accept external data to be loaded by the user.
       If <code>preventDefault()</code> is called, then a loading indicator will be shown.
       {@link Autocomplete#loading} should be set to false to indicate that the data has been successfully loaded.
        @typedef {CustomEvent} coral-autocomplete:showsuggestions
        @property {String} detail.value
       The user input.
       */

      /**
       Triggered when the {@link Autocomplete} hides the suggestions.
       This is typically used to cancel a load request because the suggestions will not be shown anymore.
        @typedef {CustomEvent} coral-autocomplete:hidesuggestions
       */

    }, {
      key: "overlay",
      get: function get() {
        return this._elements.overlay;
      }
      /**
       The item collection.
        @type {SelectableCollection}
       @readonly
       */

    }, {
      key: "items",
      get: function get() {
        // Construct the collection on first request:
        if (!this._items) {
          this._items = new SelectableCollection({
            itemTagName: 'coral-autocomplete-item',
            host: this
          });
        }

        return this._items;
      }
      /**
       Indicates if the autocomplete is a single or multiple mode. In multiple mode, the user can select multiple
       values.
        @type {Boolean}
       @default false
       @htmlattribute multiple
       @htmlattributereflected
       */

    }, {
      key: "multiple",
      get: function get() {
        return this._multiple || false;
      },
      set: function set(value) {
        this._multiple = transform.booleanAttr(value);

        this._reflectAttribute('multiple', this._multiple);

        this._setName(this.name);

        if (this._multiple) {
          this._elements.tagList.hidden = false;
        } else {
          this._elements.tagList.hidden = true;

          this._elements.tagList.items.clear();
        }

        this.labelledBy = this.labelledBy;
      }
      /**
       Amount of time, in milliseconds, to wait after typing a character before the suggestion is shown.
        @type {Number}
       @default 200
       @htmlattribute delay
       */

    }, {
      key: "delay",
      get: function get() {
        return typeof this._delay === 'number' ? this._delay : 200;
      },
      set: function set(value) {
        value = transform.number(value);

        if (typeof value === 'number' && value >= 0) {
          this._delay = transform.number(value);
        }
      }
      /**
       Set to <code>true</code> to restrict the selected value to one of the given options from the suggestions.
       When set to <code>false</code>, users can enter anything.
        <strong>NOTE:</strong> This API is under review and may be removed or changed in a subsequent release.
       @ignore
        @type {Boolean}
       @default false
       @htmlattribute forceselection
       @htmlattributereflected
       */

    }, {
      key: "forceSelection",
      get: function get() {
        return this._forceSelection || false;
      },
      set: function set(value) {
        this._forceSelection = transform.booleanAttr(value);

        this._reflectAttribute('forceselection', this._forceSelection);
      }
      /**
       A hint to the user of what can be entered.
        @type {String}
       @default ""
       @htmlattribute placeholder
       @htmlattributereflected
       */

    }, {
      key: "placeholder",
      get: function get() {
        return this._elements.input.placeholder;
      },
      set: function set(value) {
        this._elements.input.placeholder = value;

        this._reflectAttribute('placeholder', this.placeholder);
      }
      /**
       Max length for the Input field
        @type {Number}
       @htmlattribute maxlength
       @htmlattributereflected
       */

    }, {
      key: "maxLength",
      get: function get() {
        return this._elements.input.maxLength;
      },
      set: function set(value) {
        this._elements.input.maxLength = value;

        this._reflectAttribute('maxlength', this._elements.input.maxLength);
      }
      /**
       The Autocomplete's variant. See {@link AutocompleteVariantEnum}.
        @type {AutocompleteVariantEnum}
       @default AutocompleteVariantEnum.DEFAULT
       @htmlattribute variant
       @htmlattributereflected
       */

    }, {
      key: "variant",
      get: function get() {
        return this._variant || variant$a.DEFAULT;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        this._variant = validate.enumeration(variant$a)(value) && value || variant$a.DEFAULT;

        this._reflectAttribute('variant', this._variant);

        if (this._variant === variant$a.QUIET) {
          this._elements.inputGroup.classList.add('_coral-InputGroup--quiet');

          this._elements.input.variant = Textfield.variant.QUIET;

          this._elements.trigger.classList.add('_coral-FieldButton--quiet');
        } else {
          this._elements.inputGroup.classList.remove('_coral-InputGroup--quiet');

          this._elements.input.variant = Textfield.variant.DEFAULT;

          this._elements.trigger.classList.remove('_coral-FieldButton--quiet');
        }
      }
      /**
       The match mode. See {@link AutocompleteMatchEnum}.
        @type {String}
       @default AutocompleteMatchEnum.CONTAINS
       @htmlattribute match
       */

    }, {
      key: "match",
      get: function get() {
        return this._match || match$1.CONTAINS;
      },
      set: function set(value) {
        if (typeof value === 'function') {
          this._match = value;
          this._matchFunction = value;
        } else {
          value = transform.string(value).toLowerCase();
          this._match = validate.enumeration(match$1)(value) && value || match$1.CONTAINS;

          if (this._match === match$1.STARTSWITH) {
            this._matchFunction = this._optionStartsWithValue;
          } else if (this._match === match$1.CONTAINS) {
            this._matchFunction = this._optionContainsValue;
          }
        }
      }
      /**
       Indicates that the component is currently loading remote data. This will set the wait indicator inside the list.
        @type {Boolean}
       @default false
       @htmlattribute loading
       */

    }, {
      key: "loading",
      get: function get() {
        return this._loading || false;
      },
      set: function set(value) {
        this._loading = transform.booleanAttr(value);

        if (this._loading) {
          var overlay = this._elements.overlay; // we decide first if we need to scroll to the bottom since adding the load will change the dimensions

          var scrollToBottom = overlay.scrollTop >= overlay.scrollHeight - overlay.clientHeight; // if it does not exist we create it

          if (!this._elements.loadIndicator) {
            template$h.call(this._elements);
          } // inserts the item at the end


          this._elements.selectList.appendChild(this._elements.loadIndicator); // we make the load indicator visible


          if (scrollToBottom) {
            overlay.scrollTop = overlay.scrollHeight;
          }
        } else if (this._elements.loadIndicator) {
          this._elements.loadIndicator.remove();
        }
      }
      /**
       Returns an Array containing the set selected items.
       @type {Array.<HTMLElement>}
       @readonly
       */

    }, {
      key: "selectedItems",
      get: function get() {
        return this.items._getAllSelected();
      }
      /**
       Returns the first selected item in the Autocomplete. The value <code>null</code> is returned if no element is
       selected.
       @type {?HTMLElement}
       @readonly
       */

    }, {
      key: "selectedItem",
      get: function get() {
        return this.items._getAllSelected()[0] || null;
      }
      /**
       The current value, as submitted during form submission.
       When {@link Coral.Autocomplete#multiple} is <code>true</code>, the first selected value will be returned.
        @type {String}
       @default ""
       @htmlattribute value
       */

    }, {
      key: "value",
      get: function get() {
        // Get the first value (or empty string)
        var values = this.values;
        return values && values.length > 0 ? values[0] : '';
      },
      set: function set(value) {
        this.values = [transform.string(value)];
      }
      /**
       The current values, as submitted during form submission.
       When {@link Coral.Autocomplete#multiple} is <code>false</code>, this will be an array of length 1.
        @type {Array.<String>}
       */

    }, {
      key: "values",
      get: function get() {
        return this._values;
      },
      set: function set(values) {
        if (values === undefined || values === null) {
          values = [];
        }

        if (Array.isArray(values)) {
          // if value was set to empty string
          if (values.length === 1 && values[0] === '') {
            values = [];
          }

          var i;
          var value;
          var selectedValues = []; // Valid values only

          if (this.forceSelection) {
            // Add each valid value
            for (i = 0; i < values.length; i++) {
              value = values[i];

              if (this._optionsMap[value] !== undefined) {
                selectedValues.push(value);
              }
            }
          } // Any value goes
          else {
              for (i = 0; i < values.length; i++) {
                value = values[i];
                selectedValues.push(value);
              }
            }

          if (this.multiple) {
            // Remove existing tags, DOM selection, etc
            // This is a full override
            this._clearValues(); // Add each tag


            for (i = 0; i < selectedValues.length; i++) {
              value = selectedValues[i]; // Ensure the item is selected if it's present in the DOM
              // This keeps the DOM in sync with the JS API and prevents bugs like CUI-5681

              this._selectItem(value); // Add the value to the tag list


              this._addValue(value, null, true);
            }
          } else {
            // Set value
            this._values = selectedValues.length > 0 ? [selectedValues[0]] : [];

            this._reflectCurrentValue();
          }
        }
      }
      /**
       Name used to submit the data in a form.
       @type {String}
       @default ""
       @htmlattribute name
       @htmlattributereflected
       */

    }, {
      key: "name",
      get: function get() {
        return this._getName();
      },
      set: function set(value) {
        this._reflectAttribute('name', value);

        this._setName(value);
      }
      /**
       Inherited from {@link BaseFormField#invalid}.
       */

    }, {
      key: "invalid",
      get: function get() {
        return _get(_getPrototypeOf(Autocomplete.prototype), "invalid", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(Autocomplete.prototype), "invalid", value, this, true); // Add to outer component


        this._elements.inputGroup.classList.toggle('is-invalid', this.invalid);

        this._elements.trigger.classList.toggle('is-invalid', this.invalid);

        this._elements.input.invalid = this.invalid;
      }
      /**
       Whether this field is disabled or not.
       @type {Boolean}
       @default false
       @htmlattribute disabled
       @htmlattributereflected
       */

    }, {
      key: "disabled",
      get: function get() {
        return this._disabled || false;
      },
      set: function set(value) {
        this._disabled = transform.booleanAttr(value);

        this._reflectAttribute('disabled', this._disabled);

        this[this._disabled ? 'setAttribute' : 'removeAttribute']('aria-disabled', this._disabled);

        this._elements.inputGroup.classList.toggle('is-disabled', this._disabled);

        this._elements.input.disabled = this._disabled;
        var disabledOrReadOnly = this._disabled || this.readOnly;
        this._elements.trigger.disabled = disabledOrReadOnly;
        this._elements.tagList.disabled = disabledOrReadOnly; // Prevents the overlay to be shown

        this._elements.inputGroup.disabled = disabledOrReadOnly;
      }
      /**
       Whether this field is readOnly or not. Indicating that the user cannot modify the value of the control.
       @type {Boolean}
       @default false
       @htmlattribute readonly
       @htmlattributereflected
       */

    }, {
      key: "readOnly",
      get: function get() {
        return this._readOnly || false;
      },
      set: function set(value) {
        this._readOnly = transform.booleanAttr(value);

        this._reflectAttribute('readonly', this._readOnly);

        this._elements.input.readOnly = this._readOnly;
        var readOnlyOrDisabled = this._readOnly || this.disabled;
        this._elements.trigger.readOnly = readOnlyOrDisabled;
        this._elements.tagList.readOnly = readOnlyOrDisabled; // Prevents the overlay to be shown

        this._elements.inputGroup.disabled = readOnlyOrDisabled;
      }
      /**
       Whether this field is required or not.
       @type {Boolean}
       @default false
       @htmlattribute required
       @htmlattributereflected
       */

    }, {
      key: "required",
      get: function get() {
        return this._required || false;
      },
      set: function set(value) {
        this._required = transform.booleanAttr(value);

        this._reflectAttribute('required', this._required);

        this._elements.input.required = this._required;
      }
      /**
       Inherited from {@link BaseFormField#labelled}.
       */

    }, {
      key: "labelled",
      get: function get() {
        return _get(_getPrototypeOf(Autocomplete.prototype), "labelled", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(Autocomplete.prototype), "labelled", value, this, true);

        this[this.labelled ? 'setAttribute' : 'removeAttribute']('aria-label', this.labelled);

        this._elements.selectList[this.labelled ? 'setAttribute' : 'removeAttribute']('aria-label', this.labelled);

        if (this.labelled && this.multiple) {
          this._elements.tagList.setAttribute('aria-label', this.labelled);
        } else {
          this._elements.tagList.removeAttribute('aria-label');
        }
      }
      /**
       Inherited from {@link BaseFormField#labelledBy}.
       */

    }, {
      key: "labelledBy",
      get: function get() {
        return _get(_getPrototypeOf(Autocomplete.prototype), "labelledBy", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(Autocomplete.prototype), "labelledBy", value, this, true);

        this[this.labelledBy ? 'setAttribute' : 'removeAttribute']('aria-labelledby', this.labelledBy);

        this._elements.selectList[this.labelledBy ? 'setAttribute' : 'removeAttribute']('aria-labelledby', this.labelledBy);

        if (this.labelledBy && this.multiple) {
          this._elements.tagList.setAttribute('aria-labelledby', this.labelledBy);
        } else {
          this._elements.tagList.removeAttribute('aria-labelledby');
        }
      }
      /**
       @ignore
        Not supported anymore.
       */

    }, {
      key: "icon",
      get: function get() {
        return this._icon || '';
      },
      set: function set(value) {
        this._icon = transform.string(value);

        this._reflectAttribute('icon', this._icon);
      }
    }], [{
      key: "match",
      get: function get() {
        return match$1;
      }
      /**
       Returns {@link Autocomplete} variants.
        @return {AutocompleteVariantEnum}
       */

    }, {
      key: "variant",
      get: function get() {
        return variant$a;
      }
    }, {
      key: "_attributePropertyMap",
      get: function get() {
        return commons.extend(_get(_getPrototypeOf(Autocomplete), "_attributePropertyMap", this), {
          forceselection: 'forceSelection',
          maxlength: 'maxLength'
        });
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(Autocomplete), "observedAttributes", this).concat(['multiple', 'delay', 'forceselection', 'placeholder', 'maxlength', 'icon', 'match', 'loading', 'variant']);
      }
    }]);

    return Autocomplete;
  }(BaseFormField(BaseComponent(HTMLElement)));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons.extend(strings, {
    'coral-component-autocomplete': translations$a
  }); // Expose component on the Coral namespace

  commons._define('coral-autocomplete-item', AutocompleteItem);

  commons._define('coral-autocomplete', Autocomplete);

  Autocomplete.Item = AutocompleteItem;

  var CLASSNAME$A = '_coral-Banner';
  /**
   Enumeration for {@link Banner} variants.

   @typedef {Object} BannerVariantEnum

   @property {String} ERROR
   A banner to indicate that an error has occurred.
   @property {String} WARNING
   A banner to warn the user of something important.
   @property {String} INFO
   A banner to inform the user of non-critical information.
   */

  var variant$b = {
    ERROR: 'error',
    WARNING: 'warning',
    INFO: 'info'
  }; // An array of all possible variant classnames

  var ALL_VARIANT_CLASSES$7 = [];

  for (var variantValue$5 in variant$b) {
    ALL_VARIANT_CLASSES$7.push("".concat(CLASSNAME$A, "--").concat(variant$b[variantValue$5]));
  }
  /**
   @class Coral.Banner
   @classdesc A Banner component
   @htmltag coral-banner
   @extends {HTMLElement}
   @extends {BaseComponent}
   */


  var Banner = /*#__PURE__*/function (_BaseComponent) {
    _inherits(Banner, _BaseComponent);

    var _super = _createSuper(Banner);

    /** @ignore */
    function Banner() {
      var _this;

      _classCallCheck(this, Banner);

      _this = _super.call(this); // Fetch content zones

      _this._elements = {
        header: _this.querySelector('coral-banner-header') || document.createElement('coral-banner-header'),
        content: _this.querySelector('coral-banner-content') || document.createElement('coral-banner-content')
      };
      return _this;
    }
    /**
     The banner variant style to use. See {@link BannerVariantEnum}.
      @type {String}
     @default BannerVariantEnum.INFO
     @htmlattribute variant
     @htmlattributereflected
     */


    _createClass(Banner, [{
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(Banner.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$A); // Default reflected attributes

        if (!this._variant) {
          this.variant = variant$b.INFO;
        }

        var header = this._elements.header;
        var content = this._elements.content; // When the content zone was not created, we need to make sure that everything is added inside it as a content.

        if (!content.parentNode) {
          while (this.firstChild) {
            var child = this.firstChild; // Don't move header into content

            if (child === header) {
              child.remove();
            } else {
              content.appendChild(this.firstChild);
            }
          }
        } // Assign content zones


        this.header = this._elements.header;
        this.content = this._elements.content;
      }
    }, {
      key: "variant",
      get: function get() {
        return this._variant || variant$b.INFO;
      },
      set: function set(value) {
        var _this$classList;

        value = transform.string(value).toLowerCase();
        this._variant = validate.enumeration(variant$b)(value) && value || variant$b.INFO;

        this._reflectAttribute('variant', this._variant); // Remove all variant classes


        (_this$classList = this.classList).remove.apply(_this$classList, ALL_VARIANT_CLASSES$7); // Set new variant class


        this.classList.add("".concat(CLASSNAME$A, "--").concat(this._variant));
      }
      /**
       The banner's header.
        @type {BannerHeader}
       @contentzone
       */

    }, {
      key: "header",
      get: function get() {
        return this._getContentZone(this._elements.header);
      },
      set: function set(value) {
        this._setContentZone('header', value, {
          handle: 'header',
          tagName: 'coral-banner-header',
          insert: function insert(header) {
            header.classList.add("".concat(CLASSNAME$A, "-header"));
            this.insertBefore(header, this.firstChild);
          }
        });
      }
      /**
       The banner's content.
        @type {BannerContent}
       @contentzone
       */

    }, {
      key: "content",
      get: function get() {
        return this._getContentZone(this._elements.content);
      },
      set: function set(value) {
        this._setContentZone('content', value, {
          handle: 'content',
          tagName: 'coral-banner-content',
          insert: function insert(content) {
            content.classList.add("".concat(CLASSNAME$A, "-content"));
            this.appendChild(content);
          }
        });
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-banner-header': 'header',
          'coral-banner-content': 'content'
        };
      }
      /**
       Returns {@link Banner} variants.
        @return {BannerVariantEnum}
       */

    }], [{
      key: "variant",
      get: function get() {
        return variant$b;
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return ['variant'];
      }
    }]);

    return Banner;
  }(BaseComponent(HTMLElement));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Banner.Header
   @classdesc A Banner Header component
   @htmltag coral-banner-header
   @return {HTMLElement}
   */
  var BannerHeader = (function () {
    return document.createElement('coral-banner-header');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Banner.Content
   @classdesc A Banner Content component
   @htmltag coral-banner-content
   @return {HTMLElement}
   */
  var BannerContent = (function () {
    return document.createElement('coral-banner-content');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons._define('coral-banner', Banner);

  Banner.Header = BannerHeader;
  Banner.Content = BannerContent;

  var template$i = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["nativeSelect"] = document.createElement("select");
    el0.className += " _coral-ButtonGroup-select";
    el0.setAttribute("tabindex", "-1");
    el0.setAttribute("handle", "nativeSelect");
    frag.appendChild(el0);
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    return frag;
  };

  /**
   Enumeration for {@link ButtonGroup} selection options.

   @typedef {Object} ButtonGroupSelectionModeEnum

   @property {String} NONE
   None is default, selection of buttons doesn't happen based on click.
   @property {String} SINGLE
   Single selection mode, button group behaves like radio input elements.
   @property {String} MULTIPLE
   Multiple selection mode, button group behaves like checkbox input elements.
   */

  var selectionMode = {
    NONE: 'none',
    SINGLE: 'single',
    MULTIPLE: 'multiple'
  };
  /** @const Selector used to recognized an item of the ButtonGroup */

  var ITEM_SELECTOR = 'button[is="coral-button"]';
  /**
   Extracts the value from the item in case no explicit value was provided.
   @param {HTMLElement} item
   the item whose value will be extracted.
   @returns {String} the value that will be submitted for this item.
   @private
   */

  var itemValueFromDOM$2 = function itemValueFromDOM(item) {
    var attr = item.getAttribute('value'); // checking explicitely for null allows to differenciate between non set values and empty strings

    return attr !== null ? attr : item.textContent.replace(/\s{2,}/g, ' ').trim();
  };

  var CLASSNAME$B = '_coral-ButtonGroup';
  /**
   @class Coral.ButtonGroup
   @classdesc A ButtonGroup component that can be used as a selection form field.
   @htmltag coral-buttongroup
   @extends {HTMLElement}
   @extends {BaseComponent}
   @extends {BaseFormField}
   */

  var ButtonGroup = /*#__PURE__*/function (_BaseFormField) {
    _inherits(ButtonGroup, _BaseFormField);

    var _super = _createSuper(ButtonGroup);

    /** @ignore */
    function ButtonGroup() {
      var _this;

      _classCallCheck(this, ButtonGroup);

      _this = _super.call(this); // Store template

      _this._elements = {};
      template$i.call(_this._elements); // Pre-define labellable element

      _this._labellableElement = _assertThisInitialized(_this); // save initial selection (used for reset)

      _this._initalSelectedValues = []; // Attach events

      _this._delegateEvents(commons.extend(_this._events, {
        'click button[is="coral-button"]': '_onButtonClick',
        'capture:focus button[is="coral-button"]': '_onButtonFocus',
        'capture:blur button[is="coral-button"]': '_onButtonBlur',
        'key:up button[is="coral-button"]': '_onButtonKeyUpLeft',
        'key:left button[is="coral-button"]': '_onButtonKeyUpLeft',
        'key:down button[is="coral-button"]': '_onButtonKeyDownRight',
        'key:right button[is="coral-button"]': '_onButtonKeyDownRight',
        'key:home button[is="coral-button"]': '_onButtonKeyHome',
        'key:end button[is="coral-button"]': '_onButtonKeyEnd',
        'coral-button:_valuechanged button[is="coral-button"]': '_onButtonValueChanged',
        'coral-button:_selectedchanged button[is="coral-button"]': '_onButtonSelectedChanged'
      })); // Init the mutation observer but we don't handle the initial items in the constructor


      _this.items._startHandlingItems(true);

      return _this;
    }
    /**
     The Collection Interface that allows interacting with the items that the component contains.
      @type {SelectableCollection}
     @readonly
     */


    _createClass(ButtonGroup, [{
      key: "reset",

      /**
       Inherited from {@link BaseFormField#reset}.
       */
      value: function reset() {
        // reset the values to the initial values
        this.values = this._initalSelectedValues;
      }
      /** @private */

    }, {
      key: "_onButtonClick",
      value: function _onButtonClick(event) {
        // uses matchTarget to make sure the buttons is handled and not an internal component
        var item = event.matchedTarget;

        this._onButtonFocus(event);

        if (this.readOnly) {
          event.preventDefault();
          event.stopImmediatePropagation();
          return;
        }

        if (this.selectionMode === selectionMode.SINGLE) {
          // prevent event only if selectionMode is not of type none
          event.preventDefault(); // first unselect the other element

          var selectedItems = this.items._getAllSelected(); // we deselect the previously selected item


          if (selectedItems.length !== 0 && selectedItems[0] !== item) {
            this._toggleItemSelection(selectedItems[0], false);
          } // forces the selection on the clicked item


          this._toggleItemSelection(item, true); // if the same button was clicked we do not need to trigger an event


          if (selectedItems[0] !== item) {
            this.trigger('change');
          }
        } else if (this.selectionMode === selectionMode.MULTIPLE) {
          // prevent event only if selectionMode is not of type none
          event.preventDefault();

          this._toggleItemSelection(item); // since we toggle the selection we always trigger a change event


          this.trigger('change');
        }
      }
      /** @private */

    }, {
      key: "_onButtonFocus",
      value: function _onButtonFocus(event) {
        var item = event.matchedTarget;
        var buttons = this.items.getAll();
        var buttonsCount = buttons.length;
        var button;

        for (var i = 0; i < buttonsCount; i++) {
          // stores the reference
          button = buttons[i];
          button.setAttribute('tabindex', button === item ? 0 : -1);
        }
      }
      /** @private */

    }, {
      key: "_onButtonBlur",
      value: function _onButtonBlur(event) {
        var item = event.matchedTarget;
        var buttons = this.items.getAll();
        var buttonsCount = buttons.length;
        var button;
        var tabindex;
        var selectedItemsLength = this.selectedItems.length;

        var firstSelectable = this.items._getFirstSelectable();

        var isSelected = false;

        for (var i = 0; i < buttonsCount; i++) {
          // stores the reference
          button = buttons[i];
          isSelected = button.hasAttribute('selected');

          if (this.selectionMode === selectionMode.SINGLE) {
            // selected item should be tabbable
            tabindex = isSelected ? 0 : -1;
          } else if (this.selectionMode === selectionMode.MULTIPLE) {
            tabindex = // if no items are selected, first item should be tabbable
            !selectedItemsLength && i === 0 || // if the element losing focus is selected, it should be tabbable
            isSelected && button === item || // if the element losing focus is not selected, the last selected item should be tabbable
            !item.hasAttribute('selected') && button === (this.selectedItems[selectedItemsLength - 1] || firstSelectable) ? 0 : -1;
          } else {
            // first item should be tabbable
            tabindex = button === firstSelectable ? 0 : -1;
          }

          button.setAttribute('tabindex', tabindex);
        }
      }
      /** @private */

    }, {
      key: "_onButtonKeyUpLeft",
      value: function _onButtonKeyUpLeft(event) {
        event.preventDefault();
        var item = event.matchedTarget;
        var button = item.previousElementSibling; // skip disabled items

        while (!button || button.disabled || button.nodeName !== 'BUTTON') {
          if (!button) {
            button = this.items._getLastSelectable();
          } else {
            button = button.previousElementSibling;
          }
        }

        if (button !== item) {
          if (this.selectionMode === selectionMode.SINGLE) {
            button.click();
          }

          this._setFocusToButton(button);
        }
      }
      /** @private */

    }, {
      key: "_onButtonKeyDownRight",
      value: function _onButtonKeyDownRight(event) {
        event.preventDefault();
        var item = event.matchedTarget;
        var button = item.nextElementSibling; // skip disabled items

        while (!button || button.disabled || button.nodeName !== 'BUTTON') {
          if (!button) {
            button = this.items._getFirstSelectable();
          } else {
            button = button.nextElementSibling;
          }
        }

        if (button !== item) {
          if (this.selectionMode === selectionMode.SINGLE) {
            button.click();
          }

          this._setFocusToButton(button);
        }
      }
      /** @private */

    }, {
      key: "_onButtonKeyHome",
      value: function _onButtonKeyHome(event) {
        event.preventDefault();
        var item = event.matchedTarget;

        var button = this.items._getFirstSelectable();

        if (button !== item) {
          if (this.selectionMode === selectionMode.SINGLE) {
            button.click();
          }

          this._setFocusToButton(button);
        }
      }
      /** @private */

    }, {
      key: "_onButtonKeyEnd",
      value: function _onButtonKeyEnd(event) {
        event.preventDefault();
        var item = event.matchedTarget;

        var button = this.items._getLastSelectable();

        if (button !== item) {
          if (this.selectionMode === selectionMode.SINGLE) {
            button.click();
          }

          this._setFocusToButton(button);
        }
      }
      /** @private */

    }, {
      key: "_setFocusToButton",
      value: function _setFocusToButton(button) {
        if (button) {
          button.focus();
        }
      }
      /** @private */

    }, {
      key: "_onItemAdded",
      value: function _onItemAdded(item) {
        // Store variant to be able to reset it when item is removed
        item._initialVariant = item._initialVariant || item.variant; // Force action variant

        if (!(item.variant === Button.variant.ACTION || item.variant === Button.variant.QUIET_ACTION)) {
          item.variant = item.variant === Button.variant.QUIET ? Button.variant.QUIET_ACTION : Button.variant.ACTION;
        }

        if (this.selectionMode !== selectionMode.NONE) {
          if (this.selectionMode === selectionMode.SINGLE) {
            item.setAttribute('role', 'radio');
            item.setAttribute('tabindex', item.hasAttribute('selected') ? 0 : -1);
          } else {
            item.setAttribute('role', 'checkbox');
          }

          item.setAttribute('aria-checked', item.hasAttribute('selected'));
        } else {
          item.removeAttribute('role');
        }

        item.disabled = this.disabled || this.readOnly && !item.hasAttribute('selected');
        item[this.readOnly ? 'setAttribute' : 'removeAttribute']('aria-disabled', true);

        this._addItemOption(item); // Handle the case where we might have multiple items selected while single selection mode is on


        if (this.selectionMode === selectionMode.SINGLE) {
          var selectedItems = this.items._getAllSelected(); // The last added item will stay selected


          if (selectedItems.length > 1 && item.hasAttribute('selected')) {
            item.removeAttribute('selected');
          }
        }
      }
      /** @private */

    }, {
      key: "_onItemRemoved",
      value: function _onItemRemoved(item) {
        // Restore variant
        item.variant = item._initialVariant;
        item._initialVariant = undefined;
        item.removeAttribute('role');

        if (!item.parentNode) {
          // Remove the item from the initial selected values
          var index = this._initalSelectedValues.indexOf(item.value);

          if (index !== -1) {
            this._initalSelectedValues.splice(index, 1);
          }
        } // delete option


        if (item.option) {
          item.option.parentNode.removeChild(item.option);
          item.option = undefined;
        }
      }
      /** @private */

    }, {
      key: "_onCollectionChange",
      value: function _onCollectionChange() {
        // we need to make sure that the state of the selectionMode is valid
        this._validateSelection();
      }
      /** @private */

    }, {
      key: "_onButtonSelectedChanged",
      value: function _onButtonSelectedChanged(event) {
        event.stopImmediatePropagation();
        var button = event.target;
        var isSelected = button.hasAttribute('selected'); // when in single mode, we need to make sure the current selection is valid

        if (this.selectionMode === selectionMode.SINGLE) {
          this._validateSelection(isSelected ? button : null);
        } else {
          // we simply toggle the selection
          this._toggleItemSelection(button, isSelected);
        }
      }
      /** @private */

    }, {
      key: "_onButtonValueChanged",
      value: function _onButtonValueChanged(event) {
        event.stopImmediatePropagation();
        var button = event.target; // Make sure option is attached before setting the value

        if (this.selectionMode !== selectionMode.NONE) {
          button.option.value = itemValueFromDOM$2(button);
        }
      }
      /**
       Toggles the selected state of the item. When <code>selected</code> is provided, it is set as the current state. If
       the value is ommited, then the selected is toggled.
        @param {HTMLElement} item
       Item whose selection needs to be updated.
       @param {Boolean} [selected]
       Whether the item is selected. If it is not provided, then it is toggled.
        @private
       */

    }, {
      key: "_toggleItemSelection",
      value: function _toggleItemSelection(item, selected) {
        var ariaCheckedAttr = item.getAttribute('aria-checked');
        var tabIndexAttr = item.getAttribute('tabindex'); // if selected is provided it is used to enforce the selection, otherwise we toggle the current state

        selected = typeof selected !== 'undefined' ? selected : !item.hasAttribute('selected'); // only manipulates the attributes when necessary to avoid unnecessary mutations

        if (selected) {
          if (!item.hasAttribute('selected')) {
            item.setAttribute('selected', '');
          }

          if (ariaCheckedAttr !== 'true') {
            item.setAttribute('aria-checked', true);
          }

          if (this.selectionMode === selectionMode.SINGLE && tabIndexAttr !== '0') {
            item.setAttribute('tabindex', 0);
          }
        } else if (!selected) {
          if (item.hasAttribute('selected')) {
            item.removeAttribute('selected');
          }

          if (this.selectionMode !== selectionMode.NONE) {
            if (ariaCheckedAttr !== 'false') {
              item.setAttribute('aria-checked', false);
            }

            if (this.selectionMode === selectionMode.SINGLE && tabIndexAttr !== '-1') {
              item.setAttribute('tabindex', -1);
            }
          } else {
            item.removeAttribute('aria-checked');
            item.removeAttribute('tabindex');
          }
        } // if element.option is present - absent when selection mode changed to none


        if (item.option) {
          item.option.selected = selected;
        }
      }
    }, {
      key: "_selectItemByValue",
      value: function _selectItemByValue(values) {
        // queries all the buttons to change their selection state
        var buttons = this.items.getAll();
        var item;

        for (var i = 0, buttonsCount = buttons.length; i < buttonsCount; i++) {
          // stores the reference
          item = buttons[i]; // if the value is inside the new values array it should be selected

          this._toggleItemSelection(item, values.indexOf(itemValueFromDOM$2(item)) !== -1);
        }
      }
      /** @private */

    }, {
      key: "_setInitialValues",
      value: function _setInitialValues() {
        if (this.selectionMode !== selectionMode.NONE) {
          var selectedItems = this.selectedItems;

          for (var i = 0, selectedItemsCount = selectedItems.length; i < selectedItemsCount; i++) {
            // Store _initalSelectedValues for reset
            this._initalSelectedValues.push(selectedItems[i].value); // Same goes for native select


            this._addItemOption(selectedItems[i]);
          }
        }
      }
      /** @private */

    }, {
      key: "_addItemOption",
      value: function _addItemOption(item) {
        if (this.selectionMode === selectionMode.NONE) {
          return;
        } // if already attached return


        if (item.option) {
          return;
        }

        var option = document.createElement('option');
        option.value = itemValueFromDOM$2(item);

        if (item.hasAttribute('selected')) {
          option.setAttribute('selected', '');
        } // add it to DOM. In single selectionMode the first item gets selected automatically


        item.option = option;

        this._elements.nativeSelect.add(option); // we make sure the options reflect the state of the button


        this._toggleItemSelection(item, item.hasAttribute('selected'));
      }
      /** @private */

    }, {
      key: "_removeItemOptions",
      value: function _removeItemOptions() {
        // Find all buttons and try attaching corresponding option elem
        var buttons = this.items.getAll();
        var item;

        for (var i = 0, buttonsCount = buttons.length; i < buttonsCount; i++) {
          // stores the reference
          item = buttons[i];
          item.removeAttribute('role');
          item.removeAttribute('aria-checked'); // single we are removing the options, selection must also go away

          if (item.hasAttribute('selected')) {
            this._toggleItemSelection(item, false);
          } // we clear the related option element


          if (item.option) {
            item.option.parentNode.removeChild(item.option);
            delete item.option;
          }
        }
      }
      /** @private */

    }, {
      key: "_syncItemOptions",
      value: function _syncItemOptions() {
        // finds all buttons and try attaching corresponding option elem
        var buttons = this.items.getAll();
        var buttonsCount = buttons.length;
        var i = 0;
        var role = null;

        if (this.selectionMode === selectionMode.SINGLE) {
          role = 'radio';
        } else if (this.selectionMode === selectionMode.MULTIPLE) {
          role = 'checkbox';
        }

        var button;
        var isSelected = false;

        for (i; i < buttonsCount; i++) {
          // try attaching corresponding input element
          this._addItemOption(buttons[i]);
        } // We need to set the right state for the native select AFTER all buttons have been added
        // (as we can't disable options while there is only one option attached [at least in FF])


        for (i = buttonsCount - 1; i >= 0; i--) {
          button = buttons[i];
          isSelected = button.hasAttribute('selected');
          button.option.selected = isSelected;
          button.setAttribute('aria-checked', isSelected);

          if (role) {
            button.setAttribute('role', role);
          } else {
            button.removeAttribute('role');
          }
        }
      }
      /** @private */

    }, {
      key: "_validateSelection",
      value: function _validateSelection(item) {
        // when selectionMode = single, we need to force a selection
        if (this.selectionMode === selectionMode.SINGLE) {
          // gets the current selection
          var selection = this.items._getAllSelected();

          var selectionCount = selection.length; // if no item is currently selected, we need to find a candidate

          if (selectionCount === 0) {
            // gets the first candidate for selection
            var selectable = this.items._getFirstSelectable();

            if (selectable) {
              this._toggleItemSelection(selectable, true);
            }
          } // more items are selected, so we find a single item and deselect everything else
          else if (selectionCount > 1) {
              // if no item was provided we force the selection on the first item
              item = item || selection[0]; // we make sure the item is selected, this is important to match the options with the selection

              this._toggleItemSelection(item, true);

              for (var i = 0; i < selectionCount; i++) {
                if (selection[i] !== item) {
                  this._toggleItemSelection(selection[i], false);
                }
              }
            }
        }
      }
      /**
       Returns {@link ButtonGroup} selection options.
        @return {ButtonGroupSelectionModeEnum}
       */

    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(ButtonGroup.prototype), "render", this).call(this);

        _get(_getPrototypeOf(ButtonGroup.prototype), "connectedCallback", this).call(this);

        this.classList.add(CLASSNAME$B); // Default reflected attributes

        if (!this._selectionMode) {
          this.selectionMode = selectionMode.NONE;
        } // Create a fragment


        var frag = document.createDocumentFragment(); // Render the template

        frag.appendChild(this._elements.nativeSelect); // Clean up

        while (this.firstChild) {
          var child = this.firstChild;

          if (child.nodeType === Node.TEXT_NODE || child.getAttribute('handle') !== 'nativeSelect') {
            // Add non-template elements to the content
            frag.appendChild(child);
          } else {
            // Remove anything else
            this.removeChild(child);
          }
        } // Append the fragment to the component


        this.appendChild(frag); // Need to store and set the initially selected values in the native select so that it can reset

        this._setInitialValues(); // Call onItemAdded and onCollectionChange on the existing items


        this.items._startHandlingItems();
      }
    }, {
      key: "items",
      get: function get() {
        // we do lazy initialization of the collection
        if (!this._items) {
          this._items = new SelectableCollection({
            host: this,
            itemBaseTagName: 'button',
            itemTagName: 'coral-button',
            itemSelector: ITEM_SELECTOR,
            onItemAdded: this._onItemAdded,
            onItemRemoved: this._onItemRemoved,
            onCollectionChange: this._onCollectionChange
          });
        }

        return this._items;
      }
      /**
       Selection mode of Button group
        @type {String}
       @default ButtonGroupSelectionModeEnum.NONE
       @htmlattribute selectionmode
       @htmlattributereflected
       */

    }, {
      key: "selectionMode",
      get: function get() {
        return this._selectionMode || selectionMode.NONE;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        this._selectionMode = validate.enumeration(selectionMode)(value) && value || selectionMode.NONE;

        this._reflectAttribute('selectionmode', this._selectionMode); // update select element if multiple
        // this is required while appplying default selection
        // if selection mode is single first elem gets selected but for multiple its not


        this._elements.nativeSelect.multiple = this._selectionMode === selectionMode.MULTIPLE; // Sync

        if (this._selectionMode === selectionMode.SINGLE) {
          this.setAttribute('role', 'radiogroup'); // makes sure the internal options are properly initialized

          this._syncItemOptions(); // we make sure the selection is valid by explicitly finding a candidate or making sure just 1 item is
          // selected


          this._validateSelection();
        } else if (this._selectionMode === selectionMode.MULTIPLE) {
          this.setAttribute('role', 'group'); // makes sure the internal options are properly initialized

          this._syncItemOptions();
        } else {
          this.setAttribute('role', 'group');

          this._removeItemOptions();
        }
      }
      /**
       Name used to submit the data in a form.
       @type {String}
       @default ""
       @htmlattribute name
       @htmlattributereflected
       */

    }, {
      key: "name",
      get: function get() {
        return this._elements.nativeSelect.name;
      },
      set: function set(value) {
        this._reflectAttribute('name', value);

        this._elements.nativeSelect.name = value;
      }
      /**
       This field's current value.
       @type {String}
       @default ""
       @htmlattribute value
       */

    }, {
      key: "value",
      get: function get() {
        return this._elements.nativeSelect.value;
      },
      set: function set(value) {
        if (this.selectionMode === selectionMode.NONE) {
          return;
        } // we proceed to select the provided value


        this._selectItemByValue([value]);
      }
      /**
       Returns an Array containing the selected buttons.
        @type {Array.<HTMLElement>}
       @readonly
       */

    }, {
      key: "selectedItems",
      get: function get() {
        if (this.selectionMode === selectionMode.MULTIPLE) {
          return this.items._getAllSelected();
        }

        var item = this.selectedItem;
        return item ? [item] : [];
      }
      /**
       Returns the first selected button in the Button Group. The value <code>null</code> is returned if no button is
       selected.
        @type {HTMLElement}
       @readonly
       */

    }, {
      key: "selectedItem",
      get: function get() {
        return this.selectionMode === selectionMode.MULTIPLE ? this.items._getFirstSelected() : this.items._getLastSelected();
      }
      /**
       Current selected values as submitted during form submission.
        @type {Array.<String>}
       */

    }, {
      key: "values",
      get: function get() {
        var values = []; // uses the nativeSelect since it holds the truth of what will be submitted with the form

        var selectedOptions = this._elements.nativeSelect.querySelectorAll(':checked');

        for (var i = 0, selectedOptionsCount = selectedOptions.length; i < selectedOptionsCount; i++) {
          values.push(selectedOptions[i].value);
        }

        return values;
      },
      set: function set(values) {
        if (Array.isArray(values) && this.selectionMode !== selectionMode.NONE) {
          // just keeps the first value if selectionMode is not multiple
          if (this.selectionMode !== selectionMode.MULTIPLE && values.length > 1) {
            values = [values[0]];
          } // we proceed to select the provided values


          this._selectItemByValue(values);
        }
      }
      /**
       Whether this field is disabled or not.
       @type {Boolean}
       @default false
       @htmlattribute disabled
       @htmlattributereflected
       */

    }, {
      key: "disabled",
      get: function get() {
        return this._disabled || false;
      },
      set: function set(value) {
        this._disabled = transform.booleanAttr(value);

        this._reflectAttribute('disabled', this._disabled);

        var isDisabled = this.disabled || this.readOnly;
        this._elements.nativeSelect.disabled = isDisabled; // Also update for all the items the disabled property so it matches the native select.

        this.items.getAll().forEach(function (item) {
          item.disabled = isDisabled;
        });
        this[isDisabled ? 'setAttribute' : 'removeAttribute']('aria-disabled', isDisabled);
      }
      /**
       Whether this field is readOnly or not. Indicating that the user cannot modify the value of the control.
       @type {Boolean}
       @default false
       @htmlattribute readonly
       @htmlattributereflected
       */

    }, {
      key: "readOnly",
      get: function get() {
        return this._readOnly || false;
      },
      set: function set(value) {
        var _this2 = this;

        this._readOnly = transform.booleanAttr(value);

        this._reflectAttribute('readonly', this._readOnly);

        this._elements.nativeSelect.disabled = this.readOnly || this.disabled; // Also update for all the items the disabled property so it matches the native select.

        this.items.getAll().forEach(function (item) {
          item.disabled = _this2.disabled || _this2.readOnly && !item.hasAttribute('selected');
          item[_this2.readOnly ? 'setAttribute' : 'removeAttribute']('aria-disabled', true);
        }); // aria-readonly is not permitted on elements with role="radiogroup" or role="group"

        this.removeAttribute('aria-readonly');
      }
      /**
       Whether this field is required or not.
       @type {Boolean}
       @default false
       @htmlattribute required
       @htmlattributereflected
       */

    }, {
      key: "required",
      get: function get() {
        return this._required || false;
      },
      set: function set(value) {
        this._required = transform.booleanAttr(value);

        this._reflectAttribute('required', this._required);

        this._elements.nativeSelect.required = this.required; // aria-required is permitted on elements with role="radiogroup" but not with role="group"

        if (this.selectionMode !== selectionMode.SINGLE) {
          this.removeAttribute('aria-required');
        }
      }
      /**
       Inherited from {@link BaseFormField#labelledBy}.
       */

    }, {
      key: "labelledBy",
      get: function get() {
        return _get(_getPrototypeOf(ButtonGroup.prototype), "labelledBy", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(ButtonGroup.prototype), "labelledBy", value, this, true);

        this._elements.nativeSelect.setAttribute('aria-labelledby', this.labelledBy);
      }
    }], [{
      key: "selectionMode",
      get: function get() {
        return selectionMode;
      }
    }, {
      key: "_attributePropertyMap",
      get: function get() {
        return commons.extend(_get(_getPrototypeOf(ButtonGroup), "_attributePropertyMap", this), {
          selectionmode: 'selectionMode'
        });
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(ButtonGroup), "observedAttributes", this).concat(['selectionmode', 'selectionMode']);
      }
    }]);

    return ButtonGroup;
  }(BaseFormField(BaseComponent(HTMLElement)));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons._define('coral-buttongroup', ButtonGroup);

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var translations$b = {
    "en-US": {
      "Previous": "Previous",
      "Next": "Next",
      "Today, {0} selected/[translation hint:date]": "Today, {0} selected",
      "Today, {0}/[translation hint:date]": "Today, {0}",
      "{0} selected/[translation hint:date]": "{0} selected",
      "Previous Month": "Previous Month",
      "Next Month": "Next Month"
    },
    "fr-FR": {
      "Previous": "PrÃ©cÃ©dent",
      "Next": "Suivant",
      "Today, {0} selected/[translation hint:date]": "Aujourdâhui, sÃ©lection de {0}",
      "Today, {0}/[translation hint:date]": "Aujourdâhui, {0}",
      "{0} selected/[translation hint:date]": "SÃ©lection de {0}",
      "Previous Month": "Mois prÃ©cÃ©dent",
      "Next Month": "Mois suivant"
    },
    "de-DE": {
      "Previous": "ZurÃ¼ck",
      "Next": "Weiter",
      "Today, {0} selected/[translation hint:date]": "Heute, {0} ausgewÃ¤hlt",
      "Today, {0}/[translation hint:date]": "Heute, {0}",
      "{0} selected/[translation hint:date]": "{0} ausgewÃ¤hlt",
      "Previous Month": "Vorheriger Monat",
      "Next Month": "NÃ¤chster Monat"
    },
    "it-IT": {
      "Previous": "Precedente",
      "Next": "Successivo",
      "Today, {0} selected/[translation hint:date]": "Oggi, {0} selezionati",
      "Today, {0}/[translation hint:date]": "Oggi, {0}",
      "{0} selected/[translation hint:date]": "{0} selezionati",
      "Previous Month": "Mese precedente",
      "Next Month": "Mese successivo"
    },
    "es-ES": {
      "Previous": "Anterior",
      "Next": "Siguiente",
      "Today, {0} selected/[translation hint:date]": "Hoy, {0} seleccionados",
      "Today, {0}/[translation hint:date]": "Hoy, {0}",
      "{0} selected/[translation hint:date]": "{0} seleccionados",
      "Previous Month": "Mes anterior",
      "Next Month": "Mes siguiente"
    },
    "pt-BR": {
      "Previous": "Anterior",
      "Next": "PrÃ³ximo",
      "Today, {0} selected/[translation hint:date]": "Hoje, {0} selecionados",
      "Today, {0}/[translation hint:date]": "Hoje, {0}",
      "{0} selected/[translation hint:date]": "{0} selecionados",
      "Previous Month": "MÃªs Anterior",
      "Next Month": "MÃªs Seguinte"
    },
    "ja-JP": {
      "Previous": "åã¸",
      "Next": "æ¬¡ã¸",
      "Today, {0} selected/[translation hint:date]": "ä»æ¥ã{0} ãé¸æããã¾ãã",
      "Today, {0}/[translation hint:date]": "ä»æ¥ã{0}",
      "{0} selected/[translation hint:date]": "{0} ãé¸æããã¾ãã",
      "Previous Month": "åæ",
      "Next Month": "ç¿æ"
    },
    "ko-KR": {
      "Previous": "ì´ì ì¼ë¡",
      "Next": "ë¤ì",
      "Today, {0} selected/[translation hint:date]": "íì¬ {0}ì´(ê°) ì íë¨",
      "Today, {0}/[translation hint:date]": "íì¬ {0}",
      "{0} selected/[translation hint:date]": "{0}ì´(ê°) ì íë¨",
      "Previous Month": "ì§ë ë¬",
      "Next Month": "ë¤ì ë¬"
    },
    "zh-CN": {
      "Previous": "ä¸ä¸æ­¥",
      "Next": "ä¸ä¸æ­¥",
      "Today, {0} selected/[translation hint:date]": "å·²éå®ä»å¤© {0}",
      "Today, {0}/[translation hint:date]": "ä»å¤© {0}",
      "{0} selected/[translation hint:date]": "å·²éå® {0}",
      "Previous Month": "ä¸ä¸ªæ",
      "Next Month": "ä¸ä¸ªæ"
    },
    "zh-TW": {
      "Previous": "ä¸ä¸é ",
      "Next": "ä¸ä¸é ",
      "Today, {0} selected/[translation hint:date]": "ä»å¤©ï¼å·²é¸å {0}",
      "Today, {0}/[translation hint:date]": "ä»å¤©ï¼{0}",
      "{0} selected/[translation hint:date]": "å·²é¸å {0} ",
      "Previous Month": "ä¸åæ",
      "Next Month": "ä¸åæ"
    },
    "nl-NL": {
      "Previous": "Vorige",
      "Next": "Volgende",
      "Today, {0} selected/[translation hint:date]": "Vandaag {0} geselecteerd",
      "Today, {0}/[translation hint:date]": "Vandaag {0} ",
      "{0} selected/[translation hint:date]": "{0} geselecteerd",
      "Previous Month": "Vorige maand",
      "Next Month": "Volgende maand"
    },
    "da-DK": {
      "Previous": "ForegÃ¥ende",
      "Next": "NÃ¦ste",
      "Today, {0} selected/[translation hint:date]": "I dag, {0} valgt",
      "Today, {0}/[translation hint:date]": "I dag, {0} ",
      "{0} selected/[translation hint:date]": "{0} valgt",
      "Previous Month": "Sidste mÃ¥ned",
      "Next Month": "NÃ¦ste mÃ¥ned"
    },
    "fi-FI": {
      "Previous": "Edellinen",
      "Next": "Seuraava",
      "Today, {0} selected/[translation hint:date]": "TÃ¤nÃ¤Ã¤n, {0} valittu",
      "Today, {0}/[translation hint:date]": "TÃ¤nÃ¤Ã¤n, {0}",
      "{0} selected/[translation hint:date]": "{0} valittu",
      "Previous Month": "Edellinen kuukausi",
      "Next Month": "Seuraava kuukausi"
    },
    "nb-NO": {
      "Previous": "Forrige",
      "Next": "Neste",
      "Today, {0} selected/[translation hint:date]": "I dag, {0} valgt",
      "Today, {0}/[translation hint:date]": "I dag, {0}",
      "{0} selected/[translation hint:date]": "{0} valgt",
      "Previous Month": "Forrige mÃ¥ned",
      "Next Month": "Neste mÃ¥ned"
    },
    "sv-SE": {
      "Previous": "FÃ¶regÃ¥ende",
      "Next": "NÃ¤sta",
      "Today, {0} selected/[translation hint:date]": "Idag, {0} vald",
      "Today, {0}/[translation hint:date]": "Idag, {0}",
      "{0} selected/[translation hint:date]": "{0} vald",
      "Previous Month": "FÃ¶regÃ¥ende mÃ¥nad",
      "Next Month": "NÃ¤sta mÃ¥nad"
    },
    "cs-CZ": {
      "Previous": "PÅedchozÃ­",
      "Next": "DalÅ¡Ã­",
      "Today, {0} selected/[translation hint:date]": "Dnes je vybrÃ¡no: {0}",
      "Today, {0}/[translation hint:date]": "Dnes, {0}",
      "{0} selected/[translation hint:date]": "VybrÃ¡no: {0}",
      "Previous Month": "PÅedchozÃ­ mÄsÃ­c",
      "Next Month": "PÅÃ­Å¡tÃ­ mÄsÃ­c"
    },
    "pl-PL": {
      "Previous": "Wstecz",
      "Next": "Dalej",
      "Today, {0} selected/[translation hint:date]": "DziÅ, wybrano {0}",
      "Today, {0}/[translation hint:date]": "DziÅ, {0}",
      "{0} selected/[translation hint:date]": "wybrano {0}",
      "Previous Month": "Poprzedni miesiÄc",
      "Next Month": "NastÄpny miesiÄc"
    },
    "ru-RU": {
      "Previous": "ÐÑÐµÐ´ÑÐ´ÑÑÐ¸Ð¹",
      "Next": "Ð¡Ð»ÐµÐ´ÑÑÑÐ¸Ð¹",
      "Today, {0} selected/[translation hint:date]": "Ð¡ÐµÐ³Ð¾Ð´Ð½Ñ, {0}, Ð²ÑÐ±ÑÐ°Ð½Ð¾",
      "Today, {0}/[translation hint:date]": "Ð¡ÐµÐ³Ð¾Ð´Ð½Ñ, {0}",
      "{0} selected/[translation hint:date]": "{0} Ð²ÑÐ±ÑÐ°Ð½Ð¾",
      "Previous Month": "ÐÑÐµÐ´ÑÐ´ÑÑÐ¸Ð¹ Ð¼ÐµÑÑÑ",
      "Next Month": "Ð¡Ð»ÐµÐ´ÑÑÑÐ¸Ð¹ Ð¼ÐµÑÑÑ"
    },
    "tr-TR": {
      "Previous": "Ãnceki",
      "Next": "Ä°leri",
      "Today, {0} selected/[translation hint:date]": "BugÃ¼n, {0} seÃ§ildi",
      "Today, {0}/[translation hint:date]": "BugÃ¼n, {0}",
      "{0} selected/[translation hint:date]": "{0} seÃ§ildi",
      "Previous Month": "Ãnceki Ay",
      "Next Month": "Gelecek Ay"
    }
  };

  var template$j = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var data = data_0 = typeof data_0 === "undefined" ? {} : data_0;
    var el0 = this["input"] = document.createElement("input");
    el0.setAttribute("handle", "input");
    el0.setAttribute("type", "hidden");
    el0.setAttribute("name", "");
    frag.appendChild(el0);
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    var el2 = this["header"] = document.createElement("div");
    el2.setAttribute("handle", "header");
    el2.className += " _coral-Calendar-header";
    var el3 = document.createTextNode("\n  ");
    el2.appendChild(el3);
    var el4 = this["heading"] = document.createElement("div");
    el4.setAttribute("handle", "heading");
    el4.className += " _coral-Calendar-title";
    el4.setAttribute("role", "heading");
    el4.setAttribute("aria-live", "assertive");
    el4.setAttribute("aria-atomic", "true");
    el4.setAttribute("aria-level", "2");
    el4.id = data_0["commons"]["getUID"]();
    el2.appendChild(el4);
    var el5 = document.createTextNode("\n  ");
    el2.appendChild(el5);
    var el6 = this["prev"] = document.createElement("button", "coral-button");
    el6.setAttribute("type", "button");
    el6.setAttribute("handle", "prev");
    el6.className += " _coral-Calendar-prevMonth";
    el6.setAttribute("is", "coral-button");
    el6.setAttribute("variant", "quietaction");
    el6.setAttribute("aria-label", data_0["i18n"]["get"]('Previous Month'));
    el6.setAttribute("title", data_0["i18n"]["get"]('Previous Month'));
    var el7 = document.createTextNode("\n    ");
    el6.appendChild(el7);
    var el8 = this["prevLabel"] = document.createElement("coral-button-label");
    el8.setAttribute("handle", "prevLabel");
    el6.appendChild(el8);
    var el9 = document.createTextNode("\n  ");
    el6.appendChild(el9);
    el2.appendChild(el6);
    var el10 = document.createTextNode("\n  ");
    el2.appendChild(el10);
    var el11 = this["next"] = document.createElement("button", "coral-button");
    el11.setAttribute("type", "button");
    el11.setAttribute("handle", "next");
    el11.className += " _coral-Calendar-nextMonth";
    el11.setAttribute("is", "coral-button");
    el11.setAttribute("variant", "quietaction");
    el11.setAttribute("aria-label", data_0["i18n"]["get"]('Next Month'));
    el11.setAttribute("title", data_0["i18n"]["get"]('Next Month'));
    var el12 = document.createTextNode("\n    ");
    el11.appendChild(el12);
    var el13 = this["nextLabel"] = document.createElement("coral-button-label");
    el13.setAttribute("handle", "nextLabel");
    el11.appendChild(el13);
    var el14 = document.createTextNode("\n  ");
    el11.appendChild(el14);
    el2.appendChild(el11);
    var el15 = document.createTextNode("\n  ");
    el2.appendChild(el15);
    data = data_0; // Don't wait for button MO to pick up the label

    this.prev._elements.label = this.prevLabel;
    this.next._elements.label = this.nextLabel; // Render chevron icon

    this.prev.insertAdjacentHTML('beforeend', data.Icon._renderSVG('spectrum-css-icon-ChevronLeftLarge', ['_coral-UIIcon-ChevronLeftLarge']));
    this.next.insertAdjacentHTML('beforeend', data.Icon._renderSVG('spectrum-css-icon-ChevronRightLarge', ['_coral-UIIcon-ChevronRightLarge']));
    data_0 = data;
    var el17 = document.createTextNode("\n");
    el2.appendChild(el17);
    frag.appendChild(el2);
    var el18 = document.createTextNode("\n");
    frag.appendChild(el18);
    var el19 = this["body"] = document.createElement("div");
    el19.className += " _coral-Calendar-body";
    el19.setAttribute("handle", "body");
    el19.setAttribute("role", "grid");
    el19.setAttribute("tabindex", "0");
    el19.setAttribute("aria-readonly", "true");
    el19.setAttribute("aria-labelledby", this["heading"]["id"]);
    frag.appendChild(el19);
    var el20 = document.createTextNode("\n");
    frag.appendChild(el20);
    return frag;
  };

  var template$k = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["container"] = document.createElement("div");
    el0.className += " _coral-DatePicker-calendarSlidingContainer";
    el0.setAttribute("handle", "container");
    el0.setAttribute("style", "width: " + data_0["width"] + "px; height: " + data_0["height"] + "px;");
    frag.appendChild(el0);
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    return frag;
  };

  var template$l = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var data = data_0 = typeof data_0 === "undefined" ? {} : data_0;
    data = data_0;
    this.i18n = data.i18n;
    this.commons = data.commons;
    data_0 = data;
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    var el2 = this["table"] = document.createElement("table");
    el2.setAttribute("handle", "table");
    el2.className += " _coral-Calendar-table";
    el2.setAttribute("role", "presentation");
    var el3 = document.createTextNode("\n  ");
    el2.appendChild(el3);
    var el4 = document.createElement("thead");
    el4.setAttribute("role", "presentation");
    var el5 = document.createTextNode("\n    ");
    el4.appendChild(el5);
    var el6 = document.createElement("tr");
    el6.setAttribute("role", "row");
    var el7 = document.createTextNode("\n      ");
    el6.appendChild(el7);
    var iterated_1 = data_0["dayNames"];

    for (var i1 = 0, ni1 = iterated_1.length; i1 < ni1; i1++) {
      var data_1 = data = iterated_1[i1];
      var el9 = document.createTextNode("\n        ");
      el6.appendChild(el9);
      var el10 = document.createElement("th");
      el10.setAttribute("role", "columnheader");
      el10.setAttribute("scope", "col");
      el10.className += " _coral-Calendar-tableCell";
      var el11 = document.createTextNode("\n          ");
      el10.appendChild(el11);
      var el12 = document.createElement("abbr");
      el12.className += " _coral-Calendar-dayOfWeek";
      el12.setAttribute("title", data_1["dayFullName"]);
      el12.textContent = data_1["dayAbbr"];
      el10.appendChild(el12);
      var el13 = document.createTextNode("\n        ");
      el10.appendChild(el13);
      el6.appendChild(el10);
      var el14 = document.createTextNode("\n      ");
      el6.appendChild(el14);
    }

    var el15 = document.createTextNode("\n    ");
    el6.appendChild(el15);
    el4.appendChild(el6);
    var el16 = document.createTextNode("\n  ");
    el4.appendChild(el16);
    el2.appendChild(el4);
    var el17 = document.createTextNode("\n  ");
    el2.appendChild(el17);
    var el18 = document.createElement("tbody");
    el18.setAttribute("role", "presentation");
    var el19 = document.createTextNode("\n    ");
    el18.appendChild(el19);
    var iterated_1 = data_0["weeks"];

    for (var i1 = 0, ni1 = iterated_1.length; i1 < ni1; i1++) {
      var data_1 = data = iterated_1[i1];
      var el21 = document.createTextNode("\n      ");
      el18.appendChild(el21);
      var el22 = document.createElement("tr");
      el22.setAttribute("role", "row");
      var el23 = document.createTextNode("\n        ");
      el22.appendChild(el23);
      var iterated_2 = data_1;

      for (var i2 = 0, ni2 = iterated_2.length; i2 < ni2; i2++) {
        var data_2 = data = iterated_2[i2];
        var el25 = document.createTextNode("\n          ");
        el22.appendChild(el25);
        data = data_2;
        var calendarTitle;
        var calendarDate = data.dateLabel + ', ' + data.formattedDate;

        if (data.isToday) {
          if (data.ariaSelected) {
            calendarTitle = this.i18n.get('Today, {0} selected', calendarDate, 'date');
          } else {
            calendarTitle = this.i18n.get('Today, {0}', calendarDate, 'date');
          }
        } else {
          if (data.ariaSelected) {
            calendarTitle = this.i18n.get('{0} selected', calendarDate, 'date');
          } else {
            calendarTitle = calendarTitle = calendarDate;
          }
        }

        data_2 = data;
        var el27 = document.createTextNode("\n          ");
        el22.appendChild(el27);
        var el28 = this["cell"] = document.createElement("td");
        el28.setAttribute("handle", "cell");
        el28.setAttribute("role", "gridcell");
        el28.id = this["commons"]["getUID"]() + "-row" + i1 + "-col" + i2;
        el28.className += " _coral-Calendar-tableCell";
        el28.setAttribute("aria-selected", data_2["ariaSelected"]);

        if (data_2["isDisabled"]) {
          el28.setAttribute("aria-disabled", "true");
        }

        if (data_2["ariaInvalid"]) {
          el28.setAttribute("aria-invalid", "true");
        }

        if (data_2["formattedDate"]) {
          el28.setAttribute("title", calendarTitle);
        }

        var el29 = document.createTextNode("\n            ");
        el28.appendChild(el29);
        data = data_2;

        if (data.cssClass.indexOf('is-outsideMonth') !== -1) {
          this.cell.classList.add('is-outsideMonth');
        }

        data_2 = data;
        var el31 = document.createTextNode("\n            ");
        el28.appendChild(el31);

        if (data_2["dateAttr"]) {
          var el33 = document.createTextNode("\n                ");
          el28.appendChild(el33);
          var el34 = document.createElement("a");
          el34.setAttribute("role", "presentation");
          el34.className += " _coral-Calendar-date " + data_2["cssClass"];
          el34.setAttribute("data-date", data_2["dateAttr"]);
          el34.textContent = data_2["dateText"];
          el28.appendChild(el34);
          var el35 = document.createTextNode("\n              ");
          el28.appendChild(el35);
          var el36 = document.createTextNode("\n            ");
          el28.appendChild(el36);
        } else {
          var el37 = document.createTextNode("\n                ");
          el28.appendChild(el37);
          var el38 = document.createElement("span");
          el38.setAttribute("role", "presentation");
          el38.className += " _coral-Calendar-date " + data_2["cssClass"];
          el38.textContent = data_2["dateText"];
          el28.appendChild(el38);
          var el39 = document.createTextNode("\n              ");
          el28.appendChild(el39);
        }

        var el40 = document.createTextNode("\n          ");
        el28.appendChild(el40);
        el22.appendChild(el28);
        var el41 = document.createTextNode("\n        ");
        el22.appendChild(el41);
      }

      var el42 = document.createTextNode("\n      ");
      el22.appendChild(el42);
      el18.appendChild(el22);
      var el43 = document.createTextNode("\n    ");
      el18.appendChild(el43);
    }

    var el44 = document.createTextNode("\n  ");
    el18.appendChild(el44);
    el2.appendChild(el18);
    var el45 = document.createTextNode("\n  ");
    el2.appendChild(el45);
    var el46 = document.createElement("caption");
    el46.className += " u-coral-screenReaderOnly";
    el46.setAttribute("aria-live", "assertive");
    el46.setAttribute("aria-atomic", "true");
    el2.appendChild(el46);
    var el47 = document.createTextNode("\n");
    el2.appendChild(el47);
    frag.appendChild(el2);
    var el48 = document.createTextNode("\n");
    frag.appendChild(el48);
    return frag;
  };

  /** @ignore */

  function isDateInRange(date, startDate, endDate) {
    if (!date) {
      return false;
    }

    if (startDate === null && endDate === null) {
      return true;
    } else if (startDate === null) {
      return date.toDate() <= endDate;
    } else if (endDate === null) {
      return date.toDate() >= startDate;
    }

    return startDate <= date.toDate() && date.toDate() <= endDate;
  }
  /** @ignore */


  function toMoment(value, format) {
    if (value === 'today') {
      return new DateTime.Moment().startOf('day');
    } else if (DateTime.Moment.isMoment(value)) {
      return value.isValid() ? value.clone() : null;
    } // if the value provided is a date it does not make sense to provide a format to parse the date


    var result = new DateTime.Moment(value, value instanceof Date ? null : format);
    return result.isValid() ? result.startOf('day') : null;
  }
  /** @ignore */


  function validateAsChangedAndValidMoment(newValue, oldValue) {
    // if the value is undefined we change it to null since moment considers both to be different
    newValue = newValue || null;
    oldValue = oldValue || null;

    if (newValue !== oldValue && !new DateTime.Moment(newValue).isSame(oldValue, 'day')) {
      return newValue === null || newValue.isValid();
    }

    return false;
  }
  /**
   Slides in new month tables, slides out old tables, and then cleans up the leftovers when it is done.

   @ignore
   */


  function TableAnimator(host) {
    var _this = this;

    this.host = host;

    this._addContainerIfNotPresent = function (width, height) {
      if (!_this.container) {
        // Get a fresh container for the animation:
        template$k.call(_this, {
          width: width,
          height: height
        });

        _this.host.appendChild(_this.container);
      }
    };

    this._removeContainerIfEmpty = function () {
      if (_this.container && _this.container.children.length === 0) {
        _this.host.removeChild(_this.container);

        _this.container = null;
      }
    };

    this.slide = function (newTable, direction) {
      var replace = direction === undefined;
      var isLeft = direction === 'left';
      var oldTable = _this.oldTable; // Should the replace flag be raised, or no old table be present, then do a non-transitioned (re)place and exit

      if (replace || !oldTable) {
        if (oldTable) {
          oldTable.parentNode.removeChild(oldTable);
        }

        _this.host.insertBefore(newTable, _this.host.firstChild);

        _this.oldTable = newTable;
        return;
      }

      var boundingClientRect = oldTable.getBoundingClientRect();
      var width = boundingClientRect.width;
      var height = boundingClientRect.height;

      _this._addContainerIfNotPresent(width, height); // Add both the old and the new table to the container:


      _this.container.appendChild(oldTable);

      _this.container.appendChild(newTable); // Set the existing table to start from being in full view, and mark it to transition on `left` changing


      oldTable.classList.add('_coral-Calendar-table--transit');
      commons.transitionEnd(oldTable, function () {
        oldTable.parentNode.removeChild(oldTable);

        _this._removeContainerIfEmpty();
      }); // Set the new table to start out of view (either left or right depending on the direction of the slide), and mark
      // it to transition on `left` changing

      newTable.classList.add('_coral-Calendar-table--transit');
      newTable.style.left = "".concat(isLeft ? width : -width, "px"); // When the transition is done, have the transition class lifted

      commons.transitionEnd(newTable, function () {
        newTable.classList.remove('_coral-Calendar-table--transit');

        _this.host.appendChild(newTable);

        _this._removeContainerIfEmpty();
      }); // Force a redraw by querying the browser for its offsetWidth. Without this, the re-positioning code later on
      // would not lead to a transition. Note that there's no significance to the resulting value being assigned to
      // 'height'

      height = _this.container.offsetWidth; // Set the `left` positions to transition to:

      oldTable.style.left = "".concat(isLeft ? -width : width, "px");
      newTable.style.left = 0;
      _this.oldTable = newTable;
    };
  }
  /** @ignore */


  var ARRAYOF6 = [0, 0, 0, 0, 0, 0];
  /** @ignore */

  var ARRAYOF7 = [0, 0, 0, 0, 0, 0, 0];
  /** @ignore */

  var INTERNAL_FORMAT = 'YYYY-MM-DD';
  /** @ignore */

  var timeUnit = {
    YEAR: 'year',
    MONTH: 'month',
    WEEK: 'week',
    DAY: 'day'
  };
  var CLASSNAME$C = '_coral-Calendar';
  /**
   @class Coral.Calendar
   @classdesc A Calendar component that can be used as a date selection form field. Leverages {@link momentJS} if loaded
   on the page.
   @htmltag coral-calendar
   @extends {HTMLElement}
   @extends {BaseComponent}
   @extends {BaseFormField}
   */

  var Calendar = /*#__PURE__*/function (_BaseFormField) {
    _inherits(Calendar, _BaseFormField);

    var _super = _createSuper(Calendar);

    /** @ignore */
    function Calendar() {
      var _this2;

      _classCallCheck(this, Calendar);

      _this2 = _super.call(this); // Default value

      _this2._value = null;

      _this2._delegateEvents(commons.extend(_this2._events, {
        'click ._coral-Calendar-nextMonth,._coral-Calendar-prevMonth': '_onNextOrPreviousMonthClick',
        'click ._coral-Calendar-body ._coral-Calendar-date': '_onDayClick',
        'mousedown ._coral-Calendar-body ._coral-Calendar-date': '_onDayMouseDown',
        'key:up ._coral-Calendar-body': '_onUpKey',
        'key:right ._coral-Calendar-body': '_onRightKey',
        'key:down ._coral-Calendar-body': '_onDownKey',
        'key:left ._coral-Calendar-body': '_onLeftKey',
        'key:home ._coral-Calendar-body': '_onHomeOrEndKey',
        'key:end ._coral-Calendar-body': '_onHomeOrEndKey',
        'key:pageup': '_onPageUpKey',
        'key:pagedown': '_onPageDownKey',
        // On OSX we use Command+Page Up
        'key:meta+pageup': '_onCtrlPageUpKey',
        // On OSX we use Command+Page Down
        'key:meta+pagedown': '_onCtrlPageDownKey',
        // On Windows, we use CTRL+Page Up
        'key:ctrl+pageup': '_onCtrlPageUpKey',
        // On Windows, we use CTRL+Page Down
        'key:ctrl+pagedown': '_onCtrlPageDownKey',
        'key:enter ._coral-Calendar-body': '_onEnterKey',
        'key:return ._coral-Calendar-body': '_onEnterKey',
        'key:space ._coral-Calendar-body': '_onEnterKey'
      })); // Prepare templates


      _this2._elements = {};
      template$j.call(_this2._elements, {
        commons: commons,
        i18n: i18n,
        Icon: Icon
      }); // Pre-define labellable element

      _this2._labellableElement = _assertThisInitialized(_this2); // Internal keeper of the month that is currently on display.

      _this2._cursor = null; // Internal keeper for the id of the currently focused date cell or the cell that would receive focus when the
      // calendar body receives focus.

      _this2._activeDescendant = null;
      _this2._animator = new TableAnimator(_this2._elements.body);
      return _this2;
    }
    /**
     Defines the start day for the week, 0 = Sunday, 1 = Monday etc., as depicted on the calendar days grid.
      @type {Number}
     @default 0
     @htmlattribute startday
     */


    _createClass(Calendar, [{
      key: "_renderCalendar",

      /** @ignore */
      value: function _renderCalendar(slide) {
        var _this3 = this;

        var cursor = this._requireCursor();

        var displayYear = cursor.year();
        var displayMonth = cursor.month();
        var oldTable = this._animator.oldTable;
        this._elements.heading.innerHTML = new DateTime.Moment([displayYear, displayMonth, 1]).format(this.headerFormat);

        var newTable = this._renderTable(displayYear, displayMonth + 1);

        if (oldTable) {
          commons.transitionEnd(newTable, function () {
            _this3._setActiveDescendant();
          });
        }

        this._animator.slide(newTable, slide);

        var el = this._elements.body.querySelector('.is-selected'); // This will be overwritten later if there is any other function setting the attribute


        this._activeDescendant = el ? el.id : null;

        this._setActiveDescendant();
      }
      /**
       Returns <code>true</code> if moment specified is before <code>min</code>.
        @param {moment} currentMoment
       A moment to test.
       @param {String} unit
       Year, Month, Week, Day
       @returns {Boolean}
       <code>true</code> if moment specified is before <code>min</code>
        @ignore
       */

    }, {
      key: "_isBeforeMin",
      value: function _isBeforeMin(currentMoment, unit) {
        var min = this.min ? new DateTime.Moment(this.min) : null;
        return min && currentMoment.isBefore(min, unit);
      }
      /**
       Returns <code>true</code> if moment specified is after <code>max</code>.
        @param {moment} currentMoment
       A moment to test.
       @param {String} unit
       Year, Month, Week, Day
       @returns {Boolean}
       <code>true</code> if moment specified is after <code>max</code>
        @ignore
       */

    }, {
      key: "_isAfterMax",
      value: function _isAfterMax(currentMoment, unit) {
        var max = this.max ? new DateTime.Moment(this.max) : null;
        return max && currentMoment.isAfter(max, unit);
      }
      /**
       Returns <code>true</code> if moment specified is greater than or equal to <code>min</code> and less than or equal to <code>max</code>.
        @param {moment} currentMoment
       A moment to test.
       @param {String} unit
       Year, Month, Week, Day
       @returns {Boolean}
       <code>true</code> if moment specified falls within <code>min</code>/<code>max</code> date range.
        @ignore
       */

    }, {
      key: "_isInRange",
      value: function _isInRange(currentMoment, unit) {
        return !(this._isBeforeMin(currentMoment, unit) || this._isAfterMax(currentMoment, unit));
      }
      /**
       Updates the aria-activedescendant property for the calendar grid to communicate the currently focused date, or the
       date that should get focus when the grid receives focus, to assistive technology.
        @ignore
       */

    }, {
      key: "_setActiveDescendant",
      value: function _setActiveDescendant() {
        var el;

        if (!this._activeDescendant || !this._elements.body.querySelector("#".concat(this._activeDescendant, " [data-date]"))) {
          this._activeDescendant = null;
          el = this._elements.body.querySelector('.is-selected');
          this._activeDescendant = el && el.id;

          if (!this._activeDescendant || !this._elements.body.querySelector("#".concat(this._activeDescendant, " [data-date]"))) {
            var currentMoment = this._value;

            if (currentMoment) {
              var dates = this._elements.body.querySelectorAll('[data-date]');

              if (dates.length) {
                if (this._isBeforeMin(currentMoment)) {
                  el = dates[0];
                } else if (this._isAfterMax(currentMoment)) {
                  el = dates[dates.length - 1];
                }
              }
            } else {
              el = this._elements.body.querySelector('.is-focused') || this._elements.body.querySelector('.is-today');
            }

            if (el) {
              this._activeDescendant = el.parentElement.id;
            }
          }
        }

        el = this._elements.body.querySelector('.is-focused');

        if (el) {
          el.classList.remove('is-focused');
        }

        this._elements.body[this._activeDescendant ? 'setAttribute' : 'removeAttribute']('aria-activedescendant', this._activeDescendant);

        this._updateTableCaption();

        if (!this._activeDescendant) {
          return;
        }

        el = document.getElementById(this._activeDescendant);
        var newTable = this.querySelector('._coral-Calendar-table--transit');
        var isTransitioning = newTable !== null;

        if (el) {
          if (isTransitioning) {
            window.requestAnimationFrame(function () {
              el.querySelector('._coral-Calendar-date').classList.add('is-focused');
            });
          } else {
            // Focus the selected date
            el.querySelector('._coral-Calendar-date').classList.add('is-focused');
          }
        }
      }
      /**
       Updates the table caption which serves as a live region to announce the currently focused date to assistive
       technology, improving compatibility across operating systems, browsers and screen readers.
        @ignore
       */

    }, {
      key: "_updateTableCaption",
      value: function _updateTableCaption() {
        var caption = this._elements.body.querySelector('caption');

        if (!caption) {
          return;
        }

        if (caption.firstChild) {
          caption.removeChild(caption.firstChild);
        }

        if (this._activeDescendant) {
          var activeDescendant = this._elements.body.querySelector("#".concat(this._activeDescendant));

          var captionText = document.createTextNode(activeDescendant.getAttribute('title'));
          caption.appendChild(captionText);
        }
      }
      /** @ignore */

    }, {
      key: "_renderTable",
      value: function _renderTable(year, month) {
        var _this4 = this;

        var firstDate = new DateTime.Moment([year, month - 1, 1]);
        var monthStartsAt = (firstDate.day() - this.startDay) % 7;
        var dateLocal = this._value ? this._value.clone().startOf('day') : null;

        if (monthStartsAt < 0) {
          monthStartsAt += 7;
        }

        var data = {
          i18n: i18n,
          commons: commons,
          // eslint-disable-next-line no-unused-vars
          dayNames: ARRAYOF7.map(function (currentIndex, index) {
            var dayMoment = new DateTime.Moment().day((index + _this4.startDay) % 7);
            return {
              dayAbbr: dayMoment.format('dd'),
              dayFullName: dayMoment.format('dddd')
            };
          }, this),
          // eslint-disable-next-line no-unused-vars, arrow-body-style
          weeks: ARRAYOF6.map(function (currentWeekIndex, weekIndex) {
            // eslint-disable-next-line no-unused-vars
            return ARRAYOF7.map(function (currentDayIndex, dayIndex) {
              var result = {};
              var cssClass = _this4.disabled ? ['is-disabled'] : [];
              var ariaSelected = false;
              var ariaInvalid = false;
              var day = weekIndex * 7 + dayIndex - monthStartsAt;
              var cursor = new DateTime.Moment([year, month - 1]); // we use add() since 'day' could be a negative value

              cursor.add(day, 'days');
              var isCurrentMonth = cursor.month() + 1 === parseFloat(month);
              var dayOfWeek = new DateTime.Moment().day((dayIndex + _this4.startDay) % 7).format('dddd');
              var isToday = cursor.isSame(new DateTime.Moment(), 'day');
              var cursorLocal = cursor.clone().startOf('day');

              if (isToday) {
                cssClass.push('is-today');
              }

              if (dateLocal && cursorLocal.isSame(dateLocal, 'day')) {
                ariaSelected = true;
                cssClass.push('is-selected');

                if (_this4.invalid) {
                  ariaInvalid = true;
                  cssClass.push('is-invalid');
                }
              }

              if (isCurrentMonth) {
                cssClass.push('is-currentMonth');

                if (!_this4.disabled && isDateInRange(cursor, _this4.min, _this4.max)) {
                  result.dateAttr = cursorLocal.format(INTERNAL_FORMAT);
                  result.weekIndex = cursor.week();
                  result.formattedDate = cursor.format('LL');
                } else {
                  cssClass.push('is-disabled');
                }
              } else {
                cssClass.push('is-outsideMonth');
              }

              result.isDisabled = _this4.disabled || !result.dateAttr;
              result.dateText = cursor.date();
              result.cssClass = cssClass.join(' ');
              result.isToday = isToday;
              result.ariaSelected = ariaSelected;
              result.ariaInvalid = ariaInvalid;
              result.dateLabel = dayOfWeek;
              result.weekIndex = cursor.week();
              return result;
            }, _this4);
          }, this)
        };
        var handles = {};
        template$l.call(handles, data);
        return handles.table;
      }
      /** @ignore */

    }, {
      key: "_requireCursor",
      value: function _requireCursor() {
        var cursor = this._cursor;

        if (!cursor || !cursor.isValid()) {
          // When its unknown what month we should be showing, use the set date. If that is not available, use 'today'
          cursor = (this._value ? this._value.clone().startOf('day') : new DateTime.Moment()).startOf('month');
          this._cursor = cursor;
        }

        return cursor;
      }
      /**
       Navigate to previous or next timeUnit interval.
        @param {String} unit
       Year, Month, Week, Day
       @param {Boolean} isNext
       Whether to navigate forward or backward.
        @private
       */

    }, {
      key: "_gotoPreviousOrNextTimeUnit",
      value: function _gotoPreviousOrNextTimeUnit(unit, isNext) {
        var direction = isNext ? 'left' : 'right';
        var operator = isNext ? 'add' : 'subtract';

        var el = this._elements.body.querySelector('._coral-Calendar-date.is-focused');

        var currentActive;
        var currentMoment;
        var newMoment;
        var difference;

        if (el) {
          currentActive = el.dataset.date;
          currentMoment = new DateTime.Moment(currentActive);
          newMoment = currentMoment[operator](1, unit); // make sure new moment is in range before transitioning

          if (this._isInRange(newMoment, unit)) {
            difference = Math.abs(new DateTime.Moment(currentActive).diff(newMoment, 'days'));

            this._getToNewMoment(direction, operator, difference);

            this._setActiveDescendant();
          }
        } else {
          this._requireCursor(); // if cursor is out of range


          if (!this._isInRange(this._cursor, unit)) {
            // advance to closest value in range
            if (this._isBeforeMin(this._cursor)) {
              newMoment = this.min;
            } else if (this._isAfterMax(this._cursor)) {
              newMoment = this.max;
            }

            newMoment = new DateTime.Moment(newMoment);
            difference = Math.abs(this._cursor.diff(newMoment, 'days'));

            this._getToNewMoment(direction, operator, difference);

            this._setActiveDescendant();

            return;
          }

          this._cursor[operator](1, unit);

          this._renderCalendar(direction);
        }
      }
      /**
       Checks if the Calendar is valid or not. This is done by checking that the current value is between the
       provided <code>min</code> and <code>max</code> values. This check is only performed on user interaction.
       @ignore
       */

    }, {
      key: "_validateCalendar",
      value: function _validateCalendar() {
        var isInvalid = !(this._value === null || isDateInRange(this._value, this.min, this.max));

        if (this.invalid !== isInvalid) {
          this.invalid = isInvalid;
        }
      }
      /** @ignore */

    }, {
      key: "_onNextOrPreviousMonthClick",
      value: function _onNextOrPreviousMonthClick(event) {
        event.preventDefault();

        this._gotoPreviousOrNextTimeUnit(timeUnit.MONTH, this._elements.next === event.matchedTarget);

        event.matchedTarget.focus();

        this._validateCalendar();
      }
      /** @ignore */

    }, {
      key: "_getToNewMoment",
      value: function _getToNewMoment(direction, operator, difference) {
        var el = this._elements.body.querySelector('._coral-Calendar-date.is-focused');

        var currentActive;

        if (el) {
          currentActive = el.dataset.date;
        } else {
          this._requireCursor();

          currentActive = this._cursor.format(INTERNAL_FORMAT);
        }

        var currentMoment = new DateTime.Moment(currentActive);
        var currentMonth = currentMoment.month();
        var currentYear = currentMoment.year();
        var newMoment = currentMoment[operator](difference, 'days');
        var newMonth = newMoment.month();
        var newYear = newMoment.year();
        var newMomentValue = newMoment.format(INTERNAL_FORMAT);

        if (newMonth !== currentMonth) {
          this._requireCursor();

          this._cursor[operator](1, 'months');

          this._renderCalendar(direction);
        } else if (newMonth === currentMonth && newYear !== currentYear) {
          this._requireCursor();

          this._cursor[operator](1, 'years');

          this._renderCalendar(direction);
        }

        var dateQuery = "._coral-Calendar-date[data-date^=".concat(JSON.stringify(newMomentValue), "]");

        var newDescendant = this._elements.body.querySelector(dateQuery);

        if (newDescendant) {
          this._activeDescendant = newDescendant.parentNode.getAttribute('id');
        }
      }
      /** @ignore */

    }, {
      key: "_onDayMouseDown",
      value: function _onDayMouseDown(event) {
        this._activeDescendant = event.target.parentNode.id;

        this._setActiveDescendant();

        this._elements.body.focus();

        this._validateCalendar();
      }
      /** @ignore */

    }, {
      key: "_onDayClick",
      value: function _onDayClick(event) {
        event.preventDefault();

        this._elements.body.focus();

        var date = new DateTime.Moment(event.target.dataset.date, INTERNAL_FORMAT);
        var dateLocal; // Carry over any user set time info

        if (this._value) {
          dateLocal = this._value.clone();
        } // Set attribute so a change event will be triggered if the user has selected a different date


        if (validateAsChangedAndValidMoment(date, dateLocal)) {
          this.value = date;
          this.trigger('change');
        }

        this._validateCalendar();
      }
      /** @ignore */

    }, {
      key: "_onEnterKey",
      value: function _onEnterKey(event) {
        event.preventDefault();

        var el = this._elements.body.querySelector('._coral-Calendar-date.is-focused');

        if (el) {
          el.click();
        }

        this._validateCalendar();
      }
      /** @ignore */

    }, {
      key: "_onUpKey",
      value: function _onUpKey(event) {
        event.preventDefault();

        this._gotoPreviousOrNextTimeUnit(timeUnit.WEEK, false);

        this._validateCalendar();
      }
      /** @ignore */

    }, {
      key: "_onDownKey",
      value: function _onDownKey(event) {
        event.preventDefault();

        this._gotoPreviousOrNextTimeUnit(timeUnit.WEEK, true);

        this._validateCalendar();
      }
      /** @ignore */

    }, {
      key: "_onRightKey",
      value: function _onRightKey(event) {
        event.preventDefault();

        this._gotoPreviousOrNextTimeUnit(timeUnit.DAY, true);

        this._validateCalendar();
      }
      /** @ignore */

    }, {
      key: "_onLeftKey",
      value: function _onLeftKey(event) {
        event.preventDefault();

        this._gotoPreviousOrNextTimeUnit(timeUnit.DAY, false);

        this._validateCalendar();
      }
      /** @ignore */

    }, {
      key: "_onHomeOrEndKey",
      value: function _onHomeOrEndKey(event) {
        event.preventDefault();
        var isHome = event.keyCode === Keys.keyToCode('home');
        var direction = '';
        var operator = isHome ? 'subtract' : 'add';

        var el = this._elements.body.querySelector('._coral-Calendar-date.is-focused');

        if (el) {
          var currentActive = el.dataset.date;
          var currentMoment = new DateTime.Moment(currentActive);
          var difference = isHome ? currentMoment.date() - 1 : currentMoment.daysInMonth() - currentMoment.date();

          this._getToNewMoment(direction, operator, difference);

          this._setActiveDescendant();
        }

        this._validateCalendar();
      }
      /** @ignore */

    }, {
      key: "_onPageDownKey",
      value: function _onPageDownKey(event) {
        event.preventDefault();

        this._gotoPreviousOrNextTimeUnit(timeUnit.MONTH, true);

        this._validateCalendar();
      }
      /** @ignore */

    }, {
      key: "_onPageUpKey",
      value: function _onPageUpKey(event) {
        event.preventDefault();

        this._gotoPreviousOrNextTimeUnit(timeUnit.MONTH, false);

        this._validateCalendar();
      }
      /** @ignore */

    }, {
      key: "_onCtrlPageDownKey",
      value: function _onCtrlPageDownKey(event) {
        event.preventDefault();

        this._gotoPreviousOrNextTimeUnit(timeUnit.YEAR, true);

        this._validateCalendar();
      }
      /** @ignore */

    }, {
      key: "_onCtrlPageUpKey",
      value: function _onCtrlPageUpKey(event) {
        event.preventDefault();

        this._gotoPreviousOrNextTimeUnit(timeUnit.YEAR, false);

        this._validateCalendar();
      }
      /**
       sets focus to appropriate descendant
       */

    }, {
      key: "focus",
      value: function focus() {
        var focusedElement = this._elements.body.querySelector('.is-focused');

        if (focusedElement !== document.activeElement && !this.disabled) {
          this._setActiveDescendant();

          this._elements.body.focus();
        }
      }
    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(Calendar.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$C);
        this.setAttribute('role', 'group'); // Default reflected attribute

        if (!this._valueFormat) {
          this.valueFormat = INTERNAL_FORMAT;
        }

        var frag = document.createDocumentFragment(); // Render template

        frag.appendChild(this._elements.input);
        frag.appendChild(this._elements.header);
        frag.appendChild(this._elements.body); /// Clean Up (cloneNode support)

        while (this.firstChild) {
          this.removeChild(this.firstChild);
        }

        this.appendChild(frag); // Render the calendar body if it's empty

        if (!this._elements.body.firstElementChild) {
          this._renderCalendar();
        }
      }
    }, {
      key: "startDay",
      get: function get() {
        if (this._startDay) {
          return this._startDay;
        }

        if (typeof DateTime.Moment.localeData(i18n.locale).firstDayOfWeek !== 'undefined') {
          return DateTime.Moment.localeData(i18n.locale).firstDayOfWeek();
        }

        return 0;
      },
      set: function set(value) {
        if (value >= 0 && value < 7) {
          this._startDay = value;

          this._renderCalendar();
        }
      }
      /**
       The format used to display the current month and year.
       'MMMM YYYY' is supported by default. Include momentjs to support additional format string options see
       http://momentjs.com/docs/#/displaying/.
        @type {String}
       @default "MMMM YYYY"
       @htmlattribute headerformat
       */

    }, {
      key: "headerFormat",
      get: function get() {
        return this._headerFormat || 'MMMM YYYY';
      },
      set: function set(value) {
        this._headerFormat = transform.string(value);

        this._renderCalendar();
      }
      /**
       The minimal selectable date in the Calendar view. When passed a string, it needs to be 'YYYY-MM-DD' formatted.
        @type {String|Date}
       @default null
       @htmlattribute min
       */

    }, {
      key: "min",
      get: function get() {
        return this._min ? this._min.toDate() : null;
      },
      set: function set(value) {
        value = toMoment(value, this.valueFormat);

        if (validateAsChangedAndValidMoment(value, this._min)) {
          this._min = value;

          this._renderCalendar();
        }
      }
      /**
       The max selectable date in the Calendar view. When passed a string, it needs to be 'YYYY-MM-DD'
       formatted.
        @type {String|Date}
       @default null
       @htmlattribute max
       */

    }, {
      key: "max",
      get: function get() {
        return this._max ? this._max.toDate() : null;
      },
      set: function set(value) {
        value = toMoment(value, this.valueFormat);

        if (validateAsChangedAndValidMoment(value, this._max)) {
          this._max = value;

          this._renderCalendar();
        }
      }
      /**
       The format to use on expressing the selected date as a string on the <code>value</code> attribute.
       'YYYY-MM-DD' is supported by default. Include momentjs to support additional format string options see
       http://momentjs.com/docs/#/displaying/.
        @type {String}
       @default "YYYY-MM-DD"
       @htmlattribute valueformat
       @htmlattributereflected
       */

    }, {
      key: "valueFormat",
      get: function get() {
        return this._valueFormat || INTERNAL_FORMAT;
      },
      set: function set(value) {
        var _this5 = this;

        value = transform.string(value);

        var setValueFormat = function setValueFormat(newValue) {
          _this5._valueFormat = newValue;

          _this5._reflectAttribute('valueformat', _this5._valueFormat);
        }; // Once the valueFormat is set, we make sure the value is also correct


        if (!this._valueFormat && this._originalValue) {
          setValueFormat(value);
          this.value = this._originalValue;
        } else {
          setValueFormat(value);
          this._elements.input.value = this.value;
        }
      }
      /**
       The value returned, or set, as a Date. If the value is '' it will return <code>null</code>.
        @type {Date}
       @default null
       */

    }, {
      key: "valueAsDate",
      get: function get() {
        return this._value ? this._value.toDate() : null;
      },
      set: function set(value) {
        if (value instanceof Date) {
          this._valueAsDate = new DateTime.Moment(value);
          this.value = this._valueAsDate;
        } else {
          this._valueAsDate = null;
          this.value = '';
        }
      }
      /**
       The current value. When set to 'today', the value is coerced into the clients local date expressed as string
       formatted in accordance to the set <code>valueFormat</code>.
        @type {String}
       @default ""
       @htmlattribute value
       */

    }, {
      key: "value",
      get: function get() {
        return this._value ? this._value.format(this.valueFormat) : '';
      },
      set: function set(value) {
        // This is used to change the value if valueformat is also set but afterwards
        this._originalValue = value;
        value = toMoment(value, this.valueFormat);

        if (validateAsChangedAndValidMoment(value, this._value)) {
          this._value = value;
          this._elements.input.value = this.value; // resets the view cursor, so the selected month will be in view

          this._cursor = null;

          this._renderCalendar();

          this.required = this.required;
        }
      }
      /**
       Name used to submit the data in a form.
       @type {String}
       @default ""
       @htmlattribute name
       @htmlattributereflected
       */

    }, {
      key: "name",
      get: function get() {
        return this._elements.input.name;
      },
      set: function set(value) {
        this._reflectAttribute('name', value);

        this._elements.input.name = value;
      }
      /**
       Whether this field is required or not.
       @type {Boolean}
       @default false
       @htmlattribute required
       @htmlattributereflected
       */

    }, {
      key: "required",
      get: function get() {
        return this._required || false;
      },
      set: function set(value) {
        this._required = transform.booleanAttr(value);

        this._reflectAttribute('required', this._required);

        this.classList.toggle('is-required', this._required && this._value === null);
      }
      /**
       Whether this field is disabled or not.
       @type {Boolean}
       @default false
       @htmlattribute disabled
       @htmlattributereflected
       */

    }, {
      key: "disabled",
      get: function get() {
        return this._disabled || false;
      },
      set: function set(value) {
        this._disabled = transform.booleanAttr(value);

        this._reflectAttribute('disabled', this._disabled);

        this.classList.toggle('is-disabled', this._disabled);
        this._elements.prev.disabled = this._disabled;
        this._elements.next.disabled = this._disabled;

        this._elements.body[this._disabled ? 'setAttribute' : 'removeAttribute']('aria-disabled', this._disabled);

        this._elements.body[this._disabled ? 'removeAttribute' : 'setAttribute']('tabindex', '0');

        this._renderCalendar();
      }
      /**
       Inherited from {@link BaseFormField#invalid}.
       */

    }, {
      key: "invalid",
      get: function get() {
        return _get(_getPrototypeOf(Calendar.prototype), "invalid", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(Calendar.prototype), "invalid", value, this, true);

        this._renderCalendar();
      }
      /**
       Whether this field is readOnly or not. Indicating that the user cannot modify the value of the control.
       @type {Boolean}
       @default false
       @htmlattribute readonly
       @htmlattributereflected
       */

    }, {
      key: "readOnly",
      get: function get() {
        return this._readOnly || false;
      },
      set: function set(value) {
        this._readOnly = transform.booleanAttr(value);

        this._reflectAttribute('readonly', this._readOnly);

        this._elements.prev.disabled = this._readOnly;
        this._elements.next.disabled = this._readOnly;

        this._elements.body[this._readOnly ? 'removeAttribute' : 'setAttribute']('tabindex', '0');

        this.classList.toggle('is-readOnly', this._readOnly);
      }
    }], [{
      key: "_attributePropertyMap",
      get: function get() {
        return commons.extend(_get(_getPrototypeOf(Calendar), "_attributePropertyMap", this), {
          startday: 'startDay',
          headerformat: 'headerFormat',
          valueformat: 'valueFormat'
        });
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(Calendar), "observedAttributes", this).concat(['startday', 'headerformat', 'min', 'max', 'valueformat']);
      }
    }]);

    return Calendar;
  }(BaseFormField(BaseComponent(HTMLElement)));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons.extend(strings, {
    'coral-component-calendar': translations$b
  }); // Expose component on the Coral namespace

  commons._define('coral-calendar', Calendar);

  var template$m = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["wrapper"] = document.createElement("div");
    el0.setAttribute("handle", "wrapper");
    el0.className += " _coral-Card-wrapper";
    frag.appendChild(el0);
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    return frag;
  };

  var COLOR_HINT_REG_EXP = /^#[0-9A-F]{6}$/i;
  /**
   Enumeration for {@link Card} variants.

   @typedef {Object} CardVariantEnum

   @property {String} DEFAULT
   Default card variant that shows the asset, overlay and content in their default positions.
   @property {String} QUIET
   Quiet card variant that shows the asset, overlay and content in their default positions.
   @property {String} CONDENSED
   Condensed card variant where the overlay is hidden and the content is shown over the image.
   @property {String} INVERTED
   Condensed card variant where the overlay is hidden and the content is shown over the image with a dark style.
   @property {String} ASSET
   Card variant where only the asset is shown.
   */

  var variant$c = {
    DEFAULT: 'default',
    QUIET: 'quiet',
    CONDENSED: 'condensed',
    INVERTED: 'inverted',
    ASSET: 'asset'
  }; // the card's base classname

  var CLASSNAME$D = '_coral-Card'; // builds a string containing all possible variant classnames. this will be used to remove classnames when the variant
  // changes

  var ALL_VARIANT_CLASSES$8 = [];

  for (var variantValue$6 in variant$c) {
    ALL_VARIANT_CLASSES$8.push("".concat(CLASSNAME$D, "--").concat(variant$c[variantValue$6]));
  }
  /**
   @class Coral.Card
   @classdesc A Card component to display content in different variations.
   @htmltag coral-card
   @extends {HTMLElement}
   @extends {BaseComponent}
   */


  var Card = /*#__PURE__*/function (_BaseComponent) {
    _inherits(Card, _BaseComponent);

    var _super = _createSuper(Card);

    /** @ignore */
    function Card() {
      var _this;

      _classCallCheck(this, Card);

      _this = _super.call(this); // Prepare templates

      _this._elements = {
        // Fetch or create the content zone elements
        asset: _this.querySelector('coral-card-asset') || document.createElement('coral-card-asset'),
        content: _this.querySelector('coral-card-content') || document.createElement('coral-card-content'),
        info: _this.querySelector('coral-card-info') || document.createElement('coral-card-info'),
        overlay: _this.querySelector('coral-card-overlay') || document.createElement('coral-card-overlay')
      };
      template$m.call(_this._elements); // Events

      _this._delegateEvents({
        'capture:load coral-card-asset img': '_onLoad'
      });

      return _this;
    }
    /**
     The Asset of the card.
      @type {CardAsset}
     @contentzone
     */


    _createClass(Card, [{
      key: "_onLoad",

      /** @ignore */
      value: function _onLoad(event) {
        // @todo fix me for multiple images
        // sets the image as loaded
        this._loaded = true; // removes the height style since the asset has been completely loaded

        this._elements.asset.style.height = ''; // enables the transition

        event.target.classList.remove('is-loading');
      }
    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(Card.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$D); // Default reflected attributes

        if (!this._variant) {
          this.variant = variant$c.DEFAULT;
        }

        var content = this._elements.content;
        var asset = this._elements.asset; // Prepares images to be loaded nicely

        var images = asset.querySelectorAll('img');
        var imagesCount = images.length;

        for (var i = 0; i < imagesCount; i++) {
          var image = images[i];

          if (!image.complete) {
            image.classList.add('is-loading');
          }
        }

        for (var contentZone in this._contentZones) {
          var element = this._elements[this._contentZones[contentZone]]; // Remove it so we can process children

          if (element.parentNode) {
            element.parentNode.removeChild(element);
          }
        } // Moves everything into the main content zone


        while (this.firstChild) {
          var child = this.firstChild; // Removes the empty spaces

          if (child.nodeType === Node.TEXT_NODE && child.textContent.trim() !== '' || child.nodeType === Node.ELEMENT_NODE && child.getAttribute('handle') !== 'wrapper') {
            // Add non-template elements to the content
            content.appendChild(child);
          } // Remove anything else element
          else {
              this.removeChild(child);
            }
        } // Assign the content zones so the insert functions will be called


        this.overlay = this._elements.overlay;
        this.content = content;
        this.info = this._elements.info;
        this.appendChild(this._elements.wrapper); // The 'asset' setter knows to insert the element just before the wrapper node.

        this.asset = asset; // In case a lot of alerts are added, they will not overflow the card
        // Also check whether any alerts are available

        this.classList.toggle("".concat(CLASSNAME$D, "--overflow"), this.info.childNodes.length && this.info.scrollHeight > this.clientHeight);
      }
    }, {
      key: "asset",
      get: function get() {
        return this._getContentZone(this._elements.asset);
      },
      set: function set(value) {
        this._setContentZone('asset', value, {
          handle: 'asset',
          tagName: 'coral-card-asset',
          insert: function insert(asset) {
            this.insertBefore(asset, this.info || this._elements.wrapper || null);
          }
        });
      }
      /**
       Hints the height of the asset that is going to be loaded. This prepares the size so that when the image is
       loaded no reflow is triggered. Both <code>assetHeight</code> and <code>assetWidth</code> need to be specified
       for this feature to take effect.
        @type {String}
       @default ""
       @htmlattribute assetheight
       */

    }, {
      key: "assetHeight",
      get: function get() {
        return this._assetHeight || '';
      },
      set: function set(value) {
        var _this2 = this;

        this._assetHeight = transform.number(value); // Avoid a forced reflow by executing following in the next frame

        window.requestAnimationFrame(function () {
          // both hint dimensions need to be set in order to use this feature
          if (!_this2._loaded && _this2._elements.asset && _this2.assetWidth && _this2._assetHeight) {
            // gets the width without the border of the card
            var clientRect = _this2.getBoundingClientRect();

            var width = clientRect.right - clientRect.left; // calculates the image ratio used to resize the height

            var ratio = width / _this2.assetWidth; // the image is considered "low resolution"
            // @todo: check this after removal of lowResolution

            if (ratio > 1) {
              // 32 = $card-asset-lowResolution-padding * 2
              _this2._elements.asset.style.height = "".concat(_this2._assetHeight + 32, "px");
            } // for non-low resolution images, condensed and inverted cards do not require the height to be set
            else if (_this2.variant !== variant$c.CONDENSED && _this2.variant !== variant$c.INVERTED) {
                _this2._elements.asset.style.height = "".concat(ratio * _this2._assetHeight, "px");
              }
          }
        });
      }
      /**
       Hints the width of the asset that is going to be loaded. This prepares the size so that when the image is
       loaded no reflow is triggered. Both <code>assetHeight</code> and <code>assetWidth</code> need to be specified
       for this feature to take effect.
        @type {String}
       @default ""
       @htmlattribute assetwidth
       */

    }, {
      key: "assetWidth",
      get: function get() {
        return this._assetWidth || '';
      },
      set: function set(value) {
        this._assetWidth = transform.number(value);
      }
      /**
       @type {String}
       @default ""
       @htmlattribute colorhint
       */

    }, {
      key: "colorHint",
      get: function get() {
        return this._colorHint || '';
      },
      set: function set(value) {
        if (COLOR_HINT_REG_EXP.test(value)) {
          this._colorHint = value; // if the image is already loaded we do not add the color hint to the asset

          if (!this._loaded) {
            this._elements.asset.style['background-color'] = this._colorHint;
          }
        }
      }
      /**
       The Content of the card.
        @type {CardContent}
       @contentzone
       */

    }, {
      key: "content",
      get: function get() {
        return this._getContentZone(this._elements.content);
      },
      set: function set(value) {
        this._setContentZone('content', value, {
          handle: 'content',
          tagName: 'coral-card-content',
          insert: function insert(content) {
            // Ensure title comes first
            var title = content.querySelector('coral-card-title');

            if (title) {
              content.insertBefore(title, content.firstChild);
            }

            this._elements.wrapper.insertBefore(content, this.overlay || null);
          }
        });
      }
      /**
       The information area of the card, which is placed over all the content. It is typically used for alerts.
        @type {CardInfo}
       @contentzone
       */

    }, {
      key: "info",
      get: function get() {
        return this._getContentZone(this._elements.info);
      },
      set: function set(value) {
        this._setContentZone('info', value, {
          handle: 'info',
          tagName: 'coral-card-info',
          insert: function insert(info) {
            this.appendChild(info);
          }
        });
      }
      /**
       Fixes the width of the card. By default cards will take the width of their containers allowing them to interact
       nicely with grids. Whenever they are used standalone fixing the width might be desired.
        @type {Boolean}
       @default false
       @htmlattribute fixedwidth
       @htmlattributereflected
       */

    }, {
      key: "fixedWidth",
      get: function get() {
        return this._fixedWidth || false;
      },
      set: function set(value) {
        this._fixedWidth = transform.booleanAttr(value);

        this._reflectAttribute('fixedwidth', this._fixedWidth);

        this.classList.toggle("".concat(CLASSNAME$D, "--fixedWidth"), this._fixedWidth);
      }
      /**
       The Overlay of the card.
        @type {CardOverlay}
       @contentzone
       */

    }, {
      key: "overlay",
      get: function get() {
        return this._getContentZone(this._elements.overlay);
      },
      set: function set(value) {
        this._setContentZone('overlay', value, {
          handle: 'overlay',
          tagName: 'coral-card-overlay',
          insert: function insert(overlay) {
            this._elements.wrapper.appendChild(overlay);
          }
        });
      }
      /**
       Whether the card is stacked or not. This is used to represent several assets grouped together.
        @type {Boolean}
       @default false
       @htmlattribute stacked
       @htmlattributereflected
       */

    }, {
      key: "stacked",
      get: function get() {
        return this._stacked || false;
      },
      set: function set(value) {
        this._stacked = transform.booleanAttr(value);

        this._reflectAttribute('stacked', this._stacked);

        this.classList.toggle("".concat(CLASSNAME$D, "--stacked"), this._stacked);
      }
      /**
       The card's variant. It determines which sections of the Card and in which position they are shown.
       See {@link CardVariantEnum}.
        @type {String}
       @default CardVariantEnum.DEFAULT
       @htmlattribute variant
       */

    }, {
      key: "variant",
      get: function get() {
        return this._variant || variant$c.DEFAULT;
      },
      set: function set(value) {
        var _this$classList;

        value = transform.string(value).toLowerCase();
        this._variant = validate.enumeration(variant$c)(value) && value || variant$c.DEFAULT;

        this._reflectAttribute('variant', this._variant);

        (_this$classList = this.classList).remove.apply(_this$classList, ALL_VARIANT_CLASSES$8);

        if (this._variant !== variant$c.DEFAULT) {
          this.classList.add("".concat(CLASSNAME$D, "--").concat(this._variant));
        }

        this.assetHeight = this.assetHeight;
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-card-asset': 'asset',
          'coral-card-content': 'content',
          'coral-card-info': 'info',
          'coral-card-overlay': 'overlay'
        };
      }
      /**
       Returns {@link Card} variants.
        @return {CardVariantEnum}
       */

    }], [{
      key: "variant",
      get: function get() {
        return variant$c;
      }
    }, {
      key: "_attributePropertyMap",
      get: function get() {
        return commons.extend(_get(_getPrototypeOf(Card), "_attributePropertyMap", this), {
          assetwidth: 'assetWidth',
          assetheight: 'assetHeight',
          colorhint: 'colorHint',
          fixedwidth: 'fixedWidth'
        });
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(Card), "observedAttributes", this).concat(['assetwidth', 'assetheight', 'colorhint', 'fixedwidth', 'variant', 'stacked']);
      }
    }]);

    return Card;
  }(BaseComponent(HTMLElement));

  var template$n = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["icon"] = document.createElement("coral-icon");
    el0.setAttribute("handle", "icon");
    el0.setAttribute("size", "XS");
    el0.className += " _coral-Card-property-icon";
    el0.setAttribute("autoarialabel", "on");
    frag.appendChild(el0);
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    return frag;
  };

  var CLASSNAME$E = '_coral-Card-property';
  /**
   @class Coral.Card.Property
   @classdesc A Card property component
   @htmltag coral-card-property
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var CardProperty = /*#__PURE__*/function (_BaseComponent) {
    _inherits(CardProperty, _BaseComponent);

    var _super = _createSuper(CardProperty);

    /** @ignore */
    function CardProperty() {
      var _this;

      _classCallCheck(this, CardProperty);

      _this = _super.call(this); // Prepare templates

      _this._elements = {
        content: _this.querySelector('coral-card-property-content') || document.createElement('coral-card-property-content')
      };
      template$n.call(_this._elements);
      return _this;
    }
    /**
     The property's content zone
      @type {CardPropertyContent}
     @contentzone
     */


    _createClass(CardProperty, [{
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(CardProperty.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$E, 'coral-Body--small'); // Create a fragment

        var frag = document.createDocumentFragment(); // Render the main template

        if (this.icon) {
          frag.appendChild(this._elements.icon);
        }

        var content = this._elements.content; // Remove it so we can process children

        if (content.parentNode) {
          content.parentNode.removeChild(content);
        }

        while (this.firstChild) {
          var child = this.firstChild;

          if (child.nodeType === Node.TEXT_NODE || child.nodeType === Node.ELEMENT_NODE && child.getAttribute('handle') !== 'icon') {
            // Add non-template elements to the label
            content.appendChild(child);
          } else {
            this.removeChild(child);
          }
        } // Add the frag to the component


        this.appendChild(frag); // Assign the content zones, moving them into place in the process

        this.content = content;
      }
    }, {
      key: "content",
      get: function get() {
        return this._getContentZone(this._elements.content);
      },
      set: function set(value) {
        this._setContentZone('content', value, {
          handle: 'content',
          tagName: 'coral-card-property-content',
          insert: function insert(content) {
            this.appendChild(content);
          }
        });
      }
      /**
       Specifies the icon name used inside the property. See {@link Icon} for valid icon names.
        @type {String}
       @default ""
       @htmlattribute icon
       */

    }, {
      key: "icon",
      get: function get() {
        return this._elements.icon.icon;
      },
      set: function set(value) {
        this._elements.icon.icon = value; // removes the icon element from the DOM since there is no valid icon. this causes the content to have the
        // correct styling

        if (this.icon === '') {
          this._elements.icon.remove();
        } else if (!this._elements.icon.parentNode) {
          this.insertBefore(this._elements.icon, this.firstChild);
        }
      }
      /**
       Specifies the alternative text to be used for the icon.
        @type {String}
       @default ""
       @htmlattribute iconalt
       */

    }, {
      key: "iconAlt",
      get: function get() {
        return this._elements.icon ? this._elements.icon.getAttribute('alt') : undefined;
      },
      set: function set(value) {
        this._elements.icon && this._elements.icon.setAttribute('alt', value);
      }
      /**
       Specifies the title attribute to be used for the icon.
        @type {String}
       @default ""
       @htmlattribute icontitle
       */

    }, {
      key: "iconTitle",
      get: function get() {
        return this._elements.icon ? this._elements.icon.getAttribute('title') : undefined;
      },
      set: function set(value) {
        this._elements.icon && this._elements.icon.setAttribute('title', value);
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-card-property-content': 'content'
        };
      }
    }], [{
      key: "_attributePropertyMap",
      get: function get() {
        return commons.extend(_get(_getPrototypeOf(CardProperty), "_attributePropertyMap", this), {
          iconalt: 'iconAlt',
          icontitle: 'iconTitle'
        });
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(CardProperty), "observedAttributes", this).concat(['icon', 'iconalt', 'icontitle']);
      }
    }]);

    return CardProperty;
  }(BaseComponent(HTMLElement));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Card.Title
   @classdesc A Card title component
   @htmltag coral-card-title
   @return {HTMLElement}
   */
  var CardTitle = (function () {
    return document.createElement('coral-card-title');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Card.Subtitle
   @classdesc A Card sub title component
   @htmltag coral-card-subtitle
   @return {HTMLElement}
   */
  var CardSubtitle = (function () {
    return document.createElement('coral-card-subtitle');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Card.Context
   @classdesc A Card context component
   @htmltag coral-card-context
   @return {HTMLElement}
   */
  var CardContext = (function () {
    return document.createElement('coral-card-context');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Card.Description
   @classdesc A Card description component
   @htmltag coral-card-description
   @return {HTMLElement}
   */
  var CardDescription = (function () {
    return document.createElement('coral-card-description');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Card.Asset
   @classdesc The Card Asset
   @htmltag coral-card-asset
   @return {HTMLElement}
   */
  var CardAsset = (function () {
    return document.createElement('coral-card-asset');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Card.Overlay
   @classdesc The Card Overlay
   @htmltag coral-card-overlay
   @return {HTMLElement}
   */
  var CardOverlay = (function () {
    return document.createElement('coral-card-overlay');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Card.Info
   @classdesc The Card Info
   @htmltag coral-card-info
   @return {HTMLElement}
   */
  var CardInfo = (function () {
    return document.createElement('coral-card-info');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Card.Content
   @classdesc The Card Content
   @htmltag coral-card-content
   @return {HTMLElement}
   */
  var CardContent = (function () {
    return document.createElement('coral-card-content');
  });

  /**
   @class Coral.Card.PropertyList
   @classdesc The Card PropertyList component
   @htmltag coral-card-propertylist
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var CardPropertyList = /*#__PURE__*/function (_BaseComponent) {
    _inherits(CardPropertyList, _BaseComponent);

    var _super = _createSuper(CardPropertyList);

    function CardPropertyList() {
      _classCallCheck(this, CardPropertyList);

      return _super.apply(this, arguments);
    }

    _createClass(CardPropertyList, [{
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(CardPropertyList.prototype), "render", this).call(this);

        this.classList.add('u-coral-clearFix'); // Empty it if no items

        if (this.innerHTML.trim() === '') {
          this.textContent = '';
        }
      }
    }]);

    return CardPropertyList;
  }(BaseComponent(HTMLElement));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Card.Property.Content
   @classdesc A Card Property Content component
   @htmltag coral-card-property-content
   @return {HTMLElement}
   */
  var CardPropertyContent = (function () {
    return document.createElement('coral-card-property-content');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons._define('coral-card-propertylist', CardPropertyList);

  commons._define('coral-card-property', CardProperty);

  commons._define('coral-card', Card);

  Card.Property = CardProperty;
  Card.Property.Content = CardPropertyContent;
  Card.Title = CardTitle;
  Card.Subtitle = CardSubtitle;
  Card.Context = CardContext;
  Card.Description = CardDescription;
  Card.Asset = CardAsset;
  Card.Overlay = CardOverlay;
  Card.Info = CardInfo;
  Card.Content = CardContent;
  Card.PropertyList = CardPropertyList;

  var CLASSNAME$F = '_coral-CharacterCount';
  /**
   Enumeration for {@link CharacterCount} targets.

   @typedef {Object} CharacterCountTargetEnum

   @property {String} PREVIOUS
   Relates the CharacterCount to the previous sibling.
   @property {String} NEXT
   Relates the CharacterCount to the next sibling.
   */

  var target$1 = {
    PREVIOUS: '_prev',
    NEXT: '_next'
  };
  /**
   @class Coral.CharacterCount
   @classdesc A CharacterCount component that indicates the remaining characters in a Textfield or Textarea.
   @htmltag coral-charactercount
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var CharacterCount = /*#__PURE__*/function (_BaseComponent) {
    _inherits(CharacterCount, _BaseComponent);

    var _super = _createSuper(CharacterCount);

    function CharacterCount() {
      _classCallCheck(this, CharacterCount);

      return _super.apply(this, arguments);
    }

    _createClass(CharacterCount, [{
      key: "_getCharCount",

      /** @ignore */
      value: function _getCharCount() {
        var elementLength = 0;

        if (this._targetEl && this._targetEl.value) {
          elementLength = this._targetEl.value.length;
        }

        return this._maxLength ? this._maxLength - elementLength : elementLength;
      }
      /** @ignore */

    }, {
      key: "_refreshCharCount",
      value: function _refreshCharCount() {
        var currentCount = this._getCharCount();
        /** @ignore */


        this.innerHTML = currentCount;
        var isMaxExceeded = currentCount < 0;

        if (this._targetEl) {
          this._targetEl.classList.toggle('is-invalid', isMaxExceeded);

          this.classList.toggle('is-invalid', isMaxExceeded);
        }
      }
      /**
       Returns {@link CharacterCount} target options.
        @return {CharacterCountTargetEnum}
       */

    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(CharacterCount.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$F, 'coral-Body--S'); // Set defaults

        this.target = this.target; // Refresh once connected

        this._refreshCharCount();
      }
    }, {
      key: "target",

      /**
       The target Textfield or Textarea for this component. It accepts values from {@link CharacterCountTargetEnum},
       as well as any DOM element or CSS selector.
        @type {HTMLElement|String}
       @default CharacterCountTargetEnum.PREVIOUS
       @htmlattribute target
       */
      get: function get() {
        return this._target || target$1.PREVIOUS;
      },
      set: function set(value) {
        if (typeof value === 'string' || value instanceof Node) {
          this._target = value; // Remove previous event listener

          if (this._targetEl) {
            this._targetEl.removeEventListener('input', this._refreshCharCount.bind(this));
          } // Get the target DOM element


          if (value === target$1.NEXT) {
            this._targetEl = this.nextElementSibling;
          } else if (value === target$1.PREVIOUS) {
            this._targetEl = this.previousElementSibling;
          } else if (typeof value === 'string') {
            this._targetEl = document.querySelector(value);
          } else {
            this._targetEl = value;
          }

          if (this._targetEl) {
            this._targetEl.addEventListener('input', this._refreshCharCount.bind(this)); // Try to get maxlength from target element


            if (this._targetEl.getAttribute('maxlength')) {
              this.maxLength = this._targetEl.getAttribute('maxlength');
            }
          }
        }
      }
      /**
       Maximum character length for the TextField/TextArea (will be read from target field markup if able).
        @type {Number}
       @default null
       @htmlattribute maxlength
       @htmlattributereflected
       */

    }, {
      key: "maxLength",
      get: function get() {
        return this._maxLength || null;
      },
      set: function set(value) {
        this._maxLength = transform.number(value);

        this._reflectAttribute('maxlength', this._maxLength);

        this._refreshCharCount();
      }
    }], [{
      key: "target",
      get: function get() {
        return target$1;
      }
    }, {
      key: "_attributePropertyMap",
      get: function get() {
        return commons.extend(_get(_getPrototypeOf(CharacterCount), "_attributePropertyMap", this), {
          maxlength: 'maxLength'
        });
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(CharacterCount), "observedAttributes", this).concat(['target', 'maxlength']);
      }
    }]);

    return CharacterCount;
  }(BaseComponent(HTMLElement));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons._define('coral-charactercount', CharacterCount);

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var translations$c = {
    "en-US": {
      "am": "am",
      "pm": "pm",
      "Hours": "Hours",
      "Minutes": "Minutes",
      "AM/PM": "AM/PM"
    },
    "de-DE": {
      "am": "vormittags",
      "pm": "nachmittags",
      "Hours": "Stunden",
      "Minutes": "Minuten",
      "AM/PM": "AM/PM"
    },
    "fr-FR": {
      "am": "matin",
      "pm": "aprÃ¨s-midi",
      "Hours": "Heures",
      "Minutes": "Minutes",
      "AM/PM": "AM/PM"
    },
    "ja-JP": {
      "am": "åå",
      "pm": "åå¾",
      "Hours": "æé",
      "Minutes": "å",
      "AM/PM": "åå / åå¾"
    },
    "es-ES": {
      "am": "a. m.",
      "pm": "p. m.",
      "Hours": "Horas",
      "Minutes": "Minutos",
      "AM/PM": "a. m./p. m."
    },
    "ko-KR": {
      "am": "ì¤ì ",
      "pm": "ì¤í",
      "Hours": "ìê°",
      "Minutes": "ë¶",
      "AM/PM": "ì¤ì /ì¤í"
    },
    "zh-CN": {
      "am": "ä¸å",
      "pm": "ä¸å",
      "Hours": "å°æ¶",
      "Minutes": "åé",
      "AM/PM": "ä¸å/ä¸å"
    },
    "zh-TW": {
      "am": "ä¸å",
      "pm": "ä¸å",
      "Hours": "å°æ",
      "Minutes": "åé",
      "AM/PM": "ä¸å/ä¸å"
    },
    "pt-BR": {
      "am": "am",
      "pm": "pm",
      "Hours": "Horas",
      "Minutes": "Minutos",
      "AM/PM": "AM/PM"
    },
    "it-IT": {
      "am": "am",
      "pm": "pm",
      "Hours": "Ore",
      "Minutes": "Minuti",
      "AM/PM": "AM/PM"
    },
    "nl-NL": {
      "am": "am",
      "pm": "pm",
      "Hours": "Uren",
      "Minutes": "Minuten",
      "AM/PM": "AM/PM"
    },
    "da-DK": {
      "am": "am",
      "pm": "pm",
      "Hours": "Timer",
      "Minutes": "Minutter",
      "AM/PM": "AM/PM"
    },
    "fi-FI": {
      "am": "ap.",
      "pm": "ip.",
      "Hours": "Tunnit",
      "Minutes": "Minuutit",
      "AM/PM": "ap./ip."
    },
    "nb-NO": {
      "am": "am",
      "pm": "pm",
      "Hours": "Timer",
      "Minutes": "Minutter",
      "AM/PM": "AM/PM"
    },
    "sv-SE": {
      "am": "am",
      "pm": "pm",
      "Hours": "Timmar",
      "Minutes": "Minuter",
      "AM/PM": "AM/PM"
    },
    "cs-CZ": {
      "am": "am",
      "pm": "pm",
      "Hours": "hodin",
      "Minutes": "minut",
      "AM/PM": "AM/PM"
    },
    "pl-PL": {
      "am": "przed poÅudniem",
      "pm": "po poÅudniu",
      "Hours": "Godz.",
      "Minutes": "Min",
      "AM/PM": "Przed poÅudniem / Po poÅudniu"
    },
    "ru-RU": {
      "am": "Ð´Ð¿",
      "pm": "Ð¿Ð¿",
      "Hours": "Ñ.",
      "Minutes": "Ð¼Ð¸Ð½.",
      "AM/PM": "ÐÐ/ÐÐ"
    },
    "tr-TR": {
      "am": "Ã¶Ã¶",
      "pm": "Ã¶s",
      "Hours": "Saat",
      "Minutes": "Dakika",
      "AM/PM": "ÃÃ/ÃS"
    }
  };

  var template$o = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var data = data_0 = typeof data_0 === "undefined" ? {} : data_0;
    data = data_0;
    var labelHourId = data.commons.getUID();
    var labelMinuteId = data.commons.getUID();
    data_0 = data;
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    var el2 = this["input"] = document.createElement("input");
    el2.setAttribute("type", "hidden");
    el2.setAttribute("name", "");
    el2.setAttribute("handle", "input");
    frag.appendChild(el2);
    var el3 = document.createTextNode("\n");
    frag.appendChild(el3);
    var el4 = this["valueAsText"] = document.createElement("time");
    el4.setAttribute("handle", "valueAsText");
    el4.id = data_0["commons"]["getUID"]();
    el4.setAttribute("hidden", "");
    frag.appendChild(el4);
    var el5 = document.createTextNode("\n");
    frag.appendChild(el5);
    var el6 = document.createElement("label");
    el6.setAttribute("for", labelHourId);
    el6.className += " coral-Form-fieldlabel";
    el6.textContent = data_0["i18n"]["get"]('Hours');
    frag.appendChild(el6);
    var el7 = document.createTextNode("\n");
    frag.appendChild(el7);
    var el8 = this["hours"] = document.createElement("input", "coral-textfield");
    el8.setAttribute("is", "coral-textfield");
    el8.id = labelHourId;
    el8.setAttribute("type", "number");
    el8.setAttribute("min", "0");
    el8.setAttribute("max", "23");
    el8.className += " _coral-Clock-hour";
    el8.setAttribute("handle", "hours");
    frag.appendChild(el8);
    var el9 = document.createTextNode("\n");
    frag.appendChild(el9);
    var el10 = this["divider"] = document.createElement("span");
    el10.className += " _coral-Clock-divider";
    el10.setAttribute("handle", "divider");
    el10.textContent = ":";
    frag.appendChild(el10);
    var el11 = document.createTextNode("\n");
    frag.appendChild(el11);
    var el12 = document.createElement("label");
    el12.setAttribute("for", labelMinuteId);
    el12.className += " coral-Form-fieldlabel";
    el12.textContent = data_0["i18n"]["get"]('Minutes');
    frag.appendChild(el12);
    var el13 = document.createTextNode("\n");
    frag.appendChild(el13);
    var el14 = this["minutes"] = document.createElement("input", "coral-textfield");
    el14.setAttribute("is", "coral-textfield");
    el14.id = labelMinuteId;
    el14.setAttribute("type", "number");
    el14.setAttribute("min", "0");
    el14.setAttribute("max", "59");
    el14.className += " _coral-Clock-minute";
    el14.setAttribute("handle", "minutes");
    frag.appendChild(el14);
    var el15 = document.createTextNode("\n");
    frag.appendChild(el15);
    var el16 = this["period"] = document.createElement("coral-select");
    el16.setAttribute("handle", "period");
    el16.className += " _coral-Clock-period";
    el16.setAttribute("hidden", "");
    el16.setAttribute("aria-label", data_0["i18n"]["get"]('AM/PM'));
    var el17 = document.createTextNode("\n  ");
    el16.appendChild(el17);
    var el18 = document.createElement("coral-select-item");
    el18.setAttribute("value", "am");
    el16.appendChild(el18);
    var el19 = document.createTextNode("\n  ");
    el16.appendChild(el19);
    var el20 = document.createElement("coral-select-item");
    el20.setAttribute("value", "pm");
    el16.appendChild(el20);
    var el21 = document.createTextNode("\n");
    el16.appendChild(el21);
    frag.appendChild(el16);
    var el22 = document.createTextNode("\n");
    frag.appendChild(el22);
    return frag;
  };

  var DEFAULT_HOUR_FORMAT = 'HH';
  var DEFAULT_MINUTE_FORMAT = 'mm';
  var DEFAULT_TIME_FORMAT = "".concat(DEFAULT_HOUR_FORMAT, ":").concat(DEFAULT_MINUTE_FORMAT); // Used to extract the time format from a date format

  var AUTHORIZED_TOKENS = '(A|a|H{1,2}|h{1,2}|k{1,2}|m{1,2})';
  var TIME_REG_EXP = new RegExp("".concat(AUTHORIZED_TOKENS, ".*").concat(AUTHORIZED_TOKENS, "|").concat(AUTHORIZED_TOKENS));
  var HOUR_REG_EXP = new RegExp('h{1,2}|H{1,2}|k{1,2}');
  var MIN_REG_EXP = new RegExp('m{1,2}');
  /**
   Enumeration for {@link Clock} variants.

   @typedef {Object} ClockVariantEnum

   @property {String} DEFAULT
   A default, gray Clock.
   @property {String} QUIET
   A Clock with no border or background.
   */

  var variant$d = {
    DEFAULT: 'default',
    QUIET: 'quiet'
  };
  var CLASSNAME$G = '_coral-Clock'; // builds an array containing all possible variant classnames. this will be used to remove classnames when the variant
  // changes

  var ALL_VARIANT_CLASSES$9 = [];

  for (var variantValue$7 in variant$d) {
    ALL_VARIANT_CLASSES$9.push("".concat(CLASSNAME$G, "--").concat(variant$d[variantValue$7]));
  }
  /**
   @class Coral.Clock
   @classdesc A Clock component that can be used as a time selection form field. Leverages {@link momentJS} if loaded
   on the page.
   @htmltag coral-clock
   @extends {HTMLElement}
   @extends {BaseComponent}
   @extends {BaseFormField}
   */


  var Clock = /*#__PURE__*/function (_BaseFormField) {
    _inherits(Clock, _BaseFormField);

    var _super = _createSuper(Clock);

    /** @ignore */
    function Clock() {
      var _this;

      _classCallCheck(this, Clock);

      _this = _super.call(this); // Default value

      _this._value = ''; // Events

      _this._delegateEvents(commons.extend(_this._events, {
        'change [handle="period"]': '_onPeriodChange'
      })); // Prepare templates


      _this._elements = {};
      _this._template = template$o.call(_this._elements, {
        commons: commons,
        i18n: i18n
      }); // Pre-define labellable element

      _this._labellableElement = _assertThisInitialized(_this);
      return _this;
    }
    /**
     The format used to display the selected time to the user. If the user manually types a time, this format
     will be used to parse the value. 'HH:mm' is supported by default. Include momentjs to support additional format
     string options see http://momentjs.com/docs/#/displaying/.
      @type {String}
     @default "HH:mm"
     @htmlattribute displayformat
     @htmlattributereflected
     */


    _createClass(Clock, [{
      key: "_extractTimeFormat",

      /**
       Ignore the date part and use the time part only
        @private
       */
      value: function _extractTimeFormat(format, regExp, defaultFormat) {
        var match = regExp.exec(format);
        return match && match.length && match[0] !== '' ? match[0] : defaultFormat;
      }
      /**
       Sync time display based on the format
        @private
       */

    }, {
      key: "_syncDisplay",
      value: function _syncDisplay() {
        var hourFormat = this._extractTimeFormat(this.displayFormat, HOUR_REG_EXP, DEFAULT_HOUR_FORMAT);

        var minuteFormat = this._extractTimeFormat(this.displayFormat, MIN_REG_EXP, DEFAULT_MINUTE_FORMAT);

        this._elements.hours.placeholder = hourFormat;
        this._elements.minutes.placeholder = minuteFormat;
        this._elements.hours.value = this._getValueAsString(this._value, hourFormat);
        this._elements.minutes.value = this._getValueAsString(this._value, minuteFormat);

        this._syncPeriod();

        this._syncValueAsText();
      }
      /**
       Sync period selector based on the format
        @private
       */

    }, {
      key: "_syncPeriod",
      value: function _syncPeriod() {
        var period = this._elements.period;
        var time = this._value;
        var am = i18n.get('am');
        var pm = i18n.get('pm');
        var items = period.items.getAll();

        if (time && time.isValid()) {
          if (time.hours() < 12) {
            period.value = 'am';
          } else {
            period.value = 'pm';
          }
        } // Check for am/pm


        if (this.displayFormat.indexOf('a') !== -1) {
          items[0].textContent = am;
          items[1].textContent = pm;

          this._togglePeriod(true);
        } else if (this.displayFormat.indexOf('A') !== -1) {
          items[0].textContent = am.toUpperCase();
          items[1].textContent = pm.toUpperCase();

          this._togglePeriod(true);
        } else {
          this._togglePeriod(false);
        }
      }
      /** @private */

    }, {
      key: "_togglePeriod",
      value: function _togglePeriod(show) {
        this.classList.toggle("".concat(CLASSNAME$G, "--extended"), show);
        this._elements.period.hidden = !show;
      }
      /** @private */

    }, {
      key: "_onPeriodChange",
      value: function _onPeriodChange(event) {
        // stops the event from leaving the component
        event.stopImmediatePropagation();
        var time = this._value;
        var period = this._elements.period; // we check if a change event needs to be triggered since it was produced via user interaction

        if (time && time.isValid()) {
          if (this.displayFormat.indexOf('h') !== -1) {
            if (period.value === 'am') {
              time.subtract(12, 'h');
            } else {
              time.add(12, 'h');
            }
          }

          this.value = time.format(this.valueFormat);
          this.trigger('change');
        }
      }
    }, {
      key: "_syncValueAsText",
      value: function _syncValueAsText() {
        this._elements.valueAsText.textContent = this._getValueAsString(this._value, this.displayFormat);

        if (!this.getAttribute('aria-labelledby')) {
          this.labelledBy = this.labelledBy;
        }
      }
      /**
       Kills the internal _onInputChange from BaseFormField because it does not check the target.
        @private
       */

    }, {
      key: "_onInputChange",
      value: function _onInputChange(event) {
        // stops the event from leaving the component
        event.stopImmediatePropagation();
        var newTime = new DateTime.Moment();
        var oldTime = this._value;
        var hours = parseInt(this._elements.hours.value, 10);
        var minutes = parseInt(this._elements.minutes.value, 10);

        if (window.isNaN(hours) || window.isNaN(minutes)) {
          newTime = '';
        } else {
          if (!this._elements.period.hidden && this.displayFormat.indexOf('h') !== -1 && this._elements.period.value === 'pm') {
            hours += 12;
          }

          newTime.hours(hours);
          newTime.minutes(minutes);
        } // we check if a change event needs to be triggered since it was produced via user interaction


        if (newTime && newTime.isValid()) {
          // @polyfill ie
          this.invalid = false;

          if (!newTime.isSame(oldTime, 'hour') || !newTime.isSame(oldTime, 'minute')) {
            this.value = newTime.format(this.valueFormat);
            this.trigger('change');
          }
        } else {
          // @polyfill ie
          this.invalid = true; // does not sync the inputs so allow the user to continue typing the date

          this._value = '';

          if (newTime !== oldTime) {
            this.trigger('change');
          }
        }
      }
      /**
       Helper class that converts the internal moment value into a String using the provided date format. If the value is
       invalid, empty string will be returned.
        @param {?Moment} value
       The value representing the date. It has to be a moment object or <code>null</code>
       @param {String} format
       The Date format to be used.
        @returns {String} a String representing the value in the given format.
        @ignore
       */

    }, {
      key: "_getValueAsString",
      value: function _getValueAsString(value, format) {
        return value && value.isValid() ? value.format(format) : '';
      }
    }, {
      key: "focus",
      value: function focus() {
        // Sets focus to appropriate descendant
        if (!this.contains(document.activeElement)) {
          this._elements.hours.focus();
        }
      }
      /**
       Returns {@link Clock} variants.
        @return {ClockVariantEnum}
       */

    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(Clock.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$G); // a11y

        this.setAttribute('role', 'group'); // Default reflected attributes

        if (!this._variant) {
          this.variant = variant$d.DEFAULT;
        }

        if (!this._valueFormat) {
          this.valueFormat = DEFAULT_TIME_FORMAT;
        }

        if (!this._displayFormat) {
          this.displayFormat = DEFAULT_TIME_FORMAT;
        } // clean up to be able to clone it


        while (this.firstChild) {
          this.removeChild(this.firstChild);
        } // Render template


        this.appendChild(this._template);

        this._syncDisplay();
      }
    }, {
      key: "displayFormat",
      get: function get() {
        return this._displayFormat || DEFAULT_TIME_FORMAT;
      },
      set: function set(value) {
        this._displayFormat = this._extractTimeFormat(transform.string(value).trim(), TIME_REG_EXP, DEFAULT_TIME_FORMAT);

        this._reflectAttribute('displayformat', this._displayFormat);

        this._syncDisplay();
      }
      /**
       The format to use on expressing the time as a string on the <code>value</code> attribute. The value
       will be sent to the server using this format. If an empty string is provided, then the default value per type
       will be used. 'HH:mm' is supported by default. Include momentjs to support additional format string options
       see http://momentjs.com/docs/#/displaying/.
        @type {String}
       @default "HH:mm"
       @htmlattribute valueformat
       @htmlattributereflected
       */

    }, {
      key: "valueFormat",
      get: function get() {
        return this._valueFormat || DEFAULT_TIME_FORMAT;
      },
      set: function set(value) {
        var _this2 = this;

        var setValueFormat = function setValueFormat(newValue) {
          _this2._valueFormat = _this2._extractTimeFormat(transform.string(newValue).trim(), TIME_REG_EXP, DEFAULT_TIME_FORMAT);

          _this2._reflectAttribute('valueformat', _this2._valueFormat);
        }; // Once the valueFormat is set, we make sure the value is also correct


        if (!this._valueFormat && this._originalValue) {
          setValueFormat(value);
          this.value = this._originalValue;
        } else {
          setValueFormat(value);
          this._elements.input.value = this.value;
        }
      }
      /**
       The current value as a Date. If the value is "" or an invalid date, <code>null</code> will be returned.
        @type {Date}
       @default null
       */

    }, {
      key: "valueAsDate",
      get: function get() {
        return this._value ? new Date(this._value.toDate().getTime()) : null;
      },
      set: function set(value) {
        this.value = value instanceof Date ? new DateTime.Moment(value, null, true).format(this.valueFormat) : '';
      }
      /**
       The clock's variant. See {@link ClockVariantEnum}.
        @type {String}
       @default ClockVariantEnum.DEFAULT
       @htmlattribute variant
       @htmlattributereflected
       */

    }, {
      key: "variant",
      get: function get() {
        return this._variant || variant$d.DEFAULT;
      },
      set: function set(value) {
        var _this$classList;

        value = transform.string(value).toLowerCase();
        this._variant = validate.enumeration(variant$d)(value) && value || variant$d.DEFAULT;

        this._reflectAttribute('variant', this._variant); // passes down the variant to the underlying components


        this._elements.hours.variant = this._variant;
        this._elements.minutes.variant = this._variant;
        this._elements.period.variant = this._variant; // removes every existing variant

        (_this$classList = this.classList).remove.apply(_this$classList, ALL_VARIANT_CLASSES$9);

        if (this._variant !== variant$d.DEFAULT) {
          this.classList.add("".concat(CLASSNAME$G, "--").concat(this._variant));
        }
      }
      /**
       Name used to submit the data in a form.
       @type {String}
       @default ""
       @htmlattribute name
       @htmlattributereflected
       */

    }, {
      key: "name",
      get: function get() {
        return this._elements.input.name;
      },
      set: function set(value) {
        this._reflectAttribute('name', value);

        this._elements.input.name = value;
      }
      /**
       Whether this field is disabled or not.
       @type {Boolean}
       @default false
       @htmlattribute disabled
       @htmlattributereflected
       */

    }, {
      key: "disabled",
      get: function get() {
        return this._disabled || false;
      },
      set: function set(value) {
        this._disabled = transform.booleanAttr(value);

        this._reflectAttribute('disabled', this._disabled);

        this[this._disabled ? 'setAttribute' : 'removeAttribute']('aria-disabled', this._disabled);
        this.classList.toggle('is-disabled', this._disabled);
        this._elements.hours.disabled = this._disabled;
        this._elements.minutes.disabled = this._disabled; // stops the form submission

        this._elements.input.disabled = this._disabled;
      }
      /**
       Inherited from {@link BaseFormField#invalid}.
       */

    }, {
      key: "invalid",
      get: function get() {
        return _get(_getPrototypeOf(Clock.prototype), "invalid", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(Clock.prototype), "invalid", value, this, true);

        this._elements.hours.invalid = this._invalid;
        this._elements.minutes.invalid = this._invalid;
      }
      /**
       Whether this field is required or not.
       @type {Boolean}
       @default false
       @htmlattribute required
       @htmlattributereflected
       */

    }, {
      key: "required",
      get: function get() {
        return this._required || false;
      },
      set: function set(value) {
        this._required = transform.booleanAttr(value);

        this._reflectAttribute('required', this._required);

        this._elements.hours.required = this._required;
        this._elements.minutes.required = this._required;
        this._elements.input.required = this._required;
      }
      /**
       Whether this field is readOnly or not. Indicating that the user cannot modify the value of the control.
       @type {Boolean}
       @default false
       @htmlattribute readonly
       @htmlattributereflected
       */

    }, {
      key: "readOnly",
      get: function get() {
        return this._readOnly || false;
      },
      set: function set(value) {
        this._readOnly = transform.booleanAttr(value);

        this._reflectAttribute('readonly', this._readOnly);

        this._elements.hours.readOnly = this._readOnly;
        this._elements.minutes.readOnly = this._readOnly;
        this._elements.input.readOnly = this._readOnly;
      }
      /**
       This field's current value.
       @type {String}
       @default ""
       @htmlattribute value
       */

    }, {
      key: "value",
      get: function get() {
        return this._getValueAsString(this._value, this.valueFormat);
      },
      set: function set(value) {
        value = typeof value === 'string' ? value : ''; // This is used to change the value if valueformat is also set but afterwards

        this._originalValue = value; // we do strict conversion of the values

        var time = new DateTime.Moment(value, this.valueFormat, true);
        this._value = time.isValid() ? time : '';
        this._elements.input.value = this.value;

        this._syncValueAsText();

        this._syncDisplay();
      }
      /**
       Inherited from {@link BaseFormField#labelledBy}.
       */

    }, {
      key: "labelledBy",
      get: function get() {
        // Get current aria-labelledby attribute on the labellable element.
        var labelledBy = this.getAttribute('aria-labelledby'); // If a labelledBy attribute has been defined,

        if (labelledBy) {
          // and strip the valueAsText element id from the end of the aria-labelledby string.
          labelledBy = labelledBy.replace(this._elements.valueAsText.id, '').trim(); // If the resulting labelledBy string is empty, return null.

          if (!labelledBy.length) {
            labelledBy = null;
          }
        }

        return labelledBy;
      },
      set: function set(value) {
        _set(_getPrototypeOf(Clock.prototype), "labelledBy", value, this, true); // The specified labelledBy property.


        var labelledBy = this.labelledBy; // An array of element ids to label control, the last being the valueAsText element id.

        var ids = [this._elements.valueAsText.id]; // If a labelledBy property exists,

        if (labelledBy) {
          // prepend the labelledBy value to the ids array
          ids.unshift(labelledBy); // Set aria-labelledby attribute on the labellable element joining ids array into space-delimited list of ids.

          this.setAttribute('aria-labelledby', ids.join(' '));
        } else {
          // labelledBy property is null, remove the aria-labelledby attribute.
          this.removeAttribute('aria-labelledby');
        }
      }
    }], [{
      key: "variant",
      get: function get() {
        return variant$d;
      }
    }, {
      key: "_attributePropertyMap",
      get: function get() {
        return commons.extend(_get(_getPrototypeOf(Clock), "_attributePropertyMap", this), {
          displayformat: 'displayFormat',
          valueformat: 'valueFormat'
        });
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(Clock), "observedAttributes", this).concat(['displayformat', 'valueformat', 'variant']);
      }
    }]);

    return Clock;
  }(BaseFormField(BaseComponent(HTMLElement)));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons.extend(strings, {
    'coral-component-clock': translations$c
  }); // Expose component on the Coral namespace

  commons._define('coral-clock', Clock);

  var template$p = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = document.createElement("div");
    el0.className += " _coral-CoachMarkIndicator-ring";
    frag.appendChild(el0);
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    var el2 = document.createElement("div");
    el2.className += " _coral-CoachMarkIndicator-ring";
    frag.appendChild(el2);
    var el3 = document.createTextNode("\n");
    frag.appendChild(el3);
    var el4 = document.createElement("div");
    el4.className += " _coral-CoachMarkIndicator-ring";
    frag.appendChild(el4);
    var el5 = document.createTextNode("\n");
    frag.appendChild(el5);
    return frag;
  };

  /**
   Enumeration for {@link CoachMark} sizes.

   @typedef {Object} CoachMarkSizeEnum

   @property {String} SMALL
   A small sized coach mark.
   @property {String} MEDIUM
   A default sized coach mark.
   */

  var size$5 = {
    SMALL: 'S',
    MEDIUM: 'M'
  };
  /**
   Enumeration for {@link CoachMark} variants.

   @typedef {Object} CoachMarkVariantEnum

   @property {String} DEFAULT
   The default styled coach mark.
   @property {String} LIGHT
   A styled coach mark for dark backgrounds.
   @property {String} DARK
   A styled coach mark for light backgrounds.
   */

  var variant$e = {
    DEFAULT: 'default',
    LIGHT: 'light',
    DARK: 'dark'
  };
  var CLASSNAME$H = '_coral-CoachMarkIndicator';
  /**
   @class Coral.CoachMark
   @classdesc A coach mark component to highlight UI elements on the page.
   @htmltag coral-coachmark
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var CoachMark = /*#__PURE__*/function (_BaseComponent) {
    _inherits(CoachMark, _BaseComponent);

    var _super = _createSuper(CoachMark);

    /** @ignore */
    function CoachMark() {
      var _this;

      _classCallCheck(this, CoachMark);

      _this = _super.call(this); // Templates

      _this._elements = {};
      _this._template = template$p.call(_this._elements);
      return _this;
    }
    /**
     The element the coach mark should position relative to. It accepts values from {@link OverlayTargetEnum}, as
     well as a DOM element or a CSS selector. If a CSS selector is provided, the first matching element will be used.
      @type {?HTMLElement|String}
     @default null
     */


    _createClass(CoachMark, [{
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(CoachMark.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$H); // Default reflected attributes

        if (!this._size) {
          this.size = size$5.MEDIUM;
        }

        if (!this._variant) {
          this.variant = variant$e.DEFAULT;
        } // Support cloneNode


        var template = this.getElementsByClassName('_coral-CoachMarkIndicator-ring');

        while (template.length) {
          template[0].remove();
        } // Render template


        this.appendChild(this._template);
      }
    }, {
      key: "target",
      get: function get() {
        return this._target || null;
      },
      set: function set(value) {
        var _this2 = this;

        // We don't want to validate that the value must change here
        // If a selector is provided, we'll take the first element matching that selector
        // If the DOM is modified and the user wants a new target with the same selector,
        // They should be able to set target = 'selector' again and get a different element
        if (value === null || typeof value === 'string' || value instanceof Node) {
          this._target = value;
          requestAnimationFrame(function () {
            var targetElement = Overlay._getTarget(_this2);

            if (targetElement) {
              // Initialize popper only if we have a target
              _this2._popper = _this2._popper || new Popper(targetElement, _this2); // Update target only if valid

              if (targetElement) {
                _this2._popper.reference = targetElement;
              }

              _this2._popper.options.placement = 'top';

              _this2._popper.modifiers.forEach(function (modifier) {
                if (modifier.name === 'offset') {
                  var lengthOffset = targetElement.clientHeight / 2 + _this2.clientHeight / 2;
                  modifier.offset = "0, -".concat(lengthOffset);
                } else if (modifier.name === 'preventOverflow') {
                  modifier.padding = 0;
                }
              });

              _this2._popper.update();
            }
          });
        }
      }
      /**
       The coach mark size. See {@link CoachMarkSizeEnum}.
        @type {String}
       @default CoachMarkSizeEnum.MEDIUM
       @htmlattribute size
       @htmlattributereflected
       */

    }, {
      key: "size",
      get: function get() {
        return this._size || size$5.MEDIUM;
      },
      set: function set(value) {
        value = transform.string(value).toUpperCase();
        this._size = validate.enumeration(size$5)(value) && value || size$5.MEDIUM;

        this._reflectAttribute('size', this._size);

        this.classList.toggle("".concat(CLASSNAME$H, "--quiet"), this._size === size$5.SMALL);
      }
      /**
       The coach mark variant. See {@link CoachMarkVariantEnum}.
        @type {String}
       @default CoachMarkVariantEnum.DEFAULT
       @htmlattribute variant
       @htmlattributereflected
       */

    }, {
      key: "variant",
      get: function get() {
        return this._variant || variant$e.DEFAULT;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        this._variant = validate.enumeration(variant$e)(value) && value || variant$e.DEFAULT;

        this._reflectAttribute('variant', this._variant);

        this.classList.toggle("".concat(CLASSNAME$H, "--light"), this._variant === variant$e.LIGHT);
        this.classList.toggle("".concat(CLASSNAME$H, "--dark"), this._variant === variant$e.DARK);
      }
      /**
       Returns {@link CoachMark} sizes options.
        @return {CoachMarkSizeEnum}
       */

    }], [{
      key: "size",
      get: function get() {
        return size$5;
      }
      /**
       Returns {@link CoachMark} variant options.
        @return {CoachMarkVariantEnum}
       */

    }, {
      key: "variant",
      get: function get() {
        return variant$e;
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(CoachMark), "observedAttributes", this).concat(['size', 'variant', 'target']);
      }
    }]);

    return CoachMark;
  }(BaseComponent(HTMLElement));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons._define('coral-coachmark', CoachMark);

  /** @ignore */

  var colorSpace = {
    RGB: 'rgb',
    HEX: 'hex',
    CMYK: 'cmyk',
    HSB: 'hsb',
    HSL: 'hsl'
  };
  /**
   Transforms part of a color (r,g,b) into a hex value.

   @static
   @param {Number} x
   value between 0-255

   @return {String} Hex representation
   @ignore
   */

  function _hex(x) {
    return "0".concat(x.toString(16)).slice(-2);
  }
  /** @ignore */


  function _slice(str, startStr) {
    var sliced = [];
    str = transform.string(str).toLowerCase();
    startStr = transform.string(startStr).toLowerCase();

    if (str.indexOf(startStr) !== -1) {
      sliced = str.substring(str.indexOf(startStr) + startStr.length, str.lastIndexOf(')')).split(/,\s*/);
    }

    return sliced;
  }
  /**
   Parse an rgb value into an object.
   e.g.: 'rgb(0,0,0)' => {r:0, g:0, b:0}

   @static
   @param {String} rgbStr
   The string representing the rgb value

   @return {Object} {r, g, b} Returns null if string could not be parsed
   @ignore
   */


  function _parseRGB(rgbStr) {
    var sliced = _slice(rgbStr, 'rgb(');

    if (sliced.length !== 3) {
      return null;
    }

    var r = parseInt(sliced[0], 10);
    var g = parseInt(sliced[1], 10);
    var b = parseInt(sliced[2], 10);

    if (isNaN(r) || isNaN(g) || isNaN(b)) {
      return null;
    }

    if (r < 0 || r > 255 || g < 0 || g > 255 || b < 0 || b > 255) {
      return null;
    }

    return {
      r: r,
      g: g,
      b: b
    };
  }
  /**
   Serialize an rgb object into a string.
   e.g.: {r:0, g:0, b:0} => 'rgb(0,0,0)'

   @static
   @param {Object} rgb
   @return {String} rgbStr The string representing the rgb value
   @ignore
   */


  function _serializeRGB(rgb) {
    if (rgb) {
      return "rgb(".concat(rgb.r, ",").concat(rgb.g, ",").concat(rgb.b, ")");
    }

    return '';
  }
  /**
   Parse an rgba value into an object.
   e.g.: 'rgba(0,0,0,0.5)' => {r:0, g:0, b:0, a:0.5}

   @static
   @param {String} rgbaStr
   The string representing the rgba value.

   @return {Object} {r, g, b, a} Returns null if string could not be parsed
   @ignore
   */


  function _parseRGBA(rgbaStr) {
    var sliced = _slice(rgbaStr, 'rgba(');

    if (sliced.length !== 4) {
      return null;
    }

    var r = parseInt(sliced[0], 10);
    var g = parseInt(sliced[1], 10);
    var b = parseInt(sliced[2], 10);
    var a = parseFloat(sliced[3]);

    if (isNaN(r) || isNaN(g) || isNaN(b) || isNaN(a)) {
      return null;
    }

    if (r < 0 || r > 255 || g < 0 || g > 255 || b < 0 || b > 255 || a < 0 || a > 1) {
      return null;
    }

    return {
      r: r,
      g: g,
      b: b,
      a: a
    };
  }
  /**
   Serialize an rgba object into a string.
   e.g.: {r:0, g:0, b:0, a:0.5} => 'rgb(0,0,0,0.5)'

   @static
   @param {Object} rgba
   @return {String} rgbaStr The string representing the rgba value
   @ignore
   */


  function _serializeRGBA(rgba) {
    if (rgba) {
      return "rgba(".concat(rgba.r, ",").concat(rgba.g, ",").concat(rgba.b, ",").concat(rgba.a, ")");
    }

    return '';
  }
  /**
   Parse an cmyk value into an object.
   e.g.: 'cmyk(0, 100, 50, 0)' => {c:0, m:100, y:50, k:0}

   @static
   @param {String} cmykStr
   The string representing the cmyk value.

   @return {Object} {c, m, y, k} Returns null if string could not be parsed
   @ignore
   */


  function _parseCMYK(cmykStr) {
    var sliced = _slice(cmykStr, 'cmyk(');

    if (sliced.length !== 4) {
      return null;
    }

    var c = parseFloat(sliced[0]);
    var m = parseFloat(sliced[1]);
    var y = parseFloat(sliced[2]);
    var k = parseFloat(sliced[3]);

    if (isNaN(c) || isNaN(m) || isNaN(y) || isNaN(k)) {
      return null;
    }

    if (c < 0 || c > 100 || m < 0 || m > 100 || y < 0 || y > 100 || k < 0 || k > 100) {
      return null;
    }

    return {
      c: c,
      m: m,
      y: y,
      k: k
    };
  }
  /**
   Serialize an cmyk object into a string.
   e.g.: {c:0, m:100, y:50, k:0} => 'cmyk(0, 100, 50, 0)'

   @static
   @param {Object} cmyk
   @return {String} cmykStr The string representing the cmyk value
   @ignore
   */


  function _serializeCMYK(cmyk) {
    if (cmyk) {
      // make sure there are not more than 2 digits after dot
      var c = parseFloat(cmyk.c.toFixed(2));
      var m = parseFloat(cmyk.m.toFixed(2));
      var y = parseFloat(cmyk.y.toFixed(2));
      var k = parseFloat(cmyk.k.toFixed(2));
      return "cmyk(".concat(c, ",").concat(m, ",").concat(y, ",").concat(k, ")");
    }

    return '';
  }
  /**
   Parse an hex value into a number. Corrects a hex value, if it is represented by 3 or 6 characters with or without
   '#'.

   @static
   @param {String} hexStr The string representing the hex value
   @return {Number} Returns a number representing the parsed hex value
   @ignore
   */


  function _parseHex(hexStr) {
    hexStr = transform.string(hexStr).replace('#', '');

    if (hexStr.length === 3) {
      hexStr = hexStr.charAt(0) + hexStr.charAt(0) + hexStr.charAt(1) + hexStr.charAt(1) + hexStr.charAt(2) + hexStr.charAt(2);
    } // test if this could be a hex value


    var isOk = /^[0-9A-F]{6}$/i.test(hexStr);

    if (!isOk) {
      return null;
    }

    return parseInt(hexStr, 16);
  }
  /**
   Transforms a hex color into RGB representation.

   @static
   @param {Number} hex
   The color hex representation.

   @return {Object} {r, g, b}
   @ignore
   */


  function _hexToRgb(hex) {
    // explicitly test null (0 is valid)
    if (hex !== null) {
      return {
        r: hex >> 16,
        // eslint-disable-next-line no-extra-parens
        g: (hex & 0x00FF00) >> 8,
        // eslint-disable-next-line no-extra-parens
        b: hex & 0x0000FF
      };
    }

    return null;
  }
  /**
   Serialize a hex number into a string.

   @static
   @param {Number} hex
   @return {String}
   @ignore
   */


  function _serializeHex(hex) {
    // explicitly test null (0 is valid)
    if (hex !== null) {
      var rgb = _hexToRgb(hex);

      return "#".concat(_hex(rgb.r) + _hex(rgb.g) + _hex(rgb.b));
    }

    return '';
  }
  /**
   Transforms a RGB color into HEX representation.

   @static
   @param {Object} rgb
   @return {Number} hex The color hex representation
   @ignore
   */


  function _rgbToHex(rgb) {
    if (rgb) {
      return _parseHex(_hex(rgb.r) + _hex(rgb.g) + _hex(rgb.b));
    }

    return null;
  }
  /**
   Transforms a cmyk color into RGB representation. Converting CMYK to RGB will incur slight loss because both color
   spaces are not absolute and there will be some round-off error in the conversion process.

   @static
   @param {Object} cmyk
   @return {Object} {r, g, b}
   @ignore
   */


  function _cmykToRgb(cmyk) {
    if (!cmyk) {
      return null;
    }

    var result = {
      r: 0,
      g: 0,
      b: 0
    };
    var c = parseFloat(cmyk.c) / 100;
    var m = parseFloat(cmyk.m) / 100;
    var y = parseFloat(cmyk.y) / 100;
    var k = parseFloat(cmyk.k) / 100;
    result.r = 1 - Math.min(1, c * (1 - k) + k);
    result.g = 1 - Math.min(1, m * (1 - k) + k);
    result.b = 1 - Math.min(1, y * (1 - k) + k);
    result.r = Math.round(result.r * 255);
    result.g = Math.round(result.g * 255);
    result.b = Math.round(result.b * 255);
    return result;
  }
  /**
   Transforms a rgb color into cmyk representation. Converting CMYK to RGB will incur slight loss because both color
   spaces are not absolute and there will be some round-off error in the conversion process.

   @static
   @param {Object} rgb
   @return {Object} {c, m, y, k}
   @ignore
   */


  function _rgbToCmyk(rgb) {
    if (!rgb) {
      return null;
    }

    var result = {
      c: 0,
      m: 0,
      y: 0,
      k: 0
    };

    if (rgb.r === 0 && rgb.g === 0 && rgb.b === 0) {
      result.k = 100;
      return result;
    }

    var r = rgb.r / 255;
    var g = rgb.g / 255;
    var b = rgb.b / 255;
    result.k = Math.min(1 - r, 1 - g, 1 - b);
    result.c = (1 - r - result.k) / (1 - result.k);
    result.m = (1 - g - result.k) / (1 - result.k);
    result.y = (1 - b - result.k) / (1 - result.k);
    result.c = Math.round(result.c * 100);
    result.m = Math.round(result.m * 100);
    result.y = Math.round(result.y * 100);
    result.k = Math.round(result.k * 100);
    return result;
  }
  /**
   Parse an hsb value into an object.
   e.g.: 'hsb(360,100,0)' => {h:360, s:100, b:0}

   @static
   @param {String} hsbStr
   The string representing the hsb value.

   @return {Object} {h, s, b} Returns null if string could not be parsed
   @ignore
   */


  function _parseHSB(hsbStr) {
    var sliced = _slice(hsbStr, 'hsb(');

    if (sliced.length !== 3) {
      return null;
    } // make sure there are not more than 2 digits after dot


    var h = parseFloat(sliced[0]);
    var s = parseFloat(sliced[1]);
    var b = parseFloat(sliced[2]);

    if (isNaN(h) || isNaN(s) || isNaN(b)) {
      return null;
    }

    if (h < 0 || h > 360 || s < 0 || s > 100 || b < 0 || b > 100) {
      return null;
    }

    return {
      h: h,
      s: s,
      b: b
    };
  }
  /**
   Serialize an hsb object into a string.
   e.g.: {h:0, s:0, b:0} => 'hsb(0,0,0)'

   @static
   @param {Object} hsb
   @return {String} hsb The string representing the hsb value
   @ignore
   */


  function _serializeHSB(hsb) {
    if (hsb) {
      // make sure there are not more than 2 digits after dot
      var h = parseFloat(hsb.h.toFixed(2));
      var s = parseFloat(hsb.s.toFixed(2));
      var b = parseFloat(hsb.b.toFixed(2));
      return "hsb(".concat(h, ",").concat(s, ",").concat(b, ")");
    }

    return '';
  }
  /**
   Transforms a HSB (same as HSV) color into RGB representation.
   h (hue has value between 0-360 degree)
   s (saturation has a value between 0-100 percent)
   b (brightness has a value between 0-100 percent)

   @static
   @param {Object} hsb
   @return {Object} {r, g, b}
   @ignore
   */


  function _hsbToRgb(hsb) {
    if (!hsb) {
      return null;
    }

    var h = hsb.h / 360;
    var s = hsb.s / 100;
    var v = hsb.b / 100;
    var r, g, b;
    var i = Math.floor(h * 6);
    var f = h * 6 - i;
    var p = v * (1 - s);
    var q = v * (1 - f * s);
    var t = v * (1 - (1 - f) * s);

    switch (i % 6) {
      case 0:
        r = v;
        g = t;
        b = p;
        break;

      case 1:
        r = q;
        g = v;
        b = p;
        break;

      case 2:
        r = p;
        g = v;
        b = t;
        break;

      case 3:
        r = p;
        g = q;
        b = v;
        break;

      case 4:
        r = t;
        g = p;
        b = v;
        break;

      case 5:
        r = v;
        g = p;
        b = q;
        break;
    }

    return {
      r: Math.round(r * 255),
      g: Math.round(g * 255),
      b: Math.round(b * 255)
    };
  }
  /**
   Transforms a RGB color into HSB (same as HSV) representation.

   @static
   @param {Object} rgb
   @return {Object} {h, s, b}
   @ignore
   */


  function _rgbToHsb(rgb) {
    if (!rgb) {
      return null;
    }

    var r = rgb.r;
    var g = rgb.g;
    var b = rgb.b;
    var max = Math.max(r, g, b);
    var min = Math.min(r, g, b);
    var d = max - min;
    var h;
    var s = max === 0 ? 0 : d / max;
    var v = max / 255;

    switch (max) {
      case min:
        h = 0;
        break;

      case r:
        h = g - b + d * (g < b ? 6 : 0);
        h /= 6 * d;
        break;

      case g:
        h = b - r + d * 2;
        h /= 6 * d;
        break;

      case b:
        h = r - g + d * 4;
        h /= 6 * d;
        break;
    }

    return {
      h: h * 360,
      s: s * 100,
      b: v * 100
    };
  }
  /**
   Parse an hsl value into an object.
   e.g.: 'hsl(360,100,0)' => {h:360, s:100, b:0}

   @static
   @param {String} hslStr
   The string representing the hsl value.

   @return {Object} {h, s, l} Returns null if string could not be parsed
   @ignore
   */


  function _parseHSL(hslStr) {
    var sliced = _slice(hslStr, 'hsl(');

    if (sliced.length !== 3) {
      return null;
    } // make sure there are not more than 2 digits after dot


    var h = parseFloat(sliced[0]);
    var s = parseFloat(sliced[1]);
    var l = parseFloat(sliced[2]);

    if (isNaN(h) || isNaN(s) || isNaN(l)) {
      return null;
    }

    if (h < 0 || h > 360 || s < 0 || s > 100 || l < 0 || l > 100) {
      return null;
    }

    return {
      h: h,
      s: s,
      l: l
    };
  }
  /**
   Serialize an hsl object into a string.
   e.g.: {h:0, s:0, l:0} => 'hsl(0,0%,0%)'

   @static
   @param {Object} hsl
   @return {String} hsb The string representing the hsb value
   @ignore
   */


  function _serializeHSL(hsl) {
    if (hsl) {
      // make sure there are not more than 2 digits after dot
      var h = parseFloat(hsl.h.toFixed(2));
      var s = parseFloat(hsl.s.toFixed(2));
      var l = parseFloat(hsl.l.toFixed(2));
      return "hsl(".concat(h, ",").concat(s, "%,").concat(l, "%)");
    }

    return '';
  }
  /**
   Transforms a HSL color into RGB representation.
   h (hue has value between 0-360 degree)
   s (saturation has a value between 0-100 percent)
   l (lightness has a value between 0-100 percent)

   @static
   @param {Object} hsl
   @return {Object} {r, g, b}
   @ignore
   */


  function _hslToRgb(hsl) {
    if (!hsl) {
      return null;
    }

    var h = hsl.h / 360;
    var s = hsl.s / 100;
    var l = hsl.l / 100;
    var r;
    var g;
    var b;

    if (s === 0) {
      // achromatic
      r = g = b = l;
    } else {
      var hue2rgb = function hue2rgb(p, q, t) {
        if (t < 0) {
          t += 1;
        }

        if (t > 1) {
          t -= 1;
        }

        if (t < 1 / 6) {
          return p + (q - p) * 6 * t;
        }

        if (t < 1 / 2) {
          return q;
        }

        if (t < 2 / 3) {
          return p + (q - p) * (2 / 3 - t) * 6;
        }

        return p;
      };

      var qValue = l < 0.5 ? l * (1 + s) : l + s - l * s;
      var pValue = 2 * l - qValue;
      r = hue2rgb(pValue, qValue, h + 1 / 3);
      g = hue2rgb(pValue, qValue, h);
      b = hue2rgb(pValue, qValue, h - 1 / 3);
    }

    return {
      r: Math.round(r * 255),
      g: Math.round(g * 255),
      b: Math.round(b * 255)
    };
  }
  /**
   Transforms an RGB color into HSL representation.

   @static
   @param {Object} rgb
   @return {Object} {h, s, l}
   @ignore
   */


  function _rgbToHsl(rgb) {
    if (!rgb) {
      return null;
    }

    var r = rgb.r / 255;
    var g = rgb.g / 255;
    var b = rgb.b / 255;
    var max = Math.max(r, g, b);
    var min = Math.min(r, g, b);
    var h;
    var s;
    var l = (max + min) / 2;

    if (max === min) {
      // achromatic
      h = s = 0;
    } else {
      var d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

      switch (max) {
        case r:
          h = (g - b) / d + (g < b ? 6 : 0);
          break;

        case g:
          h = (b - r) / d + 2;
          break;

        case b:
          h = (r - g) / d + 4;
          break;
      }

      h /= 6;
    }

    return {
      h: h * 360,
      s: s * 100,
      l: l * 100
    };
  }
  /**
   Parse an hsla value into an object.
   e.g.: 'hsla(360,100%,0%,0.5)' => {h:360, s:100, l:0, 0.5}

   @static
   @param {String} hslaStr
   The string representing the hsl value.

   @return {Object} {h, s, l, a} Returns null if string could not be parsed
   @ignore
   */


  function _parseHSLA(hslaStr) {
    var sliced = _slice(hslaStr, 'hsla(');

    if (sliced.length !== 4) {
      return null;
    } // make sure there are not more than 2 digits after dot


    var h = parseFloat(sliced[0]);
    var s = parseFloat(sliced[1]);
    var l = parseFloat(sliced[2]);
    var a = parseFloat(sliced[3]);

    if (isNaN(h) || isNaN(s) || isNaN(l)) {
      return null;
    }

    if (h < 0 || h > 360 || s < 0 || s > 100 || l < 0 || l > 100 || a < 0 || a > 1) {
      return null;
    }

    return {
      h: h,
      s: s,
      l: l,
      a: a
    };
  }
  /**
   Serialize an hsla object into a string.
   e.g.: {h:0, s:0, l:0, a:0.5} => 'hsl(0,0%,0%,0.5)'

   @static
   @param {Object} hsla
   @return {String} hsb The string representing the hsb value
   @ignore
   */


  function _serializeHSLA(hsla) {
    if (hsla) {
      // make sure there are not more than 2 digits after dot
      var h = parseFloat(hsla.h.toFixed(2));
      var s = parseFloat(hsla.s.toFixed(2));
      var l = parseFloat(hsla.l.toFixed(2));
      var a = parseFloat(hsla.a.toFixed(2));
      return "hsla(".concat(h, ",").concat(s, "%,").concat(l, "%,").concat(a, ")");
    }

    return '';
  }
  /**
   Color is used to get a color in different color spaces, calculate tints and shades etc.
   */


  var Color = /*#__PURE__*/function () {
    /** @ignore */
    function Color() {
      _classCallCheck(this, Color);

      // Set defaults
      this._colorSpace = colorSpace.HEX;
      this._value = '';
      this._alpha = 1;
    }
    /**
     The value of the color. This value can be set in different formats (HEX, RGB, RGBA, HSB, HSL, HSLA and CMYK).
     Corrects a hex value, if it is represented by 3 or 6 characters with or without '#'.
      e.g:
     HEX:  #FFFFFF
     RGB:  rgb(16,16,16)
     RGBA: rgba(215,40,40,0.9)
     HSB:  hsb(360,100,100)
     HSL:  hsl(360,100%,100%)
     HSLA: hsla(360,100%,100%,0.9)
     CMYK: cmyk(0,100,50,0)
      @type {String}
     @default ""
     */


    _createClass(Color, [{
      key: "clone",

      /**
       Clone this color.
        @type {Color}
       */
      value: function clone() {
        var clone = new this.constructor();
        clone.value = this.value;
        clone.alpha = this.alpha;
        return clone;
      }
      /**
       Test if this Color is similar to another color.
        @type {Boolean}
       @param {Color} compareColor
       The color to compare this color too.
        @param {Boolean} [allowSlightColorDifference=true]
       While converting between color spaces slight loses might happen => we should normally consider colors equal,
       even if they are minimally different.
        */

    }, {
      key: "isSimilarTo",
      value: function isSimilarTo(compareColor, allowSlightColorDifference) {
        if (this.rgb === null && (!compareColor || compareColor.rgb === null)) {
          // Consider an rgb of null equal to a null object (or another value of null)
          return true;
        }

        if (!compareColor || compareColor.rgb === null || this.rgb === null) {
          return false;
        }

        var allowedRgbDifference = 1;
        var allowedAlphaDifference = 0.01;

        if (allowSlightColorDifference === false) {
          allowedRgbDifference = 0;
          allowedAlphaDifference = 0;
        }

        var rgb = this.rgb;
        var rgb2 = compareColor.rgb;
        var rDiff = Math.abs(rgb2.r - rgb.r);
        var gDiff = Math.abs(rgb2.g - rgb.g);
        var bDiff = Math.abs(rgb2.b - rgb.b);
        var aDiff = Math.abs(this.alpha - compareColor.alpha);

        if (rDiff <= allowedRgbDifference && gDiff <= allowedRgbDifference && bDiff <= allowedRgbDifference && aDiff <= allowedAlphaDifference) {
          return true;
        }

        return false;
      }
      /**
       Calculates an array of lighter colors.
        @type {Array<Coral.Color>}
       @param {Number} amount
       Amount of tint colors to generate.
        */

    }, {
      key: "calculateTintColors",
      value: function calculateTintColors(amount) {
        var tintColors = [];
        var tintColor = null;
        var rgb = this.rgb;

        if (rgb) {
          var r = rgb.r;
          var g = rgb.g;
          var b = rgb.b;
          var tintFactor = 1;

          for (var i = 1; i <= amount; i++) {
            tintFactor = i / (amount + 1);
            tintColor = this.clone(); // alpha value kept from original

            tintColor.rgb = {
              r: r + (255 - r) * tintFactor,
              g: g + (255 - g) * tintFactor,
              b: b + (255 - b) * tintFactor
            };
            tintColors.push(tintColor);
          }
        }

        return tintColors;
      }
      /**
       Calculates an array of darker colors.
        @type {Array<Coral.Color>}
       @param {Number} amount
       Amount of shade colors to generate.
        */

    }, {
      key: "calculateShadeColors",
      value: function calculateShadeColors(amount) {
        var shadeColors = [];
        var shadeColor = null;
        var rgb = this.rgb;

        if (rgb) {
          var r = rgb.r;
          var g = rgb.g;
          var b = rgb.b;
          var shadeFactor = 1;

          for (var i = 1; i <= amount; i++) {
            shadeFactor = i / (amount + 1);
            shadeColor = this.clone(); // alpha value kept from original

            shadeColor.rgb = {
              r: r * (1 - shadeFactor),
              g: g * (1 - shadeFactor),
              b: b * (1 - shadeFactor)
            };
            shadeColors.push(shadeColor);
          }
        }

        return shadeColors;
      }
    }, {
      key: "value",
      get: function get() {
        return this._value;
      },
      set: function set(value) {
        // Two color formats with alpha values
        var rgba = _parseRGBA(value);

        var hsla = _parseHSLA(value);

        var rgb = _parseRGB(value);

        var cmyk = _parseCMYK(value);

        var hsb = _parseHSB(value);

        var hsl = _parseHSL(value);

        var hex = _parseHex(value);

        if (rgba !== null) {
          this._colorSpace = colorSpace.RGB;
          this.alpha = rgba.a;
          value = _serializeRGB({
            r: rgba.r,
            g: rgba.g,
            b: rgba.b
          });
        } else if (hsla !== null) {
          this._colorSpace = colorSpace.HSL;
          this.alpha = hsla.a;
          value = _serializeHSL({
            h: hsla.h,
            s: hsla.s,
            l: hsla.l
          });
        } else if (rgb !== null) {
          this._colorSpace = colorSpace.RGB;
        } else if (cmyk !== null) {
          this._colorSpace = colorSpace.CMYK;
        } else if (hsb !== null) {
          this._colorSpace = colorSpace.HSB;
        } else if (hsl !== null) {
          this._colorSpace = colorSpace.HSL;
        } else if (hex !== null) {
          this._colorSpace = colorSpace.HEX;
        } else {
          // restore defaults
          this._colorSpace = colorSpace.HEX;
          value = '';
        }

        this._value = value;
      }
      /**
       The alpha value of the color (value between 0-1).
        @type {Number}
       @default 1
       */

    }, {
      key: "alpha",
      get: function get() {
        return this._alpha;
      },
      set: function set(value) {
        if (isNaN(value) || value < 0 || value > 1) {
          return;
        }

        this._alpha = transform.number(value);
      }
      /**
       The rgb values of the color (value between 0-255).
       e.g.: {r:0, g:0, b:0}
        @type {Object}
       @default null
       */

    }, {
      key: "rgb",
      get: function get() {
        var rgb = null;

        if (this._colorSpace === colorSpace.RGB) {
          rgb = _parseRGB(this.value);
        } else if (this._colorSpace === colorSpace.HEX) {
          var hex = _parseHex(this.value);

          rgb = _hexToRgb(hex);
        } else if (this._colorSpace === colorSpace.CMYK) {
          var cmyk = _parseCMYK(this.value);

          rgb = _cmykToRgb(cmyk);
        } else if (this._colorSpace === colorSpace.HSB) {
          var hsb = _parseHSB(this.value);

          rgb = _hsbToRgb(hsb);
        } else if (this._colorSpace === colorSpace.HSL) {
          var hsl = _parseHSL(this.value);

          rgb = _hslToRgb(hsl);
        }

        return rgb;
      },
      set: function set(value) {
        this.value = _serializeRGB(value);
      }
      /**
       The serialized rgb values of the color (r,g,b values between 0-255).
       e.g: 'rgb(0,0,0)'
        @type {String}
       @default ""
       */

    }, {
      key: "rgbValue",
      get: function get() {
        return _serializeRGB(this.rgb);
      },
      set: function set(value) {
        this.value = value;
      }
      /**
       The rgba values of the color (r,g,b values between 0-255 and a between 0-1).
       e.g: {r:0, g:0, b:0, a:1}
        @type {Object}
       @default null
       */

    }, {
      key: "rgba",
      get: function get() {
        var rgb = this.rgb;

        if (rgb) {
          return {
            r: rgb.r,
            g: rgb.g,
            b: rgb.b,
            a: this.alpha
          };
        }

        return null;
      },
      set: function set(value) {
        this.value = _serializeRGBA(value);
      }
      /**
       The serialized rgba values of the color (r,g,b values between 0-255 and alpha between 0-1).
       e.g: 'rgba(0,0,0,1)'
        @type {String}
       @default ""
       */

    }, {
      key: "rgbaValue",
      get: function get() {
        return _serializeRGBA(this.rgba);
      },
      set: function set(value) {
        this.value = value;
      }
      /**
       The hex value of the color.
        @type {Number}
       @default null
       */

    }, {
      key: "hex",
      get: function get() {
        // as hex color space is essentially just the same as rgb and there is no loss in conversion, we can do it this way
        return _rgbToHex(this.rgb);
      },
      set: function set(value) {
        this.value = _serializeHex(value);
      }
      /**
       The serialized hex value of the color.
       e.g: '#94CD4B'
        @type {String}
       @default ""
       */

    }, {
      key: "hexValue",
      get: function get() {
        return _serializeHex(this.hex);
      },
      set: function set(value) {
        this.value = value;
      }
      /**
       The cmyk values of the color (all values between 0-100).
       e.g: {c:0, m:100, y:0, k:100}
        @type {Object}
       @default null
       */

    }, {
      key: "cmyk",
      get: function get() {
        var cmyk = null;
        var rgb = null;

        if (this._colorSpace === colorSpace.RGB) {
          rgb = _parseRGB(this.value);
          cmyk = _rgbToCmyk(rgb);
        } else if (this._colorSpace === colorSpace.HEX) {
          var hex = _parseHex(this.value);

          rgb = _hexToRgb(hex);
          cmyk = _rgbToCmyk(rgb);
        } else if (this._colorSpace === colorSpace.CMYK) {
          cmyk = _parseCMYK(this.value);
        } else if (this._colorSpace === colorSpace.HSB) {
          var hsb = _parseHSB(this.value);

          rgb = _hsbToRgb(hsb);
          cmyk = _rgbToCmyk(rgb);
        } else if (this._colorSpace === colorSpace.HSL) {
          var hsl = _parseHSL(this.value);

          rgb = _hslToRgb(hsl);
          cmyk = _rgbToCmyk(rgb);
        }

        return cmyk;
      },
      set: function set(value) {
        this.value = _serializeCMYK(value);
      }
      /**
       The serialized cmyk values of the color (all values between 0-100).
       e.g: 'cmyk(100,100,100,100)'
        @type {String}
       @default ""
       */

    }, {
      key: "cmykValue",
      get: function get() {
        return _serializeCMYK(this.cmyk);
      },
      set: function set(value) {
        this.value = value;
      }
      /**
       The hsb values of the color.
       h (hue has value between 0-360 degree)
       s (saturation has a value between 0-100 percent)
       b (brightness has a value between 0-100 percent)
        @type {Object}
       @default null
       */

    }, {
      key: "hsb",
      get: function get() {
        var hsb = null;
        var rgb = null;

        if (this._colorSpace === colorSpace.RGB) {
          rgb = _parseRGB(this.value);
          hsb = _rgbToHsb(rgb);
        } else if (this._colorSpace === colorSpace.HEX) {
          var hex = _parseHex(this.value);

          rgb = _hexToRgb(hex);
          hsb = _rgbToHsb(rgb);
        } else if (this._colorSpace === colorSpace.CMYK) {
          var cmyk = _parseCMYK(this.value);

          rgb = _cmykToRgb(cmyk);
          hsb = _rgbToHsb(rgb);
        } else if (this._colorSpace === colorSpace.HSB) {
          hsb = _parseHSB(this.value);
        } else if (this._colorSpace === colorSpace.HSL) {
          var hsl = _parseHSL(this.value);

          rgb = _hslToRgb(hsl);
          hsb = _rgbToHsb(rgb);
        }

        return hsb;
      },
      set: function set(value) {
        this.value = _serializeHSB(value);
      }
      /**
       The serialized hsb values of the color (s and b values between 0-100, h between 0-360).
       e.g: 'hsb(360,100,100)'
        @type {String}
       @default ""
       */

    }, {
      key: "hsbValue",
      get: function get() {
        return _serializeHSB(this.hsb);
      },
      set: function set(value) {
        this.value = value;
      }
      /*
       The hsl values of the color.
       h (hue has value between 0-360 degree)
       s (saturation has a value between 0-100 percent)
       l (lightness has a value between 0-100 percent)
        @type {Object}
       @default null
       */

    }, {
      key: "hsl",
      get: function get() {
        var hsl = null;
        var rgb = null;

        if (this._colorSpace === colorSpace.RGB) {
          rgb = _parseRGB(this.value);
          hsl = _rgbToHsl(rgb);
        } else if (this._colorSpace === colorSpace.HEX) {
          var hex = _parseHex(this.value);

          rgb = _hexToRgb(hex);
          hsl = _rgbToHsl(rgb);
        } else if (this._colorSpace === colorSpace.CMYK) {
          var cmyk = _parseCMYK(this.value);

          rgb = _cmykToRgb(cmyk);
          hsl = _rgbToHsl(rgb);
        } else if (this._colorSpace === colorSpace.HSB) {
          var hsb = _parseHSB(this.value);

          rgb = _hsbToRgb(hsb);
          hsl = _rgbToHsl(rgb);
        } else if (this._colorSpace === colorSpace.HSL) {
          hsl = _parseHSL(this.value);
        }

        return hsl;
      },
      set: function set(value) {
        this.value = _serializeHSL(value);
      }
      /**
       The serialized hsl values of the color (s and l values between 0-100 in percent, h between 0-360).
       e.g: 'hsl(360,100%,100%)'
        @type {String}
       @default ""
       */

    }, {
      key: "hslValue",
      get: function get() {
        return _serializeHSL(this.hsl);
      },
      set: function set(value) {
        this.value = value;
      }
      /**
       The hsla values of the color.
       h (hue has value between 0-360 degree)
       s (saturation has a value between 0-100 percent)
       l (lightness has a value between 0-100 percent)
       a (alpha has a value between 0-1)
        @type {Object}
       @default null
       */

    }, {
      key: "hsla",
      get: function get() {
        var hsl = this.hsl;

        if (hsl) {
          return {
            h: hsl.h,
            s: hsl.s,
            l: hsl.l,
            a: this.alpha
          };
        }

        return null;
      },
      set: function set(value) {
        this.value = _serializeHSLA(value);
      }
      /**
       The serialized hsla values of the color.
       h (hue has value between 0-360 degree)
       s (saturation has a value between 0-100 percent)
       l (lightness has a value between 0-100 percent)
       a (alpha has a value between 0-1)
       e.g: 'hsla(360,50%,50%,0.9)'
        @type {String}
       @default ""
       */

    }, {
      key: "hslaValue",
      get: function get() {
        return _serializeHSLA(this.hsla);
      },
      set: function set(value) {
        this.value = value;
      }
    }]);

    return Color;
  }();

  /**
   @class Coral.ColorInput.Item
   @classdesc A ColorInput Item component
   @htmltag coral-colorinput-item
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var ColorInputItem = /*#__PURE__*/function (_BaseComponent) {
    _inherits(ColorInputItem, _BaseComponent);

    var _super = _createSuper(ColorInputItem);

    function ColorInputItem() {
      _classCallCheck(this, ColorInputItem);

      return _super.apply(this, arguments);
    }

    _createClass(ColorInputItem, [{
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(ColorInputItem.prototype), "render", this).call(this); // adds the role to support accessibility


        this.setAttribute('role', 'option');
      }
    }, {
      key: "value",

      /**
       The value of the color. This value can be set in different formats (HEX, RGB, RGBA, HSB, HSL, HSLA and CMYK).
       Corrects a hex value, if it is represented by 3 or 6 characters with or without '#'.
        e.g:
       HEX:  #FFFFFF
       RGB:  rgb(16,16,16)
       RGBA: rgba(215,40,40,0.9)
       HSB: hsb(360,100,100)
       HSL: hsl(360,100,100)
       HSLA: hsla(360,100%,100%, 0.9)
       CMYK: cmyk(0,100,50,0)
        @type {String}
       @default ""
       @htmlattribute value
       @htmlattributereflected
       */
      get: function get() {
        return this._value || '';
      },
      set: function set(value) {
        // invalid values fallback to empty string
        var color = new Color();
        color.value = value; // invalid values fallback to empty string

        this._value = color.rgb !== null ? value : '';

        this._reflectAttribute('value', this._value);
      }
      /**
       Whether the Item is selected.
       @type {Boolean}
       @default false
       @htmlattribute selected
       @htmlattributereflected
       */

    }, {
      key: "selected",
      get: function get() {
        return this._selected || false;
      },
      set: function set(value) {
        value = transform.booleanAttr(value);
        this._selected = value;

        this._reflectAttribute('selected', this._selected);

        this.classList.toggle('is-selected', this._selected);
        this.setAttribute('aria-selected', this._selected);
        this.trigger('coral-colorinput-item:_selectedchanged');
      }
      /** @ignore */

    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(ColorInputItem), "observedAttributes", this).concat(['selected', 'value']);
      }
    }]);

    return ColorInputItem;
  }(BaseComponent(HTMLElement));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @base BaseColorInputAbstractSubview
   @classdesc An abstract subview class that other subviews should extend.
   */
  var BaseColorInputAbstractSubview = function BaseColorInputAbstractSubview(superClass) {
    return /*#__PURE__*/function (_superClass) {
      _inherits(_class, _superClass);

      var _super = _createSuper(_class);

      /** @ignore */
      function _class() {
        var _this;

        _classCallCheck(this, _class);

        _this = _super.call(this);
        _this._events = {
          'click ._coral-ColorInput-preview': '_onPreviewClicked'
        }; // export a static variable used by all subviews

        _this.constructor._lastValidColor = null;
        return _this;
      }
      /** @ignore */


      _createClass(_class, [{
        key: "_onPreviewClicked",
        value: function _onPreviewClicked() {
          if (this._colorinput.valueAsColor !== null) {
            this.constructor._lastValidColor = this._colorinput.valueAsColor;

            this._colorinput._setActiveColor(null);
          } else if (this.constructor._lastValidColor !== null) {
            this._colorinput._setActiveColor(this.constructor._lastValidColor);
          }
        }
        /** @ignore */

      }, {
        key: "_beforeOverlayOpen",
        value: function _beforeOverlayOpen() {} // overwrite callback in subclass if needed

        /** @ignore */

      }, {
        key: "_onColorInputChange",
        value: function _onColorInputChange() {} // overwrite callback in subclass if needed

        /** @ignore */

      }, {
        key: "connectedCallback",
        value: function connectedCallback() {
          _get(_getPrototypeOf(_class.prototype), "connectedCallback", this).call(this);

          var overlay = this.closest('._coral-ColorInput-overlay');

          if (overlay && overlay._colorinput) {
            // save references to bound callbacks (in order to be able to remove them again from event system)
            this.__beforeOverlayOpen = this._beforeOverlayOpen.bind(this);
            this.__onColorInputChange = this._onColorInputChange.bind(this); // cache colorinput if this component is attached to dom

            this._colorinput = overlay._colorinput;

            this._colorinput.on('coral-overlay:beforeopen', this.__beforeOverlayOpen);

            this._colorinput.on('coral-colorinput:_valuechange', this.__onColorInputChange); // trigger one change initially


            this._onColorInputChange();
          }
        }
        /** @ignore */

      }, {
        key: "disconnectedCallback",
        value: function disconnectedCallback() {
          _get(_getPrototypeOf(_class.prototype), "disconnectedCallback", this).call(this);

          if (this._colorinput) {
            this._colorinput.off('coral-overlay:beforeopen', this.__beforeOverlayOpen);

            this._colorinput.off('coral-colorinput:_valuechange', this.__onColorInputChange);
          }

          this._colorinput = null;
        }
      }]);

      return _class;
    }(superClass);
  };

  var template$q = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["label"] = document.createElement("div");
    el0.className += " _coral-Slider-labelContainer";
    el0.setAttribute("handle", "label");
    var el1 = document.createTextNode("\n  ");
    el0.appendChild(el1);
    var el2 = this["labelContent"] = document.createElement("label");
    el2.className += " _coral-Slider-label";
    el2.setAttribute("handle", "labelContent");
    el0.appendChild(el2);
    var el3 = document.createTextNode("\n  ");
    el0.appendChild(el3);
    var el4 = this["labelValue"] = document.createElement("label");
    el4.className += " _coral-Slider-value";
    el4.setAttribute("handle", "labelValue");
    el4.setAttribute("hidden", "");
    el0.appendChild(el4);
    var el5 = document.createTextNode("\n");
    el0.appendChild(el5);
    frag.appendChild(el0);
    var el6 = document.createTextNode("\n");
    frag.appendChild(el6);
    var el7 = this["controls"] = document.createElement("div");
    el7.className += " _coral-Slider-controls";
    el7.setAttribute("role", "presentation");
    el7.setAttribute("handle", "controls");
    var el8 = document.createTextNode("\n  ");
    el7.appendChild(el8);
    var el9 = document.createElement("div");
    el9.className += " _coral-Slider-track";
    el7.appendChild(el9);
    var el10 = document.createTextNode("\n  ");
    el7.appendChild(el10);
    var el11 = this["leftHandle"] = document.createElement("div");
    el11.className += " _coral-Slider-handle";
    el11.setAttribute("handle", "leftHandle");
    var el12 = document.createTextNode("\n    ");
    el11.appendChild(el12);
    var el13 = this["leftInput"] = document.createElement("input");
    el13.setAttribute("handle", "leftInput");
    el13.setAttribute("value", "1");
    el13.setAttribute("type", "range");
    el13.className += " _coral-Slider-input";
    el11.appendChild(el13);
    var el14 = document.createTextNode("\n  ");
    el11.appendChild(el14);
    el7.appendChild(el11);
    var el15 = document.createTextNode("\n  ");
    el7.appendChild(el15);
    var el16 = document.createElement("div");
    el16.className += " _coral-Slider-track";
    el7.appendChild(el16);
    var el17 = document.createTextNode("\n");
    el7.appendChild(el17);
    frag.appendChild(el7);
    var el18 = document.createTextNode("\n");
    frag.appendChild(el18);
    return frag;
  };

  var CLASSNAME$I = '_coral-Slider';
  var CLASSNAME_HANDLE = '_coral-Slider-handle';
  var CLASSNAME_INPUT = '_coral-Slider-input';
  /**
   Enumeration for {@link Slider} orientations.

   @typedef {Object} SliderOrientationEnum

   @property {String} HORIZONTAL
   Horizontal slider.
   @property {String} VERTICAL
   Not supported. Falls back to HORIZONTAL.
   */

  var orientation$2 = {
    HORIZONTAL: 'horizontal',
    VERTICAL: 'vertical'
  };
  /**
   @class Coral.Slider
   @classdesc A Slider component is a form field that can be used to set a number within a range.
   @htmltag coral-slider
   @extends {HTMLElement}
   @extends {BaseComponent}
   @extends {BaseFormField}
   */

  var Slider = /*#__PURE__*/function (_BaseFormField) {
    _inherits(Slider, _BaseFormField);

    var _super = _createSuper(Slider);

    /** @ignore */
    function Slider() {
      var _this;

      _classCallCheck(this, Slider);

      _this = _super.call(this);

      _this._delegateEvents(commons.extend(_this._events, {
        'key:up ._coral-Slider-handle': '_handleKey',
        'key:right ._coral-Slider-handle': '_handleKey',
        'key:down ._coral-Slider-handle': '_handleKey',
        'key:left ._coral-Slider-handle': '_handleKey',
        'key:pageUp ._coral-Slider-handle': '_handleKey',
        'key:pageDown ._coral-Slider-handle': '_handleKey',
        'key:home ._coral-Slider-handle': '_handleKey',
        'key:end ._coral-Slider-handle': '_handleKey',
        'input': '_onInputChangeHandler',
        'touchstart': '_onMouseDown',
        'mousedown': '_onMouseDown',
        'capture:focus': '_focus',
        'capture:blur': '_blur'
      })); // Prepare templates


      _this._elements = {};

      _this._getTemplate().call(_this._elements, {
        commons: commons
      }); // Pre-define labellable element


      _this._labellableElement = _this._elements.leftInput; // Content zone

      _this._elements.content = _this.querySelector('coral-slider-content') || document.createElement('coral-slider-content'); // Additional shortcuts

      var handleContainer = _this._elements.controls;
      _this._elements.handles = Array.prototype.slice.call(handleContainer.querySelectorAll(".".concat(CLASSNAME_HANDLE)));
      _this._elements.inputs = Array.prototype.slice.call(handleContainer.querySelectorAll(".".concat(CLASSNAME_INPUT))); // Binding

      _this._onInteraction = _this._onInteraction.bind(_assertThisInitialized(_this)); // Init the collection mutation observer

      _this.items._startHandlingItems(true);

      return _this;
    }
    /**
     The slider's content.
      @type {SliderContent}
     @contentzone
     */


    _createClass(Slider, [{
      key: "_getValueOf",

      /** @private */
      value: function _getValueOf(name, defaultValue) {
        if (typeof this["_".concat(name)] === 'number') {
          return this["_".concat(name)];
        } else if (this.hasAttribute(name)) {
          return parseFloat(this.getAttribute(name));
        }

        return defaultValue;
      }
      /**
       handles any mousedown/touchstart on the whole slider
       @private
       */

    }, {
      key: "_onMouseDown",
      value: function _onMouseDown(event) {
        if (this.disabled) {
          return;
        } // do not accept right mouse button clicks


        if (event instanceof MouseEvent) {
          if ((event.which || event.button) !== 1) {
            return;
          }
        }

        event.preventDefault();
        this._currentHandle = event.target.closest(".".concat(CLASSNAME_HANDLE)); // If no handle was touched:
        // the closest handle needs to jump to the closest valid position

        if (!this._currentHandle) {
          var p = this._getPoint(event);

          var val = this._getValueFromCoord(p.pageX, p.pageY, true);

          this._currentHandle = this._findNearestHandle(p.pageX, p.pageY);

          this._updateValue(this._currentHandle, val);

          this._setHandleFocus(this._currentHandle);
        }

        this._currentHandle.classList.add('is-dragged');

        document.body.classList.add('u-coral-closedHand');
        this._draggingHandler = this._handleDragging.bind(this);
        this._mouseUpHandler = this._mouseUp.bind(this);
        events.on('mousemove.Slider', this._draggingHandler);
        events.on('mouseup.Slider', this._mouseUpHandler);
        events.on('touchmove.Slider', this._draggingHandler);
        events.on('touchend.Slider', this._mouseUpHandler);
        events.on('touchcancel.Slider', this._mouseUpHandler);

        this._setHandleFocus(this._currentHandle);
      }
      /**
       @private
       @return {Object} which contains the real coordinates
       */

    }, {
      key: "_getPoint",
      value: function _getPoint(event) {
        if (event.changedTouches && event.changedTouches.length > 0) {
          return event.changedTouches[0];
        } else if (event.touches && event.touches.length > 0) {
          return event.touches[0];
        }

        return event;
      }
      /**
       will set the focus either on the handle element
       or its input if range is supported
        @protected
       */

    }, {
      key: "_setHandleFocus",
      value: function _setHandleFocus(handle) {
        handle.querySelector(".".concat(CLASSNAME_INPUT)).focus();
      }
      /**
       Handles keyboard interaction with the handlers.
       In case input[type=range] is supported, the focus
       will be on the input and keyboard handling will happen natively
        @private
       */

    }, {
      key: "_handleKey",
      value: function _handleKey(event) {
        event.preventDefault();

        this._focus(event);

        var handle = event.matchedTarget;

        var idx = this._elements.handles.indexOf(handle);

        var v = parseInt(this._values[idx], 10); // increase

        if (event.keyCode === Keys.keyToCode('up') || event.keyCode === Keys.keyToCode('right') || event.keyCode === Keys.keyToCode('pageUp')) {
          v += this.step;
        } // decrease
        else if (event.keyCode === Keys.keyToCode('down') || event.keyCode === Keys.keyToCode('left') || event.keyCode === Keys.keyToCode('pageDown')) {
            v -= this.step;
          } // min
          else if (event.keyCode === Keys.keyToCode('home')) {
              v = this.min;
            } // max
            else if (event.keyCode === Keys.keyToCode('end')) {
                v = this.max;
              }

        this._updateValue(handle, v);
      }
      /**
       Finds the nearest handle based on X/Y coordinates
        @private
       */

    }, {
      key: "_findNearestHandle",
      value: function _findNearestHandle(mouseX, mouseY) {
        var closestDistance = Infinity;
        var closestHandle;

        function calculateDistance(elem, x, y) {
          var box = elem.getBoundingClientRect();
          var top = box.top + window.pageYOffset;
          var left = box.left + window.pageXOffset;
          return Math.floor(Math.sqrt(Math.pow(x - (left + box.width / 2), 2) + Math.pow(y - (top + box.height / 2), 2)));
        } // Find the nearest handle


        this._elements.handles.forEach(function (handle) {
          var distance = calculateDistance(handle, mouseX, mouseY);

          if (distance < closestDistance) {
            closestDistance = distance;
            closestHandle = handle;
          }
        });

        return closestHandle;
      }
      /**
       Moves the handles to right position
       based on the data in this._values
        @private
       */

    }, {
      key: "_moveHandles",
      value: function _moveHandles() {
        var _this2 = this;

        var calculatePercent = function calculatePercent(value) {
          return (value - _this2.min) / (_this2.max - _this2.min) * 100;
        };

        var labelValue = []; // Set the handle position as a percentage based on the stored values

        if (this._elements.handles.length === 1) {
          var handle = this._elements.handles[0];
          var percent = calculatePercent(this._values[0]);
          handle.style.left = "".concat(percent, "%");
          handle.previousElementSibling.style.width = "".concat(percent, "%");
          handle.nextElementSibling.style.width = "".concat(100 - percent, "%");
          labelValue.push(this._getLabel(this._values[0]));
        } else {
          var leftHandle = this._elements.handles[0];
          var leftPercent = calculatePercent(this._values[0]);
          leftHandle.style.left = "".concat(leftPercent, "%");
          var rightHandle = this._elements.handles[1];
          var rightPercent = calculatePercent(this._values[1]);
          rightHandle.style.left = "".concat(rightPercent, "%");
          leftHandle.previousElementSibling.style.width = "".concat(leftPercent, "%");
          leftHandle.nextElementSibling.style.left = "".concat(leftPercent, "%");
          var middlePercent = 100 - rightPercent;
          leftHandle.nextElementSibling.style.right = "".concat(middlePercent, "%");
          rightHandle.nextElementSibling.style.width = "".concat(middlePercent, "%");
          labelValue.push(this._getLabel(this._values[0]));
          labelValue.push(this._getLabel(this._values[1]));
        }

        this._elements.labelValue.textContent = labelValue.length > 1 ? labelValue.join(' - ') : labelValue[0];
      }
      /**
       Handles "onchange" events from the input.
       This is only neede in case of IE10 which doesn't handle "oninput event".
       In that case, the _onInputChangeHandler will be called from this handler.
        @private
       */

    }, {
      key: "_onInputChange",
      value: function _onInputChange(event) {
        if (typeof event.target.oninput === 'undefined') {
          this._onInputChangeHandler(event);
        }
      }
      /**
       Handles "oninput" events from the input.
       This makes ensures native inputs like
       - direct keyboard interaction with input[type=range]
       - accessibility features with input[type=range]
        Note we are not using the "_onInputChange" directly because Firefox
       will trigger the "change" event only after the focus has been lost.
        @private
       */

    }, {
      key: "_onInputChangeHandler",
      value: function _onInputChangeHandler(event) {
        // stops the current event
        event.stopPropagation();
        var handle = event.target.closest(".".concat(CLASSNAME_HANDLE));

        if (event.target === document.activeElement) {
          this._focus(event);
        }

        this._updateValue(handle, event.target.value, true);
      }
      /**
       Handles "focusin" event from  either an input or its handle.
        @private
       */

    }, {
      key: "_focus",
      value: function _focus(event) {
        // Depending on support for input[type=range],
        // the event.target could be either the handle or its child input.
        // Use closest() to locate the actual handle.
        event.target.closest(".".concat(CLASSNAME_HANDLE)).classList.add('is-focused');
        events.on('touchstart.Slider', this._onInteraction);
        events.on('mousedown.Slider', this._onInteraction);
      }
      /**
       Handles the blur
        @private
       */

    }, {
      key: "_onInteraction",
      value: function _onInteraction(event) {
        if (!this.contains(event.target)) {
          return;
        }

        event.target.blur();
      }
      /**
       Handles "focusout" event from  either an input or its handle.
        @private
       */

    }, {
      key: "_blur",
      value: function _blur(event) {
        // Depending on support for input[type=range],
        // the event.target could be either the handle or its child input.
        // Use closest() to locate the actual handle.
        event.target.closest(".".concat(CLASSNAME_HANDLE)).classList.remove('is-focused');
        events.off('touchstart.Slider');
        events.off('mousedown.Slider');
      }
      /**
       handles mousemove/touchmove after a succesful start on an handle
        @private
       */

    }, {
      key: "_handleDragging",
      value: function _handleDragging(event) {
        var p = this._getPoint(event);

        this._updateValue(this._currentHandle, this._getValueFromCoord(p.pageX, p.pageY));

        event.preventDefault();
      }
      /**
       updates the value for a handle
       @param handle
       @param val
       @param {Boolean} forceEvent
       Always triggers the event. If <code>true</code> the change event will be triggered without checking if the value really changed. This is useful if we are called from something like the _onInputChange where new value has already been updated AND we are certain the change event should be triggered without checking.
       @protected
       */

    }, {
      key: "_updateValue",
      value: function _updateValue(handle, val, forceEvent) {
        // this is prepared to work for multiple handles
        var idx = this._elements.handles.indexOf(handle);

        var values = this._values;
        values[idx] = val;
        var oldValues = this._values;
        this._values = values;
        var newValues = this._values;

        if (forceEvent || oldValues.join(':') !== newValues.join(':')) {
          this.trigger('change');
        }
      }
      /** @private */
      // eslint-disable-next-line no-unused-vars

    }, {
      key: "_getValueFromCoord",
      value: function _getValueFromCoord(posX, posY, restrictBounds) {
        var boundingClientRect = this.getBoundingClientRect();
        var elementWidth = boundingClientRect.width;
        var percent = (posX - boundingClientRect.left) / elementWidth; // if the bounds are restricted, as with _handleClick, we shouldn't change the value.

        if (restrictBounds && (percent < 0 || percent > 1)) {
          return NaN;
        }

        var rawValue = this.min + (this.max - this.min) * percent; // Snap value to nearest step

        return this._snapValueToStep(rawValue, this.min, this.max, this.step);
      }
      /** @private */

    }, {
      key: "_snapValueToStep",
      value: function _snapValueToStep(rawValue, min, max, step) {
        step = parseFloat(step);
        var remainder = (rawValue - min) % step;
        var floatString = step.toString().replace(/^(?:\d+)(?:\.(\d+))?$/g, '$1');
        var precision = floatString.length;
        var snappedValue;

        if (Math.abs(remainder) * 2 >= step) {
          snappedValue = rawValue - Math.abs(remainder) + step;
        } else {
          snappedValue = rawValue - remainder;
        }

        if (snappedValue < min) {
          snappedValue = min;
        } else if (snappedValue > max) {
          snappedValue = min + Math.floor((max - min) / step) * step;
        } // correct floating point behavior by rounding to step precision


        if (precision > 0) {
          snappedValue = parseFloat(snappedValue.toFixed(precision));
        }

        return snappedValue;
      }
      /**
       end operation of a dragging flow
       @private
       */

    }, {
      key: "_mouseUp",
      value: function _mouseUp() {
        if (this._currentHandle) {
          this._currentHandle.style.cursor = 'grab';

          this._currentHandle.classList.remove('is-dragged');
        }

        document.body.classList.remove('u-coral-closedHand');
        events.off('mousemove.Slider', this._draggingHandler);
        events.off('touchmove.Slider', this._draggingHandler);
        events.off('mouseup.Slider', this._mouseUpHandler);
        events.off('touchend.Slider', this._mouseUpHandler);
        events.off('touchcancel.Slider', this._mouseUpHandler);
        this._currentHandle = null;
        this._draggingHandler = null;
        this._mouseUpHandler = null;
      }
      /**
       Gets the label for a passed value.
        @param value
       @return {String|Number} the known label from the item or the value itself
       @protected
       */

    }, {
      key: "_getLabel",
      value: function _getLabel(value) {
        var items = this.items.getAll();
        var item;

        for (var i = 0; i < items.length; i++) {
          if (transform.number(items[i].getAttribute('value')) === transform.number(value)) {
            item = items[i];
            break;
          }
        } // Use the innerHTML of the item if one was found


        return item ? item.innerHTML : value;
      } // To be overridden by RangedSlider

    }, {
      key: "_getTemplate",
      value: function _getTemplate() {
        return template$q;
      }
    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(Slider.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$I); // Default reflected attributes

        if (!this._min) {
          this.min = this.min;
        }

        if (!this._max) {
          this.max = this.max;
        }

        if (!this._step) {
          this.step = this.step;
        }

        if (!this._orientation) {
          this.orientation = orientation$2.HORIZONTAL;
        } // A11y


        this.setAttribute('role', 'presentation'); // Support cloneNode

        var template = this.querySelectorAll('._coral-Slider-labelContainer, ._coral-Slider-controls');

        for (var i = 0; i < template.length; i++) {
          template[i].remove();
        } // Render the main template


        var frag = document.createDocumentFragment();
        frag.appendChild(this._elements.label);
        frag.appendChild(this._elements.controls);
        var content = this._elements.content; // If no default content zone was provided, move everything there

        if (!content.parentNode) {
          // Process remaining elements as necessary
          while (this.firstChild) {
            var child = this.firstChild;

            if (child.nodeName === 'CORAL-SLIDER-ITEM') {
              // Add items to the fragment
              frag.appendChild(child);
            } else {
              // Add anything else to the content
              content.appendChild(child);
            }
          }
        } // Add the frag to the component


        this.appendChild(frag); // Assign the content zone so the insert function will be called

        this.content = content; // Defaults

        this._moveHandles();
      }
    }, {
      key: "content",
      get: function get() {
        return this._getContentZone(this._elements.content);
      },
      set: function set(value) {
        this._setContentZone('content', value, {
          handle: 'content',
          tagName: 'coral-slider-content',
          insert: function insert(content) {
            this._elements.labelContent.appendChild(content);
          }
        });
      }
      /**
       The Collection Interface that allows interacting with the items that the component contains.
        @type {Collection}
       @readonly
       */

    }, {
      key: "items",
      get: function get() {
        // just init on demand
        if (!this._items) {
          this._items = new Collection$1({
            host: this,
            itemTagName: 'coral-slider-item'
          });
        }

        return this._items;
      }
      /**
       Increment value of one step.
        @type {Number}
       @default 1
       @htmlattribute step
       @htmlattributereflected
       */

    }, {
      key: "step",
      get: function get() {
        return this._getValueOf('step', 1);
      },
      set: function set(value) {
        var _this3 = this;

        value = transform.number(value);

        if (value > 0) {
          this._step = value;

          this._reflectAttribute('step', this._step);

          this._elements.inputs.forEach(function (input) {
            input.setAttribute('step', _this3._step);
          });
        }
      }
      /**
       The minimum value.
        @type {Number}
       @default 1
       @htmlattribute min
       @htmlattributereflected
       */

    }, {
      key: "min",
      get: function get() {
        return this._getValueOf('min', 1);
      },
      set: function set(value) {
        var _this4 = this;

        this._min = transform.number(value);

        this._reflectAttribute('min', this._min);

        this._elements.inputs.forEach(function (input) {
          input.setAttribute('min', _this4._min);
        });
      }
      /**
       The maximum value.
        @type {Number}
       @default 100
       @htmlattribute max
       @htmlattributereflected
       */

    }, {
      key: "max",
      get: function get() {
        return this._getValueOf('max', 100);
      },
      set: function set(value) {
        var _this5 = this;

        this._max = transform.number(value);

        this._reflectAttribute('max', this._max);

        this._elements.inputs.forEach(function (input) {
          input.setAttribute('max', _this5._max);
        });
      }
      /**
       @ignore
        Not supported anymore. Use "showValue" instead.
       */

    }, {
      key: "tooltips",
      get: function get() {
        return this.showValue;
      },
      set: function set(value) {
        this.showValue = value;
      }
      /**
       Display the slider value.
        @type {Boolean}
       @default false
       @htmlattribute showvalue
       @htmlattributereflected
       */

    }, {
      key: "showValue",
      get: function get() {
        return this._showValue || false;
      },
      set: function set(value) {
        this._showValue = transform.booleanAttr(value);

        this._reflectAttribute('showvalue', this._showValue);

        this._elements.labelValue.hidden = !this._showValue;
      }
      /**
       Orientation of the slider. See {@link SliderOrientationEnum}.
        @type {String}
       @default SliderOrientationEnum.HORIZONTAL
       @htmlattribute orientation
       @htmlattributereflected
       */

    }, {
      key: "orientation",
      get: function get() {
        return this._orientation || orientation$2.HORIZONTAL;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        this._orientation = validate.enumeration(orientation$2)(value) && value || orientation$2.HORIZONTAL;

        this._reflectAttribute('orientation', this._orientation);
      }
      /**
       Fill a value or value range using a highlight color.
        @type {Boolean}
       @default false
       @htmlattribute filled
       @htmlattributereflected
       */

    }, {
      key: "filled",
      get: function get() {
        return this._filled || false;
      },
      set: function set(value) {
        this._filled = transform.booleanAttr(value);

        this._reflectAttribute('filled', this._filled);

        this.classList.toggle("".concat(CLASSNAME$I, "--filled"), this._filled);
      }
      /**
       The value returned as a Number. Value is <code>NaN</code> if conversion to Number is not possible.
        @type {Number}
       @default NaN
       */

    }, {
      key: "valueAsNumber",
      get: function get() {
        return parseFloat(this.value);
      },
      set: function set(value) {
        this.value = transform.float(value);
      }
      /**
       Name used to submit the data in a form.
       @type {String}
       @default ""
       @htmlattribute name
       @htmlattributereflected
       */

    }, {
      key: "name",
      get: function get() {
        return this._elements.inputs[0].name;
      },
      set: function set(value) {
        var _this6 = this;

        this._reflectAttribute('name', value);

        this._elements.inputs.forEach(function (input) {
          input.name = _this6.getAttribute('name');
        });
      }
      /**
       This field's current value.
       @type {String}
       @default ""
       @htmlattribute value
       */

    }, {
      key: "value",
      get: function get() {
        return this._elements.inputs[0].value;
      },
      set: function set(value) {
        value = transform.number(value); // setting the value should always set the first value

        if (this._elements.handles.length === 1) {
          var input = this._elements.inputs[0];
          value = this._snapValueToStep(value, this.min, this.max, this.step);
          input.value = value;

          if (input.value) {
            input.setAttribute('aria-valuenow', value);
            input.setAttribute('aria-valuetext', this._getLabel(value));
          } else {
            input.removeAttribute('aria-valuenow');
            input.removeAttribute('aria-valuetext');
          }

          this._moveHandles(); // in order to keep the reset value in sync, we need to handle the "value" attribute of the inner input


          var valueAttribute = this.getAttribute('value');
          input[valueAttribute ? 'setAttribute' : 'removeAttribute']('value', valueAttribute);
        }
      }
      /**
       Whether this field is disabled or not.
       @type {Boolean}
       @default false
       @htmlattribute disabled
       @htmlattributereflected
       */

    }, {
      key: "disabled",
      get: function get() {
        return this._disabled || false;
      },
      set: function set(value) {
        var _this7 = this;

        this._disabled = transform.booleanAttr(value);

        this._reflectAttribute('disabled', this._disabled);

        this.classList.toggle('is-disabled', this._disabled);
        this[this._disabled ? 'setAttribute' : 'removeAttribute']('aria-disabled', this._disabled);

        this._elements.inputs.forEach(function (input) {
          input.disabled = _this7._disabled;
        });
      }
      /**
       Whether this field is required or not.
       @type {Boolean}
       @default false
       @htmlattribute required
       @htmlattributereflected
       */

    }, {
      key: "required",
      get: function get() {
        return this._required || false;
      },
      set: function set(value) {
        var _this8 = this;

        this._required = transform.booleanAttr(value);

        this._reflectAttribute('required', this._required);

        this._elements.inputs.forEach(function (input) {
          input.required = _this8._required;
        });
      }
      /**
       Whether this field is readOnly or not. Indicating that the user cannot modify the value of the control.
       @type {Boolean}
       @default false
       @htmlattribute readonly
       @htmlattributereflected
       */

    }, {
      key: "readOnly",
      get: function get() {
        return this._readOnly || false;
      },
      set: function set(value) {
        var _this9 = this;

        this._readOnly = transform.booleanAttr(value);

        this._reflectAttribute('readonly', this._readOnly);

        this._elements.inputs.forEach(function (input) {
          input.readOnly = _this9._readOnly;
        });
      }
      /**
       Inherited from {@link BaseFormField#labelledBy}.
       */

    }, {
      key: "labelledBy",
      get: function get() {
        return _get(_getPrototypeOf(Slider.prototype), "labelledBy", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(Slider.prototype), "labelledBy", value, this, true);

        if (this._elements.inputs.length > 1) {
          var input = this._elements.inputs[1];
          var labelledBy = this.labelledBy;
          input[labelledBy ? 'setAttribute' : 'removeAttribute']('aria-labelledby', labelledBy);
        }
      }
      /** @private */

    }, {
      key: "_values",
      get: function get() {
        return this._elements.inputs.map(function (input) {
          return String(parseInt(input.value, 10));
        });
      },
      set: function set(values) {
        var _this10 = this;

        if (values && values.length === this._elements.handles.length) {
          this._elements.inputs.forEach(function (input, i) {
            var value = values[i] = _this10._snapValueToStep(values[i], _this10.min, _this10.max, _this10.step);

            input.value = value;

            if (input.value) {
              input.setAttribute('aria-valuenow', value);
              input.setAttribute('aria-valuetext', _this10._getLabel(value));
            } else {
              input.removeAttribute('aria-valuenow');
              input.removeAttribute('aria-valuetext');
            }
          });

          this._moveHandles();
        }
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-slider-content': 'content'
        };
      }
      /**
       Returns {@link Slider} orientation options.
        @return {SliderOrientationEnum}
       */

    }], [{
      key: "orientation",
      get: function get() {
        return orientation$2;
      }
    }, {
      key: "_attributePropertyMap",
      get: function get() {
        return commons.extend(_get(_getPrototypeOf(Slider), "_attributePropertyMap", this), {
          showvalue: 'showValue'
        });
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(Slider), "observedAttributes", this).concat(['step', 'min', 'max', 'tooltips', 'showvalue', 'orientation', 'filled']);
      }
    }]);

    return Slider;
  }(BaseFormField(BaseComponent(HTMLElement)));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Slider.Content
   @classdesc Slider's content component
   @htmltag coral-slider-content
   @return {HTMLElement}
   */
  var SliderContent = (function () {
    return document.createElement('coral-slider-content');
  });

  var CLASSNAME$J = '_coral-Slider-item';
  /**
   @class Coral.Slider.Item
   @classdesc The Slider item
   @htmltag coral-slider-item
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var SliderItem = /*#__PURE__*/function (_BaseComponent) {
    _inherits(SliderItem, _BaseComponent);

    var _super = _createSuper(SliderItem);

    function SliderItem() {
      _classCallCheck(this, SliderItem);

      return _super.apply(this, arguments);
    }

    _createClass(SliderItem, [{
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(SliderItem.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$J);
      }
    }, {
      key: "value",

      /**
       The slider's item value.
       This should contain a number formatted as a string (e.g.: "10") or an empty string.
        @type {String}
       @default ""
       @htmlattribute value
       @htmlattributereflected
       */
      get: function get() {
        return this.getAttribute('value');
      },
      set: function set(value) {
        this._reflectAttribute('value', transform.string(value));
      } // @compat

    }, {
      key: "content",
      get: function get() {
        return this;
      },
      set: function set(value) {
        if (value instanceof HTMLElement) {
          /** @ignore */
          this.innerHTML = value.innerHTML;
        }
      }
    }]);

    return SliderItem;
  }(BaseComponent(HTMLElement));

  var template$r = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var data = data_0 = typeof data_0 === "undefined" ? {} : data_0;
    data = data_0;
    data.uidMin = data.commons.getUID();
    data.uidMax = data.commons.getUID();
    data_0 = data;
    var el1 = document.createTextNode("\n\n");
    frag.appendChild(el1);
    var el2 = this["label"] = document.createElement("div");
    el2.className += " _coral-Slider-labelContainer";
    el2.setAttribute("handle", "label");
    var el3 = document.createTextNode("\n  ");
    el2.appendChild(el3);
    var el4 = this["labelContent"] = document.createElement("label");
    el4.className += " _coral-Slider-label";
    el4.setAttribute("handle", "labelContent");
    el2.appendChild(el4);
    var el5 = document.createTextNode("\n  ");
    el2.appendChild(el5);
    var el6 = this["labelValue"] = document.createElement("label");
    el6.className += " _coral-Slider-value";
    el6.setAttribute("handle", "labelValue");
    el6.setAttribute("hidden", "");
    el2.appendChild(el6);
    var el7 = document.createTextNode("\n");
    el2.appendChild(el7);
    frag.appendChild(el2);
    var el8 = document.createTextNode("\n");
    frag.appendChild(el8);
    var el9 = this["controls"] = document.createElement("div");
    el9.className += " _coral-Slider-controls";
    el9.setAttribute("role", "presentation");
    el9.setAttribute("handle", "controls");
    var el10 = document.createTextNode("\n  ");
    el9.appendChild(el10);
    var el11 = document.createElement("div");
    el11.className += " _coral-Slider-track";
    el9.appendChild(el11);
    var el12 = document.createTextNode("\n  ");
    el9.appendChild(el12);
    var el13 = this["leftHandle"] = document.createElement("div");
    el13.className += " _coral-Slider-handle";
    el13.setAttribute("handle", "leftHandle");
    var el14 = document.createTextNode("\n    ");
    el13.appendChild(el14);
    var el15 = this["leftLabel"] = document.createElement("label");
    el15.setAttribute("handle", "leftLabel");
    el15.className += " u-coral-screenReaderOnly";
    el15.id = data_0["uidMin"] + "-label";
    el15.setAttribute("for", data_0["uidMin"]);
    el15.setAttribute("aria-hidden", "true");
    el15.textContent = "Minimum";
    el13.appendChild(el15);
    var el16 = document.createTextNode("\n    ");
    el13.appendChild(el16);
    var el17 = this["leftInput"] = document.createElement("input");
    el17.setAttribute("handle", "leftInput");
    el17.setAttribute("value", "1");
    el17.setAttribute("type", "range");
    el17.className += " _coral-Slider-input";
    el17.id = data_0["uidMin"];
    el13.appendChild(el17);
    var el18 = document.createTextNode("\n  ");
    el13.appendChild(el18);
    el9.appendChild(el13);
    var el19 = document.createTextNode("\n  ");
    el9.appendChild(el19);
    var el20 = document.createElement("div");
    el20.className += " _coral-Slider-track";
    el9.appendChild(el20);
    var el21 = document.createTextNode("\n  ");
    el9.appendChild(el21);
    var el22 = this["rightHandle"] = document.createElement("div");
    el22.className += " _coral-Slider-handle";
    el22.setAttribute("handle", "rightHandle");
    var el23 = document.createTextNode("\n    ");
    el22.appendChild(el23);
    var el24 = this["rightLabel"] = document.createElement("label");
    el24.setAttribute("handle", "rightLabel");
    el24.className += " u-coral-screenReaderOnly";
    el24.id = data_0["uidMax"] + "-label";
    el24.setAttribute("for", data_0["uidMax"]);
    el24.setAttribute("aria-hidden", "true");
    el24.textContent = "Maximum";
    el22.appendChild(el24);
    var el25 = document.createTextNode("\n    ");
    el22.appendChild(el25);
    var el26 = this["rightInput"] = document.createElement("input");
    el26.setAttribute("handle", "rightInput");
    el26.setAttribute("value", "100");
    el26.setAttribute("type", "range");
    el26.className += " _coral-Slider-input";
    el26.id = data_0["uidMax"];
    el22.appendChild(el26);
    var el27 = document.createTextNode("\n  ");
    el22.appendChild(el27);
    el9.appendChild(el22);
    var el28 = document.createTextNode("\n  ");
    el9.appendChild(el28);
    var el29 = document.createElement("div");
    el29.className += " _coral-Slider-track";
    el9.appendChild(el29);
    var el30 = document.createTextNode("\n");
    el9.appendChild(el30);
    frag.appendChild(el9);
    var el31 = document.createTextNode("\n");
    frag.appendChild(el31);
    return frag;
  };

  /**
   @class Coral.RangedSlider
   @classdesc A Ranged Slider
   @htmltag coral-rangedslider
   @extends {Slider}
   */

  var RangedSlider = /*#__PURE__*/function (_Slider) {
    _inherits(RangedSlider, _Slider);

    var _super = _createSuper(RangedSlider);

    function RangedSlider() {
      _classCallCheck(this, RangedSlider);

      return _super.apply(this, arguments);
    }

    _createClass(RangedSlider, [{
      key: "_getHighestValue",

      /** @private */
      value: function _getHighestValue() {
        return Math.max.apply(null, this.values);
      }
      /** @private */

    }, {
      key: "_getLowestValue",
      value: function _getLowestValue() {
        return Math.min.apply(null, this.values);
      }
      /** @override */

    }, {
      key: "_updateValue",
      value: function _updateValue(handle, val) {
        var idx = this._elements.handles.indexOf(handle);

        if (idx === 0) {
          if (val > parseFloat(this.values[1])) {
            val = this.values[1];
          }

          this._elements.rightInput.min = val;

          this._elements.rightHandle.setAttribute('aria-valuemin', val);
        } else {
          if (val < parseFloat(this.values[0])) {
            val = this.values[0];
          }

          this._elements.leftInput.max = val;

          this._elements.leftHandle.setAttribute('aria-valuemax', val);
        }

        var resValue = [this.values[0], this.values[1]];
        resValue[idx] = val;
        var oldValues = this.values;
        this.values = resValue;
        var newValues = this.values;

        if (oldValues.join(':') !== newValues.join(':')) {
          this.trigger('change');
        }
      }
      /** @override */

    }, {
      key: "_getTemplate",
      value: function _getTemplate() {
        return template$r;
      }
      /**
       Inherited from {@link BaseFormField#clear}.
       */

    }, {
      key: "clear",
      value: function clear() {
        this.startValue = this.min;
        this.endValue = this.max;
      }
      /**
       Inherited from {@link BaseFormField#reset}.
       */

    }, {
      key: "reset",
      value: function reset() {
        // since the 'value' property is not reflected, form components use it to restore the initial value. When a
        // component has support for values, this method needs to be overwritten
        var initialStartValue = this.getAttribute('startvalue') || this.getAttribute('value');
        var initialEndValue = this.getAttribute('endvalue');
        this.startValue = transform.string(initialStartValue);
        this.endValue = transform.string(initialEndValue);
      }
    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(RangedSlider.prototype), "render", this).call(this);

        this.classList.add('_coral-Slider--range'); // Set filled attribute by default

        this.setAttribute('filled', '');
      }
    }, {
      key: "filled",

      /**
       Ranged sliders are always filled.
        @type {Boolean}
       @default true
       @htmlattribute filled
       @htmlattributereflected
       */
      get: function get() {
        return true;
      },
      set: function set(value) {
        if (!transform.booleanAttr(value)) {
          commons._log('warn', 'Coral.RangedSlider: filled can not be set to false.');
        }
      }
      /**
       This field's current value.
       @type {String}
       @default ""
       @htmlattribute value
       */

    }, {
      key: "value",
      get: function get() {
        return this.startValue;
      },
      set: function set(value) {
        this.startValue = value;
      }
      /**
       The starting value of the range.
        @type {String}
       @default '1'
       @emits {change}
       @htmlattribute startValue
       */

    }, {
      key: "startValue",
      get: function get() {
        return this.values[0] || '1';
      },
      set: function set(value) {
        // Snap value to step
        value = String(this._snapValueToStep(transform.number(value), this.min, this.max, this.step));
        var values = this.values;
        values[0] = value;
        this.values = values; // in order to keep the reset value in sync, we need to handle the "startvalue" attribute of the inner input

        var input = this._elements.inputs[0];
        var valueAttribute = this.getAttribute('startvalue') || this.getAttribute('value');
        input[valueAttribute ? 'setAttribute' : 'removeAttribute']('value', valueAttribute);
      }
      /**
       The ending value of the range.
        @type {String}
       @default '100'
       @emits {change}
       @htmlattribute endValue
       */

    }, {
      key: "endValue",
      get: function get() {
        return this.values[1] || '100';
      },
      set: function set(value) {
        // Snap value to step
        value = String(this._snapValueToStep(transform.number(value), this.min, this.max, this.step));
        var values = this.values;
        values[1] = value;
        this.values = values; // in order to keep the reset value in sync, we need to handle the "endvalue" attribute of the inner input

        var input = this._elements.inputs[1];
        var valueAttribute = this.getAttribute('endvalue');
        input[valueAttribute ? 'setAttribute' : 'removeAttribute']('value', valueAttribute);
      }
      /**
       The current values of the ranged slider.
        @type {Array.<String>}
       @default [{@link Coral.RangedSlider#startValue},{@link Coral.RangedSlider#endValue}]
       @emits {change}
       */

    }, {
      key: "values",
      get: function get() {
        return this._values;
      },
      set: function set(values) {
        this._values = values;
      }
    }], [{
      key: "_attributePropertyMap",
      get: function get() {
        return commons.extend(_get(_getPrototypeOf(RangedSlider), "_attributePropertyMap", this), {
          startvalue: 'startValue',
          endvalue: 'endValue'
        });
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(RangedSlider), "observedAttributes", this).concat(['startvalue', 'endvalue']);
      }
    }]);

    return RangedSlider;
  }(Slider);

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons._define('coral-slider-item', SliderItem);

  commons._define('coral-rangedslider', RangedSlider);

  commons._define('coral-slider', Slider);

  Slider.Content = SliderContent;
  Slider.Item = SliderItem;

  var template$s = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["label"] = document.createElement("div");
    el0.className += " _coral-Slider-labelContainer";
    el0.setAttribute("handle", "label");
    var el1 = document.createTextNode("\n  ");
    el0.appendChild(el1);
    var el2 = this["labelContent"] = document.createElement("label");
    el2.className += " _coral-Slider-label";
    el2.setAttribute("handle", "labelContent");
    el0.appendChild(el2);
    var el3 = document.createTextNode("\n  ");
    el0.appendChild(el3);
    var el4 = this["labelValue"] = document.createElement("label");
    el4.className += " _coral-Slider-value";
    el4.setAttribute("handle", "labelValue");
    el4.setAttribute("hidden", "");
    el0.appendChild(el4);
    var el5 = document.createTextNode("\n");
    el0.appendChild(el5);
    frag.appendChild(el0);
    var el6 = document.createTextNode("\n");
    frag.appendChild(el6);
    var el7 = this["controls"] = document.createElement("div");
    el7.className += " _coral-Slider-controls u-coral-noMargin";
    el7.setAttribute("role", "presentation");
    el7.setAttribute("handle", "controls");
    var el8 = document.createTextNode("\n  ");
    el7.appendChild(el8);
    var el9 = this["bar"] = document.createElement("div");
    el9.className += " _coral-Slider-track _coral-ColorInput-sliderBar u-coral-clearFix";
    el9.setAttribute("handle", "bar");
    el7.appendChild(el9);
    var el10 = document.createTextNode("\n  ");
    el7.appendChild(el10);
    var el11 = this["leftHandle"] = document.createElement("div");
    el11.className += " _coral-Slider-handle _coral-ColorInput-sliderHandle";
    el11.setAttribute("handle", "leftHandle");
    var el12 = document.createTextNode("\n    ");
    el11.appendChild(el12);
    var el13 = this["leftInput"] = document.createElement("input");
    el13.setAttribute("aria-orientation", "horizontal");
    el13.setAttribute("handle", "leftInput");
    el13.setAttribute("value", "1");
    el13.setAttribute("type", "range");
    el13.className += " _coral-Slider-input";
    el11.appendChild(el13);
    var el14 = document.createTextNode("\n  ");
    el11.appendChild(el14);
    el7.appendChild(el11);
    var el15 = document.createTextNode("\n");
    el7.appendChild(el15);
    frag.appendChild(el7);
    var el16 = document.createTextNode("\n");
    frag.appendChild(el16);
    return frag;
  };

  var CLASSNAMES$1 = ['_coral-ColorInput-slider', '_coral-Slider--color'];
  /**
   @class Coral.ColorInput.Slider
   @classdesc A ColorInput Slider component
   @htmltag coral-colorinput-slider
   @extends {Slider}
   */

  var ColorInputSlider = /*#__PURE__*/function (_Slider) {
    _inherits(ColorInputSlider, _Slider);

    var _super = _createSuper(ColorInputSlider);

    function ColorInputSlider() {
      _classCallCheck(this, ColorInputSlider);

      return _super.apply(this, arguments);
    }

    _createClass(ColorInputSlider, [{
      key: "_moveHandles",
      value: function _moveHandles() {
        var _this = this;

        var calculatePercent = function calculatePercent(value) {
          return (value - _this.min) / (_this.max - _this.min) * 100;
        };

        var labelValue = []; // Set the handle position as a percentage based on the stored values

        this._elements.handles.forEach(function (handle, index) {
          var percent = calculatePercent(_this._values[index]);
          handle.style.left = "".concat(percent, "%");
          labelValue.push(_this._getLabel(_this._values[index]));
        });

        this._elements.labelValue.textContent = labelValue.length > 1 ? labelValue.join(' - ') : labelValue[0];
      }
      /** @override */

    }, {
      key: "_getTemplate",
      value: function _getTemplate() {
        return template$s;
      }
      /** @ignore */

    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        var _this$classList;

        _get(_getPrototypeOf(ColorInputSlider.prototype), "render", this).call(this);

        (_this$classList = this.classList).add.apply(_this$classList, CLASSNAMES$1);
      }
    }, {
      key: "gradient",

      /**
       The gradient shown as slider background as space separated values (at least 2 values needed).
       e.g: #ff0000 #ffff00 #00ff00 #00ffff #0000ff #ff00ff #ff0000
        @type {String}
       @default ""
       @htmlattribute gradient
       */
      get: function get() {
        return this._gradient || '';
      },
      set: function set(value) {
        this._gradient = transform.string(value);
        var bar = this._elements.bar;
        var barStyle = bar.style;
        var stops = this.gradient.split(' ');
        var amountStops = stops.length; // remove old gradients

        barStyle.backgroundImage = 'none';
        barStyle.filter = '';

        if (amountStops < 2) {
          return;
        }

        var partialGradientStr = '';

        for (var i = 0; i < amountStops; i++) {
          partialGradientStr += ", ".concat(stops[i], " ").concat(Math.abs(i * 100 / (amountStops - 1)), "%");
        }

        barStyle.backgroundImage = "-moz-linear-gradient(to right".concat(partialGradientStr, ")");
        barStyle.backgroundImage = "-ms-linear-gradient(to right".concat(partialGradientStr, ")");
        barStyle.backgroundImage = "-o-linear-gradient(to right".concat(partialGradientStr, ")");
        barStyle.backgroundImage = "-webkit-linear-gradient(to right".concat(partialGradientStr, ")");
        barStyle.backgroundImage = "linear-gradient(to right".concat(partialGradientStr, ")");
        barStyle.filter = "progid:DXImageTransform.Microsoft.gradient(startColorstr='".concat(stops[0], "', endColorstr='").concat(stops[1], "', gradientType=1)");
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(ColorInputSlider), "observedAttributes", this).concat(['gradient']);
      }
    }]);

    return ColorInputSlider;
  }(Slider);

  var template$t = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var data = data_0 = typeof data_0 === "undefined" ? {} : data_0;
    data = data_0;
    var uid = data.commons.getUID();
    data_0 = data;
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    var el2 = this["propertiesSubview"] = document.createElement("div");
    el2.className += " _coral-ColorInput-propertiesSubview";
    el2.setAttribute("handle", "propertiesSubview");
    el2.setAttribute("role", "group");
    var el3 = document.createTextNode("\n  ");
    el2.appendChild(el3);
    var el4 = document.createElement("div");
    el4.className += " _coral-ColorInput-previewView";
    el4.setAttribute("role", "presentation");
    var el5 = document.createTextNode("\n    ");
    el4.appendChild(el5);
    var el6 = document.createElement("div");
    el6.className += " _coral-ColorInput-preview-container";
    el6.setAttribute("role", "presentation");
    var el7 = document.createTextNode("\n      ");
    el6.appendChild(el7);
    var el8 = this["colorPreview2"] = document.createElement("button", "coral-button");
    el8.setAttribute("is", "coral-button");
    el8.setAttribute("handle", "colorPreview2");
    el8.setAttribute("variant", "action");
    el8.className += " _coral-ColorInput-preview";
    el8.setAttribute("type", "button");
    el8.setAttribute("aria-pressed", "false");
    el6.appendChild(el8);
    var el9 = document.createTextNode("\n    ");
    el6.appendChild(el9);
    el4.appendChild(el6);
    var el10 = document.createTextNode("\n    ");
    el4.appendChild(el10);
    var el11 = document.createElement("div");
    el11.className += " _coral-ColorInput-editHex";
    el11.setAttribute("role", "presentation");
    var el12 = document.createTextNode("\n      ");
    el11.appendChild(el12);
    var el13 = document.createElement("label");
    el13.className += " _coral-ColorInput-editHex-label";
    var el14 = document.createTextNode("\n        ");
    el13.appendChild(el14);
    var el15 = document.createElement("span");
    el15.textContent = "#";
    el13.appendChild(el15);
    var el16 = document.createTextNode("\n        ");
    el13.appendChild(el16);
    var el17 = this["hexInput"] = document.createElement("input", "coral-textfield");
    el17.className += " _coral-ColorInput-editHex-input";
    el17.setAttribute("type", "text");
    el17.setAttribute("handle", "hexInput");
    el17.setAttribute("is", "coral-textfield");
    el17.setAttribute("aria-label", data_0["i18n"]["get"]('HEX'));
    el17.setAttribute("placeholder", data_0["i18n"]["get"]('HEX'));
    el17.setAttribute("maxlength", "6");
    el17.setAttribute("value", "");
    el17.setAttribute("variant", "quiet");
    el13.appendChild(el17);
    var el18 = document.createTextNode("\n      ");
    el13.appendChild(el18);
    el11.appendChild(el13);
    var el19 = document.createTextNode("\n    ");
    el11.appendChild(el19);
    el4.appendChild(el11);
    var el20 = document.createTextNode("\n  ");
    el4.appendChild(el20);
    el2.appendChild(el4);
    var el21 = document.createTextNode("\n  ");
    el2.appendChild(el21);
    var el22 = document.createElement("div");
    el22.className += " _coral-ColorInput-rgbaView _coral-ColorInput-editRgba";
    el22.setAttribute("role", "presentation");
    var el23 = document.createTextNode("\n    ");
    el22.appendChild(el23);
    var el24 = document.createElement("div");
    el24.setAttribute("role", "group");
    el24.className += " _coral-ColorInput-editRgba-group";
    var el25 = document.createTextNode("\n      ");
    el24.appendChild(el25);
    var el26 = document.createElement("label");
    el26.className += " _coral-ColorInput-editRgba-group-label";
    el26.id = uid + "-r-label";
    el26.setAttribute("for", uid + "-r");
    el26.textContent = data_0["i18n"]["get"]('R');
    el24.appendChild(el26);
    var el27 = document.createTextNode("\n      ");
    el24.appendChild(el27);
    var el28 = this["redSlider"] = document.createElement("coral-colorinput-slider");
    el28.setAttribute("handle", "redSlider");
    el28.setAttribute("min", "0");
    el28.setAttribute("max", "255");
    el28.setAttribute("value", "0");
    el28.setAttribute("gradient", "#000000 #FF0000");
    el28.setAttribute("labelledby", uid + "-r-label");
    el24.appendChild(el28);
    var el29 = document.createTextNode("\n      ");
    el24.appendChild(el29);
    var el30 = this["redInput"] = document.createElement("input", "coral-textfield");
    el30.className += " _coral-ColorInput-editRgba-group-input";
    el30.id = uid + "-r";
    el30.setAttribute("handle", "redInput");
    el30.setAttribute("is", "coral-textfield");
    el30.setAttribute("type", "number");
    el30.setAttribute("placeholder", data_0["i18n"]["get"]('R'));
    el30.setAttribute("maxlength", "3");
    el30.setAttribute("value", "");
    el30.setAttribute("variant", "quiet");
    el24.appendChild(el30);
    var el31 = document.createTextNode("\n    ");
    el24.appendChild(el31);
    el22.appendChild(el24);
    var el32 = document.createTextNode("\n    ");
    el22.appendChild(el32);
    var el33 = document.createElement("div");
    el33.setAttribute("role", "group");
    el33.className += " _coral-ColorInput-editRgba-group";
    var el34 = document.createTextNode("\n      ");
    el33.appendChild(el34);
    var el35 = document.createElement("label");
    el35.className += " _coral-ColorInput-editRgba-group-label";
    el35.id = uid + "-g-label";
    el35.setAttribute("for", uid + "-g");
    el35.textContent = data_0["i18n"]["get"]('G');
    el33.appendChild(el35);
    var el36 = document.createTextNode("\n      ");
    el33.appendChild(el36);
    var el37 = this["greenSlider"] = document.createElement("coral-colorinput-slider");
    el37.setAttribute("handle", "greenSlider");
    el37.setAttribute("min", "0");
    el37.setAttribute("max", "255");
    el37.setAttribute("value", "0");
    el37.setAttribute("gradient", "#000000 #00FF00");
    el37.setAttribute("labelledby", uid + "-g-label");
    el33.appendChild(el37);
    var el38 = document.createTextNode("\n      ");
    el33.appendChild(el38);
    var el39 = this["greenInput"] = document.createElement("input", "coral-textfield");
    el39.className += " _coral-ColorInput-editRgba-group-input";
    el39.id = uid + "-g";
    el39.setAttribute("handle", "greenInput");
    el39.setAttribute("is", "coral-textfield");
    el39.setAttribute("type", "number");
    el39.setAttribute("placeholder", data_0["i18n"]["get"]('G'));
    el39.setAttribute("maxlength", "3");
    el39.setAttribute("value", "");
    el39.setAttribute("variant", "quiet");
    el33.appendChild(el39);
    var el40 = document.createTextNode("\n    ");
    el33.appendChild(el40);
    el22.appendChild(el33);
    var el41 = document.createTextNode("\n    ");
    el22.appendChild(el41);
    var el42 = document.createElement("div");
    el42.setAttribute("role", "group");
    el42.className += " _coral-ColorInput-editRgba-group";
    var el43 = document.createTextNode("\n      ");
    el42.appendChild(el43);
    var el44 = document.createElement("label");
    el44.className += " _coral-ColorInput-editRgba-group-label";
    el44.id = uid + "-b-label";
    el44.setAttribute("for", uid + "-b");
    el44.textContent = data_0["i18n"]["get"]('B');
    el42.appendChild(el44);
    var el45 = document.createTextNode("\n      ");
    el42.appendChild(el45);
    var el46 = this["blueSlider"] = document.createElement("coral-colorinput-slider");
    el46.setAttribute("handle", "blueSlider");
    el46.setAttribute("min", "0");
    el46.setAttribute("max", "255");
    el46.setAttribute("value", "0");
    el46.setAttribute("gradient", "#000000 #0000FF");
    el46.setAttribute("labelledby", uid + "-b-label");
    el42.appendChild(el46);
    var el47 = document.createTextNode("\n      ");
    el42.appendChild(el47);
    var el48 = this["blueInput"] = document.createElement("input", "coral-textfield");
    el48.className += " _coral-ColorInput-editRgba-group-input";
    el48.id = uid + "-b";
    el48.setAttribute("handle", "blueInput");
    el48.setAttribute("is", "coral-textfield");
    el48.setAttribute("type", "number");
    el48.setAttribute("placeholder", data_0["i18n"]["get"]('B'));
    el48.setAttribute("maxlength", "3");
    el48.setAttribute("value", "");
    el48.setAttribute("variant", "quiet");
    el42.appendChild(el48);
    var el49 = document.createTextNode("\n    ");
    el42.appendChild(el49);
    el22.appendChild(el42);
    var el50 = document.createTextNode("\n    ");
    el22.appendChild(el50);
    var el51 = document.createElement("div");
    el51.setAttribute("role", "group");
    el51.className += " _coral-ColorInput-editRgba-group";
    var el52 = document.createTextNode("\n      ");
    el51.appendChild(el52);
    var el53 = document.createElement("label");
    el53.className += " _coral-ColorInput-editRgba-group-label";
    el53.id = uid + "-a-label";
    el53.setAttribute("for", uid + "-a");
    el53.textContent = data_0["i18n"]["get"]('A');
    el51.appendChild(el53);
    var el54 = document.createTextNode("\n      ");
    el51.appendChild(el54);
    var el55 = this["alphaSlider"] = document.createElement("coral-colorinput-slider");
    el55.setAttribute("handle", "alphaSlider");
    el55.setAttribute("min", "0");
    el55.setAttribute("max", "100");
    el55.setAttribute("value", "100");
    el55.setAttribute("gradient", "rgba(255,255,255,0) rgba(255,255,255,1)");
    el55.setAttribute("labelledby", uid + "-a-label");
    el51.appendChild(el55);
    var el56 = document.createTextNode("\n      ");
    el51.appendChild(el56);
    var el57 = this["alphaInput"] = document.createElement("input", "coral-textfield");
    el57.className += " _coral-ColorInput-editRgba-group-input";
    el57.id = uid + "-a";
    el57.setAttribute("handle", "alphaInput");
    el57.setAttribute("is", "coral-textfield");
    el57.setAttribute("type", "number");
    el57.setAttribute("placeholder", data_0["i18n"]["get"]('A'));
    el57.setAttribute("maxlength", "3");
    el57.setAttribute("value", "");
    el57.setAttribute("variant", "quiet");
    el51.appendChild(el57);
    var el58 = document.createTextNode("\n    ");
    el51.appendChild(el58);
    el22.appendChild(el51);
    var el59 = document.createTextNode("\n  ");
    el22.appendChild(el59);
    el2.appendChild(el22);
    var el60 = document.createTextNode("\n");
    el2.appendChild(el60);
    frag.appendChild(el2);
    var el61 = document.createTextNode("\n");
    frag.appendChild(el61);
    return frag;
  };

  var CLASSNAME$K = '_coral-ColorInput-colorProperties';
  /**
   @class Coral.ColorInput.ColorProperties
   @classdesc A ColorInput Color properties component
   @htmltag coral-colorinput-colorproperties
   @extends {HTMLElement}
   @extends {BaseComponent}
   @extends {BaseColorInputAbstractSubview}
   */

  var ColorInputColorProperties = /*#__PURE__*/function (_BaseColorInputAbstra) {
    _inherits(ColorInputColorProperties, _BaseColorInputAbstra);

    var _super = _createSuper(ColorInputColorProperties);

    /** @ignore */
    function ColorInputColorProperties() {
      var _this;

      _classCallCheck(this, ColorInputColorProperties);

      _this = _super.call(this);

      _this._delegateEvents(commons.extend(_this._events, {
        'change [handle="redSlider"]': '_onRedSliderChange',
        'change [handle="greenSlider"]': '_onGreenSliderChange',
        'change [handle="blueSlider"]': '_onBlueSliderChange',
        'change [handle="alphaSlider"]': '_onAlphaSliderChange',
        'change ._coral-ColorInput-editHex': '_onChangeHex',
        'change ._coral-ColorInput-editRgba': '_onChangeRgba'
      })); // Templates


      _this._elements = {};
      template$t.call(_this._elements, {
        commons: commons,
        i18n: i18n
      });
      return _this;
    }
    /** @ignore */


    _createClass(ColorInputColorProperties, [{
      key: "_onColorInputChange",
      value: function _onColorInputChange() {
        var newColor = this._colorinput.valueAsColor;
        var colorPreview = this._elements.colorPreview2;
        var rgba;

        if (!newColor) {
          // update the colorPreview background color, state, and label
          colorPreview.setAttribute('aria-pressed', 'true');
          colorPreview.setAttribute('aria-label', i18n.get('Color not set')); // reset Hex value to empty

          this._elements.hexInput.value = '';
        } else {
          rgba = newColor.rgba; // update the colorPreview background color, state, and label

          colorPreview.style.backgroundColor = newColor.rgbValue;
          colorPreview.setAttribute('aria-pressed', 'false');
          colorPreview.setAttribute('aria-label', i18n.get('{value}, Color', {
            value: parseFloat(rgba.a) === 1 ? newColor.value : newColor.rgbaValue
          })); // update the Hex input value

          this._elements.hexInput.value = newColor.hexValue.substr(1);
        }

        var prefixes = ['red', 'green', 'blue', 'alpha'];
        var prefixesLength = prefixes.length;
        var prefix;
        var abbr;
        var isAlpha;
        var val; // update rgba slider and input values

        for (var i = 0; i < prefixesLength; i++) {
          prefix = prefixes[i];
          abbr = prefix.substr(0, 1);
          isAlpha = i === prefixesLength - 1; // default slider and input value

          val = isAlpha ? 100 : 127; // with new color, get appropriate RGBA value

          if (newColor) {
            if (!rgba) {
              val = '';
            } else if (isAlpha) {
              val = parseInt(rgba[abbr] * 100, 10);
            } else {
              val = rgba[abbr];
            }
          } // update the slider and input values


          this._elements["".concat(prefix, "Slider")].value = this._elements["".concat(prefix, "Input")].value = val;
        }

        if (colorPreview === document.activeElement) {
          // force blur and focus on colorButton so that new color or state is announced
          colorPreview.blur(); // delay focus by 100ms so that screen reader has time to adjust to label with updated color value

          window.setTimeout(function () {
            colorPreview.focus();
          }, 100);
        }
      }
      /** @ignore */

    }, {
      key: "_onRedSliderChange",
      value: function _onRedSliderChange(event) {
        this._elements.redInput.value = this._elements.redSlider.value;

        this._onChangeRgba(event);
      }
      /** @ignore */

    }, {
      key: "_onGreenSliderChange",
      value: function _onGreenSliderChange(event) {
        this._elements.greenInput.value = this._elements.greenSlider.value;

        this._onChangeRgba(event);
      }
      /** @ignore */

    }, {
      key: "_onBlueSliderChange",
      value: function _onBlueSliderChange(event) {
        this._elements.blueInput.value = this._elements.blueSlider.value;

        this._onChangeRgba(event);
      }
      /** @ignore */

    }, {
      key: "_onAlphaSliderChange",
      value: function _onAlphaSliderChange(event) {
        this._elements.alphaInput.value = this._elements.alphaSlider.value;

        this._onChangeRgba(event);
      }
      /** @ignore */

    }, {
      key: "_onChangeHex",
      value: function _onChangeHex(event) {
        event.stopPropagation(); // Value of hexInput field is without '#'.

        var value = "#".concat(this._elements.hexInput.value);
        var color = new Color();
        color.value = value;

        if (color.hex === null) {
          // no valid color value
          this._elements.hexInput.value = ''; // Save last valid color

          if (this._colorinput.valueAsColor !== null) {
            this.constructor._lastValidColor = this._colorinput.valueAsColor;
          }

          this._colorinput._setActiveColor(null);
        } else {
          this._colorinput._setActiveColor(color);
        }
      }
      /** @ignore */

    }, {
      key: "_onChangeRgba",
      value: function _onChangeRgba(event) {
        event.stopPropagation();
        var r = parseInt(this._elements.redInput.value, 10);
        var g = parseInt(this._elements.greenInput.value, 10);
        var b = parseInt(this._elements.blueInput.value, 10);
        var a = parseInt(this._elements.alphaInput.value, 10);
        var colorValid = true;

        if (isNaN(r) || r < 0 || r > 255) {
          colorValid = false;
          this._elements.redInput.value = '';
        }

        if (isNaN(g) || g < 0 || g > 255) {
          colorValid = false;
          this._elements.greenInput.value = '';
        }

        if (isNaN(b) || b < 0 || b > 255) {
          colorValid = false;
          this._elements.blueInput.value = '';
        }

        if (isNaN(a) || a < 0 || a > 100) {
          colorValid = false;
          this._elements.alphaInput.value = '';
        }

        if (colorValid) {
          var color = new Color();
          color.rgba = {
            r: r,
            g: g,
            b: b,
            a: a / 100
          };

          this._colorinput._setActiveColor(color);
        }
      }
      /** @ignore */

    }, {
      key: "render",
      value: function render() {
        _get(_getPrototypeOf(ColorInputColorProperties.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$K); // Support cloneNode

        var subview = this.querySelector('._coral-ColorInput-propertiesSubview');

        if (subview) {
          subview.remove();
        }

        this.appendChild(this._elements.propertiesSubview);
      }
    }]);

    return ColorInputColorProperties;
  }(BaseColorInputAbstractSubview(BaseComponent(HTMLElement)));

  var template$u = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["colorButton"] = document.createElement("button", "coral-button");
    el0.setAttribute("is", "coral-button");
    el0.setAttribute("variant", "action");
    el0.setAttribute("handle", "colorButton");
    el0.setAttribute("icon", "checkmark");
    el0.setAttribute("type", "button");
    el0.setAttribute("role", "option");
    frag.appendChild(el0);
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    this.colorButton.label.classList.add('u-coral-screenReaderOnly');
    var el3 = document.createTextNode("\n");
    frag.appendChild(el3);
    return frag;
  };

  var CLASSNAME$L = '_coral-ColorInput-swatch';
  /**
   @class Coral.ColorInput.Swatch
   @classdesc A ColorInput Swatch component
   @htmltag coral-colorinput-swatch
   @extends {HTMLElement}
   @extends {BaseComponent}
   @extends {BaseColorInputAbstractSubview}
   */

  var ColorInputSwatch = /*#__PURE__*/function (_BaseColorInputAbstra) {
    _inherits(ColorInputSwatch, _BaseColorInputAbstra);

    var _super = _createSuper(ColorInputSwatch);

    /** @ignore */
    function ColorInputSwatch() {
      var _this;

      _classCallCheck(this, ColorInputSwatch);

      _this = _super.call(this); // Events

      _this._delegateEvents(_this._events); // Templates


      _this._elements = {};
      template$u.call(_this._elements);
      return _this;
    }
    /**
     Whether the Item is selected.
     @type {Boolean}
     @default false
     @htmlattribute selected
     @htmlattributereflected
     */


    _createClass(ColorInputSwatch, [{
      key: "_onColorInputChange",

      /** @ignore */
      value: function _onColorInputChange() {
        if (this.targetColor) {
          // sync selections
          this.selected = this.targetColor.selected;
        }
      }
    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(ColorInputSwatch.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$L, 'u-coral-clearFix'); // adds the role to support accessibility

        this.setAttribute('role', 'presentation'); // Support cloneNode

        var button = this.querySelector('[handle="colorButton"]');

        if (button) {
          button.remove();
        }

        this.appendChild(this._elements.colorButton);
      }
    }, {
      key: "selected",
      get: function get() {
        return this._selected || false;
      },
      set: function set(value) {
        value = transform.booleanAttr(value);

        if (!value || value && !this.disabled) {
          this._selected = value;

          this._reflectAttribute('selected', this.disabled ? false : this._selected);

          this.removeAttribute('aria-selected', this._selected);
          this.classList.toggle('is-selected', this._selected);

          this._elements.colorButton.setAttribute('aria-selected', this._selected);

          this._elements.colorButton.tabIndex = this.tabIndex;
          this.removeAttribute('tabindex');

          this._elements.colorButton[this._selected ? 'setAttribute' : 'removeAttribute']('aria-label', "".concat(i18n.get('checked'), " ").concat(this._elements.colorButton.label.textContent));

          this.trigger('coral-colorinput-swatch:_selectedchanged');
        }
      }
      /**
       The Coral.ColorInput.Item that the swatch is a visual representation of. It accepts a DOM element or a CSS selector.
       If a CSS selector is provided, the first matching element will be used.
        @type {HTMLElement|String}
       @default null
       @htmlattribute targetcolor
       */

    }, {
      key: "targetColor",
      get: function get() {
        return this._targetColor || null;
      },
      set: function set(value) {
        if (typeof value === 'string') {
          value = this.querySelector(value);
        } // Store new value


        this._targetColor = value;
        var cssColorValue = '';
        var hexColorValue = '';

        if (this._targetColor) {
          var color = new Color();
          color.value = this._targetColor.value;
          cssColorValue = color.rgbaValue;
          hexColorValue = color.hexValue;
        } // Update background color and text label for color swatch


        if (cssColorValue) {
          this._elements.colorButton.style.backgroundColor = cssColorValue;
          this._elements.colorButton.label.textContent = hexColorValue;
          this.setAttribute('data-value', hexColorValue);
        } else {
          this._elements.colorButton.classList.add('_coral-ColorInput-swatch-novalue');

          this._elements.colorButton.label.textContent = i18n.get('unset');
          this.setAttribute('data-value', '');
        }
      }
      /**
       Whether the color preview is disabled or not.
        @type {Boolean}
       @default false
       @htmlattribute disabled
       @htmlattributereflected
       */

    }, {
      key: "disabled",
      get: function get() {
        return this._elements.colorButton.disabled;
      },
      set: function set(value) {
        this._elements.colorButton.disabled = value;

        this._reflectAttribute('disabled', this.disabled);
      }
      /**
       The tabindex of the color preview button.
       So that we don't wind up with nested focusable elements,
       the internal colorButton should should receive the tabIndex property,
       while the coral-colorinput-swatch should reflect the value using the _tabindex attribute.
        @type {Integer}
       @default -1
       @htmlattribute tabindex
       @htmlattributereflected
       */

    }, {
      key: "tabIndex",
      get: function get() {
        return this._elements.colorButton.tabIndex;
      },
      set: function set(value) {
        this._elements.colorButton.tabIndex = value;
        this.removeAttribute('tabindex');
      }
    }], [{
      key: "_attributePropertyMap",
      get: function get() {
        return commons.extend(_get(_getPrototypeOf(ColorInputSwatch), "_attributePropertyMap", this), {
          tabindex: 'tabIndex',
          targetcolor: 'targetColor'
        });
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(ColorInputSwatch), "observedAttributes", this).concat(['selected', 'tabindex', 'disabled', 'targetcolor']);
      }
    }]);

    return ColorInputSwatch;
  }(BaseColorInputAbstractSubview(BaseComponent(HTMLElement)));

  var template$v = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["swatchesSubview"] = document.createElement("div");
    el0.className += " _coral-ColorInput-swatchesSubview";
    el0.setAttribute("role", "presentation");
    el0.setAttribute("handle", "swatchesSubview");
    var el1 = document.createTextNode("\n  ");
    el0.appendChild(el1);
    var el2 = document.createElement("div");
    el2.className += " _coral-ColorInput-swatches-header-title coral-Heading coral-Heading--5";
    el2.setAttribute("role", "presentation");
    el2.setAttribute("aria-hidden", "true");
    var el3 = document.createTextNode("\n    ");
    el2.appendChild(el3);
    var el4 = this["swatchesHeaderTitle"] = document.createElement("span");
    el4.setAttribute("handle", "swatchesHeaderTitle");
    el4.id = data_0["commons"]["getUID"]();
    el4.setAttribute("role", "heading");
    el4.setAttribute("aria-level", "2");
    el4.textContent = "\n      " + data_0["i18n"]["get"]('Swatches');
    el2.appendChild(el4);
    var el5 = document.createTextNode("\n  ");
    el2.appendChild(el5);
    el0.appendChild(el2);
    var el6 = document.createTextNode("\n  ");
    el0.appendChild(el6);
    var el7 = document.createElement("div");
    el7.className += " _coral-ColorInput-swatches-container";
    el7.setAttribute("role", "presentation");
    var el8 = document.createTextNode("\n    ");
    el7.appendChild(el8);
    var el9 = this["swatchesContainer"] = document.createElement("div");
    el9.setAttribute("handle", "swatchesContainer");
    el9.setAttribute("role", "presentation");
    el7.appendChild(el9);
    var el10 = document.createTextNode("\n  ");
    el7.appendChild(el10);
    el0.appendChild(el7);
    var el11 = document.createTextNode("\n");
    el0.appendChild(el11);
    frag.appendChild(el0);
    var el12 = document.createTextNode("\n");
    frag.appendChild(el12);
    return frag;
  };

  var CLASSNAME$M = '_coral-ColorInput-swatches';
  /**
   @class Coral.ColorInput.Swatches
   @classdesc A ColorInput Swatches component
   @htmltag coral-colorinput-swatches
   @extends {HTMLElement}
   @extends {BaseComponent}
   @extends {BaseColorInputAbstractSubview}
   */

  var ColorInputSwatches = /*#__PURE__*/function (_BaseColorInputAbstra) {
    _inherits(ColorInputSwatches, _BaseColorInputAbstra);

    var _super = _createSuper(ColorInputSwatches);

    /** @ignore */
    function ColorInputSwatches() {
      var _this;

      _classCallCheck(this, ColorInputSwatches);

      _this = _super.call(this); // Events

      _this._delegateEvents(commons.extend(_this._events, {
        'click coral-colorinput-swatch': '_onSwatchClicked',
        'keydown ._coral-ColorInput-swatch': '_onKeyDown',
        'capture:focus coral-colorinput-swatch': '_onFocus',
        // private
        'coral-colorinput-swatch:_selectedchanged': '_onItemSelectedChanged'
      })); // Templates


      _this._elements = {};
      template$v.call(_this._elements, {
        commons: commons,
        i18n: i18n
      }); // Used for eventing

      _this._oldSelection = null; // Init the collection mutation observer

      _this.items._startHandlingItems(true);

      return _this;
    }
    /**
     The Collection Interface that allows interacting with the items that the component contains.
      @type {SelectableCollection}
     @readonly
     */


    _createClass(ColorInputSwatches, [{
      key: "_onItemSelectedChanged",

      /** @private */
      value: function _onItemSelectedChanged(event) {
        event.stopImmediatePropagation();

        this._validateSelection(event.target);
      }
      /** @private */

    }, {
      key: "_validateSelection",
      value: function _validateSelection(item) {
        var _this2 = this;

        var selectedItems = this.items._getAllSelected(); // Last selected item wins


        item = item || selectedItems[selectedItems.length - 1];

        if (item && item.hasAttribute('selected') && selectedItems.length > 1) {
          selectedItems.forEach(function (selectedItem) {
            if (selectedItem !== item) {
              // Don't trigger change events
              _this2._preventTriggeringEvents = true;
              selectedItem.removeAttribute('selected');
            }
          }); // We can trigger change events again

          this._preventTriggeringEvents = false;
        }

        this._triggerChangeEvent();
      }
      /** @private */

    }, {
      key: "_triggerChangeEvent",
      value: function _triggerChangeEvent() {
        var selectedItem = this.selectedItem;
        var oldSelection = this._oldSelection;

        if (!this._preventTriggeringEvents && selectedItem !== oldSelection) {
          // update hidden fields
          if (selectedItem) {
            this.value = selectedItem.value;
          }

          this.trigger('coral-colorinput-swatches:change', {
            oldSelection: oldSelection,
            selection: selectedItem
          });
          this._oldSelection = selectedItem;
        }
      }
      /** @ignore */

    }, {
      key: "_beforeOverlayOpen",
      value: function _beforeOverlayOpen() {
        // relayout swatches if items have been added/removed/moved...
        var colorElements = this._colorinput.items.getAll();

        var colorsElementsChanged = false;

        if (!this._cachedColorElements) {
          colorsElementsChanged = true;
        } else if (this._cachedColorElements.length !== colorElements.length) {
          colorsElementsChanged = true;
        } else if (this._cachedColorElements.length === colorElements.length) {
          for (var i = 0; i < colorElements.length; i++) {
            if (this._cachedColorElements[i] !== colorElements[i]) {
              colorsElementsChanged = true;
              break;
            }
          }
        }

        this._cachedColorElements = colorElements;

        if (colorsElementsChanged) {
          this._layoutColorSwatch();
        }

        this._ensureKeyboardAccess();
      }
      /** @ignore */

    }, {
      key: "_onColorInputChange",
      value: function _onColorInputChange() {
        this._ensureKeyboardAccess();
      }
      /**
       If no swatch is selected, make sure that the first swatch is tabbable
       @ignore
       */

    }, {
      key: "_ensureKeyboardAccess",
      value: function _ensureKeyboardAccess() {
        if (!this.querySelector('coral-colorinput-swatch[selected]')) {
          var firstSwatch = this.querySelector('coral-colorinput-swatch');

          if (firstSwatch) {
            firstSwatch.tabIndex = 0;
          }
        }
      }
      /** @ignore */

    }, {
      key: "_layoutColorSwatch",
      value: function _layoutColorSwatch() {
        // Clear container before adding elements to avoid multiple addition
        this._elements.swatchesContainer.innerHtml = '';

        var colors = this._colorinput.items.getAll();

        var colorsLength = colors.length;
        var swatchSelected = false;

        for (var colorCount = 0; colorCount < colorsLength; colorCount++) {
          var color = colors[colorCount];
          var swatch = new ColorInputSwatch();

          this._elements.swatchesContainer.appendChild(swatch);

          swatch.targetColor = color;

          if (color.selected) {
            swatch[color.selected ? 'setAttribute' : 'removeAttribute']('selected', color.selected);
            swatchSelected = true;
          } // Update color button tabindex depending on selected state


          swatch.tabIndex = swatch.selected ? 0 : -1;
        } // If no swatch is selected, make sure that the first swatch is focusable


        if (!swatchSelected) {
          this._ensureKeyboardAccess();
        }
      }
      /** @ignore */

    }, {
      key: "_onSwatchClicked",
      value: function _onSwatchClicked(event) {
        event.stopPropagation();
        var colorButton = event.target;
        var swatch = colorButton.closest('coral-colorinput-swatch');

        if (!swatch.selected) {
          var color = new Color();
          color.value = swatch.targetColor ? swatch.targetColor.value : '';

          this._colorinput._setActiveColor(color);

          swatch.selected = true;
        }

        swatch.firstChild.focus();
      }
      /** @ignore */

    }, {
      key: "_onKeyDown",
      value: function _onKeyDown(event) {
        var overlay = this._colorinput._elements.overlay; // only if overlay is open

        if (!overlay.open) {
          return;
        }

        var allItems = this.items.getAll();
        var currentIndex = allItems.indexOf(event.matchedTarget);
        var preventDefault = true;
        var newIndex = currentIndex;

        switch (event.which) {
          // return
          case 13:
            // Wait a frame before closing so that focus is restored correctly
            window.requestAnimationFrame(function () {
              overlay.open = false;
            });
            break;
          // left arrow

          case 37:
            newIndex -= 1;
            break;
          // up arrow

          case 38:
            newIndex -= 4;
            break;
          // right arrow

          case 39:
            newIndex += 1;
            break;
          // down arrow

          case 40:
            newIndex += 4;
            break;

          default:
            preventDefault = false;
            break;
        } // If any action has been taken prevent event propagation


        if (preventDefault) {
          event.preventDefault();

          if (newIndex < 0 || newIndex >= allItems.length) {
            return;
          } // show right page in carousel and focus right swatch


          var swatch = allItems[newIndex];
          var color = new Color();
          color.value = swatch.targetColor ? swatch.targetColor.value : '';

          this._colorinput._setActiveColor(color);

          swatch.selected = true;
          swatch.firstChild.focus();
        }
      }
      /**
       Ensure that only one swatch can receive tab focus at a time
       @ignore
       */

    }, {
      key: "_onFocus",
      value: function _onFocus(event) {
        var allItems = this.items.getAll();

        for (var i = 0; i < allItems.length; i++) {
          var swatch = allItems[i];

          if (!swatch.contains(event.matchedTarget)) {
            swatch.tabIndex = -1;
          }
        }

        event.matchedTarget.tabIndex = 0;

        if (document.activeElement !== event.matchedTarget.firstChild) {
          event.matchedTarget.firstChild.focus();
        }
      }
      /** @ignore */

    }, {
      key: "render",
      value: function render() {
        _get(_getPrototypeOf(ColorInputSwatches.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$M); // adds the role to support accessibility

        this.setAttribute('role', 'listbox'); // Support cloneNode

        var swatchesSubview = this.querySelector('._coral-ColorInput-swatchesSubview');

        if (swatchesSubview) {
          swatchesSubview.remove();
        } // add header


        this.appendChild(this._elements.swatchesSubview); // add accessibility label

        this.setAttribute('aria-labelledby', this._elements.swatchesHeaderTitle.id); // Don't trigger events once connected

        this._preventTriggeringEvents = true;

        this._validateSelection();

        this._preventTriggeringEvents = false;
        this._oldSelection = this.selectedItem;
      }
    }, {
      key: "items",
      get: function get() {
        // just init on demand
        if (!this._items) {
          this._items = new SelectableCollection({
            host: this,
            itemTagName: 'coral-colorinput-swatch',
            onItemAdded: this._validateSelection
          });
        }

        return this._items;
      }
      /**
       The selected item.
        @type {HTMLElement}
       @readonly
       */

    }, {
      key: "selectedItem",
      get: function get() {
        return this.items._getLastSelected();
      }
    }]);

    return ColorInputSwatches;
  }(BaseColorInputAbstractSubview(BaseComponent(HTMLElement)));

  var template$w = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var data = data_0 = typeof data_0 === "undefined" ? {} : data_0;
    var el0 = this["defaultPalette"] = document.createElement("div");
    el0.setAttribute("handle", "defaultPalette");
    var el1 = document.createTextNode("\n  ");
    el0.appendChild(el1);
    var el2 = document.createElement("coral-colorinput-item");
    el2.setAttribute("value", "");
    el0.appendChild(el2);
    var el3 = document.createTextNode("\n  ");
    el0.appendChild(el3);
    var el4 = document.createElement("coral-colorinput-item");
    el4.setAttribute("value", "#001F3F");
    el0.appendChild(el4);
    var el5 = document.createTextNode("\n  ");
    el0.appendChild(el5);
    var el6 = document.createElement("coral-colorinput-item");
    el6.setAttribute("value", "#0074D9");
    el0.appendChild(el6);
    var el7 = document.createTextNode("\n  ");
    el0.appendChild(el7);
    var el8 = document.createElement("coral-colorinput-item");
    el8.setAttribute("value", "#7FDBFF");
    el0.appendChild(el8);
    var el9 = document.createTextNode("\n  ");
    el0.appendChild(el9);
    var el10 = document.createElement("coral-colorinput-item");
    el10.setAttribute("value", "#39CCCC");
    el0.appendChild(el10);
    var el11 = document.createTextNode("\n  ");
    el0.appendChild(el11);
    var el12 = document.createElement("coral-colorinput-item");
    el12.setAttribute("value", "#3D9970");
    el0.appendChild(el12);
    var el13 = document.createTextNode("\n  ");
    el0.appendChild(el13);
    var el14 = document.createElement("coral-colorinput-item");
    el14.setAttribute("value", "#2ECC40");
    el0.appendChild(el14);
    var el15 = document.createTextNode("\n  ");
    el0.appendChild(el15);
    var el16 = document.createElement("coral-colorinput-item");
    el16.setAttribute("value", "#01FF70");
    el0.appendChild(el16);
    var el17 = document.createTextNode("\n  ");
    el0.appendChild(el17);
    var el18 = document.createElement("coral-colorinput-item");
    el18.setAttribute("value", "#FFDC00");
    el0.appendChild(el18);
    var el19 = document.createTextNode("\n  ");
    el0.appendChild(el19);
    var el20 = document.createElement("coral-colorinput-item");
    el20.setAttribute("value", "#FF851B");
    el0.appendChild(el20);
    var el21 = document.createTextNode("\n  ");
    el0.appendChild(el21);
    var el22 = document.createElement("coral-colorinput-item");
    el22.setAttribute("value", "#FF4136");
    el0.appendChild(el22);
    var el23 = document.createTextNode("\n  ");
    el0.appendChild(el23);
    var el24 = document.createElement("coral-colorinput-item");
    el24.setAttribute("value", "#85144B");
    el0.appendChild(el24);
    var el25 = document.createTextNode("\n  ");
    el0.appendChild(el25);
    var el26 = document.createElement("coral-colorinput-item");
    el26.setAttribute("value", "#F012BE");
    el0.appendChild(el26);
    var el27 = document.createTextNode("\n  ");
    el0.appendChild(el27);
    var el28 = document.createElement("coral-colorinput-item");
    el28.setAttribute("value", "#B10DC9");
    el0.appendChild(el28);
    var el29 = document.createTextNode("\n  ");
    el0.appendChild(el29);
    var el30 = document.createElement("coral-colorinput-item");
    el30.setAttribute("value", "#111111");
    el0.appendChild(el30);
    var el31 = document.createTextNode("\n  ");
    el0.appendChild(el31);
    var el32 = document.createElement("coral-colorinput-item");
    el32.setAttribute("value", "#AAAAAA");
    el0.appendChild(el32);
    var el33 = document.createTextNode("\n  ");
    el0.appendChild(el33);
    var el34 = document.createElement("coral-colorinput-item");
    el34.setAttribute("value", "#DDDDDD");
    el0.appendChild(el34);
    var el35 = document.createTextNode("\n");
    el0.appendChild(el35);
    frag.appendChild(el0);
    var el36 = document.createTextNode("\n");
    frag.appendChild(el36);
    data = data_0;
    var uid = data.commons.getUID();
    data_0 = data;
    var el38 = document.createTextNode("\n");
    frag.appendChild(el38);
    var el39 = this["input"] = document.createElement("input", "coral-textfield");
    el39.setAttribute("handle", "input");
    el39.setAttribute("is", "coral-textfield");
    el39.className += " _coral-ColorInput-input";
    el39.setAttribute("type", "text");
    el39.setAttribute("value", "");
    el39.setAttribute("role", "combobox");
    el39.setAttribute("aria-autocomplete", "none");
    el39.setAttribute("aria-haspopup", "dialog");
    el39.setAttribute("aria-expanded", "false");
    el39.setAttribute("aria-controls", uid);
    frag.appendChild(el39);
    var el40 = document.createTextNode("\n");
    frag.appendChild(el40);
    var el41 = this["buttonWrapper"] = document.createElement("div");
    el41.className += " _coral-ColorInput-buttonWrapper";
    el41.setAttribute("handle", "buttonWrapper");
    el41.setAttribute("role", "presentation");
    var el42 = document.createTextNode("\n  ");
    el41.appendChild(el42);
    var el43 = this["colorPreview"] = document.createElement("button", "coral-button");
    el43.setAttribute("handle", "colorPreview");
    el43.setAttribute("is", "coral-button");
    el43.setAttribute("variant", "_custom");
    el43.className += " _coral-FieldButton _coral-ColorInput-button _coral-ColorInput-preview";
    el43.setAttribute("type", "button");
    el43.setAttribute("aria-haspopup", "dialog");
    el43.setAttribute("aria-expanded", "false");
    el43.setAttribute("aria-controls", uid);
    el41.appendChild(el43);
    var el44 = document.createTextNode("\n  ");
    el41.appendChild(el44);
    data = data_0; // Since we don't have a mutation observer anymore to replace content zones magically, we have to do it manually.

    this.colorPreview.label.classList.add('u-coral-screenReaderOnly');
    this.colorPreview.label.innerText = data.i18n.get('Color Picker');
    this.colorPreview.label.id = uid + '-coral-button-label';
    data_0 = data;
    var el46 = document.createTextNode("\n");
    el41.appendChild(el46);
    frag.appendChild(el41);
    var el47 = document.createTextNode("\n");
    frag.appendChild(el47);
    var el48 = this["overlay"] = document.createElement("coral-popover");
    el48.setAttribute("smart", "");
    el48.className += " _coral-ColorInput-overlay";
    el48.setAttribute("role", "dialog");
    el48.setAttribute("focusonshow", "on");
    el48.setAttribute("trapfocus", "on");
    el48.setAttribute("handle", "overlay");
    el48.setAttribute("breadthoffset", "50%r - 50%p");
    el48.setAttribute("placement", "bottom");
    el48.id = uid;
    el48.setAttribute("aria-label", data_0["i18n"]["get"]('Color Picker'));
    var el49 = document.createTextNode("\n  ");
    el48.appendChild(el49);
    var el50 = this["propertiesView"] = document.createElement("coral-colorinput-colorproperties");
    el50.setAttribute("handle", "propertiesView");
    el48.appendChild(el50);
    var el51 = document.createTextNode("\n  ");
    el48.appendChild(el51);
    var el52 = this["swatchesView"] = document.createElement("coral-colorinput-swatches");
    el52.setAttribute("handle", "swatchesView");
    el48.appendChild(el52);
    var el53 = document.createTextNode("\n");
    el48.appendChild(el53);
    frag.appendChild(el48);
    var el54 = document.createTextNode("\n");
    frag.appendChild(el54);
    return frag;
  };

  var CLASSNAME$N = '_coral-ColorInput';
  /**
   Enumeration for {@link ColorInput} variants.

   @typedef {Object} ColorInputVariantEnum

   @property {String} DEFAULT
   Use ColorInput as a formfield (default).
   @property {String} SWATCH
   Use a simple swatch as ColorInput.
   */

  var variant$f = {
    DEFAULT: 'default',
    SWATCH: 'swatch'
  };
  /**
   Enumeration for {@link ColorInput} auto generated colors options.

   @typedef {Object} ColorInputAutoGenerateColorsEnum

   @property {String} OFF
   Disable auto generation.
   @property {String} SHADES
   Automatically generate shades (darker colors) of all colors.
   @property {String} TINTS
   Automatically generate tints (lighter colors) of all colors.
   */

  var autoGenerateColors = {
    OFF: 'off',
    SHADES: 'shades',
    TINTS: 'tints'
  };
  /**
   Enumeration for {@link ColorInput} swatches display options.

   @typedef {Object} ColorInputShowSwatchesEnum

   @property {String} ON
   Display swatches view (default).
   @property {String} OFF
   Hide swatches view.
   */

  var showSwatches = {
    ON: 'on',
    OFF: 'off'
  };
  /**
   Enumeration for {@link ColorInput} color properties display options.

   @typedef {Object} ColorInputShowPropertiesEnum

   @property {String} ON
   Display color properties view (default).
   @property {String} OFF
   Hide color properties view.
   */

  var showProperties = {
    ON: 'on',
    OFF: 'off'
  };
  /**
   Enumeration for {@link ColorInput} default colors display options.

   @typedef {Object} ColorInputShowDefaultColorsEnum

   @property {String} ON
   Display default colors (default).
   @property {String} OFF
   Hide default colors.
   */

  var showDefaultColors = {
    ON: 'on',
    OFF: 'off'
  };
  /**
   @class Coral.ColorInput
   @classdesc A ColorInput component than can be used as a form field to select from a list of color options.
   @htmltag coral-colorinput
   @extends {HTMLElement}
   @extends {BaseComponent}
   @extends {BaseFormField}
   */

  var ColorInput = /*#__PURE__*/function (_BaseFormField) {
    _inherits(ColorInput, _BaseFormField);

    var _super = _createSuper(ColorInput);

    /** @ignore */
    function ColorInput() {
      var _this;

      _classCallCheck(this, ColorInput);

      _this = _super.call(this); // Prepare templates

      _this._elements = {};
      template$w.call(_this._elements, {
        commons: commons,
        i18n: i18n
      });
      var overlay = _this._elements.overlay;
      var overlayId = overlay.id; // Add a reference to this

      overlay._colorinput = _assertThisInitialized(_this); // Extend form field events

      var events = commons.extend(_this._events, {
        'key:down ._coral-ColorInput-input:not([readonly])': '_onKeyDown',
        'key:down [handle="colorPreview"]': '_onKeyDown',
        'click [handle="colorPreview"]': '_onColorPreviewClick',
        'key:esc input': '_onKeyEsc',
        'key:enter input': '_onKeyEsc',
        // private
        'coral-colorinput-item:_selectedchanged': '_onItemSelectedChanged'
      }); // Overlay

      events["global:capture:coral-overlay:beforeopen #".concat(overlayId)] = '_beforeOverlayOpen';
      events["global:capture:coral-overlay:close #".concat(overlayId)] = '_onOverlayClose';
      events["global:key:esc #".concat(overlayId)] = '_onKeyEsc'; // Events

      _this._delegateEvents(events); // Pre-define labellable element


      _this._labellableElement = _this._elements.input; // Used for eventing

      _this._oldSelection = null; // Init the collection mutation observer

      _this.items._startHandlingItems(true);

      return _this;
    }
    /**
     Returns the inner overlay to allow customization.
      @type {Popover}
     @readonly
     */


    _createClass(ColorInput, [{
      key: "_onItemSelectedChanged",

      /** @private */
      value: function _onItemSelectedChanged(event) {
        event.stopImmediatePropagation();

        this._validateSelection(event.target);
      }
      /** @private */

    }, {
      key: "_onItemAdded",
      value: function _onItemAdded(item) {
        this._validateSelection(item);

        if (this._elements.overlay.open) {
          // simply close the overlay whenever a color is added
          this._elements.overlay.open = false;
        }
      }
      /** @private */

    }, {
      key: "_onItemRemoved",
      value: function _onItemRemoved() {
        if (this._elements.overlay.open) {
          // simply close the overlay whenever a color is removed
          this._elements.overlay.open = false;
        }
      }
      /** @private */

    }, {
      key: "_validateSelection",
      value: function _validateSelection(item) {
        var _this2 = this;

        var selectedItems = this.items._getAllSelected(); // Last selected item wins


        item = item || selectedItems[selectedItems.length - 1];

        if (item && item.hasAttribute('selected') && selectedItems.length > 1) {
          selectedItems.forEach(function (selectedItem) {
            if (selectedItem !== item) {
              // Don't trigger change events
              _this2._preventTriggeringEvents = true;
              selectedItem.removeAttribute('selected');
            }
          }); // We can trigger change events again

          this._preventTriggeringEvents = false;
        }

        this._triggerChangeEvent();
      }
      /** @private */

    }, {
      key: "_triggerChangeEvent",
      value: function _triggerChangeEvent() {
        var selectedItem = this.selectedItem;
        var oldSelection = this._oldSelection;

        if (!this._preventTriggeringEvents && selectedItem !== oldSelection) {
          // update hidden fields
          if (selectedItem) {
            this.value = selectedItem.getAttribute('value');
          }

          this.trigger('coral-colorinput:change', {
            oldSelection: oldSelection,
            selection: selectedItem
          });
          this._oldSelection = selectedItem;
        }
      }
      /** @ignore */

    }, {
      key: "_onColorPreviewClick",
      value: function _onColorPreviewClick(event) {
        // restore focus to appropriate element when overlay closes
        this._elements.overlay.returnFocusTo(this.variant === variant$f.SWATCH ? event.matchedTarget : this._elements.input);
      }
    }, {
      key: "_onInputChange",
      value: function _onInputChange(event) {
        if (event.target === this._elements.input) {
          // only handle changes to the hidden input field ...
          // stops the current event
          event.stopPropagation();
          var color = new Color();
          color.value = event.target[this._eventTargetProperty];

          this._setActiveColor(color);
        }
      }
      /** @ignore */

    }, {
      key: "_onKeyDown",
      value: function _onKeyDown(event) {
        event.stopPropagation(); // restore focus to appropriate element when overlay closes

        this._elements.overlay.returnFocusTo(this.variant === variant$f.SWATCH ? event.matchedTarget : this._elements.input);

        this._elements.overlay.open = true;
      }
      /** @ignore */

    }, {
      key: "_onKeyEsc",
      value: function _onKeyEsc(event) {
        if (!this._elements.overlay.open) {
          return;
        }

        event.stopPropagation();
        this._elements.overlay.open = false;
      }
      /** @ignore */

    }, {
      key: "_beforeOverlayOpen",
      value: function _beforeOverlayOpen() {
        // Make sure appropriate tabbable descendant will receive focus
        if (this.showProperties === showProperties.ON) {
          this._elements.overlay.focusOnShow = this._elements.propertiesView._elements.colorPreview2;
        } else if (this.showSwatches === showSwatches.ON) {
          this._elements.overlay.focusOnShow = this._elements.overlay.querySelector('coral-colorinput-swatch[selected] > button') || 'coral-colorinput-swatch > button';
        } // set aria-expanded state


        this._elements.input.setAttribute('aria-expanded', true);

        this._elements.colorPreview.setAttribute('aria-expanded', true);
      }
      /** @ignore */

    }, {
      key: "_onOverlayClose",
      value: function _onOverlayClose() {
        // set aria-expanded state
        this._elements.input.setAttribute('aria-expanded', true);

        this._elements.colorPreview.setAttribute('aria-expanded', false);
      }
      /**
       Checks if the current input is valid or not. This check will only be performed on user interaction.
        @ignore
       */

    }, {
      key: "_validateInputValue",
      value: function _validateInputValue() {
        this.invalid = this.value !== '' && this.valueAsColor === null;
      }
      /** @ignore */

    }, {
      key: "_showOrHideView",
      value: function _showOrHideView(view, hide) {
        view.hidden = hide; // Remove both classes and add only the required one

        this._elements.overlay.classList.remove('_coral-ColorInput-onlySwatchesView', '_coral-ColorInput-onlyPropertiesView');

        if (!this._elements.propertiesView.hidden && this._elements.swatchesView.hidden) {
          this._elements.overlay.classList.add('_coral-ColorInput-onlyPropertiesView');
        } else if (this._elements.propertiesView.hidden && !this._elements.swatchesView.hidden) {
          this._elements.overlay.classList.add('_coral-ColorInput-onlySwatchesView');
        } // Update accessibility label for colorPreview button when only swatches are shown


        if (this.showProperties === showProperties.OFF && this.showSwatches === showSwatches.ON) {
          this._elements.colorPreview.label.textContent = i18n.get('Swatches');

          this._elements.overlay.setAttribute('aria-label', i18n.get('Swatches'));
        } else {
          this._elements.colorPreview.label.textContent = i18n.get('Color Picker');

          this._elements.overlay.setAttribute('aria-label', i18n.get('Color Picker'));
        }
      }
      /** @ignore */

    }, {
      key: "_recalculateGeneratedColors",
      value: function _recalculateGeneratedColors() {
        // remove old generated tint colors
        var childrenList = this.querySelectorAll('coral-colorinput-item[coral-colorinput-generatedcolor]');
        var childrenListLength = childrenList.length;

        for (var i = 0; i < childrenListLength; i++) {
          childrenList[i].remove();
        }

        if (this.autoGenerateColors !== autoGenerateColors.OFF) {
          var colorElements = this.items.getAll();
          var colorEl = null;
          var color = null;
          var colorIndex = 0;
          var generatedIndex = 0;
          var generatedColorEl = null;
          var generatedColors = [];

          for (colorIndex = 0; colorIndex < colorElements.length; colorIndex++) {
            colorEl = colorElements[colorIndex];
            color = new Color();
            color.value = colorEl.value;
            generatedColors = this.autoGenerateColors === autoGenerateColors.TINTS ? color.calculateTintColors(5) : color.calculateShadeColors(5);

            for (generatedIndex = generatedColors.length - 1; generatedIndex >= 0; generatedIndex--) {
              generatedColorEl = new ColorInputItem(); // be sure to add alpha

              generatedColorEl.value = generatedColors[generatedIndex].rgbaValue;
              generatedColorEl.setAttribute('coral-colorinput-generatedcolor', '');
              colorEl.parentNode.insertBefore(generatedColorEl, colorEl.nextSibling);
            }
          }
        }
      }
      /** @ignore */

    }, {
      key: "_syncColorPreviewIcon",
      value: function _syncColorPreviewIcon() {
        var colorPreview = this._elements.colorPreview;
        colorPreview.icon = this.disabled && this.variant === variant$f.SWATCH ? 'lockClosed' : '';
        colorPreview.iconSize = Icon.size.SMALL;
      }
      /** @ignore */

    }, {
      key: "_setActiveColor",
      value: function _setActiveColor(color) {
        // method used by subviews to set a color and trigger a change event if needed
        var oldColor = this.valueAsColor ? this.valueAsColor : new Color();
        this.valueAsColor = color;

        if (!oldColor.isSimilarTo(this.valueAsColor, false)) {
          // test if current color is invalid
          this._validateInputValue(); // trigger a change event (change events should only be triggered when an user interaction happened)


          this.trigger('change');
        }
      }
      /** @ignore */

    }, {
      key: "_selectColorInputColor",
      value: function _selectColorInputColor(newColor) {
        var selectColorInItems = true;

        if (this.selectedItem) {
          var selectedColor = new Color();
          selectedColor.value = this.selectedItem.value; // only select color if it is not already selected

          selectColorInItems = !selectedColor.isSimilarTo(newColor, true);
        }

        if (selectColorInItems) {
          // select right color in this.items (if necessary and possible)
          var selectedItem = this.selectedItem;

          if (selectedItem) {
            selectedItem.removeAttribute('selected');
          }

          var colorElements = this.items.getAll();
          var colorElementsCount = colorElements.length;
          var color = null;

          for (var i = 0; i < colorElementsCount; i++) {
            color = new Color();
            color.value = colorElements[i].getAttribute('value');

            if (color.isSimilarTo(newColor, true)) {
              colorElements[i].setAttribute('selected', '');
              break;
            }
          }
        }
      }
      /** @private */

    }, {
      key: "_setDefaultSelectedItem",
      value: function _setDefaultSelectedItem() {
        var selectedItem = this.selectedItem;
        var value = this.value; // Sync selectedItem if value is set

        if (value && !selectedItem) {
          var color = new Color();
          color.value = value;

          this._selectColorInputColor(color);
        } // Also sync color preview


        this._updateColorPreview();
      }
    }, {
      key: "_updateColorPreview",
      value: function _updateColorPreview() {
        var isValueEmpty = this.value === ''; // update color preview

        var currentColor = this.valueAsColor;
        this._elements.colorPreview.style.backgroundColor = currentColor ? currentColor.rgbaValue : '';
        this.classList.toggle('_coral-ColorInput--novalue', isValueEmpty); // Update preview in overlay

        var preview = this._elements.overlay.querySelector('._coral-ColorInput-preview');

        if (preview) {
          preview.classList.toggle('_coral-ColorInput-preview--novalue', isValueEmpty);
        }
      }
      /**
       Returns {@link ColorInput} variants.
        @return {ColorInputVariantEnum}
       */

    }, {
      key: "connectedCallback",

      /** @ignore */
      value: function connectedCallback() {
        _get(_getPrototypeOf(ColorInput.prototype), "connectedCallback", this).call(this);

        var overlay = this._elements.overlay; // Cannot be open by default when rendered

        overlay.removeAttribute('open'); // Restore in DOM

        if (overlay._parent) {
          overlay._parent.appendChild(overlay);
        }
      }
      /** @ignore */

    }, {
      key: "render",
      value: function render() {
        _get(_getPrototypeOf(ColorInput.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$N);
        this.setAttribute('role', 'group');
        var frag = document.createDocumentFragment(); // Render template

        frag.appendChild(this._elements.defaultPalette);
        frag.appendChild(this._elements.input);
        frag.appendChild(this._elements.buttonWrapper);
        frag.appendChild(this._elements.overlay); // Support cloneNode

        while (this.firstChild) {
          var child = this.firstChild;

          if (child.nodeType === Node.ELEMENT_NODE && child.hasAttribute('handle')) {
            this.removeChild(child);
          } else {
            frag.appendChild(child);
          }
        } // we use 'this' so properly aligns to the input


        this._elements.overlay.target = this._elements.colorPreview;
        this.appendChild(frag); // Make sure colors are generated

        this.autoGenerateColors = this.autoGenerateColors;
        this.showDefaultColors = this.showDefaultColors; // Don't trigger events once connected

        this._preventTriggeringEvents = true; // Make sure we don't have multiple items selected

        this._validateSelection(); // If value is set to default palette item value, we have to make sure it's selected


        this._setDefaultSelectedItem(); // We can trigger events gain


        this._preventTriggeringEvents = false;
        this._oldSelection = this.selectedItem;
      }
      /** @ignore */

    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        _get(_getPrototypeOf(ColorInput.prototype), "disconnectedCallback", this).call(this);

        var overlay = this._elements.overlay; // In case it was moved out don't forget to remove it

        if (!this.contains(overlay)) {
          overlay._parent = overlay._repositioned ? document.body : this;
          overlay.remove();
        }
      }
    }, {
      key: "overlay",
      get: function get() {
        return this._elements.overlay;
      }
      /**
       The Collection Interface that allows interacting with the items that the component contains.
        @type {SelectableCollection}
       @readonly
       */

    }, {
      key: "items",
      get: function get() {
        // just init on demand
        if (!this._items) {
          this._items = new SelectableCollection({
            host: this,
            itemTagName: 'coral-colorinput-item',
            onItemAdded: this._onItemAdded,
            onItemRemoved: this._onItemRemoved
          });
        }

        return this._items;
      }
      /**
       The selected item in the ColorInput.
        @type {HTMLElement}
       @readonly
       */

    }, {
      key: "selectedItem",
      get: function get() {
        return this.items._getLastSelected();
      }
      /**
       The ColorInput variant. See {@link ColorInputVariantEnum}.
        @default ColorInputVariantEnum.DEFAULT
       @type {String}
       @htmlattribute variant
       @htmlattributereflected
       */

    }, {
      key: "variant",
      get: function get() {
        return this._variant || variant$f.DEFAULT;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        this._variant = validate.enumeration(variant$f)(value) && value || variant$f.DEFAULT;

        this._reflectAttribute('variant', this._variant);

        if (this._variant === variant$f.SWATCH) {
          this.classList.add('_coral-ColorInput--swatch');

          this._elements.input.setAttribute('tabindex', -1);

          this._elements.colorPreview.removeAttribute('tabindex');
        } else {
          this.classList.remove('_coral-ColorInput--swatch');

          this._elements.input.removeAttribute('tabindex');

          this._elements.colorPreview.setAttribute('tabindex', -1);
        }

        this._syncColorPreviewIcon();
      }
      /**
       Convenient property to get/set the the current color. If the value is no valid color it will return
       <code>null</code> (The getter will return a copy of the current selected color).
        @type {Color}
       */

    }, {
      key: "valueAsColor",
      get: function get() {
        if (!this._color) {
          this._color = new Color();
        } // sync this._color with the hidden field if necessary


        var newColor = new Color();
        newColor.value = this.value;

        if (!this._color.isSimilarTo(newColor, true)) {
          this._color.value = newColor.value;
          this._color.alpha = newColor.alpha;
        }

        if (this._color.rgb === null) {
          return null;
        }

        return this._color.clone();
      },
      set: function set(value) {
        if (!this._color) {
          this._color = new Color();
        }

        if (!value) {
          // clear color values
          this._color.value = '';
          this.value = '';
        } else {
          // set color values
          this._color = value;

          if (value.alpha < 1) {
            // if an alpha value is used store rgba in the hidden field (it is the only format that can store alpha)
            this.value = value.rgbaValue;
          } else {
            this.value = value.value;
          }
        }
      }
      /**
       Should shades (darker colors) or tints (lighter colors) automatically be generated.
       See {@link ColorInputAutoGenerateColorsEnum}.
        @default Coral.ColorInput.autoGenerateColors.OFF
       @type {String}
       @htmlattribute autogeneratecolors
       */

    }, {
      key: "autoGenerateColors",
      get: function get() {
        return this._autoGenerateColors || autoGenerateColors.OFF;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        this._autoGenerateColors = validate.enumeration(autoGenerateColors)(value) && value || autoGenerateColors.OFF;

        this._recalculateGeneratedColors();
      }
      /**
       Whether swatches view should be displayed. See {@link ColorInputSwatches}.
        @default ColorInputShowSwatchesEnum.ON
       @type {ColorInputSwatches}
       @htmlattribute showswatches
       */

    }, {
      key: "showSwatches",
      get: function get() {
        return this._showSwatches || showSwatches.ON;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        this._showSwatches = validate.enumeration(showSwatches)(value) && value || showSwatches.ON;

        this._showOrHideView(this._elements.swatchesView, this._showSwatches === showSwatches.OFF);
      }
      /**
       Whether properties view should be displayed. See {@link ColorInputColorProperties}.
        @default ColorInputShowPropertiesEnum.ON
       @type {String}
       @htmlattribute showproperties
       */

    }, {
      key: "showProperties",
      get: function get() {
        return this._showProperties || showProperties.ON;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        this._showProperties = validate.enumeration(showProperties)(value) && value || showProperties.ON;

        this._showOrHideView(this._elements.propertiesView, this._showProperties === showProperties.OFF);
      }
      /**
       Whether default colors should be displayed. Link {@link ColorInputShowDefaultColorsEnum}.
        @default ColorInputShowDefaultColorsEnum.ON
       @type {String}
       @htmlattribute showdefaultcolors
       */

    }, {
      key: "showDefaultColors",
      get: function get() {
        return this._showDefaultColors || showDefaultColors.ON;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        this._showDefaultColors = validate.enumeration(showDefaultColors)(value) && value || showDefaultColors.ON;
        var defaultPalette = this._elements.defaultPalette;

        if (this._showDefaultColors === showDefaultColors.ON) {
          if (!defaultPalette.parentNode) {
            this.insertBefore(defaultPalette, this.firstChild || null);
          }
        } else if (defaultPalette.parentNode) {
          defaultPalette.parentNode.removeChild(defaultPalette);
        }
      }
      /**
       Short hint that describes the expected value of the ColorInput. It is displayed when the ColorInput is empty
       and the variant is {@link Coral.ColorInput.variant.DEFAULT}
        @type {String}
       @default ""
       @htmlattribute placeholder
       @htmlattributereflected
       */

    }, {
      key: "placeholder",
      get: function get() {
        return this._elements.input.placeholder;
      },
      set: function set(value) {
        this._reflectAttribute('placeholder', value);

        this._elements.input.placeholder = value;
      }
      /**
       The value of the color. This value can be set in 5 different formats (HEX, RGB, RGBA, HSB and CMYK). Corrects a
       hex value, if it is represented by 3 or 6 characters with or without '#'
        e.g:
       HEX:  #FFFFFF
       RGB:  rgb(16,16,16)
       RGBA: rgba(215,40,40,0.9)
       RGBA: hsb(360,100,100)
       CMYK: cmyk(0,100,50,0)
        @type {String}
       @default ""
       @htmlattribute value
       */

    }, {
      key: "value",
      get: function get() {
        return this._value || '';
      },
      set: function set(value) {
        var oldColor = new Color();
        oldColor.value = this.value;
        var newColor = new Color();
        newColor.value = value;

        if (!newColor.isSimilarTo(oldColor, false)) {
          this._value = value; // make sure right ColorInput.Item is selected even if input field was set by hand

          this._selectColorInputColor(newColor); // trigger a change event


          this.trigger('coral-colorinput:_valuechange');
        } // always set the input to the current value


        this._elements.input.value = this.value;

        this._updateColorPreview();
      }
      /**
       Name used to submit the data in a form.
       @type {String}
       @default ""
       @htmlattribute name
       @htmlattributereflected
       */

    }, {
      key: "name",
      get: function get() {
        return this._elements.input.name;
      },
      set: function set(value) {
        this._reflectAttribute('name', value);

        this._elements.input.name = value;
      }
      /**
       Whether this field is disabled or not.
       @type {Boolean}
       @default false
       @htmlattribute disabled
       @htmlattributereflected
       */

    }, {
      key: "disabled",
      get: function get() {
        return this._disabled || false;
      },
      set: function set(value) {
        this._disabled = transform.booleanAttr(value);

        this._reflectAttribute('disabled', this._disabled);

        this[this._disabled ? 'setAttribute' : 'removeAttribute']('aria-disabled', this._disabled);
        this.classList.toggle('is-disabled', this._disabled);
        this._elements.input.disabled = this.disabled;
        this._elements.colorPreview.disabled = this._disabled || this.readOnly;

        this._syncColorPreviewIcon();
      }
      /**
       Inherited from {@link BaseFormField#invalid}.
       */

    }, {
      key: "invalid",
      get: function get() {
        return _get(_getPrototypeOf(ColorInput.prototype), "invalid", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(ColorInput.prototype), "invalid", value, this, true);

        this._elements.input.invalid = this.invalid;
      }
      /**
       Whether this field is required or not.
       @type {Boolean}
       @default false
       @htmlattribute required
       @htmlattributereflected
       */

    }, {
      key: "required",
      get: function get() {
        return this._required || false;
      },
      set: function set(value) {
        this._required = transform.booleanAttr(value);

        this._reflectAttribute('required', this._required);

        this._elements.input.required = this._required;
      }
      /**
       Whether this field is readOnly or not. Indicating that the user cannot modify the value of the control.
       @type {Boolean}
       @default false
       @htmlattribute readonly
       @htmlattributereflected
       */

    }, {
      key: "readOnly",
      get: function get() {
        return this._readOnly || false;
      },
      set: function set(value) {
        this._readOnly = transform.booleanAttr(value);

        this._reflectAttribute('readonly', this._readOnly);

        this._elements.input.readOnly = this._readOnly;
        this._elements.colorPreview.disabled = this.disabled || this._readOnly;
      }
      /**
       Inherited from {@link BaseFormField#labelledBy}.
       */

    }, {
      key: "labelledBy",
      get: function get() {
        return _get(_getPrototypeOf(ColorInput.prototype), "labelledBy", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(ColorInput.prototype), "labelledBy", value, this, true); // Sync input aria-labelledby


        this._elements.input[value ? 'setAttribute' : 'removeAttribute']('aria-labelledby', value); // in case the user focuses the buttons, he will still get a notion of the usage of the component


        if (this.labelledBy) {
          this.setAttribute('aria-labelledby', this.labelledBy);

          this._elements.colorPreview.setAttribute('aria-labelledby', [this.labelledBy, this._elements.colorPreview.label.id].join(' '));
        } else {
          this.removeAttribute('aria-labelledby');

          this._elements.colorPreview.removeAttribute('aria-labelledby');
        }
      }
    }], [{
      key: "variant",
      get: function get() {
        return variant$f;
      }
      /**
       Returns {@link ColorInput} auto generated colors options.
        @return {ColorInputAutoGenerateColorsEnum}
       */

    }, {
      key: "autoGenerateColors",
      get: function get() {
        return autoGenerateColors;
      }
      /**
       Returns {@link ColorInput} swatches display options.
        @return {ColorInputShowSwatchesEnum}
       */

    }, {
      key: "showSwatches",
      get: function get() {
        return showSwatches;
      }
      /**
       Returns {@link ColorInput} color properties display options.
        @return {ColorInputShowDefaultColorsEnum}
       */

    }, {
      key: "showDefaultColors",
      get: function get() {
        return showDefaultColors;
      }
      /**
       Returns {@link ColorInput} default colors display options.
        @return {ColorInputShowPropertiesEnum}
       */

    }, {
      key: "showProperties",
      get: function get() {
        return showProperties;
      }
    }, {
      key: "_attributePropertyMap",
      get: function get() {
        return commons.extend(_get(_getPrototypeOf(ColorInput), "_attributePropertyMap", this), {
          autogeneratecolors: 'autoGenerateColors',
          showswatches: 'showSwatches',
          showproperties: 'showProperties',
          showdefaultcolors: 'showDefaultColors'
        });
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(ColorInput), "observedAttributes", this).concat(['variant', 'autogeneratecolors', 'showswatches', 'showproperties', 'showdefaultcolors', 'placeholder']);
      }
    }]);

    return ColorInput;
  }(BaseFormField(BaseComponent(HTMLElement)));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var translations$d = {
    "en-US": {
      "Swatches": "Swatches",
      "R": "R",
      "G": "G",
      "B": "B",
      "A": "A",
      "HEX": "HEX",
      "Color Picker": "Color Picker",
      "unset": "Not set",
      "checked": "Checked",
      "{value}, Color": "{value}, Color",
      "Color not set": "Color not set"
    },
    "fr-FR": {
      "Swatches": "Ãchantillons",
      "R": "R",
      "G": "G",
      "B": "B",
      "A": "A",
      "HEX": "HEX",
      "Color Picker": "SÃ©lecteur de couleurs",
      "unset": "Non dÃ©fini",
      "checked": "ActivÃ©",
      "{value}, Color": "{value}, Couleur",
      "Color not set": "Couleur non dÃ©fini"
    },
    "de-DE": {
      "Swatches": "Muster",
      "R": "R",
      "G": "G",
      "B": "B",
      "A": "A",
      "HEX": "HEX",
      "Color Picker": "Farbauswahl",
      "unset": "Nicht gesetzt",
      "checked": "Aktiviert",
      "{value}, Color": "{value}, Farbe",
      "Color not set": "Farbe nicht gesetzt"
    },
    "it-IT": {
      "Swatches": "Campioni",
      "R": "R",
      "G": "G",
      "B": "B",
      "A": "A",
      "HEX": "HEX",
      "Color Picker": "Selettore colori",
      "unset": "Non impostato",
      "checked": "Selezionato",
      "{value}, Color": "{value}, Colore",
      "Color not set": "Colore non impostato"
    },
    "es-ES": {
      "Swatches": "Muestras",
      "R": "R",
      "G": "G",
      "B": "B",
      "A": "A",
      "HEX": "HEX",
      "Color Picker": "Selector de colores",
      "unset": "No establecido",
      "checked": "Activado",
      "{value}, Color": "{value}, Color",
      "Color not set": "Color no establecido"
    },
    "pt-BR": {
      "Swatches": "Amostras",
      "R": "R",
      "G": "G",
      "B": "B",
      "A": "A",
      "HEX": "HEX",
      "Color Picker": "Seletor de cores",
      "unset": "NÃ£o definida",
      "checked": "Selecionado",
      "{value}, Color": "{value}, Cor",
      "Color not set": "Cor nÃ£o definida"
    },
    "ja-JP": {
      "Swatches": "ã¹ã¦ã©ãã",
      "R": "R",
      "G": "G",
      "B": "B",
      "A": "A",
      "HEX": "16 é²",
      "Color Picker": "ã«ã©ã¼ ããã«ã¼",
      "unset": "è¨­å®è§£é¤",
      "checked": "é¸æ",
      "{value}, Color": "{value}, ã«ã©ã¼",
      "Color not set": "è²ãè¨­å®ããã¦ãã¾ãã"
    },
    "ko-KR": {
      "Swatches": "ê²¬ë³¸",
      "R": "R",
      "G": "G",
      "B": "B",
      "A": "A",
      "HEX": "HEX",
      "Color Picker": "ì ì í",
      "unset": "ì¤ì  í´ì ",
      "checked": "ì íë¨",
      "{value}, Color": "{value}, ì",
      "Color not set": "ììì´ ì¤ì ëì§ ìììµëë¤."
    },
    "zh-CN": {
      "Swatches": "è²æ¿",
      "R": "R",
      "G": "G",
      "B": "B",
      "A": "A",
      "HEX": "åå­è¿å¶",
      "Color Picker": "é¢è²éåå¨",
      "unset": "åæ¶è®¾ç½®",
      "checked": "å·²éä¸­",
      "{value}, Color": "{value}, é¢è²",
      "Color not set": "é¢è²æªè®¾å®"
    },
    "zh-TW": {
      "Swatches": "è²ç¥¨",
      "R": "R",
      "G": "G",
      "B": "B",
      "A": "A",
      "HEX": "åå­é²ä½",
      "Color Picker": "è²å½©é¸æå¨",
      "unset": "åæ¶è¨­å®",
      "checked": "å·²æª¢æ¥",
      "{value}, Color": "{value}, è²å½©",
      "Color not set": "é¡è²æªè¨­å®"
    },
    "nl-NL": {
      "Swatches": "Stalen",
      "R": "R",
      "G": "G",
      "B": "B",
      "A": "A",
      "HEX": "HEX",
      "Color Picker": "Kleurenkiezer",
      "unset": "Niet ingesteld",
      "checked": "Geselecteerd",
      "{value}, Color": "{value}, Kleur",
      "Color not set": "Kleur niet ingesteld"
    },
    "da-DK": {
      "Swatches": "FarveprÃ¸ver",
      "R": "R",
      "G": "G",
      "B": "B",
      "A": "A",
      "HEX": "HEX",
      "Color Picker": "FarvevÃ¦lger",
      "unset": "annuller indstilling",
      "checked": "kontrolleret",
      "{value}, Color": "{value}, Farve",
      "Color not set": "Farve ikke indstillet"
    },
    "fi-FI": {
      "Swatches": "VÃ¤rimallit",
      "R": "R",
      "G": "G",
      "B": "B",
      "A": "A",
      "HEX": "HEX",
      "Color Picker": "VÃ¤rimuokkain",
      "unset": "poista asetus",
      "checked": "valittu",
      "{value}, Color": "{value}, vÃ¤ri",
      "Color not set": "VÃ¤riÃ¤ ei ole asetettu."
    },
    "nb-NO": {
      "Swatches": "Fargekart",
      "R": "R",
      "G": "G",
      "B": "B",
      "A": "A",
      "HEX": "HEX",
      "Color Picker": "Fargevelger",
      "unset": "fjern",
      "checked": "avmerket",
      "{value}, Color": "{value}, farge",
      "Color not set": "Farge ikke angitt"
    },
    "sv-SE": {
      "Swatches": "FÃ¤rgrutor",
      "R": "R",
      "G": "G",
      "B": "B",
      "A": "A",
      "HEX": "HEX",
      "Color Picker": "FÃ¤rgvÃ¤ljaren",
      "unset": "stÃ¤ll tillbaka",
      "checked": "kontrollerade",
      "{value}, Color": "{value}, FÃ¤rg",
      "Color not set": "FÃ¤rg inte instÃ¤lld"
    },
    "cs-CZ": {
      "Swatches": "VzornÃ­ky",
      "R": "R",
      "G": "G",
      "B": "B",
      "A": "A",
      "HEX": "HEX",
      "Color Picker": "VÃ½bÄr barvy",
      "unset": "nenastaveno",
      "checked": "zkontrolovÃ¡no",
      "{value}, Color": "{value}, Barva",
      "Color not set": "Barva nenÃ­ nastavena"
    },
    "pl-PL": {
      "Swatches": "PrÃ³bki",
      "R": "R",
      "G": "G",
      "B": "B",
      "A": "A",
      "HEX": "HEX",
      "Color Picker": "PrÃ³bnik kolorÃ³w",
      "unset": "usuÅ ustawienie",
      "checked": "sprawdzono",
      "{value}, Color": "{value}, kolor",
      "Color not set": "Nie ustawiono koloru"
    },
    "ru-RU": {
      "Swatches": "Ð¦Ð²ÐµÑÐ¾Ð²ÑÐµ Ð¾Ð±ÑÐ°Ð·ÑÑ",
      "R": "R",
      "G": "G",
      "B": "B",
      "A": "A",
      "HEX": "HEX",
      "Color Picker": "ÐÐ°Ð»Ð¸ÑÑÐ° ÑÐ²ÐµÑÐ¾Ð²",
      "unset": "Ð½Ðµ Ð·Ð°Ð´Ð°Ð½Ð¾",
      "checked": "Ð¿ÑÐ¾Ð²ÐµÑÐµÐ½Ð¾",
      "{value}, Color": "{value}, ÑÐ²ÐµÑ",
      "Color not set": "Ð¦Ð²ÐµÑ Ð½Ðµ Ð·Ð°Ð´Ð°Ð½"
    },
    "tr-TR": {
      "Swatches": "Renk Ãrnekleri",
      "R": "R",
      "G": "G",
      "B": "B",
      "A": "A",
      "HEX": "HEX",
      "Color Picker": "Renk SeÃ§ici",
      "unset": "ayarÄ± kaldÄ±r",
      "checked": "denetlendi",
      "{value}, Color": "{value}, Renk",
      "Color not set": "Renk ayarlanmadÄ±"
    }
  };

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons.extend(strings, {
    'coral-component-colorinput': translations$d
  }); // Expose component on the Coral namespace

  commons._define('coral-colorinput-swatches', ColorInputSwatches);

  commons._define('coral-colorinput-swatch', ColorInputSwatch);

  commons._define('coral-colorinput-slider', ColorInputSlider);

  commons._define('coral-colorinput-colorproperties', ColorInputColorProperties);

  commons._define('coral-colorinput-item', ColorInputItem);

  commons._define('coral-colorinput', ColorInput);

  ColorInput.Item = ColorInputItem;
  ColorInput.Swatches = ColorInputSwatches;
  ColorInput.Swatch = ColorInputSwatch;
  ColorInput.Slider = ColorInputSlider;
  ColorInput.ColorProperties = ColorInputColorProperties;

  var template$x = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["accessibilityState"] = document.createElement("span");
    el0.setAttribute("handle", "accessibilityState");
    el0.className += " u-coral-screenReaderOnly";
    el0.setAttribute("aria-hidden", "true");
    el0.id = data_0["commons"]["getUID"]();
    el0.setAttribute("role", "presentation");
    el0.setAttribute("aria-live", "off");
    el0.setAttribute("aria-atomic", "true");
    frag.appendChild(el0);
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    return frag;
  };

  /**
   @class Coral.ColumnView.Collection
   @classdesc The ColumnView collection
   @extends {SelectableCollection}
   */

  var ColumnViewCollection = /*#__PURE__*/function (_SelectableCollection) {
    _inherits(ColumnViewCollection, _SelectableCollection);

    var _super = _createSuper(ColumnViewCollection);

    function ColumnViewCollection() {
      _classCallCheck(this, ColumnViewCollection);

      return _super.apply(this, arguments);
    }

    _createClass(ColumnViewCollection, [{
      key: "_deselectAndDeactivateAllExcept",
      value: function _deselectAndDeactivateAllExcept(item) {
        this.getAll().forEach(function (el) {
          if (el.hasAttribute('selected') || el.hasAttribute('active')) {
            el.removeAttribute('selected');

            if (el !== item) {
              el.removeAttribute('active');
            }
          }
        });
      }
    }, {
      key: "_deactivateAll",
      value: function _deactivateAll() {
        this._deselectAllExcept(null, 'active');
      }
    }, {
      key: "_deactivateAllExceptFirst",
      value: function _deactivateAllExceptFirst() {
        this._deselectAllExceptFirst('active');
      }
    }, {
      key: "_getAllActive",
      value: function _getAllActive() {
        return this._getAllSelected('active');
      }
    }, {
      key: "_selectAll",
      value: function _selectAll() {
        this.getAll().forEach(function (el) {
          if (!el.hasAttribute('selected')) {
            el.setAttribute('selected', '');
          }
        });
      }
    }]);

    return ColumnViewCollection;
  }(SelectableCollection);

  /**
   * Copyright 2020 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   * Helper function to test whether event.target is explicitly marked as interactive.
   *
   * Interactive elements included in an Item should respond to keyboard events without the event being handled by the Item as well.
   *
   * @private
   */
  var isInteractiveTarget = function isInteractiveTarget(target) {
    return target.hasAttribute('coral-interactive') || target.closest('[coral-interactive]') !== null;
  };

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   Enumeration for {@link ColumnView} selection options.

   @typedef {Object} ColumnViewSelectionModeEnum

   @property {String} NONE
   None is default, selection of items does not happen based on click.
   @property {String} SINGLE
   Single selection mode, only one item per column can be selected.
   @property {String} MULTIPLE
   Multiple selection mode, multiple items per column can be selected.
   */
  var selectionMode$1 = {
    NONE: 'none',
    SINGLE: 'single',
    MULTIPLE: 'multiple'
  };

  var CLASSNAME$O = '_coral-MillerColumns';

  var scrollTo = function scrollTo(element, to, duration, scrollCallback) {
    if (duration <= 0) {
      if (scrollCallback) {
        scrollCallback();
      }

      return;
    }

    var difference = to - element.scrollLeft;
    var perTick = difference / duration * 10;
    window.setTimeout(function () {
      element.scrollLeft = element.scrollLeft + perTick;

      if (element.scrollLeft === to) {
        if (scrollCallback) {
          scrollCallback();
        }
      } else {
        scrollTo(element, to, duration - 10);
      }
    }, 10);
  };
  /**
   @class Coral.ColumnView
   @classdesc A ColumnView component to display and allow users to browse and select items in a dynamic tree structure
   (e.g. a filesystem or multi-level navigation).
   @htmltag coral-columnview
   @extends {HTMLElement}
   @extends {BaseComponent}
   */


  var ColumnView = /*#__PURE__*/function (_BaseComponent) {
    _inherits(ColumnView, _BaseComponent);

    var _super = _createSuper(ColumnView);

    /** @ignore */
    function ColumnView() {
      var _this;

      _classCallCheck(this, ColumnView);

      _this = _super.call(this); // Content zone

      _this._elements = {
        accessibilityState: _this.querySelector('span[handle="accessibilityState"]')
      };

      if (!_this._elements.accessibilityState) {
        // Templates
        template$x.call(_this._elements, {
          commons: commons
        });

        _this._elements.accessibilityState.removeAttribute('aria-hidden');

        _this._elements.accessibilityState.hidden = true;
      } // Events


      _this._delegateEvents({
        // Prevents text selection while selecting multiple items
        'global:keyup': '_onGlobalKeyUp',
        'global:keydown': '_onGlobalKeyDown',
        'key:up': '_onKeyUp',
        'key:down': '_onKeyDown',
        'key:right': '_onKeyRight',
        'key:left': '_onKeyLeft',
        'key:shift+up': '_onKeyShiftAndUp',
        'key:shift+down': '_onKeyShiftAndDown',
        'key:space': '_onKeySpace',
        'key:control+a': '_onKeyCtrlA',
        'key:command+a': '_onKeyCtrlA',
        'key:control+shift+a': '_onKeyCtrlShiftA',
        'key:command+shift+a': '_onKeyCtrlShiftA',
        'key:esc': '_onKeyCtrlShiftA',
        'capture:focus coral-columnview-item': '_onItemFocus',
        'mousedown coral-columnview-item': '_onItemMouseDown',
        'mouseup coral-columnview-item': '_onItemMouseUp',
        // column events
        'coral-columnview-column:_loaditems': '_onColumnLoadItems',
        'coral-columnview-column:_activeitemchanged': '_onColumnActiveItemChanged',
        'coral-columnview-column:_selecteditemchanged': '_onColumnSelectedItemChanged'
      }); // Defaults


      _this._oldActiveItem = null;
      _this._oldSelection = []; // default value of inner flag to process events

      _this._bulkSelectionChange = false; // initializes the mutation observer that used to detect when new items are added or removed

      _this._observer = new MutationObserver(_this._handleMutation.bind(_assertThisInitialized(_this)));

      _this._observer.observe(_assertThisInitialized(_this), {
        // only watch the childList, items will tell us if selected/value/content changes
        childList: true
      }); // Init the collection mutation observer


      _this.items._startHandlingItems(true);

      _this.columns._startHandlingItems(true);

      return _this;
    }
    /**
     Collection that holds all the columns inside the ColumnView.
      @type {ColumnViewCollection}
     @readonly
     */


    _createClass(ColumnView, [{
      key: "_onColumnActiveItemChanged",

      /** @private */
      value: function _onColumnActiveItemChanged(event) {
        // this is a private event and should not leave the column view
        event.stopImmediatePropagation(); // ignores event handling due to bulk select operation

        if (this._bulkSelectionChange) {
          return;
        }

        var column = event.target; // clears the internal selection cursor

        this._handleKeyboardMultiselect(null);

        this._bulkSelectionChange = true;

        if (!event.detail.activeItem) {
          // all items to the right must be removed. we do this at the end to be able to extract the values before
          // removing everything
          this._afterItemSelectedInColumn(column);
        } else {
          // when there is an active item, selection must not exist
          this.items._deselectAllExcept(); // we need to deactivate every item to the right of the new active item to keep a correct DOM representation


          var nextColumn = column.nextElementSibling;

          while (nextColumn) {
            // We ignore preview columns
            if (nextColumn.tagName === 'CORAL-COLUMNVIEW-COLUMN' && nextColumn.items) {
              nextColumn.items._deactivateAll();
            }

            nextColumn = nextColumn.nextElementSibling;
          }
        }

        this._bulkSelectionChange = false; // we trigger the appropiate events

        this._validateColumnViewChange();
      }
      /**
       Requests external data to be loaded.
        @emits {coral-columnview:loaditems}
        @private
       */

    }, {
      key: "_onColumnLoadItems",
      value: function _onColumnLoadItems(event) {
        // this is a private event and should not leave the column view
        event.stopImmediatePropagation();

        this._updateAriaLevel(event.target);

        this._ensureTabbableItem(); // triggers an event to indicate more data could be loaded


        this.trigger('coral-columnview:loaditems', {
          column: event.target,
          start: event.detail.start,
          item: event.detail.item
        });
      }
      /**
       Handle when first selectable item is added and make sure it is tabbable.
       @param {HTMLElement} [item]
       @private
       */

    }, {
      key: "_onItemAdd",
      value: function _onItemAdd() {
        var _this2 = this;

        window.requestAnimationFrame(function () {
          return _this2._ensureTabbableItem();
        });
      }
      /**
       Handle when item is removed, make sure that at least one element is tabbable, or if there are no items, and add listener to handle when item is added.
       @param {HTMLElement} [item]
       Item that was removed.
       @private
       */

    }, {
      key: "_onItemRemoved",
      value: function _onItemRemoved() {
        var _this3 = this;

        window.requestAnimationFrame(function () {
          return _this3._ensureTabbableItem();
        });
      }
      /* @private */

    }, {
      key: "_ensureTabbableItem",
      value: function _ensureTabbableItem() {
        this._vent.off('coral-collection:add', this._onItemAdd);

        this._vent.off('coral-collection:remove', this._onItemRemoved); // Ensures that item will receive focus


        if (!this.selectedItem && !this.activeItem) {
          var selectableItems = this.items._getSelectableItems(); // If there are no selectable items, stop listening for items being removed and start listening for the next item added.


          if (!selectableItems.length) {
            this._vent.off('coral-collection:remove', this._onItemRemoved);

            this._vent.on('coral-collection:add', this._onItemAdd);
          } else {
            // Otherwise, if there is a selectable item, make sure it has a tabIndex.
            selectableItems[0].tabIndex = 0; // Listen for item removal so that we can handle the edge case where all items have been removed.

            this._vent.on('coral-collection:remove', this._onItemRemoved);
          }
        } else if (this.selectedItem && this.selectedItem.tabIndex !== 0) {
          // If the selectedItem is not tabbable, make sure that it has tabIndex === 0
          this.selectedItem.tabIndex = 0;
        } else if (this.activeItem && this.activeItem.tabIndex !== 0) {
          // If the activeItem is not tabbable, make sure that it has tabIndex === 0
          this.activeItem.tabIndex = 0;
        }
      }
      /** @private */

    }, {
      key: "_onColumnSelectedItemChanged",
      value: function _onColumnSelectedItemChanged(event) {
        // this is a private event and should not leave the column view
        event.stopImmediatePropagation(); // ignores event handling due to bulk select operation

        if (this._bulkSelectionChange || this.selectionMode === selectionMode$1.NONE) {
          return;
        }

        this._bulkSelectionChange = true; // we need to deselect any other selection that is not part of the same column

        this._oldSelection.forEach(function (el) {
          if (event.detail.selection.indexOf(el) === -1) {
            el.removeAttribute('selected');
          }
        });

        this._bulkSelectionChange = false; // we trigger the appropiate events

        this._validateColumnViewChange();
      }
      /** @private */

    }, {
      key: "_onGlobalKeyUp",
      value: function _onGlobalKeyUp(event) {
        // removes the class to stop selection
        if (event.keyCode === 16 && !isInteractiveTarget(event.target)) {
          this.classList.remove('is-unselectable');
        }
      }
      /** @private */

    }, {
      key: "_onGlobalKeyDown",
      value: function _onGlobalKeyDown(event) {
        // adds a class that prevents the text selection, otherwise shift + click would select the text
        if (event.keyCode === 16 || !isInteractiveTarget(event.target)) {
          this.classList.add('is-unselectable');
        }
      }
      /** @private */

    }, {
      key: "_onKeyShiftAndUp",
      value: function _onKeyShiftAndUp(event) {
        var matchedTarget = this._getRealMatchedTarget(event); // don't select items when focus is within the preview


        if (matchedTarget.closest('coral-columnview-preview') || isInteractiveTarget(event.target)) {
          return;
        }

        event.preventDefault();

        if (this.selectionMode === selectionMode$1.NONE) {
          this._onKeyUp(event);

          return;
        } // using _oldSelection since it should be equivalent to this.items._getSelectedItems() but faster


        var oldSelectedItems = this._oldSelection;
        this._isKeyBoardMultiselect = true; // first make sure to select the active item as we want to multiselect

        if (oldSelectedItems.length === 0) {
          var activeItem = this.activeItem;

          if (activeItem) {
            activeItem.setAttribute('selected', '');
          }
        } // gets all the selected items of the active column. calling _getSelectedItems() will include the active item
        // if it was selected


        var selectedItems = this.items._getAllSelected(); // reference of the last selected item to know the direction of the selection while using the multiselection


        var lastSelected = this._lastSelected;
        var selectedItem; // when no previous selection is stored we need to initialize it with the current information

        if (!lastSelected) {
          selectedItem = selectedItems[0].previousElementSibling; // selects the item

          selectedItem.setAttribute('selected', '');
        } else if (lastSelected.item) {
          selectedItem = lastSelected.item; // we have reached the upper selection limit

          if (selectedItem.matches(':first-child')) {
            this._isKeyBoardMultiselect = false;
            return;
          }

          if (!lastSelected.direction || lastSelected.direction === 'up') {
            selectedItem = selectedItem.previousElementSibling;
            selectedItem.setAttribute('selected', '');
          } else {
            if (selectedItem !== lastSelected.firstSelectedItem) {
              selectedItem.removeAttribute('selected');
            } else {
              // switches the direction if this was the last item selected
              lastSelected.direction = 'up';
            }

            selectedItem = selectedItem.previousElementSibling;
            selectedItem.setAttribute('selected', '');
          }
        } // stores the reference and direction to be able to perform the multiple selection correctly


        this._lastSelected = {
          item: selectedItem,
          direction: lastSelected && lastSelected.direction ? lastSelected.direction : 'up',
          firstSelectedItem: lastSelected && lastSelected.firstSelectedItem ? lastSelected.firstSelectedItem : selectedItem.nextElementSibling
        };

        if (selectedItem && selectedItem !== document.activeElement) {
          selectedItem.focus();
        }

        this._isKeyBoardMultiselect = false;
      }
      /** @private */

    }, {
      key: "_onKeyShiftAndDown",
      value: function _onKeyShiftAndDown(event) {
        var matchedTarget = this._getRealMatchedTarget(event); // don't select items when focus is within the preview


        if (matchedTarget.closest('coral-columnview-preview') || isInteractiveTarget(event.target)) {
          return;
        }

        event.preventDefault();

        if (this.selectionMode === selectionMode$1.NONE) {
          this._onKeyDown(event);

          return;
        } // using _oldSelection since it should be equivalent to this.items._getSelectedItems() but faster


        var oldSelectedItems = this._oldSelection;
        this._isKeyBoardMultiselect = true; // first make sure to select the active item as we want to multiselect

        if (oldSelectedItems.length === 0) {
          var activeItem = this.activeItem;

          if (activeItem) {
            activeItem.setAttribute('selected', '');
          }
        } // gets all the selected items of the active column. calling _getSelectedItems() will include the active item
        // if it was selected


        var selectedItems = this.items._getAllSelected(); // reference of the last selected item to know the direction of the selection while using the multiselection


        var lastSelected = this._lastSelected;
        var selectedItem; // when no previous selection is stored we need to initialize it with the current information

        if (!lastSelected) {
          selectedItem = selectedItems[selectedItems.length - 1].nextElementSibling; // selects the item

          selectedItem.setAttribute('selected', '');
        } else if (lastSelected.item) {
          selectedItem = lastSelected.item; // we have reached the lower selection limit

          if (selectedItem.matches(':last-child')) {
            this._isKeyBoardMultiselect = false;
            return;
          }

          if (!lastSelected.direction || lastSelected.direction === 'down') {
            selectedItem = selectedItem.nextElementSibling;
            selectedItem.setAttribute('selected', '');
          } else {
            if (selectedItem !== lastSelected.firstSelectedItem) {
              selectedItem.removeAttribute('selected');
            } else {
              // switches the direction if this was the last item selected
              lastSelected.direction = 'down';
            }

            selectedItem = selectedItem.nextElementSibling;
            selectedItem.setAttribute('selected', '');
          }
        } // stores the reference and direction to be able to perform the multiple selection correctly


        this._lastSelected = {
          item: selectedItem,
          direction: lastSelected && lastSelected.direction ? lastSelected.direction : 'down',
          firstSelectedItem: lastSelected && lastSelected.firstSelectedItem ? lastSelected.firstSelectedItem : selectedItem.previousElementSibling
        };

        if (selectedItem && selectedItem !== document.activeElement) {
          selectedItem.focus();
        }

        this._isKeyBoardMultiselect = false;
      }
      /** @private */

    }, {
      key: "_onKeyUp",
      value: function _onKeyUp(event) {
        var matchedTarget = this._getRealMatchedTarget(event); // don't navigate items when focus is within the preview


        if (matchedTarget.closest('coral-columnview-preview') || isInteractiveTarget(event.target)) {
          return;
        }

        event.preventDefault(); // selection will win over active buttons, because they are the right most item. using _oldSelection since it
        // should be equivalent to this.items._getSelectedItems() but faster

        var selectedItems = this._oldSelection;
        var item;

        if (selectedItems.length !== 0) {
          var selectedItem = matchedTarget;
          item = selectedItem.previousElementSibling;

          if (!item) {
            item = selectedItem;
          }
        } // when there is no active item to select, we get the last item of the column. this way users can interact with
        // the column view when there is nothing selected or activated
        else if (this._oldActiveItem === null) {
            item = this.items._getLastSelectable();
          } else {
            item = this._oldActiveItem.previousElementSibling;
          } // we use click instead of selected to force the deselection of the other items


        if (item && item !== document.activeElement) {
          item.focus();

          if (this.selectionMode === selectionMode$1.NONE || selectedItems.length === 0 || // For use case in cascading schema editor,
          // where the focused item is not in the same column as the selected items,
          // we should activate the item so that coral-columnview:activeitemchange gets called.
          item.parentElement !== selectedItems[0].parentElement) {
            item.click();
          }
        }
      }
      /** @private */

    }, {
      key: "_onKeyDown",
      value: function _onKeyDown(event) {
        var matchedTarget = this._getRealMatchedTarget(event); // don't navigate items when focus is within the preview


        if (matchedTarget.closest('coral-columnview-preview') || isInteractiveTarget(event.target)) {
          return;
        }

        event.preventDefault(); // selection will win over active buttons, because they are the right most item. using _oldSelection since it
        // should be equivalent to this.items._getSelectedItems() but faster

        var selectedItems = this._oldSelection;
        var item;

        if (selectedItems.length !== 0) {
          var selectedItem = matchedTarget;
          item = selectedItem.nextElementSibling; // when

          if (!item) {
            item = matchedTarget;
          }
        } // when there is no active item to select, we get the first item of the column. this way users can interact with
        // the column view when there is nothing selected or activated
        else if (this._oldActiveItem === null) {
            item = this.items._getFirstSelectable();
          } else {
            item = this._oldActiveItem.nextElementSibling;
          } // we use click instead of selected to force the deselection of the other items


        if (item && item !== document.activeElement) {
          item.focus();

          if (this.selectionMode === selectionMode$1.NONE || selectedItems.length === 0 || // For use case in cascading schema editor,
          // where the focused item is not in the same column as the selected items,
          // we should activate the item so that coral-columnview:activeitemchange gets called.
          item.parentElement !== selectedItems[0].parentElement) {
            item.click();
          }
        }
      }
      /** @private */

    }, {
      key: "_onKeyRight",
      value: function _onKeyRight(event) {
        var _this4 = this;

        var matchedTarget = this._getRealMatchedTarget(event);

        if (matchedTarget.variant !== ColumnView.Item.variant.DRILLDOWN) {
          return false;
        }

        if (isInteractiveTarget(event.target)) {
          return;
        }

        event.preventDefault(); // we can only navigate right when there is a column on the right side to navigate to

        var nextColumn; // using _oldSelection since it should be equivalent to this.items._getSelectedItems() but faster

        var selectedItems = this._oldSelection; // when there is an active item, we use the item containing the active item as reference

        if (matchedTarget) {
          nextColumn = matchedTarget.closest('coral-columnview-column').nextElementSibling;
        } // otherwise when there is selection, we use the item containing the selected items as reference
        else if (selectedItems.length !== 0) {
            nextColumn = selectedItems[0].closest('coral-columnview-column').nextElementSibling;
          }

        if (nextColumn && nextColumn.tagName === 'CORAL-COLUMNVIEW-COLUMN') {
          // we need to make sure the column is initialized
          commons.ready(nextColumn, function () {
            return _this4._focusAndActivateFirstSelectableItem(nextColumn);
          });
        }
      }
      /** @private */

    }, {
      key: "_onKeyLeft",
      value: function _onKeyLeft(event) {
        if (isInteractiveTarget(event.target)) {
          return;
        }

        event.preventDefault(); // we can only navigate left when there is a column on the left side to navigate to

        var previousColumn; // using _oldSelection since it should be equivalent to this.items._getSelectedItems() but faster

        var selectedItems = this._oldSelection; // when there is selection, we use the previous column as a reference

        if (selectedItems.length !== 0) {
          previousColumn = selectedItems[0].closest('coral-columnview-column').previousElementSibling;
        } // otherwise we use the activeItems as a reference
        else if (this.activeItem) {
            var col = this.activeItem.closest('coral-columnview-column');
            previousColumn = event.target.closest('coral-columnview-preview') ? col : col.previousElementSibling;
          }

        if (previousColumn && previousColumn.tagName === 'CORAL-COLUMNVIEW-COLUMN') {
          // we need to make sure the column is initialized
          var activeDescendant = previousColumn.activeItem || previousColumn.items._getFirstSelected() || previousColumn.items._getFirstSelectable();

          if (activeDescendant && activeDescendant !== document.activeElement) {
            activeDescendant.focus();

            if (this.selectionMode === selectionMode$1.NONE || selectedItems.length === 0) {
              activeDescendant.click();
            }
          }
        }
      }
      /** @private */

    }, {
      key: "_onKeySpace",
      value: function _onKeySpace(event) {
        var matchedTarget = this._getRealMatchedTarget(event); // don't select item when focus is within the preview


        if (matchedTarget.closest('coral-columnview-preview') || isInteractiveTarget(event.target)) {
          return;
        }

        event.preventDefault(); // using _oldSelection since it should be equivalent to this.items._getSelectedItems() but faster

        var selectedItems = this._oldSelection;
        var activeDescendant; // when there is a selection, we need to activate the first item of the selection

        if (selectedItems.length !== 0) {
          activeDescendant = matchedTarget;

          if (activeDescendant.hasAttribute('selected', '')) {
            if (selectedItems.length === 1) {
              activeDescendant.setAttribute('active', '');
            } else {
              activeDescendant.removeAttribute('selected', '');
            }
          } else {
            activeDescendant.setAttribute('selected', '');
          }
        } else {
          var activeItem = this.activeItem || matchedTarget; // toggles the selection between active and selected

          if (activeItem && this.selectionMode !== selectionMode$1.NONE) {
            // select the item
            activeItem.setAttribute('selected', '');
            activeDescendant = activeItem;
          }
        }
      }
      /** @private */

    }, {
      key: "_onKeyCtrlA",
      value: function _onKeyCtrlA(event) {
        var matchedTarget = this._getRealMatchedTarget(event); // don't select item when focus is within the preview


        if (matchedTarget.closest('coral-columnview-preview') || isInteractiveTarget(event.target)) {
          return;
        }

        event.preventDefault();

        if (this.selectionMode === selectionMode$1.MULTIPLE) {
          var currentColumn = matchedTarget.closest('coral-columnview-column');

          currentColumn.items._selectAll();
        } else if (this.selectionMode === selectionMode$1.SINGLE) {
          if (!matchedTarget.hasAttribute('selected')) {
            matchedTarget.setAttribute('selected', '');
          }
        }
      }
      /** @private */

    }, {
      key: "_onKeyCtrlShiftA",
      value: function _onKeyCtrlShiftA(event) {
        var matchedTarget = this._getRealMatchedTarget(event); // don't select item when focus is within the preview


        if (matchedTarget.closest('coral-columnview-preview') || isInteractiveTarget(event.target)) {
          return;
        }

        event.preventDefault();

        if (this.selectionMode !== selectionMode$1.NONE) {
          var currentColumn = matchedTarget.closest('coral-columnview-column');

          currentColumn.items._deselectAndDeactivateAllExcept(matchedTarget);

          if (!matchedTarget.hasAttribute('active')) {
            matchedTarget.setAttribute('active', '');
          }
        }
      }
      /** @private */

    }, {
      key: "_onItemFocus",
      value: function _onItemFocus(event) {
        if (isInteractiveTarget(event.target)) {
          return;
        }

        var matchedTarget = this._getRealMatchedTarget(event);

        if (!this.activeItem && !this._oldSelection.length && !matchedTarget._flagMouseDown) {
          matchedTarget.setAttribute('active', '');
        }

        this.items._getSelectableItems().forEach(function (item) {
          item.tabIndex = item === matchedTarget ? 0 : -1;
        });

        if (matchedTarget.contains(document.activeElement)) {
          matchedTarget.focus();
        }
      }
      /** @ignore */

    }, {
      key: "_onItemMouseDown",
      value: function _onItemMouseDown(event) {
        if (isInteractiveTarget(event.target)) {
          return;
        }

        var matchedTarget = this._getRealMatchedTarget(event);

        matchedTarget._flagMouseDown = true;
      }
      /** @ignore */

    }, {
      key: "_onItemMouseUp",
      value: function _onItemMouseUp(event) {
        if (isInteractiveTarget(event.target)) {
          return;
        }

        var matchedTarget = this._getRealMatchedTarget(event);

        delete matchedTarget._flagMouseDown;
      }
      /** @ignore */

    }, {
      key: "_updateAriaLevel",
      value: function _updateAriaLevel(column) {
        var colIndex = this.columns.getAll().indexOf(column);
        var level = colIndex + 1;

        if (column.items) {
          column.items.getAll().filter(function (item, index) {
            item.setAttribute('aria-posinset', index + 1);
            item.setAttribute('aria-setsize', column.items.length);
            return !item.hasAttribute('aria-level');
          }).forEach(function (item) {
            item.setAttribute('aria-level', level);
          });
        } // root column has role="presentation"


        if (colIndex === 0) {
          column.setAttribute('role', 'presentation'); // and should not be labeled.

          return;
        } // Make sure the column group has a label so that it can be navigated with VoiceOver


        if (!column.hasAttribute('aria-labelledby')) {
          if (!column.hasAttribute('aria-label')) {
            column.setAttribute('aria-label', this.getAttribute('aria-label') || 'â¦');
          }
        } else if (column.getAttribute('aria-label') === (this.getAttribute('aria-label') || 'â¦')) {
          column.removeAttribute('aria-label');
        }
      }
      /** @private */

    }, {
      key: "_arraysAreDifferent",
      value: function _arraysAreDifferent(selection, oldSelection) {
        var diff = [];

        if (oldSelection.length === selection.length) {
          diff = oldSelection.filter(function (item) {
            return selection.indexOf(item) === -1;
          });
        } // since we guarantee that they are arrays, we can start by comparing their size


        return oldSelection.length !== selection.length || diff.length !== 0;
      }
      /** @private */

    }, {
      key: "_handleKeyboardMultiselect",
      value: function _handleKeyboardMultiselect(newSelectedItem) {
        if (!this._isKeyBoardMultiselect) {
          this._lastSelected = undefined; // if there is a new selected item save this (but without direction info)

          if (newSelectedItem) {
            this._lastSelected = {
              item: newSelectedItem,
              direction: null,
              firstSelectedItem: newSelectedItem
            };
          }
        }
      }
      /**
       Scrolls the given {@link Coral.ColumnView.Column} into view.
        @param {HTMLElement} column
       The column that needs to be scrolled into view.
       @param {Boolean} clearEmptyColumns
       Remove empty columns once animation is done.
       @param {Boolean} triggerEvent
        @private
       */

    }, {
      key: "_scrollColumnIntoView",
      value: function _scrollColumnIntoView(column, clearEmptyColumns, triggerEvent) {
        var _this5 = this;

        // @todo: improve animation effect when key is kept press
        var left = 0;
        var duration; // we return if the column is not inside the current column view

        if (!this.contains(column)) {
          return;
        } // make sure to clear columns next to this column if animation is done


        var completeCallback = function completeCallback() {
          if (clearEmptyColumns) {
            _this5._removeEmptyColumnsWithSmoothTransition(triggerEvent);
          }
        }; // scroll right to the given column


        if (column.getBoundingClientRect().left + column.offsetWidth >= this.offsetWidth) {
          var next = column.nextElementSibling;

          while (next) {
            next.parentNode.removeChild(next);
            next = column.nextElementSibling;
          }

          left = this.scrollWidth - this.offsetWidth;
          duration = left - this.scrollLeft;
          scrollTo(this, left, duration, completeCallback);
        } else if (clearEmptyColumns) {
          this._removeEmptyColumnsWithSmoothTransition(triggerEvent);
        }
      }
      /**
       Handling of the column view after selecting an item.
        @param {HTMLElement} column
        @private
       */

    }, {
      key: "_afterItemSelectedInColumn",
      value: function _afterItemSelectedInColumn(column) {
        // @todo: emptying the columns allows them to be queried
        this._emptyColumnsNextToColumn(column);

        this._scrollColumnIntoView(column, true, true);
      }
      /**
       Empties all the columns to the right of the provided column.
        @param {HTMLElement} column
        @private
       */

    }, {
      key: "_emptyColumnsNextToColumn",
      value: function _emptyColumnsNextToColumn(column) {
        if (column !== null) {
          var next = column.nextElementSibling;

          while (next && next.innerHTML.length) {
            next.innerHTML = '';
            next = next.nextElementSibling;
          }
        }
      }
      /**
       Remove all empty columns with a smooth transition. Optionally the navigate event is triggered when all the extra
       columns are removed from the DOM.
        @param {Boolean} triggerEvent
       Whether the navigate event must be triggered.
        @private
       */

    }, {
      key: "_removeEmptyColumnsWithSmoothTransition",
      value: function _removeEmptyColumnsWithSmoothTransition(triggerEvent) {
        var _this6 = this;

        // fade width of empty items to 0 before removing the columns (for better usability while navigating)
        var emptyColumns = Array.prototype.filter.call(this.querySelectorAll('coral-columnview-column, coral-columnview-preview'), function (el) {
          return !el.firstChild;
        });

        if (emptyColumns.length) {
          emptyColumns.forEach(function (column, i) {
            column.style.visibility = 'hidden';
            column.classList.add('is-collapsing');
            commons.transitionEnd(column, function () {
              column.remove();

              if (i === emptyColumns.length - 1 && triggerEvent) {
                _this6._validateNavigation(_this6.columns.last());
              }
            });
            column.style.width = 0;
          });
        } else if (triggerEvent) {
          this._validateNavigation(this.columns.last());
        }
      }
      /** @private */

    }, {
      key: "_triggerCollectionEvents",
      value: function _triggerCollectionEvents(addedNodes, removedNodes) {
        var item;
        var addedNodesCount = addedNodes.length;

        for (var i = 0; i < addedNodesCount; i++) {
          item = addedNodes[i];

          if (this.activeItem) {
            // @a11y add aria-owns attribute to active item to express relationship of added column to the active item
            this.activeItem.setAttribute('aria-owns', item.id); // @a11y column or preview should be labelled by active item

            item.setAttribute('aria-labelledby', this.activeItem.content.id); // @a11y preview should provide description for active item

            if (item.tagName === 'CORAL-COLUMNVIEW-PREVIEW') {
              this.activeItem.setAttribute('aria-describedby', item.id);
            }
          }

          if (item.tagName === 'CORAL-COLUMNVIEW-COLUMN') {
            // we use the property since the item may not be ready
            item.setAttribute('_selectionmode', this.selectionMode);
            this.trigger('coral-collection:add', {
              item: item
            });

            this._updateAriaLevel(item);
          }
        } // @todo: check if special handling is needed when selected column is removed


        var removedNodesCount = removedNodes.length;

        for (var j = 0; j < removedNodesCount; j++) {
          item = removedNodes[j]; // @todo: should I handle it specially if it was selected? should a selection and active event be triggered?

          if (item.tagName === 'CORAL-COLUMNVIEW-COLUMN') {
            this.trigger('coral-collection:remove', {
              item: item
            });
          }
        }
      }
      /** @private */

    }, {
      key: "_setStateFromDOM",
      value: function _setStateFromDOM() {
        // @todo: should I trigger change events?
        // initial state of the columnview
        this._oldActiveItem = this.activeItem;
        this._oldSelection = this.selectedItems;

        this._ensureTabbableItem();

        if (this.columns) {
          var columns = this.columns.getAll();
          var self = this;
          columns.forEach(function (column) {
            self._updateAriaLevel(column);
          });
        }
      }
      /** @private */

    }, {
      key: "_handleMutation",
      value: function _handleMutation(mutations) {
        var mutationsCount = mutations.length;

        for (var i = 0; i < mutationsCount; i++) {
          var mutation = mutations[i]; // we handle the collection events

          this._triggerCollectionEvents(mutation.addedNodes, mutation.removedNodes);
        } // sets the internal state based on the existing columns


        this._setStateFromDOM();
      }
      /**
       Determines if something of the internal state of the component has changed. Active item event is always triggered
       first and then the selection event.
        @private
       */

    }, {
      key: "_validateColumnViewChange",
      value: function _validateColumnViewChange() {
        // we evaluate first the active event since we always need to trigger active first and then selection
        var activeItem = this.activeItem;
        var oldActiveItem = this._oldActiveItem; // same column events are only triggered if the active item changed, otherwise they are ignored

        if (activeItem !== oldActiveItem) {
          this.trigger('coral-columnview:activeitemchange', {
            activeItem: activeItem,
            oldActiveItem: oldActiveItem
          }); // we cache the old active item to be able to report correct change events

          this._oldActiveItem = activeItem;
        } // when there is no selection we avoid triggering any change event but we do not stop items from having the
        // selected attribute


        if (this.selectionMode === selectionMode$1.NONE) {
          return;
        }

        var newSelection = this.selectedItems;
        var oldSelection = this._oldSelection || []; // use first newly selected item for new selection

        var newSelectedItems = newSelection.filter(function (item) {
          return oldSelection.indexOf(item) === -1;
        });

        this._handleKeyboardMultiselect(newSelectedItems.length > 0 ? newSelectedItems[0] : null);

        if (this._arraysAreDifferent(newSelection, oldSelection)) {
          this.trigger('coral-columnview:change', {
            selection: newSelection,
            oldSelection: oldSelection
          }); // changes the old selection array since we selected something new

          this._oldSelection = newSelection; // announce the selection state for the focused item

          this._announceActiveElementState();
        }
      }
      /**
       Triggers the navigation event. Navigation would happen when a) a new column is added, and it is ready to be
       used or b) columns are removed and the active changed. In case the column is actually a preview column, the event
       will only be triggered when there is no selection (meanning a real navigation was performed).
        @param {HTMLElement} column
       Last column of the ColumnView.
        @emits {coral-columnview:navigate}
        @private
       */

    }, {
      key: "_validateNavigation",
      value: function _validateNavigation(column) {
        // we use _oldSelection because it is faster
        if (column.tagName === 'CORAL-COLUMNVIEW-PREVIEW' && this._oldSelection.length !== 0) {
          return;
        }

        this.trigger('coral-columnview:navigate', {
          activeItem: this.activeItem,
          column: column
        });
      }
      /* @private */

    }, {
      key: "_announceActiveElementState",
      value: function _announceActiveElementState() {
        var _this7 = this;

        // @a11y Add live region element to ensure announcement of selected state
        var accessibilityState = this._elements.accessibilityState; // @a11y accessibility state string should announce in document lang, rather than item lang.

        accessibilityState.setAttribute('lang', i18n.locale); // @a11y append live region content element

        if (!this.contains(accessibilityState)) {
          this.insertBefore(accessibilityState, this.firstChild);
        } // utility method to clean up accessibility state


        function resetAccessibilityState() {
          accessibilityState.hidden = true;
          accessibilityState.setAttribute('aria-live', 'off');
          accessibilityState.innerHTML = '';
        }

        resetAccessibilityState();

        if (this._addTimeout || this._removeTimeout) {
          clearTimeout(this._addTimeout);
          clearTimeout(this._removeTimeout);
        } // we use setTimeout instead of nextFrame to give screen reader
        // more time to respond to live region update in order to announce
        // complete text content when the state changes.


        this._addTimeout = window.setTimeout(function () {
          var activeElement = document.activeElement.closest('coral-columnview-item') || document.activeElement;

          if (!_this7.contains(activeElement) || activeElement.tagName !== 'CORAL-COLUMNVIEW-ITEM') {
            return;
          }

          var span = document.createElement('span');
          var contentSpan = document.createElement('span');
          var lang = !activeElement.hasAttribute('lang') && activeElement.closest('[lang]') ? activeElement.closest('[lang]').getAttribute('lang') : activeElement.getAttribute('lang');

          if (lang && lang !== i18n.locale) {
            contentSpan.setAttribute('lang', lang);
          }

          contentSpan.innerText = activeElement._elements.content.innerText;
          span.appendChild(contentSpan);
          span.appendChild(document.createTextNode(i18n.get(activeElement.selected ? ', checked' : ', unchecked')));
          accessibilityState.hidden = false;
          accessibilityState.setAttribute('aria-live', 'assertive');
          accessibilityState.appendChild(span); // give screen reader 2 secs before clearing the live region, to provide enough time for announcement

          _this7._removeTimeout = window.setTimeout(function () {
            resetAccessibilityState();
            _this7._elements.accessibilityState = accessibilityState.parentNode.removeChild(accessibilityState);
          }, 2000);
        }, 20);
      }
      /**
       * Helper function to extract the correct matchedTarget from the event.
       *
       * Tests can interact with ColumnView directly where the key events are triggered on
       * the ColumnView itself. In that case the event.matchedTarget point to the ColumnView
       * instead of the ColumnViewItem, in other word the active or selected element.
       *
       * @private
       **/

    }, {
      key: "_getRealMatchedTarget",
      value: function _getRealMatchedTarget(event) {
        if (event.matchedTarget.nodeName !== 'CORAL-COLUMNVIEW') {
          return event.matchedTarget;
        }

        if (event.matchedTarget.contains(document.activeElement) && document.activeElement.nodeName === 'CORAL-COLUMNVIEW-ITEM') {
          return document.activeElement;
        }

        if (event.matchedTarget.selectedItem) {
          return event.matchedTarget.selectedItem;
        }

        if (event.matchedTarget.activeItem) {
          return event.matchedTarget.activeItem;
        }
      }
    }, {
      key: "_focusAndActivateFirstSelectableItem",
      value: function _focusAndActivateFirstSelectableItem(column) {
        var item;
        var selectedItems = this.selectedItems;

        if (column.items) {
          item = column.items._getFirstSelectable();
        } else if (column.tagName === 'CORAL-COLUMNVIEW-PREVIEW') {
          item = selectedItems[0] || this.activeItem;
        }

        if (item && item !== document.activeElement) {
          item.focus();

          if (this.selectionMode === selectionMode$1.NONE || this._oldSelection.length === 0 || selectedItems.length === 0 || // For use case in cascading schema editor,
          // where the focused item is not in the same column as the selected items,
          // we should activate the item so that coral-columnview:activeitemchange gets called.
          item.parentElement !== selectedItems[0].parentElement) {
            item.click();
          }
        }
      }
      /** @ignore */

    }, {
      key: "focus",
      value: function focus() {
        // selected items go first because there is no active item in a column with selection
        var item = this.selectedItems[0] || this.activeItem;

        if (item && item !== document.activeElement) {
          item.focus();
        }
      }
      /**
       Sets the next column given a reference column. This will handle cleaning the DOM and removing any columns as
       required.
        @param {HTMLElement} newColumn
       The new column to add to the column view. It will be placed next to the <code>referenceColumn</code> if
       provided.
       @param {HTMLElement} referenceColumn
       The column that will be used as a reference to place the new column. This column needs to be already inside the
       DOM.
       @param {Boolean} [scrollToColumn = true]
       Whether the columnview show scroll to have the <code>newColumn</code> visible.
        @emits {coral-columnview:navigate}
       */

    }, {
      key: "setNextColumn",
      value: function setNextColumn(newColumn, referenceColumn, scrollToColumn) {
        var _this8 = this;

        scrollToColumn = typeof scrollToColumn === 'undefined' || scrollToColumn;
        var column = referenceColumn || null;
        var columnReplacedContainedFocus = false; // handles the case where the first column needs to be added

        if (column === null || !this.contains(column)) {
          this.appendChild(newColumn);
        } else {
          var nextColumn = column.nextElementSibling;

          if (nextColumn) {
            columnReplacedContainedFocus = nextColumn.contains(document.activeElement);

            this._emptyColumnsNextToColumn(column);

            var before = nextColumn.nextElementSibling;
            this.removeChild(nextColumn);
            this.insertBefore(newColumn, before);
          } else {
            this.appendChild(newColumn);
          }
        } // if we want to scroll to it, we need for it to be ready due to measurements


        commons.ready(newColumn, function () {
          if (scrollToColumn) {
            // event is not triggered because it is handled separately
            _this8._scrollColumnIntoView(newColumn, true, false);
          } // we notify that the columnview navigated and it is ready to be used


          _this8._validateNavigation(newColumn); // if the column the newColumn replaces contained focus, restore focus to an item in the newColumn


          if (columnReplacedContainedFocus && !newColumn.contains(document.activeElement)) {
            _this8._focusAndActivateFirstSelectableItem(newColumn);
          }
        });
      }
      /**
       Returns {@link ColumnView} selection options.
        @return {ColumnViewSelectionModeEnum}
       */

    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(ColumnView.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$O); // @a11y

        this.setAttribute('role', 'tree'); // @a11y: the columnview needs to be focusable to handle a11y properly

        this.tabIndex = -1; // @a11y: the columnview should be labelled so that its entire content
        // is not read as its accessibility name

        if (!this.hasAttribute('aria-label') && !this.hasAttribute('aria-labelledby')) {
          this.setAttribute('aria-label', i18n.get('Column View'));
        } // Default reflect attributes


        if (!this._selectionMode) {
          this._selectionMode = selectionMode$1.NONE;
        } // no need to wait for the mutation observers


        this._setStateFromDOM();
      }
      /**
       Triggered when additional items can be loaded into the {@link ColumnView}. This will happen when the current column can
       still hold more items, when the user scrolls down the current column or when a new column needs to be loaded. If
       <code>preventDefault()</code> is called, then a loading indicator will be shown.
       {@link ColumnViewColumn#loading} should be set to false to indicate that the data has been successfully
       loaded.
        @typedef {CustomEvent} coral-columnview:loaditems
        @property {ColumnViewColumn} detail.column
       The column that is requesting more items. While doing pagination, it will become the target of the loaded items.
       @property {Number} detail.start
       Indicates the current amount of items in the <code>column</code> to do pagination. If <code>item</code> is
       available, start will be 0 to denote that the column should be loaded from the start.
       @property {ColumnViewItem} detail.item
       The item that initialized the load. If item is provided, it means that a new column needs to be added after
       the load is performed. In this scenario, <code>column</code> will be refer to the column that holds the item.
       */

      /**
       Triggered when the selection inside the {@link ColumnViewColumn} changes. In case both the selection and the active item change,
       the <code>coral-columnview:activeitemchange</code> will be triggered first.
        @typedef {CustomEvent} coral-columnview:change
        @property {ColumnViewColumn} detail.column
       The column whose selection changed.
       @property {ColumnViewItem|Array.<ColumnViewItem>} detail.selection
       The new selection of the Column.
       @property {ColumnViewItem|Array.<ColumnViewItem>} detail.oldSelection
       The old selection of the Column.
       */

      /**
       Triggered when the active item of the {@link ColumnViewColumn} changes.
        @typedef {CustomEvent} coral-columnview:activeitemchange
        @property {ColumnViewColumn} detail.column
       The column whose active item has changed.
       @property {ColumnViewItem} detail.activeItem
       The currently active item of the column.
       @property {ColumnViewItem} detail.oldActiveItem
       The item of the column that was active before.
       */

      /**
       Triggered when the {@link ColumnView} navigation is complete and the new columns are ready.
        @typedef {CustomEvent} coral-columnview:navigate
        @property {ColumnViewColumn} detail.column
       The last Column of the ColumnView that is used to determine the path. If the navigate was triggered because a
       new {@link ColumnViewColumn} was added, then it will match that column. In case the path was
       reduced, the column will match the last column.
       @property {ColumnViewItem} detail.activeItem
       The currently active item of the ColumnView.
       */

    }, {
      key: "columns",
      get: function get() {
        // constructs the collection on first request
        if (!this._columns) {
          this._columns = new ColumnViewCollection({
            host: this,
            itemTagName: 'coral-columnview-column'
          });
        }

        return this._columns;
      }
      /**
       Collection used to represent the coral-columnview-item across all columns.
        @type {ColumnViewCollection}
       @readonly
        @private
       */

    }, {
      key: "items",
      get: function get() {
        // constructs the collection on first request
        if (!this._items) {
          this._items = new ColumnViewCollection({
            host: this,
            itemTagName: 'coral-columnview-item'
          });
        }

        return this._items;
      }
      /**
       Selection mode of the ColumnView. See {@link ColumnViewSelectionModeEnum}.
        @type {String}
       @default ColumnViewSelectionModeEnum.NONE
       @htmlattribute selectionmode
       @htmlattributereflected
       */

    }, {
      key: "selectionMode",
      get: function get() {
        return this._selectionMode || selectionMode$1.NONE;
      },
      set: function set(value) {
        var _this9 = this;

        value = transform.string(value).toLowerCase();
        this._selectionMode = validate.enumeration(selectionMode$1)(value) && value || selectionMode$1.NONE;

        this._reflectAttribute('selectionmode', this._selectionMode); // propagates the selection mode to the columns


        this.columns.getAll().forEach(function (item) {
          item.setAttribute('_selectionmode', _this9._selectionMode);
        });
        this.classList.remove("".concat(CLASSNAME$O, "--selection"));

        if (this._selectionMode !== selectionMode$1.NONE) {
          this.classList.add("".concat(CLASSNAME$O, "--selection"));
        } // @a11y


        this.setAttribute('aria-multiselectable', this._selectionMode === selectionMode$1.MULTIPLE);
      }
      /**
       First selected item of the ColumnView.
        @type {HTMLElement}
       @readonly
       */

    }, {
      key: "selectedItem",
      get: function get() {
        return this.selectionMode !== selectionMode$1.NONE ? this.items._getFirstSelected() : null;
      }
      /**
       Array containing the set selected items. The items will match only one column since selection across columns is
       not allowed.
        @type {Array.<HTMLElement>}
       @readonly
       */

    }, {
      key: "selectedItems",
      get: function get() {
        return this.selectionMode !== selectionMode$1.NONE ? this.items._getAllSelected() : [];
      }
      /**
       Active Item that corresponds to the last item in the path.
        @type {HTMLElement}
       @readonly
       */

    }, {
      key: "activeItem",
      get: function get() {
        return this.items._getAllActive().pop() || null;
      }
    }], [{
      key: "selectionMode",
      get: function get() {
        return selectionMode$1;
      }
    }, {
      key: "_attributePropertyMap",
      get: function get() {
        return commons.extend(_get(_getPrototypeOf(ColumnView), "_attributePropertyMap", this), {
          selectionmode: 'selectionMode'
        });
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(ColumnView), "observedAttributes", this).concat(['selectionmode']);
      }
    }]);

    return ColumnView;
  }(BaseComponent(HTMLElement));

  var CLASSNAME$P = '_coral-MillerColumns-item'; // The number of milliseconds for which scroll events should be debounced.

  var SCROLL_DEBOUNCE$2 = 100; // Height if every item to avoid using offsetHeight during calculations.

  var ITEM_HEIGHT = 40; // Flag to check if window load was called

  var WINDOW_LOAD = false;
  window.addEventListener('load', function () {
    WINDOW_LOAD = true;
  });
  /**
   @class Coral.ColumnView.Column
   @classdesc A ColumnView Column component
   @htmltag coral-columnview-column
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var ColumnViewColumn = /*#__PURE__*/function (_BaseComponent) {
    _inherits(ColumnViewColumn, _BaseComponent);

    var _super = _createSuper(ColumnViewColumn);

    /** @ignore */
    function ColumnViewColumn() {
      var _this;

      _classCallCheck(this, ColumnViewColumn);

      _this = _super.call(this); // Events

      _this._delegateEvents({
        // we need to use capture as scroll events do not bubble
        'capture:scroll coral-columnview-column-content': '_onContentScroll',
        'click coral-columnview-column-content': '_onColumnContentClick',
        // item interaction
        'click coral-columnview-item': '_onItemClick',
        'click [coral-columnview-itemselect]': '_onItemSelectClick',
        // item events
        'coral-columnview-item:_activechanged coral-columnview-item': '_onItemActiveChange',
        'coral-columnview-item:_selectedchanged coral-columnview-item': '_onItemSelectedChange'
      }); // Content zone


      _this._elements = {
        content: _this.querySelector('coral-columnview-column-content') || document.createElement('coral-columnview-column-content')
      }; // default values

      _this._bulkSelectionChange = false;
      _this._oldSelection = [];
      _this._oldActiveItem = null; // cache bound event handler functions

      _this._onDebouncedScroll = _this._onDebouncedScroll.bind(_assertThisInitialized(_this));
      _this._toggleItemSelection = _this._toggleItemSelection.bind(_assertThisInitialized(_this));
      _this._observer = new MutationObserver(_this._handleMutation.bind(_assertThisInitialized(_this))); // items outside the scroll area are not supported

      _this._observer.observe(_this._elements.content, {
        // only watch the childList, items will tell us if selected/value/content changes
        childList: true
      }); // Init the collection mutation observer


      _this.items._startHandlingItems(true);

      return _this;
    }
    /**
     The current active item.
      @type {HTMLElement}
     @readonly
     @default null
     */


    _createClass(ColumnViewColumn, [{
      key: "_onItemClick",

      /** @private */
      value: function _onItemClick(event) {
        if (isInteractiveTarget(event.target)) {
          return;
        } // since transform will kill the modification, we trigger the event manually


        if (event.matchedTarget.hasAttribute('active')) {
          // directly calls the event since setting the attribute will not trigger an event
          this._onItemActiveChange(event);
        } else {
          // sets the item as active. while handling mouse interaction, items are not toggled
          event.matchedTarget.active = true;
        }
      }
    }, {
      key: "_toggleItemSelection",
      value: function _toggleItemSelection(item) {
        item[this._selectionMode !== selectionMode$1.NONE ? 'setAttribute' : 'removeAttribute']('_selectable', '');
      }
      /** @private */

    }, {
      key: "_onItemSelectClick",
      value: function _onItemSelectClick(event) {
        if (this._selectionMode && this._selectionMode !== selectionMode$1.NONE) {
          // stops propagation so that active is not called as well
          event.stopPropagation();
          var item = event.matchedTarget.parentElement; // toggles the selection of the item

          var isSelected = item.hasAttribute('selected'); // Handle multi-selection with shiftKey

          if (!isSelected && event.shiftKey && this._selectionMode === selectionMode$1.MULTIPLE) {
            var lastSelectedItem = this._lastSelectedItems[this._lastSelectedItems.length - 1];

            if (lastSelectedItem) {
              var items = this.items.getAll();
              var lastSelectedItemIndex = items.indexOf(lastSelectedItem);
              var selectedItemIndex = items.indexOf(item); // true : selection goes up, false : selection goes down

              var direction = selectedItemIndex < lastSelectedItemIndex;
              var selectionRange = [];
              var selectionIndex = lastSelectedItemIndex; // Retrieve all items in the range

              while (selectedItemIndex !== selectionIndex) {
                selectionIndex = direction ? selectionIndex - 1 : selectionIndex + 1;
                selectionRange.push(items[selectionIndex]);
              } // Select all items in the range silently


              selectionRange.forEach(function (rangeItem) {
                // Except for item which is needed to trigger the selection change event
                if (rangeItem !== item) {
                  rangeItem.set('selected', true, true);
                }
              });
            }
          }

          item[isSelected ? 'removeAttribute' : 'setAttribute']('selected', ''); // if item was selected, make it active

          if (isSelected && !this._lastSelectedItems.length) {
            item.setAttribute('active', '');
          }
        }
      }
      /**
       Handles the item activation, this causes the current item to get active and sets the next column to the item's
       src.
        @private
       */

    }, {
      key: "_onItemActiveChange",
      value: function _onItemActiveChange(event) {
        // we stop propagation since it is a private event
        event.stopImmediatePropagation(); // ignores event handling due to bulk select operation

        if (this._bulkSelectionChange) {
          return;
        }

        var item = event.matchedTarget;
        this._bulkSelectionChange = true; // clears the selection and keeps the item active. this force only 1 item to be active per column

        this.items._deselectAndDeactivateAllExcept(item);

        this._bulkSelectionChange = false; // we check if the selection requires an event to be triggered

        this._validateColumnChange(item); // loads data using the item as the activator and 0 as the start since it is a new column


        this._loadItems(0, item);
      }
      /**
       Handles selecting multiple items in the same column. Selection could result in none, a single or multiple selected
       items.
        @private
       */

    }, {
      key: "_onItemSelectedChange",
      value: function _onItemSelectedChange(event) {
        // we stop propagation since it is a private event
        event.stopImmediatePropagation(); // item that was selected

        var item = event.target;
        var isSelected = item.selected;

        if (isSelected) {
          // Remember the last selected item
          this._lastSelectedItems.push(item);
        } else {
          var removedItemIndex = this._lastSelectedItems.indexOf(item);

          if (removedItemIndex !== -1) {
            this._lastSelectedItems = this._lastSelectedItems.splice(removedItemIndex, 1);
          }
        } // ignores event handling due to bulk select operation


        if (this._bulkSelectionChange) {
          return;
        } // when the item is selected, we need to enforce the selection mode


        if (isSelected) {
          this._bulkSelectionChange = true; // when there is selection, no item can be active

          this.items._deactivateAll(); // enforces the selection mode


          if (this._selectionMode === selectionMode$1.SINGLE) {
            this.items._deselectAllExcept(item);
          }

          this._bulkSelectionChange = false;
        } // we make sure the change event is triggered before the load event.


        this._validateColumnChange();
      }
      /** @ignore */

    }, {
      key: "_tryToLoadAdditionalItems",
      value: function _tryToLoadAdditionalItems() {
        var _this2 = this;

        // makes sure that not too many events are triggered (only one per frame)
        if (this._bulkCollectionChange) {
          return;
        }

        this._bulkCollectionChange = true; // we use setTimeout instead of nextFrame because macrotasks allow for more flexibility since they are less
        // aggressive in executing the code

        window.setTimeout(function () {
          // trigger 'coral-columnview:loaditems' asynchronously in order to be sure the application is done
          // adding/removing elements. Also make sure that only one event is triggered at once
          // bulkCollectionChange has to be reset before loading new items
          _this2._bulkCollectionChange = false;

          _this2._loadFittingAdditionalItems();
        }, 0);
      }
      /** @private */

    }, {
      key: "_onContentScroll",
      value: function _onContentScroll() {
        window.clearTimeout(this._scrollTimeout);
        this._scrollTimeout = window.setTimeout(this._onDebouncedScroll, SCROLL_DEBOUNCE$2);
      }
      /**
       Handles the column click. When the column body is clicked, we need to deselect everything up to that column.
        @private
       */

    }, {
      key: "_onColumnContentClick",
      value: function _onColumnContentClick(event) {
        // we make sure the content was clicked directly and not an item
        if (event.target !== event.matchedTarget || isInteractiveTarget(event.target)) {
          return;
        }

        event.preventDefault(); // ignores event handling due to bulk select operation

        if (this._bulkSelectionChange) {
          return false;
        }

        this._bulkSelectionChange = true; // clears the current column

        this.items._deselectAndDeactivateAllExcept();

        this._bulkSelectionChange = false; // we check if the selection requires an event to be triggered

        this._validateColumnChange();
      }
      /** @private */

    }, {
      key: "_onDebouncedScroll",
      value: function _onDebouncedScroll() {
        var threshold = 20;

        if (this.content.scrollTop + this.offsetHeight >= this.content.scrollHeight - threshold) {
          this._loadItems(this.items.length, undefined);
        }
      }
      /** @private */

    }, {
      key: "_arraysAreDifferent",
      value: function _arraysAreDifferent(selection, oldSelection) {
        var diff = [];

        if (oldSelection.length === selection.length) {
          diff = oldSelection.filter(function (item) {
            return selection.indexOf(item) === -1;
          });
        } // since we guarantee that they are arrays, we can start by comparing their size


        return oldSelection.length !== selection.length || diff.length !== 0;
      }
      /** @private */

    }, {
      key: "_validateColumnChange",
      value: function _validateColumnChange(item) {
        var newActiveItem = this.activeItem;
        var oldActiveItem = this._oldActiveItem || null; // we have to force the event in case the same active item was clicked again, but still try to avoid triggering as
        // less events as possible

        if (newActiveItem !== oldActiveItem || item === newActiveItem) {
          this.trigger('coral-columnview-column:_activeitemchanged', {
            activeItem: newActiveItem,
            oldActiveItem: oldActiveItem
          }); // we cache the active item for the next time

          this._oldActiveItem = newActiveItem;
        }

        var newSelection = this.selectedItems;
        var oldSelection = this._oldSelection;

        if (this._arraysAreDifferent(newSelection, oldSelection)) {
          this.trigger('coral-columnview-column:_selecteditemchanged', {
            selection: newSelection,
            oldSelection: oldSelection
          }); // changes the old selection array since we selected something new

          this._oldSelection = newSelection;
        }
      }
      /**
       Loads additional Items if the current items of the column to not exceed its height and a path this.next is given.
        @private
       */

    }, {
      key: "_loadFittingAdditionalItems",
      value: function _loadFittingAdditionalItems() {
        var itemsCount = this.items.length; // this value must match $columnview-item-height

        var itemsHeight = itemsCount * ITEM_HEIGHT; // we request more items if there is still space for them. in case the values are the same, we request more data
        // just to be sure, specially when the value is 0

        if (itemsHeight <= this.offsetHeight) {
          this._loadItems(itemsCount, undefined);
        }
      }
      /**
       Loads additional items. If the given item is not <code>active</code>, no data will be requested.
        @param {Number} count
       Amount of items in the column.
       @param {?HTMLElement} item
       Item that triggered the load.
        @private
       */

    }, {
      key: "_loadItems",
      value: function _loadItems(count, item) {
        // if the given item is not active, it should not request data
        if (!item || item.hasAttribute('active')) {
          this.trigger('coral-columnview-column:_loaditems', {
            start: count,
            item: item
          });
        }
      }
      /**
       Updates the active and selected options from the DOM.
        @ignore
       */

    }, {
      key: "_setStateFromDOM",
      value: function _setStateFromDOM() {
        // if the selection mode has not been set, we do no try to force selection
        if (this._selectionMode) {
          // single: only the last item is selected
          if (this._selectionMode === selectionMode$1.SINGLE) {
            this.items._deselectAllExceptLast();
          } // none: deselects everything
          else if (this._selectionMode === selectionMode$1.NONE) {
              this.items._deselectAllExcept();
            } // makes sure only one item is active


          this.items._deactivateAllExceptFirst();
        }
      }
      /** @private */

    }, {
      key: "_handleMutation",
      value: function _handleMutation(mutations) {
        var mutationsCount = mutations.length;

        for (var i = 0; i < mutationsCount; i++) {
          var mutation = mutations[i]; // we handle the collection events

          this._triggerCollectionEvents(mutation.addedNodes, mutation.removedNodes);
        }

        this._setStateFromDOM(); // in case items were added removed and selection changed


        this._validateColumnChange(); // checks if more items can be added after the childlist change


        this._tryToLoadAdditionalItems();
      }
      /** @private */

    }, {
      key: "_triggerCollectionEvents",
      value: function _triggerCollectionEvents(addedNodes, removedNodes) {
        var item;
        var addedNodesCount = addedNodes.length;

        for (var i = 0; i < addedNodesCount; i++) {
          item = addedNodes[i];

          if (item.tagName === 'CORAL-COLUMNVIEW-ITEM') {
            this.trigger('coral-collection:add', {
              item: item
            });
          }
        }

        var removedNodesCount = removedNodes.length;

        for (var j = 0; j < removedNodesCount; j++) {
          item = removedNodes[j];

          if (item.tagName === 'CORAL-COLUMNVIEW-ITEM') {
            this.trigger('coral-collection:remove', {
              item: item
            });
          }
        }
      }
    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        var _this3 = this;

        _get(_getPrototypeOf(ColumnViewColumn.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$P); // @a11y

        if (!this.hasAttribute('role')) {
          this.setAttribute('role', 'group');
        }

        this.id = this.id || commons.getUID(); // @todo: initial collection items needs to be triggered

        var content = this._elements.content; // when the content zone was not created, we need to make sure that everything is added inside it as a content.
        // this stops the content zone from being voracious

        if (!content.parentNode) {
          // move the contents of the item into the content zone
          while (this.firstChild) {
            content.appendChild(this.firstChild);
          }
        } // @a11y


        content.setAttribute('role', 'presentation'); // Call content zone insert

        this.content = content; // handles the initial selection

        this._setStateFromDOM(); // we keep a list of the last selection to determine if something changed. we need to do this after
        // validateSelection since it modifies the initial state based on the option


        this._oldSelection = this.selectedItems;
        this._oldActiveItem = this.activeItem;

        if (!WINDOW_LOAD) {
          // instead of being super aggressive on requesting data, we use window onload so it is scheduled after
          // all the code has been executed, this way events can be added before
          window.addEventListener('load', function () {
            _this3._loadFittingAdditionalItems();
          });
        } else {
          // macro-task is necessary for the same reasons as listed above
          window.setTimeout(function () {
            _this3._loadFittingAdditionalItems();
          });
        }
      }
    }, {
      key: "activeItem",
      get: function get() {
        return this.items._getAllActive()[0] || null;
      }
      /**
       The content of the column. This container is where the items should be added and is responsible for handling the
       scrolling.
        @type {ColumnViewColumnContent}
       @contentzone
       */

    }, {
      key: "content",
      get: function get() {
        return this._getContentZone(this._elements.content);
      },
      set: function set(value) {
        this._setContentZone('content', value, {
          handle: 'content',
          tagName: 'coral-columnview-column-content',
          insert: function insert(content) {
            content.classList.add('_coral-AssetList');
            this.appendChild(content);
          }
        });
      }
      /**
       The Collection Interface that allows interacting with the items that the component contains.
        @type {ColumnViewCollection}
       @readonly
       */

    }, {
      key: "items",
      get: function get() {
        // we do lazy initialization of the collection
        if (!this._items) {
          this._items = new ColumnViewCollection({
            host: this,
            container: this._elements.content,
            itemTagName: 'coral-columnview-item',
            onItemAdded: this._toggleItemSelection
          });
        }

        return this._items;
      }
      /**
       Returns the first selected item in the ColumnView. The value <code>null</code> is returned if no element is
       selected.
        @type {?HTMLElement}
       @readonly
       */

    }, {
      key: "selectedItem",
      get: function get() {
        return this._selectionMode !== selectionMode$1.NONE ? this.items._getFirstSelected() : null;
      }
      /**
       Returns an Array containing the set selected items inside this Column.
        @type {Array.<HTMLElement>}
       @readonly
       */

    }, {
      key: "selectedItems",
      get: function get() {
        return this._selectionMode !== selectionMode$1.NONE ? this.items._getAllSelected() : [];
      }
      /**
       Private property that indicates the selection mode. If the <code>Coral.ColumnView.Column</code> is not inside
       a <code>Coral.ColumnView</code> this value will be <code>undefined</code>.
       See {@link ColumnViewSelectionModeEnum}.
        @type {String}
       @htmlattribute _selectionmode
       @htmlattributereflected
       @private
       */

    }, {
      key: "_selectionMode",
      get: function get() {
        return this.__selectionMode;
      },
      set: function set(value) {
        var _this4 = this;

        value = transform.string(value).toLowerCase();
        this.__selectionMode = validate.enumeration(selectionMode$1)(value) && value || null;

        this._reflectAttribute('_selectionmode', this.__selectionMode);

        this.items.getAll().forEach(function (item) {
          return _this4._toggleItemSelection(item);
        });

        this._setStateFromDOM();
      }
      /**
       Returns an Array containing the last selected items inside this Column in selected order.
        @type {Array.<HTMLElement>}
       @private
       */

    }, {
      key: "_lastSelectedItems",
      get: function get() {
        return this.__lastSelectedItems || this.selectedItems;
      },
      set: function set(value) {
        this.__lastSelectedItems = value;
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-columnview-column-content': 'content'
        };
      }
    }], [{
      key: "_attributePropertyMap",
      get: function get() {
        return commons.extend(_get(_getPrototypeOf(ColumnViewColumn), "_attributePropertyMap", this), {
          _selectionmode: '_selectionMode'
        });
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(ColumnViewColumn), "observedAttributes", this).concat(['_selectionmode']);
      }
    }]);

    return ColumnViewColumn;
  }(BaseComponent(HTMLElement));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.ColumnView.Column.Content
   @classdesc ColumnView's Column content component
   @htmltag coral-columnview-column-content
   @return {HTMLElement}
   */
  var ColumnViewColumnContent = (function () {
    return document.createElement('coral-columnview-column-content');
  });

  var CLASSNAME$Q = '_coral-AssetList-item';
  /**
   Enumeration for {@link ColumnViewItem} variants.

   @typedef {Object} ColumnViewItemVariantEnum

   @property {String} DEFAULT
   Default item variant. Contains no special decorations.
   @property {String} DRILLDOWN
   An item with a right arrow indicating that the navigation will go one level down.
   */

  var variant$g = {
    DEFAULT: 'default',
    DRILLDOWN: 'drilldown'
  };
  /**
   Utility that identifies Chrome on macOS, which announces drilldown items as "row 1 expanded" or "row 1 collapsed" when navigating between items.
   */

  var isChromeMacOS = !!window && !!window.chrome && /Mac/i.test(window.navigator.platform);
  /**
   @class Coral.ColumnView.Item
   @classdesc A ColumnView Item component
   @htmltag coral-columnview-item
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var ColumnViewItem = /*#__PURE__*/function (_BaseLabellable) {
    _inherits(ColumnViewItem, _BaseLabellable);

    var _super = _createSuper(ColumnViewItem);

    /** @ignore */
    function ColumnViewItem() {
      var _thisSuper, _this;

      _classCallCheck(this, ColumnViewItem);

      _this = _super.call(this); // Content zone

      _this._elements = {
        content: _this.querySelector('coral-columnview-item-content') || document.createElement('coral-columnview-item-content'),
        thumbnail: _this.querySelector('coral-columnview-item-thumbnail') || document.createElement('coral-columnview-item-thumbnail'),
        accessibilityState: _this.querySelector('span[handle="accessibilityState"]')
      };

      if (!_this._elements.accessibilityState) {
        // Templates
        template$x.call(_this._elements, {
          commons: commons
        });
      }

      _get((_thisSuper = _assertThisInitialized(_this), _getPrototypeOf(ColumnViewItem.prototype)), "_observeLabel", _thisSuper).call(_thisSuper);

      return _this;
    }
    /**
     The content of the item.
      @type {ColumnViewItemContent}
     @contentzone
     */


    _createClass(ColumnViewItem, [{
      key: "attributeChangedCallback",

      /** @ignore */
      value: function attributeChangedCallback(name, oldValue, value) {
        if (name === '_selectable') {
          // Disable selection
          if (value === null) {
            this.classList.remove('is-selectable');
          } // Enable selection
          else {
              this.classList.add('is-selectable');
              var itemSelector = this.querySelector('[coral-columnview-itemselect]'); // Render checkbox on demand

              if (!itemSelector) {
                itemSelector = new Checkbox();
                itemSelector.setAttribute('coral-columnview-itemselect', '');

                if (this.classList.contains('is-selected')) {
                  itemSelector.setAttribute('checked', '');
                }

                itemSelector._elements.input.tabIndex = -1;
                itemSelector.setAttribute('labelledby', this._elements.content.id); // Add the item selector as first child

                this.insertBefore(itemSelector, this.firstChild);
              }
            }
        } else {
          _get(_getPrototypeOf(ColumnViewItem.prototype), "attributeChangedCallback", this).call(this, name, oldValue, value);
        }
      }
      /**
       Returns {@link ColumnViewItem} variants.
        @return {ColumnViewItemVariantEnum}
       */

    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(ColumnViewItem.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$Q); // @a11y

        this.setAttribute('role', 'treeitem');
        this.id = this.id || commons.getUID(); // only set tabIndex if it is not already set

        if (!this.hasAttribute('tabindex')) {
          this.tabIndex = this.active || this.selected ? 0 : -1;
        } // Default reflected attributes


        if (!this._variant) {
          this.variant = variant$g.DEFAULT;
        }

        var thumbnail = this._elements.thumbnail;
        var content = this._elements.content;
        var contentZoneProvided = content.parentNode || thumbnail.parentNode;

        if (!contentZoneProvided) {
          // move the contents of the item into the content zone
          while (this.firstChild) {
            content.appendChild(this.firstChild);
          }
        } // Assign content zones


        this.content = content;
        this.thumbnail = thumbnail; // @a11y thumbnail img element should have alt attribute

        var thumbnailImg = thumbnail.querySelector('img:not([alt])');

        if (thumbnailImg) {
          thumbnailImg.setAttribute('alt', '');
        } // @ally add aria-labelledby so that JAWS/IE announces item correctly


        thumbnail.id = thumbnail.id || commons.getUID();
        content.id = content.id || commons.getUID(); // @a11y Add live region element to ensure announcement of selected state

        var accessibilityState = this._elements.accessibilityState; // @a11y accessibility state string should announce in document lang, rather than item lang.

        accessibilityState.setAttribute('lang', i18n.locale); // @a11y Item should be labelled by thumbnail, content, and accessibility state.

        this.setAttribute('aria-labelledby', thumbnail.id + ' ' + content.id);
      }
    }, {
      key: "content",
      get: function get() {
        return this._getContentZone(this._elements.content);
      },
      set: function set(value) {
        this._setContentZone('content', value, {
          handle: 'content',
          tagName: 'coral-columnview-item-content',
          insert: function insert(content) {
            content.classList.add("".concat(CLASSNAME$Q, "Label")); // Insert before chevron

            this.insertBefore(content, this.querySelector('._coral-AssetList-itemChildIndicator'));
          }
        });
      }
      /**
       The thumbnail of the item. It is used to hold an icon or an image.
        @type {ColumnViewItemThumbnail}
       @contentzone
       */

    }, {
      key: "thumbnail",
      get: function get() {
        return this._getContentZone(this._elements.thumbnail);
      },
      set: function set(value) {
        this._setContentZone('thumbnail', value, {
          handle: 'thumbnail',
          tagName: 'coral-columnview-item-thumbnail',
          insert: function insert(thumbnail) {
            thumbnail.classList.add("".concat(CLASSNAME$Q, "Thumbnail")); // Insert before content

            this.insertBefore(thumbnail, this.content || null);
          }
        });
      }
      /**
       The item's variant. See {@link ColumnViewItemVariantEnum}.
        @type {String}
       @default ColumnViewItemVariantEnum.DEFAULT
       @htmlattribute variant
       @htmlattributereflected
       */

    }, {
      key: "variant",
      get: function get() {
        return this._variant || variant$g.DEFAULT;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        this._variant = validate.enumeration(variant$g)(value) && value || variant$g.DEFAULT;

        this._reflectAttribute('variant', this._variant);

        if (this._variant === variant$g.DRILLDOWN) {
          // Render chevron on demand
          var childIndicator = this.querySelector('._coral-AssetList-itemChildIndicator');

          if (!childIndicator) {
            this.insertAdjacentHTML('beforeend', Icon._renderSVG('spectrum-css-icon-ChevronRightMedium', ['_coral-AssetList-itemChildIndicator', '_coral-UIIcon-ChevronRightMedium']));
          }

          this.classList.add('is-branch'); // @a11y Update aria-expanded. Active drilldowns should be expanded.
          // Note: Omit aria-expanded on Chrome for macOS, because with VoiceOver tends
          // to announce drilldown items as "row 1 expanded" or "row 1 collapsed" when
          // navigating between items.

          if (this.selected || isChromeMacOS && this.getAttribute('aria-level') === '1') {
            this.removeAttribute('aria-expanded');
          } else {
            this.setAttribute('aria-expanded', this.active);
          }
        } else {
          this.classList.remove('is-branch');
          this.removeAttribute('aria-expanded');
        }
      }
      /**
       Specifies the icon that will be placed inside the thumbnail. The size of the icon is always controlled by the
       component.
        @type {String}
       @default ""
       @htmlattribute icon
       @htmlattributereflected
       */

    }, {
      key: "icon",
      get: function get() {
        return this._icon || '';
      },
      set: function set(value) {
        this._icon = transform.string(value);

        this._reflectAttribute('icon', this._icon); // ignored if it is an empty string


        if (this._icon) {
          // creates a new icon element
          if (!this._elements.icon) {
            this._elements.icon = new Icon();
          }

          this._elements.icon.icon = this.icon;
          this._elements.icon.size = Icon.size.SMALL; // removes all the items, since the icon attribute has precedence

          this._elements.thumbnail.innerHTML = ''; // adds the newly created icon

          this._elements.thumbnail.appendChild(this._elements.icon);
        }

        _get(_getPrototypeOf(ColumnViewItem.prototype), "_toggleIconAriaHidden", this).call(this);
      }
      /**
       Whether the item is selected.
        @type {Boolean}
       @default false
       @htmlattribute selected
       @htmlattributereflected
       */

    }, {
      key: "selected",
      get: function get() {
        return this._selected || false;
      },
      set: function set(value) {
        var _this2 = this;

        this._selected = transform.booleanAttr(value);

        this._reflectAttribute('selected', this._selected);

        this.trigger('coral-columnview-item:_selectedchanged'); // wait a frame before updating attributes

        commons.nextFrame(function () {
          _this2.classList.toggle('is-selected', _this2._selected);

          _this2.setAttribute('aria-selected', _this2._selected); // @a11y Update aria-expanded. Active drilldowns should be expanded.
          // Note: Omit aria-expanded on Chrome for macOS, because with VoiceOver tends
          // to announce drilldown items as "row 1 expanded" or "row 1 collapsed" when
          // navigating between items.


          if (_this2.variant === variant$g.DRILLDOWN) {
            if (_this2._selected || isChromeMacOS && _this2.getAttribute('aria-level') === '1') {
              _this2.removeAttribute('aria-expanded');
            } else {
              _this2.setAttribute('aria-expanded', _this2.active);
            }
          }

          var accessibilityState = _this2._elements.accessibilityState;

          if (_this2._selected) {
            // @a11y Panels to right of selected item are removed, so remove aria-owns and aria-describedby attributes.
            _this2.removeAttribute('aria-owns');

            _this2.removeAttribute('aria-describedby'); // @a11y Update content to ensure that checked state is announced by assistive technology when the item receives focus


            accessibilityState.innerHTML = i18n.get(', checked'); // @a11y append live region content element

            if (!_this2.contains(accessibilityState)) {
              _this2.appendChild(accessibilityState);
            }
          } // @a11y If deselecting from checked state,
          else {
              // @a11y remove, but retain reference to accessibilityState state
              if (accessibilityState.parentNode) {
                _this2._elements.accessibilityState = accessibilityState.parentNode.removeChild(accessibilityState);
              } // @a11y Update content to remove checked state


              _this2._elements.accessibilityState.innerHTML = '';
            } // @a11y Item should be labelled by thumbnail, content, and if appropriate accessibility state.


          var ariaLabelledby = _this2._elements.thumbnail.id + ' ' + _this2._elements.content.id;

          _this2.setAttribute('aria-labelledby', _this2.selected ? "".concat(ariaLabelledby, " ").concat(accessibilityState.id) : ariaLabelledby); // Sync checkbox item selector


          var itemSelector = _this2.querySelector('coral-checkbox[coral-columnview-itemselect]');

          if (itemSelector) {
            itemSelector[_this2._selected ? 'setAttribute' : 'removeAttribute']('checked', '');
          }
        });
      }
      /**
       Whether the item is active.
        @type {Boolean}
       @default false
       @htmlattribut active
       @htmlattributereflected
       */

    }, {
      key: "active",
      get: function get() {
        return this._active || false;
      },
      set: function set(value) {
        this._active = transform.booleanAttr(value);

        this._reflectAttribute('active', this._active);

        this.classList.toggle('is-navigated', this._active);
        this.setAttribute('aria-selected', this.hasAttribute('_selectable') ? this.selected : this._active); // @a11y Update aria-expanded. Active drilldowns should be expanded.
        // Note: Omit aria-expanded on Chrome for macOS, because with VoiceOver tends
        // to announce drilldown items as "row 1 expanded" or "row 1 collapsed" when
        // navigating between items.

        if (this.variant === variant$g.DRILLDOWN) {
          if (this._selected || isChromeMacOS && this.getAttribute('aria-level') === '1') {
            this.removeAttribute('aria-expanded');
          } else {
            this.setAttribute('aria-expanded', this.active);
          }
        }

        if (!this._active) {
          // @a11y Inactive items are not expanded, so remove aria-owns and aria-describedby attributes.
          this.removeAttribute('aria-owns');
          this.removeAttribute('aria-describedby');
        }

        this.trigger('coral-columnview-item:_activechanged');
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-columnview-item-content': 'content',
          'coral-columnview-item-thumbnail': 'thumbnail'
        };
      }
    }], [{
      key: "variant",
      get: function get() {
        return variant$g;
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(ColumnViewItem), "observedAttributes", this).concat(['variant', 'icon', 'selected', 'active', '_selectable']);
      }
    }]);

    return ColumnViewItem;
  }(BaseLabellable(BaseComponent(HTMLElement)));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.ColumnView.Item.Content
   @classdesc ColumnView's Item content component
   @htmltag coral-columnview-item-content
   @return {HTMLElement}
   */
  var ColumnViewItemContent = (function () {
    return document.createElement('coral-columnview-item-content');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.ColumnView.Item.Thumbnail
   @classdesc ColumnView's Item thumbnail component
   @htmltag coral-columnview-item-thumbnail
   @return {HTMLElement}
   */
  var ColumnViewItemThumbnail = (function () {
    return document.createElement('coral-columnview-item-thumbnail');
  });

  var CLASSNAME$R = '_coral-MillerColumns-item';
  /**
   @class Coral.ColumnView.Preview
   @classdesc A ColumnView Preview component
   @htmltag coral-columnview-preview
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var ColumnViewPreview = /*#__PURE__*/function (_BaseComponent) {
    _inherits(ColumnViewPreview, _BaseComponent);

    var _super = _createSuper(ColumnViewPreview);

    /** @ignore */
    function ColumnViewPreview() {
      var _this;

      _classCallCheck(this, ColumnViewPreview);

      _this = _super.call(this); // Content zone

      _this._elements = {
        content: _this.querySelector('coral-columnview-preview-content') || document.createElement('coral-columnview-preview-content')
      };
      return _this;
    }
    /**
     The content of the Preview.
      @type {ColumnViewPreviewContent}
     @contentzone
     */


    _createClass(ColumnViewPreview, [{
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(ColumnViewPreview.prototype), "render", this).call(this);

        this.setAttribute('role', 'group');
        this.id = this.id || commons.getUID();
        this.classList.add(CLASSNAME$R);
        var content = this._elements.content; // when the content zone was not created, we need to make sure that everything is added inside it as a content.
        // this stops the content zone from being voracious

        if (!content.parentNode) {
          // move the contents of the item into the content zone
          while (this.firstChild) {
            content.appendChild(this.firstChild);
          }
        } // Call content zone insert


        this.content = content;

        this._makeAccessible();
      }
      /** @ignore */

    }, {
      key: "_makeAccessible",
      value: function _makeAccessible() {
        // @a11y For item values with a label, identify the value as a focusable, readOnly textbox labeled by the label.
        var elements = this.content.querySelectorAll('coral-columnview-preview-label + coral-columnview-preview-value');
        var length = elements.length;
        var i;
        var element;
        var elementLabel; // @a11y If the previous column has selected items,
        // do not include item values in the tab order,
        // so that a keyboard user can quickly advance to a subsequent toolbar.

        var tabIndex = this.parentElement && this.parentElement.tagName === 'CORAL-COLUMNVIEW' && this.parentElement.selectedItems.length ? -1 : 0;

        for (i = 0; i < length; i++) {
          element = elements[i];
          elementLabel = element.previousElementSibling;
          elementLabel.id = elementLabel.id || commons.getUID();
          element.setAttribute('aria-labelledby', elementLabel.id);
          element.setAttribute('role', 'textbox');
          element.setAttribute('tabindex', tabIndex);
          element.setAttribute('aria-readonly', 'true'); // force ChromeVox to read value of textbox

          if (window.cvox) {
            element.setAttribute('aria-valuetext', element.textContent);
          }
        } // @a11y Expose separator as a horizontally-oriented separator.


        elements = this.content.querySelectorAll('coral-columnview-preview-separator');
        length = elements.length;

        for (i = 0; i < length; i++) {
          element = elements[i];
          element.setAttribute('role', 'separator');
          element.setAttribute('aria-orientation', 'horizontal');
        } // @a11y If the preview asset image does not include an alt attribute, set alt="", so that screen readers do not announce the image url.


        elements = this.content.querySelectorAll('coral-columnview-preview-asset > img:not([alt])');
        length = elements.length;

        for (i = 0; i < length; i++) {
          element = elements[i];
          element.setAttribute('alt', '');
        }
      }
    }, {
      key: "content",
      get: function get() {
        return this._getContentZone(this._elements.content);
      },
      set: function set(value) {
        this._setContentZone('content', value, {
          handle: 'content',
          tagName: 'coral-columnview-preview-content',
          insert: function insert(content) {
            content.classList.add('coral-Body--small');
            this.appendChild(content);
          }
        });
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-columnview-preview-content': 'content'
        };
      }
    }]);

    return ColumnViewPreview;
  }(BaseComponent(HTMLElement));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.ColumnView.Preview.Asset
   @classdesc ColumnView's preview asset component
   @htmltag coral-columnview-preview-asset
   @return {HTMLElement}
   */
  var ColumnViewPreviewAsset = (function () {
    return document.createElement('coral-columnview-preview-asset');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.ColumnView.Preview.Content
   @classdesc ColumnView's preview content component
   @htmltag coral-columnview-preview-content
   @return {HTMLElement}
   */
  var ColumnViewPreviewContent = (function () {
    return document.createElement('coral-columnview-preview-content');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.ColumnView.Preview.Label
   @classdesc ColumnView's preview label component
   @htmltag coral-columnview-preview-label
   @return {HTMLElement}
   */
  var ColumnViewPreviewLabel = (function () {
    return document.createElement('coral-columnview-preview-label');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.ColumnView.Preview.Separator
   @classdesc ColumnView's preview separator component
   @htmltag coral-columnview-preview-separator
   @return {HTMLElement}
   */
  var ColumnViewPreviewSeparator = (function () {
    return document.createElement('coral-columnview-preview-separator');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.ColumnView.Preview.Value
   @classdesc ColumnView's preview value component
   @htmltag coral-columnview-preview-value
   @return {HTMLElement}
   */
  var ColumnViewPreviewValue = (function () {
    return document.createElement('coral-columnview-preview-value');
  });

  /**
   * Copyright 2020 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var translations$e = {
    "en-US": {
      "Column View": "Column View",
      ", checked": ", checked",
      ", unchecked": ", unchecked"
    },
    "de-DE": {
      "Column View": "Column View",
      ", checked": ", markiert",
      ", unchecked": ", nicht markiert"
    },
    "fr-FR": {
      "Column View": "Column View",
      ", checked": ", cochÃ©e",
      ", unchecked": ", pas cochÃ©e"
    },
    "it-IT": {
      "Column View": "Column View",
      ", checked": ", selezionata",
      ", unchecked": ", non selezionata"
    },
    "ja-JP": {
      "Column View": "Column View",
      ", checked": "ããã§ãã¯",
      ", unchecked": "ãæªãã§ãã¯"
    },
    "es-ES": {
      "Column View": "Column View",
      ", checked": ", marcada",
      ", unchecked": ", desmarcada"
    },
    "ko-KR": {
      "Column View": "Column View",
      ", checked": ", ì íë¨",
      ", unchecked": ", ì íëì§ ìì"
    },
    "zh-CN": {
      "Column View": "Column View",
      ", checked": "ï¼éä¸­",
      ", unchecked": "ï¼æªéä¸­"
    },
    "zh-TW": {
      "Column View": "Column View",
      ", checked": "ï¼é¸ä¸­",
      ", unchecked": "ï¼æªé¸ä¸­"
    },
    "pt-BR": {
      "Column View": "Column View",
      ", checked": ", marcada",
      ", unchecked": ", desmarcada"
    },
    "nl-NL": {
      "Column View": "Column View",
      ", checked": ", geselecteerd",
      ", unchecked": ", neit geselecteerd"
    },
    "da-DK": {
      ", checked": ", valgte",
      ", unchecked": ", ikke valgt"
    },
    "fi-FI": {
      "Column View": "Column View",
      ", checked": ", valittu",
      ", unchecked": ", valittuna"
    },
    "nb-NO": {
      "Column View": "Column View",
      ", checked": ", valgt",
      ", unchecked": ", ikke valgt"
    },
    "sv-SE": {
      "Column View": "Column View",
      ", checked": ", markerad",
      ", unchecked": ", avmarkerad"
    },
    "cs-CZ": {
      "Column View": "Column View",
      ", checked": ", vybrÃ¡no",
      ", unchecked": ", nenÃ­ vybrÃ¡no"
    },
    "pl-PL": {
      "Column View": "Column View",
      ", checked": ", zaznaczone",
      ", unchecked": ", nie zaznaczone"
    },
    "ru-RU": {
      "Column View": "Column View",
      ", checked": ", Ð²ÑÐ±ÑÐ°Ð½Ð½ÑÐ¹",
      ", unchecked": ", Ð½ÐµÐ¾ÑÐ¾Ð±ÑÐ°Ð½Ð½ÑÐ¹"
    },
    "tr-TR": {
      "Column View": "Column View",
      ", checked": ", seÃ§ilmiÅ",
      ", unchecked": ", seÃ§ilmemiÅ"
    }
  };

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons.extend(strings, {
    'coral-component-columnview': translations$e
  }); // Expose component on the Coral namespace

  commons._define('coral-columnview-preview', ColumnViewPreview);

  commons._define('coral-columnview-column', ColumnViewColumn);

  commons._define('coral-columnview-item', ColumnViewItem);

  commons._define('coral-columnview', ColumnView);

  ColumnView.Column = ColumnViewColumn;
  ColumnView.Column.Content = ColumnViewColumnContent;
  ColumnView.Item = ColumnViewItem;
  ColumnView.Item.Content = ColumnViewItemContent;
  ColumnView.Item.Thumbnail = ColumnViewItemThumbnail;
  ColumnView.Preview = ColumnViewPreview;
  ColumnView.Preview.Asset = ColumnViewPreviewAsset;
  ColumnView.Preview.Content = ColumnViewPreviewContent;
  ColumnView.Preview.Label = ColumnViewPreviewLabel;
  ColumnView.Preview.Separator = ColumnViewPreviewSeparator;
  ColumnView.Preview.Value = ColumnViewPreviewValue;

  /**
   Enum for {CycleButtonItem} display options.

   @typedef {Object} CycleButtonItemDisplayModeEnum

   @property {String} ICON
   Icon display mode.
   @property {String} TEXT
   Text display mode.
   @property {String} ICON_TEXT
   Icon and text display mode.
   @property {String} INHERIT
   Inherit display mode.
   */

  var displayMode = {
    ICON: 'icon',
    TEXT: 'text',
    ICON_TEXT: 'icontext',
    INHERIT: 'inherit'
  };
  /**
   @class Coral.CycleButton.Item
   @classdesc A CycleButton Item component
   @htmltag coral-cyclebutton-item
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var CycleButtonItem = /*#__PURE__*/function (_BaseComponent) {
    _inherits(CycleButtonItem, _BaseComponent);

    var _super = _createSuper(CycleButtonItem);

    function CycleButtonItem() {
      _classCallCheck(this, CycleButtonItem);

      return _super.apply(this, arguments);
    }

    _createClass(CycleButtonItem, [{
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(CycleButtonItem.prototype), "render", this).call(this); // adds the role to support accessibility


        this.setAttribute('role', 'menuitemradio'); // Default reflected attributes

        if (!this._displayMode) {
          this.displayMode = displayMode.INHERIT;
        }
      }
    }, {
      key: "icon",

      /**
       The Item's icon. See {@link Coral.Icon} for valid icon names.
        @type {String}
       @default ""
       @htmlattribute icon
       @htmlattributereflected
       */
      get: function get() {
        return this._icon || '';
      },
      set: function set(value) {
        var _icon = transform.string(value);

        if (this._icon === _icon) {
          return;
        }

        this._icon = _icon;

        this._reflectAttribute('icon', this._icon);

        this.trigger('coral-cyclebutton-item:_iconchanged');
      } // @compat

    }, {
      key: "content",
      get: function get() {
        return this;
      },
      set: function set(value) {
        // Support configs
        if (_typeof(value) === 'object') {
          for (var prop in value) {
            /** @ignore */
            this[prop] = value[prop];
          }
        }
      }
      /**
       Whether the Item is disabled. When set to true, this will prevent every user interacting with it.
        @type {Boolean}
       @default false
       @htmlattribute disabled
       @htmlattributereflected
       */

    }, {
      key: "disabled",
      get: function get() {
        return this._disabled || false;
      },
      set: function set(value) {
        this._disabled = transform.booleanAttr(value);

        this._reflectAttribute('disabled', this._disabled);

        this.classList.toggle('is-disabled', this.disabled);
        this[this._disabled ? 'setAttribute' : 'removeAttribute']('aria-disabled', this._disabled);

        if (this._disabled && this.selected) {
          this.selected = false;
        }

        if (!this._disabled && !this.selected) {
          // We inform the parent to verify if this item should be selected because it's the only one left
          this.trigger('coral-cyclebutton-item:_validateselection');
        }
      }
      /**
       Whether the Item is selected.
       @type {Boolean}
       @default false
       @htmlattribute selected
       @htmlattributereflected
       */

    }, {
      key: "selected",
      get: function get() {
        return this._selected || false;
      },
      set: function set(value) {
        var _selected = transform.booleanAttr(value);

        if (this._selected === _selected) {
          return;
        }

        if (!_selected || _selected && !this.disabled) {
          this._selected = _selected;

          this._reflectAttribute('selected', this.disabled ? false : this._selected);

          this.classList.toggle('is-selected', this._selected);
          this.setAttribute('aria-checked', this._selected);
          this.trigger('coral-cyclebutton-item:_selectedchanged');
        }
      }
      /**
       The displayMode to be used when the particular item is selected. When this value is set to <code>inherit</code>
       it will defer to the component level displayMode. If the selected item does not have the necessary icon or text
       information, then fallback to show whichever is available. The appearance of collapsed items in the popover are
       not affected by this property.
       See {@link CycleButtonItemDisplayModeEnum}.
        @type {String}
       @default CycleButtonItemDisplayModeEnum.INHERIT
       @htmlattribute displaymode
       @htmlattributereflected
       */

    }, {
      key: "displayMode",
      get: function get() {
        return this._displayMode || displayMode.INHERIT;
      },
      set: function set(value) {
        var _value = transform.string(value).toLowerCase();

        var _displayMode = validate.enumeration(displayMode)(_value) && _value || displayMode.INHERIT;

        if (this._displayMode === _displayMode) {
          return;
        }

        this._displayMode = _displayMode;

        this._reflectAttribute('displaymode', this._displayMode);

        this.trigger('coral-cyclebutton-item:_displaymodechanged');
      }
      /**
       Inherited from {@link BaseComponent#trackingElement}.
       */

    }, {
      key: "trackingElement",
      get: function get() {
        return typeof this._trackingElement === 'undefined' ? // keep spaces to only 1 max and trim. this mimics native html behaviors
        (this.content || this).textContent.replace(/\s{2,}/g, ' ').trim() || this.icon : this._trackingElement;
      },
      set: function set(value) {
        _set(_getPrototypeOf(CycleButtonItem.prototype), "trackingElement", value, this, true);
      }
      /**
       Returns {@link CycleButtonItem} display options.
        @return {CycleButtonItemDisplayModeEnum}
       */

    }], [{
      key: "displayMode",
      get: function get() {
        return displayMode;
      }
    }, {
      key: "_attributePropertyMap",
      get: function get() {
        return commons.extend(_get(_getPrototypeOf(CycleButtonItem), "_attributePropertyMap", this), {
          displaymode: 'displayMode'
        });
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(CycleButtonItem), "observedAttributes", this).concat(['selected', 'disabled', 'icon', 'displaymode']);
      }
    }]);

    return CycleButtonItem;
  }(BaseComponent(HTMLElement));

  var template$y = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var data = data_0 = typeof data_0 === "undefined" ? {} : data_0;
    data = data_0;
    data.buttonId = data.id + '-button';
    data.menuId = data.id + '-menu';
    data_0 = data;
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    var el2 = this["button"] = document.createElement("button", "coral-button");
    el2.setAttribute("tracking", "off");
    el2.id = data_0["buttonId"];
    el2.setAttribute("handle", "button");
    el2.className += " _coral-CycleSelect-button";
    el2.setAttribute("is", "coral-button");
    el2.setAttribute("type", "button");
    el2.setAttribute("variant", "quietaction");
    el2.setAttribute("iconsize", "S");
    var el3 = document.createTextNode("\n  ");
    el2.appendChild(el3);
    var el4 = this["label"] = document.createElement("coral-button-label");
    el4.className += " _coral-ActionButton-label";
    el4.setAttribute("handle", "label");
    el2.appendChild(el4);
    var el5 = document.createTextNode("\n");
    el2.appendChild(el5);
    frag.appendChild(el2);
    var el6 = document.createTextNode("\n");
    frag.appendChild(el6);
    data = data_0; // Don't wait for button MO to pick up the label

    this.button._elements.label = this.label; // Render chevron icon

    this.button.insertAdjacentHTML('afterbegin', data.Icon._renderSVG('spectrum-css-icon-ChevronDownMedium', ['_coral-CycleSelect-icon', '_coral-UIIcon-ChevronDownMedium']));
    data_0 = data;
    var el8 = document.createTextNode("\n");
    frag.appendChild(el8);
    var el9 = this["overlay"] = document.createElement("coral-popover");
    el9.setAttribute("tracking", "off");
    el9.setAttribute("smart", "");
    el9.id = data_0["menuId"];
    el9.setAttribute("handle", "overlay");
    el9.setAttribute("focusonshow", "coral-selectlist");
    el9.setAttribute("placement", "bottom");
    el9.setAttribute("aria-live", "off");
    el9.setAttribute("role", "menu");
    var el10 = document.createTextNode("\n  ");
    el9.appendChild(el10);
    var el11 = this["selectList"] = document.createElement("coral-selectlist");
    el11.setAttribute("role", "group");
    el11.setAttribute("tracking", "off");
    el11.className += " _coral-CycleSelect-list";
    el11.setAttribute("handle", "selectList");
    el11.id = data_0["commons"]["getUID"]();
    el9.appendChild(el11);
    var el12 = document.createTextNode("\n  ");
    el9.appendChild(el12);
    var el13 = this["separator"] = document.createElement("div");
    el13.setAttribute("role", "separator");
    el13.setAttribute("handle", "separator");
    el13.className += " _coral-CycleButton-separator";
    el13.setAttribute("hidden", "");
    el9.appendChild(el13);
    var el14 = document.createTextNode("\n  ");
    el9.appendChild(el14);
    var el15 = this["actionList"] = document.createElement("coral-buttonlist");
    el15.setAttribute("role", "group");
    el15.setAttribute("tracking", "off");
    el15.className += " _coral-CycleSelect-buttonList";
    el15.setAttribute("handle", "actionList");
    el15.setAttribute("hidden", "");
    el9.appendChild(el15);
    var el16 = document.createTextNode("\n");
    el9.appendChild(el16);
    frag.appendChild(el9);
    var el17 = document.createTextNode("\n");
    frag.appendChild(el17);
    return frag;
  };

  /**
   Enumeration for {@link CycleButton} display options.

   @typedef {Object} CycleButtonDisplayModeEnum

   @property {String} ICON
   Icon display mode.
   @property {String} TEXT
   Text display mode.
   @property {String} ICON_TEXT
   Icon and text display mode.
   */

  var displayMode$1 = {
    ICON: 'icon',
    TEXT: 'text',
    ICON_TEXT: 'icontext'
  };
  /**
   Regex used to remove whitespace from selectedItem label for use as an aria-label for accessibility.

   @ignore
   */

  var WHITESPACE_REGEX = /[\t\n\r ]+/g;
  /** @ignore */

  var ACTION_TAG_NAME = 'coral-cyclebutton-action';
  var CLASSNAME$S = '_coral-CycleSelect';
  /**
   @class Coral.CycleButton
   @classdesc A CycleButton component is a simple multi-state toggle button that toggles between the possible items below
   a certain threshold, and shows them in a popover selector when above.
   @htmltag coral-cyclebutton
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var CycleButton = /*#__PURE__*/function (_BaseComponent) {
    _inherits(CycleButton, _BaseComponent);

    var _super = _createSuper(CycleButton);

    /** @ignore */
    function CycleButton() {
      var _this;

      _classCallCheck(this, CycleButton);

      _this = _super.call(this);
      _this._id = _this.id || commons.getUID(); // Templates

      _this._elements = {};
      template$y.call(_this._elements, {
        Icon: Icon,
        commons: commons,
        id: _this._id
      });
      var events = {
        'click button[is="coral-button"]': '_onMouseDown',
        'click ._coral-CycleSelect-button': '_onItemClick',
        'click coral-cyclebutton-item': '_onItemClick',
        'key:down ._coral-CycleSelect-button[aria-expanded=false]': '_onItemClick',
        // private
        'coral-cyclebutton-item:_selectedchanged': '_onItemSelectedChanged',
        'coral-cyclebutton-item:_validateselection': '_onValidateSelection',
        'coral-cyclebutton-item:_iconchanged coral-cyclebutton-item[selected]': '_onSelectedItemPropertyChange',
        'coral-cyclebutton-item:_displaymodechanged coral-cyclebutton-item[selected]': '_onSelectedItemPropertyChange',
        'key:pageup coral-selectlist-item, [coral-list-item]': '_onFocusPreviousItem',
        'key:left coral-selectlist-item, [coral-list-item]': '_onFocusPreviousItem',
        'key:up coral-selectlist-item, [coral-list-item]': '_onFocusPreviousItem',
        'key:pagedown coral-selectlist-item, [coral-list-item]': '_onFocusNextItem',
        'key:right coral-selectlist-item, [coral-list-item]': '_onFocusNextItem',
        'key:down coral-selectlist-item, [coral-list-item]': '_onFocusNextItem',
        'key:home coral-selectlist-item, [coral-list-item]': '_onFocusFirstItem',
        'key:end coral-selectlist-item, [coral-list-item]': '_onFocusLastItem',
        'capture:focus coral-selectlist-item, [coral-list-item]': '_onItemFocus',
        'capture:blur coral-selectlist-item, [coral-list-item]': '_onItemBlur',
        'coral-overlay:open': '_onOverlayOpen',
        'coral-overlay:close': '_onOverlayClose'
      };
      var overlay = _this._elements.overlay;
      var overlayId = overlay.id; // Overlay

      events["global:capture:click #".concat(overlayId, " button[is=\"coral-buttonlist-item\"]")] = '_onActionClick';
      events["global:capture:coral-selectlist:beforechange #".concat(overlayId)] = '_onSelectListBeforeChange';
      events["global:capture:coral-selectlist:change #".concat(overlayId)] = '_onSelectListChange'; // Keyboard interaction

      events["global:keypress #".concat(overlayId)] = '_onOverlayKeyPress'; // Attach events

      _this._delegateEvents(events); // Used for eventing


      _this._oldSelection = null; // Init the collection mutation observer

      _this.items._startHandlingItems(true);

      _this.actions._startHandlingItems(true);

      return _this;
    }
    /**
     Returns the inner overlay to allow customization.
      @type {Popover}
     @readonly
     */


    _createClass(CycleButton, [{
      key: "_hasMenuItemRadioGroup",

      /** @private */
      value: function _hasMenuItemRadioGroup() {
        return this.items.getAll().length > 0 && this.actions.getAll().length > 0;
      }
      /** @private */

    }, {
      key: "_onItemAdded",
      value: function _onItemAdded(item) {
        if (!this.selectedItem) {
          item.setAttribute('selected', '');
        } else {
          this._validateSelection(item);
        }

        this._checkExtended();
      }
      /** @private */

    }, {
      key: "_onItemRemoved",
      value: function _onItemRemoved() {
        if (!this.selectedItem) {
          this._selectFirstItem();
        }

        this._checkExtended();
      }
      /** @private */

    }, {
      key: "_onItemSelectedChanged",
      value: function _onItemSelectedChanged(event) {
        event.stopImmediatePropagation();

        this._validateSelection(event.target);
      }
      /** @private */

    }, {
      key: "_onValidateSelection",
      value: function _onValidateSelection(event) {
        event.stopImmediatePropagation();

        this._validateSelection();
      }
      /** @private */

    }, {
      key: "_selectFirstItem",
      value: function _selectFirstItem() {
        var item = this.items._getFirstSelectable();

        if (item) {
          item.setAttribute('selected', '');
        }
      }
      /** @private */

    }, {
      key: "_validateSelection",
      value: function _validateSelection(item) {
        var _this2 = this;

        var selectedItems = this.items._getAllSelected();

        if (item) {
          // Deselected item
          if (!item.hasAttribute('selected') && !selectedItems.length) {
            var siblingItem = this.items._getNextSelectable(item); // Next selectable item is forced to be selected if selection is cleared


            if (item !== siblingItem) {
              siblingItem.setAttribute('selected', '');
            }
          } // Selected item
          else if (item.hasAttribute('selected') && selectedItems.length > 1) {
              selectedItems.forEach(function (selectedItem) {
                if (selectedItem !== item) {
                  // Don't trigger change events
                  _this2._preventTriggeringEvents = true;
                  selectedItem.removeAttribute('selected');
                }
              }); // We can trigger change events again

              this._preventTriggeringEvents = false;
            }
        } else if (selectedItems.length > 1) {
          // If multiple items are selected, the last one wins
          item = selectedItems[selectedItems.length - 1];
          selectedItems.forEach(function (selectedItem) {
            if (selectedItem !== item) {
              // Don't trigger change events
              _this2._preventTriggeringEvents = true;
              selectedItem.removeAttribute('selected');
            }
          }); // We can trigger change events again

          this._preventTriggeringEvents = false;
        } // First selectable item is forced to be selected if no selection at all
        else if (!selectedItems.length) {
            this._selectFirstItem();
          }

        this._renderSelectedItem(this.selectedItem);

        this._triggerChangeEvent();
      }
      /** @private */

    }, {
      key: "_triggerChangeEvent",
      value: function _triggerChangeEvent() {
        var selectedItem = this.selectedItem;
        var oldSelection = this._oldSelection;

        if (!this._preventTriggeringEvents && selectedItem !== oldSelection) {
          this.trigger('coral-cyclebutton:change', {
            oldSelection: oldSelection,
            selection: selectedItem
          });
          this._oldSelection = selectedItem;
        }
      }
    }, {
      key: "_onMouseDown",
      value: function _onMouseDown(event) {
        event.preventDefault();
        event.stopPropagation();

        this._trackEvent('click', 'coral-cyclebutton', event);
      }
      /** @private */

    }, {
      key: "_onItemClick",
      value: function _onItemClick(event) {
        event.preventDefault();
        var items = this.items.getAll();
        var itemCount = items.length; // When we have more than a specified number of items, use the overlay selection. If threshold is 0, then we never
        // show the popover. If there are actions, we always show the popover.

        if (this._isExtended()) {
          // we toggle the overlay if it was already open
          this[this._elements.overlay.classList.contains('is-open') ? '_hideOverlay' : '_showOverlay']();
        } // Unless this is the only item we have, select the next item in line:
        else if (itemCount > 1) {
            var neighbor = this.selectedItem.nextElementSibling;
            var nextItem = neighbor.nodeName === 'CORAL-CYCLEBUTTON-ITEM' ? neighbor : items[0];

            this._selectCycleItem(nextItem);

            this._focusItem(this._elements.button);
          }
      }
      /**
       Render the provided item as selected according to resolved icon and displayMode properties.
        @private
       */

    }, {
      key: "_renderSelectedItem",
      value: function _renderSelectedItem(item) {
        if (!item || !item.content) {
          return;
        } // resolve effective values by checking for item and component level properties


        var effectiveDisplayMode = this.displayMode;
        var effectiveIcon = item.icon || this.icon || '';

        if (item.displayMode !== CycleButtonItem.displayMode.INHERIT) {
          effectiveDisplayMode = item.displayMode;
        }

        if (!item.content.textContent.trim() || !effectiveIcon.trim()) {
          // if icon or text missing then we fallback to showing whichever is available
          effectiveDisplayMode = displayMode$1.ICON_TEXT;
        } // manipulate button sub-component depending on display mode


        if (effectiveDisplayMode === displayMode$1.ICON) {
          this._elements.button.icon = effectiveIcon;
          this._elements.button.label.innerHTML = ''; // @a11y

          var ariaLabel = item.content.textContent.replace(WHITESPACE_REGEX, ' ');

          this._elements.button.setAttribute('aria-label', ariaLabel);

          this._elements.button.setAttribute('title', ariaLabel);

          if (ariaLabel && effectiveIcon !== '' && this._elements.button._elements.icon) {
            this._elements.button._elements.icon.setAttribute('aria-hidden', true);
          }
        } else {
          // handle display modes that include text
          if (effectiveDisplayMode === displayMode$1.TEXT) {
            this._elements.button.icon = '';
          }

          if (effectiveDisplayMode === displayMode$1.ICON_TEXT) {
            this._elements.button.icon = effectiveIcon;

            if (effectiveIcon !== '' && this._elements.button._elements.icon) {
              this._elements.button._elements.icon.setAttribute('aria-hidden', true);
            }
          }

          this._elements.button.label.innerHTML = item.content.innerHTML; // @a11y we do not require aria attributes since we already show text

          this._elements.button.removeAttribute('aria-label');

          this._elements.button.removeAttribute('title');
        }
      }
      /**
       Update currently selected item if it's <code>icon</code> or <code>displayMode</code> properties have changed.
        @private
       */

    }, {
      key: "_onSelectedItemPropertyChange",
      value: function _onSelectedItemPropertyChange(event) {
        // stops propagation because the event is internal to the component
        event.stopImmediatePropagation();

        this._renderSelectedItem(event.target);
      }
      /** @private */

    }, {
      key: "_onSelectListBeforeChange",
      value: function _onSelectListBeforeChange(event) {
        if (event.detail.item.selected) {
          event.preventDefault();

          if (!this._isPopulatingLists) {
            // Hide the overlay, cleanup will be done before overlay.show()
            this._hideOverlay();
          }
        }
      }
      /** @private */

    }, {
      key: "_onSelectListChange",
      value: function _onSelectListChange(event) {
        event.stopImmediatePropagation();
        event.preventDefault();
        var origNode;
        var selectListItem = event.detail.selection;

        if (selectListItem) {
          origNode = selectListItem._originalItem;

          this._selectCycleItem(origNode);

          if (!this._isPopulatingLists) {
            // Hide the overlay, cleanup will be done before overlay.show()
            this._hideOverlay();
          }
        }

        this._trackEvent('selected', 'coral-cyclebutton-item', event, origNode);
      }
    }, {
      key: "_onOverlayKeyPress",
      value: function _onOverlayKeyPress(event) {
        // Focus on item which text starts with pressed keys
        this._elements.selectList._onKeyPress(event);
      }
      /** @private */

    }, {
      key: "_onActionClick",
      value: function _onActionClick(event) {
        event.stopPropagation();
        var item = event.matchedTarget;

        var proxyEvent = item._originalItem.trigger('click');

        if (!proxyEvent.defaultPrevented) {
          this._hideOverlay();
        }

        this._trackEvent('selected', 'coral-cyclebutton-action', event, item);
      }
      /** @private */

    }, {
      key: "_isExtended",
      value: function _isExtended() {
        var hasActions = this.actions.getAll().length > 0;
        return this.threshold > 0 && this.items.getAll().length >= this.threshold || hasActions;
      }
      /** @private */

    }, {
      key: "_checkExtended",
      value: function _checkExtended() {
        var isExtended = this._isExtended();

        this.classList.toggle("".concat(CLASSNAME$S, "--extended"), isExtended); // @a11y

        if (isExtended) {
          this._elements.button.setAttribute('aria-controls', this._elements.overlay.id);

          this._elements.button.setAttribute('aria-haspopup', true);

          this._elements.button.setAttribute('aria-expanded', false); // Assign the button as the target for the overlay


          this._elements.overlay.target = this._elements.button;
          this._elements.overlay.hidden = false; // Regions within the overlay should have role=presentation

          this._elements.overlay.content.setAttribute('role', 'presentation');
        } else {
          this._elements.button.removeAttribute('aria-controls');

          this._elements.button.removeAttribute('aria-haspopup');

          this._elements.button.removeAttribute('aria-expanded'); // Remove target and hide overlay


          this._elements.overlay.target = null;
          this._elements.overlay.hidden = true;
        }
      }
      /** @ignore */

    }, {
      key: "_focusItem",
      value: function _focusItem(item) {
        if (item) {
          item.focus();
        }
      }
      /** @private */

    }, {
      key: "_onFocusPreviousItem",
      value: function _onFocusPreviousItem(event) {
        event.preventDefault();

        var items = this._getSelectableItems();

        if (items.length > 1) {
          var el = event.matchedTarget;
          var index = items.indexOf(el);

          if (index > 0) {
            this._focusItem(items[index - 1]);
          } else if (document.activeElement !== el) {
            // make sure ButtonList doesn't wrap focus
            this._focusItem(el);
          }
        }
      }
      /** @private */

    }, {
      key: "_onFocusNextItem",
      value: function _onFocusNextItem(event) {
        event.preventDefault();

        var items = this._getSelectableItems();

        if (items.length > 1) {
          var el = event.matchedTarget;
          var index = items.indexOf(el);

          if (index < items.length - 1) {
            this._focusItem(items[index + 1]);
          } else if (document.activeElement !== el) {
            // make sure ButtonList doesn't wrap focus
            this._focusItem(el);
          }
        }
      }
      /** @private */

    }, {
      key: "_onFocusFirstItem",
      value: function _onFocusFirstItem(event) {
        event.preventDefault();

        this._focusItem(this._getSelectableItems()[0]);
      }
      /** @private */

    }, {
      key: "_onFocusLastItem",
      value: function _onFocusLastItem(event) {
        event.preventDefault();

        var items = this._getSelectableItems();

        this._focusItem(items[items.length - 1]);
      }
      /** @private */

    }, {
      key: "_getSelectableItems",
      value: function _getSelectableItems() {
        var items = this.items.getAll();
        var actions = this.actions.getAll();
        return items.concat(actions).map(function (item) {
          return item._selectListItem || item._buttonListItem;
        }).filter(function (item) {
          !item.hasAttribute('hidden') && !item.hasAttribute('disabled') && item.offsetParent !== null && (item.offsetWidth > 0 || item.offsetHeight > 0);
        });
      }
      /** @private */

    }, {
      key: "_onItemFocus",
      value: function _onItemFocus(event) {
        this._elements.selectList.classList.toggle('is-focused', true);

        event.matchedTarget.classList.toggle('focus-ring', true);
      }
      /** @private */

    }, {
      key: "_onItemBlur",
      value: function _onItemBlur(event) {
        this._elements.selectList.classList.toggle('is-focused', false);

        event.matchedTarget.classList.toggle('focus-ring', false);
      }
    }, {
      key: "_onOverlayClose",
      value: function _onOverlayClose() {
        // @a11y
        this._elements.button.setAttribute('aria-expanded', false);
      }
    }, {
      key: "_onOverlayOpen",
      value: function _onOverlayOpen() {
        // @a11y
        this._elements.button.setAttribute('aria-expanded', true);
      }
      /** @ignore */

    }, {
      key: "_hideOverlay",
      value: function _hideOverlay() {
        this._elements.overlay.hide();
      }
      /** @ignore */

    }, {
      key: "_getSelectListItem",
      value: function _getSelectListItem(item) {
        var selectListItem = new SelectList.Item(); // Needs to be reflected on the generated Item.

        selectListItem.trackingElement = item.trackingElement; // We do first the content, so that the icon is not destroyed

        var selectListItemContent = new SelectList.Item.Content();
        selectListItemContent.innerHTML = item.content.innerHTML;
        selectListItem.content = selectListItemContent; // Specify the icon

        if (item.icon) {
          selectListItem.icon = item.icon;
        }

        selectListItem.disabled = item.disabled;
        selectListItem.selected = item.selected;
        selectListItem.role = item.role;
        selectListItem.setAttribute('aria-checked', item.selected);
        selectListItem._originalItem = item;
        item._selectListItem = selectListItem;
        return selectListItem;
      }
      /** @ignore */

    }, {
      key: "_getActionListItem",
      value: function _getActionListItem(action) {
        var actionListItem = new ButtonList.Item();
        actionListItem.icon = action.icon;
        actionListItem.disabled = action.disabled;
        actionListItem.role = action.role;
        actionListItem.tabIndex = action.tabIndex; // Needs to be reflected on the generated Action.

        actionListItem.trackingElement = action.trackingElement;
        actionListItem.content.innerHTML = action.content.innerHTML;
        actionListItem._originalItem = action;
        action._buttonListItem = actionListItem;
        return actionListItem;
      }
      /** @ignore */

    }, {
      key: "_populateLists",
      value: function _populateLists() {
        var _this3 = this;

        var selectList = this._elements.selectList;
        var actionList = this._elements.actionList;
        var items = this.items.getAll();
        var actions = this.actions.getAll();
        var itemCount = items.length;
        var actionCount = actions.length;
        var selectListItem;
        var actionListItem;
        this._isPopulatingLists = true; // we empty the existing items before populating the lists again

        selectList.items.clear();
        actionList.items.clear(); // adds the items to the selectList

        for (var i = 0; i < itemCount; i++) {
          var item = items[i];
          selectListItem = this._getSelectListItem(item);
          selectListItem.icon = item.icon;
          selectListItem.role = item.role;
          selectListItem.setAttribute('aria-checked', item.selected);

          selectListItem._elements.icon.setAttribute('aria-hidden', true);

          selectListItem.set({
            disabled: item.disabled,
            selected: item.selected
          }, true);
          selectList.items.add(selectListItem);
        } // adds any additional actions to the actions buttonList


        if (actionCount > 0) {
          for (var j = 0; j < actionCount; j++) {
            var action = actions[j];
            actionListItem = this._getActionListItem(action);
            actionListItem.disabled = action.disabled;
            actionListItem.icon = action.icon;
            actionListItem.role = action.role;

            actionListItem._elements.icon.setAttribute('aria-hidden', true);

            actionList.items.add(actionListItem);
          }

          this._elements.actionList.removeAttribute('hidden');

          if (itemCount > 0) {
            this._elements.separator.removeAttribute('hidden');

            this._elements.selectList.setAttribute('role', 'group');
          }
        } else {
          this._elements.actionList.setAttribute('hidden', '');

          this._elements.separator.setAttribute('hidden', '');

          this._elements.selectList.setAttribute('role', 'presentation');
        }

        commons.nextFrame(function () {
          _this3._isPopulatingLists = false;
        });
      }
      /** @private */

    }, {
      key: "_selectCycleItem",
      value: function _selectCycleItem(item) {
        item.setAttribute('selected', '');
      }
      /** @ignore */

    }, {
      key: "_showOverlay",
      value: function _showOverlay() {
        this._populateLists();

        this._elements.overlay.show();
      }
      /**
       Returns {@link CycleButton} display options.
        @return {CycleButtonDisplayModeEnum}
       */

    }, {
      key: "attributeChangedCallback",

      /** @ignore */
      value: function attributeChangedCallback(name, oldValue, value) {
        // The accessibility name for the button element
        if (name === 'aria-label') {
          var hasMenuItemRadioGroup = this._hasMenuItemRadioGroup(); // aria-labelledby takes precedence over aria-label


          if (this.getAttribute('aria-labelledby')) {
            // Button should be labeled by the container and the button, with the selected value, itself
            this._elements.button.setAttribute('aria-labelledby', "".concat(this.id, " ").concat(this._elements.button.id)); // Overlay should be labeled by the container with aria-label


            this._elements.overlay.setAttribute('aria-labelledby', this.id); // With both items and actions, the items should be grouped and the group should be labeled
            // SelectList menuitemradio group should be labeled by the container with aria-label,
            // Otherwise the selectList should not be labeled independantly from the menu


            this._elements.selectList[hasMenuItemRadioGroup ? 'setAttribute' : 'removeAttribute']('aria-labelledby', this.id);
          } else {
            //  With no aria-label, clean up aria-labelledby on _elements
            this._elements.button.removeAttribute('aria-labelledby');

            this._elements.overlay.setAttribute('aria-labelledby', this._elements.button.id); // With both items and actions, the items should be grouped and the group should be labeled
            // SelectList menuitemradio group should be labeled by the button, with the selected value, itself,
            // Otherwise the selectList should not be labeled independantly from the menu


            this._elements.selectList[hasMenuItemRadioGroup ? 'setAttribute' : 'removeAttribute']('aria-labelledby', this._elements.button.id);
          }
        } // The id reference for an HTML element that labels the button element accessibility name for the button element
        else if (name === 'aria-labelledby') {
            if (value || !this.getAttribute('aria-label')) {
              this._elements.button.setAttribute('aria-labelledby', "".concat(value, " ").concat(this._elements.button.id));

              this._elements.overlay.setAttribute('aria-labelledby', value || this._elements.button.id);

              this._elements.selectList[this._hasMenuItemRadioGroup() ? 'setAttribute' : 'removeAttribute']('aria-labelledby', value || this._elements.button.id);
            }
          } else {
            _get(_getPrototypeOf(CycleButton.prototype), "attributeChangedCallback", this).call(this, name, oldValue, value);
          }
      }
      /** @ignore */

    }, {
      key: "connectedCallback",
      value: function connectedCallback() {
        _get(_getPrototypeOf(CycleButton.prototype), "connectedCallback", this).call(this);

        var overlay = this._elements.overlay; // Cannot be open by default when rendered

        overlay.removeAttribute('open'); // Restore in DOM

        if (overlay._parent) {
          overlay._parent.appendChild(overlay);
        }
      }
      /** @ignore */

    }, {
      key: "render",
      value: function render() {
        var _this4 = this;

        _get(_getPrototypeOf(CycleButton.prototype), "render", this).call(this);

        if (!this.id) {
          this.id = this._id;
        }

        this.classList.add(CLASSNAME$S); // Default reflected attributes

        if (typeof this._threshold === 'undefined') {
          this.threshold = 3;
        }

        if (!this._displayMode) {
          this.displayMode = displayMode$1.ICON;
        } // adds the role to support accessibility


        this.setAttribute('role', 'presentation'); // checks the component's extended mode

        this._checkExtended();

        ['button', 'overlay'].forEach(function (handleName) {
          var handle = _this4.querySelector("[handle=\"".concat(handleName, "\"]"));

          if (handle) {
            handle.remove();
          }
        });
        var frag = document.createDocumentFragment(); // Render the base layout

        frag.appendChild(this._elements.button);
        frag.appendChild(this._elements.overlay); // Inserting the template before the items

        this.appendChild(frag); // Don't trigger events once connected

        this._preventTriggeringEvents = true;

        this._validateSelection();

        this._preventTriggeringEvents = false;
        this._oldSelection = this.selectedItem;
      }
      /** @ignore */

    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        _get(_getPrototypeOf(CycleButton.prototype), "disconnectedCallback", this).call(this);

        var overlay = this._elements.overlay; // In case it was moved out don't forget to remove it

        if (!this.contains(overlay)) {
          overlay._parent = overlay._repositioned ? document.body : this;
          overlay.remove();
        }
      }
      /**
       Triggered when the {@link CycleButton} selected item has changed.
        @typedef {CustomEvent} coral-cyclebutton:change
        @property {CycleButtonItem} detail.oldSelection
       The prior selected item(s).
       @property {CycleButtonItem} detail.selection
       The newly selected item(s).
       */

    }, {
      key: "overlay",
      get: function get() {
        return this._elements.overlay;
      }
      /**
       The Collection Interface that allows interacting with the items that the component contains.
        @type {SelectableCollection}
       @readonly
       */

    }, {
      key: "items",
      get: function get() {
        // just init on demand
        if (!this._items) {
          this._items = new SelectableCollection({
            host: this,
            itemTagName: 'coral-cyclebutton-item',
            onItemAdded: this._onItemAdded,
            onItemRemoved: this._onItemRemoved
          });
        }

        return this._items;
      }
      /**
       The selected item in the CycleButton.
        @type {HTMLElement}
       @readonly
       */

    }, {
      key: "selectedItem",
      get: function get() {
        return this.items._getLastSelected();
      }
      /**
       General icon of the CycleButton. The icon will be displayed no matter the selection. If the selected item has
       its own icon, it will be overwritten.
        @type {String}
       @default ""
       @htmlattribute icon
       @htmlattributereflected
       */

    }, {
      key: "icon",
      get: function get() {
        return this._icon || '';
      },
      set: function set(value) {
        this._icon = transform.string(value);

        this._reflectAttribute('icon', this._icon);

        var selectedItem = this.selectedItem;

        if (selectedItem) {
          this._renderSelectedItem(selectedItem);
        }
      }
      /**
       Number of items that can be directly cycled through before collapsing. If <code>0</code> is used, the items
       will never be collapsed.
        @type {Number}
       @default 3
       @htmlattribute threshold
       @htmlattributereflected
       */

    }, {
      key: "threshold",
      get: function get() {
        return typeof this._threshold === 'number' ? this._threshold : 3;
      },
      set: function set(value) {
        value = transform.number(value);

        if (value > -1) {
          this._threshold = value;

          this._checkExtended();
        }
      }
      /**
       The Collection Interface that allows interaction with the {@link CycleButtonAction} elements.
        @type {SelectableCollection}
       @readonly
       */

    }, {
      key: "actions",
      get: function get() {
        if (!this._actions) {
          this._actions = new SelectableCollection({
            host: this,
            itemTagName: ACTION_TAG_NAME,
            itemSelector: ACTION_TAG_NAME,
            onCollectionChange: this._checkExtended
          });
        }

        return this._actions;
      }
      /**
       The CycleButton's displayMode. This defines how the selected item is displayed. If the selected item does not
       have the necessary icon or text information then fallback to show whichever is available. The appearance of
       collapsed items in the popover are not affected by this property. The displayMode property can be set on an
       item to override the component level value when that item is selected.
       See {@link CycleButtonDisplayModeEnum}.
        @type {String}
       @default CycleButtonDisplayModeEnum.ICON
       @htmlattribute displaymode
       @htmlattributereflected
       */

    }, {
      key: "displayMode",
      get: function get() {
        return this._displayMode || displayMode$1.ICON;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        this._displayMode = validate.enumeration(displayMode$1)(value) && value || displayMode$1.ICON;

        this._reflectAttribute('displaymode', this._displayMode);

        var selectedItem = this.selectedItem;

        if (selectedItem) {
          this._renderSelectedItem(selectedItem);
        }
      }
    }], [{
      key: "displayMode",
      get: function get() {
        return displayMode$1;
      }
    }, {
      key: "_attributePropertyMap",
      get: function get() {
        return commons.extend(_get(_getPrototypeOf(CycleButton), "_attributePropertyMap", this), {
          displaymode: 'displayMode'
        });
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(CycleButton), "observedAttributes", this).concat(['icon', 'threshold', 'displaymode', 'aria-label', 'aria-labelledby']);
      }
    }]);

    return CycleButton;
  }(BaseComponent(HTMLElement));

  /**
   @class Coral.CycleButton.Action
   @classdesc A CycleButton Action component
   @htmltag coral-cyclebutton-action
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var CycleButtonAction = /*#__PURE__*/function (_BaseComponent) {
    _inherits(CycleButtonAction, _BaseComponent);

    var _super = _createSuper(CycleButtonAction);

    function CycleButtonAction() {
      _classCallCheck(this, CycleButtonAction);

      return _super.apply(this, arguments);
    }

    _createClass(CycleButtonAction, [{
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(CycleButtonAction.prototype), "render", this).call(this); // adds the role to support accessibility


        this.setAttribute('role', 'menuitem');
        this.tabIndex = -1;
      }
    }, {
      key: "icon",

      /**
       The Action's icon. See {@link Coral.Icon} for valid icon names.
        @type {String}
       @default ""
       @htmlattribute icon
       @htmlattributereflected
       */
      get: function get() {
        return this._icon || '';
      },
      set: function set(value) {
        this._icon = transform.string(value);

        this._reflectAttribute('icon', this._icon);
      } // @compat

    }, {
      key: "content",
      get: function get() {
        return this;
      },
      set: function set(value) {
        // Support configs
        if (_typeof(value) === 'object') {
          for (var prop in value) {
            /** @ignore */
            this[prop] = value[prop];
          }
        }
      }
      /**
       Inherited from {@link BaseComponent#trackingElement}.
       */

    }, {
      key: "trackingElement",
      get: function get() {
        return typeof this._trackingElement === 'undefined' ? // keep spaces to only 1 max and trim. this mimics native html behaviors
        (this.content || this).textContent.replace(/\s{2,}/g, ' ').trim() || this.icon : this._trackingElement;
      },
      set: function set(value) {
        _set(_getPrototypeOf(CycleButtonAction.prototype), "trackingElement", value, this, true);
      }
      /** @ignore */

    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(CycleButtonAction), "observedAttributes", this).concat(['icon']);
      }
    }]);

    return CycleButtonAction;
  }(BaseComponent(HTMLElement));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons._define('coral-cyclebutton-action', CycleButtonAction);

  commons._define('coral-cyclebutton-item', CycleButtonItem);

  commons._define('coral-cyclebutton', CycleButton);

  CycleButton.Item = CycleButtonItem;
  CycleButton.Action = CycleButtonAction;

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var translations$f = {
    "en-US": {
      "Time": "Time",
      "Calendar": "Calendar"
    },
    "de-DE": {
      "Time": "Zeit",
      "Calendar": "Kalender"
    },
    "fr-FR": {
      "Time": "Heure",
      "Calendar": "Calendrier"
    },
    "it-IT": {
      "Time": "Ora",
      "Calendar": "Calendario"
    },
    "ja-JP": {
      "Time": "æé",
      "Calendar": "ã«ã¬ã³ãã¼"
    },
    "es-ES": {
      "Time": "Hora",
      "Calendar": "Calendario"
    },
    "ko-KR": {
      "Time": "ìê°",
      "Calendar": "ë¬ë ¥"
    },
    "zh-CN": {
      "Time": "æ¶é´",
      "Calendar": "æ¥å"
    },
    "zh-TW": {
      "Time": "æé",
      "Calendar": "æ¥æ"
    },
    "pt-BR": {
      "Time": "Hora",
      "Calendar": "CalendÃ¡rio"
    },
    "nl-NL": {
      "Time": "Tijd",
      "Calendar": "Kalender"
    },
    "da-DK": {
      "Time": "Tid",
      "Calendar": "Kalender"
    },
    "fi-FI": {
      "Time": "Aika",
      "Calendar": "Kalenteri"
    },
    "nb-NO": {
      "Time": "Klokkeslett",
      "Calendar": "Kalender"
    },
    "sv-SE": {
      "Time": "Tid",
      "Calendar": "Kalender"
    },
    "cs-CZ": {
      "Time": "Äas",
      "Calendar": "KalendÃ¡Å"
    },
    "pl-PL": {
      "Time": "Czas",
      "Calendar": "Kalendarz"
    },
    "ru-RU": {
      "Time": "ÐÑÐµÐ¼Ñ",
      "Calendar": "ÐÐ°Ð»ÐµÐ½Ð´Ð°ÑÑ"
    },
    "tr-TR": {
      "Time": "Zaman",
      "Calendar": "Takvim"
    }
  };

  var template$z = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["overlay"] = document.createElement("coral-popover");
    el0.setAttribute("tracking", "off");
    el0.setAttribute("smart", "");
    el0.className += " _coral-Datepicker-overlay";
    el0.setAttribute("handle", "overlay");
    el0.id = data_0["commons"]["getUID"]();
    el0.setAttribute("breadthoffset", "50%r - 50%p");
    el0.setAttribute("placement", "bottom");
    frag.appendChild(el0);
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    var el2 = this["hiddenInput"] = document.createElement("input");
    el2.setAttribute("type", "hidden");
    el2.setAttribute("handle", "hiddenInput");
    frag.appendChild(el2);
    var el3 = document.createTextNode("\n");
    frag.appendChild(el3);
    var el4 = this["input"] = document.createElement("input", "coral-textfield");
    el4.setAttribute("tracking", "off");
    el4.setAttribute("is", "coral-textfield");
    el4.setAttribute("type", "text");
    el4.setAttribute("handle", "input");
    el4.className += " _coral-InputGroup-field";
    el4.setAttribute("role", "textbox");
    frag.appendChild(el4);
    var el5 = document.createTextNode("\n");
    frag.appendChild(el5);
    var el6 = this["toggle"] = document.createElement("button", "coral-button");
    el6.setAttribute("tracking", "off");
    el6.setAttribute("is", "coral-button");
    el6.setAttribute("variant", "_custom");
    el6.className += " _coral-InputGroup-button _coral-FieldButton";
    el6.setAttribute("type", "button");
    el6.setAttribute("handle", "toggle");
    el6.setAttribute("aria-haspopup", "dialog");
    el6.setAttribute("aria-label", data_0["i18n"]["get"]('Calendar'));
    el6.setAttribute("title", data_0["i18n"]["get"]('Calendar'));
    var el7 = document.createTextNode("\n  ");
    el6.appendChild(el7);
    var el8 = this["icon"] = document.createElement("coral-icon");
    el8.setAttribute("icon", "calendar");
    el8.setAttribute("iconsize", "S");
    el8.className += " u-coral-noMargin";
    el8.setAttribute("handle", "icon");
    el6.appendChild(el8);
    var el9 = document.createTextNode("\n  ");
    el6.appendChild(el9);
    var el10 = document.createElement("coral-button-label");
    el6.appendChild(el10);
    var el11 = document.createTextNode("\n");
    el6.appendChild(el11);
    frag.appendChild(el6);
    var el12 = document.createTextNode("\n");
    frag.appendChild(el12);
    return frag;
  };

  var template$A = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var data = data_0 = typeof data_0 === "undefined" ? {} : data_0;
    data = data_0;
    var uid = data.commons.getUID();
    data_0 = data;
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    var el2 = this["calendar"] = document.createElement("coral-calendar");
    el2.setAttribute("handle", "calendar");
    el2.className += " _coral-Datepicker-calendar";
    el2.setAttribute("aria-labelledby", uid + "-calendar");
    var el3 = document.createTextNode("\n  ");
    el2.appendChild(el3);
    var el4 = document.createElement("span");
    el4.id = uid + "-calendar";
    el4.className += " u-coral-screenReaderOnly";
    el4.setAttribute("hidden", "");
    el4.textContent = data_0["i18n"]["get"]("Calendar");
    el2.appendChild(el4);
    var el5 = document.createTextNode("\n");
    el2.appendChild(el5);
    frag.appendChild(el2);
    var el6 = document.createTextNode("\n");
    frag.appendChild(el6);
    var el7 = this["clock"] = document.createElement("coral-clock");
    el7.setAttribute("handle", "clock");
    el7.className += " _coral-Datepicker-clock";
    el7.setAttribute("aria-labelledby", uid + "-clock");
    var el8 = document.createTextNode("\n  ");
    el7.appendChild(el8);
    var el9 = document.createElement("span");
    el9.id = uid + "-clock";
    el9.className += " u-coral-screenReaderOnly";
    el9.setAttribute("hidden", "");
    el9.textContent = data_0["i18n"]["get"]("Time");
    el7.appendChild(el9);
    var el10 = document.createTextNode("\n");
    el7.appendChild(el10);
    frag.appendChild(el7);
    var el11 = document.createTextNode("\n");
    frag.appendChild(el11);
    return frag;
  };

  /**
   Enum for {@link Datepicker} variant values.

   @typedef {Object} DatepickerVariantEnum

   @property {String} DEFAULT
   A default, gray Datepicker.
   @property {String} QUIET
   A Datepicker with no border or background.
   */

  var variant$h = {
    DEFAULT: 'default',
    QUIET: 'quiet'
  };
  var CLASSNAME$T = '_coral-InputGroup'; // builds a string containing all possible variant classnames. This will be used to remove
  // classnames when the variant changes.

  var ALL_VARIANT_CLASSES$a = [];

  for (var variantKey in variant$h) {
    ALL_VARIANT_CLASSES$a.push("".concat(CLASSNAME$T, "--").concat(variant$h[variantKey]));
  }
  /** @ignore */


  function toMoment$1(value, format) {
    if (value === 'today') {
      return new DateTime.Moment();
    } else if (DateTime.Moment.isMoment(value)) {
      return value.isValid() ? value.clone() : null;
    } // if the value provided is a date it does not make sense to provide a format to parse the date


    var result = new DateTime.Moment(value, value instanceof Date ? null : format);
    return result.isValid() ? result : null;
  }
  /**
   Enumeration for {@link Datepicker} variants.

   @typedef {Object} DatepickerTypeEnum

   @property {String} DATE
   The selection overlay contains only a calendar.
   @property {String} DATETIME
   Provides both calendar and time controls in the selection overlay.
   @property {String} TIME
   The selection overlay provides only time controls.
   */


  var type = {
    DATE: 'date',
    DATETIME: 'datetime',
    TIME: 'time'
  }; // Used to determine if the client is on a mobile device

  var IS_MOBILE_DEVICE$1 = navigator.userAgent.match(/iPhone|iPad|iPod|Android/i) !== null;
  var NATIVE_FORMATS = {
    date: 'YYYY-MM-DD',
    datetime: 'YYYY-MM-DD[T]HH:mmZ',
    time: 'HH:mm'
  };

  var isNativeFormat = function isNativeFormat(format) {
    var res = false;

    for (var key in NATIVE_FORMATS) {
      if (format === NATIVE_FORMATS[key]) {
        res = true;
      }
    }

    return res;
  };
  /**
   @class Coral.Datepicker
   @classdesc A Datepicker component that can be used as a date and time selection form field. Leverages {@link momentJS}
   if loaded on the page.
   @htmltag coral-datepicker
   @extends {HTMLElement}
   @extends {BaseComponent}
   @extends {BaseFormField}
   */


  var Datepicker = /*#__PURE__*/function (_BaseFormField) {
    _inherits(Datepicker, _BaseFormField);

    var _super = _createSuper(Datepicker);

    /** @ignore */
    function Datepicker() {
      var _this;

      _classCallCheck(this, Datepicker);

      _this = _super.call(this); // Prepare templates

      _this._elements = {};
      template$z.call(_this._elements, {
        commons: commons,
        i18n: i18n
      }); // Creates and stores the contents of the popover separately

      _this._calendarFragment = template$A.call(_this._elements, {
        commons: commons,
        i18n: i18n
      }); // Pre-define labellable element

      _this._labellableElement = _this._elements.input;
      var overlayId = _this._elements.overlay.id;
      var events = {};
      events["global:capture:click #".concat(overlayId, " coral-calendar")] = '_onCalendarDayClick';
      events["global:capture:change #".concat(overlayId)] = '_onChange';
      events["global:capture:coral-overlay:beforeopen #".concat(overlayId)] = '_onPopoverBeforeOpen';
      events["global:capture:coral-overlay:open #".concat(overlayId)] = '_onPopoverOpenOrClose';
      events["global:capture:coral-overlay:close #".concat(overlayId)] = '_onPopoverOpenOrClose';
      events['key:alt+down [handle="input"],[handle="toggle"]'] = '_onAltDownKey';
      events['key:down [handle="toggle"]'] = '_onAltDownKey';
      events['change coral-datepicker > input[is="coral-textfield"]'] = '_onInputChange'; // Events

      _this._delegateEvents(commons.extend(_this._events, events));

      return _this;
    }
    /**
     Returns the inner overlay to allow customization.
      @type {Popover}
     @readonly
     */


    _createClass(Datepicker, [{
      key: "_onPopoverBeforeOpen",

      /** @ignore */
      value: function _onPopoverBeforeOpen() {
        this._elements.overlay.returnFocusTo(this._elements.input);

        this._elements.calendar._validateCalendar();

        this._renderCalendar();
      }
      /**
       Matches the accessibility to the state of the popover.
        @ignore
       */

    }, {
      key: "_onPopoverOpenOrClose",
      value: function _onPopoverOpenOrClose(event) {
        // set focus to calendar grid
        if (this._elements.overlay.open) {
          if (this.type === type.TIME) {
            this._elements.clock.focus();
          } else {
            this._elements.calendar.focus();
          }

          this._elements.input.setAttribute('aria-expanded', 'true');

          this._elements.toggle.setAttribute('aria-expanded', 'true');

          this._trackEvent('open', 'coral-datepicker', event);
        } else {
          this._elements.input.setAttribute('aria-expanded', 'false');

          this._elements.toggle.setAttribute('aria-expanded', 'false');

          this._trackEvent('close', 'coral-datepicker', event);
        }
      }
      /** @ignore */

    }, {
      key: "_onCalendarDayClick",
      value: function _onCalendarDayClick(event) {
        if (event.target.tagName === 'A') {
          // since a selection has been made, we close the popover. we cannot use the _onChange listener to handle this
          // because clicking on the same button will not trigger a change event
          this._elements.overlay.open = false;

          this._trackEvent('click', 'coral-datepicker', event);
        }
      }
      /** @ignore */

    }, {
      key: "_onInputChange",
      value: function _onInputChange(event) {
        // because we are reimplementing the form field mix in, we will have to stop the propagation and trigger the
        // 'change' event from here
        event.stopPropagation();
        this.value = new DateTime.Moment(event.target.value, this.displayFormat);

        this._validateValue();

        this.trigger('change');

        this._trackEvent('change', 'coral-datepicker', event);
      }
      /** @ignore */

    }, {
      key: "_onChange",
      value: function _onChange(event) {
        if (event.target.tagName === 'CORAL-CALENDAR' || event.target.tagName === 'CORAL-CLOCK') {
          event.stopPropagation(); // we create the new value using both calendar and clock controls
          // datepicker should set the current time as default when no time is set, but a date was chosen (if in datetime
          // mode)

          this.value = this._mergeCalendarAndClockDates(true);

          this._validateValue();

          this.trigger('change');
        }
      }
      /** @private */

    }, {
      key: "_onAltDownKey",
      value: function _onAltDownKey(event) {
        // Stop any consequences of pressing the key
        event.preventDefault();

        if (!this._elements.overlay.open) {
          this._elements.overlay.open = true;
        }
      }
      /** @ignore */

    }, {
      key: "_validateValue",
      value: function _validateValue() {
        // calendar validates only on user input, we have to manually force the validation
        this._elements.calendar._validateCalendar(); // check if the current value is valid and update the internal state of the component


        if (this.type === type.DATE) {
          this.invalid = this._elements.calendar.invalid;
        } else if (this.type === type.TIME) {
          this.invalid = this._elements.clock.invalid;
        } else {
          this.invalid = this._elements.calendar.invalid || this._elements.clock.invalid;
        }
      }
      /** @ignore */

    }, {
      key: "_mergeCalendarAndClockDates",
      value: function _mergeCalendarAndClockDates(autoSetTimeIfNeeded) {
        var value = new DateTime.Moment(this._elements.calendar.valueAsDate);
        var time = this._elements.clock.valueAsDate;

        if (autoSetTimeIfNeeded && value && !time && this.type === type.DATETIME) {
          // datepicker should set the current time as default when no time is set, but a date was chosen (if in datetime
          // mode)
          time = new DateTime.Moment().toDate();
        }

        if (time) {
          if (!value.isValid()) {
            value = new DateTime.Moment();
          }

          value.hours(time.getHours());
          value.minutes(time.getMinutes());
        }

        return value;
      }
      /**
       Helper class that converts the internal moment value into a String using the provided date format. If the value is
       invalid, empty string will be returned.
        @param {?Moment} value
       The value representing the date. It has to be a moment object or <code>null</code>
       @param {String} format
       The Date format to be used.
        @ignore
       */

    }, {
      key: "_getValueAsString",
      value: function _getValueAsString(value, format) {
        return value && value.isValid() ? value.format(format) : '';
      }
      /** @ignore */

    }, {
      key: "_renderCalendar",
      value: function _renderCalendar() {
        if (this._elements.overlay.content.innerHTML === '') {
          this._elements.overlay.content.appendChild(this._calendarFragment);

          this._calendarFragment = undefined;
        }
      }
      /**
       Returns {@link Datepicker} variants.
        @return {DatepickerVariantEnum}
       */

    }, {
      key: "connectedCallback",

      /** @ignore */
      value: function connectedCallback() {
        _get(_getPrototypeOf(Datepicker.prototype), "connectedCallback", this).call(this);

        var overlay = this._elements.overlay; // Cannot be open by default when rendered

        overlay.removeAttribute('open'); // Restore in DOM

        if (overlay._parent) {
          overlay._parent.appendChild(overlay);
        }
      }
      /** @ignore */

    }, {
      key: "render",
      value: function render() {
        _get(_getPrototypeOf(Datepicker.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$T); // a11y

        this.setAttribute('role', 'group'); // Input attributes per ARIA Autocomplete

        this._elements.input.setAttribute('role', 'combobox');

        this._elements.input.setAttribute('aria-autocomplete', 'none');

        this._elements.input.setAttribute('aria-haspopup', 'dialog');

        this._elements.input.setAttribute('aria-expanded', 'false');

        this._elements.input.setAttribute('aria-controls', this._elements.overlay.id); // Trigger button attributes per ARIA Autocomplete


        this._elements.toggle.setAttribute('aria-haspopup', 'dialog');

        this._elements.toggle.setAttribute('aria-expanded', 'false');

        this._elements.toggle.setAttribute('aria-controls', this._elements.overlay.id); // a11y we only have AUTO mode.


        this._useNativeInput = IS_MOBILE_DEVICE$1; // Default reflected attributes

        if (!this._variant) {
          this.variant = variant$h.DEFAULT;
        } // "type" takes care of reflecting "displayFormat" and "valueFormat"


        if (!this._type) {
          this.type = type.DATE;
        } // clean up to be able to clone it


        while (this.firstChild) {
          this.removeChild(this.firstChild);
        }

        var frag = document.createDocumentFragment(); // Render template

        frag.appendChild(this._elements.hiddenInput);
        frag.appendChild(this._elements.input);
        frag.appendChild(this._elements.toggle);
        frag.appendChild(this._elements.overlay); // Point at the button from the bottom

        this._elements.overlay.target = this._elements.toggle;
        this.appendChild(frag);
      }
      /** @ignore */

    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        _get(_getPrototypeOf(Datepicker.prototype), "disconnectedCallback", this).call(this);

        var overlay = this._elements.overlay; // In case it was moved out don't forget to remove it

        if (!this.contains(overlay)) {
          overlay._parent = overlay._repositioned ? document.body : this;
          overlay.remove();
        }
      }
    }, {
      key: "overlay",
      get: function get() {
        return this._elements.overlay;
      }
      /**
       The type of datepicker to show to the user. See {@link DatepickerTypeEnum}.
        @type {DatepickerTypeEnum}
       @default DatepickerTypeEnum.DATE
       @htmlattribute type
       @htmlattributereflected
       */

    }, {
      key: "type",
      get: function get() {
        return this._type || type.DATE;
      },
      set: function set(value) {
        // Flag to indicate that we are changing the type for the first time
        this._typeFormatChanged = typeof this._type === 'undefined';
        value = transform.string(value).toLowerCase();
        this._type = validate.enumeration(type)(value) && value || type.DATE;

        this._reflectAttribute('type', this._type);

        var format = NATIVE_FORMATS[this._type];
        var isTime = this._type === type.TIME;
        var isDate = this._type === type.DATE;
        this._elements.icon.icon = isTime ? 'clock' : 'calendar';
        var toggleLabel = isTime ? i18n.get('Time') : i18n.get('Calendar');

        this._elements.toggle.setAttribute('aria-label', toggleLabel);

        this._elements.toggle.setAttribute('title', toggleLabel);

        this._elements.clock.hidden = isDate;

        this._elements.clock.setAttribute('aria-hidden', isDate);

        this._elements.calendar.hidden = isTime;

        this._elements.calendar.setAttribute('aria-hidden', isTime); // Change format if we have a native format set


        if (isNativeFormat(this.valueFormat)) {
          this.valueFormat = format;
        }

        if (isNativeFormat(this.displayFormat)) {
          this.displayFormat = format;
        }

        this._useNativeInput = this._useNativeInput;
        this._typeFormatChanged = false;
      }
      /**
       The format used to display the selected date(time) to the user. If the user manually types a date, this format
       will be used to parse the value. When using this component on a mobile device, the display format must follow
       the format used by the native input. If an empty string is provided, then the default value per type will
       be used. The default value depends on the <code>type</code>, which can be one from <code>YYYY-MM-DD</code>,
       <code>YYYY-MM-DD[T]HH:mmZ</code> or <code>HH:mm</code>.  Include momentjs to support additional format string options
       see http://momentjs.com/docs/#/displaying/.
        @type {String}
       @default "YYYY-MM-DD"
       @htmlattribute displayformat
       @htmlattributereflected
       */

    }, {
      key: "displayFormat",
      get: function get() {
        // we ignore _useNativeInput when the type is datetime because it is not supported by mobile libraries
        if (this._useNativeInput && this.type !== type.DATETIME) {
          return NATIVE_FORMATS[this.type];
        }

        return typeof this._displayFormat === 'undefined' ? NATIVE_FORMATS[this.type] : this._displayFormat;
      },
      set: function set(value) {
        value = transform.string(value).trim(); // In case a custom display format was set, we make sure that type doesn't change it to a native format

        var displayFormatAttribute = this.getAttribute('displayformat');

        if (this._typeFormatChanged && displayFormatAttribute && displayFormatAttribute !== value) {
          value = displayFormatAttribute;
        }

        this._displayFormat = value === '' ? NATIVE_FORMATS[this.type] : value;

        this._reflectAttribute('displayformat', this._displayFormat);

        this._elements.clock.displayFormat = this._displayFormat;
        this._elements.input.value = this._getValueAsString(this._value, this._displayFormat);
      }
      /**
       The format to use on expressing the selected date as a string on the <code>value</code> attribute. The value
       will be sent to the server using this format. If an empty string is provided, then the default value per type
       will be used. The default value depends on the <code>type</code>, which can be one from <code>YYYY-MM-DD</code>,
       <code>YYYY-MM-DD[T]HH:mmZ</code> or <code>HH:mm</code>. Include momentjs to support additional format string options
       see http://momentjs.com/docs/#/displaying/.
        @type {String}
       @default "YYYY-MM-DD"
       @htmlattribute valueformat
       @htmlattributereflected
       */

    }, {
      key: "valueFormat",
      get: function get() {
        return typeof this._valueFormat === 'undefined' ? NATIVE_FORMATS[this.type] : this._valueFormat;
      },
      set: function set(value) {
        var _this2 = this;

        var setValueFormat = function setValueFormat(newValue) {
          _this2._valueFormat = newValue === '' ? NATIVE_FORMATS[_this2.type] : newValue;

          _this2._reflectAttribute('valueformat', _this2._valueFormat);
        };

        value = transform.string(value).trim(); // In case a custom display format was set, we make sure that type doesn't change it to a native format

        var valueFormatAttribute = this.getAttribute('valueformat');

        if (this._typeFormatChanged && valueFormatAttribute && valueFormatAttribute !== value) {
          value = valueFormatAttribute;
        } // Once the valueFormat is set, we make sure the value is also correct


        if (!this._valueFormat && this._originalValue) {
          setValueFormat(value);
          this.value = this._originalValue;
        } else {
          setValueFormat(value);
        }

        this._elements.calendar.valueFormat = this._valueFormat;
        this._elements.hiddenInput.value = this.value;
      }
      /**
       The value of the element, interpreted as a date, or <code>null</code> if conversion is not possible.
        @type {Date}
       @default null
       */

    }, {
      key: "valueAsDate",
      get: function get() {
        var value = this._value; // If type is DATE, then you strip out the time

        if (this.type === 'date' && value) {
          value = value.startOf('day');
        }

        return value ? value.toDate() : null;
      },
      set: function set(value) {
        this._valueAsDate = value instanceof Date ? new DateTime.Moment(value) : '';
        this.value = this._valueAsDate;
      }
      /**
       The minimum date that the Datepicker will accept as valid. It must not be greated that its maximum. It accepts
       both date and string values. When a string is provided, it should match the {@link Coral.Datepicker#valueFormat}.
        See {@link Coral.Calendar#min}
        @type {String|Date}
       @default null
       @htmlattribute min
       */

    }, {
      key: "min",
      get: function get() {
        return this._elements.calendar.min;
      },
      set: function set(value) {
        this._elements.calendar.min = value;
      }
      /**
       The maximum date that the Datepicker will accept as valid. It must not be less than its minimum. It accepts both
       date and string values. When a string is provided, it should match the {@link Coral.Datepicker#valueFormat}.
        See {@link Coral.Calendar#max}
        @type {String|Date}
       @default null
       @htmlattribute max
       */

    }, {
      key: "max",
      get: function get() {
        return this._elements.calendar.max;
      },
      set: function set(value) {
        this._elements.calendar.max = value;
      }
      /**
       The format used to display the current month and year.
       'MMMM YYYY' is supported by default. Include momentjs to support additional format string options see
       http://momentjs.com/docs/#/displaying/.
        See {@link Coral.Calendar#startDay}
        @type {String}
       @default "MMMM YYYY"
       @htmlattribute headerformat
       */

    }, {
      key: "headerFormat",
      get: function get() {
        return this._elements.calendar.headerFormat;
      },
      set: function set(value) {
        this._elements.calendar.headerFormat = value;
      }
      /**
       Defines the start day for the week, 0 = Sunday, 1 = Monday etc., as depicted on the calendar days grid.
        See {@link Coral.Calendar#startDay}
        @type {Number}
       @default 0
       @htmlattribute startday
       */

    }, {
      key: "startDay",
      get: function get() {
        return this._elements.calendar.startDay;
      },
      set: function set(value) {
        this._elements.calendar.startDay = value;
      }
      /**
       The current value. When set to "today", the value is coerced into the client's local date expressed as string
       formatted in accordance to the set <code>valueFormat</code>.
        See {@link Coral.Calendar#value}
        @type {String}
       @default ""
       @htmlattribute value
       */

    }, {
      key: "value",
      get: function get() {
        return this._getValueAsString(this._value, this.valueFormat);
      },
      set: function set(value) {
        // This is used to change the value if valueformat is also set but afterwards
        this._originalValue = value;
        this._value = toMoment$1(value, this.valueFormat);
        this._elements.calendar.valueAsDate = this.valueAsDate;
        this._elements.clock.valueAsDate = this.valueAsDate;
        this._elements.input.value = this._getValueAsString(this._value, this.displayFormat);
        this._elements.hiddenInput.value = this.value;
      }
      /**
       Short hint that describes the expected value of the Datepicker. It is displayed when the Datepicker is empty.
        @type {String}
       @default ""
       @htmlattribute placeholder
       @htmlattributereflected
       */

    }, {
      key: "placeholder",
      get: function get() {
        return this._elements.input.placeholder;
      },
      set: function set(value) {
        this._elements.input.placeholder = value;

        this._reflectAttribute('placeholder', this.placeholder);
      }
      /**
       The datepicker's variant. See {@link DatepickerVariantEnum}.
        @type {DatepickerVariantEnum}
       @default DatepickerVariantEnum.DEFAULT
       @htmlattribute variant
       @htmlattributereflected
       */

    }, {
      key: "variant",
      get: function get() {
        return this._variant || variant$h.DEFAULT;
      },
      set: function set(value) {
        var _this$classList;

        value = transform.string(value).toLowerCase();
        this._variant = validate.enumeration(variant$h)(value) && value || variant$h.DEFAULT; // passes down the variant to the underlying components

        this._elements.input.variant = this._variant;

        this._elements.toggle.classList.toggle('_coral-FieldButton--quiet', this._variant === variant$h.QUIET); // removes every existing variant


        (_this$classList = this.classList).remove.apply(_this$classList, ALL_VARIANT_CLASSES$a);

        if (this._variant !== variant$h.DEFAULT) {
          this.classList.add("".concat(CLASSNAME$T, "--").concat(this._variant));
        }
      }
      /**
       Name used to submit the data in a form.
       @type {String}
       @default ""
       @htmlattribute name
       @htmlattributereflected
       */

    }, {
      key: "name",
      get: function get() {
        return this._elements.hiddenInput.name;
      },
      set: function set(value) {
        this._reflectAttribute('name', value);

        this._elements.hiddenInput.name = value;
      }
      /**
       Whether this field is disabled or not.
       @type {Boolean}
       @default false
       @htmlattribute disabled
       @htmlattributereflected
       */

    }, {
      key: "disabled",
      get: function get() {
        return this._disabled || false;
      },
      set: function set(value) {
        this._disabled = transform.booleanAttr(value);

        this._reflectAttribute('disabled', this._disabled);

        this[this._disabled ? 'setAttribute' : 'removeAttribute']('aria-disabled', this._disabled);
        this.classList.toggle('is-disabled', this._disabled);
        this._elements.input.disabled = this._disabled;
        this._elements.hiddenInput.disabled = this._disabled;
        this._elements.toggle.disabled = this._disabled;
      }
      /**
       Inherited from {@link BaseFormField#invalid}.
       */

    }, {
      key: "invalid",
      get: function get() {
        return _get(_getPrototypeOf(Datepicker.prototype), "invalid", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(Datepicker.prototype), "invalid", value, this, true);

        this.classList.toggle('is-invalid', this.invalid);

        this._elements.toggle.classList.toggle('is-invalid', this.invalid);

        this._elements.input.invalid = this.invalid;

        this._elements.input.setAttribute('aria-invalid', this.invalid);
      }
      /**
       Whether this field is required or not.
       @type {Boolean}
       @default false
       @htmlattribute required
       @htmlattributereflected
       */

    }, {
      key: "required",
      get: function get() {
        return this._required || false;
      },
      set: function set(value) {
        this._required = transform.booleanAttr(value);

        this._reflectAttribute('required', this._required);

        this._elements.toggle.classList.toggle('is-invalid', this._required);

        this._elements.input.required = this._required;
      }
      /**
       Whether this field is readOnly or not. Indicating that the user cannot modify the value of the control.
       @type {Boolean}
       @default false
       @htmlattribute readonly
       @htmlattributereflected
       */

    }, {
      key: "readOnly",
      get: function get() {
        return this._readOnly || false;
      },
      set: function set(value) {
        this._readOnly = transform.booleanAttr(value);

        this._reflectAttribute('readonly', this._readOnly);

        this._elements.hiddenInput.readOnly = this.readOnly;
        this._elements.input.readOnly = this._readOnly;
        this._elements.toggle.disabled = this._readOnly;
      }
      /**
       Inherited from {@link BaseFormField#labelled}.
       */

    }, {
      key: "labelled",
      get: function get() {
        return _get(_getPrototypeOf(Datepicker.prototype), "labelled", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(Datepicker.prototype), "labelled", value, this, true); // in case the user focuses the buttons, he will still get a notion of the usage of the component


        this[this.labelled ? 'setAttribute' : 'removeAttribute']('aria-label', this.labelled);

        this._elements.overlay[this.labelled ? 'setAttribute' : 'removeAttribute']('aria-label', this.labelled);

        this._elements.calendar[this.labelled ? 'setAttribute' : 'removeAttribute']('labelled', this.labelled);
      }
      /**
       Inherited from {@link BaseFormField#labelledBy}.
       */

    }, {
      key: "labelledBy",
      get: function get() {
        return _get(_getPrototypeOf(Datepicker.prototype), "labelledBy", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(Datepicker.prototype), "labelledBy", value, this, true); // in case the user focuses the buttons, he will still get a notion of the usage of the component


        this[this.labelledBy ? 'setAttribute' : 'removeAttribute']('aria-labelledby', this.labelledBy);

        this._elements.overlay[this.labelledBy ? 'setAttribute' : 'removeAttribute']('aria-labelledby', this.labelledBy);

        this._elements.calendar[this.labelledBy ? 'setAttribute' : 'removeAttribute']('aria-labelledby', this.labelledBy);
      }
      /**
       When <code>true</code> the component will default to the native input for the date selection. When
       {@link Coral.Datepicker.type.DATETIME} has been set, it will still use the Coral way because mobile browsers
       cannot handle a datetime input.
        @ignore
       */

    }, {
      key: "_useNativeInput",
      get: function get() {
        return this.__useNativeInput;
      },
      set: function set(value) {
        this.__useNativeInput = value; // we ignore _useNativeInput when the type is datetime because it is not supported by mobile libraries

        if (this.__useNativeInput && this.type !== type.DATETIME) {
          // Switch to native date/time picker:
          this._elements.toggle.hidden = true;

          this._elements.input.setAttribute('type', this.type); // Hide pop-over and remove related attributes:


          this._elements.overlay.hidden = true;

          this._elements.input.removeAttribute('role');

          this._elements.input.removeAttribute('aria-autocomplete');

          this._elements.input.removeAttribute('aria-haspopup');

          this._elements.input.removeAttribute('aria-expanded');

          this._elements.input.removeAttribute('aria-controls');
        } else {
          // Switch to Calendar picker
          this._elements.toggle.hidden = false;

          this._elements.input.setAttribute('type', 'text'); // Show pop-over and add related attributes:


          this._elements.overlay.hidden = false; // Input attributes per ARIA Autocomplete

          this._elements.input.setAttribute('role', 'combobox');

          this._elements.input.setAttribute('aria-autocomplete', 'none');

          this._elements.input.setAttribute('aria-haspopup', 'dialog');

          this._elements.input.setAttribute('aria-expanded', this._elements.overlay.open);

          this._elements.input.setAttribute('aria-controls', this._elements.overlay.id); // Trigger button attributes per ARIA Autocomplete


          this._elements.toggle.setAttribute('aria-haspopup', 'dialog');

          this._elements.toggle.setAttribute('aria-expanded', this._elements.overlay.open);

          this._elements.toggle.setAttribute('aria-controls', this._elements.overlay.id);
        }
      }
    }], [{
      key: "variant",
      get: function get() {
        return variant$h;
      }
      /**
       Returns {@link Datepicker} types.
        @return {DatepickerTypeEnum}
       */

    }, {
      key: "type",
      get: function get() {
        return type;
      }
    }, {
      key: "_attributePropertyMap",
      get: function get() {
        return commons.extend(_get(_getPrototypeOf(Datepicker), "_attributePropertyMap", this), {
          startday: 'startDay',
          headerformat: 'headerFormat',
          displayformat: 'displayFormat',
          valueformat: 'valueFormat'
        });
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(Datepicker), "observedAttributes", this).concat(['min', 'max', 'type', 'placeholder', 'startday', 'headerFormat', 'displayformat', 'valueformat', 'variant']);
      }
    }]);

    return Datepicker;
  }(BaseFormField(BaseComponent(HTMLElement)));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons.extend(strings, {
    'coral-component-datepicker': translations$f
  }); // Expose component on the Coral namespace

  commons._define('coral-datepicker', Datepicker);

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var translations$g = {
    "en-US": {
      "More": "More"
    },
    "de-DE": {
      "More": "Mehr"
    },
    "fr-FR": {
      "More": "Plus"
    },
    "it-IT": {
      "More": "Altro"
    },
    "ja-JP": {
      "More": "ãã®ä»"
    },
    "es-ES": {
      "More": "MÃ¡s"
    },
    "ko-KR": {
      "More": "ìì¸í"
    },
    "zh-CN": {
      "More": "æ´å¤"
    },
    "zh-TW": {
      "More": "æ´å¤"
    },
    "pt-BR": {
      "More": "Mais"
    },
    "nl-NL": {
      "More": "Meer"
    },
    "da-DK": {
      "More": "Mere"
    },
    "fi-FI": {
      "More": "LisÃ¤Ã¤"
    },
    "nb-NO": {
      "More": "Mer"
    },
    "sv-SE": {
      "More": "Mer"
    },
    "cs-CZ": {
      "More": "VÃ­ce"
    },
    "pl-PL": {
      "More": "WiÄcej"
    },
    "ru-RU": {
      "More": "ÐÐ¾Ð¿Ð¾Ð»Ð½Ð¸ÑÐµÐ»ÑÐ½Ð¾"
    },
    "tr-TR": {
      "More": "Daha Fazla"
    }
  };

  var template$B = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var data = data_0 = typeof data_0 === "undefined" ? {} : data_0;
    data = data_0;
    var buttonId = data.commons.getUID();
    var contentId = data.commons.getUID();
    data_0 = data;
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    var el2 = this["slider"] = document.createElement("div");
    el2.setAttribute("handle", "slider");
    el2.className += " _coral-Drawer-slider";
    var el3 = document.createTextNode("\n  ");
    el2.appendChild(el3);
    var el4 = this["contentWrapper"] = document.createElement("div");
    el4.setAttribute("handle", "contentWrapper");
    el4.className += " _coral-Drawer-content";
    el4.id = contentId;
    el4.setAttribute("aria-labelledby", buttonId);
    el4.setAttribute("role", "region");
    el2.appendChild(el4);
    var el5 = document.createTextNode("\n");
    el2.appendChild(el5);
    frag.appendChild(el2);
    var el6 = document.createTextNode("\n");
    frag.appendChild(el6);
    var el7 = this["toggle"] = document.createElement("div");
    el7.className += " _coral-Drawer-toggle";
    el7.setAttribute("handle", "toggle");
    var el8 = document.createTextNode("\n  ");
    el7.appendChild(el8);
    var el9 = this["toggleButton"] = document.createElement("button", "coral-button");
    el9.id = buttonId;
    el9.setAttribute("aria-controls", contentId);
    el9.setAttribute("aria-label", data_0["i18n"]["get"]('More'));
    el9.className += " _coral-Drawer-toggleButton";
    el9.setAttribute("type", "button");
    el9.setAttribute("handle", "toggleButton");
    el9.setAttribute("is", "coral-button");
    el9.setAttribute("variant", "quiet");
    el7.appendChild(el9);
    var el10 = document.createTextNode("\n");
    el7.appendChild(el10);
    frag.appendChild(el7);
    var el11 = document.createTextNode("\n");
    frag.appendChild(el11);
    return frag;
  };

  /**
   Enumeration for {@link Drawer} directions.

   @typedef {Object} DrawerDirectionEnum

   @property {String} DOWN
   A drawer with a toggle button on the bottom.
   @property {String} UP
   A drawer with a toggle button on top.
   */

  var direction$1 = {
    DOWN: 'down',
    UP: 'up'
  }; // The drawer's base classname

  var CLASSNAME$U = '_coral-Drawer'; // A string of all possible direction classnames

  var ALL_DIRECTION_CLASSES = [];

  for (var directionValue in direction$1) {
    ALL_DIRECTION_CLASSES.push("".concat(CLASSNAME$U, "--").concat(direction$1[directionValue]));
  }
  /**
   @class Coral.Drawer
   @classdesc A Drawer component to display content that can be opened and closed with a sliding animation.
   @htmltag coral-drawer
   @extends {HTMLElement}
   @extends {BaseComponent}
   */


  var Drawer = /*#__PURE__*/function (_BaseComponent) {
    _inherits(Drawer, _BaseComponent);

    var _super = _createSuper(Drawer);

    /** @ignore */
    function Drawer() {
      var _this;

      _classCallCheck(this, Drawer);

      _this = _super.call(this); // Templates

      _this._elements = {
        content: _this.querySelector('coral-drawer-content') || document.createElement('coral-drawer-content')
      };
      template$B.call(_this._elements, {
        commons: commons,
        i18n: i18n
      }); // Events

      _this._delegateEvents({
        'click ._coral-Drawer-toggleButton': '_onClick'
      });

      return _this;
    }
    /**
     Whether this item is disabled or not. This will stop every user interaction with the item.
      @type {Boolean}
     @default false
     @htmlattribute disabled
     @htmlattributereflected
     */


    _createClass(Drawer, [{
      key: "_onClick",

      /** @private */
      value: function _onClick() {
        this.open = !this.open;
      }
    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(Drawer.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$U, 'coral-Well'); // Default reflected attributes

        if (!this._direction) {
          this.direction = direction$1.DOWN;
        }

        if (!this._open) {
          this.open = false;
        } // Create a fragment


        var fragment = document.createDocumentFragment();
        var templateHandleNames = ['slider', 'toggle']; // Render the template

        fragment.appendChild(this._elements.slider);
        fragment.appendChild(this._elements.toggle); // Fetch or create the content content zone element

        var content = this._elements.content; // Move any remaining elements into the content sub-component

        while (this.firstChild) {
          var child = this.firstChild;

          if (child.nodeType === Node.TEXT_NODE || child.nodeType === Node.ELEMENT_NODE && templateHandleNames.indexOf(child.getAttribute('handle')) === -1) {
            // Add non-template elements to the label
            content.appendChild(child);
          } else {
            // Remove anything else
            this.removeChild(child);
          }
        } // Add the frag to the component


        this.appendChild(fragment); // Assign the content zone

        this.content = content;
      }
      /**
       Triggered when the {@link Drawer} is opened.
        @typedef {CustomEvent} coral-drawer:open
       */

      /**
       Triggered when the {@link Drawer} is closed.
        @typedef {CustomEvent} coral-drawer:close
       */

    }, {
      key: "disabled",
      get: function get() {
        return this._disabled || false;
      },
      set: function set(value) {
        this._disabled = transform.booleanAttr(value);

        this._reflectAttribute('disabled', this._disabled);

        this[this._disabled ? 'setAttribute' : 'removeAttribute']('aria-disabled', this._disabled);
        this._elements.toggle.hidden = this._disabled;
      }
      /**
       The drawer's content element.
        @type {DrawerContent}
       @htmlttribute content
       @contentzone
       */

    }, {
      key: "content",
      get: function get() {
        return this._getContentZone(this._elements.content);
      },
      set: function set(value) {
        this._setContentZone('content', value, {
          handle: 'content',
          tagName: 'coral-drawer-content',
          insert: function insert(content) {
            this._elements.contentWrapper.appendChild(content);
          }
        });
      }
      /**
       The drawer's direction. See {@link DrawerDirectionEnum}.
        @type {String}
       @default DrawerDirectionEnum.DOWN
       @htmlattribute direction
       @htmlattributereflected
       */

    }, {
      key: "direction",
      get: function get() {
        return this._direction || direction$1.DOWN;
      },
      set: function set(value) {
        var _this$classList;

        value = transform.string(value).toLowerCase();
        this._direction = validate.enumeration(direction$1)(value) && value || direction$1.DOWN;

        this._reflectAttribute('direction', this._direction);

        (_this$classList = this.classList).remove.apply(_this$classList, ALL_DIRECTION_CLASSES);

        this.classList.add("".concat(CLASSNAME$U, "--").concat(this._direction));
      }
      /**
       Whether the Drawer is expanded or not.
        @type {Boolean}
       @default false
       @htmlattribute open
       @htmlattributereflected
       */

    }, {
      key: "open",
      get: function get() {
        return this._open || false;
      },
      set: function set(value) {
        var _this2 = this;

        var silenced = this._silenced;
        this._open = transform.booleanAttr(value);

        this._reflectAttribute('open', this._open);

        this._elements.toggleButton.setAttribute('aria-expanded', this._open); // eslint-disable-next-line no-unused-vars

        var slider = this._elements.slider; // Don't animate on initialization

        if (this._animate) {
          commons.transitionEnd(slider, function () {
            // Keep it silenced
            _this2._silenced = silenced; // Remove height as we want the drawer to naturally grow if content is added later

            if (_this2._open) {
              slider.style.height = '';
            } // Trigger once transition is finished


            _this2.trigger("coral-drawer:".concat(_this2._open ? 'open' : 'close'));

            _this2._silenced = false;
          });

          if (!this._open) {
            // Force height to enable transition
            slider.style.height = "".concat(slider.scrollHeight, "px");
          } // Do transition in next task as browser might batch up the height property change before painting


          window.setTimeout(function () {
            slider.style.height = _this2._open ? "".concat(slider.scrollHeight, "px") : 0;
          }, 10);
        } else {
          // Make sure it's animated next time
          this._animate = true; // Hide it on initialization if closed

          if (!this._open) {
            slider.style.height = 0;
          }
        }
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-drawer-content': 'content'
        };
      }
      /**
       Returns {@link Drawer} direction options.
        @return {DrawerDirectionEnum}
       */

    }], [{
      key: "direction",
      get: function get() {
        return direction$1;
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(Drawer), "observedAttributes", this).concat(['disabled', 'direction', 'open']);
      }
    }]);

    return Drawer;
  }(BaseComponent(HTMLElement));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Drawer.Content
   @classdesc Drawer content component
   @htmltag coral-drawer-content
   @return {HTMLElement}
   */
  var DrawerContent = (function () {
    return document.createElement('coral-drawer-content');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons.extend(strings, {
    'coral-component-drawer': translations$g
  }); // Expose component on the Coral namespace

  commons._define('coral-drawer', Drawer);

  Drawer.Content = DrawerContent;

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var MIME_TYPES = {
    ".123": "application/vnd.lotus-1-2-3",
    ".3dml": "text/vnd.in3d.3dml",
    ".3g2": "video/3gpp2",
    ".3gp": "video/3gpp",
    ".a": "application/octet-stream",
    ".aab": "application/x-authorware-bin",
    ".aac": "audio/x-aac",
    ".aam": "application/x-authorware-map",
    ".aas": "application/x-authorware-seg",
    ".abw": "application/x-abiword",
    ".acc": "application/vnd.americandynamics.acc",
    ".ace": "application/x-ace-compressed",
    ".acu": "application/vnd.acucobol",
    ".acutc": "application/vnd.acucorp",
    ".adp": "audio/adpcm",
    ".aep": "application/vnd.audiograph",
    ".afm": "application/x-font-type1",
    ".afp": "application/vnd.ibm.modcap",
    ".ai": "application/postscript",
    ".aif": "audio/x-aiff",
    ".aifc": "audio/x-aiff",
    ".aiff": "audio/x-aiff",
    ".air": "application/vnd.adobe.air-application-installer-package+zip",
    ".ami": "application/vnd.amiga.ami",
    ".apk": "application/vnd.android.package-archive",
    ".application": "application/x-ms-application",
    ".apr": "application/vnd.lotus-approach",
    ".asc": "application/pgp-signature",
    ".asf": "video/x-ms-asf",
    ".asm": "text/x-asm",
    ".aso": "application/vnd.accpac.simply.aso",
    ".asx": "video/x-ms-asf",
    ".atc": "application/vnd.acucorp",
    ".atom": "application/atom+xml",
    ".atomcat": "application/atomcat+xml",
    ".atomsvc": "application/atomsvc+xml",
    ".atx": "application/vnd.antix.game-component",
    ".au": "audio/basic",
    ".avi": "video/x-msvideo",
    ".aw": "application/applixware",
    ".azf": "application/vnd.airzip.filesecure.azf",
    ".azs": "application/vnd.airzip.filesecure.azs",
    ".azw": "application/vnd.amazon.ebook",
    ".bat": "application/x-msdownload",
    ".bcpio": "application/x-bcpio",
    ".bdf": "application/x-font-bdf",
    ".bdm": "application/vnd.syncml.dm+wbxml",
    ".bh2": "application/vnd.fujitsu.oasysprs",
    ".bin": "application/octet-stream",
    ".bmi": "application/vnd.bmi",
    ".bmp": "image/bmp",
    ".book": "application/vnd.framemaker",
    ".box": "application/vnd.previewsystems.box",
    ".boz": "application/x-bzip2",
    ".bpk": "application/octet-stream",
    ".btif": "image/prs.btif",
    ".bz": "application/x-bzip",
    ".bz2": "application/x-bzip2",
    ".c": "text/x-c",
    ".c4d": "application/vnd.clonk.c4group",
    ".c4f": "application/vnd.clonk.c4group",
    ".c4g": "application/vnd.clonk.c4group",
    ".c4p": "application/vnd.clonk.c4group",
    ".c4u": "application/vnd.clonk.c4group",
    ".cab": "application/vnd.ms-cab-compressed",
    ".car": "application/vnd.curl.car",
    ".cat": "application/vnd.ms-pki.seccat",
    ".cc": "text/x-c",
    ".cct": "application/x-director",
    ".ccxml": "application/ccxml+xml",
    ".cdbcmsg": "application/vnd.contact.cmsg",
    ".cdf": "application/x-netcdf",
    ".cdkey": "application/vnd.mediastation.cdkey",
    ".cdx": "chemical/x-cdx",
    ".cdxml": "application/vnd.chemdraw+xml",
    ".cdy": "application/vnd.cinderella",
    ".cer": "application/pkix-cert",
    ".cgm": "image/cgm",
    ".chat": "application/x-chat",
    ".chm": "application/vnd.ms-htmlhelp",
    ".chrt": "application/vnd.kde.kchart",
    ".cif": "chemical/x-cif",
    ".cii": "application/vnd.anser-web-certificate-issue-initiation",
    ".cil": "application/vnd.ms-artgalry",
    ".cla": "application/vnd.claymore",
    ".class": "application/java-vm",
    ".clkk": "application/vnd.crick.clicker.keyboard",
    ".clkp": "application/vnd.crick.clicker.palette",
    ".clkt": "application/vnd.crick.clicker.template",
    ".clkw": "application/vnd.crick.clicker.wordbank",
    ".clkx": "application/vnd.crick.clicker",
    ".clp": "application/x-msclip",
    ".cmc": "application/vnd.cosmocaller",
    ".cmdf": "chemical/x-cmdf",
    ".cml": "chemical/x-cml",
    ".cmp": "application/vnd.yellowriver-custom-menu",
    ".cmx": "image/x-cmx",
    ".cod": "application/vnd.rim.cod",
    ".com": "application/x-msdownload",
    ".conf": "text/plain",
    ".cpio": "application/x-cpio",
    ".cpp": "text/x-c",
    ".cpt": "application/mac-compactpro",
    ".crd": "application/x-mscardfile",
    ".crl": "application/pkix-crl",
    ".crt": "application/x-x509-ca-cert",
    ".csh": "application/x-csh",
    ".csml": "chemical/x-csml",
    ".csp": "application/vnd.commonspace",
    ".css": "text/css",
    ".cst": "application/x-director",
    ".csv": ["text/csv", "application/vnd.ms-excel"],
    ".cu": "application/cu-seeme",
    ".curl": "text/vnd.curl",
    ".cww": "application/prs.cww",
    ".cxt": "application/x-director",
    ".cxx": "text/x-c",
    ".daf": "application/vnd.mobius.daf",
    ".dataless": "application/vnd.fdsn.seed",
    ".davmount": "application/davmount+xml",
    ".dcr": "application/x-director",
    ".dcurl": "text/vnd.curl.dcurl",
    ".dd2": "application/vnd.oma.dd2+xml",
    ".ddd": "application/vnd.fujixerox.ddd",
    ".deb": "application/x-debian-package",
    ".def": "text/plain",
    ".deploy": "application/octet-stream",
    ".der": "application/x-x509-ca-cert",
    ".dfac": "application/vnd.dreamfactory",
    ".dic": "text/x-c",
    ".diff": "text/plain",
    ".dir": "application/x-director",
    ".dis": "application/vnd.mobius.dis",
    ".dist": "application/octet-stream",
    ".distz": "application/octet-stream",
    ".djv": "image/vnd.djvu",
    ".djvu": "image/vnd.djvu",
    ".dll": "application/x-msdownload",
    ".dmg": "application/octet-stream",
    ".dms": "application/octet-stream",
    ".dna": "application/vnd.dna",
    ".doc": "application/msword",
    ".docm": "application/vnd.ms-word.document.macroenabled.12",
    ".docx": "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    ".dot": "application/msword",
    ".dotm": "application/vnd.ms-word.template.macroenabled.12",
    ".dotx": "application/vnd.openxmlformats-officedocument.wordprocessingml.template",
    ".dp": "application/vnd.osgi.dp",
    ".dpg": "application/vnd.dpgraph",
    ".dsc": "text/prs.lines.tag",
    ".dtb": "application/x-dtbook+xml",
    ".dtd": "application/xml-dtd",
    ".dts": "audio/vnd.dts",
    ".dtshd": "audio/vnd.dts.hd",
    ".dump": "application/octet-stream",
    ".dvi": "application/x-dvi",
    ".dwf": "model/vnd.dwf",
    ".dwg": "image/vnd.dwg",
    ".dxf": "image/vnd.dxf",
    ".dxp": "application/vnd.spotfire.dxp",
    ".dxr": "application/x-director",
    ".ecelp4800": "audio/vnd.nuera.ecelp4800",
    ".ecelp7470": "audio/vnd.nuera.ecelp7470",
    ".ecelp9600": "audio/vnd.nuera.ecelp9600",
    ".ecma": "application/ecmascript",
    ".edm": "application/vnd.novadigm.edm",
    ".edx": "application/vnd.novadigm.edx",
    ".efif": "application/vnd.picsel",
    ".ei6": "application/vnd.pg.osasli",
    ".elc": "application/octet-stream",
    ".eml": "message/rfc822",
    ".emma": "application/emma+xml",
    ".eol": "audio/vnd.digital-winds",
    ".eot": "application/vnd.ms-fontobject",
    ".eps": "application/postscript",
    ".epub": "application/epub+zip",
    ".es3": "application/vnd.eszigno3+xml",
    ".esf": "application/vnd.epson.esf",
    ".et3": "application/vnd.eszigno3+xml",
    ".etx": "text/x-setext",
    ".exe": "application/x-msdownload",
    ".ext": "application/vnd.novadigm.ext",
    ".ez": "application/andrew-inset",
    ".ez2": "application/vnd.ezpix-album",
    ".ez3": "application/vnd.ezpix-package",
    ".f": "text/x-fortran",
    ".f4v": "video/x-f4v",
    ".f77": "text/x-fortran",
    ".f90": "text/x-fortran",
    ".fbs": "image/vnd.fastbidsheet",
    ".fdf": "application/vnd.fdf",
    ".fe_launch": "application/vnd.denovo.fcselayout-link",
    ".fg5": "application/vnd.fujitsu.oasysgp",
    ".fgd": "application/x-director",
    ".fh": "image/x-freehand",
    ".fh4": "image/x-freehand",
    ".fh5": "image/x-freehand",
    ".fh7": "image/x-freehand",
    ".fhc": "image/x-freehand",
    ".fig": "application/x-xfig",
    ".fli": "video/x-fli",
    ".flo": "application/vnd.micrografx.flo",
    ".flv": "video/x-flv",
    ".flw": "application/vnd.kde.kivio",
    ".flx": "text/vnd.fmi.flexstor",
    ".fly": "text/vnd.fly",
    ".fm": "application/vnd.framemaker",
    ".fnc": "application/vnd.frogans.fnc",
    ".for": "text/x-fortran",
    ".fpx": "image/vnd.fpx",
    ".frame": "application/vnd.framemaker",
    ".fsc": "application/vnd.fsc.weblaunch",
    ".fst": "image/vnd.fst",
    ".ftc": "application/vnd.fluxtime.clip",
    ".fti": "application/vnd.anser-web-funds-transfer-initiation",
    ".fvt": "video/vnd.fvt",
    ".fzs": "application/vnd.fuzzysheet",
    ".g3": "image/g3fax",
    ".gac": "application/vnd.groove-account",
    ".gdl": "model/vnd.gdl",
    ".geo": "application/vnd.dynageo",
    ".gex": "application/vnd.geometry-explorer",
    ".ggb": "application/vnd.geogebra.file",
    ".ggt": "application/vnd.geogebra.tool",
    ".ghf": "application/vnd.groove-help",
    ".gif": "image/gif",
    ".gim": "application/vnd.groove-identity-message",
    ".gmx": "application/vnd.gmx",
    ".gnumeric": "application/x-gnumeric",
    ".gph": "application/vnd.flographit",
    ".gqf": "application/vnd.grafeq",
    ".gqs": "application/vnd.grafeq",
    ".gram": "application/srgs",
    ".gre": "application/vnd.geometry-explorer",
    ".grv": "application/vnd.groove-injector",
    ".grxml": "application/srgs+xml",
    ".gsf": "application/x-font-ghostscript",
    ".gtar": "application/x-gtar",
    ".gtm": "application/vnd.groove-tool-message",
    ".gtw": "model/vnd.gtw",
    ".gv": "text/vnd.graphviz",
    ".gz": "application/x-gzip",
    ".h": "text/x-c",
    ".h261": "video/h261",
    ".h263": "video/h263",
    ".h264": "video/h264",
    ".hbci": "application/vnd.hbci",
    ".hdf": "application/x-hdf",
    ".hh": "text/x-c",
    ".hlp": "application/winhlp",
    ".hpgl": "application/vnd.hp-hpgl",
    ".hpid": "application/vnd.hp-hpid",
    ".hps": "application/vnd.hp-hps",
    ".hqx": "application/mac-binhex40",
    ".htke": "application/vnd.kenameaapp",
    ".htm": "text/html",
    ".html": "text/html",
    ".hvd": "application/vnd.yamaha.hv-dic",
    ".hvp": "application/vnd.yamaha.hv-voice",
    ".hvs": "application/vnd.yamaha.hv-script",
    ".icc": "application/vnd.iccprofile",
    ".ice": "x-conference/x-cooltalk",
    ".icm": "application/vnd.iccprofile",
    ".ico": "image/x-icon",
    ".ics": "text/calendar",
    ".ief": "image/ief",
    ".ifb": "text/calendar",
    ".ifm": "application/vnd.shana.informed.formdata",
    ".iges": "model/iges",
    ".igl": "application/vnd.igloader",
    ".igs": "model/iges",
    ".igx": "application/vnd.micrografx.igx",
    ".iif": "application/vnd.shana.informed.interchange",
    ".imp": "application/vnd.accpac.simply.imp",
    ".ims": "application/vnd.ms-ims",
    ".in": "text/plain",
    ".ipk": "application/vnd.shana.informed.package",
    ".irm": "application/vnd.ibm.rights-management",
    ".irp": "application/vnd.irepository.package+xml",
    ".iso": "application/octet-stream",
    ".itp": "application/vnd.shana.informed.formtemplate",
    ".ivp": "application/vnd.immervision-ivp",
    ".ivu": "application/vnd.immervision-ivu",
    ".jad": "text/vnd.sun.j2me.app-descriptor",
    ".jam": "application/vnd.jam",
    ".jar": "application/java-archive",
    ".java": "text/x-java-source",
    ".jisp": "application/vnd.jisp",
    ".jlt": "application/vnd.hp-jlyt",
    ".jnlp": "application/x-java-jnlp-file",
    ".joda": "application/vnd.joost.joda-archive",
    ".jpe": "image/jpeg",
    ".jpeg": "image/jpeg",
    ".jpg": "image/jpeg",
    ".jpgm": "video/jpm",
    ".jpgv": "video/jpeg",
    ".jpm": "video/jpm",
    ".js": "application/javascript",
    ".json": "application/json",
    ".kar": "audio/midi",
    ".karbon": "application/vnd.kde.karbon",
    ".kfo": "application/vnd.kde.kformula",
    ".kia": "application/vnd.kidspiration",
    ".kil": "application/x-killustrator",
    ".kml": "application/vnd.google-earth.kml+xml",
    ".kmz": "application/vnd.google-earth.kmz",
    ".kne": "application/vnd.kinar",
    ".knp": "application/vnd.kinar",
    ".kon": "application/vnd.kde.kontour",
    ".kpr": "application/vnd.kde.kpresenter",
    ".kpt": "application/vnd.kde.kpresenter",
    ".ksh": "text/plain",
    ".ksp": "application/vnd.kde.kspread",
    ".ktr": "application/vnd.kahootz",
    ".ktz": "application/vnd.kahootz",
    ".kwd": "application/vnd.kde.kword",
    ".kwt": "application/vnd.kde.kword",
    ".latex": "application/x-latex",
    ".lbd": "application/vnd.llamagraphics.life-balance.desktop",
    ".lbe": "application/vnd.llamagraphics.life-balance.exchange+xml",
    ".les": "application/vnd.hhe.lesson-player",
    ".lha": "application/octet-stream",
    ".link66": "application/vnd.route66.link66+xml",
    ".list": "text/plain",
    ".list3820": "application/vnd.ibm.modcap",
    ".listafp": "application/vnd.ibm.modcap",
    ".log": "text/plain",
    ".lostxml": "application/lost+xml",
    ".lrf": "application/octet-stream",
    ".lrm": "application/vnd.ms-lrm",
    ".ltf": "application/vnd.frogans.ltf",
    ".lvp": "audio/vnd.lucent.voice",
    ".lwp": "application/vnd.lotus-wordpro",
    ".lzh": "application/octet-stream",
    ".m13": "application/x-msmediaview",
    ".m14": "application/x-msmediaview",
    ".m1v": "video/mpeg",
    ".m2a": "audio/mpeg",
    ".m2v": "video/mpeg",
    ".m3a": "audio/mpeg",
    ".m3u": "audio/x-mpegurl",
    ".m4u": "video/vnd.mpegurl",
    ".m4v": "video/x-m4v",
    ".ma": "application/mathematica",
    ".mag": "application/vnd.ecowin.chart",
    ".maker": "application/vnd.framemaker",
    ".man": "text/troff",
    ".mathml": "application/mathml+xml",
    ".mb": "application/mathematica",
    ".mbk": "application/vnd.mobius.mbk",
    ".mbox": "application/mbox",
    ".mc1": "application/vnd.medcalcdata",
    ".mcd": "application/vnd.mcd",
    ".mcurl": "text/vnd.curl.mcurl",
    ".mdb": "application/x-msaccess",
    ".mdi": "image/vnd.ms-modi",
    ".me": "text/troff",
    ".mesh": "model/mesh",
    ".mfm": "application/vnd.mfmp",
    ".mgz": "application/vnd.proteus.magazine",
    ".mht": "message/rfc822",
    ".mhtml": "message/rfc822",
    ".mid": "audio/midi",
    ".midi": "audio/midi",
    ".mif": "application/vnd.mif",
    ".mime": "message/rfc822",
    ".mj2": "video/mj2",
    ".mjp2": "video/mj2",
    ".mlp": "application/vnd.dolby.mlp",
    ".mmd": "application/vnd.chipnuts.karaoke-mmd",
    ".mmf": "application/vnd.smaf",
    ".mmr": "image/vnd.fujixerox.edmics-mmr",
    ".mny": "application/x-msmoney",
    ".mobi": "application/x-mobipocket-ebook",
    ".mov": "video/quicktime",
    ".movie": "video/x-sgi-movie",
    ".mp2": "audio/mpeg",
    ".mp2a": "audio/mpeg",
    ".mp3": "audio/mpeg",
    ".mp4": "video/mp4",
    ".mp4a": "audio/mp4",
    ".mp4s": "application/mp4",
    ".mp4v": "video/mp4",
    ".mpa": "video/mpeg",
    ".mpc": "application/vnd.mophun.certificate",
    ".mpe": "video/mpeg",
    ".mpeg": "video/mpeg",
    ".mpg": "video/mpeg",
    ".mpg4": "video/mp4",
    ".mpga": "audio/mpeg",
    ".mpkg": "application/vnd.apple.installer+xml",
    ".mpm": "application/vnd.blueice.multipass",
    ".mpn": "application/vnd.mophun.application",
    ".mpp": "application/vnd.ms-project",
    ".mpt": "application/vnd.ms-project",
    ".mpy": "application/vnd.ibm.minipay",
    ".mqy": "application/vnd.mobius.mqy",
    ".mrc": "application/marc",
    ".ms": "text/troff",
    ".mscml": "application/mediaservercontrol+xml",
    ".mseed": "application/vnd.fdsn.mseed",
    ".mseq": "application/vnd.mseq",
    ".msf": "application/vnd.epson.msf",
    ".msh": "model/mesh",
    ".msi": "application/x-msdownload",
    ".msl": "application/vnd.mobius.msl",
    ".msty": "application/vnd.muvee.style",
    ".mts": "model/vnd.mts",
    ".mus": "application/vnd.musician",
    ".musicxml": "application/vnd.recordare.musicxml+xml",
    ".mvb": "application/x-msmediaview",
    ".mwf": "application/vnd.mfer",
    ".mxf": "application/mxf",
    ".mxl": "application/vnd.recordare.musicxml",
    ".mxml": "application/xv+xml",
    ".mxs": "application/vnd.triscape.mxs",
    ".mxu": "video/vnd.mpegurl",
    ".n-gage": "application/vnd.nokia.n-gage.symbian.install",
    ".nb": "application/mathematica",
    ".nc": "application/x-netcdf",
    ".ncx": "application/x-dtbncx+xml",
    ".ngdat": "application/vnd.nokia.n-gage.data",
    ".nlu": "application/vnd.neurolanguage.nlu",
    ".nml": "application/vnd.enliven",
    ".nnd": "application/vnd.noblenet-directory",
    ".nns": "application/vnd.noblenet-sealer",
    ".nnw": "application/vnd.noblenet-web",
    ".npx": "image/vnd.net-fpx",
    ".nsf": "application/vnd.lotus-notes",
    ".nws": "message/rfc822",
    ".o": "application/octet-stream",
    ".oa2": "application/vnd.fujitsu.oasys2",
    ".oa3": "application/vnd.fujitsu.oasys3",
    ".oas": "application/vnd.fujitsu.oasys",
    ".obd": "application/x-msbinder",
    ".obj": "application/octet-stream",
    ".oda": "application/oda",
    ".odb": "application/vnd.oasis.opendocument.database",
    ".odc": "application/vnd.oasis.opendocument.chart",
    ".odf": "application/vnd.oasis.opendocument.formula",
    ".odft": "application/vnd.oasis.opendocument.formula-template",
    ".odg": "application/vnd.oasis.opendocument.graphics",
    ".odi": "application/vnd.oasis.opendocument.image",
    ".odp": "application/vnd.oasis.opendocument.presentation",
    ".ods": "application/vnd.oasis.opendocument.spreadsheet",
    ".odt": "application/vnd.oasis.opendocument.text",
    ".oga": "audio/ogg",
    ".ogg": "audio/ogg",
    ".ogv": "video/ogg",
    ".ogx": "application/ogg",
    ".onepkg": "application/onenote",
    ".onetmp": "application/onenote",
    ".onetoc": "application/onenote",
    ".onetoc2": "application/onenote",
    ".opf": "application/oebps-package+xml",
    ".oprc": "application/vnd.palm",
    ".org": "application/vnd.lotus-organizer",
    ".osf": "application/vnd.yamaha.openscoreformat",
    ".osfpvg": "application/vnd.yamaha.openscoreformat.osfpvg+xml",
    ".otc": "application/vnd.oasis.opendocument.chart-template",
    ".otf": "application/x-font-otf",
    ".otg": "application/vnd.oasis.opendocument.graphics-template",
    ".oth": "application/vnd.oasis.opendocument.text-web",
    ".oti": "application/vnd.oasis.opendocument.image-template",
    ".otm": "application/vnd.oasis.opendocument.text-master",
    ".otp": "application/vnd.oasis.opendocument.presentation-template",
    ".ots": "application/vnd.oasis.opendocument.spreadsheet-template",
    ".ott": "application/vnd.oasis.opendocument.text-template",
    ".oxt": "application/vnd.openofficeorg.extension",
    ".p": "text/x-pascal",
    ".p10": "application/pkcs10",
    ".p12": "application/x-pkcs12",
    ".p7b": "application/x-pkcs7-certificates",
    ".p7c": "application/pkcs7-mime",
    ".p7m": "application/pkcs7-mime",
    ".p7r": "application/x-pkcs7-certreqresp",
    ".p7s": "application/pkcs7-signature",
    ".pas": "text/x-pascal",
    ".pbd": "application/vnd.powerbuilder6",
    ".pbm": "image/x-portable-bitmap",
    ".pcf": "application/x-font-pcf",
    ".pcl": "application/vnd.hp-pcl",
    ".pclxl": "application/vnd.hp-pclxl",
    ".pct": "image/x-pict",
    ".pcurl": "application/vnd.curl.pcurl",
    ".pcx": "image/x-pcx",
    ".pdb": "application/vnd.palm",
    ".pdf": "application/pdf",
    ".pfa": "application/x-font-type1",
    ".pfb": "application/x-font-type1",
    ".pfm": "application/x-font-type1",
    ".pfr": "application/font-tdpfr",
    ".pfx": "application/x-pkcs12",
    ".pgm": "image/x-portable-graymap",
    ".pgn": "application/x-chess-pgn",
    ".pgp": "application/pgp-encrypted",
    ".pic": "image/x-pict",
    ".pkg": "application/octet-stream",
    ".pki": "application/pkixcmp",
    ".pkipath": "application/pkix-pkipath",
    ".pl": "text/plain",
    ".plb": "application/vnd.3gpp.pic-bw-large",
    ".plc": "application/vnd.mobius.plc",
    ".plf": "application/vnd.pocketlearn",
    ".pls": "application/pls+xml",
    ".pml": "application/vnd.ctc-posml",
    ".png": "image/png",
    ".pnm": "image/x-portable-anymap",
    ".portpkg": "application/vnd.macports.portpkg",
    ".pot": "application/vnd.ms-powerpoint",
    ".potm": "application/vnd.ms-powerpoint.template.macroenabled.12",
    ".potx": "application/vnd.openxmlformats-officedocument.presentationml.template",
    ".ppa": "application/vnd.ms-powerpoint",
    ".ppam": "application/vnd.ms-powerpoint.addin.macroenabled.12",
    ".ppd": "application/vnd.cups-ppd",
    ".ppm": "image/x-portable-pixmap",
    ".pps": "application/vnd.ms-powerpoint",
    ".ppsm": "application/vnd.ms-powerpoint.slideshow.macroenabled.12",
    ".ppsx": "application/vnd.openxmlformats-officedocument.presentationml.slideshow",
    ".ppt": "application/vnd.ms-powerpoint",
    ".pptm": "application/vnd.ms-powerpoint.presentation.macroenabled.12",
    ".pptx": "application/vnd.openxmlformats-officedocument.presentationml.presentation",
    ".pqa": "application/vnd.palm",
    ".prc": "application/x-mobipocket-ebook",
    ".pre": "application/vnd.lotus-freelance",
    ".prf": "application/pics-rules",
    ".ps": "application/postscript",
    ".psb": "application/vnd.3gpp.pic-bw-small",
    ".psd": "image/vnd.adobe.photoshop",
    ".psf": "application/x-font-linux-psf",
    ".ptid": "application/vnd.pvi.ptid1",
    ".pub": "application/x-mspublisher",
    ".pvb": "application/vnd.3gpp.pic-bw-var",
    ".pwn": "application/vnd.3m.post-it-notes",
    ".pwz": "application/vnd.ms-powerpoint",
    ".py": "text/x-python",
    ".pya": "audio/vnd.ms-playready.media.pya",
    ".pyc": "application/x-python-code",
    ".pyo": "application/x-python-code",
    ".pyv": "video/vnd.ms-playready.media.pyv",
    ".qam": "application/vnd.epson.quickanime",
    ".qbo": "application/vnd.intu.qbo",
    ".qfx": "application/vnd.intu.qfx",
    ".qps": "application/vnd.publishare-delta-tree",
    ".qt": "video/quicktime",
    ".qwd": "application/vnd.quark.quarkxpress",
    ".qwt": "application/vnd.quark.quarkxpress",
    ".qxb": "application/vnd.quark.quarkxpress",
    ".qxd": "application/vnd.quark.quarkxpress",
    ".qxl": "application/vnd.quark.quarkxpress",
    ".qxt": "application/vnd.quark.quarkxpress",
    ".ra": "audio/x-pn-realaudio",
    ".ram": "audio/x-pn-realaudio",
    ".rar": "application/x-rar-compressed",
    ".ras": "image/x-cmu-raster",
    ".rcprofile": "application/vnd.ipunplugged.rcprofile",
    ".rdf": "application/rdf+xml",
    ".rdz": "application/vnd.data-vision.rdz",
    ".rep": "application/vnd.businessobjects",
    ".res": "application/x-dtbresource+xml",
    ".rgb": "image/x-rgb",
    ".rif": "application/reginfo+xml",
    ".rl": "application/resource-lists+xml",
    ".rlc": "image/vnd.fujixerox.edmics-rlc",
    ".rld": "application/resource-lists-diff+xml",
    ".rm": "application/vnd.rn-realmedia",
    ".rmi": "audio/midi",
    ".rmp": "audio/x-pn-realaudio-plugin",
    ".rms": "application/vnd.jcp.javame.midlet-rms",
    ".rnc": "application/relax-ng-compact-syntax",
    ".roff": "text/troff",
    ".rpm": "application/x-rpm",
    ".rpss": "application/vnd.nokia.radio-presets",
    ".rpst": "application/vnd.nokia.radio-preset",
    ".rq": "application/sparql-query",
    ".rs": "application/rls-services+xml",
    ".rsd": "application/rsd+xml",
    ".rss": "application/rss+xml",
    ".rtf": "application/rtf",
    ".rtx": "text/richtext",
    ".s": "text/x-asm",
    ".saf": "application/vnd.yamaha.smaf-audio",
    ".sbml": "application/sbml+xml",
    ".sc": "application/vnd.ibm.secure-container",
    ".scd": "application/x-msschedule",
    ".scm": "application/vnd.lotus-screencam",
    ".scq": "application/scvp-cv-request",
    ".scs": "application/scvp-cv-response",
    ".scurl": "text/vnd.curl.scurl",
    ".sda": "application/vnd.stardivision.draw",
    ".sdc": "application/vnd.stardivision.calc",
    ".sdd": "application/vnd.stardivision.impress",
    ".sdkd": "application/vnd.solent.sdkm+xml",
    ".sdkm": "application/vnd.solent.sdkm+xml",
    ".sdp": "application/sdp",
    ".sdw": "application/vnd.stardivision.writer",
    ".see": "application/vnd.seemail",
    ".seed": "application/vnd.fdsn.seed",
    ".sema": "application/vnd.sema",
    ".semd": "application/vnd.semd",
    ".semf": "application/vnd.semf",
    ".ser": "application/java-serialized-object",
    ".setpay": "application/set-payment-initiation",
    ".setreg": "application/set-registration-initiation",
    ".sfd-hdstx": "application/vnd.hydrostatix.sof-data",
    ".sfs": "application/vnd.spotfire.sfs",
    ".sgl": "application/vnd.stardivision.writer-global",
    ".sgm": "text/sgml",
    ".sgml": "text/sgml",
    ".sh": "application/x-sh",
    ".shar": "application/x-shar",
    ".shf": "application/shf+xml",
    ".si": "text/vnd.wap.si",
    ".sic": "application/vnd.wap.sic",
    ".sig": "application/pgp-signature",
    ".silo": "model/mesh",
    ".sis": "application/vnd.symbian.install",
    ".sisx": "application/vnd.symbian.install",
    ".sit": "application/x-stuffit",
    ".sitx": "application/x-stuffitx",
    ".skd": "application/vnd.koan",
    ".skm": "application/vnd.koan",
    ".skp": "application/vnd.koan",
    ".skt": "application/vnd.koan",
    ".sl": "text/vnd.wap.sl",
    ".slc": "application/vnd.wap.slc",
    ".sldm": "application/vnd.ms-powerpoint.slide.macroenabled.12",
    ".sldx": "application/vnd.openxmlformats-officedocument.presentationml.slide",
    ".slt": "application/vnd.epson.salt",
    ".smf": "application/vnd.stardivision.math",
    ".smi": "application/smil+xml",
    ".smil": "application/smil+xml",
    ".snd": "audio/basic",
    ".snf": "application/x-font-snf",
    ".so": "application/octet-stream",
    ".spc": "application/x-pkcs7-certificates",
    ".spf": "application/vnd.yamaha.smaf-phrase",
    ".spl": "application/x-futuresplash",
    ".spot": "text/vnd.in3d.spot",
    ".spp": "application/scvp-vp-response",
    ".spq": "application/scvp-vp-request",
    ".spx": "audio/ogg",
    ".src": "application/x-wais-source",
    ".srx": "application/sparql-results+xml",
    ".sse": "application/vnd.kodak-descriptor",
    ".ssf": "application/vnd.epson.ssf",
    ".ssml": "application/ssml+xml",
    ".stc": "application/vnd.sun.xml.calc.template",
    ".std": "application/vnd.sun.xml.draw.template",
    ".stf": "application/vnd.wt.stf",
    ".sti": "application/vnd.sun.xml.impress.template",
    ".stk": "application/hyperstudio",
    ".stl": "application/vnd.ms-pki.stl",
    ".str": "application/vnd.pg.format",
    ".stw": "application/vnd.sun.xml.writer.template",
    ".sus": "application/vnd.sus-calendar",
    ".susp": "application/vnd.sus-calendar",
    ".sv4cpio": "application/x-sv4cpio",
    ".sv4crc": "application/x-sv4crc",
    ".svd": "application/vnd.svd",
    ".svg": "image/svg+xml",
    ".svgz": "image/svg+xml",
    ".swa": "application/x-director",
    ".swf": "application/x-shockwave-flash",
    ".swi": "application/vnd.arastra.swi",
    ".sxc": "application/vnd.sun.xml.calc",
    ".sxd": "application/vnd.sun.xml.draw",
    ".sxg": "application/vnd.sun.xml.writer.global",
    ".sxi": "application/vnd.sun.xml.impress",
    ".sxm": "application/vnd.sun.xml.math",
    ".sxw": "application/vnd.sun.xml.writer",
    ".t": "text/troff",
    ".tao": "application/vnd.tao.intent-module-archive",
    ".tar": "application/x-tar",
    ".tcap": "application/vnd.3gpp2.tcap",
    ".tcl": "application/x-tcl",
    ".teacher": "application/vnd.smart.teacher",
    ".tex": "application/x-tex",
    ".texi": "application/x-texinfo",
    ".texinfo": "application/x-texinfo",
    ".text": "text/plain",
    ".tfm": "application/x-tex-tfm",
    ".tgz": "application/x-gzip",
    ".tif": "image/tiff",
    ".tiff": "image/tiff",
    ".tmo": "application/vnd.tmobile-livetv",
    ".torrent": "application/x-bittorrent",
    ".tpl": "application/vnd.groove-tool-template",
    ".tpt": "application/vnd.trid.tpt",
    ".tr": "text/troff",
    ".tra": "application/vnd.trueapp",
    ".trm": "application/x-msterminal",
    ".tsv": "text/tab-separated-values",
    ".ttc": "application/x-font-ttf",
    ".ttf": "application/x-font-ttf",
    ".twd": "application/vnd.simtech-mindmapper",
    ".twds": "application/vnd.simtech-mindmapper",
    ".txd": "application/vnd.genomatix.tuxedo",
    ".txf": "application/vnd.mobius.txf",
    ".txt": "text/plain",
    ".u32": "application/x-authorware-bin",
    ".udeb": "application/x-debian-package",
    ".ufd": "application/vnd.ufdl",
    ".ufdl": "application/vnd.ufdl",
    ".umj": "application/vnd.umajin",
    ".unityweb": "application/vnd.unity",
    ".uoml": "application/vnd.uoml+xml",
    ".uri": "text/uri-list",
    ".uris": "text/uri-list",
    ".urls": "text/uri-list",
    ".ustar": "application/x-ustar",
    ".utz": "application/vnd.uiq.theme",
    ".uu": "text/x-uuencode",
    ".vcd": "application/x-cdlink",
    ".vcf": "text/x-vcard",
    ".vcg": "application/vnd.groove-vcard",
    ".vcs": "text/x-vcalendar",
    ".vcx": "application/vnd.vcx",
    ".vis": "application/vnd.visionary",
    ".viv": "video/vnd.vivo",
    ".vor": "application/vnd.stardivision.writer",
    ".vox": "application/x-authorware-bin",
    ".vrml": "model/vrml",
    ".vsd": "application/vnd.visio",
    ".vsf": "application/vnd.vsf",
    ".vss": "application/vnd.visio",
    ".vst": "application/vnd.visio",
    ".vsw": "application/vnd.visio",
    ".vtu": "model/vnd.vtu",
    ".vxml": "application/voicexml+xml",
    ".w3d": "application/x-director",
    ".wad": "application/x-doom",
    ".wav": "audio/x-wav",
    ".wax": "audio/x-ms-wax",
    ".wbmp": "image/vnd.wap.wbmp",
    ".wbs": "application/vnd.criticaltools.wbs+xml",
    ".wbxml": "application/vnd.wap.wbxml",
    ".wcm": "application/vnd.ms-works",
    ".wdb": "application/vnd.ms-works",
    ".wiz": "application/msword",
    ".wks": "application/vnd.ms-works",
    ".wm": "video/x-ms-wm",
    ".wma": "audio/x-ms-wma",
    ".wmd": "application/x-ms-wmd",
    ".wmf": "application/x-msmetafile",
    ".wml": "text/vnd.wap.wml",
    ".wmlc": "application/vnd.wap.wmlc",
    ".wmls": "text/vnd.wap.wmlscript",
    ".wmlsc": "application/vnd.wap.wmlscriptc",
    ".wmv": "video/x-ms-wmv",
    ".wmx": "video/x-ms-wmx",
    ".wmz": "application/x-ms-wmz",
    ".wpd": "application/vnd.wordperfect",
    ".wpl": "application/vnd.ms-wpl",
    ".wps": "application/vnd.ms-works",
    ".wqd": "application/vnd.wqd",
    ".wri": "application/x-mswrite",
    ".wrl": "model/vrml",
    ".wsdl": "application/wsdl+xml",
    ".wspolicy": "application/wspolicy+xml",
    ".wtb": "application/vnd.webturbo",
    ".wvx": "video/x-ms-wvx",
    ".x32": "application/x-authorware-bin",
    ".x3d": "application/vnd.hzn-3d-crossword",
    ".xap": "application/x-silverlight-app",
    ".xar": "application/vnd.xara",
    ".xbap": "application/x-ms-xbap",
    ".xbd": "application/vnd.fujixerox.docuworks.binder",
    ".xbm": "image/x-xbitmap",
    ".xdm": "application/vnd.syncml.dm+xml",
    ".xdp": "application/vnd.adobe.xdp+xml",
    ".xdw": "application/vnd.fujixerox.docuworks",
    ".xenc": "application/xenc+xml",
    ".xer": "application/patch-ops-error+xml",
    ".xfdf": "application/vnd.adobe.xfdf",
    ".xfdl": "application/vnd.xfdl",
    ".xht": "application/xhtml+xml",
    ".xhtml": "application/xhtml+xml",
    ".xhvml": "application/xv+xml",
    ".xif": "image/vnd.xiff",
    ".xla": "application/vnd.ms-excel",
    ".xlam": "application/vnd.ms-excel.addin.macroenabled.12",
    ".xlb": "application/vnd.ms-excel",
    ".xlc": "application/vnd.ms-excel",
    ".xlm": "application/vnd.ms-excel",
    ".xls": "application/vnd.ms-excel",
    ".xlsb": "application/vnd.ms-excel.sheet.binary.macroenabled.12",
    ".xlsm": "application/vnd.ms-excel.sheet.macroenabled.12",
    ".xlsx": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    ".xlt": "application/vnd.ms-excel",
    ".xltm": "application/vnd.ms-excel.template.macroenabled.12",
    ".xltx": "application/vnd.openxmlformats-officedocument.spreadsheetml.template",
    ".xlw": "application/vnd.ms-excel",
    ".xml": "application/xml",
    ".xo": "application/vnd.olpc-sugar",
    ".xop": "application/xop+xml",
    ".xpdl": "application/xml",
    ".xpi": "application/x-xpinstall",
    ".xpm": "image/x-xpixmap",
    ".xpr": "application/vnd.is-xpr",
    ".xps": "application/vnd.ms-xpsdocument",
    ".xpw": "application/vnd.intercon.formnet",
    ".xpx": "application/vnd.intercon.formnet",
    ".xsl": "application/xml",
    ".xslt": "application/xslt+xml",
    ".xsm": "application/vnd.syncml+xml",
    ".xspf": "application/xspf+xml",
    ".xul": "application/vnd.mozilla.xul+xml",
    ".xvm": "application/xv+xml",
    ".xvml": "application/xv+xml",
    ".xwd": "image/x-xwindowdump",
    ".xyz": "chemical/x-xyz",
    ".zaz": "application/vnd.zzazz.deck+xml",
    ".zip": "application/zip",
    ".zir": "application/vnd.zul",
    ".zirz": "application/vnd.zul",
    ".zmm": "application/vnd.handheld-entertainment+xml"
  };

  /**
   Enumeration for {@link FileUploadItem} response types.

   @typedef {Object} FileUploadItemResponseTypeEnum

   @property {String} TEXT
   String type.
   @property {String} ARRAY_BUFFER
   Array buffer type.
   @property {String} BLOB
   Blob type.
   @property {String} DOCUMENT
   Document type.
   @property {String} JSON
   JavaScript object, parsed from a JSON string returned by the server.
   */

  var responseType = {
    TEXT: 'text',
    ARRAY_BUFFER: 'arraybuffer',
    BLOB: 'blob',
    DOCUMENT: 'document',
    JSON: 'json'
  }; // eg text/plain

  var MIME_TYPE_REGEXP = /(.+)\/(.+)$/; // eg .txt

  var FILE_EXTENSION_REGEXP = /\.(.+)$/; // eg text

  var SHORTCUT_REGEXP = /.*/;
  var MIME_TYPE_AUDIO = 'audio/*';
  var MIME_TYPE_IMAGE = 'image/*';
  var MIME_TYPE_VIDEO = 'video/*';
  /**
   @class Coral.FileUpload.Item
   @classdesc A FileUpload item encapsulating file meta-data
   @param {File|HTMLElement} file
   The file element.
   */

  var FileUploadItem = /*#__PURE__*/function () {
    /**
     Takes a {File} as argument.
      @param {File} file
     */
    function FileUploadItem(file) {
      _classCallCheck(this, FileUploadItem);

      this._originalFile = file;
      this._xhr = null;
    }
    /**
     The File.
      @name file
     @readonly
     @type {File}
     */


    _createClass(FileUploadItem, [{
      key: "_isMimeTypeAllowed",

      /** @private */
      value: function _isMimeTypeAllowed(acceptedMimeTypes) {
        var isAllowed = false; // Unrecognized browser mime types have a file type of ''.

        var fileType = this.file.type || 'application/unknown';

        if (!fileType.match(MIME_TYPE_REGEXP)) {
          // File mime type is erroneous
          return false;
        }

        return acceptedMimeTypes.split(',').some(function (allowedMimeType) {
          allowedMimeType = allowedMimeType.trim();

          if (allowedMimeType === '*' || allowedMimeType === '.*' || allowedMimeType === '*/*' || fileType === 'application/unknown') {
            // Explicit wildcard case: allow any file
            // Allow unknown mime types
            isAllowed = true;
          } else if (allowedMimeType.match(MIME_TYPE_REGEXP)) {
            if (allowedMimeType === MIME_TYPE_AUDIO) {
              isAllowed = fileType.indexOf(MIME_TYPE_AUDIO.slice(0, -1)) === 0;
            } else if (allowedMimeType === MIME_TYPE_IMAGE) {
              isAllowed = fileType.indexOf(MIME_TYPE_IMAGE.slice(0, -1)) === 0;
            } else if (allowedMimeType === MIME_TYPE_VIDEO) {
              isAllowed = fileType.indexOf(MIME_TYPE_VIDEO.slice(0, -1)) === 0;
            } else {
              // Proper mime type case: directly compare with file mime type
              isAllowed = fileType === allowedMimeType;
            }
          } else if (allowedMimeType.match(FILE_EXTENSION_REGEXP)) {
            // File extension case
            var allowedMimeTypes = MIME_TYPES[allowedMimeType]; // Depending on OS and browser, a file extension can map to different mime types
            // e.g .csv maps to "text/csv" on Mac OS and to "application/vnd.ms-excel" on Windows

            if (Array.isArray(allowedMimeTypes)) {
              isAllowed = allowedMimeTypes.some(function (mimeType) {
                return fileType === mimeType;
              });
            } else {
              isAllowed = fileType === MIME_TYPES[allowedMimeType];
            }
          } else if (allowedMimeType.match(SHORTCUT_REGEXP)) {
            // "Shortcut" case: only compare first part of the file mime type with the shortcut
            isAllowed = fileType.split('/')[0] === allowedMimeType;
          } // Break the loop if file mime type is allowed


          return isAllowed;
        });
      }
      /**
       Returns {@link FileUploadItem} response types.
        @return {FileUploadItemResponseTypeEnum}
       */

    }, {
      key: "file",
      get: function get() {
        return this._originalFile;
      }
      /**
       Array of additional parameters as key:value to be uploaded with the file.
       A parameter must contain a <code>name</code> key:value and optionally a <code>value</code> key:value.
        @name parameters
       @type {Array.<Object>}
       @default []
       */

    }, {
      key: "parameters",
      get: function get() {
        return this._parameters || [];
      },
      set: function set(value) {
        var isValid = Array.isArray(value) && value.every(function (el) {
          return el && el.name;
        });

        if (isValid) {
          this._parameters = value;
        }
      }
      /**
       The item xhr <code>withCredentials</code> property.
        @name withCredentials
       @type {Boolean}
       @default false
       */

    }, {
      key: "withCredentials",
      get: function get() {
        return this._withCredentials || false;
      },
      set: function set(value) {
        this._withCredentials = transform.boolean(value);
      }
      /**
       The item xhr <code>timeout</code> property.
        @name timeout
       @type {Number}
       @default 0
       */

    }, {
      key: "timeout",
      get: function get() {
        return this._timeout || 0;
      },
      set: function set(value) {
        var timeout = transform.number(value);

        if (timeout !== null) {
          this._timeout = timeout;

          if (this._xhr) {
            this._xhr.timeout = timeout;
          }
        }
      }
      /**
       The item xhr <code>responseType</code> property. See {@link FileUploadItemResponseTypeEnum}.
        @name responseType
       @default {FileUploadItemResponseTypeEnum.TEXT}
       @type {String}
       */

    }, {
      key: "responseType",
      get: function get() {
        return this._responseType || responseType.TEXT;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        this._responseType = validate.enumeration(responseType)(value) && value || responseType.TEXT;

        if (this._xhr) {
          this._xhr.responseType = value;
        }
      }
      /**
       The item xhr <code>readyState</code> property.
        @name readyState
       @readonly
       @default 0
       @type {Number}
       */

    }, {
      key: "readyState",
      get: function get() {
        return this._xhr ? this._xhr.readyState : this._readyState || 0;
      }
      /**
       The item xhr <code>responseType</code> property. Depends on {@link Coral.FileUpload.Item#responseType}.
        @name response
       @readonly
       @default ""
       @type {String|ArrayBuffer|Blob|Document}
       */

    }, {
      key: "response",
      get: function get() {
        return this._xhr ? this._xhr.response : this._response || '';
      }
      /**
       The item xhr <code>responseText</code> property.
        @name responseText
       @readonly
       @default ""
       @type {String}
       */

    }, {
      key: "responseText",
      get: function get() {
        return this._xhr ? this._xhr.responseText : this._responseText || '';
      }
      /**
       The item xhr <code>responseXML</code> property.
        @name responseXML
       @readonly
       @default null
       @type {HTMLElement}
       */

    }, {
      key: "responseXML",
      get: function get() {
        return this._xhr ? this._xhr.responseXML : this._responseXML || null;
      }
      /**
       The item xhr <code>status</code> property.
        @name status
       @readonly
       @default 0
       @type {Number}
       */

    }, {
      key: "status",
      get: function get() {
        return this._xhr ? this._xhr.status : this._status || 0;
      }
      /**
       The item xhr <code>statusText</code> property.
        @name statusText
       @readonly
       @default ""
       @type {String}
       */

    }, {
      key: "statusText",
      get: function get() {
        return this._xhr ? this._xhr.statusText : this._statusText || '';
      }
    }], [{
      key: "responseType",
      get: function get() {
        return responseType;
      }
    }]);

    return FileUploadItem;
  }();

  var template$C = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["input"] = document.createElement("input");
    el0.id = data_0["commons"]["getUID"]();
    el0.setAttribute("handle", "input");
    el0.className += " _coral-FileUpload-input is-unselectable";
    el0.setAttribute("tabindex", "-1");
    el0.setAttribute("name", "");
    el0.setAttribute("type", "file");
    el0.setAttribute("accept", "");
    frag.appendChild(el0);
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    return frag;
  };

  var CLASSNAME$V = '_coral-FileUpload';
  var XHR_EVENT_NAMES = ['loadstart', 'progress', 'load', 'error', 'loadend', 'readystatechange', 'abort', 'timeout'];
  /**
   Enumeration for {@link FileUpload} HTTP methods that can be used to upload files.

   @typedef {Object} FileUploadMethodEnum

   @property {String} POST
   Send a POST request. Used when creating a resource.
   @property {String} PUT
   Send a PUT request. Used when replacing a resource.
   @property {String} PATCH
   Send a PATCH request. Used when partially updating a resource.
   */

  var method = {
    POST: 'POST',
    PUT: 'PUT',
    PATCH: 'PATCH'
  };
  /**
   @class Coral.FileUpload
   @classdesc A FileUpload component that manages the upload process of multiple files. Child elements of FileUpload can
   be given special attributes to enable functionality:
   - <code>[coral-fileupload-select]</code>. Click to choose file(s), replacing existing files.
   - <code>[coral-fileupload-dropzone]</code>. Drag and drop files to choose file(s), replacing existing files.
   - <code>[coral-fileupload-clear]</code>. Click to remove all files from the queue.
   - <code>[coral-fileupload-submit]</code>. Click to start uploading.
   - <code>[coral-fileupload-abort]</code>. Click to abort all uploads.
   - <code>[coral-fileupload-abortfile="filename.txt"]</code>. Click to abort a specific file, leaving it in the queue.
   - <code>[coral-fileupload-removefile="filename.txt"]</code>. Click to remove a specific file from the queue.
   - <code>[coral-fileupload-uploadfile="filename.txt"]</code>. Click to start uploading a specific file.

   @htmltag coral-fileupload
   @extends {HTMLElement}
   @extends {BaseComponent}
   @extends {BaseFormField}
   */

  var FileUpload = /*#__PURE__*/function (_BaseFormField) {
    _inherits(FileUpload, _BaseFormField);

    var _super = _createSuper(FileUpload);

    /** @ignore */
    function FileUpload() {
      var _this;

      _classCallCheck(this, FileUpload);

      _this = _super.call(this); // Events

      _this._delegateEvents(commons.extend(_this._events, {
        // Clickable hooks
        'click [coral-fileupload-submit]': '_onSubmitButtonClick',
        'click [coral-fileupload-clear]': 'clear',
        'click [coral-fileupload-select]': '_showFileDialog',
        'click [coral-fileupload-abort]': 'abort',
        'click [coral-fileupload-abortfile]': '_onAbortFileClick',
        'click [coral-fileupload-removefile]': '_onRemoveFileClick',
        'click [coral-fileupload-uploadfile]': '_onUploadFileClick',
        // Drag & Drop zones
        'dragenter [coral-fileupload-dropzone]': '_onDragAndDrop',
        'dragover [coral-fileupload-dropzone]': '_onDragAndDrop',
        'dragleave [handle="input"]': '_onDragAndDrop',
        'drop [handle="input"]': '_onDragAndDrop',
        // Accessibility
        'capture:focus [coral-fileupload-select]': '_onButtonFocusIn',
        'capture:focus [handle="input"]': '_onInputFocusIn',
        'capture:blur [handle="input"]': '_onInputFocusOut'
      })); // Prepare templates


      _this._elements = {};
      template$C.call(_this._elements, {
        commons: commons
      }); // Pre-define labellable element

      _this._labellableElement = _this._elements.input; // Used for items

      _this._uploadQueue = []; // this should refer to the fileupload

      _this._doAddDragClass = _this._doAddDragClass.bind(_assertThisInitialized(_this));
      _this._doRemoveDragClass = _this._doRemoveDragClass.bind(_assertThisInitialized(_this));
      _this._positionInputOnDropZone = _this._positionInputOnDropZone.bind(_assertThisInitialized(_this)); // Reposition the input under the specified dropzone

      _this._observer = new MutationObserver(_this._positionInputOnDropZone);

      _this._observer.observe(_assertThisInitialized(_this), {
        childList: true,
        attributes: true,
        attributeFilter: ['coral-fileupload-dropzone'],
        subtree: true
      });

      return _this;
    }
    /**
     Name used to submit the data in a form.
     @type {String}
     @default ""
     @htmlattribute name
     @htmlattributereflected
     */


    _createClass(FileUpload, [{
      key: "_onButtonFocusIn",

      /** @private */
      value: function _onButtonFocusIn(event) {
        // Get the input
        var input = this._elements.input; // Get the button

        var button = event.matchedTarget; // Move the input to after the button
        // This lets the next focused item be the correct one according to tab order

        button.parentNode.insertBefore(input, button.nextElementSibling);

        if (event.relatedTarget !== input) {
          // Make sure the input gets focused on FF
          window.setTimeout(function () {
            input.focus();
          }, 100);
        }
      }
      /** @private */

    }, {
      key: "_onInputFocusIn",
      value: function _onInputFocusIn() {
        // Get the input
        var input = event.matchedTarget;
        var button = this.querySelector('[coral-fileupload-select]');

        if (button) {
          // Remove from the tab order so shift+tab works
          button.tabIndex = -1; // So shifting focus backwards with screen reader doesn't create a focus trap

          button.setAttribute('aria-hidden', true); // Mark the button as focused

          button.classList.add('is-focused');
          window.requestAnimationFrame(function () {
            if (input.classList.contains('focus-ring')) {
              button.classList.add('focus-ring');
            }
          });
        }
      }
      /** @private */

    }, {
      key: "_onInputFocusOut",
      value: function _onInputFocusOut() {
        // Unmark all the focused buttons
        var button = this.querySelector('[coral-fileupload-select].is-focused');
        button.classList.remove('is-focused');
        button.classList.remove('focus-ring'); // Wait a frame so that shifting focus backwards with screen reader doesn't create a focus trap

        window.requestAnimationFrame(function () {
          button.tabIndex = 0; // @a11y: aria-hidden is removed to prevent focus trap when navigating backwards using a screen reader's
          // virtual cursor

          button.removeAttribute('aria-hidden');
        });
      }
      /** @private */

    }, {
      key: "_onAbortFileClick",
      value: function _onAbortFileClick(event) {
        if (!this.async) {
          throw new Error('Coral.FileUpload does not support aborting file(s) upload on synchronous mode.');
        } // Get file to abort


        var fileName = event.target.getAttribute('coral-fileupload-abortfile');

        if (fileName) {
          this._abortFile(fileName);
        }
      }
      /** @private */

    }, {
      key: "_onRemoveFileClick",
      value: function _onRemoveFileClick(event) {
        if (!this.async) {
          throw new Error('Coral.FileUpload does not support removing a file from the queue on synchronous mode.');
        } else {
          // Get file to remove
          var fileName = event.target.getAttribute('coral-fileupload-removefile');

          if (fileName) {
            this._clearFile(fileName);
          }
        }
      }
      /** @private */

    }, {
      key: "_onUploadFileClick",
      value: function _onUploadFileClick(event) {
        if (!this.async) {
          throw new Error('Coral.FileUpload does not support uploading a file from the queue on synchronous mode.');
        } // Get file to upload


        var fileName = event.target.getAttribute('coral-fileupload-uploadfile');

        if (fileName) {
          this.upload(fileName);
        }
      }
      /** @private */

    }, {
      key: "_onDragAndDrop",
      value: function _onDragAndDrop(event) {
        // Set dragging classes
        if (event.type === 'dragenter' || event.type === 'dragover') {
          this._addDragClass();
        } else if (event.type === 'dragleave' || event.type === 'drop') {
          this._removeDragClass();
        }

        this.trigger("coral-fileupload:".concat(event.type));
      }
      /** @private */

    }, {
      key: "_addDragClass",
      value: function _addDragClass() {
        window.clearTimeout(this._removeClassTimeout);
        this._removeClassTimeout = window.setTimeout(this._doAddDragClass, 10);
      }
      /** @private */

    }, {
      key: "_doAddDragClass",
      value: function _doAddDragClass() {
        this.classList.add('is-dragging');
        var dropZone = this.querySelector('[coral-fileupload-dropzone]');

        if (dropZone) {
          dropZone.classList.add('is-dragging');
        } // Put the input on top to enable file drop


        this._elements.input.classList.remove('is-unselectable');
      }
      /** @private */

    }, {
      key: "_removeDragClass",
      value: function _removeDragClass() {
        window.clearTimeout(this._removeClassTimeout);
        this._removeClassTimeout = window.setTimeout(this._doRemoveDragClass, 10);
      }
      /** @private */

    }, {
      key: "_doRemoveDragClass",
      value: function _doRemoveDragClass() {
        this.classList.remove('is-dragging');
        var dropZone = this.querySelector('[coral-fileupload-dropzone]');

        if (dropZone) {
          dropZone.classList.remove('is-dragging');
        } // Disable user interaction with the input


        this._elements.input.classList.add('is-unselectable');
      }
      /**
       Handles clicks to submit buttons
        @private
       */

    }, {
      key: "_onSubmitButtonClick",
      value: function _onSubmitButtonClick(event) {
        var target = event.matchedTarget; // Override or reset the action/method given the button's configuration

        this._buttonAction = target.getAttribute('formaction'); // Make sure the method provided by the button is valid

        var buttonMethod = transform.string(target.getAttribute('formmethod')).toUpperCase();
        this._buttonMethod = validate.enumeration(method)(buttonMethod) && buttonMethod || null; // Start the file upload

        this.upload();
      }
      /**
       Handles changes to the input element.
        @private
       */

    }, {
      key: "_onInputChange",
      value: function _onInputChange(event) {
        var _this2 = this;

        // Stop the current event
        event.stopPropagation();

        if (this.disabled) {
          return;
        }

        var files = [];
        var items = []; // Retrieve files for select event

        if (event.target.files && event.target.files.length) {
          this._clearQueue();

          files = event.target.files; // Verify if multiple file upload is allowed

          if (!this.multiple) {
            files = [files[0]];
          }
        } // Retrieve files for drop event
        else if (event.dataTransfer && event.dataTransfer.files && event.dataTransfer.files.length) {
            this._clearQueue();

            files = event.dataTransfer.files; // Verify if multiple file upload is allowed

            if (!this.multiple) {
              files = [files[0]];
            }
          } else {
            return;
          } // Initialize items


        for (var i = 0; i < files.length; i++) {
          items.push(new FileUploadItem(files[i]));
        } // Verify if file is allowed to be uploaded and trigger events accordingly


        items.forEach(function (item) {
          // If file is not found in uploadQueue using filename
          if (!_this2._getQueueItemByFilename(item.file.name)) {
            // Check file size
            if (_this2.sizeLimit && item.file.size > _this2.sizeLimit) {
              _this2.trigger('coral-fileupload:filesizeexceeded', {
                item: item
              });
            } // Check mime type
            else if (_this2.accept && !item._isMimeTypeAllowed(_this2.accept)) {
                _this2.trigger('coral-fileupload:filemimetyperejected', {
                  item: item
                });
              } else {
                // Add item to queue
                _this2._uploadQueue.push(item);

                _this2.trigger('coral-fileupload:fileadded', {
                  item: item
                });
              }
          }
        });

        if (this.autoStart) {
          this.upload();
        } // Explicitly re-emit the change event


        if (this._triggerChangeEvent) {
          this.trigger('change');
        } // Clear file input once files are added to the queue to make sure next file selection will trigger a change event


        if (this.async) {
          this._clearFileInputValue();
        }
      }
      /**
       Sets the disabled/readonly state of elements with the associated special attributes
        @private
       */

    }, {
      key: "_setElementState",
      value: function _setElementState() {
        var _this3 = this;

        Array.prototype.forEach.call(this.querySelectorAll('[coral-fileupload-select],' + '[coral-fileupload-dropzone],' + '[coral-fileupload-submit],' + '[coral-fileupload-clear],' + '[coral-fileupload-abort],' + '[coral-fileupload-abortfile],' + '[coral-fileupload-removefile],' + '[coral-fileupload-uploadfile]'), function (item) {
          item.classList.toggle('is-invalid', _this3.invalid);
          item.classList.toggle('is-disabled', _this3.disabled);
          item.classList.toggle('is-required', _this3.required);
          item.classList.toggle('is-readOnly', _this3.readOnly);
          item[_this3.disabled || _this3.readOnly ? 'setAttribute' : 'removeAttribute']('disabled', '');
        });
      }
      /** @private */

    }, {
      key: "_clearQueue",
      value: function _clearQueue() {
        var _this4 = this;

        this._uploadQueue.slice().forEach(function (item) {
          _this4._clearFile(item.file.name);
        });
      }
      /**
       Clear file selection on the file input
        @private
       */

    }, {
      key: "_clearFileInputValue",
      value: function _clearFileInputValue() {
        this._elements.input.value = '';
      }
      /**
       Remove a file from the upload queue.
        @param {String} filename
       The filename of the file to remove.
        @private
       */

    }, {
      key: "_clearFile",
      value: function _clearFile(filename) {
        var item = this._getQueueItemByFilename(filename);

        if (item) {
          // Abort file upload
          this._abortFile(filename); // Remove file from queue


          this._uploadQueue.splice(this._getQueueIndex(filename), 1);

          this.trigger('coral-fileupload:fileremoved', {
            item: item
          });
        }
      }
      /**
       Uploads a file in the queue. If an array is provided as the first argument, it is used as the parameters.
        @param filename {String}
       The name of the file to upload.
        @private
       */

    }, {
      key: "_uploadFile",
      value: function _uploadFile(filename) {
        var item = this._getQueueItemByFilename(filename);

        if (item) {
          this._abortFile(filename);

          this._ajaxUpload(item);
        }
      }
      /** @private */

    }, {
      key: "_showFileDialog",
      value: function _showFileDialog() {
        // Show the dialog
        // This ONLY works when the call stack traces back to another click event!
        this._elements.input.click();
      }
      /**
       Abort specific file upload.
        @param {String} filename
       The filename identifies the file to abort.
        @private
       */

    }, {
      key: "_abortFile",
      value: function _abortFile(filename) {
        var item = this._getQueueItemByFilename(filename);

        if (item && item._xhr) {
          item._xhr.abort();

          item._xhr = null;
        }
      }
      /**
       Handles the ajax upload.
        @private
       */

    }, {
      key: "_ajaxUpload",
      value: function _ajaxUpload(item) {
        var _this5 = this;

        // Use the action/method provided by the last button click, if provided
        var action = this._buttonAction || this.action;
        var requestMethod = this._buttonMethod ? this._buttonMethod.toUpperCase() : this.method; // We merge the global parameters with the specific file parameters and send them all together

        var parameters = this.parameters.concat(item.parameters);
        var formData = new FormData();
        parameters.forEach(function (additionalParameter) {
          formData.append(additionalParameter.name, additionalParameter.value);
        });
        formData.append('_charset_', 'utf-8');
        formData.append(this.name, item._originalFile); // Store the XHR on the item itself

        item._xhr = new XMLHttpRequest(); // Opening before being able to set response type to avoid IE11 InvalidStateError

        item._xhr.open(requestMethod, action); // Reflect specific xhr properties


        item._xhr.timeout = item.timeout;
        item._xhr.responseType = item.responseType;
        item._xhr.withCredentials = item.withCredentials;
        XHR_EVENT_NAMES.forEach(function (name) {
          // Progress event is the only event among other ProgressEvents that can trigger multiple times.
          // Hence it's the only one that gives away usable progress information.
          var isProgressEvent = name === 'progress';
          (isProgressEvent ? item._xhr.upload : item._xhr).addEventListener(name, function (event) {
            var detail = {
              item: item,
              action: action,
              method: requestMethod
            };

            if (isProgressEvent) {
              detail.lengthComputable = event.lengthComputable;
              detail.loaded = event.loaded;
              detail.total = event.total;
            }

            _this5.trigger("coral-fileupload:".concat(name), detail);
          });
        });

        item._xhr.send(formData);
      }
      /** @private */

    }, {
      key: "_getLabellableElement",
      value: function _getLabellableElement() {
        return this;
      }
      /** @private */

    }, {
      key: "_getQueueItemByFilename",
      value: function _getQueueItemByFilename(filename) {
        return this._getQueueItem(this._getQueueIndex(filename));
      }
      /** @private */

    }, {
      key: "_getQueueItem",
      value: function _getQueueItem(index) {
        return index > -1 ? this._uploadQueue[index] : null;
      }
      /** @private */

    }, {
      key: "_getQueueIndex",
      value: function _getQueueIndex(filename) {
        var index = -1;

        this._uploadQueue.some(function (item, i) {
          if (item.file.name === filename) {
            index = i;
            return true;
          }

          return false;
        });

        return index;
      }
      /** @private */

    }, {
      key: "_getTargetChangeInput",
      value: function _getTargetChangeInput() {
        return this._elements.input;
      }
      /** @ignore */

    }, {
      key: "_positionInputOnDropZone",
      value: function _positionInputOnDropZone() {
        var input = this._elements.input;
        var dropZone = this.querySelector('[coral-fileupload-dropzone]');

        if (dropZone) {
          var size = dropZone.getBoundingClientRect();
          input.style.top = "".concat(parseInt(dropZone.offsetTop, 10), "px");
          input.style.left = "".concat(parseInt(dropZone.offsetLeft, 10), "px");
          input.style.width = "".concat(parseInt(size.width, 10), "px");
          input.style.height = "".concat(parseInt(size.height, 10), "px");
        } else {
          input.style.width = '0';
          input.style.height = '0';
        }
      }
      /**
       Uploads the given filename, or all the files into the queue. It accepts extra parameters that are sent with the
       file.
        @param {String} [filename]
       The name of the file to upload.
       */

    }, {
      key: "upload",
      value: function upload(filename) {
        var _this6 = this;

        if (!this.async) {
          if (typeof filename === 'string') {
            throw new Error('Coral.FileUpload does not support uploading a file from the queue on synchronous mode.');
          }

          var form = this.closest('form');

          if (!form) {
            form = document.createElement('form');
            form.method = this.method.toLowerCase();
            form.enctype = 'multipart/form-data';
            form.action = this.action;
            form.hidden = true;
            form.appendChild(this._elements.input);
            Array.prototype.forEach.call(this.querySelectorAll('input[type="hidden"]'), function (hiddenInput) {
              form.appendChild(hiddenInput);
            }); // Make sure the form is connected before submission

            this.appendChild(form);
          }

          var input = document.createElement('input');
          input.type = 'hidden';
          input.name = '_charset_';
          input.value = 'utf-8';
          form.submit();
        } else if (typeof filename === 'string') {
          this._uploadFile(filename);
        } else {
          this._uploadQueue.forEach(function (item) {
            _this6._abortFile(item.file.name);

            _this6._ajaxUpload(item);
          });
        }
      }
      /**
       Remove a file or all files from the upload queue.
        @param {String} [filename]
       The filename of the file to remove. If a filename is not provided, all files will be removed.
       */

    }, {
      key: "clear",
      value: function clear(filename) {
        if (!this.async) {
          if (typeof filename === 'string') {
            throw new Error('Coral.FileUpload does not support removing a file from the queue on synchronous mode.');
          }

          this._clearQueue();

          this._clearFileInputValue();
        } else if (typeof filename === 'string') {
          this._clearFile(filename);
        } else {
          this._clearQueue();
        }
      }
      /**
       Abort upload of a given file or all files in the queue.
        @param {String} [filename]
       The filename of the file to abort. If a filename is not provided, all files will be aborted.
       */

    }, {
      key: "abort",
      value: function abort(filename) {
        var _this7 = this;

        if (!this.async) {
          throw new Error('Coral.FileUpload does not support aborting file(s) upload on synchronous mode.');
        }

        if (typeof filename === 'string') {
          // Abort a single file
          this._abortFile(filename);
        } else {
          // Abort all files
          this._uploadQueue.forEach(function (item) {
            _this7._abortFile(item.file.name);
          });
        }
      }
    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        var _this8 = this;

        _get(_getPrototypeOf(FileUpload.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$V);
        var button = this.querySelector('[coral-fileupload-select]');

        if (button) {
          button.id = button.id || commons.getUID();
        } // If no labelledby is specified, ensure input is at labelledby the select button


        this.labelledBy = this.labelledBy; // Fetch additional parameters if any

        var parameters = [];
        Array.prototype.forEach.call(this.querySelectorAll('input[type="hidden"]'), function (input) {
          parameters.push({
            name: input.name,
            value: input.value
          });
        });
        this.parameters = parameters; // Remove the input if it's already there
        // A fresh input is preferred to value = '' as it may not work in all browsers

        var inputElement = this.querySelector('[handle="input"]');

        if (inputElement) {
          inputElement.parentNode.removeChild(inputElement);
        } // Add the input to the component


        this.appendChild(this._elements.input); // IE11 requires one more frame or the resize listener <object> will appear as an overlaying white box

        window.requestAnimationFrame(function () {
          // Handles the repositioning of the input to allow dropping files
          commons.addResizeListener(_this8, _this8._positionInputOnDropZone);
        });
      }
    }, {
      key: "name",
      get: function get() {
        return this._elements.input.name;
      },
      set: function set(value) {
        this._reflectAttribute('name', value);

        this._elements.input.name = value;
      }
      /**
       This field's current value.
       @type {String}
       @default ""
       @htmlattribute value
       */

    }, {
      key: "value",
      get: function get() {
        var item = this._uploadQueue ? this._getQueueItem(0) : null; // The first selected filename, or the empty string if no files are selected.

        return item ? "C:\\fakepath\\".concat(item.file.name) : '';
      },
      set: function set(value) {
        if (value === '' || value === null) {
          this._clearQueue();

          this._clearFileInputValue();
        } else {
          // Throws exception if value is different than an empty string or null
          throw new Error('Coral.FileUpload accepts a filename, which may only be programmatically set to empty string.');
        }
      }
      /**
       Whether this field is disabled or not.
       @type {Boolean}
       @default false
       @htmlattribute disabled
       @htmlattributereflected
       */

    }, {
      key: "disabled",
      get: function get() {
        return this._elements.input.disabled;
      },
      set: function set(value) {
        this._elements.input.disabled = transform.booleanAttr(value);

        this._reflectAttribute('disabled', this.disabled);

        this.classList.toggle('is-disabled', this.disabled);

        this._setElementState();
      }
      /**
       Inherited from {@link BaseFormField#invalid}.
       */

    }, {
      key: "invalid",
      get: function get() {
        return _get(_getPrototypeOf(FileUpload.prototype), "invalid", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(FileUpload.prototype), "invalid", value, this, true);

        this._elements.input.setAttribute('aria-invalid', this.invalid);

        this._setElementState();
      }
      /**
       Whether this field is required or not.
       @type {Boolean}
       @default false
       @htmlattribute required
       @htmlattributereflected
       */

    }, {
      key: "required",
      get: function get() {
        return this._elements.input.required;
      },
      set: function set(value) {
        this._elements.input.required = transform.booleanAttr(value);

        this._reflectAttribute('required', this.required);

        this.classList.toggle('is-required', this.required);

        this._setElementState();
      }
      /**
       Whether this field is readOnly or not. Indicating that the user cannot modify the value of the control.
       @type {Boolean}
       @default false
       @htmlattribute readonly
       @htmlattributereflected
       */

    }, {
      key: "readOnly",
      get: function get() {
        return this._readOnly || false;
      },
      set: function set(value) {
        this._readOnly = transform.booleanAttr(value);

        this._reflectAttribute('readonly', this._readOnly);

        this._setElementState();
      }
      /**
       The names of the currently selected files.
       When {@link Coral.FileUpload#multiple} is <code>false</code>, this will be an array of length 1.
        @type {Array.<String>}
       */

    }, {
      key: "values",
      get: function get() {
        var values = this._uploadQueue.map(function (item) {
          return "C:\\fakepath\\".concat(item.file.name);
        });

        if (values.length && !this.multiple) {
          values = [values[0]];
        }

        return values;
      },
      set: function set(values) {
        if (Array.isArray(values)) {
          if (values.length) {
            this.value = values[0];
          } else {
            this.value = '';
          }
        }
      }
      /**
       Inherited from {@link BaseFormField#labelledBy}.
       */

    }, {
      key: "labelledBy",
      get: function get() {
        return _get(_getPrototypeOf(FileUpload.prototype), "labelledBy", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(FileUpload.prototype), "labelledBy", value, this, true); // The specified labelledBy property.


        var labelledBy = this.labelledBy; // An array of element ids to label control, the last being the select button element id.

        var ids = [];
        var button = this.querySelector('[coral-fileupload-select]');

        if (button) {
          ids.push(button.id);
        } // If a labelledBy property exists,


        if (labelledBy) {
          // prepend the labelledBy value to the ids array
          ids.unshift(labelledBy);
        } // Set aria-labelledby attribute on the labellable element joining ids array into space-delimited list of ids.


        this._elements.input.setAttribute('aria-labelledby', ids.join(' '));

        if (labelledBy) {
          // Set label for attribute
          var labelElement = document.getElementById(labelledBy);

          if (labelElement && labelElement.tagName === 'LABEL') {
            labelElement.setAttribute('for', this._elements.input.id);
            this._labelElement = labelElement;
          }
        } // Remove label for attribute
        else if (this._labelElement) {
            this._labelElement.removeAttribute('for');
          }
      }
      /**
       Array of additional parameters as key:value to send in addition of files.
       A parameter must contain a <code>name</code> key:value and optionally a <code>value</code> key:value.
        @type {Array.<Object>}
       @default []
       */

    }, {
      key: "parameters",
      get: function get() {
        return this._parameters || [];
      },
      set: function set(values) {
        var _this9 = this;

        // Verify that every item has a name
        var isValid = Array.isArray(values) && values.every(function (el) {
          return el && el.name;
        });

        if (isValid) {
          this._parameters = values;

          if (!this.async) {
            Array.prototype.forEach.call(this.querySelectorAll('input[type="hidden"]'), function (input) {
              input.parentNode.removeChild(input);
            }); // Add extra parameters

            this.parameters.forEach(function (param) {
              var input = document.createElement('input');
              input.type = 'hidden';
              input.name = param.name;
              input.value = param.value;

              _this9.appendChild(input);
            });
          }
        }
      }
      /**
       Whether files should be uploaded asynchronously via XHR or synchronously e.g. within a
       <code>&lt;form&gt;</code> tag. One option excludes the other. Setting a new <code>async</code> value removes all
       files from the queue.
        @type {Boolean}
       @default false
       @htmlattribute async
       @htmlattributereflected
       */

    }, {
      key: "async",
      get: function get() {
        return this._async || false;
      },
      set: function set(value) {
        this._async = transform.booleanAttr(value);

        this._reflectAttribute('async', this._async); // Sync extra parameters in case of form submission


        if (!this._async) {
          this.parameters = this.parameters;
        } // Clear file selection


        if (this._uploadQueue) {
          this._clearQueue();

          this._clearFileInputValue();
        }
      }
      /**
       The URL where the upload request should be sent. When used within a <code>&lt;form&gt;</code> tag to upload
       synchronously, the action of the form is used. If an element is clicked that has a
       <code>[coral-fileupload-submit]</code> attribute as well as a <code>[formaction]</code> attribute, the action of
       the clicked element will be used. Set this property before calling {@link Coral.FileUpload#upload} to reset the
       action set by a click.
        @type {String}
       @default ""
       @htmlattribute action
       @htmlattributereflected
       */

    }, {
      key: "action",
      get: function get() {
        return this._action || '';
      },
      set: function set(value) {
        this._action = transform.string(value);

        this._reflectAttribute('action', this._action); // Reset button action as action was set explicitly


        this._buttonAction = null;
      }
      /**
       The HTTP method to use when uploading files asynchronously. When used within a <code>&lt;form&gt;</code> tag to
       upload synchronously, the method of the form is used. If an element is clicked that has a
       <code>[coral-fileupload-submit]</code> attribute as well as a <code>[formmethod]</code> attribute, the method of
       the clicked element will be used. Set this property before calling {@link FileUpload#upload} to reset the
       method set by a click.
       See {@link FileUploadMethodEnum}.
        @type {String}
       @default FileUploadMethodEnum.POST
       @htmlattribute method
       @htmlattributereflected
       */

    }, {
      key: "method",
      get: function get() {
        return this._method || method.POST;
      },
      set: function set(value) {
        value = transform.string(value).toUpperCase();
        this._method = validate.enumeration(method)(value) && value || method.POST;

        this._reflectAttribute('method', this._method); // Reset button method as method was set explcitly


        this._buttonMethod = null;
      }
      /**
       Whether more than one file can be chosen at the same time to upload.
        @type {Boolean}
       @default false
       @htmlattribute multiple
       @htmlattributereflected
       */

    }, {
      key: "multiple",
      get: function get() {
        return this._elements.input.multiple;
      },
      set: function set(value) {
        this._elements.input.multiple = transform.booleanAttr(value);

        this._reflectAttribute('multiple', this.multiple);
      }
      /**
       File size limit in bytes for one file. The value of 0 indicates unlimited, which is also the default.
        @type {Number}
       @htmlattribute sizelimit
       @htmlattributereflected
       @default 0
       */

    }, {
      key: "sizeLimit",
      get: function get() {
        return this._sizeLimit || 0;
      },
      set: function set(value) {
        this._sizeLimit = transform.number(value);

        this._reflectAttribute('sizelimit', this._sizeLimit);
      }
      /**
       MIME types allowed for uploading (proper MIME types, wildcard '*' and file extensions are supported). To specify
       more than one value, separate the values with a comma (e.g.
       <code>&lt;input accept="audio/*,video/*,image/*" /&gt;</code>.
        @type {String}
       @default ""
       @htmlattribute accept
       @htmlattributereflected
       */

    }, {
      key: "accept",
      get: function get() {
        return this._elements.input.accept;
      },
      set: function set(value) {
        this._elements.input.accept = value;

        this._reflectAttribute('accept', this.accept);
      }
      /**
       Whether the upload should start immediately after file selection.
        @type {Boolean}
       @default false
       @htmlattribute autostart
       @htmlattributereflected
       */

    }, {
      key: "autoStart",
      get: function get() {
        return this._autoStart || false;
      },
      set: function set(value) {
        this._autoStart = transform.booleanAttr(value);

        this._reflectAttribute('autostart', this._autoStart);
      }
      /**
       Files to be uploaded.
        @readonly
       @default []
       @type {Array.<Object>}
       */

    }, {
      key: "uploadQueue",
      get: function get() {
        return this._uploadQueue;
      }
    }], [{
      key: "_attributePropertyMap",
      get: function get() {
        return commons.extend(_get(_getPrototypeOf(FileUpload), "_attributePropertyMap", this), {
          sizelimit: 'sizeLimit',
          autostart: 'autoStart'
        });
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(FileUpload), "observedAttributes", this).concat(['async', 'action', 'method', 'multiple', 'sizelimit', 'accept', 'autostart']);
      }
    }]);

    return FileUpload;
  }(BaseFormField(BaseComponent(HTMLElement)));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons._define('coral-fileupload', FileUpload);

  FileUpload.Item = FileUploadItem;

  var template$D = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["quickactions"] = document.createElement("div");
    el0.setAttribute("handle", "quickactions");
    el0.className += " _coral-Masonry-item-quickActions";
    var el1 = document.createTextNode("\n  ");
    el0.appendChild(el1);
    var el2 = this["check"] = document.createElement("coral-checkbox");
    el2.setAttribute("handle", "check");
    el0.appendChild(el2);
    var el3 = document.createTextNode("\n");
    el0.appendChild(el3);
    frag.appendChild(el0);
    var el4 = document.createTextNode("\n");
    frag.appendChild(el4);
    return frag;
  };

  var CLASSNAME$W = '_coral-Masonry-item';
  /**
   @class Coral.Masonry.Item
   @classdesc A Masonry Item component
   @htmltag coral-masonry-item
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var MasonryItem = /*#__PURE__*/function (_BaseComponent) {
    _inherits(MasonryItem, _BaseComponent);

    var _super = _createSuper(MasonryItem);

    /** @ignore */
    function MasonryItem() {
      var _this;

      _classCallCheck(this, MasonryItem);

      _this = _super.call(this); // Represents ownership (necessary when the item is moved which triggers callbacks)

      _this._masonry = null; // Default value

      _this._dragAction = null; // Template

      _this._elements = {};
      template$D.call(_this._elements);
      return _this;
    } // @compat


    _createClass(MasonryItem, [{
      key: "_insert",

      /**
       Animates the insertion of the item.
        @private
       */
      value: function _insert() {
        var _this2 = this;

        if (this.classList.contains('is-beforeInserting')) {
          this.classList.remove('is-beforeInserting');
          this.classList.add('is-inserting');
          commons.transitionEnd(this, function () {
            _this2.classList.remove('is-inserting');
          });
        }
      }
      /** @private */

    }, {
      key: "_setTabbable",
      value: function _setTabbable(tabbable) {
        this.setAttribute('tabindex', tabbable ? 0 : -1);
      }
      /** @private */

    }, {
      key: "_updateDragAction",
      value: function _updateDragAction(enabled) {
        var handle;

        if (enabled) {
          // Find handle
          if (this.getAttribute('coral-masonry-draghandle') !== null) {
            handle = this;
          } else {
            handle = this.querySelector('[coral-masonry-draghandle]');

            if (!handle) {
              // Disable drag&drop if handle wasn't found
              enabled = false;
            }
          }
        }

        if (enabled) {
          if (!this._dragAction) {
            this._dragAction = new DragAction(this);
            this._dragAction.dropZone = this.parentNode;
          }

          this._dragAction.handle = handle;
        } else if (this._dragAction) {
          this._dragAction.destroy();

          this._dragAction = null;
        }
      }
      /** @ignore */

    }, {
      key: "attributeChangedCallback",

      /** @ignore */
      value: function attributeChangedCallback(name, oldValue, value) {
        var _this3 = this;

        if (name === '_removing') {
          // Do it in the next frame so that the removing animation is visible
          window.requestAnimationFrame(function () {
            _this3.classList.toggle('is-removing', value !== null);
          });
        } else if (name === '_orderable') {
          this._updateDragAction(value !== null);
        } else {
          _get(_getPrototypeOf(MasonryItem.prototype), "attributeChangedCallback", this).call(this, name, oldValue, value);
        }
      }
      /** @ignore */

    }, {
      key: "connectedCallback",
      value: function connectedCallback() {
        if (this._skipConnectedCallback()) {
          return;
        }

        _get(_getPrototypeOf(MasonryItem.prototype), "connectedCallback", this).call(this); // Inform masonry immediately


        this.trigger('coral-masonry-item:_connected');
      }
      /** @ignore */

    }, {
      key: "render",
      value: function render() {
        _get(_getPrototypeOf(MasonryItem.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$W); // @a11y

        this.setAttribute('tabindex', '-1'); // Support cloneNode

        var template = this.querySelector('._coral-Masonry-item-quickActions');

        if (template) {
          template.remove();
        }

        this.insertBefore(this._elements.quickactions, this.firstChild); // todo workaround to not give user possibility to tab into checkbox

        this._elements.check._labellableElement.tabIndex = -1;
      }
      /** @ignore */

    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        if (this.isConnected) {
          return;
        }

        _get(_getPrototypeOf(MasonryItem.prototype), "disconnectedCallback", this).call(this); // Handle it in masonry immediately


        var masonry = this._masonry;

        if (masonry) {
          masonry._onItemDisconnected(this);
        }
      }
    }, {
      key: "content",
      get: function get() {
        return this;
      },
      set: function set(value) {
        // Support configs
        if (_typeof(value) === 'object') {
          for (var prop in value) {
            /** @ignore */
            this[prop] = value[prop];
          }
        }
      }
      /**
       Whether the item is selected.
        @type {Boolean}
       @default false
       @htmlattribute selected
       @htmlattributereflected
       */

    }, {
      key: "selected",
      get: function get() {
        return this._selected || false;
      },
      set: function set(value) {
        this._selected = transform.booleanAttr(value);

        this._reflectAttribute('selected', this._selected);

        this.setAttribute('aria-selected', this._selected);
        this.classList.toggle('is-selected', this._selected);

        this._elements.check[this._selected ? 'setAttribute' : 'removeAttribute']('checked', '');

        this.trigger('coral-masonry-item:_selectedchanged');
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(MasonryItem), "observedAttributes", this).concat(['selected', '_removing', '_orderable']);
      }
    }]);

    return MasonryItem;
  }(BaseComponent(HTMLElement));

  var CLASSNAME$X = '_coral-Masonry';
  /**
   Enumeration for {@link Masonry} selection options.

   @typedef {Object} MasonrySelectionModeEnum

   @property {String} NONE
   None is default, selection of Masonry items doesn't happen based on click.
   @property {String} SINGLE
   Single selection mode, Masonry behaves like radio input elements.
   @property {String} MULTIPLE
   Multiple selection mode, Masonry behaves like checkbox input elements.
   */

  var selectionMode$2 = {
    NONE: 'none',
    SINGLE: 'single',
    MULTIPLE: 'multiple'
  };
  /**
   Enumeration for {@link Masonry} layouts.

   @typedef {Object} MasonryLayoutsEnum

   @property {String} FIXED_CENTERED
   A Layout with fixed width centered items.
   @property {String} FIXED_SPREAD
   A layout with fixed width and evenly spread items.
   @property {String} VARIABLE
   A layout with variable width items.
   @property {String} DASHBOARD
   A layout with variable width items which are expanded in their height to fill gaps.
   */

  var layouts = {
    FIXED_CENTERED: 'fixed-centered',
    FIXED_SPREAD: 'fixed-spread',
    VARIABLE: 'variable',
    DASHBOARD: 'dashboard'
  };
  /**
   Enumeration values to enable/disable aria grid support for {@link Masonry}.

   @typedef {Object} MasonryAriaGridEnum

   @property {String} ON
   Turn on auto aria grid roles.
   @property {String} OFF
   OFF is default. Turn off auto aria grid roles.
   */

  var ariaGrid = {
    ON: 'on',
    OFF: 'off'
  }; // IE does not set the complete property to true if an image cannot be loaded. This code must be outside of the
  // masonry to make sure that the listener catches images which fail loading before the masonry is initalized.
  // @polyfill ie11

  document.addEventListener('error', function (event) {
    var target = event.target;

    if (target && target.tagName === 'IMG') {
      target._loadError = true;
    }
  }, true); // Ignore children which are being removed

  var itemFilter = function itemFilter(element) {
    return element && element.tagName === 'CORAL-MASONRY-ITEM' && !element.hasAttribute('_removing');
  }; // Filter out items being removed


  var isRemovingOrRemoved = function isRemovingOrRemoved(item) {
    return item.hasAttribute('_removing') || !item.parentNode;
  };
  /**
   * Returns the position of the second element relative to the first element.
   */


  var relativePosition = function relativePosition(el1, el2) {
    var rect1 = el1.getBoundingClientRect();
    var rect2 = el2.getBoundingClientRect();
    return {
      left: rect2.left - rect1.left,
      top: rect2.top - rect1.top
    };
  };

  var weightedDistance = function weightedDistance(x1, y1, x2, y2, unitWidth, unitHeight) {
    return Math.sqrt(Math.pow((x2 - x1) / unitWidth, 2) + Math.pow((y2 - y1) / unitHeight, 2));
  };

  var getPreviousItem = function getPreviousItem(item) {
    var previousItem = item.previousElementSibling;
    return itemFilter(previousItem) ? previousItem : null;
  };
  /**
   @class Coral.Masonry
   @classdesc A Masonry component that allows to lay out items in a masonry grid.
   @htmltag coral-masonry
   @extends {HTMLElement}
   @extends {BaseComponent}
   */


  var Masonry = /*#__PURE__*/function (_BaseComponent) {
    _inherits(Masonry, _BaseComponent);

    var _super = _createSuper(Masonry);

    /** @ignore */
    function Masonry() {
      var _this;

      _classCallCheck(this, Masonry);

      _this = _super.call(this); // Defaults

      _this._loaded = false;
      _this._layouted = false;
      _this._layoutScheduled = false;
      _this._forceDebounce = false;
      _this._debounceId = null;
      _this._newItems = [];
      _this._tabbableItem = null; //a11y

      _this._defaultAriaRole = "group";
      _this._ariaGrid = ariaGrid.OFF;
      _this._preservedAriaRole = _this._defaultAriaRole;
      _this._preservedParentAriaRole = null;

      _this._delegateEvents({
        'global:resize': '_onWindowResize',
        // Loaded
        'global:load': '_updateLoaded',
        'capture:load img': '_updateLoaded',
        'capture:error img': '_updateLoaded',
        // Drag and drop
        'coral-dragaction:dragstart coral-masonry-item': '_onItemDragStart',
        'coral-dragaction:dragover coral-masonry-item': '_onItemDragMove',
        'coral-dragaction:dragend coral-masonry-item': '_onItemDragEnd',
        // Keyboard
        'capture:focus coral-masonry-item': '_onItemFocus',
        // Selection
        'click coral-masonry-item': '_onItemClick',
        'key:space coral-masonry-item': '_onItemClick',
        // private
        'coral-masonry-item:_connected': '_onItemConnected',
        'coral-masonry-item:_selectedchanged': '_onItemSelectedChanged'
      }); // Relayout when child elements change or are added/removed
      // Should this mutation observer become a bottleneck, it could be replaced with a resize listener


      _this._observer = new MutationObserver(_this._scheduleLayout.bind(_assertThisInitialized(_this), 'mutation'));

      _this._observer.observe(_assertThisInitialized(_this), {
        childList: true,
        subtree: true,
        characterData: true,
        attributes: true
      }); // Used for eventing


      _this._oldSelection = []; // Init the collection mutation observer

      _this.items._startHandlingItems(true);

      return _this;
    }
    /**
     Allows to interact with the masonry items.
      @type {SelectableCollection}
     @readonly
     */


    _createClass(Masonry, [{
      key: "_onItemSelectedChanged",
      value: function _onItemSelectedChanged(event) {
        event.stopImmediatePropagation();

        this._validateSelection(event.target);
      }
      /**
       Allows to interact with the masonry layout instance.
        @type {MasonryLayout}
       @readonly
       */

    }, {
      key: "_updateAriaRoleForParent",

      /** @private */
      value: function _updateAriaRoleForParent(activateAriaGrid) {
        if (!this.parentElement) {
          return;
        }

        if (activateAriaGrid === ariaGrid.ON) {
          // Save/set role for the parent as grid
          this._preservedParentAriaRole = this.parentElement.getAttribute('role');
          this.parentElement.setAttribute('role', 'grid'); // parent grid should be labelled the same as coral-masonry

          if (this.ariaLabel && this.parentElement.getAttribute('aria-label') !== this.ariaLabel) {
            this._preservedParentAriaLabel = this.parentElement.getAttribute('aria-label');
            this.parentElement.setAttribute('aria-label', this.ariaLabel);
          }

          if (this.ariaLabelledby && this.parentElement.getAttribute('aria-labelledby') !== this.ariaLabelledby) {
            this._preservedParentAriaLabelledby = this.parentElement.getAttribute('aria-labelledby');
            this.parentElement.setAttribute('aria-labelledby', this.ariaLabelledby);
          }
        } else {
          // Restore/remove role of the parent element
          if (this._preservedParentAriaRole) {
            this.parentElement.setAttribute('role', this._preservedParentAriaRole);
          } else {
            this.parentElement.removeAttribute('role');
          } // restore the aria-label or aria-labelledby values as well


          if (this._preservedParentAriaLabel) {
            this.parentElement.setAttribute('aria-label', this._preservedParentAriaLabel);
            this._preservedParentAriaLabel = undefined;
          } else {
            this.parentElement.removeAttribute('aria-label');
          }

          if (this._preservedParentAriaLabelledby !== undefined) {
            this.parentElement.setAttribute('aria-labelledby', this._preservedParentAriaLabelledby);
          } else {
            this.parentElement.removeAttribute('aria-labelledby');
          } // Remove aria-colcount


          this.parentElement.removeAttribute('aria-colcount');
        }
      }
      /** @private */

    }, {
      key: "_updateAriaRoleForItems",
      value: function _updateAriaRoleForItems(activateAriaGrid) {
        var _this2 = this;

        var columnIndex = 1;
        this.items.getAll().forEach(function (item) {
          _this2._updateAriaRoleForItem(item, columnIndex++, activateAriaGrid);
        });
      }
      /** @private */

    }, {
      key: "_updateAriaRoleForItem",
      value: function _updateAriaRoleForItem(item, columnIndex, activateAriaGrid) {
        if (activateAriaGrid === ariaGrid.ON) {
          item.setAttribute('role', 'gridcell');
          item.setAttribute('aria-colindex', columnIndex);
        } else {
          item.removeAttribute('role');
          item.removeAttribute('aria-colindex');
        }
      }
      /** @private */

    }, {
      key: "_updateAriaColumnCountForParent",
      value: function _updateAriaColumnCountForParent(activateAriaGrid) {
        if (!this.parentElement) {
          return;
        }

        if (activateAriaGrid === ariaGrid.ON) {
          this.parentElement.setAttribute('aria-colcount', this.items.length);
        } else {
          this.parentElement.removeAttribute('aria-colcount');
        }
      }
    }, {
      key: "_validateSelection",
      value: function _validateSelection(item) {
        var _this3 = this;

        var selectedItems = this.selectedItems;

        if (this.selectionMode === selectionMode$2.NONE) {
          selectedItems.forEach(function (selectedItem) {
            // Don't trigger change events
            _this3._preventTriggeringEvents = true;
            selectedItem.removeAttribute('selected');
          });
        } else if (this.selectionMode === selectionMode$2.SINGLE) {
          // Last selected item wins if multiple selection while not allowed
          item = item || selectedItems[selectedItems.length - 1];

          if (item && item.hasAttribute('selected') && selectedItems.length > 1) {
            selectedItems.forEach(function (selectedItem) {
              if (selectedItem !== item) {
                // Don't trigger change events
                _this3._preventTriggeringEvents = true;
                selectedItem.removeAttribute('selected');
              }
            }); // We can trigger change events again

            this._preventTriggeringEvents = false;
          }
        }

        this._triggerChangeEvent();
      }
    }, {
      key: "_triggerChangeEvent",
      value: function _triggerChangeEvent() {
        var selectedItems = this.selectedItems;
        var oldSelection = this._oldSelection;

        if (!this._preventTriggeringEvents && this._arraysAreDifferent(selectedItems, oldSelection)) {
          if (this.selectionMode === selectionMode$2.MULTIPLE) {
            this.trigger('coral-masonry:change', {
              oldSelection: oldSelection,
              selection: selectedItems
            });
          } else {
            this.trigger('coral-masonry:change', {
              oldSelection: oldSelection.length > 1 ? oldSelection : oldSelection[0] || null,
              selection: selectedItems[0] || null
            });
          }

          this._oldSelection = selectedItems;
        }
      }
    }, {
      key: "_arraysAreDifferent",
      value: function _arraysAreDifferent(selection, oldSelection) {
        var diff = [];

        if (oldSelection.length === selection.length) {
          diff = oldSelection.filter(function (item) {
            return selection.indexOf(item) === -1;
          });
        } // since we guarantee that they are arrays, we can start by comparing their size


        return oldSelection.length !== selection.length || diff.length !== 0;
      }
    }, {
      key: "_onItemClick",
      value: function _onItemClick(event) {
        if (this.selectionMode !== selectionMode$2.NONE) {
          event.preventDefault();
          var item = event.matchedTarget;
          item[item.hasAttribute('selected') ? 'removeAttribute' : 'setAttribute']('selected', '');
        }
      }
      /** @private */

    }, {
      key: "_setAllSelected",
      value: function _setAllSelected(selected) {
        var items = this.items.getAll();

        for (var i = 0; i < items.length; i++) {
          var item = items[i];

          if (item.hasAttribute('selected') !== selected) {
            item[selected ? 'setAttribute' : 'removeAttribute']('selected', '');
          }
        }
      }
      /**
       Schedules a layout for the next animation frame. Even if called many times, the layout happens still just once.
        @private
       */

    }, {
      key: "_scheduleLayout",
      value: function _scheduleLayout() {
        var _this4 = this;

        if (!this._forceDebounce && !this._layoutScheduled) {
          window.requestAnimationFrame(function () {
            // Skip layout if a layout was forced in between
            if (_this4._layoutScheduled) {
              _this4._doLayout(); // Cancel potentially scheduled layout if the current layout was enforced by calling doLayout directly


              _this4._layoutScheduled = false;
            }
          });
          this._layoutScheduled = true;
        }
      }
      /** @private */

    }, {
      key: "_scheduleDebouncedLayout",
      value: function _scheduleDebouncedLayout(force) {
        var _this5 = this;

        // Do not force debounce if the masonry isn't layouted yet. Safari sometimes triggers resize events while loading.
        if (force && this._layouted) {
          this._forceDebounce = true;
        }

        window.clearTimeout(this._debounceId);
        this._debounceId = window.setTimeout(function () {
          _this5._forceDebounce = false;

          _this5._scheduleLayout('window resize');
        }, 500);
      }
      /**
       Callback which has to be called when the dimensions have changed or the masonry turned visible.
        @private
       */

    }, {
      key: "_onResize",
      value: function _onResize() {
        if (!this._layouted) {
          // The masonry was first invisible, render it now immediately
          this._doLayout('became visible');
        } else {
          this._scheduleDebouncedLayout(false);
        }
      }
      /** @private */

    }, {
      key: "_onWindowResize",
      value: function _onWindowResize() {
        this._scheduleDebouncedLayout(true);
      }
      /**
       Performs a layout. Should only be called by {@link #_scheduleLayout} if possible.
        @private
       */

    }, {
      key: "_doLayout",
      value: function _doLayout() {
        var visible = !!this.offsetParent;
        var LayoutClass = this.constructor._layouts[this.layout];

        if (this._forceDebounce || !LayoutClass || !visible) {
          return;
        }

        if (!this._layoutInstance) {
          this._layoutInstance = new LayoutClass(this);
        } // Check if the layout has changed
        else if (this._layoutInstance.name !== this.layout) {
            this._layoutInstance.destroy();

            this._layoutInstance = new LayoutClass(this);
          } // Animate insertion. In the attachedCallback of the item, the is-beforeInserting class was already added. This
        // class is now removed again which allows to transition between the is-beforeInserting and is-inserting class.
        // By separating the code and batching the changes, the overhead is reduced significantly.


        var i;
        var newItems = this._newItems;

        for (i = 0; i < newItems.length; i++) {
          newItems[i]._insert();
        } // Position the items


        this._layoutInstance.layout();

        this._layouted = true; // Mark newly added items as managed. Before this class is added, the items are invisible. The reason why this is
        // done here after positioning the items is that it seems to be the only way to ensure that the items are never
        // shown at the wrong position. There used to be two cases when this happened:
        // - When the masonry is first invisible and later shown because the resize event is triggered too late.
        // - In some browsers (e.g. Safari) always when items are added dynamically

        for (i = 0; i < newItems.length; i++) {
          newItems[i].classList.add('is-managed');
        } // clear


        newItems.length = 0; // Update loaded class. Cannot be done in _updateLoaded because it has to happen after the positioning.

        this.classList.toggle('is-loaded', this._loaded); // Ensure that the tabbable item is set & still valid

        var tabbableItem = this._tabbableItem;

        if (!tabbableItem || isRemovingOrRemoved(tabbableItem)) {
          this._setTabbableItem(this.items.first());
        } // Focus the next item if the previously focused item has been removed


        var focusedItem = this._focusedItem;

        if (focusedItem) {
          if (isRemovingOrRemoved(focusedItem) && this._focusedItemNext) {
            this._focusedItemNext.focus();
          } else if (focusedItem !== document.activeElement) {
            this._focusedItem = null;
            this._focusedItemNext = null;
          }
        } // Update items, so that column indexes are correctly set


        this._updateAriaRoleForItems(this.ariaGrid);

        this._updateAriaColumnCountForParent(this.ariaGrid); // Prevent endless observation loop (skip mutations which have been caused by the layout)


        this._observer.takeRecords();
      }
      /** @ignore */

    }, {
      key: "_updateLoaded",
      value: function _updateLoaded() {
        // Wait until complete because fonts might be loaded after interactive
        if (!this._loaded && document.readyState === 'complete') {
          var loaded = true;
          var images = this.querySelectorAll('img');

          for (var i = 0; i < images.length; i++) {
            var image = images[i]; // _loadError is set in a listener at the top of this file

            if (image.src && !image.complete && !image._loadError) {
              loaded = false;
              break;
            }
          }

          this._loaded = loaded;
        } // A loaded image might have made an item bigger


        this._scheduleLayout();
      }
      /** @private */

    }, {
      key: "_onItemConnected",
      value: function _onItemConnected(event) {
        event.stopImmediatePropagation();
        var item = event.target;

        this._prepareItem(item);
      }
    }, {
      key: "_prepareItem",
      value: function _prepareItem(item) {
        var _this6 = this;

        // We don't care about transitions if the masonry is not in the body
        if (!document.body.contains(this)) {
          return;
        } // check if just moving


        if (!item.hasAttribute('_removing') && this !== item._masonry && !item.hasAttribute('_placeholder')) {
          item._masonry = this; // Insert animation start style. This is separated from _insert because otherwise we would have to enforce a
          // reflow between changing the classes for every item (which is slow).

          item.classList.add('is-beforeInserting'); // Do it in the next frame so that the inserting animation is visible

          window.requestAnimationFrame(function () {
            _this6._onItemAdded(item);
          });
        }
      }
      /** @private */

    }, {
      key: "_onItemDisconnected",
      value: function _onItemDisconnected(item) {
        // We don't care about transitions if the masonry is not in the body
        if (!document.body.contains(this)) {
          return;
        } // Ignore the item being dropped after ordering


        if (item._dropping) {
          return;
        }

        if (!item.hasAttribute('_removing')) {
          // Attach again for remove transition
          item.setAttribute('_removing', '');
          this.appendChild(item);
          commons.transitionEnd(item, function () {
            item.remove();
          });
        } // remove transition completed
        else {
            item.removeAttribute('_removing');
            item._masonry = null;

            this._onItemRemoved(item);
          }
      }
      /** @private */

    }, {
      key: "_onItemAdded",
      value: function _onItemAdded(item) {
        item._updateDragAction(this.orderable);

        this._newItems.push(item); // Hack to prevent flickering in some browsers which don't support custom elements natively (e.g. Safari)


        if (this._attaching && item.nextElementSibling === null) {
          this._doLayout('last item attached');
        }
      }
      /** @private */

    }, {
      key: "_onItemRemoved",
      value: function _onItemRemoved(item) {
        item._updateDragAction(false);

        item.classList.remove('is-managed');
      }
      /** @private */

    }, {
      key: "_onItemFocus",
      value: function _onItemFocus(e) {
        var item = e.target;

        if (item === e.matchedTarget) {
          this._setTabbableItem(item); // Remember the focused item and a sibling for the case when the currently focused item is removed and another
          // item has to be selected in _doLayout


          this._focusedItem = item;
          this._focusedItemNext = [item.nextElementSibling, item.previousElementSibling].filter(itemFilter)[0];
        }
      }
      /** @private */

    }, {
      key: "_setTabbableItem",
      value: function _setTabbableItem(item) {
        if (this._tabbableItem) {
          this._tabbableItem._setTabbable(false);
        }

        if (item) {
          item._setTabbable(true);
        }

        this._tabbableItem = item;
      }
      /**
       @return {Boolean} true if the new position isn't further away from the center of the placeholder than the
       previous position.
        @private
       */

    }, {
      key: "_isApproachingPlaceholder",
      value: function _isApproachingPlaceholder(pos, prevPos, placeholder) {
        var placeholderPos = relativePosition(this, placeholder);
        var placeholderWidth = placeholder.offsetWidth;
        var placeholderHeight = placeholder.offsetHeight;
        var placeholderX = placeholderPos.left + placeholderWidth / 2;
        var placeholderY = placeholderPos.top + placeholderHeight / 2; // A weighted distance is used to improve the user experience with rather long/high cards

        return weightedDistance(placeholderX, placeholderY, pos.left, pos.top, placeholderWidth, placeholderHeight) <= weightedDistance(placeholderX, placeholderY, prevPos.left, prevPos.top, placeholderWidth, placeholderHeight);
      }
      /** @private */

    }, {
      key: "_onItemDragStart",
      value: function _onItemDragStart(e) {
        var item = e.target;

        if (item === e.matchedTarget) {
          this._layoutInstance.detach(item);

          item._oldBefore = getPreviousItem(item);
          var placeholder = item._dropPlaceholder = new MasonryItem();
          placeholder.setAttribute('_placeholder', ''); // Add a content div with the right dimension instead of setting the dimension on the item directly. This is
          // necessary because some layouts modify the dimensions as well.

          var contentDiv = document.createElement('div');
          contentDiv.style.width = "".concat(item.clientWidth, "px");
          contentDiv.style.height = "".concat(item.clientHeight, "px");
          placeholder.appendChild(contentDiv); // Insert placeholder before dragged item

          placeholder.classList.add('_coral-Masonry-item--placeholder');
          this.insertBefore(placeholder, item);
        }
      }
      /** @private */

    }, {
      key: "_onItemDragMove",
      value: function _onItemDragMove(e) {
        var item = e.target;
        var placeholder = item._dropPlaceholder;

        if (item === e.matchedTarget && placeholder) {
          var prevPos = item._prevDragPos;
          var pos = relativePosition(this, item); // If the current move is approaching the previous placeholder target, then it must not move the placeholder
          // again. Otherwise it can happen with multi-column items that the items jump around hectically while dragging
          // an item.

          if (!prevPos || !this._isApproachingPlaceholder(pos, prevPos, placeholder)) {
            // Find item below cursor
            var itemBelow = this._layoutInstance.itemAt(pos.left, pos.top);

            if (itemBelow && itemBelow !== placeholder) {
              // If the item below (the dragged item) is preceding the placeholder, then it has to insert the placeholder
              // before the item below (the dragged item)
              if (placeholder.compareDocumentPosition(itemBelow) & document.DOCUMENT_POSITION_PRECEDING) {
                itemBelow.parentNode.insertBefore(placeholder, itemBelow);
              } else {
                itemBelow.parentNode.insertBefore(placeholder, itemBelow.nextSibling);
              }
            }
          }

          item._prevDragPos = pos;
        }
      }
      /** @private */

    }, {
      key: "_onItemDragEnd",
      value: function _onItemDragEnd(e) {
        var item = e.target;
        var placeholder = item._dropPlaceholder;

        if (item === e.matchedTarget && placeholder) {
          item._dropping = true; // Replace the drop placeholder with this item

          this.replaceChild(item, placeholder);
          item._dropping = false; // Trigger order event

          item.trigger('coral-masonry:order', {
            item: item,
            oldBefore: item._oldBefore,
            before: getPreviousItem(item)
          }, true, false); // // Drop transition

          this._layoutInstance.reattach(item);

          item.classList.add('is-dropping');
          commons.transitionEnd(item, function () {
            item.classList.remove('is-dropping');
          }); // Update items, so that column indexes are correctly set

          this._updateAriaRoleForItems(this.ariaGrid);
        }

        item._oldBefore = null;
        item._dropPlaceholder = null;
        item._prevDragPos = null;
      }
      /**
       Registry for masonry layouts.
        @type {Object.<string,Layout>}
       @private
       @readonly
       */

    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        var _this7 = this;

        _get(_getPrototypeOf(Masonry.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$X); // Keep the default behavior when ariaGrid is not enabled

        if (this._ariaGrid === ariaGrid.OFF) {
          // a11y
          this.setAttribute('role', this._defaultAriaRole);
        } // Default reflected attributes


        if (!this._layout) {
          this.layout = layouts.FIXED_CENTERED;
        }

        if (!this._selectionMode) {
          this.selectionMode = selectionMode$2.NONE;
        } // Don't trigger events once connected


        this._preventTriggeringEvents = true;

        this._validateSelection();

        this._preventTriggeringEvents = false;
        this._oldSelection = this.selectedItems; // Handles the resizing of the masonry

        commons.addResizeListener(this, this._onResize.bind(this)); // Prepare items

        this.items.getAll().forEach(function (item) {
          _this7._prepareItem(item);
        }); // This indicates that the initial items are being attached

        this._attaching = true;
        window.requestAnimationFrame(function () {
          _this7._attaching = false; // Update loaded after all items have been attached

          _this7._updateLoaded();
        });
      }
      /**
       Triggered when a {@link Masonry} item is reordered.
        @typedef {CustomEvent} coral-masonry:order
        @property {MasonryItem} detail.item
       The reordered item
       @property {?MasonryItem} detail.oldBefore
       The previous item before the reordering.
       @property {?MasonryItem} detail.before
       The previous item after the reordering.
       */

      /**
       Triggered when {@link Masonry} selected item has changed.
        @typedef {CustomEvent} coral-masonry:change
        @property {MasonryItem} detail.oldSelection
       The prior selected item(s).
       @property {MasonryItem} detail.selection
       The newly selected item(s).
       */

    }, {
      key: "items",
      get: function get() {
        if (!this._items) {
          this._items = new SelectableCollection({
            host: this,
            itemTagName: 'coral-masonry-item',
            // allows masonry to be nested
            itemSelector: ':scope > coral-masonry-item:not([_removing]):not([_placeholder])',
            onItemAdded: this._validateSelection,
            onItemRemoved: this._validateSelection
          });
        }

        return this._items;
      }
      /**
       Selection mode of Masonry
        @type {String}
       @default MasonrySelectionModeEnum.NONE
       @htmlattribute selectionmode
       @htmlattributereflected
       */

    }, {
      key: "selectionMode",
      get: function get() {
        return this._selectionMode || selectionMode$2.NONE;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        this._selectionMode = validate.enumeration(selectionMode$2)(value) && value || selectionMode$2.NONE;

        this._reflectAttribute('selectionmode', this._selectionMode);

        if (this._selectionMode === selectionMode$2.NONE) {
          this.classList.remove('is-selectable');
          this.removeAttribute('aria-multiselectable');
        } else {
          this.classList.add('is-selectable');
          this.setAttribute('aria-multiselectable', this._selectionMode === selectionMode$2.MULTIPLE);
        }

        this._validateSelection();
      }
    }, {
      key: "layoutInstance",
      get: function get() {
        return this._layoutInstance;
      }
      /**
       The layout name for this masonry. Must be one of {@link Coral.Masonry.layouts}.
       See {@link MasonryLayoutsEnum}.
        @type {String}
       @default MasonryLayoutsEnum.FIXED_CENTERED
       @htmlattribute layout
       @htmlattributereflected
       */

    }, {
      key: "layout",
      get: function get() {
        return this._layout || layouts.FIXED_CENTERED;
      },
      set: function set(value) {
        value = transform.string(value);
        var layoutEnum = this.constructor._layouts;

        if (value === '') {
          // Default is first registered layout which is "fixed-centered"
          value = Object.keys(layoutEnum)[0];
        }

        if (value !== this._layout) {
          if (layoutEnum[value]) {
            this._layout = value;

            this._reflectAttribute('layout', this._layout);

            this._scheduleLayout('new layout');
          } else {
            commons._log('Coral.Masonry: Unknown layout:', value);
          }
        }
      }
      /**
       The first selected item or <code>null</code> if no item is selected.
        @type {MasonryItem}
       @readonly
       */

    }, {
      key: "selectedItem",
      get: function get() {
        return this.items._getFirstSelected();
      }
      /**
       An array of all selected items.
        @type {Array.<MasonryItem>}
       @readonly
       */

    }, {
      key: "selectedItems",
      get: function get() {
        return this.items._getAllSelected();
      } // TODO this is layout specific. move to layout?

      /**
       The spacing between the items and the masonry container in pixel. If this property is not set, then it falls
       back to the CSS padding of the masonry and margin of the items.
        @type {?Number}
       @default null
       @htmlattribute spacing
       */

    }, {
      key: "spacing",
      get: function get() {
        return this._spacing || null;
      },
      set: function set(value) {
        value = transform.number(value);
        this._spacing = value !== null ? Math.max(0, value) : null;

        this._scheduleLayout('spacing');
      }
      /**
       Whether or not it is possible to order items with drag & drop.
        @type {Boolean}
       @default false
       @htmlattribute orderable
       */

    }, {
      key: "orderable",
      get: function get() {
        return this._orderable || false;
      },
      set: function set(value) {
        this._orderable = transform.booleanAttr(value);
        var items = this.items.getAll();

        for (var i = 0; i < items.length; i++) {
          items[i][this._orderable ? 'setAttribute' : 'removeAttribute']('_orderable', '');
        }
      }
      /**
       Attribute to enable/disable auto aria grid role assignment. Value must be one of {@link MasonryAriaGridEnum}.
       Setting this property to {@link MasonryAriaGridEnum.ON} will do following to enable support for accessibility:
       - Preserve current role attribute of the parent element of {@link Masonry}, and set new role as grid.
       - Preserve current role attribute of the {@link Masonry}, and set new role as row.
       - Set role attribute of all child {@link MasonryItem} to gridcell.
        Setting the property to {@link MasonryAriaGridEnum.OFF} will do following:
       - Restore preserved (if any) role attribute of the parent element of {@link Masonry}.
       - Restore preserved role attribute of the {@link Masonry}.
       - Remove role attribute of all child {@link MasonryItem}.
        Setting the attribute to other than allowed values will fallback to {@link MasonryAriaGridEnum.OFF}.
        @type {String}
       @default {@link MasonryAriaGridEnum.OFF}
       @htmlattribute ariagrid
       @htmlattributereflected
       */

    }, {
      key: "ariaGrid",
      get: function get() {
        return this._ariaGrid || ariaGrid.OFF;
      },
      set: function set(value) {
        value = transform.string(value); // Ensure correct values

        if (value !== ariaGrid.ON && value !== ariaGrid.OFF) {
          console.warn('Coral.Masonry: Unsupported ariaGrid value: ', value, '. Will fallback to ', ariaGrid.OFF);
          value = ariaGrid.OFF;
        } //update current state


        this._ariaGrid = value;

        this._reflectAttribute('ariagrid', this._ariaGrid); // Update role for this masonry


        if (this._ariaGrid === ariaGrid.ON) {
          // Preserve existing role and set new role
          this._preservedAriaRole = this.getAttribute('role');
          this.setAttribute('role', 'row');
        } else if (this._ariaGrid == ariaGrid.OFF) {
          // Restore or remove role
          if (this._preservedAriaRole) {
            this.setAttribute('role', this._preservedAriaRole);
          } else {
            this.removeAttribute('role');
          }
        } // Update parent and child item roles based on current state


        this._updateAriaRoleForParent(this._ariaGrid);

        this._updateAriaColumnCountForParent(this._ariaGrid);

        this._updateAriaRoleForItems(this._ariaGrid);
      }
      /**
       Specifies aria-label value
        @type {?String}
       @htmlattribute aria-label
       @htmlattributereflected
       */

    }, {
      key: "ariaLabel",
      get: function get() {
        return this.getAttribute('aria-label');
      },
      set: function set(value) {
        value = transform.string(value);

        if (value === '') {
          this.removeAttribute('aria-label');
        } else {
          this._reflectAttribute('aria-label', value);
        }

        if (!this.parentElement || this._ariaGrid === ariaGrid.OFF) {
          return;
        }

        if (this.ariaLabel) {
          this.parentElement.setAttribute('aria-label', this.ariaLabel);
        } else {
          this.parentElement.removeAttribute('aria-label');
        }
      }
      /**
       Specifies aria-labelledby value
        @type {?String}
       @htmlattribute aria-labelledby
       @htmlattributereflected
       */

    }, {
      key: "ariaLabelledby",
      get: function get() {
        return this.getAttribute('aria-labelledby');
      },
      set: function set(value) {
        value = transform.string(value);

        if (value === '') {
          this.removeAttribute('aria-labelledby');
        } else {
          this._reflectAttribute('aria-labelledby', value);
        }

        if (!this.parentElement || this._ariaGrid === ariaGrid.OFF) {
          return;
        }

        if (this.ariaLabelledby) {
          this.parentElement.setAttribute('aria-labelledby', this.ariaLabelledby);
        } else {
          this.parentElement.removeAttribute('aria-labelledby');
        }
      }
    }], [{
      key: "registerLayout",

      /**
       Registers a layout with the given name.
       The name can then be set at {@link Coral.Masonry.layout} to render a masonry with the this registered layout.
        @param {String} name of the layout
       @param {Layout} Layout class which extends {@link Coral.Masonry.Layout}
       */
      value: function registerLayout(name, Layout) {
        Layout.defineName(name);
        this._layouts[name] = Layout;
      }
      /**
       Returns {@link Masonry} layouts.
        @return {MasonryLayoutsEnum}
       */

    }, {
      key: "_layouts",
      get: function get() {
        if (!this.__layouts) {
          this.__layouts = {};
        }

        return this.__layouts;
      }
    }, {
      key: "layouts",
      get: function get() {
        return layouts;
      }
      /**
       Returns {@link Masonry} selection mode options.
        @return {MasonrySelectionModeEnum}
       */

    }, {
      key: "selectionMode",
      get: function get() {
        return selectionMode$2;
      }
    }, {
      key: "_attributePropertyMap",
      get: function get() {
        return commons.extend(_get(_getPrototypeOf(Masonry), "_attributePropertyMap", this), {
          selectionmode: 'selectionMode',
          ariagrid: 'ariaGrid',
          'aria-label': 'ariaLabel',
          'aria-labelledby': 'ariaLabelledby'
        });
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(Masonry), "observedAttributes", this).concat(['selectionmode', 'layout', 'spacing', 'orderable', 'ariagrid', 'aria-label', 'aria-labelledby']);
      }
    }]);

    return Masonry;
  }(BaseComponent(HTMLElement));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   Base class for masonry layouts.

   Whenever a change is detected, the {@link Coral.Masonry.Layout#layout} method is called. This method must then
   ensure that all the items are positioned correctly.

   Layout-specific keyboard support must be handled by adding event listeners to the masonry in the constructor. Such
   event listeners must be removed in the {@link Coral.Masonry.Layout#destroy} method.

   @param masonry
   @class Coral.Masonry.Layout
   */
  var MasonryLayout = /*#__PURE__*/function () {
    /**
     * this is constructor description.
     * @param {number} arg1 this is arg1 description.
     * @param {string[]} arg2 this is arg2 description.
     */
    function MasonryLayout(masonry) {
      _classCallCheck(this, MasonryLayout);

      this._masonry = masonry;
    }
    /**
     Layout name. Uses the constructor given name by default if defined.
      @type {String}
     */


    _createClass(MasonryLayout, [{
      key: "layout",

      /**
       Lays out the masonry items according to the implementation.
       */
      value: function layout() {} // To override

      /**
       Removes all layout-specific attributes, style, data and event listeners from the masonry and its items.
       */

    }, {
      key: "destroy",
      value: function destroy() {} // To override

      /**
       Removes the item from the control of the layout. This can be used to position the item differently,
       for example for drag&drop.
        @param {MasonryItem} item
       */
      // eslint-disable-next-line no-unused-vars

    }, {
      key: "detach",
      value: function detach(item) {} // To override

      /**
       Adds the item to the control of the layout again. The layout has to ensure that the item will be transitioned to
       its normal position flawlessly.
        @param {MasonryItem} item
       */
      // eslint-disable-next-line no-unused-vars

    }, {
      key: "reattach",
      value: function reattach(item) {} // To override

      /**
       Returns the item at the given position. The position coordinates are relative to the masonry.
        If an item is being transitioned when this method is called, then it must choose the item based on the final
       instead of the current position.
        @param {number} x
       @param {number} y
       @return {?Coral.Masonry.Item}
       */
      // eslint-disable-next-line no-unused-vars

    }, {
      key: "itemAt",
      value: function itemAt(x, y) {} // To override

      /**
       Defines the name of the Layout
        @param {String} name
       */

    }, {
      key: "name",
      get: function get() {
        return this._name || this.constructor._name;
      },
      set: function set(value) {
        this._name = value;
      }
    }], [{
      key: "defineName",
      value: function defineName(name) {
        this._name = name;
      }
    }]);

    return MasonryLayout;
  }();

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /** @ignore */
  var setTransform = function setTransform(el, value) {
    el.style.setProperty('-webkit-transform', value);
    el.style.setProperty('-ms-transform', value);
    el.style.transform = value;
  };
  /** @ignore */


  var setTransition = function setTransition(el, value) {
    el.style.setProperty('-webkit-transition', value);
    el.style.setProperty('-ms-transition', value);
    el.style.transition = value;
  };
  /** @ignore */


  var getFirstRowFilledColumns = function getFirstRowFilledColumns(columns, items) {
    var filledColumns = 0;

    for (var i = 0; i < items.length; i++) {
      var item = items[i];
      filledColumns += item._layoutData.colspan;

      if (filledColumns >= columns.length) {
        return columns.length;
      }
    }

    return filledColumns;
  };
  /** @ignore */


  var csspx = function csspx(el, property) {
    return parseFloat(window.getComputedStyle(el)[property], 10);
  }; // TODO if the property changes, it will not automatically relayout the masonry
  // TODO test columnWidth and colspan property and default values

  /** @ignore */


  var getPositiveNumberProperty = function getPositiveNumberProperty(element, property, attribute, defaultValue) {
    var value = element[property];

    if (value === undefined) {
      value = element.getAttribute(attribute);
    }

    value = parseInt(value, 10);

    if (value <= 0 || isNaN(value)) {
      value = defaultValue;
    }

    return value;
  };

  /**
   Base class for column-based masonry layouts.

   @class Coral.Masonry.ColumnLayout
   @classdesc A Masonry Column layout
   @extends {MasonryLayout}
   */

  var MasonryColumnLayout = /*#__PURE__*/function (_MasonryLayout) {
    _inherits(MasonryColumnLayout, _MasonryLayout);

    var _super = _createSuper(MasonryColumnLayout);

    /**
     Takes a {Masonry} instance as argument.
      @param {Masonry} masonry
     */
    function MasonryColumnLayout(masonry) {
      var _this;

      _classCallCheck(this, MasonryColumnLayout);

      _this = _super.call(this, masonry);
      _this._columns = [];

      var up = _this._moveFocusVertically.bind(_assertThisInitialized(_this), true);

      var down = _this._moveFocusVertically.bind(_assertThisInitialized(_this), false);

      var left = _this._moveFocusHorizontally.bind(_assertThisInitialized(_this), true);

      var right = _this._moveFocusHorizontally.bind(_assertThisInitialized(_this), false);

      var home = _this._moveFocusHomeEnd.bind(_assertThisInitialized(_this), true);

      var end = _this._moveFocusHomeEnd.bind(_assertThisInitialized(_this), false);

      var keys = _this._keys = new Keys(masonry, {
        context: _assertThisInitialized(_this)
      });
      keys.on('up', up).on('k', up);
      keys.on('down', down).on('j', down);
      keys.on('left', left).on('h', left);
      keys.on('right', right).on('l', right);
      keys.on('home', home);
      keys.on('end', end);
      return _this;
    }
    /**
     Hook to remove layout specific style and data from the item.
      @param item
     @private
     */
    // eslint-disable-next-line no-unused-vars


    _createClass(MasonryColumnLayout, [{
      key: "_resetItem",
      value: function _resetItem(item) {} // To override

      /**
       Initialize layout variables.
        @private
       */

    }, {
      key: "_init",
      value: function _init(items) {
        var firstItem = items[0];
        var masonry = this._masonry;
        this._columnWidth = getPositiveNumberProperty(masonry, 'columnWidth', 'columnwidth', 200);
        this._zeroOffsetLeft = -csspx(firstItem, 'marginLeft'); // with padding

        this._masonryInnerWidth = masonry.clientWidth;
        var spacing = this._masonry.spacing;

        if (typeof spacing === 'number') {
          this._horSpacing = spacing;
          this._verSpacing = spacing;
          this._offsetLeft = spacing + this._zeroOffsetLeft;
          this._offsetTop = spacing - csspx(firstItem, 'marginTop');
          this._verPadding = 2 * spacing;
          this._masonryAvailableWidth = masonry.clientWidth - spacing;
        } else {
          this._horSpacing = csspx(firstItem, 'marginLeft') + csspx(firstItem, 'marginRight');
          this._verSpacing = csspx(firstItem, 'marginTop') + csspx(firstItem, 'marginBottom');
          this._offsetLeft = csspx(masonry, 'paddingLeft');
          this._offsetTop = csspx(masonry, 'paddingTop');
          this._verPadding = this._offsetTop + this._verSpacing + csspx(masonry, 'paddingBottom');
          this._masonryAvailableWidth = masonry.clientWidth - this._offsetLeft - csspx(masonry, 'paddingRight');
        } // Initialize column objects


        var columnCount = Math.max(1, Math.floor(this._masonryAvailableWidth / (this._columnWidth + this._horSpacing)));
        this._columns.length = columnCount;

        for (var ci = 0; ci < columnCount; ci++) {
          this._columns[ci] = {
            height: this._offsetTop,
            items: []
          };
        } // Prepare layout data


        for (var ii = 0; ii < items.length; ii++) {
          var item = items[ii];
          var layoutData = item._layoutData;

          if (!layoutData) {
            item._layoutData = layoutData = {};
          } // Read colspan


          layoutData.colspan = Math.min(getPositiveNumberProperty(item, 'colspan', 'colspan', 1), this._columns.length);
        }
      }
      /**
       Updates the width of all items.
        @param items
       @private
       */

    }, {
      key: "_writeStyles",
      value: function _writeStyles(items) {
        for (var i = 0; i < items.length; i++) {
          var item = items[i];
          var layoutData = item._layoutData; // Update width

          var itemWidth = Math.round(this._getItemWidth(layoutData.colspan));

          if (layoutData.width !== itemWidth) {
            item.style.width = "".concat(itemWidth, "px");
            layoutData.width = itemWidth;
          }

          this._writeItemStyle(item);
        }
      }
      /**
       @param colspan column span of the item
       @return the width of the item for the given colspan
       @private
       */
      // eslint-disable-next-line no-unused-vars

    }, {
      key: "_getItemWidth",
      value: function _getItemWidth(colspan) {} // To override

      /**
       Hook to execute layout specific item preparation.
        @param item
       @private
       */
      // eslint-disable-next-line no-unused-vars

    }, {
      key: "_writeItemStyle",
      value: function _writeItemStyle(item) {} // To override

      /**
       Reads the dimension of all items.
        @param items
       @private
       */

    }, {
      key: "_readStyles",
      value: function _readStyles(items) {
        // Record size of items in a separate loop to avoid unneccessary reflows
        for (var i = 0; i < items.length; i++) {
          var item = items[i];
          var layoutData = item._layoutData;
          layoutData.height = Math.round(item.getBoundingClientRect().height);
          layoutData.ignored = layoutData.detached || !item.offsetParent;
        }
      }
      /**
       Update the position of all items.
        @param items
       @private
       */

    }, {
      key: "_positionItems",
      value: function _positionItems(items) {
        var j;

        for (var i = 0; i < items.length; i++) {
          var item = items[i];
          var layoutData = item._layoutData; // Skip ignored items

          if (layoutData.ignored) {
            continue;
          } // Search for column with the least height


          var maxLength = this._columns.length - (layoutData.colspan - 1);
          var minColumnIndex = -1;
          var minColumnHeight = void 0;

          for (j = 0; j < maxLength; j++) {
            // can be negative if set spacing < item css margin
            var columnHeight = this._offsetTop;

            for (var y = 0; y < layoutData.colspan; y++) {
              columnHeight = Math.max(columnHeight, this._columns[j + y].height);
            }

            if (minColumnIndex === -1 || columnHeight < minColumnHeight) {
              minColumnIndex = j;
              minColumnHeight = columnHeight;
            }
          }

          var top = minColumnHeight;
          var left = Math.round(this._getItemLeft(minColumnIndex)); // Check if position has changed

          if (layoutData.left !== left || layoutData.top !== top) {
            layoutData.columnIndex = minColumnIndex;
            layoutData.itemIndex = this._columns[minColumnIndex].items.length;
            layoutData.left = left;
            layoutData.top = top;
            setTransform(item, "translate(".concat(left, "px, ").concat(top, "px)"));
          } // Remember new column height to position all other items


          var newColumnHeight = top + layoutData.height + this._verSpacing;

          for (j = 0; j < layoutData.colspan; j++) {
            var column = this._columns[minColumnIndex + j];
            column.height = newColumnHeight;
            column.items.push(item);
          }
        }
      }
      /**
       @param columnIndex
       @return the left position for the given column index
       @private
       */
      // eslint-disable-next-line no-unused-vars

    }, {
      key: "_getItemLeft",
      value: function _getItemLeft(columnIndex) {} // To override

      /**
       @returns {number} the height of the content (independent of the current gird container height)
       @private
       */

    }, {
      key: "_getContentHeight",
      value: function _getContentHeight() {
        return this._columns.reduce(function (height, column) {
          return Math.max(height, column.height);
        }, 0) - this._offsetTop;
      }
      /**
       Hook which is called after the positioning is done.
        @param contentHeight
       @private
       */
      // eslint-disable-next-line no-unused-vars

    }, {
      key: "_postLayout",
      value: function _postLayout(contentHeight) {} // To override

      /**
       Moves the focus vertically.
        @private
       */

    }, {
      key: "_moveFocusVertically",
      value: function _moveFocusVertically(up, event) {
        var currentLayoutData = event.target._layoutData;

        if (!currentLayoutData) {
          return;
        } // Choose item above or below


        var nextItemIndex = currentLayoutData.itemIndex + (up ? -1 : 1);
        var nextItem = this._columns[currentLayoutData.columnIndex].items[nextItemIndex];

        if (nextItem) {
          nextItem.focus(); // prevent scrolling at the same time

          event.preventDefault();
        } else {
          // in case there is no item in the same column, we should move to first item in next column for down
          // and last item of previous column for up key
          var columnIndex = currentLayoutData.columnIndex;

          if (up) {
            if (columnIndex > 0) {
              // move to last item of previous column
              var prevColumn = this._columns[columnIndex - 1];

              if (prevColumn) {
                nextItem = prevColumn.items[prevColumn.items.length - 1]; // last item of previous column
              }
            }
          } else {
            // down key is pressed, go to first item of next column if exists
            var columnCount = this._columns.length;
            var nextColumnIndex = columnIndex + currentLayoutData.colspan;

            if (nextColumnIndex < columnCount) {
              nextItem = this._columns[nextColumnIndex].items[0]; // first item of next column
            }
          }

          if (nextItem) {
            nextItem.focus();
            event.preventDefault(); // prevent scrolling at the same time
          }
        }
      }
      /**
       Moves the focus horizontally.
        @private
       */

    }, {
      key: "_moveFocusHorizontally",
      value: function _moveFocusHorizontally(left, event) {
        var currentLayoutData = event.target._layoutData;

        if (!currentLayoutData) {
          return;
        }

        var nextItem;

        var items = this._masonry.items.getAll();

        var collectionItemIndex = items.indexOf(event.target);

        if (left) {
          if (collectionItemIndex > 0) {
            nextItem = items[collectionItemIndex - 1];
          }
        } else if (collectionItemIndex < items.length - 1) {
          nextItem = items[collectionItemIndex + 1];
        }

        if (nextItem) {
          nextItem.focus();
          event.preventDefault(); // prevent scrolling at the same time
        }
      }
      /**
       Moves the focus to first or last item based on the visual order.
        @private
       */

    }, {
      key: "_moveFocusHomeEnd",
      value: function _moveFocusHomeEnd(home, event) {
        var currentLayoutData = event.target._layoutData;

        if (!currentLayoutData) {
          return;
        }

        var nextItem;
        var columns = this._columns; // when home is pressed, we take the first item of the first column

        if (home) {
          nextItem = columns[0] && columns[0].items[0];
        } else {
          // when end is pressed, we take the last item of the last column; since some columns are empty, we need to
          // iterate backwards to find the first column that has items
          for (var i = columns.length - 1; i > -1; i--) {
            // since we found a column with items, we take the last item as the next one
            if (columns[i].items.length > 0) {
              nextItem = columns[i].items[columns[i].items.length - 1];
              break;
            }
          }
        }

        if (nextItem) {
          nextItem.focus(); // we prevent the scrolling

          event.preventDefault();
        }
      }
      /** @inheritdoc */

    }, {
      key: "layout",
      value: function layout(secondTry) {
        var masonry = this._masonry;
        var items = masonry.items.getAll();

        if (items.length > 0) {
          // For best possible performance none of these function calls must both read and write attributes in a loop to
          // avoid unnecessary reflows.
          this._init(items);

          this._writeStyles(items);

          this._readStyles(items);

          this._positionItems(items);
        } else {
          this._columns.length = 0;
        } // Update the height of the masonry (otherwise it has a height of 0px due to the absolutely positioned items)


        var contentHeight = this._getContentHeight();

        masonry.style.height = "".concat(contentHeight - this._verSpacing + this._verPadding, "px"); // Check if the masonry has changed its width due to the changed height (can happen because of appearing/disappearing scrollbars)

        if (!secondTry && this._masonryInnerWidth !== masonry.clientWidth) {
          this.layout(true);
        } else {
          // Post layout hook for sub classes
          this._postLayout(contentHeight);
        }
      }
      /** @inheritdoc */

    }, {
      key: "destroy",
      value: function destroy() {
        this._keys.destroy();

        var items = this._masonry.items.getAll();

        for (var i = 0; i < items.length; i++) {
          var item = items[i];
          item._layoutData = undefined;
          setTransform(item, '');

          this._resetItem(item);
        }
      }
      /** @inheritdoc */

    }, {
      key: "detach",
      value: function detach(item) {
        item._layoutData.detached = true;
      }
      /** @inheritdoc */

    }, {
      key: "reattach",
      value: function reattach(item) {
        var layoutData = item._layoutData;
        layoutData.detached = false;
        var rect = item.getBoundingClientRect(); // Disable transition while repositioning

        setTransition(item, 'none');
        item.style.left = '';
        item.style.top = '';
        setTransform(item, '');
        var nullRect = item.getBoundingClientRect();
        layoutData.left = rect.left - nullRect.left;
        layoutData.top = rect.top - nullRect.top;
        setTransform(item, "translate(".concat(layoutData.left, "px, ").concat(layoutData.top, "px)")); // Enforce position

        item.getBoundingClientRect(); // Enable transition again

        setTransition(item, '');
      }
      /** @inheritdoc */

    }, {
      key: "itemAt",
      value: function itemAt(x, y) {
        // TODO it would be more efficient to pick first the right column
        var items = this._masonry.items.getAll();

        for (var i = 0; i < items.length; i++) {
          var item = items[i];
          var layoutData = item._layoutData;

          if (layoutData && !layoutData.ignored && layoutData.left <= x && layoutData.left + layoutData.width >= x && layoutData.top <= y && layoutData.top + layoutData.height >= y) {
            return item;
          }
        }

        return null;
      }
    }]);

    return MasonryColumnLayout;
  }(MasonryLayout);

  /**
   Layout with fixed width centered items. The width of the items is defined with the <code>columnwidth</code>
   attribute.

   @example
   <coral-masonry layout="fixed-centered" columnwidth="300">

   @class Coral.Masonry.FixedCenteredLayout
   @extends {MasonryColumnLayout}
   */

  var MasonryFixedCenteredLayout = /*#__PURE__*/function (_MasonryColumnLayout) {
    _inherits(MasonryFixedCenteredLayout, _MasonryColumnLayout);

    var _super = _createSuper(MasonryFixedCenteredLayout);

    function MasonryFixedCenteredLayout() {
      _classCallCheck(this, MasonryFixedCenteredLayout);

      return _super.apply(this, arguments);
    }

    _createClass(MasonryFixedCenteredLayout, [{
      key: "_writeStyles",

      /** @inheritdoc */
      value: function _writeStyles(items) {
        this._outerColumnWidth = this._columnWidth + this._horSpacing; // If the first row isn't filled, then the items will be centered

        var filledColumns = getFirstRowFilledColumns(this._columns, items);
        this._offsetLeft += (this._masonryAvailableWidth - filledColumns * this._outerColumnWidth) / 2;

        _get(_getPrototypeOf(MasonryFixedCenteredLayout.prototype), "_writeStyles", this).call(this, items);
      }
      /** @inheritdoc */

    }, {
      key: "_getItemWidth",
      value: function _getItemWidth(colspan) {
        return this._columnWidth * colspan + this._horSpacing * (colspan - 1);
      }
      /** @inheritdoc */

    }, {
      key: "_getItemLeft",
      value: function _getItemLeft(columnIndex) {
        return this._offsetLeft + this._outerColumnWidth * columnIndex;
      }
    }]);

    return MasonryFixedCenteredLayout;
  }(MasonryColumnLayout);

  /**
   Layout with fixed width and evenly spread items. The width of the items is defined with the <code>columnwidth</code>
   attribute.

   @example
   <coral-masonry layout="fixed-spread" columnwidth="300">

   @class Coral.Masonry.FixedSpreadLayout
   @extends {MasonryColumnLayout}
   */

  var MasonryFixedSpreadLayout = /*#__PURE__*/function (_MasonryColumnLayout) {
    _inherits(MasonryFixedSpreadLayout, _MasonryColumnLayout);

    var _super = _createSuper(MasonryFixedSpreadLayout);

    function MasonryFixedSpreadLayout() {
      _classCallCheck(this, MasonryFixedSpreadLayout);

      return _super.apply(this, arguments);
    }

    _createClass(MasonryFixedSpreadLayout, [{
      key: "_writeStyles",

      /** @inheritdoc */
      value: function _writeStyles(items) {
        var columns = this._columns; // If the first row is not filled, then the items should be aligned left

        this._alignLeft = getFirstRowFilledColumns(columns, items) < columns.length;

        if (!this._alignLeft) {
          var remainingWidth = this._masonryInnerWidth - this._columnWidth * columns.length;
          this._horSpacing = remainingWidth / (columns.length + 1);
        }

        _get(_getPrototypeOf(MasonryFixedSpreadLayout.prototype), "_writeStyles", this).call(this, items);
      }
      /** @inheritdoc */

    }, {
      key: "_getItemWidth",
      value: function _getItemWidth(colspan) {
        return this._columnWidth * colspan + this._horSpacing * (colspan - 1);
      }
      /** @inheritdoc */

    }, {
      key: "_getItemLeft",
      value: function _getItemLeft(columnIndex) {
        return this._zeroOffsetLeft + this._columnWidth * columnIndex + this._horSpacing * (columnIndex + 1);
      }
    }]);

    return MasonryFixedSpreadLayout;
  }(MasonryColumnLayout);

  /**
   Layout with variable width items. The minimal width of the items is defined with the <code>columnwidth</code>
   attribute.

   @example
   <coral-masonry layout="dashboard" columnwidth="300">

   @class Coral.Masonry.VariableLayout
   @extends {MasonryColumnLayout}
   */

  var MasonryVariableLayout = /*#__PURE__*/function (_MasonryColumnLayout) {
    _inherits(MasonryVariableLayout, _MasonryColumnLayout);

    var _super = _createSuper(MasonryVariableLayout);

    function MasonryVariableLayout() {
      _classCallCheck(this, MasonryVariableLayout);

      return _super.apply(this, arguments);
    }

    _createClass(MasonryVariableLayout, [{
      key: "_getItemWidth",

      /** @inheritdoc */
      value: function _getItemWidth(colspan) {
        return this._masonryAvailableWidth / this._columns.length * colspan - this._horSpacing;
      }
      /** @inheritdoc */

    }, {
      key: "_getItemLeft",
      value: function _getItemLeft(columnIndex) {
        return this._offsetLeft + this._masonryAvailableWidth * columnIndex / this._columns.length;
      }
    }]);

    return MasonryVariableLayout;
  }(MasonryColumnLayout);

  /**
   Layout with variable width items which are expanded in their height to fill gaps (which are common with colspan).
   The minimal width of the items is defined with the <code>columnwidth</code> attribute.

   @example
   <coral-masonry layout="dashboard" columnwidth="300">

   @class Coral.Masonry.DashboardLayout
   @extends {MasonryVariableLayout}
   */

  var MasonryDashboardLayout = /*#__PURE__*/function (_MasonryVariableLayou) {
    _inherits(MasonryDashboardLayout, _MasonryVariableLayou);

    var _super = _createSuper(MasonryDashboardLayout);

    function MasonryDashboardLayout() {
      _classCallCheck(this, MasonryDashboardLayout);

      return _super.apply(this, arguments);
    }

    _createClass(MasonryDashboardLayout, [{
      key: "_writeItemStyle",

      /** @inheritdoc */
      value: function _writeItemStyle(item) {
        // Reset height because otherwise getBoundingClientRect() will not return the real height
        this._resetItem(item);
      }
      /** @inheritdoc */

    }, {
      key: "_postLayout",
      value: function _postLayout(contentHeight) {
        for (var columnIndex = 0; columnIndex < this._columns.length; columnIndex++) {
          var column = this._columns[columnIndex];
          var nextItemTop = contentHeight + this._offsetTop; // Fill gaps by expanding the height of the items

          for (var itemIndex = column.items.length - 1; itemIndex >= 0; itemIndex--) {
            var item = column.items[itemIndex];
            var layoutData = item._layoutData;

            if (layoutData.columnIndex === columnIndex) {
              var expandedHeight = nextItemTop - layoutData.top - this._verSpacing;
              item.style.height = "".concat(expandedHeight, "px");
            }

            nextItemTop = layoutData.top;
          }
        }
      }
      /** @inheritdoc */

    }, {
      key: "_resetItem",
      value: function _resetItem(item) {
        item.style.height = '';
      }
    }]);

    return MasonryDashboardLayout;
  }(MasonryVariableLayout);

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  Masonry.registerLayout(Masonry.layouts.FIXED_CENTERED, MasonryFixedCenteredLayout);
  Masonry.registerLayout(Masonry.layouts.FIXED_SPREAD, MasonryFixedSpreadLayout);
  Masonry.registerLayout(Masonry.layouts.VARIABLE, MasonryVariableLayout);
  Masonry.registerLayout(Masonry.layouts.DASHBOARD, MasonryDashboardLayout); // Expose component on the Coral namespace

  commons._define('coral-masonry-item', MasonryItem);

  commons._define('coral-masonry', Masonry);

  Masonry.Item = MasonryItem;
  Masonry.Layout = MasonryLayout;

  /**
   * Copyright 2020 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var translations$h = {
    "en-US": {
      "({0} of {1})": "({0} of {1})",
      "Remove": "Remove",
      "Reorder": "Reorder",
      "reorder_drag_handle": "move handle",
      "reorder_hint": "Drag and drop or use the up and down arrow keys to reorder."
    },
    "fr-FR": {
      "({0} of {1})": "({0} sur {1})",
      "Remove": "Supprimer",
      "Reorder": "RÃ©organiser",
      "reorder_drag_handle": "dÃ©placer la poignÃ©e",
      "reorder_hint": "RÃ©organisez en utilisant le glisser-dÃ©poser ou les touches flÃ©chÃ©es haut et bas."
    },
    "de-DE": {
      "({0} of {1})": "({0} von {1})",
      "Remove": "Entfernen",
      "Reorder": "Neu sortieren",
      "reorder_drag_handle": "Verschiebepunkt",
      "reorder_hint": "Neu anordnen mit Drag & Drop oder den AufwÃ¤rts- und AbwÃ¤rtspfeiltasten."
    },
    "it-IT": {
      "({0} of {1})": "({0} di {1})",
      "Remove": "Rimuovi",
      "Reorder": "Riordina",
      "reorder_drag_handle": "maniglia di spostamento",
      "reorder_hint": "Trascina e rilascia o usa i tasti freccia su e giÃ¹ per riordinare."
    },
    "es-ES": {
      "({0} of {1})": "({0} de {1})",
      "Remove": "Eliminar",
      "Reorder": "Reordenar",
      "reorder_drag_handle": "mover controlador",
      "reorder_hint": "Arrastre y suelte o use las teclas de flecha arriba y abajo para reordenar."
    },
    "pt-BR": {
      "({0} of {1})": "({0} de {1})",
      "Remove": "Remover",
      "Reorder": "Reorganizar",
      "reorder_drag_handle": "mover a alÃ§a",
      "reorder_hint": "Arraste e solte ou use as teclas de seta para cima e para baixo para reordenar."
    },
    "ja-JP": {
      "({0} of {1})": "({0}/{1})",
      "Remove": "åé¤",
      "Reorder": "ä¸¦ã¹æ¿ã",
      "reorder_drag_handle": "ãã³ãã«ãç§»å",
      "reorder_hint": "ãã©ãã°ã¢ã³ããã­ããããããä¸ä¸ã®ç¢å°ã­ã¼ãä½¿ç¨ãã¦ä¸¦ã¹æ¿ãã¾ãã"
    },
    "ko-KR": {
      "({0} of {1})": "({0}/{1})",
      "Remove": "ì ê±°",
      "Reorder": "ì¬ì ë ¬",
      "reorder_drag_handle": "í¸ë¤ ì´ë",
      "reorder_hint": "ëëê·¸ ì¤ ëë¡­íê±°ë ì / ìë íì´í í¤ë¥¼ ì¬ì©íì¬ ììë¥¼ ë³ê²½íì­ìì¤."
    },
    "zh-CN": {
      "({0} of {1})": "({0}/{1})",
      "Remove": "å é¤",
      "Reorder": "éæ°æåº",
      "reorder_drag_handle": "ç§»å¨ææ¦",
      "reorder_hint": "ææ¾æä½¿ç¨åä¸ååä¸ç®­å¤´é®éæ°æåºã"
    },
    "zh-TW": {
      "({0} of {1})": "({0}/{1})",
      "Remove": "ç§»é¤",
      "Reorder": "éæ°æåº",
      "reorder_drag_handle": "ç§»åæ§å¶é»",
      "reorder_hint": "ææ¾æä½¿ç¨åä¸ååä¸ç®­é ­éµéæ°æåºã"
    },
    "nl-NL": {
      "({0} of {1})": "({0} van {1})",
      "Remove": "Verwijderen",
      "Reorder": "Opnieuw ordenen",
      "reorder_drag_handle": "ingang verplaatsen",
      "reorder_hint": "Sleep en zet neer of gebruik de pijltoetsen omhoog en omlaag om opnieuw te ordenen."
    },
    "da-DK": {
      "({0} of {1})": "({0} af {1})",
      "Remove": "Fjern",
      "Reorder": "Omarranger",
      "reorder_drag_handle": "flyt hÃ¥ndtag",
      "reorder_hint": "TrÃ¦k og slip eller brug piletasterne op og ned til at sortere igen."
    },
    "fi-FI": {
      "({0} of {1})": "({0}/{1})",
      "Remove": "Poista",
      "Reorder": "JÃ¤rjestÃ¤ uudelleen",
      "reorder_drag_handle": "siirtokahva",
      "reorder_hint": "VedÃ¤ ja pudota tai kÃ¤ytÃ¤ ylÃ¤- ja alanuolinÃ¤ppÃ¤imiÃ¤ jÃ¤rjestyksen muuttamiseksi."
    },
    "nb-NO": {
      "({0} of {1})": "({0} av {1})",
      "Remove": "Fjern",
      "Reorder": "Endre rekkefÃ¸lge",
      "reorder_drag_handle": "flytt hÃ¥ndtak",
      "reorder_hint": "Dra og slipp eller bruk piltastene opp og ned for Ã¥ ordne pÃ¥ nytt."
    },
    "sv-SE": {
      "({0} of {1})": "({0} av {1})",
      "Remove": "Ta bort",
      "Reorder": "Ãndra ordning",
      "reorder_drag_handle": "flytta handtag",
      "reorder_hint": "Dra och slÃ¤pp eller anvÃ¤nd upp- och nedpiltangenterna fÃ¶r att ordna om."
    },
    "cs-CZ": {
      "({0} of {1})": "({0} z {1})",
      "Remove": "Odebrat",
      "Reorder": "ZmÄnit poÅadÃ­",
      "reorder_drag_handle": "tÃ¡hlo pÅesunu",
      "reorder_hint": "Chcete-li zmÄnit poÅadÃ­, pÅetÃ¡hnÄte nebo pÅetÃ¡hnÄte nebo pouÅ¾ijte klÃ¡vesy se Å¡ipkami nahoru a dolÅ¯."
    },
    "pl-PL": {
      "({0} of {1})": "({0} z {1})",
      "Remove": "UsuÅ",
      "Reorder": "ZmieÅ kolejnoÅÄ",
      "reorder_drag_handle": "przeciÄgnij uchwyt",
      "reorder_hint": "PrzeciÄgnij i upuÅÄ lub uÅ¼yj klawiszy strzaÅek w gÃ³rÄ iw dÃ³Å, aby zmieniÄ kolejnoÅÄ."
    },
    "ru-RU": {
      "({0} of {1})": ", {0} Ð¸Ð· {1})",
      "Remove": "Ð£Ð´Ð°Ð»Ð¸ÑÑ",
      "Reorder": "ÐÐµÑÐµÑÐ¿Ð¾ÑÑÐ´Ð¾ÑÐ¸ÑÑ",
      "reorder_drag_handle": "Ð¿ÐµÑÐµÐ¼ÐµÑÑÐ¸ÑÑ Ð¼Ð°Ð½Ð¸Ð¿ÑÐ»ÑÑÐ¾Ñ",
      "reorder_hint": "ÐÐµÑÐµÑÐ°ÑÐ¸ÑÐµ Ð¸Ð»Ð¸ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·ÑÐ¹ÑÐµ ÐºÐ»Ð°Ð²Ð¸ÑÐ¸ ÑÐ¾ ÑÑÑÐµÐ»ÐºÐ°Ð¼Ð¸ Ð²Ð²ÐµÑÑ Ð¸ Ð²Ð½Ð¸Ð·, ÑÑÐ¾Ð±Ñ Ð¸Ð·Ð¼ÐµÐ½Ð¸ÑÑ Ð¿Ð¾ÑÑÐ´Ð¾Ðº."
    },
    "tr-TR": {
      "({0} of {1})": "({0}/{1})",
      "Remove": "KaldÄ±r",
      "Reorder": "Yeniden SÄ±rala",
      "reorder_drag_handle": "move handle",
      "reorder_hint": "Yeniden sÄ±ralamak iÃ§in sÃ¼rÃ¼kleyip bÄ±rakÄ±n veya yukarÄ± ve aÅaÄÄ± ok tuÅlarÄ±nÄ± kullanÄ±n."
    }
  };

  var MultifieldCollection = /*#__PURE__*/function (_Collection) {
    _inherits(MultifieldCollection, _Collection);

    var _super = _createSuper(MultifieldCollection);

    function MultifieldCollection() {
      _classCallCheck(this, MultifieldCollection);

      return _super.apply(this, arguments);
    }

    _createClass(MultifieldCollection, [{
      key: "add",
      value: function add(item, insertBefore) {
        // _container and _itemTagName are the minimum options that need to be provided to automatically handle this function
        if (this._container && this._itemTagName) {
          if (!(item instanceof HTMLElement)) {
            // creates an instance of an item from the object
            item = document.createElement(this._itemTagName).set(item);
          }

          if (!insertBefore) {
            insertBefore = this.last();

            if (insertBefore) {
              // Insert before the last item
              insertBefore = insertBefore.nextElementSibling;
            }
          } // inserts the element in the specified container


          this._container.insertBefore(item, insertBefore || this._container.firstChild);

          return item;
        }
      }
    }]);

    return MultifieldCollection;
  }(Collection$1);

  var CLASSNAME$Y = '_coral-Multifield';
  var IS_DRAGGING_CLASS$1 = 'is-dragging';
  var IS_AFTER_CLASS = 'is-after';
  var IS_BEFORE_CLASS = 'is-before';
  var TEMPLATE_SUPPORT = ('content' in document.createElement('template'));
  /**
   @class Coral.Multifield
   @classdesc A Multifield component that enables adding, reordering, and removing multiple instances of a component.
   Multifield partially supports the <code>template</code> element in IE 11. If adding/removing items in the template
   is required, <code>template.content</code> should be used.
   Child elements can be given a special attribute to enable functionality:
   - <code>[coral-multifield-add]</code>. Click to add an item.
   @htmltag coral-multifield
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var Multifield = /*#__PURE__*/function (_BaseComponent) {
    _inherits(Multifield, _BaseComponent);

    var _super = _createSuper(Multifield);

    /** @ignore */
    function Multifield() {
      var _this;

      _classCallCheck(this, Multifield);

      _this = _super.call(this);

      _this.setAttribute('id', _this.id || commons.getUID()); // Attach events


      var events = {
        'coral-dragaction:dragstart coral-multifield-item': '_onDragStart',
        'coral-dragaction:drag coral-multifield-item': '_onDrag',
        'coral-dragaction:dragend coral-multifield-item': '_onDragEnd',
        'click [coral-multifield-add]': '_onAddItemClick',
        'click ._coral-Multifield-remove': '_onRemoveItemClick',
        'click [coral-multifield-move]': '_onClickDragHandle',
        'key:up [coral-multifield-move]': '_onMoveItemUp',
        'key:pageup [coral-multifield-move]': '_onMoveItemUp',
        'key:down [coral-multifield-move]': '_onMoveItemDown',
        'key:pagedown [coral-multifield-move]': '_onMoveItemDown',
        'key:home [coral-multifield-move]': '_onMoveItemHome',
        'key:end [coral-multifield-move]': '_onMoveItemEnd',
        'key:esc [coral-multifield-move]': '_onMoveItemEsc',
        'capture:blur [coral-multifield-move]': '_onBlurDragHandle',
        'change coral-multifield-item-content > input': '_onInputChange'
      };
      events["global:key:escape #".concat(_this.id, " > [coral-multifield-move]")] = '_onMoveItemEsc';

      _this._delegateEvents(events); // Templates


      _this._elements = {
        template: _this.querySelector("#".concat(_this.id, " > template[coral-multifield-template]")) || document.createElement('template')
      };

      _this._elements.template.setAttribute('coral-multifield-template', ''); // In case <template> is not supported


      _this._handleTemplateSupport(_this._elements.template); // Template support: move nodes added to the <template> to its content fragment


      _this._observer = new MutationObserver(function (mutations) {
        mutations.forEach(function (mutation) {
          for (var i = 0; i < mutation.addedNodes.length; i++) {
            var addedNode = mutation.addedNodes[i];
            var template = _this.template;

            if (template.contains(addedNode) && template !== addedNode) {
              // Move the node to the template content
              template.content.appendChild(addedNode); // Update all items content with the template content

              _this.items.getAll().forEach(function (item) {
                _this._renderTemplate(item);
              });

              _this._updatePosInSet();
            }
          }
        });
      }); // Watch for changes to the template element

      _this._observer.observe(_assertThisInitialized(_this), {
        childList: true,
        subtree: true
      }); // Init the collection mutation observer


      _this.items._startHandlingItems(true);

      return _this;
    }
    /**
     The Collection Interface that allows interacting with the Coral.Multifield items that the component contains.
      @type {MultifieldCollection}
     @readonly
     */


    _createClass(Multifield, [{
      key: "_handleTemplateSupport",

      /** @ignore */
      value: function _handleTemplateSupport(template) {
        // @polyfill IE
        if (!TEMPLATE_SUPPORT && !template.content) {
          var frag = document.createDocumentFragment();

          while (template.firstChild) {
            frag.appendChild(template.firstChild);
          }

          template.content = frag;
        }
      }
      /** @ignore */

    }, {
      key: "_onAddItemClick",
      value: function _onAddItemClick(event) {
        var _this2 = this;

        if (event.matchedTarget.closest('coral-multifield') === this) {
          this.items.add(document.createElement('coral-multifield-item')); // Wait for MO to render item template

          window.requestAnimationFrame(function () {
            _this2.trigger('change');

            _this2._trackEvent('click', 'add item button', event);
          });
        }
      }
      /** @ignore */

    }, {
      key: "_onRemoveItemClick",
      value: function _onRemoveItemClick(event) {
        if (event.matchedTarget.closest('coral-multifield') === this) {
          var item = event.matchedTarget.closest('coral-multifield-item');

          if (item) {
            // manage focus when item is removed
            var itemToFocus;
            var items = this.items.getAll();
            var setsize = items.length;

            if (setsize > 1) {
              var itemIndex = items.indexOf(item);

              if (itemIndex === setsize - 1) {
                itemToFocus = items[itemIndex - 1];
              } else {
                itemToFocus = items[itemIndex + 1];
              }
            }

            item.remove();

            if (itemToFocus) {
              itemToFocus._elements.remove.focus();
            } else {
              itemToFocus = this.querySelector('[coral-multifield-add]');

              if (itemToFocus) {
                itemToFocus.focus();
              }
            }
          }

          this.trigger('change');

          this._trackEvent('click', 'remove item button', event);
        }
      }
      /**
       * Toggles keyboard accessible dragging of the current multifield item.
       * @ignore
       */

    }, {
      key: "_toggleItemDragging",
      value: function _toggleItemDragging(multiFieldItem) {
        var dragging = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        if (multiFieldItem._dragging === dragging) {
          return;
        }

        multiFieldItem._dragging = dragging;

        if (dragging) {
          this._oldBefore = multiFieldItem.previousElementSibling;
          this._before = multiFieldItem.nextElementSibling;
        } else {
          this.trigger('coral-multifield:beforeitemorder', {
            item: multiFieldItem,
            oldBefore: this._oldBefore,
            before: this._before
          });
          this.trigger('coral-multifield:itemorder', {
            item: multiFieldItem,
            oldBefore: this._oldBefore,
            before: multiFieldItem.nextElementSibling
          });
          this.trigger('change');
          this._oldBefore = null;
          this._before = null;
        }
      }
      /**
       * Clicking dragHandle toggles keyboard accessible dragging of the current multifield item.
       * @ignore
       */

    }, {
      key: "_onClickDragHandle",
      value: function _onClickDragHandle(event) {
        event.preventDefault();
        event.stopPropagation();
        var multiFieldItem = event.matchedTarget.closest('coral-multifield-item');

        this._toggleItemDragging(multiFieldItem, !multiFieldItem._dragging);
      }
      /**
       * When the drag handle blurs, cancel dragging, leaving item where it is.
       * @ignore
       */

    }, {
      key: "_onBlurDragHandle",
      value: function _onBlurDragHandle(event) {
        var _this3 = this;

        var dragHandle = event.matchedTarget;
        var multiFieldItem = dragHandle.closest('coral-multifield-item');
        commons.nextFrame(function () {
          if (document.activeElement !== dragHandle) {
            _this3._toggleItemDragging(multiFieldItem, false);
          }
        });
      }
      /**
       * Moves multiField item selected for dragging up one index position in the multifield collection.
       * @ignore
       */

    }, {
      key: "_onMoveItemUp",
      value: function _onMoveItemUp(event) {
        var dragHandle = event.matchedTarget;
        var dragElement = dragHandle.closest('coral-multifield-item');

        if (!dragElement._dragging) {
          return;
        }

        event.preventDefault();
        event.stopPropagation();
        var items = this.items.getAll();
        var dragElementIndex = items.indexOf(dragElement);

        if (dragElementIndex > 0) {
          this.insertBefore(dragElement, dragElement.previousElementSibling);
        }

        dragElement._dragging = true;
        dragHandle.focus();
      }
      /**
       * Moves multiField item selected for dragging down one index position in the multifield collection.
       * @ignore
       */

    }, {
      key: "_onMoveItemDown",
      value: function _onMoveItemDown(event) {
        var dragHandle = event.matchedTarget;
        var dragElement = dragHandle.closest('coral-multifield-item');

        if (!dragElement._dragging) {
          return;
        }

        event.preventDefault();
        event.stopPropagation();
        var items = this.items.getAll();
        var dragElementIndex = items.indexOf(dragElement);

        if (dragElementIndex < items.length - 1) {
          var nextElement = dragElement.nextElementSibling;
          this.insertBefore(dragElement, nextElement.nextElementSibling);
        }

        dragElement._dragging = true;
        dragHandle.focus();
      }
      /**
       * Moves multiField item selected for dragging to start of multifield collection.
       * @ignore
       */

    }, {
      key: "_onMoveItemHome",
      value: function _onMoveItemHome(event) {
        var dragHandle = event.matchedTarget;
        var dragElement = dragHandle.closest('coral-multifield-item');

        if (!dragElement._dragging) {
          return;
        }

        event.preventDefault();
        event.stopPropagation();
        var items = this.items.getAll();
        var dragElementIndex = items.indexOf(dragElement);

        if (dragElementIndex > 0) {
          this.insertBefore(dragElement, this.items.first());
        }

        dragElement._dragging = true;
        dragHandle.focus();
      }
      /**
       * Moves multiField item selected for dragging to end of multifield collection.
       * @ignore
       */

    }, {
      key: "_onMoveItemEnd",
      value: function _onMoveItemEnd(event) {
        var dragHandle = event.matchedTarget;
        var dragElement = dragHandle.closest('coral-multifield-item');

        if (!dragElement._dragging) {
          return;
        }

        event.preventDefault();
        event.stopPropagation();
        var items = this.items.getAll();
        var dragElementIndex = items.indexOf(dragElement);

        if (dragElementIndex < items.length - 1) {
          this.insertBefore(dragElement, this.items.last().nextElementSibling);
        }

        dragElement._dragging = true;
        dragHandle.focus();
      }
      /**
       * Cancels keyboard drag and drop operation, restoring item to its previous location.
       * @ignore
       */

    }, {
      key: "_onMoveItemEsc",
      value: function _onMoveItemEsc(event) {
        var dragHandle = event.matchedTarget;
        var multiFieldItem = dragHandle.closest('coral-multifield-item');

        if (multiFieldItem._dragging && this._oldBefore && this._before) {
          event.stopPropagation();
          this.insertBefore(multiFieldItem, this._before);
          dragHandle.focus();
        }

        this._toggleItemDragging(multiFieldItem, false);
      }
    }, {
      key: "_onInputChange",
      value: function _onInputChange(event) {
        this._trackEvent('change', 'input', event);
      }
      /** @ignore */

    }, {
      key: "_onDragStart",
      value: function _onDragStart(event) {
        if (event.target.closest('coral-multifield') === this) {
          document.body.classList.add('u-coral-closedHand');
          var dragElement = event.detail.dragElement;
          var items = this.items.getAll();
          var dragElementIndex = items.indexOf(dragElement); // Toggle dragging state on multifield item.

          dragElement._dragging = true;
          dragElement.classList.add(IS_DRAGGING_CLASS$1);
          items.forEach(function (item, i) {
            if (i < dragElementIndex) {
              item.classList.add(IS_BEFORE_CLASS);
            } else if (i > dragElementIndex) {
              item.classList.add(IS_AFTER_CLASS);
            }
          });
        }
      }
      /** @ignore */

    }, {
      key: "_onDrag",
      value: function _onDrag(event) {
        if (event.target.closest('coral-multifield') === this) {
          var items = this.items.getAll();
          var marginBottom = 0;

          if (items.length) {
            marginBottom = parseFloat(window.getComputedStyle(items[0]).marginBottom);
          }

          items.forEach(function (item) {
            if (!item.classList.contains(IS_DRAGGING_CLASS$1)) {
              var dragElement = event.detail.dragElement;
              var dragElementBoundingClientRect = dragElement.getBoundingClientRect();
              var itemBoundingClientRect = item.getBoundingClientRect();
              var dragElementOffsetTop = dragElementBoundingClientRect.top;
              var itemOffsetTop = itemBoundingClientRect.top;
              var isAfter = dragElementOffsetTop < itemOffsetTop;
              var itemReorderedTop = "".concat(dragElementBoundingClientRect.height + marginBottom, "px");
              item.classList.toggle(IS_AFTER_CLASS, isAfter);
              item.classList.toggle(IS_BEFORE_CLASS, !isAfter);

              if (item.classList.contains(IS_AFTER_CLASS)) {
                item.style.top = items.indexOf(item) < items.indexOf(dragElement) ? itemReorderedTop : '';
              }

              if (item.classList.contains(IS_BEFORE_CLASS)) {
                var afterDragElement = items.indexOf(item) > items.indexOf(dragElement);
                item.style.top = afterDragElement ? "-".concat(itemReorderedTop) : '';
              }
            }
          });
        }
      }
      /** @ignore */

    }, {
      key: "_onDragEnd",
      value: function _onDragEnd(event) {
        if (event.target.closest('coral-multifield') === this) {
          document.body.classList.remove('u-coral-closedHand');
          var dragElement = event.detail.dragElement;
          var items = this.items.getAll();
          var beforeArr = [];
          var afterArr = [];
          items.forEach(function (item) {
            if (item.classList.contains(IS_AFTER_CLASS)) {
              afterArr.push(item);
            } else if (item.classList.contains(IS_BEFORE_CLASS)) {
              beforeArr.push(item);
            }

            item.classList.remove(IS_DRAGGING_CLASS$1, IS_AFTER_CLASS, IS_BEFORE_CLASS);
            item.style.top = '';
            item.style.position = '';
          });
          var oldBefore = dragElement.previousElementSibling;
          var before = afterArr.shift();
          var after = beforeArr.pop();
          var beforeEvent = this.trigger('coral-multifield:beforeitemorder', {
            item: dragElement,
            oldBefore: oldBefore,
            before: before
          });

          if (!beforeEvent.defaultPrevented) {
            if (before) {
              this.insertBefore(dragElement, before);
            }

            if (after) {
              this.insertBefore(dragElement, after.nextElementSibling);
            } // Toggle dragging state on multifield item.


            dragElement._dragging = false;
            this.trigger('coral-multifield:itemorder', {
              item: dragElement,
              oldBefore: oldBefore,
              before: before
            });
            this.trigger('change');

            dragElement._elements.move.focus();
          }
        }
      }
      /** @private */

    }, {
      key: "_onItemAdded",
      value: function _onItemAdded(item) {
        // Update the item content with the template content
        if (item.parentNode === this) {
          this._renderTemplate(item);

          this._updatePosInSet();
        }
      }
    }, {
      key: "_onItemRemoved",
      value: function _onItemRemoved() {
        this._updatePosInSet();
      }
      /**
       * update aria-posinset and aria-setsize for each item in the collection
       * @private
       */

    }, {
      key: "_updatePosInSet",
      value: function _updatePosInSet() {
        var items = this.items.getAll();
        var setsize = items.length;
        items.forEach(function (item, i) {
          item.setAttribute('aria-posinset', i + 1);
          item.setAttribute('aria-setsize', setsize);
          item.setAttribute('aria-label', i18n.get('({0} of {1})', i + 1, setsize)); // so long as item content is not another multifield,
          // add aria-labelledby so that the item is labelled by its content and itself.

          if (!item.querySelector('coral-multifield')) {
            item.setAttribute('aria-labelledby', "".concat(item.id, "-content ").concat(item.id));
          }
        });
      }
      /** @private */

    }, {
      key: "_renderTemplate",
      value: function _renderTemplate(item) {
        var content = item.content || item.querySelector('coral-multifield-item-content') || item; // Insert the template if item content is empty

        if (!content.firstChild) {
          // @polyfill IE
          if (!TEMPLATE_SUPPORT) {
            // Before cloning, put the nested templates content back in the DOM
            var nestedTemplates = this.template.content.querySelectorAll('template[coral-multifield-template]');
            Array.prototype.forEach.call(nestedTemplates, function (template) {
              while (template.content.firstChild) {
                template.appendChild(template.content.firstChild);
              }
            });
          } // Clone the template and append it to the item content


          content.appendChild(document.importNode(this.template.content, true));
        }
      }
    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        var _this4 = this;

        _get(_getPrototypeOf(Multifield.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$Y, 'coral-Well'); // a11y

        this.setAttribute('role', 'list'); // Assign the content zones, moving them into place in the process

        this.template = this._elements.template; // Prepare items content based on the given template

        this.items.getAll().forEach(function (item) {
          _this4._renderTemplate(item);
        }); // update aria-posinset and aria-setsize for each item in the collection

        this._updatePosInSet();
      }
      /**
       Triggered when the {@link Multifield} item are reordered.
        @typedef {CustomEvent} coral-multifield:beforeitemorder
        @property {MultifieldItem} detail.item
       The item to be ordered.
       @property {MultifieldItem} detail.oldBefore
       Ordered item next sibling before the swap. If <code>null</code>, the item was the last item.
       @property {MultifieldItem} detail.before
       Ordered item will be inserted before this sibling item. If <code>null</code>, the item is inserted at the end.
       */

      /**
       Triggered when the {@link Multifield} item are reordered.
        @typedef {CustomEvent} coral-multifield:itemorder
        @property {MultifieldItem} detail.item
       The ordered item.
       @property {MultifieldItem} detail.oldBefore
       Ordered item next sibling before the swap. If <code>null</code>, the item was the last item.
       @property {MultifieldItem} detail.before
       Ordered item was inserted before this sibling item. If <code>null</code>, the item was inserted at the end.
       */

    }, {
      key: "items",
      get: function get() {
        // just init on demand
        if (!this._items) {
          this._items = new MultifieldCollection({
            host: this,
            itemTagName: 'coral-multifield-item',
            // allows multifields to be nested
            itemSelector: ':scope > coral-multifield-item',
            onItemAdded: this._onItemAdded,
            onItemRemoved: this._onItemRemoved
          });
        }

        return this._items;
      }
      /**
       The Multifield template element. It will be used to render a new item once the element with the attribute
       <code>coral-multifield-add</code> is clicked. It supports the <code>template</code> tag. While specifying the
       template from markup, it should include the <code>coral-multifield-template</code> attribute.
       NOTE: On IE11, only <code>template.content</code> is supported to add/remove elements to the template.
        @type {HTMLElement}
       @contentzone
       */

    }, {
      key: "template",
      get: function get() {
        return this._getContentZone(this._elements.template);
      },
      set: function set(value) {
        this._setContentZone('template', value, {
          handle: 'template',
          tagName: 'template',
          insert: function insert(template) {
            this.appendChild(template);
          },
          set: function set(content) {
            // Additionally add support for template
            this._handleTemplateSupport(content);
          }
        });
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          template: 'template'
        };
      }
    }]);

    return Multifield;
  }(BaseComponent(HTMLElement));

  var template$E = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["remove"] = document.createElement("button", "coral-button");
    el0.id = data_0["uid"] + "-remove";
    el0.setAttribute("aria-labelledby", data_0["uid"] + "-remove " + data_0["uid"] + "-content " + data_0["uid"]);
    el0.setAttribute("aria-label", data_0["i18n"]["get"]('Remove'));
    el0.setAttribute("title", data_0["i18n"]["get"]('Remove'));
    el0.setAttribute("tracking", "off");
    el0.setAttribute("type", "button");
    el0.setAttribute("is", "coral-button");
    el0.setAttribute("handle", "remove");
    el0.setAttribute("variant", "quietaction");
    el0.setAttribute("icon", "delete");
    el0.setAttribute("iconsize", "S");
    el0.setAttribute("iconautoarialabel", "on");
    el0.className += " _coral-Multifield-remove";
    el0.setAttribute("coral-multifield-remove", "");
    frag.appendChild(el0);
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    var el2 = this["move"] = document.createElement("button", "coral-button");
    el2.id = data_0["uid"] + "-reorder";
    el2.setAttribute("aria-labelledby", data_0["uid"] + "-reorder " + data_0["uid"] + "-content " + data_0["uid"]);
    el2.setAttribute("aria-label", data_0["i18n"]["get"]('Reorder'));
    el2.setAttribute("aria-roledescription", data_0["i18n"]["get"]('reorder_drag_handle'));
    el2.setAttribute("aria-grabbed", "false");
    el2.setAttribute("aria-pressed", "false");
    el2.setAttribute("title", data_0["i18n"]["get"]('reorder_hint'));
    el2.setAttribute("tracking", "off");
    el2.setAttribute("type", "button");
    el2.setAttribute("is", "coral-button");
    el2.setAttribute("handle", "move");
    el2.setAttribute("variant", "quietaction");
    el2.setAttribute("icon", "moveUpDown");
    el2.setAttribute("iconsize", "S");
    el2.setAttribute("iconautoarialabel", "on");
    el2.className += " _coral-Multifield-move u-coral-openHand";
    el2.setAttribute("coral-multifield-move", "");
    frag.appendChild(el2);
    return frag;
  };

  var CLASSNAME$Z = '_coral-Multifield-item';
  /**
   @class Coral.Multifield.Item
   @classdesc A Multifield item component. It can have a pre-filled content different from the Multifield template but
   added items will always be rendered based on the template.
   @htmltag coral-multifield-item
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var MultifieldItem = /*#__PURE__*/function (_BaseComponent) {
    _inherits(MultifieldItem, _BaseComponent);

    var _super = _createSuper(MultifieldItem);

    /** @ignore */
    function MultifieldItem() {
      var _this;

      _classCallCheck(this, MultifieldItem);

      _this = _super.call(this); // Prepare templates

      _this._elements = {
        // Create or fetch the content zones
        content: _this.querySelector('coral-multifield-item-content') || document.createElement('coral-multifield-item-content')
      };
      var uid = _this.id || commons.getUID();

      _this.setAttribute('id', uid);

      _this._elements.content.setAttribute('id', "".concat(uid, "-content"));

      template$E.call(_this._elements, {
        i18n: i18n,
        uid: uid
      });
      return _this;
    }
    /**
     The item content.
      @type {MultifieldItemContent}
     @contentzone
     */


    _createClass(MultifieldItem, [{
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(MultifieldItem.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$Z); // a11y

        this.setAttribute('role', 'listitem'); // Create a fragment

        var fragment = document.createDocumentFragment();
        var templateHandleNames = ['move', 'remove']; // Render the main template

        fragment.appendChild(this._elements.remove);
        fragment.appendChild(this._elements.move);
        var content = this._elements.content; // Remove it so we can process children

        if (content.parentNode) {
          this.removeChild(content);
        } // Process remaining elements as necessary


        while (this.firstChild) {
          var child = this.firstChild;

          if (child.nodeType === Node.TEXT_NODE || child.nodeType === Node.ELEMENT_NODE && templateHandleNames.indexOf(child.getAttribute('handle')) === -1) {
            // Add non-template elements to the label
            content.appendChild(child);
          } else {
            // Remove anything else
            this.removeChild(child);
          }
        } // Add the frag to the component


        this.appendChild(fragment); // Assign the content zones, moving them into place in the process

        this.content = content; // Attach drag events

        var dragAction = new DragAction(this);
        dragAction.axis = 'vertical';
        dragAction.handle = this._elements.move;
      }
    }, {
      key: "content",
      get: function get() {
        return this._getContentZone(this._elements.content);
      },
      set: function set(value) {
        this._setContentZone('content', value, {
          handle: 'content',
          tagName: 'coral-multifield-item-content',
          insert: function insert(content) {
            // Insert the content zone before the move and remove buttons
            this.insertBefore(content, this.firstChild);
          }
        });
      }
      /**
       Whether the item is set to be reorder using the keyboard
        @type {boolean}
       @private
       */

    }, {
      key: "_dragging",
      get: function get() {
        return this.__dragging || false;
      },
      set: function set(value) {
        this.__dragging = transform.boolean(value);

        if (this.__dragging) {
          // Setting role="application" to the move button forces
          // NVDA and JAWS screen readers into forms mode,
          // so arrow keys can be used to reorder.
          this._elements.move.setAttribute('role', 'application');
        } else {
          // when reordering stops, restore the default role for the move button
          this._elements.move.removeAttribute('role');
        } // aria-grabbed, may be deprecated in WAI-ARIA 1.1, but it is still reported by NVDA as "draggable" or "dragging"


        this._elements.move.setAttribute('aria-grabbed', this.__dragging);

        this._elements.move.setAttribute('aria-pressed', this.__dragging);

        this._elements.move.selected = this.__dragging;
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-multifield-item-content': 'content'
        };
      }
    }]);

    return MultifieldItem;
  }(BaseComponent(HTMLElement));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Multifield.Item.Content
   @classdesc The Multifield item content
   @htmltag coral-multifield-item-content
   @return {HTMLElement}
   */
  var MultifieldItemContent = (function () {
    return document.createElement('coral-multifield-item-content');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons.extend(strings, {
    'coral-component-multifield': translations$h
  }); // Expose component on the Coral namespace

  commons._define('coral-multifield-item', MultifieldItem);

  commons._define('coral-multifield', Multifield);

  Multifield.Item = MultifieldItem;
  Multifield.Item.Content = MultifieldItemContent;

  var CLASSNAME$_ = '_coral-PanelStack';
  /**
   @class Coral.PanelStack
   @classdesc A PanelStack component holding a collection of panels. It wraps content, keeping only the selected panel in view.
   @htmltag coral-panelstack
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var PanelStack = /*#__PURE__*/function (_BaseComponent) {
    _inherits(PanelStack, _BaseComponent);

    var _super = _createSuper(PanelStack);

    /** @ignore */
    function PanelStack() {
      var _this;

      _classCallCheck(this, PanelStack);

      _this = _super.call(this); // Attach events

      _this._delegateEvents({
        // private
        'coral-panel:_selectedchanged': '_onItemSelectedChanged'
      }); // Used for eventing


      _this._oldSelection = null; // Init the collection mutation observer

      _this.items._startHandlingItems(true);

      return _this;
    }
    /**
     The Collection Interface that allows interacting with the items that the component contains.
      @type {SelectableCollection}
     @readonly
     */


    _createClass(PanelStack, [{
      key: "_onItemSelectedChanged",

      /** @private */
      value: function _onItemSelectedChanged(event) {
        event.stopImmediatePropagation();

        this._validateSelection(event.target);
      }
      /** @private */

    }, {
      key: "_validateSelection",
      value: function _validateSelection(item) {
        var _this2 = this;

        var selectedItems = this.items._getAllSelected(); // Last selected item wins if multiple selection while not allowed


        item = item || selectedItems[selectedItems.length - 1];

        if (item && item.hasAttribute('selected') && selectedItems.length > 1) {
          selectedItems.forEach(function (selectedItem) {
            if (selectedItem !== item) {
              // Don't trigger change events
              _this2._preventTriggeringEvents = true;
              selectedItem.removeAttribute('selected');
            }
          }); // We can trigger change events again

          this._preventTriggeringEvents = false;
        }

        this._triggerChangeEvent();
      }
      /** @private */

    }, {
      key: "_triggerChangeEvent",
      value: function _triggerChangeEvent() {
        var selectedItem = this.selectedItem;
        var oldSelection = this._oldSelection;

        if (!this._preventTriggeringEvents && selectedItem !== oldSelection) {
          this.trigger('coral-panelstack:change', {
            oldSelection: oldSelection,
            selection: selectedItem
          });
          this._oldSelection = selectedItem;
        }
      }
      /** @ignore */

    }, {
      key: "render",
      value: function render() {
        _get(_getPrototypeOf(PanelStack.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$_);
        this.setAttribute('role', 'presentation'); // Don't trigger events once connected

        this._preventTriggeringEvents = true;

        this._validateSelection();

        this._preventTriggeringEvents = false;
        this._oldSelection = this.selectedItem;
      }
      /**
       Triggered when {@link PanelStack} selected panel has changed.
        @typedef {CustomEvent} coral-panelstack:change
        @property {Panel} detail.selection
       The new selected panel.
       @property {Panel} detail.oldSelection
       The prior selected panel.
       */

    }, {
      key: "items",
      get: function get() {
        // just init on demand
        if (!this._items) {
          this._items = new SelectableCollection({
            host: this,
            itemTagName: 'coral-panel',
            // allows panels to be nested
            itemSelector: ':scope > coral-panel',
            onItemAdded: this._validateSelection,
            onItemRemoved: this._validateSelection
          });
        }

        return this._items;
      }
      /**
       The selected item of the PanelStack.
        @type {HTMLElement}
       @readonly
       */

    }, {
      key: "selectedItem",
      get: function get() {
        return this.items._getLastSelected();
      }
    }]);

    return PanelStack;
  }(BaseComponent(HTMLElement));

  var CLASSNAME$$ = '_coral-Panel';
  /**
   @class Coral.Panel
   @classdesc A Panel component
   @htmltag coral-panel
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var Panel = /*#__PURE__*/function (_BaseComponent) {
    _inherits(Panel, _BaseComponent);

    var _super = _createSuper(Panel);

    /** @ignore */
    function Panel() {
      var _this;

      _classCallCheck(this, Panel);

      _this = _super.call(this); // Templates

      _this._elements = {
        content: _this.querySelector('coral-panel-content') || document.createElement('coral-panel-content')
      };
      return _this;
    }
    /**
     The content of the panel.
      @type {PanelContent}
     @contentzone
     */


    _createClass(Panel, [{
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(Panel.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$$); // Adds the role to support accessibility when role is not already defined.

        if (!this.hasAttribute('role')) {
          this.setAttribute('role', 'region');
        } // Fetch the content zone elements


        var content = this._elements.content; // Move the content into the content zone if none specified

        if (!content.parentNode) {
          while (this.firstChild) {
            content.appendChild(this.firstChild);
          }
        } // Assign the content zone so the insert function will be called


        this.content = content;
      }
    }, {
      key: "content",
      get: function get() {
        return this._getContentZone(this._elements.content);
      },
      set: function set(value) {
        this._setContentZone('content', value, {
          handle: 'content',
          tagName: 'coral-panel-content',
          insert: function insert(content) {
            this.appendChild(content);
          }
        });
      }
      /**
       Whether the item is selected. When true, the item will appear as the active element in the PanelStack. The item
       must be a child of a PanelStack before this property is set to true. This property cannot be programmatically set
       to false.
        @type {Boolean}
       @default false
       @htmlattribute selected
       @htmlattributereflected
       */

    }, {
      key: "selected",
      get: function get() {
        return this._selected || false;
      },
      set: function set(value) {
        var _selected = transform.booleanAttr(value);

        if (this._selected === _selected) {
          return;
        }

        this._selected = _selected;

        this._reflectAttribute('selected', this._selected);

        this.classList.toggle('is-selected', this._selected);
        this.setAttribute('aria-hidden', !this.selected);
        this.trigger('coral-panel:_selectedchanged');
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-panel-content': 'content'
        };
      }
      /** @ignore */

    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(Panel), "observedAttributes", this).concat(['selected']);
      }
    }]);

    return Panel;
  }(BaseComponent(HTMLElement));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Panel.Content
   @classdesc A PanelStack Item Content component
   @htmltag coral-panel-content
   @return {HTMLElement}
   */
  var PanelContent = (function () {
    return document.createElement('coral-panel-content');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons._define('coral-panelstack', PanelStack);

  commons._define('coral-panel', Panel);

  Panel.Content = PanelContent;

  var template$F = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["percentage"] = document.createElement("div");
    el0.className += " _coral-BarLoader-percentage";
    el0.setAttribute("handle", "percentage");
    el0.setAttribute("aria-hidden", "true");
    el0.setAttribute("style", "visibility: hidden");
    frag.appendChild(el0);
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    var el2 = this["bar"] = document.createElement("div");
    el2.setAttribute("handle", "bar");
    el2.className += " _coral-BarLoader-track";
    var el3 = document.createTextNode("\n  ");
    el2.appendChild(el3);
    var el4 = this["status"] = document.createElement("div");
    el4.className += " _coral-BarLoader-fill";
    el4.setAttribute("handle", "status");
    el2.appendChild(el4);
    var el5 = document.createTextNode("\n");
    el2.appendChild(el5);
    frag.appendChild(el2);
    var el6 = document.createTextNode("\n");
    frag.appendChild(el6);
    return frag;
  };

  /**
   Enumeration for {@link Progress} sizes.

   @typedef {Object} ProgressSizeEnum

   @property {String} SMALL
   A small progress bar.
   @property {String} MEDIUM
   A default medium progress bar.
   @property {String} LARGE
   Not supported. Falls back to MEDIUM.
   */

  var size$6 = {
    SMALL: 'S',
    MEDIUM: 'M',
    LARGE: 'L'
  };
  /**
   Enumeration for {@link Progress} label positions.

   @typedef {Object} ProgressLabelPositionEnum

   @property {String} LEFT
   Show the label to the left of the bar.
   @property {String} SIDE
   Show the label to the side of the bar.
   @property {String} RIGHT
   Not supported. Falls back to LEFT.
   @property {String} BOTTOM
   Not supported. Falls back to LEFT.
   */

  var labelPosition = {
    LEFT: 'left',
    RIGHT: 'right',
    SIDE: 'side',
    BOTTOM: 'bottom'
  }; // Base classname

  var CLASSNAME$10 = '_coral-BarLoader';
  /**
   @class Coral.Progress
   @classdesc A Progress component to indicate progress of processes.
   @htmltag coral-progress
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var Progress = /*#__PURE__*/function (_BaseComponent) {
    _inherits(Progress, _BaseComponent);

    var _super = _createSuper(Progress);

    /** @ignore */
    function Progress() {
      var _this;

      _classCallCheck(this, Progress);

      _this = _super.call(this); // Prepare templates

      _this._elements = {
        // Fetch or create the content content zone element
        label: _this.querySelector('coral-progress-label') || document.createElement('coral-progress-label')
      };
      template$F.call(_this._elements); // Watch for label changes

      _this._observer = new MutationObserver(_this._toggleLabelVisibility.bind(_assertThisInitialized(_this)));

      _this._observer.observe(_this._elements.label, {
        characterData: true,
        childList: true,
        subtree: true
      });

      return _this;
    }
    /**
     The current progress in percent.
      @type {Number}
     @default 0
     @emits {coral-progress:change}
     @htmlattribute value
     @htmlattributereflected
     */


    _createClass(Progress, [{
      key: "_toggleLabelVisibility",

      /** @ignore */
      value: function _toggleLabelVisibility() {
        var percentage = this._elements.percentage;
        var label = this._elements.label;
        var isSidePositioned = this.labelPosition === labelPosition.SIDE; // Handle percentage

        if (this.showPercent) {
          percentage.style.visibility = 'visible';
          percentage.setAttribute('aria-hidden', 'false');

          if (isSidePositioned) {
            percentage.hidden = false;
          }
        } else {
          percentage.style.visibility = 'hidden';
          percentage.setAttribute('aria-hidden', 'true');

          if (isSidePositioned) {
            percentage.hidden = true;
          }
        } // Handle label


        if (label.textContent.length > 0) {
          label.style.visibility = 'visible';
          label.setAttribute('aria-hidden', 'false');

          if (isSidePositioned) {
            label.hidden = false;
          }

          if (!this.showPercent) {
            // Update the value for accessibility as it was cleared when the label was hidden
            this.setAttribute('aria-valuetext', label.textContent);
          }
        } else {
          label.style.visibility = 'hidden';
          label.setAttribute('aria-hidden', 'true');

          if (isSidePositioned) {
            label.hidden = true;
          } // Remove the value for accessibility so the screenreader knows we're unlabelled


          this.removeAttribute('aria-valuetext');
        }
      }
      /** @ignore */

    }, {
      key: "_setPercentage",
      value: function _setPercentage(content) {
        this._elements.percentage.textContent = content; // ARIA

        this[this.showPercent ? 'removeAttribute' : 'setAttribute']('aria-valuetext', content);
      }
    }, {
      key: "attributeChangedCallback",

      /** @ignore */
      value: function attributeChangedCallback(name, oldValue, value) {
        if (name === 'indeterminate' && transform.booleanAttr(value)) {
          // Remember current value in case indeterminate is toggled
          this._oldValue = this._value || 0;
        }

        _get(_getPrototypeOf(Progress.prototype), "attributeChangedCallback", this).call(this, name, oldValue, value);
      }
      /** @ignore */

    }, {
      key: "render",
      value: function render() {
        _get(_getPrototypeOf(Progress.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$10); // Default reflected attributes

        if (!this._value) {
          this.value = this.value;
        }

        if (!this._size) {
          this.size = size$6.MEDIUM;
        }

        if (!this._labelPosition) {
          this.labelPosition = labelPosition.LEFT;
        } // Create a fragment


        var fragment = document.createDocumentFragment();
        var templateHandleNames = ['bar', 'percentage']; // Render the template

        fragment.appendChild(this._elements.percentage);
        fragment.appendChild(this._elements.bar);
        var label = this._elements.label; // Remove it so we can process children

        if (label.parentNode) {
          label.parentNode.removeChild(label);
        } // Move any remaining elements into the content sub-component


        while (this.firstChild) {
          var child = this.firstChild;

          if (child.nodeType === Node.TEXT_NODE || child.nodeType === Node.ELEMENT_NODE && templateHandleNames.indexOf(child.getAttribute('handle')) === -1) {
            // Add non-template elements to the label
            label.appendChild(child);
          } else {
            // Remove anything else
            this.removeChild(child);
          }
        } // Add the frag to the component


        this.appendChild(fragment); // Assign the content zone

        this.label = label; // Toggle label based on content

        this._toggleLabelVisibility(); // ARIA


        this.setAttribute('role', 'progressbar');
        this.setAttribute('aria-valuenow', '0');
        this.setAttribute('aria-valuemin', '0');
        this.setAttribute('aria-valuemax', '100');
      }
      /**
       Triggered when the {@link Progress} value is changed.
        @typedef {CustomEvent} coral-progress:change
       */

    }, {
      key: "value",
      get: function get() {
        return this.indeterminate ? 0 : this._value || 0;
      },
      set: function set(value) {
        value = transform.number(value) || 0; // Stay within bounds

        if (value > 100) {
          value = 100;
        } else if (value < 0) {
          value = 0;
        }

        this._value = value;

        this._reflectAttribute('value', this._value);

        if (!this.indeterminate) {
          this._elements.status.style.width = "".concat(this.value, "%"); // ARIA: Reflect value for screenreaders

          this.setAttribute('aria-valuenow', this._value);

          if (this.showPercent) {
            // Only update label text in percent mode
            this._setPercentage("".concat(this._value, "%"));
          }
        } else {
          this._elements.status.style.width = '';
        }

        this.trigger('coral-progress:change');
      }
      /**
       Whether to hide the current value and show an animation. Set to true for operations whose progress cannot be
       determined.
        @type {Boolean}
       @default false
       @htmlattribute indeterminate
       @htmlattributereflected
       */

    }, {
      key: "indeterminate",
      get: function get() {
        return this._indeterminate || false;
      },
      set: function set(value) {
        this._indeterminate = transform.booleanAttr(value);

        this._reflectAttribute('indeterminate', this._indeterminate);

        if (this._indeterminate) {
          this.classList.add("".concat(CLASSNAME$10, "--indeterminate")); // ARIA: Remove attributes

          this.removeAttribute('aria-valuenow');
          this.removeAttribute('aria-valuemin');
          this.removeAttribute('aria-valuemax');
          this.value = 0;
        } else {
          this.classList.remove("".concat(CLASSNAME$10, "--indeterminate")); // ARIA: Add attributes

          this.setAttribute('aria-valuemin', '0');
          this.setAttribute('aria-valuemax', '100');
          this.value = this._oldValue;
        }
      }
      /**
       The vertical and text size of this progress bar. To adjust the width, simply set the CSS width property.
       See {@link ProgressSizeEnum}.
        @type {String}
       @default ProgressSizeEnum.MEDIUM
       @htmlattribute size
       @htmlattributereflected size
       */

    }, {
      key: "size",
      get: function get() {
        return this._size || size$6.MEDIUM;
      },
      set: function set(value) {
        value = transform.string(value).toUpperCase();
        this._size = validate.enumeration(size$6)(value) && value || size$6.MEDIUM;

        this._reflectAttribute('size', this._size);

        this.classList.toggle("".concat(CLASSNAME$10, "--small"), this._size === size$6.SMALL);
      }
      /**
       Boolean attribute to toggle showing progress percent as the label content.
       Default is true.
        @type {Boolean}
       @default false
       @htmlattribute showpercent
       */

    }, {
      key: "showPercent",
      get: function get() {
        return this._showPercent || false;
      },
      set: function set(value) {
        this._showPercent = transform.booleanAttr(value);

        this._reflectAttribute('showpercent', this._showPercent);

        if (this._showPercent) {
          var content = this.indeterminate ? '' : "".concat(this.value, "%");

          this._setPercentage(content);
        }

        this._toggleLabelVisibility();
      }
      /**
       Used to access to the {@link Coral.Progress.Label} element. Keep in mind that the width of a custom label is
       limited for {@link Coral.Progress.labelPosition.LEFT} and {@link Coral.Progress.labelPosition.RIGHT}.
        @type {ProgressLabel}
       @contentzone
       */

    }, {
      key: "label",
      get: function get() {
        return this._getContentZone(this._elements.label);
      },
      set: function set(value) {
        this._setContentZone('label', value, {
          handle: 'label',
          tagName: 'coral-progress-label',
          insert: function insert(label) {
            label.classList.add("".concat(CLASSNAME$10, "-label"));
            this.appendChild(label);
          }
        });
      }
      /**
       Label position. See {@link ProgressLabelPositionEnum}.
        @type {String}
       @default ProgressLabelPositionEnum.LEFT
       @htmlattribute labelposition
       @htmlattributereflected
       */

    }, {
      key: "labelPosition",
      get: function get() {
        return this._labelPosition || labelPosition.LEFT;
      },
      set: function set(value) {
        var _this2 = this;

        value = transform.string(value).toLowerCase();
        this._labelPosition = validate.enumeration(labelPosition)(value) && value || labelPosition.LEFT;

        this._reflectAttribute('labelposition', this._labelPosition);

        this.classList.toggle('_coral-BarLoader--sideLabel', this._labelPosition === labelPosition.SIDE);
        var elements = this.labelPosition === labelPosition.SIDE ? ['label', 'bar', 'percentage'] : ['label', 'percentage', 'bar']; // @spectrum should be supported with classes

        elements.forEach(function (el, i) {
          _this2._elements[el].style.order = i;
        });

        this._toggleLabelVisibility();
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-progress-label': 'label'
        };
      }
      /**
       Returns {@link Progress} label position options.
        @return {ProgressLabelPositionEnum}
       */

    }], [{
      key: "labelPosition",
      get: function get() {
        return labelPosition;
      }
      /**
       Returns {@link Progress} sizes.
        @return {ProgressSizeEnum}
       */

    }, {
      key: "size",
      get: function get() {
        return size$6;
      }
    }, {
      key: "_attributePropertyMap",
      get: function get() {
        return commons.extend(_get(_getPrototypeOf(Progress), "_attributePropertyMap", this), {
          showpercent: 'showPercent',
          labelposition: 'labelPosition'
        });
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(Progress), "observedAttributes", this).concat(['value', 'indeterminate', 'size', 'showpercent', 'labelposition']);
      }
    }]);

    return Progress;
  }(BaseComponent(HTMLElement));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Progress.Label
   @classdesc The Progress label content
   @htmltag coral-progress-label
   @return {HTMLElement}
   */
  var ProgressLabel = (function () {
    return document.createElement('coral-progress-label');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons._define('coral-progress', Progress);

  Progress.Label = ProgressLabel;

  /**
   Enumeration for {@link QuickActionsItem} type values.

   @typedef {Object} QuickActionsItemTypeEnum

   @property {String} BUTTON
   Default button type
   @property {String} ANCHOR
   Anchor button type
   */

  var type$1 = {
    BUTTON: 'button',
    ANCHOR: 'anchor'
  };
  /**
   @class Coral.QuickActions.Item
   @classdesc A QuickActions item component
   @htmltag coral-quickactions-item
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var QuickActionsItem = /*#__PURE__*/function (_BaseComponent) {
    _inherits(QuickActionsItem, _BaseComponent);

    var _super = _createSuper(QuickActionsItem);

    /** @ignore */
    function QuickActionsItem() {
      var _this;

      _classCallCheck(this, QuickActionsItem);

      _this = _super.call(this); // QuickActions will add button/anchorbutton references to it

      _this._elements = {};
      _this._observer = new MutationObserver(_this._onMutation.bind(_assertThisInitialized(_this)));

      _this._observer.observe(_assertThisInitialized(_this), {
        characterData: true,
        childList: true,
        subtree: true
      });

      return _this;
    } // @compat


    _createClass(QuickActionsItem, [{
      key: "_onMutation",

      /**
       Handles mutations on the Item.
        @emits {coral-quickactions-item:_contentchanged}
        @private
       */
      value: function _onMutation() {
        this.trigger('coral-quickactions-item:_contentchanged');
      }
      /**
       Returns {@link QuickActionsItem} type options.
        @return {QuickActionsItemTypeEnum}
       */

    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(QuickActionsItem.prototype), "render", this).call(this); // Default reflected attributes


        if (!this._type) {
          this.type = type$1.BUTTON;
        }
      }
      /**
       Triggered when an icon of a {@link QuickActionsItem} was changed.
        @typedef {CustomEvent} coral-quickactions-item:_iconchanged
        @private
       */

      /**
       Triggered when the content of a {@link QuickActionsItem} was changed.
        @typedef {CustomEvent} coral-quickactions-item:_contentchanged
        @private
       */

      /**
       Triggered when the href of a {@link QuickActionsItem} was changed.
        @typedef {CustomEvent} coral-quickactions-item:_hrefchanged
        @private
       */

      /**
       Triggered when the type of a {@link QuickActionsItem} was changed.
        @typedef {CustomEvent} coral-quickactions-item:_typechanged
        @private
       */

    }, {
      key: "content",
      get: function get() {
        return this;
      },
      set: function set(value) {
        // Support configs
        if (_typeof(value) === 'object') {
          for (var prop in value) {
            /** @ignore */
            this[prop] = value[prop];
          }
        }
      }
      /**
       When <code>type</code> is {@link Coral.QuickActions.Item.type.ANCHOR}, the href will be used for the anchor.
        @type {String}
       @default ""
       @htmlattribute href
       @htmlattributereflected
       @emits {coral-quickactions-item:_hrefchanged}
       */

    }, {
      key: "href",
      get: function get() {
        return this._href || '';
      },
      set: function set(value) {
        var _href = transform.string(value);

        if (this._href === _href) {
          return;
        }

        this._href = _href;

        this._reflectAttribute('href', this._href);

        this.trigger('coral-quickactions-item:_hrefchanged');
      }
      /**
       Specifies the name of the icon to be shown in the QuickActions Item. See {@link Icon} for valid icon
       names.
        @type {String}
       @default ""
       @htmlattribute icon
       @htmlattributereflected
       @emits {coral-quickactions-item:_iconchanged}
       */

    }, {
      key: "icon",
      get: function get() {
        return this._icon || '';
      },
      set: function set(value) {
        var _icon = transform.string(value);

        if (this._icon === _icon) {
          return;
        }

        this._icon = _icon;

        this._reflectAttribute('icon', this._icon);

        this.trigger('coral-quickactions-item:_iconchanged');
      }
      /**
       The type of item that will be used. Setting {@link QuickActionsItemTypeEnum}.ANCHOR will allow users to
       navigate using the quickactions proving the correct hypermedia to the users.
        @type {String}
       @default QuickActionsItemTypeEnum.BUTTON
       @htmlattribute type
       @htmlattributereflected
       */

    }, {
      key: "type",
      get: function get() {
        return this._type || type$1.BUTTON;
      },
      set: function set(value) {
        var _value = transform.string(value).toLowerCase();

        var _type = validate.enumeration(type$1)(_value) && _value || type$1.BUTTON;

        if (this._type === _type) {
          return;
        }

        this._type = _type;

        this._reflectAttribute('type', this._type);

        this.trigger('coral-quickactions-item:_typechanged');
      }
      /**
       Inherited from {@link BaseComponent#trackingElement}.
       */

    }, {
      key: "trackingElement",
      get: function get() {
        return typeof this._trackingElement === 'undefined' ? // keep spaces to only 1 max and trim. this mimics native html behaviors
        this.textContent && this.textContent.replace(/\s{2,}/g, ' ').trim() || this.icon : this._trackingElement;
      },
      set: function set(value) {
        _set(_getPrototypeOf(QuickActionsItem.prototype), "trackingElement", value, this, true);
      }
    }], [{
      key: "type",
      get: function get() {
        return type$1;
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(QuickActionsItem), "observedAttributes", this).concat(['href', 'icon', 'type']);
      }
    }]);

    return QuickActionsItem;
  }(BaseComponent(HTMLElement));

  var template$G = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["moreButton"] = document.createElement("button", "coral-button");
    el0.setAttribute("tracking", "off");
    el0.className += " _coral-QuickActions-item _coral-QuickActions-item-more";
    el0.setAttribute("variant", "quietaction");
    el0.setAttribute("is", "coral-button");
    el0.setAttribute("type", "button");
    el0.setAttribute("icon", "more");
    el0.setAttribute("iconsize", "S");
    el0.setAttribute("handle", "moreButton");
    el0.setAttribute("title", data_0["i18n"]["get"]('More actions'));
    el0.setAttribute("role", "menuitem");
    el0.setAttribute("aria-haspopup", "menu");
    el0.setAttribute("aria-expanded", "false");
    el0.setAttribute("aria-label", data_0["i18n"]["get"]('More actions'));
    frag.appendChild(el0);
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    var el2 = this["overlay"] = document.createElement("coral-popover");
    el2.className += " _coral-QuickActions-moreOverlay";
    el2.setAttribute("tracking", "off");
    el2.setAttribute("smart", "");
    el2.id = data_0["commons"]["getUID"]();
    el2.setAttribute("breadthoffset", "50%p - 50%");
    el2.setAttribute("placement", "bottom");
    el2.setAttribute("handle", "overlay");
    el2.setAttribute("role", "presentation");
    var el3 = document.createTextNode("\n  ");
    el2.appendChild(el3);
    var el4 = this["buttonList"] = document.createElement("coral-buttonlist");
    el4.setAttribute("tracking", "off");
    el4.id = data_0["commons"]["getUID"]();
    el4.className += " _coral-QuickActions-buttonList";
    el4.setAttribute("handle", "buttonList");
    el4.setAttribute("role", "menu");
    el4.setAttribute("tabindex", "-1");
    el2.appendChild(el4);
    var el5 = document.createTextNode("\n");
    el2.appendChild(el5);
    frag.appendChild(el2);
    var el6 = document.createTextNode("\n");
    frag.appendChild(el6);
    return frag;
  };

  var BUTTON_FOCUSABLE_SELECTOR = '._coral-QuickActions-item:not([disabled]):not([hidden])';
  /**
   Enumeration for {@link QuickActions} interaction options.

   @typedef {Object} QuickActionsInteractionEnum

   @property {String} ON
   Show when the target is hovered or focused and hide when the mouse is moved out or focus is lost.
   @property {String} OFF
   Do not show or hide automatically.
   */

  var interaction$3 = {
    ON: 'on',
    OFF: 'off'
  };
  /**
   Enumeration for {@link QuickActions} anchored overlay target options.

   @typedef {Object} QuickActionsTargetEnum

   @property {String} PARENT
   Use the parent element in the DOM.
   @property {String} PREVIOUS
   Use the previous sibling element in the DOM.
   @property {String} NEXT
   Use the next sibling element in the DOM.
   */

  var target$2 = {
    PARENT: '_parent',
    PREVIOUS: '_prev',
    NEXT: '_next'
  };
  /**
   Enumeration for {@link QuickActions} placement options.

   @typedef {Object} QuickActionsPlacementEnum

   @property {String} TOP
   QuickActions inset to the top of the target.
   @property {String} CENTER
   QuickActions inset to the center of the target.
   @property {String} BOTTOM
   QuickActions inset to the bottom the target.
   */

  var placement$2 = {
    TOP: 'top',
    CENTER: 'center',
    BOTTOM: 'bottom'
  };
  var OFFSET$2 = 10;
  var CLASSNAME$11 = '_coral-QuickActions';
  /**
   @class Coral.QuickActions
   @classdesc A QuickActions component is an overlay component that reveals actions when interacting with a container.
   Hovering the target will display the QuickActions. They can also be launched by pressing the shift + F10 key combination
   when the target is focused.
   @htmltag coral-quickactions
   @extends {Overlay}
   */

  var QuickActions = /*#__PURE__*/function (_Overlay) {
    _inherits(QuickActions, _Overlay);

    var _super = _createSuper(QuickActions);

    /** @ignore */
    function QuickActions() {
      var _this;

      _classCallCheck(this, QuickActions);

      _this = _super.call(this); // Override defaults

      _this._overlayAnimationTime = Overlay.FADETIME;
      _this._alignMy = Overlay.align.CENTER_TOP;
      _this._alignAt = Overlay.align.CENTER_TOP;
      _this._lengthOffset = OFFSET$2;
      _this._inner = true;
      _this._target = target$2.PREVIOUS;
      _this._placement = placement$2.TOP;
      _this._focusOnShow = Overlay.focusOnShow.OFF;
      _this._scrollOnFocus = Overlay.scrollOnFocus.OFF;

      if (!_this.id) {
        _this.id = commons.getUID();
      } // Flag


      _this._openedBefore = false; // Debounce timer

      _this._timeout = null; // Template

      template$G.call(_this._elements, {
        commons: commons,
        i18n: i18n
      });
      var events = {
        'global:resize': '_onWindowResize',
        'mouseout': '_onMouseOut',
        // Keyboard interaction
        'key:home': '_onHomeKeypress',
        'key:end': '_onEndKeypress',
        'key:pagedown': '_onButtonKeypressNext',
        'key:right': '_onButtonKeypressNext',
        'key:down': '_onButtonKeypressNext',
        'key:pageup': '_onButtonKeypressPrevious',
        'key:left': '_onButtonKeypressPrevious',
        'key:up': '_onButtonKeypressPrevious',
        'capture:focus': '_onFocus',
        'capture:blur': '_onBlur',
        // Buttons
        'click > ._coral-QuickActions-item:not([handle="moreButton"])': '_onButtonClick',
        'click > ._coral-QuickActions-item[handle="moreButton"]': '_onMoreButtonClick',
        // Items
        'coral-quickactions-item:_contentchanged': '_onItemChange',
        'coral-quickactions-item:_iconchanged': '_onItemChange',
        'coral-quickactions-item:_hrefchanged': '_onItemChange',
        'coral-quickactions-item:_typechanged': '_onItemTypeChange'
      };
      var overlayId = _this._elements.overlay.id; // Overlay

      events["global:capture:coral-overlay:beforeopen #".concat(overlayId)] = '_onOverlayBeforeOpen';
      events["global:capture:coral-overlay:beforeclose #".concat(overlayId)] = '_onOverlayBeforeClose';
      events["global:capture:coral-overlay:open #".concat(overlayId)] = '_onOverlayOpen';
      events['global:capture:coral-overlay:close'] = '_onOverlayClose';
      events["global:capture:coral-overlay:positioned #".concat(overlayId)] = '_onOverlayPositioned';
      events["global:capture:coral-overlay:_animate #".concat(overlayId)] = '_onAnimate';
      events["global:capture:mouseout #".concat(overlayId)] = '_onMouseOut';
      events["global:capture:click #".concat(overlayId, " [coral-list-item]")] = '_onButtonListItemClick'; // Cache bound event handler functions

      _this._onTargetMouseEnter = _this._onTargetMouseEnter.bind(_assertThisInitialized(_this));
      _this._onTargetKeyUp = _this._onTargetKeyUp.bind(_assertThisInitialized(_this));
      _this._onTargetMouseLeave = _this._onTargetMouseLeave.bind(_assertThisInitialized(_this)); // Events

      _this._delegateEvents(events); // delegates the item handling to the collection


      _this.items._startHandlingItems(true);

      return _this;
    }
    /**
     Returns the inner overlay to allow customization.
      @type {Popover}
     @readonly
     */


    _createClass(QuickActions, [{
      key: "_getButtonWidth",
      value: function _getButtonWidth() {
        if (this.closest('.coral--large')) {
          // 40px button width + 10px left margin
          return 50;
        } else {
          // 32px button width + 8px left margin
          return 40;
        }
      }
      /** @ignore */

    }, {
      key: "_getTarget",
      value: function _getTarget(targetValue) {
        // Use passed target
        targetValue = targetValue || this.target;

        if (targetValue instanceof Node) {
          // Just return the provided Node
          return targetValue;
        } // Dynamically get the target node based on target


        var newTarget = null;

        if (typeof targetValue === 'string') {
          if (targetValue === target$2.PARENT) {
            newTarget = this.parentNode;
          } else {
            // Delegate to Coral.Overlay for _prev, _next and general selector
            newTarget = _get(_getPrototypeOf(QuickActions.prototype), "_getTarget", this).call(this, targetValue);
          }
        }

        return newTarget;
      }
      /** @ignore */

    }, {
      key: "_addTargetEventListeners",
      value: function _addTargetEventListeners(targetElement) {
        targetElement = targetElement || this._getTarget();

        if (!targetElement) {
          return;
        } // Interaction-sensitive listeners


        if (this.interaction === interaction$3.ON) {
          // We do not have to worry about the EventListener being called twice as duplicates are discarded
          targetElement.addEventListener('mouseenter', this._onTargetMouseEnter);
          targetElement.addEventListener('keyup', this._onTargetKeyUp);
          targetElement.addEventListener('keydown', this._onTargetKeyDown);
          targetElement.addEventListener('mouseleave', this._onTargetMouseLeave);
        }
      }
      /** @ignore */

    }, {
      key: "_removeTargetEventListeners",
      value: function _removeTargetEventListeners(targetElement) {
        targetElement = targetElement || this._getTarget();

        if (!targetElement) {
          return;
        }

        targetElement.removeEventListener('mouseenter', this._onTargetMouseEnter);
        targetElement.removeEventListener('keyup', this._onTargetKeyUp);
        targetElement.removeEventListener('keydown', this._onTargetKeyDown);
        targetElement.removeEventListener('mouseleave', this._onTargetMouseLeave);
      }
      /**
       Toggles whether or not an item is tabbable.
        @param {HTMLElement} item
       The item to process.
        @param {Boolean} tabbable
       Whether the item should be marked tabbable.
       @ignore
       */

    }, {
      key: "_toggleTabbable",
      value: function _toggleTabbable(item, tabbable) {
        if (item) {
          if (tabbable) {
            if (item.hasAttribute('tabIndex')) {
              item.removeAttribute('tabIndex');
            }
          } else {
            item.setAttribute('tabIndex', '-1');
          }
        }
      }
      /**
       Gets the subsequent or previous focusable neighbour relative to an Item button.
        @param {HTMLElement} current
       The current button element from which to find the next selectable neighbour.
       @param {Boolean} [previous]
       Whether to look for a previous neighbour rather than a subsequent one.
        @returns {HTMLElement|undefined} The focusable neighbour. Undefined if no suitable neighbour found.
        @private
       */

    }, {
      key: "_getFocusableNeighbour",
      value: function _getFocusableNeighbour(current, previous) {
        // we need to convert the result to an array in order to use .indexOf()
        var focusableButtons = Array.prototype.slice.call(this._getFocusableButtons());
        var index = focusableButtons.indexOf(current);

        if (index >= 0) {
          if (!previous) {
            // Pick the next focusable button
            if (index < focusableButtons.length - 1) {
              return focusableButtons[index + 1];
            }
          } // Pick the previous focusable button
          else if (index !== 0) {
              return focusableButtons[index - 1];
            }
        }
      }
      /**
       Gets the buttons, optionally excluding the more button.
        @param {Boolean} excludeMore
       Whether to exclude the more button.
        @returns {NodeList} The NodeList containing all the buttons.
        @private
       */

    }, {
      key: "_getButtons",
      value: function _getButtons(excludeMore) {
        var buttonSelector = '._coral-QuickActions-item';
        buttonSelector = excludeMore ? "".concat(buttonSelector, ":not([handle=\"moreButton\"])") : buttonSelector;
        return this.querySelectorAll(buttonSelector);
      }
      /**
       An element is focusable if it is visible and not disabled.
        @returns {NodeList} A NodeList containing the focusable buttons.
        @private
       */

    }, {
      key: "_getFocusableButtons",
      value: function _getFocusableButtons() {
        // since we use the hidden attribute to hide the items, we can rely on this attribute to determine if the button
        // is hidden, instead of using a more expensive :focusable selector
        return this.querySelectorAll(BUTTON_FOCUSABLE_SELECTOR);
      }
      /**
       Gets the first focusable button.
        @returns {HTMLElement|undefined}
       The first focusable button, undefined if none found.
       @ignore
       */

    }, {
      key: "_getFirstFocusableButton",
      value: function _getFirstFocusableButton() {
        return this.querySelector(BUTTON_FOCUSABLE_SELECTOR);
      }
      /**
       Gets the last focusable button.
        @returns {HTMLElement|undefined}
       The last focusable button, undefined if none found.
       @ignore
       */

    }, {
      key: "_getLastFocusableButton",
      value: function _getLastFocusableButton() {
        var focusableButtons = this._getFocusableButtons();

        return focusableButtons[focusableButtons.length - 1];
      }
      /** @ignore */

    }, {
      key: "_proxyClick",
      value: function _proxyClick(item) {
        var event = item.trigger('click');

        if (!event.defaultPrevented && this.interaction === interaction$3.ON) {
          this._hideAll();
        }
      }
      /**
       Gets data from an Item.
        @param {HTMLElement} item
       The Item to get the data from.
       @returns {Object}
       The Item data.
       @ignore
       */

    }, {
      key: "_getItemData",
      value: function _getItemData(item) {
        return {
          htmlContent: item.innerHTML,
          textContent: item.textContent,
          // fallback to empty string in case it has no icon
          icon: item.getAttribute('icon') || ''
        };
      }
      /** @ignore */

    }, {
      key: "_attachItem",
      value: function _attachItem(item, index) {
        // since the button has already been initialized we make sure it is up to date
        if (item._elements && item._elements.button) {
          this._updateItem(item);

          return;
        } // if the index was not provided, we need to calculate it


        if (typeof index === 'undefined') {
          index = Array.prototype.indexOf.call(this.items.getAll(), item);
        }

        var itemData = this._getItemData(item);

        var type = QuickActionsItem.type;
        var button;

        if (item.type === type.BUTTON) {
          button = new Button().set({
            icon: itemData.icon,
            iconsize: Icon.size.SMALL,
            type: 'button',
            tracking: 'off'
          }, true);
        } else if (item.type === type.ANCHOR) {
          button = new AnchorButton().set({
            icon: itemData.icon,
            iconsize: Icon.size.SMALL,
            href: item.href,
            tracking: 'off'
          }, true);
        }

        button.variant = Button.variant.QUIET_ACTION;
        button.classList.add('_coral-QuickActions-item');
        button.setAttribute('tabindex', '-1');
        button.setAttribute('title', itemData.textContent.trim());
        button.setAttribute('aria-label', itemData.textContent.trim());
        button.setAttribute('role', 'menuitem');
        this.insertBefore(button, this.children[index]); // ButtonList Item

        var buttonListItem;

        if (item.type === type.BUTTON) {
          buttonListItem = new ButtonList.Item();
        } else if (item.type === type.ANCHOR) {
          buttonListItem = new AnchorList.Item();
          buttonListItem.href = item.href;
        }

        var buttonListItemParent = this._elements.buttonList;
        buttonListItemParent.insertBefore(buttonListItem, buttonListItemParent.children[index]);
        buttonListItem.tabIndex = -1;
        buttonListItem.content.innerHTML = itemData.htmlContent;
        buttonListItem.icon = itemData.icon;
        buttonListItem.setAttribute('role', 'menuitem');
        item._elements.button = button;
        item._elements.buttonListItem = buttonListItem;
        buttonListItem._elements.quickActionsItem = item;
        button._elements.quickActionsItem = item;
      }
      /**
       Layout calculation; collapses QuickActions as necessary.
       */

    }, {
      key: "_layout",
      value: function _layout() {
        // Set the width of the QuickActions to match that of the target
        this._setWidth();

        var buttons = this._getButtons(true);

        if (!buttons.length) {
          return;
        }

        var buttonListItems = this._elements.buttonList.items.getAll(); // Temporarily display the QuickActions so we can do the calculation


        var display = this.style.display;
        var temporarilyShown = false;

        if (!this.open) {
          this.style.left -= 10000;
          this.style.top -= 10000;
          this.style.display = 'block';
          temporarilyShown = true;
        }

        var totalAvailableWidth = this.offsetWidth;
        var totalFittingButtons = 0;
        var widthUsed = 0;

        var buttonWidth = this._getButtonWidth();

        while (totalAvailableWidth > widthUsed) {
          widthUsed += buttonWidth;

          if (totalAvailableWidth > widthUsed) {
            totalFittingButtons++;
          }
        } // Remove one to avoid taking full width space


        totalFittingButtons--;
        var threshold = this.threshold;
        var handleThreshold = threshold > 0;
        var moreButtonsThanThreshold = handleThreshold && buttons.length > threshold;
        var collapse = buttons.length > totalFittingButtons || moreButtonsThanThreshold; // +1 to account for the more button

        var collapseToThreshold = collapse && handleThreshold && threshold + 1 < totalFittingButtons;
        var totalButtons;

        if (collapse) {
          if (collapseToThreshold) {
            totalButtons = threshold + 1;
          } else {
            totalButtons = totalFittingButtons;
          }
        } else {
          totalButtons = buttons.length;
        } // Show all Buttons and ButtonList Items


        for (var i = 0; i < buttons.length; i++) {
          this._toggleTabbable(buttons[i], false);

          buttons[i].hidden = false;

          if (buttonListItems[i]) {
            buttonListItems[i].hidden = false;
          }
        }

        this._toggleTabbable(this._elements.moreButton, false);

        if (collapse) {
          if (totalButtons > 0) {
            // Hide the buttons we're collapsing
            for (var j = totalButtons - 1; j < buttons.length; j++) {
              buttons[j].hide();
            } // Hide the ButtonList items


            for (var k = 0; k < totalButtons - 1; k++) {
              buttonListItems[k].hide();
            } // Mark the first button as tabbable


            this._toggleTabbable(buttons[0], true);
          } else {
            this._toggleTabbable(this._elements.moreButton, true);
          }

          this._elements.moreButton.show();
        } else {
          // Mark the first button as tabbable
          this._toggleTabbable(buttons[0], true);

          this._elements.moreButton.hide();
        }

        this._setWidth(true); // Reset the QuickActions display


        if (temporarilyShown) {
          this.style.left += 10000;
          this.style.top += 10000;
          this.style.display = display;
        } // Do a reposition of the overlay


        this.reposition();
      }
      /**
       Sets the width of QuickActions from the target.
        @ignore
       */

    }, {
      key: "_setWidth",
      value: function _setWidth(buttonWidthBased) {
        var width = 0;

        var targetElement = this._getTarget();

        if (targetElement) {
          var maxWidth = targetElement.offsetWidth;

          if (buttonWidthBased) {
            var visibleButtons = this.querySelectorAll('._coral-QuickActions-item:not([hidden])');

            var buttonWidth = this._getButtonWidth();

            if (visibleButtons.length) {
              for (var i = 0; i < visibleButtons.length && width <= maxWidth; i++) {
                width += buttonWidth;
              }

              this.style.width = "".concat(width, "px");
            }
          } else {
            this.style.width = "".concat(maxWidth, "px");
          }
        }
      }
      /** @ignore */

    }, {
      key: "_setButtonListHeight",
      value: function _setButtonListHeight() {
        // Set height of ButtonList
        this._elements.buttonList.style.height = ''; // Measure actual height

        var style = window.getComputedStyle(this._elements.buttonList);
        var height = parseInt(style.height, 10);
        var maxHeight = parseInt(style.maxHeight, 10);

        if (height < maxHeight) {
          // Make it scrollable
          this._elements.buttonList.style.height = "".concat(height - 1, "px");
        }
      }
      /** @ignore */

    }, {
      key: "_isInternalToComponent",
      value: function _isInternalToComponent(element) {
        var targetElement = this._getTarget();

        return element && (this.contains(element) || this._elements.overlay.contains(element) || targetElement && targetElement.contains(element));
      }
      /** @ignore */

    }, {
      key: "_onWindowResize",
      value: function _onWindowResize() {
        this._layout();
      }
    }, {
      key: "_handleEscape",
      value: function _handleEscape(event) {
        var _this2 = this;

        if (typeof this._isTop === 'undefined') {
          this._isTop = this._isTopOverlay();
        } // Debounce


        if (this._timeout !== null) {
          window.clearTimeout(this._timeout);
        }

        this._timeout = window.setTimeout(function () {
          if (_this2._isTop) {
            _get(_getPrototypeOf(QuickActions.prototype), "_handleEscape", _this2).call(_this2, event);
          }

          _this2._isTop = undefined;
        });
      }
      /** @ignore */

    }, {
      key: "_onMouseOut",
      value: function _onMouseOut(event) {
        var toElement = event.toElement || event.relatedTarget; // Hide if we mouse leave to any element external to the component and its target

        if (!this._isInternalToComponent(toElement) && this.interaction === interaction$3.ON) {
          this._hideAll();
        }
      }
    }, {
      key: "_hideAll",
      value: function _hideAll() {
        this.hide();

        this._elements.overlay.hide();
      }
      /** @ignore */

    }, {
      key: "_onTargetMouseEnter",
      value: function _onTargetMouseEnter(event) {
        var fromElement = event.fromElement || event.relatedTarget; // Open if we aren't already

        if (!this.open && !this._isInternalToComponent(fromElement)) {
          this.show();

          this._trackEvent('display', 'coral-quickactions', event);
        }
      }
      /** @ignore */

    }, {
      key: "_onTargetKeyUp",
      value: function _onTargetKeyUp(event) {
        var keyCode = event.keyCode; // shift + F10 or ctrl + space (http://www.w3.org/WAI/PF/aria-practices/#popupmenu)

        if (event.shiftKey && keyCode === 121 || event.ctrlKey && keyCode === 32) {
          if (!this.open) {
            if (this.interaction === interaction$3.ON) {
              // Launched via keyboard and interaction enabled implies a focus trap and return focus.
              // Remember the relevant properties and return their values on hide.
              this._previousTrapFocus = this.trapFocus;
              this._previousReturnFocus = this.returnFocus;
              this._previousFocusOnShow = this.focusOnShow;
              this.trapFocus = this.constructor.trapFocus.ON;
              this.returnFocus = this.constructor.returnFocus.ON;
              this.focusOnShow = this.constructor.focusOnShow.ON;
            }

            this.show();
          }
        }
      }
    }, {
      key: "_onTargetKeyDown",
      value: function _onTargetKeyDown(event) {
        var keyCode = event.keyCode; // shift + F10 or ctrl + space (http://www.w3.org/WAI/PF/aria-practices/#popupmenu)

        if (event.shiftKey && keyCode === 121 || event.ctrlKey && keyCode === 32) {
          // Prevent default context menu show or page scroll behaviour
          event.preventDefault();
        }
      }
      /** @ignore */

    }, {
      key: "_onTargetMouseLeave",
      value: function _onTargetMouseLeave(event) {
        var toElement = event.toElement || event.relatedTarget; // Do not hide if we entered the quick actions

        if (!this._isInternalToComponent(toElement)) {
          this._hideAll();
        }
      }
      /** @ignore */

    }, {
      key: "_onHomeKeypress",
      value: function _onHomeKeypress(event) {
        // prevents the page from scrolling
        event.preventDefault();

        var firstFocusableButton = this._getFirstFocusableButton(); // Jump focus to the first focusable button


        if (firstFocusableButton) {
          firstFocusableButton.focus();
        }
      }
      /** @ignore */

    }, {
      key: "_onEndKeypress",
      value: function _onEndKeypress(event) {
        // prevents the page from scrolling
        event.preventDefault();

        var lastFocusableButton = this._getLastFocusableButton(); // Jump focus to the last focusable button


        if (lastFocusableButton) {
          lastFocusableButton.focus();
        }
      }
      /** @ignore */

    }, {
      key: "_onButtonKeypressNext",
      value: function _onButtonKeypressNext(event) {
        event.preventDefault();

        if (document.activeElement === this) {
          var firstFocusableButton = this._getFirstFocusableButton();

          if (firstFocusableButton) {
            firstFocusableButton.focus();
          }
        } else {
          // Handle key presses that imply focus of the next focusable button
          var nextButton = this._getFocusableNeighbour(event.matchedTarget);

          if (nextButton) {
            nextButton.focus();
          } else if (event.key === 'ArrowDown' && document.activeElement === this._elements.moreButton) {
            this._elements.moreButton.click();
          }
        }
      }
      /** @ignore */

    }, {
      key: "_onButtonKeypressPrevious",
      value: function _onButtonKeypressPrevious(event) {
        event.preventDefault();

        if (document.activeElement === this) {
          var lastFocusableButton = this._getLastFocusableButton();

          if (lastFocusableButton) {
            lastFocusableButton.focus();
          }
        } else {
          // Handle key presses that imply focus of the previous focusable button
          var previousButton = this._getFocusableNeighbour(event.matchedTarget, true);

          if (previousButton) {
            previousButton.focus();
          }
        }
      }
      /** @ignore */

    }, {
      key: "_onButtonClick",
      value: function _onButtonClick(event) {
        var _this3 = this;

        event.stopPropagation();

        if (this._preventClick) {
          return;
        }

        var button = event.matchedTarget;
        var item = button._elements.quickActionsItem;

        this._proxyClick(item); // Prevent double click or alternate selection during animation


        window.setTimeout(function () {
          _this3._preventClick = false;
        }, this._overlayAnimationTime);
        this._preventClick = true;

        this._trackEvent('click', 'coral-quickactions-item', event, item);
      }
    }, {
      key: "_onMoreButtonClick",
      value: function _onMoreButtonClick(event) {
        var button = event.matchedTarget;
        var item = button._elements.quickActionsItem;

        this._trackEvent('click', 'coral-quickactions-more', event, item);
      }
    }, {
      key: "_onFocus",
      value: function _onFocus() {
        if (this._focusOnShow === this.constructor.focusOnShow.OFF && this._returnFocus !== this.constructor.returnFocus.ON) {
          var targetElement = this._getTarget();

          if (targetElement) {
            if (!this._previousReturnFocus) {
              this._previousReturnFocus = this._returnFocus;
              this.returnFocus = this.constructor.returnFocus.ON;
            }

            if (!this._previousElementToFocusWhenHidden) {
              this._previousElementToFocusWhenHidden = this._elementToFocusWhenHidden;
              this._elementToFocusWhenHidden = targetElement;
            }
          }
        }
      }
    }, {
      key: "_onBlur",
      value: function _onBlur() {
        if (this._focusOnShow === this.constructor.focusOnShow.OFF) {
          if (this._previousReturnFocus) {
            this.returnFocus = this._previousReturnFocus;
            this._previousReturnFocus = undefined;
          }

          if (this._previousElementToFocusWhenHidden) {
            this._elementToFocusWhenHidden = this._previousElementToFocusWhenHidden;
            this._previousElementToFocusWhenHidden = undefined;
          }
        }
      }
      /** @ignore */

    }, {
      key: "_onOverlayBeforeOpen",
      value: function _onOverlayBeforeOpen(event) {
        if (event.target === this) {
          // Reset double-click prevention flag
          this._preventClick = false;

          this._layout();
        } else if (event.target === this._elements.overlay) {
          // do not allow internal Overlay events to escape QuickActions
          event.stopImmediatePropagation();

          this._setButtonListHeight();
        }
      }
      /** @ignore */

    }, {
      key: "_onOverlayBeforeClose",
      value: function _onOverlayBeforeClose(event) {
        if (event.target === this._elements.overlay) {
          // do not allow internal Overlay events to escape QuickActions
          event.stopImmediatePropagation();
        }
      }
      /** @ignore */

    }, {
      key: "_onOverlayOpen",
      value: function _onOverlayOpen(event) {
        if (event.target === this._elements.overlay) {
          // do not allow internal Overlay events to escape QuickActions
          event.stopImmediatePropagation();

          this._elements.moreButton.setAttribute('aria-expanded', 'true');
        }
      }
      /** @ignore */

    }, {
      key: "_onOverlayClose",
      value: function _onOverlayClose(event) {
        var _this4 = this;

        if (event.target === this) {
          this._elements.overlay.open = false; // Return the trapFocus and returnFocus properties to their state before open.
          // Handles the keyboard launch and interaction enabled case, which implies focus trap and focus return.
          // Wait a frame as this is called before the 'open' property sync. Otherwise, returnFocus is set prematurely.

          window.requestAnimationFrame(function () {
            if (_this4._previousTrapFocus) {
              _this4.trapFocus = _this4._previousTrapFocus;

              if (_this4.trapFocus !== _this4.constructor.trapFocus.ON) {
                _this4.removeAttribute('tabindex');
              }

              _this4._previousTrapFocus = undefined;
            }

            if (_this4._previousReturnFocus) {
              _this4.returnFocus = _this4._previousReturnFocus;
              _this4._previousReturnFocus = undefined;
            }

            if (_this4._previousFocusOnShow) {
              _this4.focusOnShow = _this4._previousFocusOnShow;
              _this4._previousFocusOnShow = undefined;
            }
          });
        } else if (event.target === this._elements.overlay) {
          // do not allow internal Overlay events to escape QuickActions
          event.stopImmediatePropagation();

          this._elements.moreButton.setAttribute('aria-expanded', 'false');
        }
      }
      /** @ignore */

    }, {
      key: "_onOverlayPositioned",
      value: function _onOverlayPositioned(event) {
        if (event.target === this._elements.overlay) {
          // do not allow internal Overlay events to escape QuickActions
          event.stopImmediatePropagation();
        }
      }
    }, {
      key: "_onAnimate",
      value: function _onAnimate(event) {
        if (event.target === this) {
          if (this.placement === placement$2.BOTTOM) {
            this.style.marginTop = "".concat(-parseFloat(this.lengthOffset) + 8, "px");
          } else {
            this.style.marginTop = "".concat(parseFloat(this.lengthOffset) - 8, "px");
          }
        }
      }
      /** @ignore */

    }, {
      key: "_onButtonListItemClick",
      value: function _onButtonListItemClick(event) {
        // stops propagation so that this event remains internal to the component
        event.stopImmediatePropagation();
        var buttonListItem = event.matchedTarget;

        if (!buttonListItem) {
          return;
        }

        var item = buttonListItem._elements.quickActionsItem;

        this._proxyClick(item);

        this._trackEvent('click', 'coral-quickactions-item', event, item);
      }
      /** @ignore */

    }, {
      key: "_onItemRemoved",
      value: function _onItemRemoved(item) {
        this._removeItemElements(item);
      }
      /** @ignore */

    }, {
      key: "_onCollectionChange",
      value: function _onCollectionChange(addedNodes) {
        // Delay the item initialization if the component has not been opened before
        if (!this._openedBefore) {
          return;
        } // we use the items to be able to find out the index of the added item in reference to the whole collection


        var items = this.items.getAll();
        var index;

        for (var i = 0, addedNodesCount = addedNodes.length; i < addedNodesCount; i++) {
          // we need to know the item's position in relation to the others
          index = Array.prototype.indexOf.call(items, addedNodes[i]);

          this._attachItem(addedNodes[i], index);
        }

        this._layout();
      }
      /** @ignore */

    }, {
      key: "_onItemChange",
      value: function _onItemChange(event) {
        // stops propagation so that this event remains internal to the component
        event.stopImmediatePropagation();

        this._updateItem(event.target);
      }
      /** @ignore */

    }, {
      key: "_onItemTypeChange",
      value: function _onItemTypeChange(event) {
        // stops propagation so that this event remains internal to the component
        event.stopImmediatePropagation();
        var item = event.target;

        this._removeItemElements(item);

        this._attachItem(item);

        this._layout();
      }
      /** @ignore */

    }, {
      key: "_removeItemElements",
      value: function _removeItemElements(item) {
        // Remove the associated Button and ButtonList elements
        if (item._elements.button) {
          item._elements.button.remove();

          item._elements.button._elements.quickActionsItem = undefined;
          item._elements.button = undefined;
        }

        if (item._elements.buttonListItem) {
          item._elements.buttonListItem.remove();

          item._elements.buttonListItem._elements.quickActionsItem = null;
          item._elements.buttonListItem = undefined;
        }
      }
      /** @ignore */

    }, {
      key: "_updateItem",
      value: function _updateItem(item) {
        var itemData = this._getItemData(item);

        var type = QuickActionsItem.type;
        var button = item._elements.button;

        if (button) {
          button.icon = itemData.icon;
          button.setAttribute('title', itemData.textContent.trim());
          button.setAttribute('aria-label', itemData.textContent.trim());
          button[item.type === type.ANCHOR ? 'setAttribute' : 'removeAttribute']('href', item.href);
        }

        var buttonListItem = item._elements.buttonListItem;

        if (buttonListItem) {
          buttonListItem.content.innerHTML = itemData.htmlContent;
          buttonListItem[item.type === type.ANCHOR ? 'setAttribute' : 'removeAttribute']('href', item.href);
          buttonListItem.icon = itemData.icon;
        }
      } // Maps placement CENTER with RIGHT

    }, {
      key: "_toggleCenterPlacement",
      value: function _toggleCenterPlacement(toggle) {
        if (toggle) {
          if (this.placement === placement$2.CENTER) {
            this._placement = Overlay.placement.RIGHT;
            this._oldInner = this._inner;
            this._inner = false;
            this._oldLengthOffset = this._lengthOffset;
            this._lengthOffset = '-50%r - 50%p';
          }
        } else if (this._placement === Overlay.placement.RIGHT) {
          this._placement = placement$2.CENTER; // Restore

          this._inner = this._oldInner;
          this._lengthOffset = this._oldLengthOffset;
        }
      }
      /** @ignore */

    }, {
      key: "reposition",
      value: function reposition() {
        // Override to support placement.CENTER
        this._toggleCenterPlacement(true);

        _get(_getPrototypeOf(QuickActions.prototype), "reposition", this).call(this);

        this._toggleCenterPlacement(false);

        if (this._openedOnce) {
          // PopperJS inner property issue https://github.com/FezVrasta/popper.js/issues/400
          if (this.placement === placement$2.BOTTOM) {
            this.style.marginTop = "-".concat(parseFloat(this.lengthOffset), "px");
          } else if (this.placement === placement$2.TOP) {
            this.style.marginTop = "".concat(parseFloat(this.lengthOffset), "px");
          } else if (this.placement === placement$2.CENTER) {
            this.style.marginTop = "".concat(parseFloat(this.lengthOffset) - 4, "px");
          }
        }
      } // Override placement and target

      /**
       Returns {@link QuickActions} placement options.
        @return {QuickActionsPlacementEnum}
       */

    }, {
      key: "connectedCallback",

      /** @ignore */
      value: function connectedCallback() {
        _get(_getPrototypeOf(QuickActions.prototype), "connectedCallback", this).call(this);

        var overlay = this._elements.overlay; // Cannot be open by default when rendered

        overlay.removeAttribute('open'); // Restore in DOM

        if (overlay._parent) {
          overlay._parent.appendChild(overlay);
        }
      }
      /** @ignore */

    }, {
      key: "render",
      value: function render() {
        var _this5 = this;

        _get(_getPrototypeOf(QuickActions.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$11); // Define QuickActions as a menu

        this.setAttribute('role', 'menu'); // Support cloneNode

        ['moreButton', 'overlay'].forEach(function (handleName) {
          var handle = _this5.querySelector("[handle=\"".concat(handleName, "\"]"));

          if (handle) {
            handle.remove();
          }
        }); // Render template

        var frag = document.createDocumentFragment();
        frag.appendChild(this._elements.moreButton);
        frag.appendChild(this._elements.overlay); // Link target

        this._elements.overlay.target = this._elements.moreButton;
        this.appendChild(frag);
      }
      /** @ignore */

    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        _get(_getPrototypeOf(QuickActions.prototype), "disconnectedCallback", this).call(this);

        var overlay = this._elements.overlay; // In case it was moved out don't forget to remove it

        if (!this.contains(overlay)) {
          overlay._parent = overlay._repositioned ? document.body : this;
          overlay.remove();
        }
      }
    }, {
      key: "overlay",
      get: function get() {
        return this._elements.overlay;
      }
      /**
       The Item collection.
        @type {Collection}
       @readonly
       */

    }, {
      key: "items",
      get: function get() {
        // we do lazy initialization of the collection
        if (!this._items) {
          this._items = new Collection$1({
            host: this,
            itemTagName: 'coral-quickactions-item',
            onItemRemoved: this._onItemRemoved,
            onCollectionChange: this._onCollectionChange
          });
        }

        return this._items;
      }
      /**
       The number of items that are visible in QuickActions (excluding the show more actions button) before a collapse
       is enforced. A value <= 0 disables this feature and shows as many items as possible. Regardless of this
       property, the QuickActions will still fit within their target's width.
        @type {Number}
       @default 4
       @htmlattribute threshold
       @htmlattributereflected
       */

    }, {
      key: "threshold",
      get: function get() {
        return typeof this._threshold === 'number' ? this._threshold : 4;
      },
      set: function set(value) {
        this._threshold = transform.number(value);

        this._reflectAttribute('threshold', this._threshold);
      }
      /**
       The placement of the QuickActions. The value may be one of 'top', 'center' and 'bottom' and indicates the vertical
       alignment of the QuickActions relative to their container.
       See {@link OverlayPlacementEnum}.
        @type {String}
       @default OverlayPlacementEnum.TOP
       @htmlattribute placement
       */

    }, {
      key: "placement",
      get: function get() {
        return _get(_getPrototypeOf(QuickActions.prototype), "placement", this);
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        this._placement = validate.enumeration(placement$2)(value) && value || placement$2.TOP;
        this.reposition();
      }
      /**
       Whether the QuickActions should show when the target is interacted with. See {@link QuickActionsInteractionEnum}.
        @type {String}
       @default QuickActionsInteractionEnum.ON
       @name interaction
       @htmlattribute interaction
       */

    }, {
      key: "interaction",
      get: function get() {
        return _get(_getPrototypeOf(QuickActions.prototype), "interaction", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(QuickActions.prototype), "interaction", value, this, true);

        if (this.interaction === interaction$3.ON) {
          this._addTargetEventListeners();
        } else {
          this._removeTargetEventListeners();
        }
      }
      /**
       Inherited from {@link Overlay#target}.
       */

    }, {
      key: "target",
      get: function get() {
        return _get(_getPrototypeOf(QuickActions.prototype), "target", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(QuickActions.prototype), "target", value, this, true);

        var targetElement = this._getTarget(value);

        var targetHasChanged = targetElement !== this._previousTarget;

        if (targetElement && targetHasChanged) {
          // Remove listeners from the previous target
          if (this._previousTarget) {
            var previousTarget = this._getTarget(this._previousTarget);

            if (previousTarget) {
              this._removeTargetEventListeners(previousTarget);

              targetElement.removeAttribute('aria-haspopup');
              targetElement.removeAttribute('aria-owns');
            }
          } // Set up listeners for the new target


          this._addTargetEventListeners(); // Mark the target as owning a popup


          targetElement.setAttribute('aria-haspopup', 'true');
          var ariaOwns = targetElement.getAttribute('aria-owns');
          ariaOwns = ariaOwns && ariaOwns.length ? "".concat(ariaOwns.trim(), "  ").concat(this.id) : this.id;
          targetElement.setAttribute('aria-owns', ariaOwns); // Cache for use as previous target

          this._previousTarget = targetElement;
        }
      }
      /**
       Inherited from {@link Overlay#open}.
       */

    }, {
      key: "open",
      get: function get() {
        return _get(_getPrototypeOf(QuickActions.prototype), "open", this);
      },
      set: function set(value) {
        var _this6 = this;

        // If opening and stealing focus, on close, focus should be returned
        // to the element that had focus before QuickActions were opened.
        if (value && this._focusOnShow !== this.constructor.focusOnShow.OFF) {
          this.returnFocusTo(document.activeElement);
        }

        _set(_getPrototypeOf(QuickActions.prototype), "open", value, this, true);

        this._openedOnce = true; // Position once we can read items layout in the next frame

        window.requestAnimationFrame(function () {
          if (_this6.open && !_this6._openedBefore) {
            // we iterate over all the items initializing them in the correct order
            var items = _this6.items.getAll();

            for (var i = 0, itemCount = items.length; i < itemCount; i++) {
              _this6._attachItem(items[i], i);
            }

            _this6._openedBefore = true;
          }

          if (_this6.open) {
            _this6._layout();
          } // we toggle "is-selected" on the target to indicate that the over is open


          var targetElement = _this6._getTarget();

          if (targetElement) {
            targetElement.classList.toggle('is-selected', _this6.open);
          }
        });
      }
    }], [{
      key: "placement",
      get: function get() {
        return placement$2;
      }
      /**
       Returns {@link QuickActions} target options.
        @return {QuickActionsTargetEnum}
       */

    }, {
      key: "target",
      get: function get() {
        return target$2;
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(QuickActions), "observedAttributes", this).concat(['threshold']);
      }
    }]);

    return QuickActions;
  }(Overlay);

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var translations$i = {
    "en-US": {
      "More actions": "More actions"
    },
    "fr-FR": {
      "More actions": "Autres actions"
    },
    "de-DE": {
      "More actions": "Weitere Aktionen"
    },
    "it-IT": {
      "More actions": "Altre azioni"
    },
    "es-ES": {
      "More actions": "MÃ¡s acciones"
    },
    "pt-BR": {
      "More actions": "Mais aÃ§Ãµes"
    },
    "ja-JP": {
      "More actions": "ãã®ä»ã®ã¢ã¯ã·ã§ã³"
    },
    "ko-KR": {
      "More actions": "ì¶ê° ìì"
    },
    "zh-CN": {
      "More actions": "æ´å¤æä½"
    },
    "zh-TW": {
      "More actions": "æ´å¤åä½"
    },
    "nl-NL": {
      "More actions": "Meer acties"
    },
    "da-DK": {
      "More actions": "Flere handlinger"
    },
    "fi-FI": {
      "More actions": "LisÃ¤Ã¤ toimintoja"
    },
    "nb-NO": {
      "More actions": "Flere handlinger"
    },
    "sv-SE": {
      "More actions": "Fler Ã¥tgÃ¤rder"
    },
    "cs-CZ": {
      "More actions": "DalÅ¡Ã­ akce"
    },
    "pl-PL": {
      "More actions": "WiÄcej czynnoÅci"
    },
    "ru-RU": {
      "More actions": "ÐÑÑÐ³Ð¸Ðµ Ð´ÐµÐ¹ÑÑÐ²Ð¸Ñ"
    },
    "tr-TR": {
      "More actions": "Daha fazla iÅlem"
    }
  };

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons.extend(strings, {
    'coral-component-quickactions': translations$i
  }); // Expose component on the Coral namespace

  commons._define('coral-quickactions-item', QuickActionsItem);

  commons._define('coral-quickactions', QuickActions);

  QuickActions.Item = QuickActionsItem;

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var helpTranslations = {
    "en-US": {
      "Search for Help": "Search for Help",
      "Searching Helpâ¦": "Searching Helpâ¦",
      "Error fetching results": "Error fetching results",
      "No results found": "No results found",
      "See all {0} results": "See all {0} results"
    },
    "fr-FR": {
      "Search for Help": "Rechercher de lâaide",
      "Searching Helpâ¦": "Recherche dans lâaideâ¦",
      "Error fetching results": "Erreur lors de la rÃ©cupÃ©ration des rÃ©sultats",
      "No results found": "Aucun rÃ©sultat trouvÃ©",
      "See all {0} results": "Voir les {0} rÃ©sultats"
    },
    "de-DE": {
      "Search for Help": "Nach Hilfe suchen",
      "Searching Helpâ¦": "Suche nach Hilfe â¦",
      "Error fetching results": "Fehler beim Abruf von Ergebnissen",
      "No results found": "Keine Ergebnisse gefunden",
      "See all {0} results": "Alle {0} Ergebnisse anzeigen"
    },
    "it-IT": {
      "Search for Help": "Cerca informazioni nell'Aiuto",
      "Searching Helpâ¦": "Ricerca aiutoâ¦",
      "Error fetching results": "Errore durante il recupero dei risultati",
      "No results found": "Nessun risultato trovato",
      "See all {0} results": "Visualizza tutti i {0} risultati"
    },
    "es-ES": {
      "Search for Help": "Buscar ayuda",
      "Searching Helpâ¦": "Buscando ayudaâ¦",
      "Error fetching results": "Error al obtener los resultados",
      "No results found": "No se han encontrado resultados",
      "See all {0} results": "Ver los {0} resultados"
    },
    "pt-BR": {
      "Search for Help": "Procurar nas seÃ§Ãµes de Ajuda",
      "Searching Helpâ¦": "Procurando ajudaâ¦",
      "Error fetching results": "Erro ao obter resultados",
      "No results found": "Nenhum resultado encontrado",
      "See all {0} results": "Ver todos os resultados de {0}"
    },
    "ja-JP": {
      "Search for Help": "ãã«ããæ¤ç´¢",
      "Searching Helpâ¦": "ãã«ããæ¤ç´¢ä¸­â¦",
      "Error fetching results": "çµæãåå¾ä¸­ã«ã¨ã©ã¼ãçºçãã¾ãã",
      "No results found": "çµæãè¦ã¤ããã¾ããã§ãã",
      "See all {0} results": "ãã¹ã¦ã® {0} çµæãç¢ºèª"
    },
    "ko-KR": {
      "Search for Help": "ëìë§ ê²ì",
      "Searching Helpâ¦": "ëìë§ ê²ì ì¤â¦",
      "Error fetching results": "ê²°ê³¼ë¥¼ ê°ì ¸ì¤ë ì¤ ì¤ë¥ ë°ì",
      "No results found": "ê²°ê³¼ë¥¼ ì°¾ì ì ììµëë¤",
      "See all {0} results": "ì´ {0}ê° ê²°ê³¼ ë³´ê¸°"
    },
    "zh-CN": {
      "Search for Help": "æç´¢å¸®å©",
      "Searching Helpâ¦": "æ­£å¨æç´¢å¸®å©â¦",
      "Error fetching results": "è·åç»ææ¶åºé",
      "No results found": "æ¾ä¸å°ä»»ä½ç»æ",
      "See all {0} results": "æ¥çå¨é¨ {0} ä¸ªç»æ"
    },
    "zh-TW": {
      "Search for Help": "æå°èªªæ",
      "Searching Helpâ¦": "æ­£å¨æå°èªªæâ¦",
      "Error fetching results": "æ·åçµææç¼çé¯èª¤",
      "No results found": "æ¾ä¸å°çµæ",
      "See all {0} results": "æ¥çå¨é¨ {0} åçµæ"
    },
    "nl-NL": {
      "Search for Help": "Zoeken naar hulp",
      "Searching Helpâ¦": "Hulp zoekenâ¦",
      "Error fetching results": "Fout bij ophalen resultaten",
      "No results found": "Geen resultaten gevonden",
      "See all {0} results": "Alle {0} resultaten bekijken"
    },
    "da-DK": {
      "Search for Help": "SÃ¸g efter HjÃ¦lp...",
      "Searching Helpâ¦": "SÃ¸ger i HjÃ¦lp...",
      "Error fetching results": "Fejl ved hentning af resultater",
      "No results found": "Ingen resultater fundet",
      "See all {0} results": "Se alle {0} resultater"
    },
    "fi-FI": {
      "Search for Help": "Hae ohjeita",
      "Searching Helpâ¦": "Haun ohjeâ¦",
      "Error fetching results": "Tuloksia haettaessa tapahtui virhe.",
      "No results found": "Tuloksia ei lÃ¶ytynyt.",
      "See all {0} results": "NÃ¤ytÃ¤ kaikki {0} tulosta"
    },
    "nb-NO": {
      "Search for Help": "SÃ¸k etter hjelp",
      "Searching Helpâ¦": "SÃ¸ker i Hjelp â¦",
      "Error fetching results": "Kan ikke hente resultater",
      "No results found": "Finner ingen resultater",
      "See all {0} results": "Vis alle de {0} resultatene"
    },
    "sv-SE": {
      "Search for Help": "SÃ¶k efter hjÃ¤lp",
      "Searching Helpâ¦": "SÃ¶khjÃ¤lpâ¦",
      "Error fetching results": "Det gick inte att hÃ¤mta resultat",
      "No results found": "Inga resultat funna",
      "See all {0} results": "Se alla {0} resultat"
    },
    "cs-CZ": {
      "Search for Help": "Vyhledat nÃ¡povÄdu",
      "Searching Helpâ¦": "NÃ¡povÄda hledÃ¡nÃ­â¦",
      "Error fetching results": "PÅi shromaÅ¾ÄovÃ¡nÃ­ vÃ½sledkÅ¯ doÅ¡lo k chybÄ",
      "No results found": "Nebyly nalezeny Å¾Ã¡dnÃ© vÃ½sledky",
      "See all {0} results": "Zobrazit vÅ¡echny vÃ½sledky: {0}"
    },
    "pl-PL": {
      "Search for Help": "Szukaj pomocy",
      "Searching Helpâ¦": "Trwa przeszukiwanie Pomocy...",
      "Error fetching results": "BÅÄd pobierania wynikÃ³w",
      "No results found": "Nie znaleziono Å¼adnych wynikÃ³w",
      "See all {0} results": "Zobacz wszystkie {0} wynikÃ³w"
    },
    "ru-RU": {
      "Search for Help": "ÐÐ¾Ð¸ÑÐº ÑÐ¿ÑÐ°Ð²ÐºÐ¸",
      "Searching Helpâ¦": "ÐÐ¾Ð¸ÑÐº Ð¿Ð¾ ÑÐ¿ÑÐ°Ð²ÐºÐµâ¦",
      "Error fetching results": "ÐÑÐ¸Ð±ÐºÐ° Ð¿Ð¾Ð»ÑÑÐµÐ½Ð¸Ñ ÑÐµÐ·ÑÐ»ÑÑÐ°ÑÐ¾Ð²",
      "No results found": "Ð ÐµÐ·ÑÐ»ÑÑÐ°ÑÑ Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½Ñ",
      "See all {0} results": "ÐÐ¾ÑÐ¼Ð¾ÑÑÐµÑÑ Ð²ÑÐµ ÑÐµÐ·ÑÐ»ÑÑÐ°ÑÑ ({0})"
    },
    "tr-TR": {
      "Search for Help": "YardÄ±m Ara",
      "Searching Helpâ¦": "YardÄ±m AranÄ±yor...",
      "Error fetching results": "SonuÃ§lar alÄ±nÄ±rken hata oluÅtu",
      "No results found": "SonuÃ§ bulunamadÄ±",
      "See all {0} results": "TÃ¼m {0} sonuÃ§larÄ±nÄ± gÃ¶r"
    }
  };

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var orgSwitcherTranslations = {
    "en-US": {
      "Search Organizations": "Search Organizations",
      "No organizations found&period;": "No organizations found."
    },
    "fr-FR": {
      "Search Organizations": "Rechercher des organisations",
      "No organizations found&period;": "Aucune organisation trouvÃ©e."
    },
    "de-DE": {
      "Search Organizations": "Organisationen durchsuchen",
      "No organizations found&period;": "Keine Organisationen gefunden."
    },
    "it-IT": {
      "Search Organizations": "Cerca organizzazioni",
      "No organizations found&period;": "Nessuna organizzazione trovata."
    },
    "es-ES": {
      "Search Organizations": "Buscar organizaciones",
      "No organizations found&period;": "No se ha encontrado ninguna organizaciÃ³n."
    },
    "pt-BR": {
      "Search Organizations": "Procurar organizaÃ§Ãµes",
      "No organizations found&period;": "Nenhuma organizaÃ§Ã£o encontrada."
    },
    "ja-JP": {
      "Search Organizations": "çµç¹ãæ¤ç´¢",
      "No organizations found&period;": "çµç¹ãè¦ã¤ããã¾ããã§ããã"
    },
    "ko-KR": {
      "Search Organizations": "ì¡°ì§ ê²ì",
      "No organizations found&period;": "ì¡°ì§ì ì°¾ì ì ììµëë¤."
    },
    "zh-CN": {
      "Search Organizations": "æç´¢ç»ç»",
      "No organizations found&period;": "æ¾ä¸å°ä»»ä½ç»ç»ã"
    },
    "zh-TW": {
      "Search Organizations": "æå°çµç¹",
      "No organizations found&period;": "æ¾ä¸å°çµç¹ã"
    },
    "nl-NL": {
      "Search Organizations": "Organisaties zoeken",
      "No organizations found&period;": "Geen organisaties gevonden."
    },
    "da-DK": {
      "Search Organizations": "SÃ¸g i virksomheder",
      "No organizations found&period;": "Ingen virksomheder fundet."
    },
    "fi-FI": {
      "Search Organizations": "Hae organisaatioita",
      "No organizations found&period;": "Organisaatioita ei lÃ¶ytynyt."
    },
    "nb-NO": {
      "Search Organizations": "SÃ¸k etter organisasjoner",
      "No organizations found&period;": "Finner ingen organisasjoner."
    },
    "sv-SE": {
      "Search Organizations": "SÃ¶korganisationer",
      "No organizations found&period;": "Inga organisationer funna."
    },
    "cs-CZ": {
      "Search Organizations": "Hledat ve spoleÄnostech",
      "No organizations found&period;": "Nebyly nalezeny Å¾Ã¡dnÃ© spoleÄnosti."
    },
    "pl-PL": {
      "Search Organizations": "Wyszukaj organizacje",
      "No organizations found&period;": "Nie znaleziono Å¼adnych organizacji."
    },
    "ru-RU": {
      "Search Organizations": "ÐÑÐºÐ°ÑÑ Ð¾ÑÐ³Ð°Ð½Ð¸Ð·Ð°ÑÐ¸Ð¸",
      "No organizations found&period;": "ÐÑÐ³Ð°Ð½Ð¸Ð·Ð°ÑÐ¸Ð¸ Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½Ñ."
    },
    "tr-TR": {
      "Search Organizations": "KuruluÅlarÄ± ara",
      "No organizations found&period;": "KuruluÅ bulunamadÄ±."
    }
  };

  var CLASSNAME$12 = '_coral-Shell';
  /**
   @class Coral.Shell
   @classdesc The Shell base component to be used with its family for console like applications. See examples for how to
   integrate all Shell sub components.
   @htmltag coral-shell
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var Shell = /*#__PURE__*/function (_BaseComponent) {
    _inherits(Shell, _BaseComponent);

    var _super = _createSuper(Shell);

    /** @ignore */
    function Shell() {
      var _this;

      _classCallCheck(this, Shell);

      _this = _super.call(this); // Prepare templates

      _this._elements = {
        // Fetch or create the content zone elements
        header: _this.querySelector('coral-shell-header') || document.createElement('coral-shell-header'),
        content: _this.querySelector('coral-shell-content') || document.createElement('coral-shell-content')
      };
      return _this;
    }
    /**
     The menu collection.
      @type {Collection}
     @readonly
     */


    _createClass(Shell, [{
      key: "render",

      /** @ignore */
      value: function render() {
        var _this2 = this;

        _get(_getPrototypeOf(Shell.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$12);
        var header = this._elements.header;
        var menus = this.menus.getAll();
        var content = this._elements.content; // If the the content zone is not provided, we need to make sure that it holds all children

        if (!content.parentNode) {
          // Remove header
          if (header.parentNode) {
            header.parentNode.removeChild(header);
          } // Remove menus


          this.menus.clear(); // Move the rest into content

          while (this.firstChild) {
            content.appendChild(this.firstChild);
          }
        } // Call the content zone insert


        this.header = header;
        menus.forEach(function (menu) {
          return _this2.menus.add(menu);
        });
        this.content = content;
      }
    }, {
      key: "menus",
      get: function get() {
        // Construct the collection on first request:
        if (!this._menus) {
          this._menus = new Collection$1({
            host: this,
            itemTagName: 'coral-shell-menu'
          });
        }

        return this._menus;
      }
      /**
       The shell header zone.
        @type {ShellHeader}
       @contentzone
       */

    }, {
      key: "header",
      get: function get() {
        return this._getContentZone(this._elements.header);
      },
      set: function set(value) {
        this._setContentZone('header', value, {
          handle: 'header',
          tagName: 'coral-shell-header',
          insert: function insert(header) {
            this.insertBefore(header, this.firstChild);
          }
        });
      }
      /**
       The shell content zone.
        @type {ShellContent}
       @contentzone
       */

    }, {
      key: "content",
      get: function get() {
        return this._getContentZone(this._elements.content);
      },
      set: function set(value) {
        this._setContentZone('content', value, {
          handle: 'content',
          tagName: 'coral-shell-content',
          insert: function insert(content) {
            this.appendChild(content);
          }
        });
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-shell-header': 'header',
          'coral-shell-content': 'content'
        };
      }
    }]);

    return Shell;
  }(BaseComponent(HTMLElement));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Shell.Content
   @classdesc Shell's content component
   @htmltag coral-shell-content
   @return {HTMLElement}
   */
  var ShellContent = (function () {
    return document.createElement('coral-shell-content');
  });

  var CLASSNAME$13 = '_coral-Shell-header';
  /**
   @class Coral.Shell.Header
   @classdesc A Shell Header component
   @htmltag coral-shell-header
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var ShellHeader = /*#__PURE__*/function (_BaseComponent) {
    _inherits(ShellHeader, _BaseComponent);

    var _super = _createSuper(ShellHeader);

    /** @ignore */
    function ShellHeader() {
      var _this;

      _classCallCheck(this, ShellHeader);

      _this = _super.call(this); // Prepare templates

      _this._elements = {
        // Fetch or create the content zone elements
        home: _this.querySelector('coral-shell-header-home') || document.createElement('coral-shell-header-home'),
        actions: _this.querySelector('coral-shell-header-actions') || document.createElement('coral-shell-header-actions'),
        content: _this.querySelector('coral-shell-header-content') || document.createElement('coral-shell-header-content')
      };

      Overlay._OverlayManager.push(_assertThisInitialized(_this));

      return _this;
    }
    /**
     The label of the panel.
      @type {HTMLElement}
     @contentzone
     */


    _createClass(ShellHeader, [{
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(ShellHeader.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$13); // appheader only exists on darkest theme

        this.classList.add('coral--darkest', 'u-coral-clearFix');
        var home = this._elements.home;
        var actions = this._elements.actions;
        var content = this._elements.content; // Remove them so we can process children

        if (home.parentNode) {
          home.remove();
        }

        if (actions.parentNode) {
          actions.remove();
        }

        if (content.parentNode) {
          content.remove();
        } // moves everything to the main content zone


        while (this.firstChild) {
          content.appendChild(this.firstChild);
        } // // Call the content zone insert


        this.home = home;
        this.actions = actions;
        this.content = content;
      }
    }, {
      key: "home",
      get: function get() {
        return this._getContentZone(this._elements.home);
      },
      set: function set(value) {
        this._setContentZone('home', value, {
          handle: 'home',
          tagName: 'coral-shell-header-home',
          insert: function insert(content) {
            this.appendChild(content);
          }
        });
      }
      /**
       The main content zone of the panel.
        @type {HTMLElement}
       @contentzone
       */

    }, {
      key: "content",
      get: function get() {
        return this._getContentZone(this._elements.content);
      },
      set: function set(value) {
        this._setContentZone('content', value, {
          handle: 'content',
          tagName: 'coral-shell-header-content',
          insert: function insert(content) {
            this.appendChild(content);
          }
        });
      }
      /**
       The content zone where the actions are placed.
        @type {HTMLElement}
       @contentzone
       */

    }, {
      key: "actions",
      get: function get() {
        return this._getContentZone(this._elements.actions);
      },
      set: function set(value) {
        this._setContentZone('actions', value, {
          handle: 'actions',
          tagName: 'coral-shell-header-actions',
          insert: function insert(content) {
            this.appendChild(content);
          }
        });
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-shell-header-home': 'home',
          'coral-shell-header-content': 'content',
          'coral-shell-header-actions': 'actions'
        };
      }
    }]);

    return ShellHeader;
  }(BaseComponent(HTMLElement));

  var template$H = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["icon"] = document.createElement("coral-icon");
    el0.setAttribute("handle", "icon");
    el0.className += " _coral-Shell-homeAnchor-icon";
    el0.setAttribute("size", "M");
    el0.setAttribute("alt", "");
    frag.appendChild(el0);
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    return frag;
  };

  var CLASSNAME$14 = '_coral-Shell-homeAnchor';
  /**
   @class Coral.Shell.HomeAnchor
   @classdesc A Shell Home Anchor component
   @htmltag coral-shell-homeanchor
   @htmlbasetag a
   @extends {HTMLAnchorElement}
   @extends {BaseComponent}
   */

  var ShellHomeAnchor = /*#__PURE__*/function (_BaseComponent) {
    _inherits(ShellHomeAnchor, _BaseComponent);

    var _super = _createSuper(ShellHomeAnchor);

    /** @ignore */
    function ShellHomeAnchor() {
      var _this;

      _classCallCheck(this, ShellHomeAnchor);

      _this = _super.call(this); // Prepare templates

      _this._elements = {
        // Fetch or create the content zone elements
        label: _this.querySelector('coral-shell-homeanchor-label') || document.createElement('coral-shell-homeanchor-label')
      }; // Create icon by default

      template$H.call(_this._elements);
      return _this;
    }
    /**
     The label of the anchor.
      @type {ShellHomeAnchorLabel}
     @contentzone
     */


    _createClass(ShellHomeAnchor, [{
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(ShellHomeAnchor.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$14); // Create doc fragment

        var fragment = document.createDocumentFragment();
        var label = this._elements.label; // Remove it so we can process children

        if (label.parentNode) {
          this.removeChild(label);
        } // Move any remaining elements into the label


        while (this.firstChild) {
          var child = this.firstChild;

          if (child.nodeType === Node.TEXT_NODE) {
            // Move text elements to the label
            label.appendChild(child);
          } else if (child.nodeName === 'CORAL-ICON') {
            if (!fragment.childNodes.length) {
              // Conserve existing icon element to content
              this._elements.icon = child;
              fragment.appendChild(child);
            } else {
              // Remove cloned icon
              this.removeChild(child);
            }
          } else {
            // Remove anything else
            this.removeChild(child);
          }
        } // Add fragment back


        this.appendChild(fragment); // Insert icon and label insert

        this.icon = this.icon;
        this.label = label;
      }
    }, {
      key: "label",
      get: function get() {
        return this._getContentZone(this._elements.label);
      },
      set: function set(value) {
        this._setContentZone('label', value, {
          handle: 'label',
          tagName: 'coral-shell-homeanchor-label',
          insert: function insert(content) {
            this.appendChild(content);
          }
        });
      }
      /**
       Specifies the icon name used in the anchor. See {@link Coral.Icon} for valid icon names.
        @type {String}
       @default ""
       @htmlattribute icon
       */

    }, {
      key: "icon",
      get: function get() {
        return this._elements.icon.icon;
      },
      set: function set(value) {
        this._elements.icon.icon = value; // removes the icon element from the DOM.

        if (this.icon === '') {
          this._elements.icon.remove();
        } // adds the icon back since it was blown away by textContent
        else if (!this.contains(this._elements.icon)) {
            this.insertBefore(this._elements.icon, this.firstChild);
          }
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-shell-homeanchor-label': 'label'
        };
      }
      /** @ignore */

    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(ShellHomeAnchor), "observedAttributes", this).concat(['icon']);
      }
    }]);

    return ShellHomeAnchor;
  }(BaseComponent(HTMLAnchorElement));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Shell.HomeAnchor.Label
   @classdesc Shell HomeAnchor's label component
   @htmltag coral-shell-homeanchor-label
   @return {HTMLElement}
   */
  var ShellHomeAnchorLabel = (function () {
    return document.createElement('coral-shell-homeanchor-label');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var translations$j = {
    "it-IT": {
      "Clear search": "Azzera ricerca"
    },
    "ja-JP": {
      "Clear search": "æ¤ç´¢ãã¯ãªã¢"
    },
    "es-ES": {
      "Clear search": "Borrar bÃºsqueda"
    },
    "ko-KR": {
      "Clear search": "ê²ì ì§ì°ê¸°"
    },
    "zh-CN": {
      "Clear search": "æ¸é¤æç´¢"
    },
    "zh-TW": {
      "Clear search": "æ¸é¤æå°"
    },
    "pt-BR": {
      "Clear search": "Limpar busca"
    },
    "nl-NL": {
      "Clear search": "Zoekopdracht wissen"
    },
    "en-US": {
      "Clear search": "Clear search"
    },
    "de-DE": {
      "Clear search": "Suche lÃ¶schen"
    },
    "fr-FR": {
      "Clear search": "Effacer la recherche"
    },
    "da-DK": {
      "Clear search": "Slet sÃ¸gning"
    },
    "fi-FI": {
      "Clear search": "TyhjennÃ¤ haku"
    },
    "nb-NO": {
      "Clear search": "Fjern sÃ¸k"
    },
    "sv-SE": {
      "Clear search": "Rensa sÃ¶kningen"
    },
    "cs-CZ": {
      "Clear search": "Vymazat hledÃ¡nÃ­"
    },
    "pl-PL": {
      "Clear search": "WyczyÅÄ wyniki wyszukiwania"
    },
    "ru-RU": {
      "Clear search": "ÐÑÐ¸ÑÑÐ¸ÑÑ Ð¿Ð¾Ð¸ÑÐº"
    },
    "tr-TR": {
      "Clear search": "AramayÄ± temizle"
    }
  };

  var template$I = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var data = data_0 = typeof data_0 === "undefined" ? {} : data_0;
    var el0 = this["input"] = document.createElement("input", "coral-textfield");
    el0.setAttribute("type", "search");
    el0.className += " _coral-Search-input";
    el0.setAttribute("is", "coral-textfield");
    el0.setAttribute("handle", "input");
    frag.appendChild(el0);
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    var el2 = this["clearButton"] = document.createElement("button", "coral-button");
    el2.setAttribute("type", "button");
    el2.setAttribute("aria-label", data_0["i18n"]["get"]('Clear search'));
    el2.setAttribute("is", "coral-button");
    el2.setAttribute("variant", "_custom");
    el2.className += " _coral-Search-clear _coral-ClearButton";
    el2.setAttribute("handle", "clearButton");
    var el3 = document.createTextNode("\n  ");
    el2.appendChild(el3);
    var el4 = this["clearButtonLabel"] = document.createElement("coral-button-label");
    el4.setAttribute("handle", "clearButtonLabel");
    el2.appendChild(el4);
    var el5 = document.createTextNode("\n  ");
    el2.appendChild(el5);
    data = data_0; // Don't wait for button MO to pick up the label

    this.clearButton._elements.label = this.clearButtonLabel; // Render icon

    this.clearButton.insertAdjacentHTML('beforeend', data.Icon._renderSVG('spectrum-css-icon-CrossSmall', ['_coral-UIIcon-CrossSmall']));
    data_0 = data;
    var el7 = document.createTextNode("\n");
    el2.appendChild(el7);
    frag.appendChild(el2);
    var el8 = document.createTextNode("\n");
    frag.appendChild(el8);
    return frag;
  };

  var CLASSNAME$15 = '_coral-Search';
  /**
   Enumeration for {@link Search} variants.

   @typedef {Object} SearchVariantEnum

   @property {String} DEFAULT
   A default, gray search input.
   @property {String} QUIET
   A search with no border, no background, no glow.
   */

  var variant$i = {
    DEFAULT: 'default',
    QUIET: 'quiet'
  };
  /**
   @class Coral.Search
   @classdesc A Search component is a search styled form field.
   @htmltag coral-search
   @extends {HTMLElement}
   @extends {BaseComponent}
   @extends {BaseFormField}
   */

  var Search = /*#__PURE__*/function (_BaseFormField) {
    _inherits(Search, _BaseFormField);

    var _super = _createSuper(Search);

    /** @ignore */
    function Search() {
      var _this;

      _classCallCheck(this, Search);

      _this = _super.call(this);

      _this._delegateEvents(commons.extend(_this._events, {
        // @todo use Coral.keys when key combos don't interfere with single key execution
        'keydown [handle=input]': '_onEnterKey',
        'keyup [handle=input]': '_onKeyUp',
        // @todo use coralinternalinput from Autocomplete
        'input [handle=input]': '_triggerInputEvent',
        'key:escape [handle=input]': '_clearInput',
        'click [handle=clearButton]:not(:disabled)': '_clearInput'
      })); // Prepare templates


      _this._elements = {};
      template$I.call(_this._elements, {
        i18n: i18n,
        Icon: Icon
      }); // Pre-define labellable element

      _this._labellableElement = _this._elements.input;
      return _this;
    }
    /**
     Name used to submit the data in a form.
     @type {String}
     @default ""
     @htmlattribute name
     @htmlattributereflected
     */


    _createClass(Search, [{
      key: "_triggerInputEvent",

      /** @ignore */
      value: function _triggerInputEvent() {
        this.trigger('coral-search:input');
      }
      /**
       Handles the up action by steping up the Search. It prevents the default action.
        @ignore
       */

    }, {
      key: "_onEnterKey",
      value: function _onEnterKey(event) {
        if (event.which === 13) {
          event.preventDefault(); // stops interaction if the search is disabled

          if (this.disabled) {
            return;
          }

          this.trigger('coral-search:submit');
        }
      }
      /**
       Handles the keydown action.
        @ignore
       */

    }, {
      key: "_onKeyUp",
      value: function _onKeyUp() {
        this._updateClearButton();
      }
      /**
       Updates the clear button's display status.
        @ignore
       */

    }, {
      key: "_updateClearButton",
      value: function _updateClearButton() {
        this._elements.clearButton.style.display = this._elements.input.value === '' ? 'none' : '';
      }
      /**
       Clears the text in the input box.
        @ignore
       */

    }, {
      key: "_clearInput",
      value: function _clearInput() {
        this._elements.input.value = '';

        this._updateClearButton();

        this._elements.input.focus(); // If we've been cleared, trigger the event


        this.trigger('coral-search:clear');
      } // overrides the behavior from BaseFormField

    }, {
      key: "reset",
      value: function reset() {
        // since there is an internal value, this one handles the reset
        this._elements.input.reset();

        this._updateClearButton();
      } // overrides the behavior from BaseFormField

    }, {
      key: "clear",
      value: function clear() {
        // since there is an internal value, this one handles the clear
        this._elements.input.clear();

        this._updateClearButton();
      }
      /**
       Returns {@link Search} variants.
        @return {SearchVariantEnum}
       */

    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(Search.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$15); // Default reflected attributes

        if (!this._icon) {
          this.icon = 'search';
        }

        if (!this._variant) {
          this.variant = variant$i.DEFAULT;
        } // Support cloneNode


        var templates = this.querySelectorAll('._coral-Search-input, ._coral-Search-icon, ._coral-Search-clear');

        for (var i = 0; i < templates.length; i++) {
          templates[i].remove();
        } // Create a fragment


        var fragment = document.createDocumentFragment(); // Render the main template

        fragment.appendChild(this._elements.input);
        fragment.appendChild(this._elements.clearButton); // Add the frag to the component

        this.appendChild(fragment); // Insert search icon

        this._elements.input.insertAdjacentHTML('afterend', Icon._renderSVG('spectrum-css-icon-Magnifier', ['_coral-Search-icon', '_coral-UIIcon-Magnifier']));

        this._updateClearButton();
      }
      /**
       Triggered when {@link Search} input is given.
        @typedef {CustomEvent} coral-search:input
       */

      /**
       Triggered when the user presses {@link Search} enter.
        @typedef {CustomEvent} coral-search:submit
       */

      /**
       Triggered when the {@link Search} is cleared.
        @typedef {CustomEvent} coral-search:clear
       */

    }, {
      key: "name",
      get: function get() {
        return this._elements.input.name;
      },
      set: function set(value) {
        this._reflectAttribute('name', value);

        this._elements.input.name = value;
      }
      /**
       The submitted input value. Changing this value will not trigger an event.
        @type {String}
       @default ""
       @htmlattribute value
       */

    }, {
      key: "value",
      get: function get() {
        return this._elements.input.value || '';
      },
      set: function set(value) {
        this._elements.input.value = value;

        this._updateClearButton();
      }
      /**
       Whether this field is disabled or not.
       @type {Boolean}
       @default false
       @htmlattribute disabled
       @htmlattributereflected
       */

    }, {
      key: "disabled",
      get: function get() {
        return this._disabled || false;
      },
      set: function set(value) {
        this._disabled = transform.booleanAttr(value);

        this._reflectAttribute('disabled', this._disabled);

        this[this._disabled ? 'setAttribute' : 'removeAttribute']('aria-disabled', this._disabled);
        this.classList.toggle('is-disabled', this._disabled);
        this._elements.input.disabled = this._disabled;
        this._elements.clearButton.disabled = this._disabled;
      }
      /**
       Whether this field is required or not.
       @type {Boolean}
       @default false
       @htmlattribute required
       @htmlattributereflected
       */

    }, {
      key: "required",
      get: function get() {
        return this._required || false;
      },
      set: function set(value) {
        this._required = transform.booleanAttr(value);

        this._reflectAttribute('required', this._required);

        this._elements.input.required = this._required;
      }
      /**
       Whether this field is readOnly or not. Indicating that the user cannot modify the value of the control.
       @type {Boolean}
       @default false
       @htmlattribute readonly
       @htmlattributereflected
       */

    }, {
      key: "readOnly",
      get: function get() {
        return this._readOnly || false;
      },
      set: function set(value) {
        this._readOnly = transform.booleanAttr(value);

        this._reflectAttribute('readonly', this._readOnly);

        this._elements.input.readOnly = this._readOnly;
        this._elements.clearButton.disabled = this._readOnly;
      }
      /**
       Inherited from {@link BaseFormField#labelledBy}.
       */

    }, {
      key: "labelledBy",
      get: function get() {
        return _get(_getPrototypeOf(Search.prototype), "labelledBy", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(Search.prototype), "labelledBy", value, this, true); // in case the user focuses the buttons, he will still get a notion of the usage of the component


        this[this.labelledBy ? 'setAttribute' : 'removeAttribute']('aria-labelledby', this.labelledBy);
      }
      /**
       Short hint that describes the expected value of the Search. It is displayed when the Search is empty.
        @type {String}
       @default ""
       @htmlattribute placeholder
       @htmlattributereflected
       */

    }, {
      key: "placeholder",
      get: function get() {
        return this._elements.input.placeholder || '';
      },
      set: function set(value) {
        value = transform.string(value);

        this._reflectAttribute('placeholder', value);

        this._elements.input.placeholder = value;
      }
      /**
       Max length for the Input field.
       @type {Number}
       @htmlattribute maxlength
       @htmlattributereflected
       */

    }, {
      key: "maxLength",
      get: function get() {
        return this._elements.input.maxLength;
      },
      set: function set(value) {
        this._elements.input.maxLength = value;

        this._reflectAttribute('maxlength', this.maxLength);
      }
      /**
       The search's variant. See {@link SearchVariantEnum}.
        @type {String}
       @default SearchVariantEnum.DEFAULT
       @htmlattribute variant
       @htmlattributereflected
       */

    }, {
      key: "variant",
      get: function get() {
        return this._variant || variant$i.DEFAULT;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        this._variant = validate.enumeration(variant$i)(value) && value || variant$i.DEFAULT;

        this._reflectAttribute('variant', this._variant);

        this._elements.input.variant = value;
      }
      /**
       @ignore
        Not supported anymore.
       */

    }, {
      key: "icon",
      get: function get() {
        return this._icon || 'search';
      },
      set: function set(value) {
        this._icon = transform.string(value);

        this._reflectAttribute('icon', this._icon);
      }
      /**
       Inherited from {@link BaseFormField#invalid}.
       */

    }, {
      key: "invalid",
      get: function get() {
        return _get(_getPrototypeOf(Search.prototype), "invalid", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(Search.prototype), "invalid", value, this, true);
      }
    }], [{
      key: "variant",
      get: function get() {
        return variant$i;
      }
    }, {
      key: "_attributePropertyMap",
      get: function get() {
        return commons.extend(_get(_getPrototypeOf(Search), "_attributePropertyMap", this), {
          maxlength: 'maxLength'
        });
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(Search), "observedAttributes", this).concat(['placeholder', 'icon', 'variant', 'maxlength']);
      }
    }]);

    return Search;
  }(BaseFormField(BaseComponent(HTMLElement)));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons.extend(strings, {
    'coral-component-search': translations$j
  }); // Expose component on the Coral namespace

  commons._define('coral-search', Search);

  var template$J = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var data = data_0 = typeof data_0 === "undefined" ? {} : data_0;
    data = data_0;
    var labelId = data.commons.getUID();
    data_0 = data;
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    var el2 = this["contentWrapper"] = document.createElement("div");
    el2.setAttribute("handle", "contentWrapper");
    var el3 = document.createTextNode("\n  ");
    el2.appendChild(el3);
    var el4 = document.createElement("label");
    el4.className += " u-coral-screenReaderOnly";
    el4.id = labelId;
    el4.textContent = data_0["i18n"]["get"]('Search for Help');
    el2.appendChild(el4);
    var el5 = document.createTextNode("\n  ");
    el2.appendChild(el5);
    var el6 = this["search"] = document.createElement("coral-search");
    el6.className += " _coral-Shell-help-search";
    el6.setAttribute("handle", "search");
    el6.setAttribute("placeholder", data_0["i18n"]["get"]('Search for Help'));
    el6.setAttribute("labelledby", labelId);
    el2.appendChild(el6);
    var el7 = document.createTextNode("\n  ");
    el2.appendChild(el7);
    var el8 = this["items"] = document.createElement("div");
    el8.className += " _coral-Shell-help-items";
    el8.setAttribute("handle", "items");
    el2.appendChild(el8);
    var el9 = document.createTextNode("\n  ");
    el2.appendChild(el9);
    var el10 = this["results"] = document.createElement("coral-anchorlist");
    el10.className += " _coral-Shell-help-results";
    el10.setAttribute("handle", "results");
    el10.setAttribute("hidden", "");
    el2.appendChild(el10);
    var el11 = document.createTextNode("\n  ");
    el2.appendChild(el11);
    var el12 = this["resultMessage"] = document.createElement("div");
    el12.className += " _coral-Shell-help-resultMessage";
    el12.setAttribute("handle", "resultMessage");
    el12.setAttribute("role", "status");
    el12.setAttribute("hidden", "");
    el2.appendChild(el12);
    var el13 = document.createTextNode("\n  ");
    el2.appendChild(el13);
    var el14 = this["loading"] = document.createElement("div");
    el14.className += " _coral-Shell-help-loading";
    el14.setAttribute("handle", "loading");
    el14.setAttribute("role", "status");
    el14.setAttribute("hidden", "");
    var el15 = document.createTextNode("\n    ");
    el14.appendChild(el15);
    var el16 = document.createElement("coral-wait");
    el16.setAttribute("size", "M");
    el16.className += " _coral-Shell-help-loading-wait";
    el14.appendChild(el16);
    var el17 = document.createTextNode("\n    ");
    el14.appendChild(el17);
    var el18 = this["loadingMessage"] = document.createElement("span");
    el18.className += " coral-Heading--2 _coral-Shell-help-loading-info";
    el18.setAttribute("handle", "loadingMessage");
    el18.textContent = data_0["i18n"]["get"]('Searching Helpâ¦');
    el14.appendChild(el18);
    var el19 = document.createTextNode("\n  ");
    el14.appendChild(el19);
    el2.appendChild(el14);
    var el20 = document.createTextNode("\n");
    el2.appendChild(el20);
    frag.appendChild(el2);
    var el21 = document.createTextNode("\n");
    frag.appendChild(el21);
    return frag;
  };

  var template$K = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = document.createElement("coral-list-item-content");
    var el1 = document.createTextNode(data_0["title"] + "\n  ");
    el0.appendChild(el1);
    var el2 = document.createElement("div");
    el2.className += " _coral-Shell-help-result-description";
    el2.textContent = data_0["description"];
    el0.appendChild(el2);
    var el3 = document.createTextNode("\n");
    el0.appendChild(el3);
    frag.appendChild(el0);
    var el4 = document.createTextNode("\n");
    frag.appendChild(el4);
    return frag;
  };

  var template$L = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = document.createElement("div");
    el0.className += " _coral-Shell-help-resultMessage-container";
    var el1 = document.createTextNode("\n  ");
    el0.appendChild(el1);
    var el2 = document.createElement("div");
    el2.className += " coral-Heading--1 _coral-Shell-help-resultMessage-heading";
    el2.textContent = data_0["i18n"]["get"]('Error fetching results');
    el0.appendChild(el2);
    var el3 = document.createTextNode("\n");
    el0.appendChild(el3);
    frag.appendChild(el0);
    var el4 = document.createTextNode("\n");
    frag.appendChild(el4);
    return frag;
  };

  var template$M = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = document.createElement("div");
    el0.className += " _coral-Shell-help-resultMessage-container";
    var el1 = document.createTextNode("\n  ");
    el0.appendChild(el1);
    var el2 = document.createElement("h2");
    el2.className += " coral-heading coral-Heading--2 _coral-Shell-help-resultMessage-heading";
    el2.textContent = data_0["i18n"]["get"]('No results found');
    el0.appendChild(el2);
    frag.appendChild(el0);
    var el3 = document.createTextNode("\n");
    frag.appendChild(el3);
    return frag;
  };

  var CLASSNAMES$2 = ['_coral-Menu', '_coral-AnchorList', '_coral-Shell-help'];
  /**
   @class Coral.Shell.Help
   @classdesc A Shell Help component
   @htmltag coral-shell-help
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var ShellHelp = /*#__PURE__*/function (_BaseComponent) {
    _inherits(ShellHelp, _BaseComponent);

    var _super = _createSuper(ShellHelp);

    /** @ignore */
    function ShellHelp() {
      var _this;

      _classCallCheck(this, ShellHelp);

      _this = _super.call(this); // Prepare templates

      _this._elements = {};
      template$J.call(_this._elements, {
        commons: commons,
        i18n: i18n
      }); // Events

      _this._delegateEvents({
        'coral-search:clear': '_showItems',
        'coral-search:submit': '_performSearch'
      }); // Item handling


      _this.items._startHandlingItems(true);

      return _this;
    }
    /**
     The item collection.
      @type {Collection}
     @readonly
     */


    _createClass(ShellHelp, [{
      key: "_moveItems",

      /** @private */
      value: function _moveItems() {
        var _this2 = this;

        this.setAttribute('id', this.id || commons.getUID());
        var selector = "#".concat(this.id, " > a[is=\"coral-shell-help-item\"], coral-shell-help-separator");
        Array.prototype.forEach.call(this.querySelectorAll(selector), function (item) {
          _this2._elements.items.appendChild(item);
        });
      }
      /** @private */

    }, {
      key: "_performSearch",
      value: function _performSearch(event) {
        event.stopPropagation(); // Show loading

        this._elements.items.hidden = true;

        this._showLoading();

        this._elements.resultMessage.hidden = true;
        this._elements.results.hidden = true; // Trigger event

        var searchTerm = this._elements.search.value;
        this.trigger('coral-shell-help:search', {
          value: searchTerm
        });
      }
      /** @private */

    }, {
      key: "_showItems",
      value: function _showItems(event) {
        event.stopPropagation(); // Hide search results

        this._elements.results.hidden = true; // Hide loading

        this._hideLoading(); // Hide no-results


        this._elements.resultMessage.hidden = true; // Show items

        this._elements.items.hidden = false;
      }
      /** @private */

    }, {
      key: "_clearTimeout",
      value: function _clearTimeout(timeoutName) {
        if (this[timeoutName]) {
          window.clearTimeout(this[timeoutName]);
          this[timeoutName] = undefined;
        }
      }
      /** @private */

    }, {
      key: "_showMessage",
      value: function _showMessage(elementName, message) {
        var el = this._elements[elementName];
        var timeoutName = "_".concat(elementName, "Timeout"); // Show message element

        el.hidden = false; // Add message text after 150ms delay to give screen readers enough
        // time to recognize the live region and respond to the text update

        this._clearTimeout(timeoutName);

        this[timeoutName] = window.setTimeout(function () {
          return el.appendChild(message);
        }, 150);
      }
      /** @private */

    }, {
      key: "_showLoading",
      value: function _showLoading() {
        if (!this._elements.loading.hidden) {
          return;
        }

        if (this._elements.loading.contains(this._elements.loadingMessage)) {
          this._elements.loadingMessage = this._elements.loading.removeChild(this._elements.loadingMessage);
        }

        this._showMessage('loading', this._elements.loadingMessage);
      }
      /** @private */

    }, {
      key: "_hideLoading",
      value: function _hideLoading() {
        if (this._elements.loading.hidden) {
          return;
        }

        this._elements.loading.hidden = true; // clear the timeout

        this._clearTimeout('_loadingTimeout');

        if (this._elements.loading.contains(this._elements.loadingMessage)) {
          this._elements.loadingMessage = this._elements.loading.removeChild(this._elements.loadingMessage);
        }
      }
      /**
       Indicate to the user that an error has occurred
       */

    }, {
      key: "showError",
      value: function showError() {
        // Hide loading
        this._hideLoading();

        this._elements.resultMessage.innerHTML = ''; // Show the error message

        this._showMessage('resultMessage', template$L.call(this._elements, {
          i18n: i18n
        }));
      }
      /**
       Show a set of search results.
        @param {Array.<ShellHelpResult>} results
       A set of search result objects.
       @param {Number} total
       The total number of results.
       @param {String} allResultsURL
       The URL at which all results will be displayed.
       */

    }, {
      key: "showResults",
      value: function showResults(results, total, allResultsURL) {
        var _this3 = this;

        // Hide loading
        this._hideLoading(); // clear setTimeout


        if (this._showResultsTimeout) {
          window.clearTimeout(this._showResultsTimeout);
          this._showResultsTimeout = undefined;
        }

        if (!results || total === 0) {
          // Clear existing result message
          this._elements.resultMessage.innerHTML = ''; // Indicate to the user that no results were found

          this._showMessage('resultMessage', template$M.call(this._elements, {
            i18n: i18n
          }));
        } else {
          // Clear existing results
          this._elements.results.innerHTML = ''; // Populate results

          results.forEach(function (result) {
            // Tweak: make the space between bullets larger with a non-breaking space
            var separator = ' & ';
            var description = result.tags.join(separator);
            var item = new AnchorList.Item().set({
              href: result.href,
              target: result.target
            });
            item.classList.add('_coral-Shell-help-result-item');
            item.content = template$K.call(_this3._elements, {
              title: result.title,
              description: description
            }).firstElementChild;

            _this3._elements.results.appendChild(item);
          }); // Show results

          this._elements.results.hidden = false; // Show total

          if (total > 1) {
            var seeAllItem = new AnchorList.Item().set({
              href: allResultsURL,
              content: {
                innerHTML: i18n.get('See all {0} results', total)
              },
              target: '_blank'
            }); // Look like a link

            seeAllItem.content.classList.add('coral-Link');

            this._elements.results.appendChild(seeAllItem);
          }
        }
      }
      /** @ignore */

    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        var _this$classList,
            _this4 = this;

        _get(_getPrototypeOf(ShellHelp.prototype), "render", this).call(this);

        (_this$classList = this.classList).add.apply(_this$classList, CLASSNAMES$2); // Move the items into the right place


        this._moveItems();

        var contentWrapper = this.querySelector('[handle="contentWrapper"]'); // Support cloneNode

        if (contentWrapper) {
          this._elements.contentWrapper = contentWrapper;
          ['search', 'result', 'items', 'results', 'resultMessage', 'loading'].forEach(function (handle) {
            _this4._elements[handle] = _this4.querySelector("[handle=\"".concat(handle, "\"]"));
          });
          this._items._container = this._elements.items;
        } else {
          this.appendChild(this._elements.contentWrapper);
        }
      }
      /**
       A search result object.
        @typedef {Object} ShellHelpResult
        @property {String} title
       The title of the search result.
       @property {String} href
       The URL of the search result.
       @property {String} target
       This property specifies where to display the search result. Use this property only if the href property is present.
       @property {Array.<String>} tags
       A set of tags associated with the search result.
       */

      /**
       Triggered when the user submits a search term
        @event Coral.Shell.Help#coral-shell-help:search
        @param {Object} event
       Event object.
       @param {HTMLElement} event.detail.value
       The user-provided input value aka the search-term
       */

    }, {
      key: "items",
      get: function get() {
        // Construct the collection on first request:
        if (!this._items) {
          this._items = new Collection$1({
            host: this,
            itemTagName: 'coral-shell-help-item',
            itemBaseTagName: 'a',
            container: this._elements.items
          });
        }

        return this._items;
      }
      /**
       The search field placeholder.
        @type {String}
       @default ""
       @htmlattribute placeholder
       */

    }, {
      key: "placeholder",
      get: function get() {
        return this._elements.search.placeholder;
      },
      set: function set(value) {
        this._elements.search.placeholder = value;
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(ShellHelp), "observedAttributes", this).concat(['placeholder']);
      }
    }]);

    return ShellHelp;
  }(BaseComponent(HTMLElement));

  var CLASSNAME$16 = '_coral-Shell-help-item';
  /**
   @class Coral.Shell.Help.Item
   @classdesc A Shell Help item component
   @htmltag coral-shell-help-item
   @extends {AnchorListItem}
   */

  var ShellHelpItem = /*#__PURE__*/function (_AnchorList$Item) {
    _inherits(ShellHelpItem, _AnchorList$Item);

    var _super = _createSuper(ShellHelpItem);

    function ShellHelpItem() {
      _classCallCheck(this, ShellHelpItem);

      return _super.apply(this, arguments);
    }

    _createClass(ShellHelpItem, [{
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(ShellHelpItem.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$16);
      }
    }]);

    return ShellHelpItem;
  }(AnchorList.Item);

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Shell.Help.Separator
   @classdesc Shell's help separator
   @htmltag coral-shell-help-separator
   @return {HTMLElement}

   @deprecated
   */
  var ShellHelpSeparator = (function () {
    return document.createElement('coral-shell-help-separator');
  });

  var CLASSNAME$17 = '_coral-Shell-menu';
  /**
   @class Coral.Shell.Menu
   @classdesc A Shell Menu component
   @htmltag coral-shell-menu
   @extends {Popover}
   */

  var ShellMenu = /*#__PURE__*/function (_Popover) {
    _inherits(ShellMenu, _Popover);

    var _super = _createSuper(ShellMenu);

    function ShellMenu() {
      _classCallCheck(this, ShellMenu);

      return _super.apply(this, arguments);
    }

    _createClass(ShellMenu, [{
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(ShellMenu.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$17);
        this.trigger('coral-shell-menu:_connected');
      }
    }, {
      key: "within",

      /**
       Inherited from {@link Popover#within}.
       */
      get: function get() {
        // Force 'coral-shell'
        return document.querySelector('coral-shell') || 'coral-shell';
      },
      set: function set(value) {
        _set(_getPrototypeOf(ShellMenu.prototype), "within", value, this, true);
      }
      /**
       Inherited from {@link Popover#placement}.
       */

    }, {
      key: "placement",
      get: function get() {
        // Force bottom placement
        return this.constructor.placement.BOTTOM;
      },
      set: function set(value) {
        _set(_getPrototypeOf(ShellMenu.prototype), "placement", value, this, true);
      }
      /**
       Whether the overlay should use all available space.
        @type {Boolean}
       @default false
       @htmlattribute full
       @htmlattributereflected
       */

    }, {
      key: "full",
      get: function get() {
        return this._full || false;
      },
      set: function set(value) {
        this._full = transform.booleanAttr(value);

        this._reflectAttribute('full', this._full);

        this.classList.toggle("".concat(CLASSNAME$17, "--full"), this._full);
      }
      /** @ignore */

    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(ShellMenu), "observedAttributes", this).concat(['full']);
      }
    }]);

    return ShellMenu;
  }(Popover);

  var CLASSNAME$18 = '_coral-Shell-menubar';
  /**
   @class Coral.Shell.MenuBar
   @classdesc A Shell MenuBar component
   @htmltag coral-shell-menubar
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var ShellMenuBar = /*#__PURE__*/function (_BaseComponent) {
    _inherits(ShellMenuBar, _BaseComponent);

    var _super = _createSuper(ShellMenuBar);

    /** @ignore */
    function ShellMenuBar() {
      var _this;

      _classCallCheck(this, ShellMenuBar);

      _this = _super.call(this);

      _this.setAttribute('role', 'list');

      _this.items._startHandlingItems(true);

      return _this;
    }
    /**
     The item collection.
      @type {Collection}
     @readonly
     */


    _createClass(ShellMenuBar, [{
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(ShellMenuBar.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$18);
      }
    }, {
      key: "items",
      get: function get() {
        // Construct the collection on first request:
        if (!this._items) {
          this._items = new Collection$1({
            host: this,
            itemTagName: 'coral-shell-menubar-item'
          });
        }

        return this._items;
      }
    }]);

    return ShellMenuBar;
  }(BaseComponent(HTMLElement));

  var template$N = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["shellMenuButton"] = document.createElement("button", "coral-button");
    el0.setAttribute("is", "coral-button");
    el0.setAttribute("variant", "quietaction");
    el0.setAttribute("iconsize", "S");
    el0.className += " _coral-Shell-menu-button";
    el0.setAttribute("handle", "shellMenuButton");
    el0.setAttribute("type", "button");
    var el1 = document.createTextNode("\n  ");
    el0.appendChild(el1);
    var el2 = this["shellMenuButtonLabel"] = document.createElement("coral-button-label");
    el2.setAttribute("handle", "shellMenuButtonLabel");
    el0.appendChild(el2);
    var el3 = document.createTextNode("\n");
    el0.appendChild(el3);
    frag.appendChild(el0);
    var el4 = document.createTextNode("\n");
    frag.appendChild(el4);
    return frag;
  };

  /**
   Enumeration for {@link ShellMenuBarItem} icon variants.

   @typedef {Object} ShellMenuBarItemIconVariantEnum

   @property {String} DEFAULT
   A default menubar item.
   @property {String} CIRCLE
   A round image as menubar item.
   */

  var iconVariant = {
    DEFAULT: 'default',
    CIRCLE: 'circle'
  };
  /**
   Enumeration for valid aria-haspopup values.

   @typedef {Object} ShellMenuBarItemHasPopupRoleEnum
   @property {String} MENU
   ShellMenuBarItem opens a menu.
   @property {String} LISTBOX
   ShellMenuBarItem opens a list box.
   @property {String} TREE
   ShellMenuBarItem opens a tree.
   @property {String} GRID
   ShellMenuBarItem opens a grid.
   @property {String} DIALOG
   ShellMenuBarItem opens a dialog.
   @property {Null} DEFAULT
   Defaults to null.

   */

  var hasPopupRole = {
    MENU: 'menu',
    LISTBOX: 'listbox',
    TREE: 'tree',
    GRID: 'grid',
    DIALOG: 'dialog',
    DEFAULT: null
  }; // the Menubar Item's base classname

  var CLASSNAME$19 = '_coral-Shell-menubar-item'; // Builds a string containing all possible iconVariant classnames. This will be used to remove classnames when the variant
  // changes

  var ALL_ICON_VARIANT_CLASSES = [];

  for (var variantValue$8 in iconVariant) {
    ALL_ICON_VARIANT_CLASSES.push("".concat(CLASSNAME$19, "--").concat(iconVariant[variantValue$8]));
  }
  /**
   @class Coral.Shell.MenuBar.Item
   @classdesc A Shell MenuBar Item component
   @htmltag coral-shell-menubar-item
   @extends {HTMLElement}
   @extends {BaseComponent}
   */


  var ShellMenuBarItem = /*#__PURE__*/function (_BaseComponent) {
    _inherits(ShellMenuBarItem, _BaseComponent);

    var _super = _createSuper(ShellMenuBarItem);

    /** @ignore */
    function ShellMenuBarItem() {
      var _this;

      _classCallCheck(this, ShellMenuBarItem);

      _this = _super.call(this); // Templates

      _this._elements = {};
      template$N.call(_this._elements); // Events

      _this._delegateEvents({
        'click [handle="shellMenuButton"]': '_handleButtonClick',
        // it has to be global because the menus are not direct children
        'global:coral-overlay:close': '_handleOverlayEvent',
        'global:coral-overlay:beforeclose': '_handleOverlayBeforeEvent',
        'global:coral-overlay:open': '_handleOverlayEvent',
        'global:coral-overlay:beforeopen': '_handleOverlayBeforeEvent'
      });

      return _this;
    }
    /**
     Specifies the icon name used inside the menu item.
     See {@link Icon} for valid icon names.
      @type {String}
     @default ""
     @htmlattribute icon
     */


    _createClass(ShellMenuBarItem, [{
      key: "_handleOverlayBeforeEvent",
      value: function _handleOverlayBeforeEvent(event) {
        var target = event.target;

        if (target === this._getMenu()) {
          // Mark button as selected
          this._elements.shellMenuButton.classList.toggle('is-selected', !target.open);
        }
      }
      /** @private */

    }, {
      key: "_handleOverlayEvent",
      value: function _handleOverlayEvent(event) {
        var target = event.target; // matches the open state of the target in case it was open separately

        if (target === this._getMenu()) {
          var shellMenuButton = this._elements.shellMenuButton;

          if (this.open !== target.open) {
            this.open = target.open;
          } else if (shellMenuButton.getAttribute('aria-expanded') !== target.open) {
            shellMenuButton.setAttribute('aria-expanded', target.open);
          }
        }
      }
      /** @ignore */

    }, {
      key: "_handleButtonClick",
      value: function _handleButtonClick() {
        this.open = !this.open;
      }
      /** @ignore */

    }, {
      key: "_getMenu",
      value: function _getMenu(targetValue) {
        // Use passed target
        targetValue = targetValue || this.menu;

        if (targetValue instanceof Node) {
          // Just return the provided Node
          return targetValue;
        } // Dynamically get the target node based on target


        var newTarget = null;

        if (typeof targetValue === 'string') {
          newTarget = document.querySelector(targetValue);
        }

        return newTarget;
      }
    }, {
      key: "focus",

      /** @ignore */
      value: function focus() {
        this._elements.shellMenuButton.focus();
      }
      /**
       Returns {@link ShellMenuBarItem} icon variants.
        @return {ShellMenuBarItemIconVariantEnum}
       */

    }, {
      key: "attributeChangedCallback",

      /** @ignore */
      value: function attributeChangedCallback(name, oldValue, value) {
        // a11y When user doesn't supply a button label (for an icon-only button),
        // providing aria-label will correctly pass it on to the shell menu button child element.
        if (name === 'aria-label') {
          if (value && this._elements.shellMenuButton.textContent.trim() === '') {
            this._elements.shellMenuButton.setAttribute('aria-label', value);
          }
        } else {
          _get(_getPrototypeOf(ShellMenuBarItem.prototype), "attributeChangedCallback", this).call(this, name, oldValue, value);
        }
      }
      /** @ignore */

    }, {
      key: "render",
      value: function render() {
        _get(_getPrototypeOf(ShellMenuBarItem.prototype), "render", this).call(this);

        this.setAttribute('role', 'listitem');
        this.classList.add(CLASSNAME$19);
        var button = this.querySelector('._coral-Shell-menu-button');

        if (button) {
          this._elements.shellMenuButton = button;
          this._elements.shellMenuButtonLabel = this.querySelector('coral-button-label');
        } else {
          while (this.firstChild) {
            this._elements.shellMenuButtonLabel.appendChild(this.firstChild);
          }

          this.appendChild(this._elements.shellMenuButton);
        }

        this.label = this._elements.shellMenuButtonLabel; // Sync menu

        if (this.menu !== null) {
          this.menu = this.menu;
        }
      }
      /**
       Triggered after the {@link ShellMenuBarItem} is opened with <code>show()</code> or <code>instance.open = true</code>
        @typedef {CustomEvent} coral-shell-menubar-item:open
       */

      /**
       Triggered after the {@link ShellMenuBarItem} is closed with <code>hide()</code> or <code>instance.open = false</code>
        @typedef {CustomEvent} coral-shell-menubar-item:close
       */

    }, {
      key: "icon",
      get: function get() {
        return this._elements.shellMenuButton.icon;
      },
      set: function set(value) {
        this._elements.shellMenuButton.icon = value;
      }
      /**
       Size of the icon. It accepts both lower and upper case sizes. See {@link ButtonIconSizeEnum}.
        @type {String}
       @default ButtonIconSizeEnum.SMALL
       @htmlattribute iconsize
       @htmlattributereflected
       */

    }, {
      key: "iconSize",
      get: function get() {
        return this._elements.shellMenuButton.iconSize;
      },
      set: function set(value) {
        this._elements.shellMenuButton.iconSize = value; // Required for styling

        this._reflectAttribute('iconsize', this.iconSize);
      }
      /**
       The menubar item's iconVariant. See {@link ShellMenuBarItemIconVariantEnum}.
        @type {String}
       @default ShellMenuBarItemIconVariantEnum.DEFAULT
       @htmlattribute iconvariant
       */

    }, {
      key: "iconVariant",
      get: function get() {
        return this._iconVariant || iconVariant.DEFAULT;
      },
      set: function set(value) {
        var _this$classList;

        value = transform.string(value).toLowerCase();
        this._iconVariant = validate.enumeration(iconVariant)(value) && value || iconVariant.DEFAULT; // removes all the existing variants

        (_this$classList = this.classList).remove.apply(_this$classList, ALL_ICON_VARIANT_CLASSES); // adds the new variant


        if (this.variant !== iconVariant.DEFAULT) {
          this.classList.add("".concat(CLASSNAME$19, "--").concat(this._iconVariant));
        }
      }
      /**
       The notification badge content.
        @type {String}
       @default ""
       @htmlattribute badge
       */

    }, {
      key: "badge",
      get: function get() {
        return this._elements.shellMenuButton.getAttribute('badge') || '';
      },
      set: function set(value) {
        // Non-truthy values shouldn't show
        // null, empty string, 0, etc
        this._elements.shellMenuButton[!value || value === '0' ? 'removeAttribute' : 'setAttribute']('badge', value);
      }
      /**
       Whether the menu is open or not.
        @type {Boolean}
       @default false
       @htmlattribute open
       @htmlattributereflected
        @emits {coral-shell-menubar-item:open}
       @emits {coral-shell-menubar-item:close}
       */

    }, {
      key: "open",
      get: function get() {
        return this._open || false;
      },
      set: function set(value) {
        var menu = this._getMenu(); // if we want to open the dialog we need to make sure there is a valid menu or hasPopup


        if (menu === null && this.hasPopup === hasPopupRole.DEFAULT) {
          return;
        }

        this._open = transform.booleanAttr(value);

        this._reflectAttribute('open', this._open); // if the menu is valid, toggle the menu and trigger the appropriate event


        if (menu !== null) {
          // Toggle the target menu
          if (menu.open !== this._open) {
            menu.open = this._open;
          }

          this.trigger("coral-shell-menubar-item:".concat(this._open ? 'open' : 'close'));
        }

        this._elements.shellMenuButton.setAttribute('aria-expanded', this._open);
      }
      /**
       The menubar item's label content zone.
        @type {ButtonLabel}
       @contentzone
       */

    }, {
      key: "label",
      get: function get() {
        return this._getContentZone(this._elements.shellMenuButtonLabel);
      },
      set: function set(value) {
        this._setContentZone('label', value, {
          handle: 'shellMenuButtonLabel',
          tagName: 'coral-button-label',
          insert: function insert(label) {
            this._elements.shellMenuButton.label = label;
          }
        });
      }
      /**
       The menu that this menu item should show. If a CSS selector is provided, the first matching element will be
       used.
        @type {?HTMLElement|String}
       @default null
       @htmlattribute menu
       */

    }, {
      key: "menu",
      get: function get() {
        return this._menu || null;
      },
      set: function set(value) {
        var menu;

        if (value instanceof HTMLElement) {
          this._menu = value;
          menu = this._menu;
        } else {
          this._menu = String(value);
          menu = document.querySelector(this._menu);
        } // Link menu with item


        if (menu !== null) {
          this.id = this.id || commons.getUID();
          menu.setAttribute('target', "#".concat(this.id));

          if (this.hasPopup === hasPopupRole.DEFAULT) {
            this.hasPopup = menu.getAttribute('role') || hasPopupRole.DIALOG;
          }
        } else if (this._menu && this.hasPopup !== hasPopupRole.DEFAULT) {
          this.hasPopup = hasPopupRole.DEFAULT;
        }
      }
      /**
       Whether the item opens a popup dialog or menu. Accepts either "menu", "listbox", "tree", "grid", or "dialog".
       @type {?String}
       @default ShellMenuBarItemHasPopupRoleEnum.DEFAULT
       @htmlattribute haspopup
       */

    }, {
      key: "hasPopup",
      get: function get() {
        return this._hasPopup || null;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        this._hasPopup = validate.enumeration(hasPopupRole)(value) && value || hasPopupRole.DEFAULT;
        var shellMenuButton = this._elements.shellMenuButton;
        var ariaHaspopup = this._hasPopup;

        if (ariaHaspopup) {
          shellMenuButton.setAttribute('aria-haspopup', ariaHaspopup);
          shellMenuButton.setAttribute('aria-expanded', this.open);
        } else {
          shellMenuButton.removeAttribute('aria-haspopup');
          shellMenuButton.removeAttribute('aria-expanded');
        }
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-button-label': 'label'
        };
      }
    }], [{
      key: "iconVariant",
      get: function get() {
        return iconVariant;
      }
    }, {
      key: "_attributePropertyMap",
      get: function get() {
        return commons.extend(_get(_getPrototypeOf(ShellMenuBarItem), "_attributePropertyMap", this), {
          haspopup: 'hasPopup',
          iconsize: 'iconSize',
          iconvariant: 'iconVariant'
        });
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(ShellMenuBarItem), "observedAttributes", this).concat(['haspopup', 'icon', 'iconsize', 'iconvariant', 'badge', 'open', 'menu', 'aria-label']);
      }
    }]);

    return ShellMenuBarItem;
  }(BaseComponent(HTMLElement));

  var template$O = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["container"] = document.createElement("div");
    el0.className += " _coral-Shell-user-container";
    el0.setAttribute("handle", "container");
    var el1 = document.createTextNode("\n  ");
    el0.appendChild(el1);
    var el2 = this["image"] = document.createElement("div");
    el2.className += " _coral-Shell-user-image";
    el2.setAttribute("handle", "image");
    var el3 = document.createTextNode("\n    ");
    el2.appendChild(el3);
    var el4 = this["avatar"] = document.createElement("coral-icon");
    el4.setAttribute("icon", data_0["icon"]);
    el4.className += " _coral-Shell-user-avatar";
    el4.setAttribute("size", "XL");
    el4.setAttribute("handle", "avatar");
    el2.appendChild(el4);
    var el5 = document.createTextNode("\n  ");
    el2.appendChild(el5);
    el0.appendChild(el2);
    var el6 = document.createTextNode("\n");
    el0.appendChild(el6);
    frag.appendChild(el0);
    var el7 = document.createTextNode("\n");
    frag.appendChild(el7);
    return frag;
  };

  var CLASSNAME$1a = '_coral-Shell-user';
  /**
   Enumeration for {@link ShellUser} avatar options. Avatar assets should use one of those provided, when no asset is set

   @typedef {Object} ShellUserAvatarEnum

   @property {String} DEFAULT
   Default avatar, show user icon from icon font.
   */

  var avatar = {
    DEFAULT: 'UserCircleColor_Light'
  };
  /**
   @class Coral.Shell.User
   @classdesc A Shell User component
   @htmltag coral-shell-user
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var ShellUser = /*#__PURE__*/function (_BaseComponent) {
    _inherits(ShellUser, _BaseComponent);

    var _super = _createSuper(ShellUser);

    /** @ignore */
    function ShellUser() {
      var _this;

      _classCallCheck(this, ShellUser);

      _this = _super.call(this); // Prepare templates

      _this._elements = {
        // Fetch or create the content zone elements
        name: _this.querySelector('coral-shell-user-name') || document.createElement('coral-shell-user-name'),
        heading: _this.querySelector('coral-shell-user-heading') || document.createElement('coral-shell-user-heading'),
        subheading: _this.querySelector('coral-shell-user-subheading') || document.createElement('coral-shell-user-subheading'),
        content: _this.querySelector('coral-shell-user-content') || document.createElement('coral-shell-user-content'),
        footer: _this.querySelector('coral-shell-user-footer') || document.createElement('coral-shell-user-footer')
      };
      template$O.call(_this._elements, {
        icon: avatar.DEFAULT
      });
      return _this;
    }
    /**
     Specifies the asset used inside the avatar view.
     See {@link Icon} for valid usage and icon names.
      @type {String}
     @default ShellUserAvatarEnum.DEFAULT
     @htmlattribute avatar
     */


    _createClass(ShellUser, [{
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(ShellUser.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1a);
        var frag = document.createDocumentFragment(); // Render template

        frag.appendChild(this._elements.container);

        for (var contentZone in this._contentZones) {
          var element = this._elements[this._contentZones[contentZone]]; // Remove it so we can process children

          if (element.parentNode) {
            element.parentNode.removeChild(element);
          }
        }

        while (this.firstChild) {
          var child = this.firstChild;

          if (child.nodeType === Node.TEXT_NODE || child.nodeType === Node.ELEMENT_NODE && child.getAttribute('handle') !== 'container') {
            // Add non-template elements to the content
            this._elements.content.appendChild(child);
          } else {
            // Remove anything else element
            this.removeChild(child);
          }
        }

        this.appendChild(frag); // Assign the content zones so the insert functions will be called

        for (var _contentZone in this._contentZones) {
          var contentZoneName = this._contentZones[_contentZone];
          var _element = this._elements[this._contentZones[_contentZone]];
          /** @ignore */

          this[contentZoneName] = _element;
        }
      }
    }, {
      key: "avatar",
      get: function get() {
        return this._elements.avatar.icon;
      },
      set: function set(value) {
        this._elements.avatar.icon = value;
      }
      /**
       The name content zone of the user-menu.
        @type {ShellUserName}
       @contentzone
       */

    }, {
      key: "name",
      get: function get() {
        return this._getContentZone(this._elements.name);
      },
      set: function set(value) {
        this._setContentZone('content', value, {
          handle: 'name',
          tagName: 'coral-shell-user-name',
          insert: function insert(content) {
            this._elements.container.appendChild(content);
          }
        });
      }
      /**
       The heading content zone of the user-menu.
        @type {ShellUserHeading}
       @contentzone
       */

    }, {
      key: "heading",
      get: function get() {
        return this._getContentZone(this._elements.heading);
      },
      set: function set(value) {
        this._setContentZone('heading', value, {
          handle: 'heading',
          tagName: 'coral-shell-user-heading',
          insert: function insert(content) {
            this._elements.container.appendChild(content);
          }
        });
      }
      /**
       The subheading content zone of the user-menu.
        @type {ShellUserSubheading}
       @contentzone
       */

    }, {
      key: "subheading",
      get: function get() {
        return this._getContentZone(this._elements.subheading);
      },
      set: function set(value) {
        this._setContentZone('subheading', value, {
          handle: 'subheading',
          tagName: 'coral-shell-user-subheading',
          insert: function insert(content) {
            this._elements.container.appendChild(content);
          }
        });
      }
      /**
       The main content zone of the user-menu.
        @type {ShellUserContent}
       @contentzone
       */

    }, {
      key: "content",
      get: function get() {
        return this._getContentZone(this._elements.content);
      },
      set: function set(value) {
        this._setContentZone('content', value, {
          handle: 'content',
          tagName: 'coral-shell-user-content',
          insert: function insert(content) {
            // Empty content to hide it
            if (content.innerHTML.trim() === '') {
              content.innerHTML = '';
            }

            this.appendChild(content);
          }
        });
      }
      /**
       The footer content zone of the user-menu.
        @type {ShellUserFooter}
       @contentzone
       */

    }, {
      key: "footer",
      get: function get() {
        return this._getContentZone(this._elements.footer);
      },
      set: function set(value) {
        this._setContentZone('footer', value, {
          handle: 'footer',
          tagName: 'coral-shell-user-footer',
          insert: function insert(content) {
            this.appendChild(content);
          }
        });
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-shell-user-name': 'name',
          'coral-shell-user-heading': 'heading',
          'coral-shell-user-subheading': 'subheading',
          'coral-shell-user-content': 'content',
          'coral-shell-user-footer': 'footer'
        };
      }
      /** @ignore */

    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(ShellUser), "observedAttributes", this).concat(['avatar']);
      }
      /**
       Returns {@link ShellUser} avatar options.
        @return {ShellUserAvatarEnum}
       */

    }, {
      key: "avatar",
      get: function get() {
        return avatar;
      }
    }]);

    return ShellUser;
  }(BaseComponent(HTMLElement));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Shell.User.Content
   @classdesc Shell's User content component
   @htmltag coral-shell-user-content
   @return {HTMLElement}
   */
  var ShellUserContent = (function () {
    return document.createElement('coral-shell-user-content');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Shell.User.Footer
   @classdesc Shell's User footer component
   @htmltag coral-shell-user-footer
   @return {HTMLElement}
   */
  var ShellUserFooter = (function () {
    return document.createElement('coral-shell-user-footer');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Shell.User.Heading
   @classdesc Shell's User heading component
   @htmltag coral-shell-user-heading
   @return {HTMLElement}
   */
  var ShellUserHeading = (function () {
    return document.createElement('coral-shell-user-heading');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Shell.User.Name
   @classdesc Shell's User name component
   @htmltag coral-shell-user-name
   @return {HTMLElement}
   */
  var ShellUserName = (function () {
    return document.createElement('coral-shell-user-name');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Shell.User.Subheading
   @classdesc Shell's User subheading component
   @htmltag coral-shell-user-subheading
   @return {HTMLElement}
   */
  var ShellUserSubheading = (function () {
    return document.createElement('coral-shell-user-subheading');
  });

  var CLASSNAME$1b = '_coral-Shell-workspaces';
  /**
   @class Coral.Shell.Workspaces
   @classdesc A Shell Workspaces component
   @htmltag coral-shell-workspaces
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var ShellWorkspaces = /*#__PURE__*/function (_BaseComponent) {
    _inherits(ShellWorkspaces, _BaseComponent);

    var _super = _createSuper(ShellWorkspaces);

    /** @ignore */
    function ShellWorkspaces() {
      var _this;

      _classCallCheck(this, ShellWorkspaces);

      _this = _super.call(this); // Events

      _this._delegateEvents({
        'key:down [is="coral-shell-workspace"]': '_focusNextItem',
        'key:right [is="coral-shell-workspace"]': '_focusNextItem',
        'key:left [is="coral-shell-workspace"]': '_focusPreviousItem',
        'key:up [is="coral-shell-workspace"]': '_focusPreviousItem',
        'key:pageup [is="coral-shell-workspace"]': '_focusPreviousItem',
        'key:pagedown [is="coral-shell-workspace"]': '_focusNextItem',
        'key:home [is="coral-shell-workspace"]': '_focusFirstItem',
        'key:end [is="coral-shell-workspace"]': '_focusLastItem',
        // private
        'coral-shell-workspace:_selectedchanged': '_onItemSelectedChanged',
        'change ._coral-Shell-workspaces-select': '_onSelectChanged'
      }); // Template


      _this._elements = {
        select: new Select().set({
          variant: 'quiet'
        })
      };

      _this._elements.select.classList.add('_coral-Shell-workspaces-select'); // Used for eventing


      _this._oldSelection = null; // Init the collection mutation observer

      _this.items._startHandlingItems(true);

      return _this;
    }
    /**
     The item collection.
      @type {SelectableCollection}
     @readonly
     */


    _createClass(ShellWorkspaces, [{
      key: "_validateSelection",

      /** @private */
      value: function _validateSelection(item) {
        // gets the current selection
        var selection = this.items._getAllSelected();

        var selectionCount = selection.length; // if no item is currently selected, we need to find a candidate

        if (selectionCount === 0) {
          // gets the first candidate for selection
          var selectable = this.items._getFirstSelectable();

          if (selectable) {
            selectable.setAttribute('selected', '');
          }
        } // more items are selected, so we find a single item and deselect everything else
        else if (selectionCount > 1) {
            // By default, the last one stays selected
            item = item || selection[selection.length - 1];

            for (var i = 0; i < selectionCount; i++) {
              if (selection[i] !== item) {
                // Don't trigger change events
                this._preventTriggeringEvents = true;
                selection[i].removeAttribute('selected');
              }
            } // We can trigger change events again


            this._preventTriggeringEvents = false;
          } // Sync select items under the hood


        this._renderSelectItems();

        this._triggerChangeEvent();
      }
    }, {
      key: "_renderSelectItems",
      value: function _renderSelectItems() {
        var _this2 = this;

        this._elements.select.items.clear();

        this.items.getAll().forEach(function (item) {
          _this2._elements.select.items.add({
            content: {
              innerHTML: item.innerHTML
            },
            selected: item.hasAttribute('selected'),
            _workspace: item
          });
        });
      }
    }, {
      key: "_onSelectChanged",
      value: function _onSelectChanged(event) {
        event.stopImmediatePropagation();
        this._elements.select.selectedItem._workspace.selected = true;
      }
      /** @private */

    }, {
      key: "_triggerChangeEvent",
      value: function _triggerChangeEvent() {
        var selectedItem = this.selectedItem;
        var oldSelection = this._oldSelection;

        if (!this._preventTriggeringEvents && selectedItem !== oldSelection) {
          this.trigger('coral-shell-workspaces:change', {
            oldSelection: oldSelection,
            selection: selectedItem
          });
          this._oldSelection = selectedItem;
        }
      }
      /** @private */

    }, {
      key: "_onItemSelectedChanged",
      value: function _onItemSelectedChanged(event) {
        event.stopImmediatePropagation();
        var item = event.target;

        this._validateSelection(item);
      }
      /**
       Returns true if the event is at the matched target.
        @private
       */

    }, {
      key: "_eventIsAtTarget",
      value: function _eventIsAtTarget(event) {
        var target = event.target;
        var listItem = event.matchedTarget;
        var isAtTarget = target === listItem;

        if (isAtTarget) {
          // Don't let arrow keys etc scroll the page
          event.preventDefault();
          event.stopPropagation();
        }

        return isAtTarget;
      }
      /** @private */

    }, {
      key: "_focusNextItem",
      value: function _focusNextItem(event) {
        if (!this._eventIsAtTarget(event)) {
          return;
        }

        var target = event.matchedTarget;

        if (target.nextElementSibling) {
          target.nextElementSibling.focus();
        } else {
          this.items.first().focus();
        }
      }
      /** @private */

    }, {
      key: "_focusPreviousItem",
      value: function _focusPreviousItem(event) {
        if (!this._eventIsAtTarget(event)) {
          return;
        }

        var target = event.matchedTarget;

        if (target.previousElementSibling) {
          target.previousElementSibling.focus();
        } else {
          this.items.last().focus();
        }
      }
      /** @private */

    }, {
      key: "_focusFirstItem",
      value: function _focusFirstItem(event) {
        if (!this._eventIsAtTarget(event)) {
          return;
        }

        this.items.first().focus();
      }
      /** @private */

    }, {
      key: "_focusLastItem",
      value: function _focusLastItem(event) {
        if (!this._eventIsAtTarget(event)) {
          return;
        }

        this.items.last().focus();
      }
      /** @ignore */

    }, {
      key: "render",
      value: function render() {
        _get(_getPrototypeOf(ShellWorkspaces.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1b); // Don't trigger events once connected

        this._preventTriggeringEvents = true;

        this._validateSelection();

        this._preventTriggeringEvents = false;
        this._oldSelection = this.selectedItem; // Support cloneNode

        var template = this.querySelector('._coral-Shell-workspaces-select');

        if (template) {
          template.remove();
        }

        this.appendChild(this._elements.select);
      }
    }, {
      key: "items",
      get: function get() {
        // Construct the collection on first request:
        if (!this._items) {
          this._items = new SelectableCollection({
            host: this,
            itemTagName: 'coral-shell-workspace',
            itemBaseTagName: 'a',
            onItemAdded: this._validateSelection,
            onItemRemoved: this._validateSelection
          });
        }

        return this._items;
      }
      /**
       Returns the selected workspace.
        @type {HTMLElement}
       @readonly
       */

    }, {
      key: "selectedItem",
      get: function get() {
        return this.items._getLastSelected();
      }
    }]);

    return ShellWorkspaces;
  }(BaseComponent(HTMLElement));

  var CLASSNAME$1c = '_coral-Shell-workspaces-workspace';
  /**
   @class Coral.Shell.Workspace
   @classdesc A Shell Workspace component
   @htmltag coral-shell-workspace
   @htmlbasetag a
   @extends {HTMLAnchorElement}
   @extends {BaseComponent}
   */

  var ShellWorkspace = /*#__PURE__*/function (_BaseComponent) {
    _inherits(ShellWorkspace, _BaseComponent);

    var _super = _createSuper(ShellWorkspace);

    /** @ignore */
    function ShellWorkspace() {
      var _this;

      _classCallCheck(this, ShellWorkspace);

      _this = _super.call(this); // Events

      _this._delegateEvents({
        click: '_onClick'
      });

      return _this;
    }
    /**
     Whether this workspace is selected.
      @type {Boolean}
     @default false
     @htmlattribute selected
     @htmlattributereflected
     */


    _createClass(ShellWorkspace, [{
      key: "_onClick",

      /** @private */
      value: function _onClick() {
        if (!this.selected) {
          this.selected = true;
        }
      }
      /** @ignore */

    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(ShellWorkspace.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1c);
      }
      /**
       Triggered when a {@link ShellWorkspace} selection changed.
        @typedef {CustomEvent} coral-shell-workspace:_selectedchanged
        @private
       */

    }, {
      key: "selected",
      get: function get() {
        return this._selected || false;
      },
      set: function set(value) {
        this._selected = transform.booleanAttr(value);

        this._reflectAttribute('selected', this._selected);

        this.setAttribute('aria-selected', this._selected);
        this.classList.toggle('is-selected', this._selected);
        this.trigger('coral-shell-workspace:_selectedchanged');
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(ShellWorkspace), "observedAttributes", this).concat(['selected']);
      }
    }]);

    return ShellWorkspace;
  }(BaseComponent(HTMLAnchorElement));

  var template$P = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["container"] = document.createElement("div");
    el0.setAttribute("handle", "container");
    el0.className += " _coral-Shell-solutions-container";
    frag.appendChild(el0);
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    return frag;
  };

  var CLASSNAME$1d = '_coral-Shell-solutionSwitcher';
  /**
   @class Coral.Shell.SolutionSwitcher
   @classdesc A Shell Solution Switcher component
   @htmltag coral-shell-solutionswitcher
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var ShellSolutionSwitcher = /*#__PURE__*/function (_BaseComponent) {
    _inherits(ShellSolutionSwitcher, _BaseComponent);

    var _super = _createSuper(ShellSolutionSwitcher);

    /** @ignore */
    function ShellSolutionSwitcher() {
      var _this;

      _classCallCheck(this, ShellSolutionSwitcher);

      _this = _super.call(this); // Template

      _this._elements = {};
      template$P.call(_this._elements); // Listen for mutations

      var observer = new MutationObserver(function (mutations) {
        mutations.forEach(function (mutation) {
          for (var i = 0; i < mutation.addedNodes.length; i++) {
            var addedNode = mutation.addedNodes[i]; // Move non secondary solutions to the container

            if (addedNode.nodeName === 'CORAL-SHELL-SOLUTIONS' && !addedNode.hasAttribute('secondary')) {
              _this._elements.container.appendChild(addedNode);
            }
          }
        });
      });
      observer.observe(_assertThisInitialized(_this), {
        // Only care about direct children
        childList: true
      });
      return _this;
    }
    /**
     The item collection.
      @type {Collection}
     @readonly
     */


    _createClass(ShellSolutionSwitcher, [{
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(ShellSolutionSwitcher.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1d); // force darkest theme

        this.classList.add('coral--darkest');

        var container = this.querySelector('._coral-Shell-solutions-container') || this._elements.container; // Remove it so we can process solutions


        if (container.parentNode) {
          container.remove();
        } // Move non secondary solutions to the container


        Array.prototype.forEach.call(this.querySelectorAll('coral-shell-solutions:not([secondary])'), function (item) {
          container.appendChild(item);
        }); // Put the container as first child

        this.insertBefore(container, this.firstChild);
      }
    }, {
      key: "items",
      get: function get() {
        // Construct the collection on first request
        if (!this._items) {
          this._items = new Collection$1({
            host: this,
            itemTagName: 'coral-shell-solutions'
          });
        }

        return this._items;
      }
    }]);

    return ShellSolutionSwitcher;
  }(BaseComponent(HTMLElement));

  var CLASSNAME$1e = '_coral-Shell-solutions';
  /**
   @class Coral.Shell.Solutions
   @classdesc A Shell Solutions component
   @htmltag coral-shell-solutions
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var ShellSolutions = /*#__PURE__*/function (_BaseComponent) {
    _inherits(ShellSolutions, _BaseComponent);

    var _super = _createSuper(ShellSolutions);

    function ShellSolutions() {
      _classCallCheck(this, ShellSolutions);

      return _super.apply(this, arguments);
    }

    _createClass(ShellSolutions, [{
      key: "_sortSolutions",
      value: function _sortSolutions() {
        var _this = this;

        if (this.items.length > 1) {
          var linked = [];
          var nonLinked = [];
          var isSecondary = this.hasAttribute('secondary');
          this.items.getAll().forEach(function (item, i) {
            // Exclude the first secondary item
            if (!(isSecondary && i === 0)) {
              if (item.hasAttribute('linked')) {
                linked.push(item);
              } else {
                nonLinked.push(item);
              }
            }
          });

          var alphabeticalSort = function alphabeticalSort(a, b) {
            var aText = a.textContent.trim().toLowerCase();
            var bText = b.textContent.trim().toLowerCase();

            if (aText < bText) {
              return -1;
            }

            if (aText > bText) {
              return 1;
            }

            return 0;
          };

          linked.sort(alphabeticalSort);
          nonLinked.sort(alphabeticalSort);
          linked.forEach(function (item) {
            _this.appendChild(item);
          });
          nonLinked.forEach(function (item) {
            _this.appendChild(item);
          });
        }
      }
      /** @ignore */

    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(ShellSolutions.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1e); // Sort linked solutions then non linked solutions alphabetically

        this._sortSolutions();
      }
    }, {
      key: "items",

      /**
       The item collection.
        @type {Collection}
       @readonly
       */
      get: function get() {
        // Construct the collection on first request:
        if (!this._items) {
          this._items = new Collection$1({
            host: this,
            itemTagName: 'coral-shell-solution',
            itemBaseTagName: 'a'
          });
        }

        return this._items;
      }
      /**
       Whether the solution list is secondary.
        @type {Boolean}
       @default false
       @htmlattribute secondary
       @htmlattributereflected
       */

    }, {
      key: "secondary",
      get: function get() {
        return this._secondary || false;
      },
      set: function set(value) {
        this._secondary = transform.booleanAttr(value);

        this._reflectAttribute('secondary', this._secondary);

        this.classList.toggle("".concat(CLASSNAME$1e, "--secondary"), this._secondary);
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(ShellSolutions), "observedAttributes", this).concat(['secondary']);
      }
    }]);

    return ShellSolutions;
  }(BaseComponent(HTMLElement));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  /**
   @class Coral.Shell.Solutions.Header
   @classdesc Shell's solution sub-cloud name
   @htmltag coral-shell-solutions-header
   @return {HTMLElement}

   @deprecated
   */

  var ShellSolutionsHeader = (function () {
    commons._log('warn', 'Coral.Shell.Solutions.Header: coral-shell-solutions-header is deprecated.');

    return document.createElement('coral-shell-solutions-header');
  });

  var template$Q = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["icon"] = document.createElement("coral-icon");
    el0.setAttribute("size", "XL");
    el0.setAttribute("handle", "icon");
    el0.className += " _coral-Shell-solution-icon";
    el0.setAttribute("alt", "");
    frag.appendChild(el0);
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    return frag;
  };

  var CLASSNAME$1f = '_coral-Shell-solution';
  /**
   @class Coral.Shell.Solution
   @classdesc A Shell Solution component
   @htmltag coral-shell-solution
   @extends {HTMLAnchorElement}
   @extends {BaseComponent}
   */

  var ShellSolution = /*#__PURE__*/function (_BaseComponent) {
    _inherits(ShellSolution, _BaseComponent);

    var _super = _createSuper(ShellSolution);

    /** @ignore */
    function ShellSolution() {
      var _this;

      _classCallCheck(this, ShellSolution);

      _this = _super.call(this); // Prepare templates

      _this._elements = {
        // Fetch or create the content zone elements
        label: _this.querySelector('coral-shell-solution-label') || document.createElement('coral-shell-solution-label')
      };
      template$Q.call(_this._elements);
      return _this;
    }
    /**
     Specifies the icon name used inside the button. See {@link Icon} for valid icon names.
      @type {String}
     @default ""
     @htmlattribute icon
     */


    _createClass(ShellSolution, [{
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(ShellSolution.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1f);
        var fragment = document.createDocumentFragment(); // Render template

        fragment.appendChild(this._elements.icon);
        var label = this._elements.label; // Remove it so we can process children

        if (label) {
          label.remove();
        } // Move any remaining elements into the content sub-component


        while (this.firstChild) {
          var child = this.firstChild;

          if (child.nodeType === Node.TEXT_NODE || child.nodeType === Node.ELEMENT_NODE && child.getAttribute('handle') !== 'icon') {
            label.appendChild(child);
          } else {
            this.removeChild(child);
          }
        } // Add template to component


        this.appendChild(fragment); // Call the content zone insert

        this.label = label;
      }
    }, {
      key: "icon",
      get: function get() {
        return this._elements.icon.icon;
      },
      set: function set(value) {
        this._elements.icon.icon = value;
      }
      /**
       The solution's label content zone.
        @type {ShellSolutionLabel}
       @contentzone
       */

    }, {
      key: "label",
      get: function get() {
        return this._getContentZone(this._elements.label);
      },
      set: function set(value) {
        this._setContentZone('label', value, {
          handle: 'label',
          tagName: 'coral-shell-solution-label',
          insert: function insert(content) {
            this.appendChild(content);
          }
        });
      }
      /**
       Whether a solution is linked or not
        @type {Boolean}
       @default false
       @htmlattribute linked
       @htmlattributereflected
       */

    }, {
      key: "linked",
      get: function get() {
        return this._linked || false;
      },
      set: function set(value) {
        this._linked = transform.booleanAttr(value);

        this._reflectAttribute('linked', this._linked);

        this.classList.toggle("".concat(CLASSNAME$1f, "--linked"), this._linked);
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-shell-solution-label': 'label'
        };
      }
      /** @ignore */

    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(ShellSolution), "observedAttributes", this).concat(['icon', 'linked']);
      }
    }]);

    return ShellSolution;
  }(BaseComponent(HTMLAnchorElement));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Shell.Solution.Label
   @classdesc Shell's Solution label component
   @htmltag coral-shell-solution-label
   @return {HTMLElement}
   */
  var ShellSolutionLabel = (function () {
    return document.createElement('coral-shell-solution-label');
  });

  var template$R = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var data = data_0 = typeof data_0 === "undefined" ? {} : data_0;
    data = data_0;
    var labelId = data.commons.getUID();
    data_0 = data;
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    var el2 = this["container"] = document.createElement("div");
    el2.setAttribute("handle", "container");
    var el3 = document.createTextNode("\n  ");
    el2.appendChild(el3);
    var el4 = document.createElement("label");
    el4.className += " u-coral-screenReaderOnly";
    el4.id = labelId;
    el4.textContent = data_0["i18n"]["get"]('Search Organizations');
    el2.appendChild(el4);
    var el5 = document.createTextNode("\n  ");
    el2.appendChild(el5);
    var el6 = this["search"] = document.createElement("coral-search");
    el6.className += " _coral-Shell-orgSwitcher-search";
    el6.setAttribute("handle", "search");
    el6.setAttribute("placeholder", data_0["i18n"]["get"]('Search Organizations'));
    el6.setAttribute("labelledby", labelId);
    el2.appendChild(el6);
    var el7 = document.createTextNode("\n  ");
    el2.appendChild(el7);
    var el8 = this["items"] = document.createElement("div");
    el8.className += " _coral-Shell-orgSwitcher-items";
    el8.setAttribute("handle", "items");
    el2.appendChild(el8);
    var el9 = document.createTextNode("\n  ");
    el2.appendChild(el9);
    var el10 = this["resultMessage"] = document.createElement("div");
    el10.className += " _coral-Shell-orgSwitcher-resultMessage";
    el10.setAttribute("handle", "resultMessage");
    el10.setAttribute("hidden", "");
    var el11 = document.createTextNode("\n    ");
    el10.appendChild(el11);
    var el12 = document.createElement("div");
    el12.className += " _coral-Shell-orgSwitcher-resultMessage-container";
    var el13 = document.createTextNode("\n      ");
    el12.appendChild(el13);
    var el14 = document.createElement("h2");
    el14.className += " coral-Heading coral-Heading--2";
    el14.textContent = data_0["i18n"]["get"]('No organizations found.');
    el12.appendChild(el14);
    var el15 = document.createTextNode("\n    ");
    el12.appendChild(el15);
    el10.appendChild(el12);
    var el16 = document.createTextNode("\n  ");
    el10.appendChild(el16);
    el2.appendChild(el10);
    var el17 = document.createTextNode("\n");
    el2.appendChild(el17);
    frag.appendChild(el2);
    var el18 = document.createTextNode("\n");
    frag.appendChild(el18);
    return frag;
  };

  var CLASSNAME$1g = '_coral-Shell-orgSwitcher';
  /**
   Minimum number of entries required to show search control.

   @type {Number}
   @ignore
   */

  var SEARCH_VISIBILITY_THRESHOLD = 6;
  /**
   @class Coral.Shell.OrgSwitcher
   @classdesc A Shell OrgSwitcher component
   @htmltag coral-shell-orgswitcher
   @extends {List}
   */

  var ShellOrgSwitcher = /*#__PURE__*/function (_List) {
    _inherits(ShellOrgSwitcher, _List);

    var _super = _createSuper(ShellOrgSwitcher);

    /** @ignore */
    function ShellOrgSwitcher() {
      var _this;

      _classCallCheck(this, ShellOrgSwitcher);

      _this = _super.call(this); // Events

      _this._delegateEvents({
        'coral-search:clear': '_showAll',
        'coral-search:input': '_performSearch',
        'coral-search:submit': '_selectFirst',
        'coral-shell-organization:change': '_onOrganizationChange',
        // private
        'coral-shell-organization:_selectedchanged': '_onItemSelectedChanged',
        'coral-shell-suborganization:_selectedchanged': '_onSubItemSelectedChanged'
      }); // Templates


      _this._elements = {
        footer: _this.querySelector('coral-shell-orgswitcher-footer') || document.createElement('coral-shell-orgswitcher-footer')
      };
      template$R.call(_this._elements, {
        commons: commons,
        i18n: i18n
      }); // Used for eventing

      _this._oldSelection = null; // Item handling

      _this.items._startHandlingItems(true);

      return _this;
    }
    /**
     The item collection.
      @type {SelectableCollection}
     @readonly
     */


    _createClass(ShellOrgSwitcher, [{
      key: "_onItemSelectedChanged",

      /** @private */
      value: function _onItemSelectedChanged(event) {
        event.stopImmediatePropagation();
        var item = event.target;

        this._validateSelection(item);
      }
      /** @private */

    }, {
      key: "_onSubItemSelectedChanged",
      value: function _onSubItemSelectedChanged(event) {
        var _this2 = this;

        event.stopImmediatePropagation();
        var item = event.target; // If a sub organization is selected, deselect all selected organization items

        if (item.hasAttribute('selected')) {
          this.items._getAllSelected().forEach(function (itemElement) {
            if (itemElement.tagName === 'CORAL-SHELL-ORGANIZATION') {
              _this2._preventTriggeringEvents = true;
              itemElement.removeAttribute('selected');
            }
          });

          this._preventTriggeringEvents = false;
        }
      }
      /** @private */

    }, {
      key: "_onOrganizationChange",
      value: function _onOrganizationChange() {
        this._triggerChangeEvent();
      }
      /**
       Returns the selected workspace.
        @type {HTMLElement}
       @readonly
       */

    }, {
      key: "_selectFirst",

      /** @private */
      value: function _selectFirst(event) {
        event.stopPropagation();
        var first = this.items.first();

        if (first) {
          first.setAttribute('selected', '');
        }
      }
      /** @private */

    }, {
      key: "_validateSelection",
      value: function _validateSelection(item) {
        // gets the current selection
        var selection = this.items._getAllSelected();

        var selectionCount = selection.length;

        if (selectionCount > 1) {
          for (var i = 0; i < selectionCount; i++) {
            if (selection[i] !== item) {
              // Don't trigger change events
              this._preventTriggeringEvents = true;
              selection[i].removeAttribute('selected');
            }
          } // We can trigger change events again


          this._preventTriggeringEvents = false;
        }

        this._triggerChangeEvent();
      }
      /** @private */

    }, {
      key: "_triggerChangeEvent",
      value: function _triggerChangeEvent() {
        var selectedItem = this.selectedItem;
        var oldSelection = this._oldSelection;

        if (!this._preventTriggeringEvents && selectedItem !== oldSelection) {
          this.trigger('coral-shell-orgswitcher:change', {
            oldSelection: oldSelection,
            selection: selectedItem
          });
          this._oldSelection = selectedItem;
        }
      }
      /** @private */

    }, {
      key: "_showAll",
      value: function _showAll(event) {
        event.stopPropagation();
        this._elements.resultMessage.hidden = true; // Show all items

        this.items.getAll().forEach(function (item) {
          item.hidden = false;

          if (item.items) {
            // Show all sub-items
            item.items.getAll().forEach(function (itemElement) {
              itemElement.hidden = false;
            });
          }
        });
      }
      /** @private */

    }, {
      key: "_performSearch",
      value: function _performSearch(event) {
        event.stopPropagation();

        var searchTerm = this._elements.search.value.toLowerCase();

        this._elements.resultMessage.hidden = true; // Hide items that don't match

        var resultCount = 0;
        this.items.getAll().forEach(function (item) {
          var matched = item.content.textContent.toLowerCase().indexOf(searchTerm) !== -1;
          var childMatched = false;

          if (item.items) {
            item.items.getAll().forEach(function (itemElement) {
              var elementMatch = itemElement.content.textContent.toLowerCase().indexOf(searchTerm) !== -1;
              childMatched = childMatched || elementMatch;
              itemElement.hidden = !elementMatch;
            });
          }

          matched = matched || childMatched;
          item.hidden = !matched;

          if (matched) {
            resultCount++;
          }
        });

        if (resultCount === 0) {
          this._elements.resultMessage.hidden = false;
        }
      }
      /** @private */

    }, {
      key: "_moveItems",
      value: function _moveItems() {
        var _this3 = this;

        this.setAttribute('id', this.id || commons.getUID());
        Array.prototype.forEach.call(this.querySelectorAll("#".concat(this.id, " > coral-shell-organization")), function (item) {
          _this3._elements.items.appendChild(item);
        });
      }
      /** @private */

    }, {
      key: "_onCollectionChange",
      value: function _onCollectionChange(item) {
        // Move all items into the right place
        this._moveItems(); // Select the last selected item


        this._validateSelection(item); // if mincountforsearch is set and number of organizations are less than or equal to it, hide the search


        if (this.items.length <= SEARCH_VISIBILITY_THRESHOLD) {
          this._elements.search.hide();
        } else {
          this._elements.search.show();
        }
      }
    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(ShellOrgSwitcher.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1g); // Move the items into the right place

        this._moveItems();

        var container = this.querySelector('[handle="container"]'); // Support cloneNode

        if (container) {
          this._elements.container = container;
          this._elements.items = this.querySelector('._coral-Shell-orgSwitcher-items');
          this._elements.search = this.querySelector('._coral-Shell-orgSwitcher-search');
          this._elements.resultMessage = this.querySelector('._coral-Shell-orgSwitcher-resultMessage');
          this._items._container = this._elements.items;
        } else {
          this.appendChild(this._elements.container);
        } // Call content zone insert


        this.footer = this._elements.footer; // Don't trigger events once connected

        this._preventTriggeringEvents = true;

        this._validateSelection();

        this._preventTriggeringEvents = false;
        this._oldSelection = this.selectedItem;
      }
      /**
       Triggered when the {@link ShellOrgSwitcher} selected organization has changed.
        @typedef {CustomEvent} coral-shell-orgswitcher:change
        @property {HTMLElement} detail.oldSelection
       The prior selected organization item.
       @property {HTMLElement} detail.selection
       The newly selected organization item.
       */

    }, {
      key: "items",
      get: function get() {
        // Construct the collection on first request:
        if (!this._items) {
          this._items = new SelectableCollection({
            host: this,
            itemTagName: 'coral-shell-organization',
            itemSelector: 'coral-shell-organization, coral-shell-suborganization',
            container: this._elements.items,
            onItemAdded: this._onCollectionChange,
            onItemRemoved: this._onCollectionChange
          });
        }

        return this._items;
      }
      /**
       The search field placeholder.
        @default ''
       @type {String}
       @htmlattribute placeholder
       */

    }, {
      key: "placeholder",
      get: function get() {
        return this._elements.search.placeholder;
      },
      set: function set(value) {
        this._elements.search.placeholder = value;
      }
      /**
       Content zone where the buttons are located.
        @type {ShellOrgSwitcherFooter}
       @contentzone
       */

    }, {
      key: "footer",
      get: function get() {
        return this._getContentZone(this._elements.footer);
      },
      set: function set(value) {
        this._setContentZone('content', value, {
          handle: 'footer',
          tagName: 'coral-shell-orgswitcher-footer',
          insert: function insert(content) {
            this.appendChild(content);
          }
        });
      }
      /** @private */

    }, {
      key: "_itemTagName",
      get: function get() {
        // Used for Collection
        return 'coral-shell-organization';
      }
    }, {
      key: "selectedItem",
      get: function get() {
        return this.items._getLastSelected();
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-shell-orgswitcher-footer': 'footer'
        };
      }
      /** @ignore */

    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(ShellOrgSwitcher), "observedAttributes", this).concat(['placeholder']);
      }
    }]);

    return ShellOrgSwitcher;
  }(List);

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Shell.OrgSwitcher.Footer
   @classdesc Shell's OrgSwitcher footer component
   @htmltag coral-shell-orgswitcher-footer
   @return {HTMLElement}
   */
  var ShellOrgSwitcherFooter = (function () {
    return document.createElement('coral-shell-orgswitcher-footer');
  });

  var template$S = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var data = data_0 = typeof data_0 === "undefined" ? {} : data_0;
    var el0 = this["checkmark"] = document.createElement("span");
    el0.setAttribute("handle", "checkmark");
    el0.setAttribute("hidden", "");
    el0.className += " _coral-Shell-orgSwitcher-checkmark";
    var el1 = document.createTextNode("\n  ");
    el0.appendChild(el1);
    data = data_0;
    this.checkmark.innerHTML = data.Icon._renderSVG('spectrum-css-icon-CheckmarkMedium', ['_coral-UIIcon-CheckmarkMedium', '_coral-Menu-checkmark']);
    data_0 = data;
    var el3 = document.createTextNode("\n");
    el0.appendChild(el3);
    frag.appendChild(el0);
    var el4 = document.createTextNode("\n");
    frag.appendChild(el4);
    var el5 = this["items"] = document.createElement("div");
    el5.setAttribute("handle", "items");
    el5.className += " _coral-Shell-orgSwitcher-subitems";
    frag.appendChild(el5);
    var el6 = document.createTextNode("\n\n");
    frag.appendChild(el6);
    return frag;
  };

  var CLASSNAME$1h = '_coral-Shell-orgSwitcher-item';
  /**
   @class Coral.Shell.Organization
   @classdesc A Shell Organization component
   @htmltag coral-shell-organization
   @extends {ListItem}
   */

  var ShellOrganization = /*#__PURE__*/function (_List$Item) {
    _inherits(ShellOrganization, _List$Item);

    var _super = _createSuper(ShellOrganization);

    /** @ignore */
    function ShellOrganization() {
      var _this;

      _classCallCheck(this, ShellOrganization);

      _this = _super.call(this); // Events

      _this._delegateEvents({
        'click': '_onClick',
        'key:enter': '_onClick',
        'key:space': '_onClick',
        // Private
        'coral-shell-suborganization:_selectedchanged': '_onItemSelectedChanged'
      });

      var template = {};
      template$S.call(template, {
        Icon: Icon
      });
      commons.extend(_this._elements, template); // Used for eventing

      _this._oldSelection = null; // Item handling

      _this.items._startHandlingItems(true);

      return _this;
    }
    /**
     The item collection.
      @type {SelectableCollection}
     @readonly
     */


    _createClass(ShellOrganization, [{
      key: "_onItemSelectedChanged",

      /** @private */
      value: function _onItemSelectedChanged(event) {
        // Validate the selection only if we're an organization
        if (this.tagName === 'CORAL-SHELL-ORGANIZATION') {
          // Don't stop propagation here as the orgSwitcher listens to the event too
          var item = event.target;

          this._validateSelection(item);
        }
      }
      /** @private */

    }, {
      key: "_onItemAdded",
      value: function _onItemAdded(item) {
        // Move all items into the right place
        this._moveItems();

        this._validateSelection(item);
      }
      /** @private */

    }, {
      key: "_onItemRemoved",
      value: function _onItemRemoved(item) {
        this._setParent();

        this._validateSelection(item);
      }
      /** @private */

    }, {
      key: "_validateSelection",
      value: function _validateSelection(item) {
        // gets the current selection
        var selection = this.items._getAllSelected();

        var selectionCount = selection.length;

        if (selectionCount > 1) {
          for (var i = 0; i < selectionCount; i++) {
            if (selection[i] !== item) {
              // Don't trigger change events
              this._preventTriggeringEvents = true;
              selection[i].removeAttribute('selected');
            }
          } // We can trigger change events again


          this._preventTriggeringEvents = false;
        }

        this._triggerChangeEvent();
      }
      /** @private */

    }, {
      key: "_triggerChangeEvent",
      value: function _triggerChangeEvent() {
        var selectedItem = this.selectedItem;
        var oldSelection = this._oldSelection;

        if (!this._preventTriggeringEvents && selectedItem !== oldSelection) {
          this.trigger("".concat(this.tagName.toLowerCase(), ":change"), {
            oldSelection: oldSelection,
            selection: selectedItem
          });
          this._oldSelection = selectedItem;
        }
      }
      /** @private */

    }, {
      key: "_moveItems",
      value: function _moveItems() {
        var _this2 = this;

        Array.prototype.forEach.call(this.querySelectorAll('coral-shell-suborganization'), function (item) {
          if (!_this2._elements.items.contains(item)) {
            _this2._elements.items.appendChild(item);
          }
        });
      }
      /** @private */

    }, {
      key: "_setParent",
      value: function _setParent() {
        var hasChildren = this.items.length !== 0;

        if (hasChildren) {
          this.removeAttribute('role');
          this.removeAttribute('tabindex');
        } else {
          // Be accessible
          this.setAttribute('role', 'button');
          this.setAttribute('tabindex', 0);
        }

        this.classList.toggle('is-parent', hasChildren);
      }
      /** @private */

    }, {
      key: "_onClick",
      value: function _onClick() {
        if (this.items.length !== 0) {
          // You can't be selected if you have sub-organizations
          return;
        }

        this.selected = true;
      }
      /** @ignore */

    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(ShellOrganization.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1h); // Move items into the right place

        this._moveItems();

        this.setAttribute('id', this.id || commons.getUID()); // Support cloneNode

        var items = this.querySelector("#".concat(this.id, " > ._coral-Shell-orgSwitcher-subitems"));

        if (items) {
          items.remove();
        }

        var checkmark = this.querySelector("#".concat(this.id, " > ._coral-Shell-orgSwitcher-checkmark"));

        if (checkmark) {
          checkmark.remove();
        } // Render template


        var frag = document.createDocumentFragment();
        frag.appendChild(this._elements.checkmark);
        frag.appendChild(this._elements.items);
        this.appendChild(frag); // Don't trigger events once connected

        this._preventTriggeringEvents = true;

        this._validateSelection();

        this._preventTriggeringEvents = false;
        this._oldSelection = this.selectedItem;

        this._setParent();
      }
      /**
       Triggered when a {@link ShellOrganization} selection changed.
        @typedef {CustomEvent} coral-shell-organization:_selectedchanged
        @private
       */

    }, {
      key: "items",
      get: function get() {
        // Construct the collection on first request:
        if (!this._items) {
          this._items = new SelectableCollection({
            host: this,
            itemTagName: 'coral-shell-suborganization',
            container: this._elements.items,
            onItemAdded: this._onItemAdded,
            onItemRemoved: this._onItemRemoved
          });
        }

        return this._items;
      }
      /**
       Returns the selected workspace.
        @type {HTMLElement}
       @readonly
       */

    }, {
      key: "selectedItem",
      get: function get() {
        return this.items._getLastSelected();
      }
      /**
       Whether this organization is selected.
        @type {Boolean}
       @default false
       @htmlattribute selected
       @htmlattributereflected
       */

    }, {
      key: "selected",
      get: function get() {
        return this._selected || false;
      },
      set: function set(value) {
        this._selected = transform.booleanAttr(value);

        this._reflectAttribute('selected', this._selected);

        this.setAttribute('aria-selected', this._selected);
        this.classList.toggle('is-selected', this._selected);
        this._elements.checkmark.hidden = !this._selected;

        if (this.items) {
          var selectedItem = this.selectedItem;
          this.classList.toggle('is-child-selected', selectedItem);

          if (!this._selected && selectedItem) {
            // Always de-select children when de-selected
            selectedItem.removeAttribute('selected');
          }
        }

        this.trigger("".concat(this.tagName.toLowerCase(), ":_selectedchanged"));
      }
      /**
       The name of this organization.
        @type {String}
       @default ""
       @htmlattribute name
       @htmlattributereflected
       */

    }, {
      key: "name",
      get: function get() {
        return this._name || '';
      },
      set: function set(value) {
        this._name = transform.string(value);

        this._reflectAttribute('name', this._name);
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(ShellOrganization), "observedAttributes", this).concat(['name', 'selected']);
      }
    }]);

    return ShellOrganization;
  }(List.Item);

  var CLASSNAME$1i = '_coral-Shell-orgSwitcher-subitem';
  /**
   @class Coral.Shell.Suborganization
   @classdesc A Shell Sub organization component
   @htmltag coral-shell-suborganization
   @extends {ShellOrganization}
   */

  var ShellSuborganization = /*#__PURE__*/function (_ShellOrganization) {
    _inherits(ShellSuborganization, _ShellOrganization);

    var _super = _createSuper(ShellSuborganization);

    function ShellSuborganization() {
      _classCallCheck(this, ShellSuborganization);

      return _super.apply(this, arguments);
    }

    _createClass(ShellSuborganization, [{
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(ShellSuborganization.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1i); // Set the icon size

        this._elements.icon.size = Icon.size.SMALL; // Be accessible

        this.setAttribute('role', 'button');
        this.setAttribute('tabindex', 0);
      }
    }]);

    return ShellSuborganization;
  }(ShellOrganization);

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons.extend(strings, {
    'coral-component-shell-help': helpTranslations,
    'coral-component-shell-orgswitcher': orgSwitcherTranslations
  }); // Expose component on the Coral namespace

  commons._define('coral-shell-header', ShellHeader);

  commons._define('coral-shell-homeanchor', ShellHomeAnchor, {
    extends: 'a'
  });

  commons._define('coral-shell-help-item', ShellHelpItem, {
    extends: 'a'
  });

  commons._define('coral-shell-help', ShellHelp);

  commons._define('coral-shell-menubar-item', ShellMenuBarItem);

  commons._define('coral-shell-menubar', ShellMenuBar);

  commons._define('coral-shell-menu', ShellMenu);

  commons._define('coral-shell-user', ShellUser);

  commons._define('coral-shell-workspace', ShellWorkspace, {
    extends: 'a'
  });

  commons._define('coral-shell-workspaces', ShellWorkspaces);

  commons._define('coral-shell-solution', ShellSolution, {
    extends: 'a'
  });

  commons._define('coral-shell-solutions', ShellSolutions);

  commons._define('coral-shell-solutionswitcher', ShellSolutionSwitcher);

  commons._define('coral-shell-suborganization', ShellSuborganization);

  commons._define('coral-shell-organization', ShellOrganization);

  commons._define('coral-shell-orgswitcher', ShellOrgSwitcher);

  commons._define('coral-shell', Shell);

  Shell.Content = ShellContent;
  Shell.Header = ShellHeader;
  Shell.HomeAnchor = ShellHomeAnchor;
  Shell.HomeAnchor.Label = ShellHomeAnchorLabel;
  Shell.Help = ShellHelp;
  Shell.Help.Item = ShellHelpItem;
  Shell.Help.Separator = ShellHelpSeparator;
  Shell.Menu = ShellMenu;
  Shell.MenuBar = ShellMenuBar;
  Shell.MenuBar.Item = ShellMenuBarItem;
  Shell.User = ShellUser;
  Shell.User.Content = ShellUserContent;
  Shell.User.Footer = ShellUserFooter;
  Shell.User.Heading = ShellUserHeading;
  Shell.User.Name = ShellUserName;
  Shell.User.Subheading = ShellUserSubheading;
  Shell.Workspaces = ShellWorkspaces;
  Shell.Workspace = ShellWorkspace;
  Shell.SolutionSwitcher = ShellSolutionSwitcher;
  Shell.Solutions = ShellSolutions;
  Shell.Solutions.Header = ShellSolutionsHeader;
  Shell.Solution = ShellSolution;
  Shell.Solution.Label = ShellSolutionLabel;
  Shell.OrgSwitcher = ShellOrgSwitcher;
  Shell.OrgSwitcher.Footer = ShellOrgSwitcherFooter;
  Shell.Organization = ShellOrganization;
  Shell.Suborganization = ShellSuborganization;

  var CLASSNAME$1j = '_coral-SideNav';

  var isLevel = function isLevel(node) {
    return node.nodeName === 'CORAL-SIDENAV-LEVEL';
  };

  var isHeading = function isHeading(node) {
    return node.nodeName === 'CORAL-SIDENAV-HEADING';
  };

  var isItem = function isItem(node) {
    return node.nodeName === 'A' && node.getAttribute('is') === 'coral-sidenav-item';
  };
  /**
   Enumeration for {@link SideNav} variants.

   @typedef {Object} SideNavVariantEnum

   @property {String} DEFAULT
   A default sidenav.
   @property {String} MULTI_LEVEL
   A sidenav with multiple levels of indentation.
   */


  var variant$j = {
    DEFAULT: 'default',
    MULTI_LEVEL: 'multilevel'
  };
  /**
   @class Coral.SideNav
   @classdesc A Side Navigation component to navigate the entire content of a product or a section.
   These can be used for a single level or a multi-level navigation.
   @htmltag coral-sidenav
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var SideNav = /*#__PURE__*/function (_BaseComponent) {
    _inherits(SideNav, _BaseComponent);

    var _super = _createSuper(SideNav);

    /** @ignore */
    function SideNav() {
      var _this;

      _classCallCheck(this, SideNav);

      _this = _super.call(this); // Attach events

      _this._delegateEvents({
        // Interaction
        'click a[is="coral-sidenav-item"]': '_onItemClick',
        // Accessibility
        'capture:focus a[is="coral-sidenav-item"].focus-ring': '_onItemFocusIn',
        'capture:blur a[is="coral-sidenav-item"]': '_onItemFocusOut',
        // Private
        'coral-sidenav-item:_selectedchanged': '_onItemSelectedChanged'
      }); // Used for eventing


      _this._oldSelection = null; // Level Collection

      _this._levels = _this.getElementsByTagName('coral-sidenav-level'); // Heading Collection

      _this._headings = _this.getElementsByTagName('coral-sidenav-heading'); // Init the collection mutation observer

      _this.items._startHandlingItems(true); // Initialize content MO


      _this._observer = new MutationObserver(_this._handleMutations.bind(_assertThisInitialized(_this)));

      _this._observer.observe(_assertThisInitialized(_this), {
        childList: true,
        subtree: true
      });

      return _this;
    }
    /**
     The Collection Interface that allows interacting with the items that the component contains.
      @type {Collection}
     @readonly
     */


    _createClass(SideNav, [{
      key: "_onItemClick",
      value: function _onItemClick(event) {
        var item = event.matchedTarget;

        if (!item.selected) {
          item.selected = true;
        }
      }
    }, {
      key: "_onItemFocusIn",
      value: function _onItemFocusIn(event) {
        var item = event.matchedTarget;

        item._elements.container.classList.add('focus-ring');
      }
    }, {
      key: "_onItemFocusOut",
      value: function _onItemFocusOut(event) {
        var item = event.matchedTarget;

        item._elements.container.classList.remove('focus-ring');
      }
    }, {
      key: "_onItemSelectedChanged",
      value: function _onItemSelectedChanged(event) {
        event.stopImmediatePropagation();

        this._validateSelection(event.target);
      }
    }, {
      key: "_validateSelection",
      value: function _validateSelection(item) {
        var _this2 = this;

        var selectedItems = this.items._getAllSelected(); // Last selected item wins if multiple selection while not allowed


        item = item || selectedItems[selectedItems.length - 1]; // Deselect other selected items

        if (item && item.hasAttribute('selected') && selectedItems.length > 1) {
          selectedItems.forEach(function (selectedItem) {
            if (selectedItem !== item) {
              // Don't trigger change events
              _this2._preventTriggeringEvents = true;
              selectedItem.removeAttribute('selected');
            }
          }); // We can trigger change events again

          this._preventTriggeringEvents = false;
        } // Expand multi level


        this._expandLevels(); // Notify of change


        this._triggerChangeEvent();
      }
    }, {
      key: "_expandLevels",
      value: function _expandLevels() {
        var selectedItem = this.selectedItem;

        if (selectedItem) {
          var level = selectedItem.closest('coral-sidenav-level'); // Expand until root

          while (level) {
            level.setAttribute('_expanded', 'on');
            var prev = level.previousElementSibling;

            if (prev && prev.matches('a[is="coral-sidenav-item"]')) {
              prev.setAttribute('aria-expanded', 'true');
            }

            level = level.parentNode && level.parentNode.closest('coral-sidenav-level');
          } // Expand corresponding item level


          level = selectedItem.nextElementSibling;

          if (level && level.tagName === 'CORAL-SIDENAV-LEVEL') {
            level.setAttribute('_expanded', 'on');
            selectedItem.setAttribute('aria-expanded', 'true');
          }
        }
      }
    }, {
      key: "_triggerChangeEvent",
      value: function _triggerChangeEvent() {
        var selectedItem = this.selectedItem;
        var oldSelection = this._oldSelection;

        if (!this._preventTriggeringEvents && selectedItem !== oldSelection) {
          this.trigger('coral-sidenav:change', {
            oldSelection: oldSelection,
            selection: selectedItem
          });
          this._oldSelection = selectedItem;
        }
      }
    }, {
      key: "_syncLevel",
      value: function _syncLevel(el, isRemoved) {
        if (isRemoved) {
          if (el.id && isLevel(el)) {
            var item = this.querySelector("a[is=\"coral-sidenav-item\"][aria-controls=\"".concat(el.id, "\"]"));
            item && item.removeAttribute('aria-controls');
          } else if (el.id && (isHeading(el) || isItem(el))) {
            var level = this.querySelector("coral-sidenav-level[aria-labelledby=\"".concat(el.id, "\"]"));
            level && level.removeAttribute('aria-labelledby');

            this._syncLevel(level);
          }
        } else if (isLevel(el)) {
          var prev = el.previousElementSibling;

          if (prev && (isHeading(prev) || isItem(prev))) {
            prev.id = prev.id || commons.getUID();
            el.setAttribute('aria-labelledby', prev.id);

            if (isItem(prev)) {
              el.id = el.id || commons.getUID();
              prev.setAttribute('aria-controls', el.id);
            }
          }
        } else if (isHeading(el) || isItem(el)) {
          var next = el.nextElementSibling;

          if (next && isLevel(next)) {
            el.id = el.id || commons.getUID();
            next.setAttribute('aria-labelledby', el.id);

            if (isItem(el)) {
              next.id = next.id || commons.getUID();
              el.setAttribute('aria-controls', next.id);
            }
          }
        }
      }
    }, {
      key: "_syncHeading",
      value: function _syncHeading(heading) {
        heading.classList.add("".concat(CLASSNAME$1j, "-heading"));
        heading.setAttribute('role', 'heading');
      }
    }, {
      key: "_handleMutations",
      value: function _handleMutations(mutations) {
        var _this3 = this;

        mutations.forEach(function (mutation) {
          // Sync added levels and headings
          for (var i = 0; i < mutation.addedNodes.length; i++) {
            var addedNode = mutation.addedNodes[i]; // a11y

            _this3._syncLevel(addedNode); // a11y


            if (isHeading(addedNode)) {
              _this3._syncHeading(addedNode);
            }

            if (isLevel(addedNode)) {
              _this3._validateSelection(addedNode.querySelector('a[is="coral-sidenav-item"][selected]'));
            }
          } // Sync removed levels


          for (var k = 0; k < mutation.removedNodes.length; k++) {
            var removedNode = mutation.removedNodes[k];

            _this3._syncLevel(removedNode, true);

            if (isLevel(removedNode)) {
              _this3._validateSelection();
            }
          }
        });
      }
      /**
       Returns {@link SideNav} variants.
        @return {SideNavVariantEnum}
       */

    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(SideNav.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1j); // Default reflected attributes

        if (!this._variant) {
          this.variant = variant$j.DEFAULT;
        } // a11y


        for (var i = 0; i < this._levels.length; i++) {
          this._syncLevel(this._levels[i]);
        } // a11y


        for (var _i = 0; _i < this._headings.length; _i++) {
          this._syncHeading(this._headings[_i]);
        } // Don't trigger events once connected


        this._preventTriggeringEvents = true;

        this._validateSelection();

        this._preventTriggeringEvents = false;
        this._oldSelection = this.selectedItem;
      }
      /**
       Triggered when {@link SideNav} selected item has changed.
        @typedef {CustomEvent} coral-sidenav:change
        @property {SideNavItem} detail.oldSelection
       The prior selected item.
       @property {SideNavItem} detail.selection
       The newly selected item.
       */

    }, {
      key: "items",
      get: function get() {
        // just init on demand
        if (!this._items) {
          this._items = new SelectableCollection({
            host: this,
            itemTagName: 'coral-sidenav-item',
            itemBaseTagName: 'a',
            onItemAdded: this._validateSelection,
            onItemRemoved: this._validateSelection
          });
        }

        return this._items;
      }
      /**
       Returns the first selected item in the sidenav. The value <code>null</code> is returned if no element is
       selected.
        @type {SideNavItem}
       @readonly
       */

    }, {
      key: "selectedItem",
      get: function get() {
        return this.items._getFirstSelected();
      }
      /**
       The sidenav's variant. See {@link SideNavVariantEnum}.
        @type {String}
       @default SideNavVariantEnum.DEFAULT
       @htmlattribute variant
       @htmlattributereflected
       */

    }, {
      key: "variant",
      get: function get() {
        return this._variant || variant$j.DEFAULT;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        this._variant = validate.enumeration(variant$j)(value) && value || variant$j.DEFAULT;

        this._reflectAttribute('variant', this._variant);

        this.classList.toggle("".concat(CLASSNAME$1j, "--multiLevel"), this._variant === variant$j.MULTI_LEVEL);

        if (this.variant === variant$j.MULTI_LEVEL) {
          // Don't hide the selected item level
          var selectedItem = this.selectedItem;
          var ignoreLevel = selectedItem && selectedItem.parentNode; // Hide every other level that doesn't contain the selected item

          for (var i = 0; i < this._levels.length; i++) {
            if (this._levels[i] !== ignoreLevel) {
              this._levels[i].setAttribute('_expanded', 'off');
            }
          }
        }
      }
    }], [{
      key: "variant",
      get: function get() {
        return variant$j;
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(SideNav), "observedAttributes", this).concat(['variant']);
      }
    }]);

    return SideNav;
  }(BaseComponent(HTMLElement));

  var template$T = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["container"] = document.createElement("div");
    el0.className += " _coral-SideNav-itemLink";
    el0.setAttribute("handle", "container");
    var el1 = document.createTextNode("\n  ");
    el0.appendChild(el1);
    var el2 = this["icon"] = document.createElement("coral-icon");
    el2.setAttribute("hidden", "");
    el2.className += " _coral-UIIcon-Star _coral-SideNav-itemIcon";
    el2.setAttribute("handle", "icon");
    el0.appendChild(el2);
    var el3 = document.createTextNode("\n");
    el0.appendChild(el3);
    frag.appendChild(el0);
    var el4 = document.createTextNode("\n");
    frag.appendChild(el4);
    return frag;
  };

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var CLASSNAME$1k = '_coral-SideNav-item';
  /**
   @class Coral.SideNav.Item
   @classdesc A SideNav Item component.
   @htmltag coral-sidenav-item
   @extends {HTMLAnchorElement}
   @extends {BaseComponent}
   */

  var SideNavItem = /*#__PURE__*/function (_BaseLabellable) {
    _inherits(SideNavItem, _BaseLabellable);

    var _super = _createSuper(SideNavItem);

    /** @ignore */
    function SideNavItem() {
      var _thisSuper, _this;

      _classCallCheck(this, SideNavItem);

      _this = _super.call(this); // Prepare templates

      _this._elements = {
        content: _this.querySelector('coral-sidenav-item-content') || document.createElement('coral-sidenav-item-content')
      };
      template$T.call(_this._elements);

      _get((_thisSuper = _assertThisInitialized(_this), _getPrototypeOf(SideNavItem.prototype)), "_observeLabel", _thisSuper).call(_thisSuper);

      return _this;
    }
    /**
     The content of the sidenav item.
      @type {SideNavItemContent}
     @contentzone
     */


    _createClass(SideNavItem, [{
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(SideNavItem.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1k); // Create a fragment

        var fragment = document.createDocumentFragment(); // Render the main template

        fragment.appendChild(this._elements.container);
        var content = this._elements.content; // Remove it so we can process children

        if (content.parentNode) {
          content.parentNode.removeChild(content);
        } // Process remaining elements as necessary


        while (this.firstChild) {
          var child = this.firstChild;

          if (child.nodeType === Node.TEXT_NODE || child.nodeType === Node.ELEMENT_NODE && child.getAttribute('handle') !== 'container') {
            // Add non-template elements to the content
            content.appendChild(child);
          } else {
            // Remove anything else
            this.removeChild(child);
          }
        } // Add the frag to the component


        this.appendChild(fragment); // Assign the content zones, moving them into place in the process

        this.content = content;
      }
    }, {
      key: "content",
      get: function get() {
        return this._getContentZone(this._elements.content);
      },
      set: function set(value) {
        this._setContentZone('content', value, {
          handle: 'content',
          tagName: 'coral-sidenav-item-content',
          insert: function insert(content) {
            this._elements.container.appendChild(content);
          }
        });
      }
      /**
       Specifies the icon name used inside the item. See {@link Icon} for valid icon names.
        @type {String}
       @default ""
       @htmlattribute icon
       */

    }, {
      key: "icon",
      get: function get() {
        return this._elements.icon.icon;
      },
      set: function set(value) {
        this._elements.icon.icon = value;
        this._elements.icon.hidden = this._elements.icon.icon === '';

        _get(_getPrototypeOf(SideNavItem.prototype), "_toggleIconAriaHidden", this).call(this);
      }
      /**
       Whether the item is selected.
        @type {Boolean}
       @default false
       @htmlattribute selected
       @htmlattributereflected
       */

    }, {
      key: "selected",
      get: function get() {
        return this._selected || false;
      },
      set: function set(value) {
        this._selected = transform.booleanAttr(value);

        this._reflectAttribute('selected', this._selected);

        this.classList.toggle('is-selected', this._selected);
        this.trigger('coral-sidenav-item:_selectedchanged');
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-sidenav-item-label': 'content'
        };
      }
      /** @ignore */

    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(SideNavItem), "observedAttributes", this).concat(['selected', 'icon']);
      }
    }]);

    return SideNavItem;
  }(BaseLabellable(BaseComponent(HTMLAnchorElement)));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.SideNav.Item.Content
   @classdesc The SideNav Item Content
   @htmltag coral-sidenav-item-content
   @return {HTMLElement}
   */
  var SideNavItemContent = (function () {
    return document.createElement('coral-sidenav-item-content');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.SideNav.Heading
   @classdesc The SideNav Heading
   @htmltag coral-sidenav-heading
   @return {HTMLElement}
   */
  var SideNavHeading = (function () {
    return document.createElement('coral-sidenav-heading');
  });

  var CLASSNAME$1l = '_coral-SideNav';
  /**
   @class Coral.SideNav.Level
   @classdesc A SideNav Level component
   @htmltag coral-sidenav-level
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var SideNavLevel = /*#__PURE__*/function (_BaseComponent) {
    _inherits(SideNavLevel, _BaseComponent);

    var _super = _createSuper(SideNavLevel);

    function SideNavLevel() {
      _classCallCheck(this, SideNavLevel);

      return _super.apply(this, arguments);
    }

    _createClass(SideNavLevel, [{
      key: "attributeChangedCallback",

      /** @ignore */
      value: function attributeChangedCallback(name, oldValue, value) {
        var _this = this;

        if (name === '_expanded') {
          var isExpanded = value === 'on';

          if (oldValue === value) {
            return;
          }

          this.classList.toggle('is-expanded', isExpanded); // Do animation in next frame to avoid a forced reflow

          window.requestAnimationFrame(function () {
            // Don't animate on initialization
            if (_this._animate) {
              // Remove height as we want the level to naturally grow if content is added later
              commons.transitionEnd(_this, function () {
                if (isExpanded) {
                  _this.style.height = '';
                } else {
                  _this.hidden = true;
                }
              }); // Force height to enable transition

              if (!isExpanded) {
                _this.style.height = "".concat(_this.scrollHeight, "px");
              } else {
                _this.hidden = false;
              } // We read the offset height to force a reflow, this is needed to start the transition between absolute values
              // https://blog.alexmaccaw.com/css-transitions under Redrawing
              // eslint-disable-next-line no-unused-vars


              var offsetHeight = _this.offsetHeight;
              _this.style.height = isExpanded ? "".concat(_this.scrollHeight, "px") : 0;
            } else {
              // Make sure it's animated next time
              _this._animate = true; // Hide it on initialization if closed

              if (!isExpanded) {
                _this.style.height = 0;
                _this.hidden = true;
              }
            }
          });
        } else {
          _get(_getPrototypeOf(SideNavLevel.prototype), "attributeChangedCallback", this).call(this, name, oldValue, value);
        }
      }
      /** @ignore */

    }, {
      key: "render",
      value: function render() {
        _get(_getPrototypeOf(SideNavLevel.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1l); // a11y

        this.setAttribute('role', 'region');
      }
    }], [{
      key: "observedAttributes",

      /** @ignore */
      get: function get() {
        return _get(_getPrototypeOf(SideNavLevel), "observedAttributes", this).concat(['_expanded']);
      }
    }]);

    return SideNavLevel;
  }(BaseComponent(HTMLElement));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons._define('coral-sidenav-level', SideNavLevel);

  commons._define('coral-sidenav-item', SideNavItem, {
    extends: 'a'
  });

  commons._define('coral-sidenav', SideNav, {
    extends: 'nav'
  });

  SideNav.Item = SideNavItem;
  SideNav.Item.Content = SideNavItemContent;
  SideNav.Heading = SideNavHeading;
  SideNav.Level = SideNavLevel;

  /**
   Enumeration for {@link SplitButton} variants.

   @typedef {Object} SplitButtonVariantEnum

   @property {String} DEFAULT
   The default button look and feel.
   @property {String} CTA
   A button that is meant to grab the user's attention.
   @property {String} SECONDARY
   A button that indicates that the button's action is the secondary action.
   */

  var variant$k = {
    DEFAULT: 'default',
    CTA: 'cta',
    SECONDARY: 'secondary'
  };
  var CLASSNAME$1m = '_coral-SplitButton';
  /**
   @class Coral.SplitButton
   @classdesc A Split Button component composed of an action and a trigger {@link AnchorButton} or {@link Button}.
   These elements should be marked with following attributes:
   - <code>[coral-splitbutton-action]</code> for the main action button.
   - <code>[coral-splitbutton-trigger]</code> for the trigger button.

   @htmltag coral-splitbutton
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var SplitButton = /*#__PURE__*/function (_BaseComponent) {
    _inherits(SplitButton, _BaseComponent);

    var _super = _createSuper(SplitButton);

    /** @ignore */
    function SplitButton() {
      var _this;

      _classCallCheck(this, SplitButton);

      _this = _super.call(this); // Watch for inner button changes

      _this._observer = new MutationObserver(function () {
        _this._updateLeftVariant();

        _this._updateInnerButtons();

        _this._updateInnerButtonsVariant(_this.variant);
      });

      _this._observer.observe(_assertThisInitialized(_this), {
        subtree: true,
        childList: true
      });

      return _this;
    }
    /**
     The button's variant. See {@link SplitButtonVariantEnum}.
      @type {String}
     @default SplitButtonVariantEnum.DEFAULT
     @htmlattribute variant
     @htmlattributereflected
     */


    _createClass(SplitButton, [{
      key: "_getInnerButtons",
      value: function _getInnerButtons() {
        var action = this.querySelector('[coral-splitbutton-action]');
        var trigger = this.querySelector('[coral-splitbutton-trigger]');
        return {
          action: action,
          trigger: trigger
        };
      }
    }, {
      key: "_updateLeftVariant",
      value: function _updateLeftVariant() {
        for (var i = 0; i < this.children.length; i++) {
          var child = this.children[i];

          if (child.hasAttribute('coral-splitbutton-trigger')) {
            this.classList.add('_coral-SplitButton--left');
            return;
          } else if (child.hasAttribute('coral-splitbutton-action')) {
            this.classList.remove('_coral-SplitButton--left');
            return;
          }
        }
      }
    }, {
      key: "_updateInnerButtonsVariant",
      value: function _updateInnerButtonsVariant(variant) {
        var _this$_getInnerButton = this._getInnerButtons(),
            action = _this$_getInnerButton.action,
            trigger = _this$_getInnerButton.trigger;

        if (action) {
          action.setAttribute('variant', variant);
        }

        if (trigger) {
          trigger.setAttribute('variant', variant);
        }
      }
    }, {
      key: "_updateInnerButtons",
      value: function _updateInnerButtons() {
        var _this$_getInnerButton2 = this._getInnerButtons(),
            action = _this$_getInnerButton2.action,
            trigger = _this$_getInnerButton2.trigger;

        if (action) {
          action.classList.add('_coral-SplitButton-action');
        }

        if (trigger) {
          trigger.classList.add('_coral-SplitButton-trigger'); // a11y assume a popover is targeting the trigger

          trigger.setAttribute('aria-haspopup', 'true');

          if (action) {
            action.id = action.id || commons.getUID();
            trigger.setAttribute('aria-labelledby', action.id);
          }
        }
      }
      /**
       Returns {@link SplitButton} variants.
        @return {SplitButtonVariantEnum}
       */

    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(SplitButton.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1m); // a11y

        this.setAttribute('role', 'group'); // Default reflected attributes

        if (!this._variant) {
          this.variant = variant$k.DEFAULT;
        } // Update styles


        this._updateLeftVariant();

        this._updateInnerButtons();
      }
    }, {
      key: "variant",
      get: function get() {
        return this._variant || variant$k.DEFAULT;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        this._variant = validate.enumeration(variant$k)(value) && value || variant$k.DEFAULT;

        this._reflectAttribute('variant', this._variant);

        this._updateInnerButtonsVariant(this._variant);
      }
    }], [{
      key: "variant",
      get: function get() {
        return variant$k;
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(SplitButton), "observedAttributes", this).concat(['variant']);
      }
    }]);

    return SplitButton;
  }(BaseComponent(HTMLElement));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons._define('coral-splitbutton', SplitButton);

  /**
   Enumeration for {@link Status} variants.

   @typedef {Object} StatusVariantEnum

   @property {String} NEUTRAL
   A default semantic neutral status.
   @property {String} WARNING
   A notice semantic status.
   @property {String} SUCCESS
   A positive semantic status.
   @property {String} ERROR
   A negative semantic status.
   @property {String} INFO
   An informative semantic status.
   */

  var variant$l = {
    NEUTRAL: 'neutral',
    ERROR: 'error',
    WARNING: 'warning',
    SUCCESS: 'success',
    INFO: 'info'
  };
  /**
   Enumeration for {@link Status} colors.

   @typedef {Object} StatusColorEnum

   @property {String} DEFAULT
   @property {String} CELERY
   @property {String} YELLOW
   @property {String} FUCHSIA
   @property {String} INDIGO
   @property {String} SEA_FOAM
   @property {String} CHARTREUSE
   @property {String} MAGENTA
   @property {String} PURPLE
   */

  var color$1 = {
    DEFAULT: '',
    CELERY: 'celery',
    YELLOW: 'yellow',
    FUCHSIA: 'fuchsia',
    INDIGO: 'indigo',
    SEA_FOAM: 'seafoam',
    CHARTREUSE: 'chartreuse',
    MAGENTA: 'magenta',
    PURPLE: 'purple'
  };
  var CLASSNAME$1n = '_coral-StatusLight';
  var variantMapping = {
    SUCCESS: 'positive',
    ERROR: 'negative',
    WARNING: 'notice'
  };
  var ALL_VARIANT_CLASSES$b = [];

  for (var variantValue$9 in variant$l) {
    ALL_VARIANT_CLASSES$b.push("".concat(CLASSNAME$1n, "--").concat(variantMapping[variantValue$9] || variant$l[variantValue$9]));
  }

  var ALL_COLOR_CLASSES$1 = [];

  for (var colorValue$1 in color$1) {
    ALL_COLOR_CLASSES$1.push("".concat(CLASSNAME$1n, "--").concat(color$1[colorValue$1]));
  }
  /**
   @class Coral.Status
   @classdesc A Status component to describe the condition of another entity. They can be used to convey semantic meaning
   such as statuses and categories.

   @htmltag coral-status
   @extends {HTMLElement}
   @extends {BaseComponent}
   */


  var Status = /*#__PURE__*/function (_BaseComponent) {
    _inherits(Status, _BaseComponent);

    var _super = _createSuper(Status);

    /** @ignore */
    function Status() {
      var _this;

      _classCallCheck(this, Status);

      _this = _super.call(this); // Prepare templates

      _this._elements = {
        // Fetch or create the content zone element
        label: _this.querySelector('coral-status-label') || document.createElement('coral-status-label')
      };
      return _this;
    }
    /**
     Whether the status is disabled or not.
      @type {Boolean}
     @default false
     @htmlattribute disabled
     @htmlattributereflected
     */


    _createClass(Status, [{
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(Status.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1n); // Default reflected attributes

        if (!this._variant) {
          this.variant = variant$l.NEUTRAL;
        }

        if (!this._color) {
          this.color = color$1.DEFAULT;
        } // Fetch or create the content content zone element


        var label = this._elements.label; // This stops the content zone from being voracious

        if (!label.parentNode) {
          // move the contents into the content zone
          while (this.firstChild) {
            label.appendChild(this.firstChild);
          }
        } // Assign the content zone moving it into place


        this.label = label;
      }
    }, {
      key: "disabled",
      get: function get() {
        return this._disabled || false;
      },
      set: function set(value) {
        this._disabled = transform.booleanAttr(value);

        this._reflectAttribute('disabled', this._disabled);

        this[this._disabled ? 'setAttribute' : 'removeAttribute']('aria-disabled', this._disabled);
      }
      /**
       The status variant. See {@link StatusVariantEnum}.
       When a status has a semantic meaning, it should use semantic colors.
        @type {String}
       @default StatusVariantEnum.NEUTRAL
       @htmlattribute variant
       @htmlattributereflected
       */

    }, {
      key: "variant",
      get: function get() {
        return this._variant || variant$l.NEUTRAL;
      },
      set: function set(value) {
        var _this$classList;

        value = transform.string(value).toLowerCase();
        this._variant = validate.enumeration(variant$l)(value) && value || variant$l.NEUTRAL;

        this._reflectAttribute('variant', this._variant);

        (_this$classList = this.classList).remove.apply(_this$classList, ALL_VARIANT_CLASSES$b);

        this.classList.add("".concat(CLASSNAME$1n, "--").concat(variantMapping[this._variant.toUpperCase()] || this._variant));
      }
      /**
       The status color. See {@link StatusColorEnum}.
       When a status is used to color code categories and labels commonly found in data visualization, they should use
       colors.
        The ideal usage for colors is when there are 8 or fewer categories or labels being color coded.
       Use them in the following order to ensure the greatest possible color differences for multiple forms of color
       blindness:
       - Indigo
       - Celery
       - Magenta
       - Yellow
       - Fuchsia
       - Seafoam
       - Chartreuse
       - Purple
        If a color is set, it'll override any semantic variant.
        @type {String}
       @default StatusColorEnum.DEFAULT
       @htmlattribute color
       @htmlattributereflected
       */

    }, {
      key: "color",
      get: function get() {
        return this._color || color$1.DEFAULT;
      },
      set: function set(value) {
        var _this$classList2;

        value = transform.string(value).toLowerCase();
        this._color = validate.enumeration(color$1)(value) && value || color$1.DEFAULT;

        this._reflectAttribute('color', this._color);

        (_this$classList2 = this.classList).remove.apply(_this$classList2, ALL_COLOR_CLASSES$1);

        if (this._color !== color$1.DEFAULT) {
          this.classList.add("".concat(CLASSNAME$1n, "--").concat(this._color));
        }
      }
      /**
       The status label element.
        @type {StatusLabel}
       @contentzone
       */

    }, {
      key: "label",
      get: function get() {
        return this._getContentZone(this._elements.label);
      },
      set: function set(value) {
        this._setContentZone('label', value, {
          handle: 'label',
          tagName: 'coral-status-label',
          insert: function insert(label) {
            this.appendChild(label);
          }
        });
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-status-label': 'label'
        };
      }
      /**
       Returns {@link Status} variants.
        @return {StatusVariantEnum}
       */

    }], [{
      key: "variant",
      get: function get() {
        return variant$l;
      }
      /**
       Returns {@link Status} colors.
        @return {StatusColorEnum}
       */

    }, {
      key: "color",
      get: function get() {
        return color$1;
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(Status), "observedAttributes", this).concat(['variant', 'color', 'disabled']);
      }
    }]);

    return Status;
  }(BaseComponent(HTMLElement));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Status.Label
   @classdesc The Status Label
   @htmltag coral-status-label
   @return {HTMLElement}
   */
  var StatusLabel = (function () {
    return document.createElement('coral-status-label');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons._define('coral-status', Status);

  Status.Label = StatusLabel;

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   Gets the target panel of the item.

   @private
   @param {HTMLElement|String} [targetValue]
   A specific target value to use.
   @returns {?HTMLElement}
   */
  function getTarget(targetValue) {
    if (targetValue instanceof Node) {
      // Just return the provided Node
      return targetValue;
    } // Dynamically get the target node based on the target


    var newTarget = null;

    if (typeof targetValue === 'string' && targetValue.trim() !== '') {
      newTarget = document.querySelector(targetValue);
    }

    return newTarget;
  }

  /**
   Enumeration for {@link StepList} interaction options.

   @todo support "click only past steps" mode

   @typedef {Object} StepListInteractionEnum

   @property {String} ON
   Steps can be clicked to visit them.
   @property {String} OFF
   Steps cannot be clicked.
   */

  var interaction$4 = {
    ON: 'on',
    OFF: 'off'
  };
  /**
   Enumeration for {@link StepList} sizes.

   @typedef {Object} StepListSizeEnum

   @property {String} SMALL
   A small-sized StepList.
   @property {String} LARGE
   A large-sized StepList.
   */

  var size$7 = {
    SMALL: 'S',
    LARGE: 'L'
  }; // the StepList's base classname

  var CLASSNAME$1o = '_coral-Steplist';
  /**
   @class Coral.StepList
   @classdesc A StepList component that holds a collection of steps.
   @htmltag coral-steplist
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var StepList = /*#__PURE__*/function (_BaseComponent) {
    _inherits(StepList, _BaseComponent);

    var _super = _createSuper(StepList);

    /** @ignore */
    function StepList() {
      var _this;

      _classCallCheck(this, StepList);

      _this = _super.call(this);

      _this._delegateEvents({
        'click > coral-step > [handle="link"]': '_onStepClick',
        'capture:focus > coral-step': '_onStepMouseEnter',
        'capture:mouseenter > coral-step > [handle="link"]': '_onStepMouseEnter',
        'capture:blur > coral-step': '_onStepMouseLeave',
        'capture:mouseleave > coral-step > [handle="link"]': '_onStepMouseLeave',
        'key:enter > coral-step > [handle="link"]': '_onStepKeyboardSelect',
        'key:space > coral-step > [handle="link"]': '_onStepKeyboardSelect',
        'key:home > coral-step > [handle="link"]': '_onHomeKey',
        'key:end > coral-step > [handle="link"]': '_onEndKey',
        'key:pagedown > coral-step > [handle="link"]': '_selectNextItem',
        'key:right > coral-step > [handle="link"]': '_selectNextItem',
        'key:down > coral-step > [handle="link"]': '_selectNextItem',
        'key:pageup > coral-step > [handle="link"]': '_selectPreviousItem',
        'key:left > coral-step > [handle="link"]': '_selectPreviousItem',
        'key:up > coral-step > [handle="link"]': '_selectPreviousItem',
        // private
        'coral-step:_selectedchanged': '_onItemSelectedChanged'
      }); // Used for eventing


      _this._oldSelection = null; // Init the collection mutation observer

      _this.items._startHandlingItems(true);

      return _this;
    }
    /**
     The Collection Interface that allows interacting with the items that the component contains.
      @type {SelectableCollection}
     @readonly
     */


    _createClass(StepList, [{
      key: "_syncItemTabIndex",

      /** @private */
      value: function _syncItemTabIndex(item) {
        item._syncTabIndex(this.interaction === interaction$4.ON);
      }
      /** @private */

    }, {
      key: "_onItemSelectedChanged",
      value: function _onItemSelectedChanged(event) {
        event.stopImmediatePropagation();
        var item = event.target;

        this._syncItemTabIndex(item);

        this._validateSelection(item);
      }
      /** @private */

    }, {
      key: "_validateSelection",
      value: function _validateSelection(item) {
        // gets the current selection
        var selection = this.items._getAllSelected();

        var selectionCount = selection.length; // if no item is currently selected, we need to find a candidate

        if (selectionCount === 0) {
          // gets the first candidate for selection
          var selectable = this.items._getFirstSelectable();

          if (selectable) {
            selectable.setAttribute('selected', '');
          }
        } // more items are selected, so we find a single item and deselect everything else
        else if (selectionCount > 1) {
            // By default, the last one stays selected
            item = item || selection[selection.length - 1];

            for (var i = 0; i < selectionCount; i++) {
              if (selection[i] !== item) {
                // Don't trigger change events
                this._preventTriggeringEvents = true;
                selection[i].removeAttribute('selected');
              }
            } // We can trigger change events again


            this._preventTriggeringEvents = false;
          } // sets the state-related classes every time the selection changes


        this._setStateClasses();

        this._triggerChangeEvent();
      }
      /** @private */

    }, {
      key: "_triggerChangeEvent",
      value: function _triggerChangeEvent() {
        var selectedItem = this.selectedItem;
        var oldSelection = this._oldSelection;

        if (!this._preventTriggeringEvents && selectedItem !== oldSelection) {
          this.trigger('coral-steplist:change', {
            oldSelection: oldSelection,
            selection: selectedItem
          });
          this._oldSelection = selectedItem;
        }
      }
      /** @private */

    }, {
      key: "_setStateClasses",
      value: function _setStateClasses() {
        var selectedItemIndex = Infinity;
        this.items.getAll().forEach(function (item, index) {
          // Use attribute instead of property as items might not be initialized
          if (item.hasAttribute('selected')) {
            // Mark which one is selected
            selectedItemIndex = index;
          } // Add/remove classes based on index


          item.classList.toggle('is-complete', index < selectedItemIndex);

          if (!item._elements) {
            return;
          } // Set accessibilityState text label


          var accessibilityLabel = i18n.get('not completed: ');

          if (index < selectedItemIndex) {
            accessibilityLabel = i18n.get('completed: ');
          } else if (index === selectedItemIndex) {
            accessibilityLabel = i18n.get('current: ');
          }

          item._elements.accessibilityLabel.innerHTML = accessibilityLabel;
        });
      }
      /** @private */

    }, {
      key: "_onStepKeyboardSelect",
      value: function _onStepKeyboardSelect(event) {
        if (this.interaction === interaction$4.ON) {
          event.preventDefault();
          event.stopPropagation();
          var item = event.matchedTarget.closest('coral-step');

          this._selectAndFocusItem(item);

          this._trackEvent('click', 'coral-steplist-item', event, item);
        }
      }
      /** @private */

    }, {
      key: "_onStepClick",
      value: function _onStepClick(event) {
        if (this.interaction === interaction$4.ON) {
          event.preventDefault();
          event.stopPropagation();
          var item = event.matchedTarget.closest('coral-step'); // Disabled item should not get selected

          if (item.disabled) {
            return;
          }

          this._selectAndFocusItem(item);

          this._trackEvent('click', 'coral-steplist-item', event, item);
        }
      }
      /** @private */

    }, {
      key: "_onStepMouseEnter",
      value: function _onStepMouseEnter() {
        if (this.size === size$7.SMALL) {
          var step = event.target.closest('coral-step'); // we only show the tooltip if we have a label to show

          if (step._elements.label.innerHTML.trim() !== '') {
            step._elements.overlay.content.innerHTML = step._elements.label.innerHTML;
            step._elements.overlay.open = true;
          }
        }
      }
      /** @private */

    }, {
      key: "_onStepMouseLeave",
      value: function _onStepMouseLeave(event) {
        if (this.size === size$7.SMALL) {
          var step = event.target.closest('coral-step');
          step._elements.overlay.open = false;
        }
      }
      /** @private */

    }, {
      key: "_onHomeKey",
      value: function _onHomeKey(event) {
        if (this.interaction === interaction$4.ON) {
          event.preventDefault();

          var item = this.items._getFirstSelectable();

          this._selectAndFocusItem(item);
        }
      }
      /** @private */

    }, {
      key: "_onEndKey",
      value: function _onEndKey(event) {
        if (this.interaction === interaction$4.ON) {
          event.preventDefault();

          var item = this.items._getLastSelectable();

          this._selectAndFocusItem(item);
        }
      }
      /** @private */

    }, {
      key: "_selectNextItem",
      value: function _selectNextItem(event) {
        if (this.interaction === interaction$4.ON) {
          event.preventDefault();
          this.next();
        }
      }
      /** @private */

    }, {
      key: "_selectPreviousItem",
      value: function _selectPreviousItem(event) {
        if (this.interaction === interaction$4.ON) {
          event.preventDefault();
          this.previous();
        }
      }
      /** @private */

    }, {
      key: "_selectAndFocusItem",
      value: function _selectAndFocusItem(item) {
        if (item) {
          item.setAttribute('selected', '');
          item.focus();
        }
      }
      /**
       Show the next Step.
        @emits {coral-steplist:change}
       */

    }, {
      key: "next",
      value: function next() {
        var item = this.selectedItem;

        if (item) {
          item = this.items._getNextSelectable(item);

          this._selectAndFocusItem(item);
        }
      }
      /**
       Show the previous Step.
        @emits {coral-steplist:change}
       */

    }, {
      key: "previous",
      value: function previous() {
        var item = this.selectedItem;

        if (item) {
          item = this.items._getPreviousSelectable(item);

          this._selectAndFocusItem(item);
        }
      }
      /**
       Returns {@link StepList} sizes.
        @return {StepListSizeEnum}
       */

    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(StepList.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1o); // Default reflected attributes

        if (!this._interaction) {
          this.interaction = interaction$4.OFF;
        }

        if (!this._size) {
          this.size = size$7.LARGE;
        } // A11y


        this.setAttribute('role', 'list'); // provide accessibility label for the list

        if (!this.hasAttribute('aria-label') && !this.hasAttribute('aria-labelledby')) {
          this.setAttribute('aria-label', i18n.get('Step List'));
        } // Don't trigger events once connected


        this._preventTriggeringEvents = true;

        this._validateSelection();

        this._preventTriggeringEvents = false;
        this._oldSelection = this.selectedItem;
      }
      /**
       Triggered when the {@link StepList} selected {@link Step} has changed.
        @typedef {CustomEvent} coral-steplist:change
        @property {Step} detail.selection
       The newly selected Step.
       @property {Step} detail.oldSelection
       The previously selected Step.
       */

    }, {
      key: "items",
      get: function get() {
        // we do lazy initialization of the collection
        if (!this._items) {
          this._items = new SelectableCollection({
            host: this,
            itemTagName: 'coral-step',
            onItemAdded: this._validateSelection,
            onItemRemoved: this._validateSelection
          });
        }

        return this._items;
      }
      /**
       Returns the selected step.
        @type {HTMLElement}
       @readonly
       */

    }, {
      key: "selectedItem",
      get: function get() {
        return this.items._getLastSelected();
      }
      /**
       The target component that will be linked to the StepList. It accepts either a CSS selector or a DOM element. If
       a CSS Selector is provided, the first matching element will be used. Items will be selected based on the index.
       If both target and {@link Coral.Step#target} are set, the second will have higher priority.
        @type {?HTMLElement|String}
       @default null
       @htmlattribute target
       */

    }, {
      key: "target",
      get: function get() {
        return this._target || null;
      },
      set: function set(value) {
        var _this2 = this;

        if (value === null || typeof value === 'string' || value instanceof Node) {
          this._target = value; // we do this in the sync in case the target was not yet in the DOM

          window.requestAnimationFrame(function () {
            var realTarget = getTarget(_this2._target); // we add proper accessibility if available

            if (realTarget) {
              var stepItems = _this2.items.getAll();

              var panelItems = realTarget.items ? realTarget.items.getAll() : realTarget.children; // we need to add a11y to all components, regardless of whether they can be perfectly paired

              var maxItems = Math.max(stepItems.length, panelItems.length);
              var step;
              var panel;

              for (var i = 0; i < maxItems; i++) {
                step = stepItems[i];
                panel = panelItems[i]; // if the step has its own target, we assume the target component will handle its own accessibility.
                // if the target is an empty string we simply ignore it

                if (step && step.target && step.target.trim() !== '') {
                  continue;
                }

                if (panel) {
                  panel.setAttribute('role', 'region');
                }

                if (step && panel) {
                  // sets the required ids
                  step.id = step.id || commons.getUID();
                  panel.id = panel.id || commons.getUID(); // creates a 2 way binding for accessibility

                  step.setAttribute('aria-controls', panel.id);
                  panel.setAttribute('aria-labelledby', step.id);
                } else if (step) {
                  // cleans the aria since there is no matching panel
                  step.removeAttribute('aria-controls');
                } else {
                  // cleans the aria since there is no matching Step
                  panel.removeAttribute('aria-labelledby');
                }
              }
            }
          });
        }
      }
      /**
       The size of the StepList. It accepts both lower and upper case sizes. Currently only "S" and "L" (the default)
       are available.
       See {@link StepListSizeEnum}.
        @type {String}
       @default StepListSizeEnum.LARGE
       @htmlattribute size
       @htmlattributereflected
       */

    }, {
      key: "size",
      get: function get() {
        return this._size || size$7.LARGE;
      },
      set: function set(value) {
        var _this3 = this;

        value = transform.string(value).toUpperCase();
        this._size = validate.enumeration(size$7)(value) && value || size$7.LARGE;

        this._reflectAttribute('size', this._size);

        this.classList.toggle("".concat(CLASSNAME$1o, "--small"), this._size === size$7.SMALL);

        if (!this.items.length) {
          return;
        } // update aria-label for all children


        var _syncItemLabelled = function _syncItemLabelled() {
          var isSmall = _this3.size === size$7.SMALL;

          var steps = _this3.items.getAll();

          var stepsCount = steps.length;

          for (var i = 0; i < stepsCount; i++) {
            var step = steps[i];
            var label = step._elements.label;

            if (!step.labelled && label.textContent.length) {
              label.classList.toggle('u-coral-screenReaderOnly', isSmall);
              label.style.display = isSmall ? 'block' : '';
            }
          }
        };

        var lastItem = this.items.last();

        if (typeof lastItem._syncTabIndex === 'function') {
          _syncItemLabelled();
        } else {
          commons.ready(lastItem, _syncItemLabelled);
        }
      }
      /**
       Whether Steps should be interactive or not. When interactive, a Step can be clicked to jump to it.
       See {@link StepListInteractionEnum}.
        @type {String}
       @default StepListInteractionEnum.OFF
       @htmlattribute interaction
       @htmlattributereflected
       */

    }, {
      key: "interaction",
      get: function get() {
        return this._interaction || interaction$4.OFF;
      },
      set: function set(value) {
        var _this4 = this;

        value = transform.string(value).toLowerCase();
        this._interaction = validate.enumeration(interaction$4)(value) && value || interaction$4.OFF;

        this._reflectAttribute('interaction', this._interaction);

        var isInteractive = this._interaction === interaction$4.ON;
        this.classList.toggle("".concat(CLASSNAME$1o, "--interactive"), isInteractive);

        if (!this.items.length) {
          return;
        } // update tab index for all children


        var _syncItemProps = function _syncItemProps() {
          var steps = _this4.items.getAll();

          var stepsCount = steps.length;

          for (var i = 0; i < stepsCount; i++) {
            // update tab index for all children
            steps[i]._syncTabIndex(isInteractive); //update posin set and total size for all steps


            steps[i]._syncSizeAndCurrentIndex(i + 1, stepsCount);
          }
        };

        var lastItem = this.items.last();

        if (typeof lastItem._syncTabIndex === 'function') {
          _syncItemProps();
        } else {
          commons.ready(lastItem, _syncItemProps);
        }
      }
    }], [{
      key: "size",
      get: function get() {
        return size$7;
      }
      /**
       Returns {@link StepList} interaction options.
        @return {StepListInteractionEnum}
       */

    }, {
      key: "interaction",
      get: function get() {
        return interaction$4;
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(StepList), "observedAttributes", this).concat(['target', 'size', 'interaction']);
      }
    }]);

    return StepList;
  }(BaseComponent(HTMLElement));

  var template$U = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["link"] = document.createElement("a");
    el0.className += " _coral-Steplist-link";
    el0.setAttribute("handle", "link");
    var el1 = document.createTextNode("\n  ");
    el0.appendChild(el1);
    var el2 = this["accessibilityLabel"] = document.createElement("span");
    el2.className += " u-coral-screenReaderOnly _coral-Steplist-accessibilityLabel";
    el2.setAttribute("handle", "accessibilityLabel");
    el0.appendChild(el2);
    var el3 = document.createTextNode("\n  ");
    el0.appendChild(el3);
    var el4 = this["stepMarkerContainer"] = document.createElement("span");
    el4.className += " _coral-Steplist-markerContainer";
    el4.setAttribute("handle", "stepMarkerContainer");
    el4.setAttribute("role", "img");
    el4.setAttribute("aria-hidden", "true");
    var el5 = document.createTextNode("\n    ");
    el4.appendChild(el5);
    var el6 = document.createElement("span");
    el6.className += " _coral-Steplist-marker";
    el4.appendChild(el6);
    var el7 = document.createTextNode("\n  ");
    el4.appendChild(el7);
    el0.appendChild(el4);
    var el8 = document.createTextNode("\n  ");
    el0.appendChild(el8);
    var el9 = this["overlay"] = document.createElement("coral-tooltip");
    el9.setAttribute("tracking", "off");
    el9.setAttribute("smart", "");
    el9.setAttribute("focusonshow", "off");
    el9.setAttribute("handle", "overlay");
    el9.setAttribute("placement", "top");
    el9.setAttribute("variant", "inspect");
    el9.setAttribute("interaction", "off");
    el9.setAttribute("breadthoffset", "1");
    el0.appendChild(el9);
    var el10 = document.createTextNode("\n");
    el0.appendChild(el10);
    frag.appendChild(el0);
    var el11 = document.createTextNode("\n");
    frag.appendChild(el11);
    var el12 = this["line"] = document.createElement("span");
    el12.className += " _coral-Steplist-segment";
    el12.setAttribute("handle", "line");
    frag.appendChild(el12);
    var el13 = document.createTextNode("\n");
    frag.appendChild(el13);
    return frag;
  };

  var CLASSNAME$1p = '_coral-Steplist-item';
  /**
   @class Coral.Step
   @classdesc A Step component
   @htmltag coral-step
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var Step = /*#__PURE__*/function (_BaseComponent) {
    _inherits(Step, _BaseComponent);

    var _super = _createSuper(Step);

    /** @ignore */
    function Step() {
      var _this;

      _classCallCheck(this, Step);

      _this = _super.call(this); // Fetch or create content zone

      _this._elements = {
        label: _this.querySelector('coral-step-label') || document.createElement('coral-step-label')
      };
      template$U.call(_this._elements);
      return _this;
    }
    /**
     The label of the step.
      @type {StepLabel}
     @contentzone
     */


    _createClass(Step, [{
      key: "_isHybrid",
      value: function _isHybrid() {
        var label = this.label;
        var maxWidth = this.label.clientWidth; // Required to be able to measure full width

        label.style.position = 'relative';
        label.style.whiteSpace = 'inherit';
        label.style.display = 'inline'; // Mark it for hybrid mode

        this._labelIsHidden = label.getBoundingClientRect().width > maxWidth; // Restore defaults

        label.style.position = '';
        label.style.whiteSpace = '';
        label.style.display = '';
      }
    }, {
      key: "focus",
      value: function focus() {
        this._elements.link.focus();
      }
    }, {
      key: "blur",
      value: function blur() {
        this._elements.link.blur();
      }
      /** @private */

    }, {
      key: "_syncTabIndex",
      value: function _syncTabIndex(isInteractive) {
        // the list item itself should never include a tabindex
        this.removeAttribute('tabindex'); // when interaction is on, we enable the tabindex so users can tab into the items

        if (isInteractive) {
          this._elements.link.setAttribute('role', 'link');

          if (this.disabled) {
            this._elements.link.removeAttribute('tabindex');

            this._elements.link.setAttribute('aria-disabled', true);
          } else {
            this._elements.link.removeAttribute('aria-disabled');

            this._elements.link.setAttribute('tabindex', this.selected ? '0' : '-1');
          }
        } else {
          // when off, removing the tabindex allows the component to never get focus
          this._elements.link.removeAttribute('tabindex');

          this._elements.link.removeAttribute('role');
        }
      }
      /** @private */

    }, {
      key: "_syncSizeAndCurrentIndex",
      value: function _syncSizeAndCurrentIndex(currentStep, totalSteps) {
        this.setAttribute('aria-setsize', totalSteps);
        this.setAttribute('aria-posinset', currentStep);
      }
    }, {
      key: "connectedCallback",

      /** @ignore */
      value: function connectedCallback() {
        _get(_getPrototypeOf(Step.prototype), "connectedCallback", this).call(this);

        var overlay = this._elements.overlay; // Cannot be open by default when rendered

        overlay.removeAttribute('open'); // Restore in DOM

        if (overlay._parent) {
          overlay._parent.appendChild(overlay);
        }
      }
      /** @ignore */

    }, {
      key: "render",
      value: function render() {
        _get(_getPrototypeOf(Step.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1p); // Generate a unique ID for the Step panel if one isn't already present
        // This will be used for accessibility purposes

        this.setAttribute('id', this.id || commons.getUID()); // A11y

        this.setAttribute('role', 'listitem');
        var frag = document.createDocumentFragment(); // Discard the template-created link, accessibilityLabel, stepMarkerContainer, and line if one is provided by markup

        this._elements.link = this.querySelector('[handle="link"]') || this._elements.link;
        this._elements.accessibilityLabel = this.querySelector('[handle="accessibilityLabel"]') || this._elements.accessibilityLabel;
        this._elements.stepMarkerContainer = this.querySelector('[handle="stepMarkerContainer"]') || this._elements.stepMarkerContainer;
        this._elements.line = this.querySelector('[handle="line"]') || this._elements.line; // Discard the template-created tooltip if one is provided by markup

        this._elements.overlay = this.querySelector('coral-tooltip') || this._elements.overlay; // Render main template

        frag.appendChild(this._elements.link);

        this._elements.link.appendChild(this._elements.stepMarkerContainer);

        this._elements.link.appendChild(this._elements.overlay);

        frag.appendChild(this._elements.line);
        var templateHandleNames = ['link', 'accessibilityLabel', 'stepMarkerContainer', 'overlay', 'line'];
        var label = this._elements.label; // Remove it so we can process children

        if (label.parentNode) {
          label.remove();
        }

        while (this.firstChild) {
          var child = this.firstChild;

          if (child.nodeType === Node.TEXT_NODE || child.nodeType === Node.ELEMENT_NODE && templateHandleNames.indexOf(child.getAttribute('handle')) === -1) {
            label.appendChild(child);
          } else {
            this.removeChild(child);
          }
        } // Link tooltip target


        this._elements.overlay.target = this._elements.stepMarkerContainer;
        this.appendChild(frag); // Assign the content zone so the insert function will be called

        this.label = label; // Measure hybrid potential

        this._isHybrid(); // Sync the tabIndex value an role depending on whether interaction is on.


        var stepList = this.parentElement;

        if (stepList) {
          this._syncTabIndex(stepList.interaction === StepList.interaction.ON);
        }
      }
      /** @ignore */

    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        _get(_getPrototypeOf(Step.prototype), "disconnectedCallback", this).call(this);

        var overlay = this._elements.overlay; // In case it was moved out don't forget to remove it

        if (!this.contains(overlay)) {
          overlay._parent = overlay._repositioned ? document.body : this;
          overlay.remove();
        }
      }
    }, {
      key: "label",
      get: function get() {
        return this._getContentZone(this._elements.label);
      },
      set: function set(value) {
        this._setContentZone('label', value, {
          handle: 'label',
          tagName: 'coral-step-label',
          insert: function insert(label) {
            label.classList.add('_coral-Steplist-label');

            this._elements.link.insertBefore(label, this._elements.stepMarkerContainer);
          }
        });
      }
      /**
       Whether the item is selected. When <code>true</code>, the item will appear as the active element in the
       StepList. The item must be a child of a StepList before this property is set to <code>true</code>.
        @type {Boolean}
       @default false
       @htmlattribute selected
       @htmlattributereflected
       */

    }, {
      key: "selected",
      get: function get() {
        return this._selected || false;
      },
      set: function set(value) {
        this._selected = transform.booleanAttr(value);

        this._reflectAttribute('selected', this._selected);

        this.classList.toggle('is-selected', this.selected);
        this.removeAttribute('aria-selected');

        if (this.selected) {
          this._elements.link.setAttribute('aria-current', 'step');
        } else {
          this._elements.link.removeAttribute('aria-current');
        }

        var stepList = this.parentElement;
        var realTarget; // in case the Step is selected, we need to communicate it to the panels

        if (this._selected) {
          realTarget = getTarget(this.target); // if the target was defined at the Step level, it has precedence over everything

          if (realTarget) {
            realTarget.setAttribute('selected', '');
          } // we use the target defined at the StepList level
          else if (stepList && stepList.target) {
              realTarget = getTarget(stepList.target);

              if (realTarget) {
                // we get the position of this step inside the steplist
                var currentIndex = stepList.items.getAll().indexOf(this); // we select the item with the same index

                var targetItem = (realTarget.items ? realTarget.items.getAll() : realTarget.children)[currentIndex]; // we select the item if it exists

                if (targetItem) {
                  targetItem.setAttribute('selected', '');
                }
              }
            }
        }

        this.trigger('coral-step:_selectedchanged');
      }
      /**
       Whether the item is disabled
        @type {Boolean}
       @default false
       @htmlattribute disabled
       @htmlattributereflected
       */

    }, {
      key: "disabled",
      get: function get() {
        return this._disabled || false;
      },
      set: function set(value) {
        this._disabled = transform.booleanAttr(value);

        this._reflectAttribute('disabled', this._disabled);

        this.classList.toggle('is-disabled', this.disabled);
        var stepList = this.parentElement;

        if (stepList) {
          this._syncTabIndex(stepList.interaction === StepList.interaction.ON);
        }
      }
      /**
       Reflects the <code>aria-label</code> attribute to the marker dot for cases where no visible label is provided for the Step.
       @type {?String}
       @default ''
       @htmlattribute labelled
       @htmlattributereflected
       @memberof Coral.Step#
       */

    }, {
      key: "labelled",
      get: function get() {
        return this._labelled || this.getAttribute('labelled') || this._elements.stepMarkerContainer.getAttribute('aria-label') || '';
      },
      set: function set(value) {
        this._labelled = transform.string(value);

        this._reflectAttribute('labelled', value || false);

        if (this._labelled !== '') {
          this._elements.stepMarkerContainer.setAttribute('aria-label', this._labelled);

          this._elements.stepMarkerContainer.removeAttribute('aria-hidden');
        } else {
          this._elements.stepMarkerContainer.removeAttribute('aria-label');

          if (!this.labelledBy) {
            this._elements.stepMarkerContainer.setAttribute('aria-hidden', 'true');
          }
        }
      }
      /**
       Reflects the <code>aria-labelledby</code> attribute to the marker dot for cases where no visible label is provided for the Step,
       and the Step is labelled by an external element.
       @type {?String}
       @default ''
       @htmlattribute labelledby
       @htmlattributereflected
       @memberof Coral.Step#
       */

    }, {
      key: "labelledBy",
      get: function get() {
        return this._labelledBy || this.getAttribute('labelledby') || this._elements.stepMarkerContainer.getAttribute('aria-labelledby') || '';
      },
      set: function set(value) {
        this._labelledBy = transform.string(value);

        this._reflectAttribute('labelledby', value || false);

        if (this._labelledBy !== '') {
          this._elements.stepMarkerContainer.setAttribute('aria-labelledby', this._labelledBy);

          this._elements.stepMarkerContainer.removeAttribute('aria-hidden');
        } else {
          this._elements.stepMarkerContainer.removeAttribute('aria-labelledby');

          if (!this.labelled) {
            this._elements.stepMarkerContainer.setAttribute('aria-hidden', 'true');
          }
        }
      }
      /**
       Reflects the <code>aria-describedby</code> attribute to the link element.
       @type {?String}
       @default ''
       @htmlattribute describedby
       @htmlattributereflected
       @memberof Coral.Step#
       */

    }, {
      key: "describedBy",
      get: function get() {
        return this._describedBy || this.getAttribute('describedby') || this._elements.link.getAttribute('aria-describedby') || '';
      },
      set: function set(value) {
        this._describedBy = transform.string(value);

        this._reflectAttribute('describedby', value || false);

        if (this._describedBy !== '') {
          this._elements.link.setAttribute('aria-describedby', this._describedBy);
        } else {
          this._elements.link.removeAttribute('aria-describedby');
        }
      }
      /**
       The target element that will be selected when this Step is selected. It accepts a CSS selector or a DOM element.
       If a CSS Selector is provided, the first matching element will be used.
        @type {?HTMLElement|String}
       @default null
       @htmlattribute target
       */

    }, {
      key: "target",
      get: function get() {
        return this._target || null;
      },
      set: function set(value) {
        if (value === null || typeof value === 'string' || value instanceof Node) {
          this._target = value;
          var realTarget = getTarget(this._target); // we add proper accessibility if available

          if (realTarget) {
            // creates a 2 way binding for accessibility
            this.setAttribute('aria-controls', realTarget.id);
            realTarget.setAttribute('aria-labelledby', this.id);
          }
        }
      }
      /**
       Inherited from {@link BaseComponent#trackingElement}.
       */

    }, {
      key: "trackingElement",
      get: function get() {
        return typeof this._trackingElement === 'undefined' ? // keep spaces to only 1 max and trim. this mimics native html behaviors
        (this.label || this).textContent.replace(/\s{2,}/g, ' ').trim() : this._trackingElement;
      },
      set: function set(value) {
        _set(_getPrototypeOf(Step.prototype), "trackingElement", value, this, true);
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-step-label': 'label'
        };
      }
      /** @ignore */

    }], [{
      key: "_attributePropertyMap",
      get: function get() {
        return commons.extend(_get(_getPrototypeOf(Step), "_attributePropertyMap", this), {
          labelledby: 'labelledBy',
          describedby: 'describedBy'
        });
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(Step), "observedAttributes", this).concat(['selected', 'target', 'disabled', 'labelled', 'labelledby', 'describedby']);
      }
    }]);

    return Step;
  }(BaseComponent(HTMLElement));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Step.Label
   @classdesc A Step Label
   @htmltag coral-step-label
   @return {HTMLElement}
   */
  var StepLabel = (function () {
    return document.createElement('coral-step-label');
  });

  /**
   * Copyright 2020 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var translations$k = {
    "en-US": {
      "Step List": "Step List",
      "completed: ": "completed: ",
      "current: ": "current: ",
      "not completed: ": "not completed: "
    },
    "de-DE": {
      "Step List": "Schrittliste",
      "completed: ": "abgeschlossen: ",
      "current: ": "aktuell: ",
      "not completed: ": "nicht abgeschlossen: "
    },
    "fr-FR": {
      "Step List": "Liste des Ã©tapes",
      "completed: ": "terminÃ© : ",
      "current: ": "actuel : ",
      "not completed: ": "non terminÃ© : "
    },
    "it-IT": {
      "Step List": "Elenco passi",
      "completed: ": "completato: ",
      "current: ": "corrente: ",
      "not completed: ": "non completato: "
    },
    "ja-JP": {
      "Step List": "æé ãªã¹ã",
      "completed: ": "å®äº: ",
      "current: ": "ç¾å¨: ",
      "not completed: ": "æªå®äº: "
    },
    "es-ES": {
      "Step List": "Lista de pasos",
      "completed: ": "completado: ",
      "current: ": "actual: ",
      "not completed: ": "no completado: "
    },
    "ko-KR": {
      "Step List": "ë¨ê³ ëª©ë¡",
      "completed: ": "ìë£ë¨: ",
      "current: ": "íì¬: ",
      "not completed: ": "ë¯¸ìë£: "
    },
    "zh-CN": {
      "Step List": "æ­¥éª¤åè¡¨",
      "completed: ": "å·²å®æ: ",
      "current: ": "å½å: ",
      "not completed: ": "æªå®æ: "
    },
    "zh-TW": {
      "Step List": "æ­¥é©æ¸å®",
      "completed: ": "å·²å®æ: ",
      "current: ": "ç®å: ",
      "not completed: ": "æªå®æ: "
    },
    "pt-BR": {
      "Step List": "Lista de passos",
      "completed: ": "concluÃ­do: ",
      "current: ": "atual: ",
      "not completed: ": "nÃ£o concluÃ­do: "
    },
    "nl-NL": {
      "Step List": "Stappenlijst",
      "completed: ": "voltooid: ",
      "current: ": "huidige: ",
      "not completed: ": "niet voltooid: "
    },
    "da-DK": {
      "Step List": "Trin liste",
      "completed: ": "Afsluttet: ",
      "current: ": "aktuelt: ",
      "not completed: ": "Ikke afsluttet: "
    },
    "fi-FI": {
      "Step List": "Vaihe luettelo",
      "completed: ": "Valmis: ",
      "current: ": "nykyinen: ",
      "not completed: ": "Ei valmis: "
    },
    "nb-NO": {
      "Step List": "Trinn liste",
      "completed: ": "fullfÃ¸rt: ",
      "current: ": "gjeldende: ",
      "not completed: ": "ikke fullfÃ¸rt: "
    },
    "sv-SE": {
      "Step List": "Steg lista",
      "completed: ": "slutfÃ¶rd: ",
      "current: ": "aktuell: ",
      "not completed: ": "inte slutfÃ¶rd: "
    },
    "cs-CZ": {
      "Step List": "Seznam krokÅ¯",
      "completed: ": "dokonÄeno: ",
      "current: ": "aktuÃ¡lnÃ­: ",
      "not completed: ": "nedokonÄeno: "
    },
    "pl-PL": {
      "Step List": "Lista krokÃ³w",
      "completed: ": "zakoÅczone: ",
      "current: ": "bieÅ¼Äcy: ",
      "not completed: ": "nieukoÅczone: "
    },
    "ru-RU": {
      "Step List": "Ð¡Ð¿Ð¸ÑÐ¾Ðº ÑÐ°Ð³Ð¾Ð²",
      "completed: ": "Ð·Ð°Ð²ÐµÑÑÐµÐ½Ð¾: ",
      "current: ": "ÑÐµÐºÑÑÐ¸Ð¹: ",
      "not completed: ": "Ð½Ðµ Ð·Ð°Ð²ÐµÑÑÐµÐ½Ð¾: "
    },
    "tr-TR": {
      "Step List": "AdÄ±m listesi",
      "completed: ": "tamamlandÄ±: ",
      "current: ": "geÃ§erli: ",
      "not completed: ": "tamamlanmadÄ±: "
    }
  };

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons.extend(strings, {
    'coral-component-steplist': translations$k
  }); // Expose component on the Coral namespace

  commons._define('coral-step', Step);

  commons._define('coral-steplist', StepList);

  Step.Label = StepLabel;

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var translations$l = {
    "en-US": {
      "Select": "Select"
    },
    "fr-FR": {
      "Select": "SÃ©lectionner"
    },
    "de-DE": {
      "Select": "AuswÃ¤hlen"
    },
    "it-IT": {
      "Select": "Seleziona"
    },
    "es-ES": {
      "Select": "Seleccionar"
    },
    "pt-BR": {
      "Select": "Selecionar"
    },
    "ja-JP": {
      "Select": "é¸æ"
    },
    "ko-KR": {
      "Select": "ì í"
    },
    "zh-CN": {
      "Select": "éæ©"
    },
    "zh-TW": {
      "Select": "é¸å"
    },
    "nl-NL": {
      "Select": "Selecteren"
    },
    "da-DK": {
      "Select": "VÃ¦lg"
    },
    "fi-FI": {
      "Select": "Valitse"
    },
    "nb-NO": {
      "Select": "Velg"
    },
    "sv-SE": {
      "Select": "VÃ¤lj"
    },
    "cs-CZ": {
      "Select": "Vybrat"
    },
    "pl-PL": {
      "Select": "Wybierz"
    },
    "ru-RU": {
      "Select": "ÐÑÐ±ÐµÑÐ¸ÑÐµ"
    },
    "tr-TR": {
      "Select": "SeÃ§"
    }
  };

  var template$V = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["input"] = document.createElement("input");
    el0.setAttribute("type", "checkbox");
    el0.setAttribute("handle", "input");
    el0.className += " _coral-ToggleSwitch-input";
    el0.id = data_0["commons"]["getUID"]();
    frag.appendChild(el0);
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    var el2 = this["switch"] = document.createElement("span");
    el2.setAttribute("handle", "switch");
    el2.className += " _coral-ToggleSwitch-switch";
    frag.appendChild(el2);
    var el3 = document.createTextNode("\n");
    frag.appendChild(el3);
    var el4 = this["labelWrapper"] = document.createElement("label");
    el4.className += " _coral-ToggleSwitch-label";
    el4.setAttribute("for", this["input"]["id"]);
    el4.setAttribute("handle", "labelWrapper");
    var el5 = document.createTextNode("\n  ");
    el4.appendChild(el5);
    var el6 = this["screenReaderOnly"] = document.createElement("span");
    el6.className += " u-coral-screenReaderOnly";
    el6.setAttribute("handle", "screenReaderOnly");
    el6.textContent = data_0["i18n"]["get"]('Select');
    el4.appendChild(el6);
    var el7 = document.createTextNode("\n");
    el4.appendChild(el7);
    frag.appendChild(el4);
    var el8 = document.createTextNode("\n");
    frag.appendChild(el8);
    return frag;
  };

  var CLASSNAME$1q = '_coral-ToggleSwitch';
  /**
   @class Coral.Switch
   @classdesc A Switch component is a toggle form field similar to a Checkbox component.
   @htmltag coral-switch
   @extends {HTMLElement}
   @extends {BaseComponent}
   @extends {BaseFormField}
   */

  var Switch = /*#__PURE__*/function (_BaseFormField) {
    _inherits(Switch, _BaseFormField);

    var _super = _createSuper(Switch);

    /** @ignore */
    function Switch() {
      var _this;

      _classCallCheck(this, Switch);

      _this = _super.call(this); // Make sure the events from the FormField are attached

      _this._delegateEvents(commons.extend(_this._events, {
        'capture:focus ._coral-ToggleSwitch-input': '_onFocus',
        'capture:blur ._coral-ToggleSwitch-input': '_onBlur'
      })); // Prepare templates


      _this._elements = {
        // Try to find the label content zone
        label: _this.querySelector('coral-switch-label') || document.createElement('coral-switch-label')
      };
      template$V.call(_this._elements, {
        commons: commons,
        i18n: i18n
      }); // Pre-define labellable element

      _this._labellableElement = _this._elements.input; // Check if the label is empty whenever we get a mutation

      _this._observer = new MutationObserver(_this._hideLabelIfEmpty.bind(_assertThisInitialized(_this))); // Watch for changes to the label element's children

      _this._observer.observe(_this._elements.labelWrapper, {
        // Catch changes to childList
        childList: true,
        // Catch changes to textContent
        characterData: true,
        // Monitor any child node
        subtree: true
      });

      return _this;
    }
    /**
     Whether the switch is on or off.
      @type {Boolean}
     @default false
     @htmlattribute checked
     @htmlattributereflected
     @emits {change}
     */


    _createClass(Switch, [{
      key: "_hideLabelIfEmpty",

      /**
       Hide the label if it's empty.
        @ignore
       */
      value: function _hideLabelIfEmpty() {
        var label = this._elements.label; // If it's empty and has no non-textnode children, hide the label

        var hiddenValue = !(label.children.length === 0 && label.textContent.replace(/\s*/g, '') === ''); // Toggle the screen reader text

        this._elements.labelWrapper.style.margin = !hiddenValue ? '0' : '';
        this._elements.screenReaderOnly.hidden = hiddenValue || this.labelled;
      }
    }, {
      key: "_onFocus",
      value: function _onFocus() {
        this._elements.input.classList.add('focus-ring');
      }
    }, {
      key: "_onBlur",
      value: function _onBlur() {
        this._elements.input.classList.remove('focus-ring');
      }
    }, {
      key: "clear",

      /**
       Inherited from {@link BaseFormField#clear}.
       */
      value: function clear() {
        this.checked = false;
      }
      /**
       Inherited from {@link BaseFormField#reset}.
       */

    }, {
      key: "reset",
      value: function reset() {
        this.checked = this._initialCheckedState;
      }
      /** @ignore */

    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(Switch.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1q); // Create a fragment

        var frag = document.createDocumentFragment();
        var templateHandleNames = ['input', 'switch', 'labelWrapper']; // Render the template

        frag.appendChild(this._elements.input);
        frag.appendChild(this._elements.switch);
        frag.appendChild(this._elements.labelWrapper);
        var label = this._elements.label; // Remove it so we can process children

        if (label && label.parentNode) {
          label.parentNode.removeChild(label);
        } // Clean up


        while (this.firstChild) {
          var child = this.firstChild; // Only works if all root template elements have a handle attribute

          if (child.nodeType === Node.TEXT_NODE || child.nodeType === Node.ELEMENT_NODE && templateHandleNames.indexOf(child.getAttribute('handle')) === -1) {
            // Add non-template elements to the content
            label.appendChild(child);
          } else {
            // Remove anything else
            this.removeChild(child);
          }
        } // Append the fragment to the component


        this.appendChild(frag); // Assign the content zones, moving them into place in the process

        this.label = label; // Cache the initial checked state of the switch (in order to implement reset)

        this._initialCheckedState = this.checked; // Check if we need to hide the label
        // We must do this because IE does not catch mutations when nodes are not in the DOM

        this._hideLabelIfEmpty();
      }
    }, {
      key: "checked",
      get: function get() {
        return this._checked || false;
      },
      set: function set(value) {
        this._checked = transform.booleanAttr(value);

        this._reflectAttribute('checked', this._checked);

        this._elements.input.checked = this._checked;
      }
      /**
       The switch's label element.
        @type {SwitchLabel}
       @contentzone
       */

    }, {
      key: "label",
      get: function get() {
        return this._getContentZone(this._elements.label);
      },
      set: function set(value) {
        this._setContentZone('label', value, {
          handle: 'label',
          tagName: 'coral-switch-label',
          insert: function insert(label) {
            this._elements.labelWrapper.appendChild(label);
          }
        });
      }
      /**
       Name used to submit the data in a form.
       @type {String}
       @default ""
       @htmlattribute name
       @htmlattributereflected
       */

    }, {
      key: "name",
      get: function get() {
        return this._elements.input.name;
      },
      set: function set(value) {
        this._reflectAttribute('name', value);

        this._elements.input.name = value;
      }
      /**
       The value that will be submitted when the checkbox is checked. Changing this value will not trigger an event.
        @type {String}
       @default "on"
       @htmlattribute value
       */

    }, {
      key: "value",
      get: function get() {
        return this._elements.input.value || 'on';
      },
      set: function set(value) {
        this._elements.input.value = value;
      }
      /**
       Whether this field is disabled or not.
       @type {Boolean}
       @default false
       @htmlattribute disabled
       @htmlattributereflected
       */

    }, {
      key: "disabled",
      get: function get() {
        return this._disabled || false;
      },
      set: function set(value) {
        this._disabled = transform.booleanAttr(value);

        this._reflectAttribute('disabled', this._disabled);

        this[this._disabled ? 'setAttribute' : 'removeAttribute']('aria-disabled', this._disabled);
        this.classList.toggle('is-disabled', this._disabled);
        this._elements.input.disabled = this._disabled;
      }
      /**
       Whether this field is required or not.
       @type {Boolean}
       @default false
       @htmlattribute required
       @htmlattributereflected
       */

    }, {
      key: "required",
      get: function get() {
        return this._required || false;
      },
      set: function set(value) {
        this._required = transform.booleanAttr(value);

        this._reflectAttribute('required', this._required);

        this._elements.input.required = this._required;
      }
      /**
       Whether this field is readOnly or not. Indicating that the user cannot modify the value of the control.
       @type {Boolean}
       @default false
       @htmlattribute readonly
       @htmlattributereflected
       */

    }, {
      key: "readOnly",
      get: function get() {
        return this._readOnly || false;
      },
      set: function set(value) {
        this._readOnly = transform.booleanAttr(value);

        this._reflectAttribute('readonly', this._readOnly);

        this.classList.toggle('is-readOnly', this._readOnly);
        this._elements.input.tabIndex = this._readOnly ? -1 : 0;
      }
      /**
       Inherited from {@link BaseFormField#labelled}.
       */

    }, {
      key: "labelled",
      get: function get() {
        return _get(_getPrototypeOf(Switch.prototype), "labelled", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(Switch.prototype), "labelled", value, this, true);

        this._hideLabelIfEmpty();
      }
      /*
       Indicates to the formField that the 'checked' property needs to be set in this component.
        @protected
       */

    }, {
      key: "_componentTargetProperty",
      get: function get() {
        return 'checked';
      }
      /*
       Indicates to the formField that the 'checked' property has to be extracted from the event.
        @protected
       */

    }, {
      key: "_eventTargetProperty",
      get: function get() {
        return 'checked';
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-switch-label': 'label'
        };
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(Switch), "observedAttributes", this).concat(['checked']);
      }
    }]);

    return Switch;
  }(BaseFormField(BaseComponent(HTMLElement)));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Switch.Label
   @classdesc The Switch label
   @htmltag coral-switch-label
   @return {HTMLElement}
   */
  var SwitchLabel = (function () {
    return document.createElement('coral-switch-label');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons.extend(strings, {
    'coral-component-switch': translations$l
  }); // Expose component on the Coral namespace

  commons._define('coral-switch', Switch);

  Switch.Label = SwitchLabel;

  /**
   * Copyright 2020 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var translations$m = {
    "en-US": {
      "Select": "Select",
      "Select All": "Select All",
      "sorted by column {0}, in ascending order": "sorted by column {0} in ascending order",
      "sorted by column {0}, in descending order": "sorted by column {0} in descending order",
      ", checked": ", checked",
      ", unchecked": ", unchecked"
    },
    "de-DE": {
      "Select": "AuswÃ¤hlen",
      "Select All": "Alles auswÃ¤hlen",
      "sorted by column {0}, in ascending order": "Sortiert nach Spalte {0} in aufsteigender Reihenfolge",
      "sorted by column {0}, in descending order": "Sortiert nach Spalte {0} in absteigender Reihenfolge",
      ", checked": ", markiert",
      ", unchecked": ", nicht markiert"
    },
    "fr-FR": {
      "Select": "SÃ©lectionner",
      "Select All": "SÃ©lectionner tout",
      "sorted by column {0}, in ascending order": "TriÃ© par colonne {0} dans lâordre ascendant",
      "sorted by column {0}, in descending order": "TriÃ© par colonne {0} dans lâordre dÃ©croissant",
      ", checked": ", cochÃ©e",
      ", unchecked": ", pas cochÃ©e"
    },
    "it-IT": {
      "Select": "Seleziona",
      "Select All": "Seleziona tutto",
      "sorted by column {0}, in ascending order": "Ordinato per colonna {0} in ordine crescente",
      "sorted by column {0}, in descending order": "Ordinato per colonna {0} in ordine decrescente",
      ", checked": ", selezionata",
      ", unchecked": ", non selezionata"
    },
    "ja-JP": {
      "Select": "é¸æ",
      "Select All": "ãã¹ã¦ãé¸æ",
      "sorted by column {0}, in ascending order": "å {0} ã§æé ã§ä¸¦ã¹æ¿ã",
      "sorted by column {0}, in descending order": "å {0} ã§éé ã«ä¸¦ã¹æ¿ã",
      ", checked": "ããã§ãã¯",
      ", unchecked": "ãæªãã§ãã¯"
    },
    "es-ES": {
      "Select": "Seleccionar",
      "Select All": "Seleccionar todos",
      "sorted by column {0}, in ascending order": "Ordenado por columna {0} en orden ascendente",
      "sorted by column {0}, in descending order": "Ordenado por columna {0} en orden descendente",
      ", checked": ", marcada",
      ", unchecked": ", desmarcada"
    },
    "ko-KR": {
      "Select": "ì í",
      "Select All": "ëª¨ë ì í",
      "sorted by column {0}, in ascending order": "ì¤ë¦ì°¨ìì¼ë¡ ì´ {0} ì ë ¬",
      "sorted by column {0}, in descending order": "ë´ë¦¼ì°¨ìì¼ë¡ {0} ì´ë³ë¡ ì ë ¬",
      ", checked": ", ì íë¨",
      ", unchecked": ", ì íëì§ ìì"
    },
    "zh-CN": {
      "Select": "éæ©",
      "Select All": "å¨é",
      "sorted by column {0}, in ascending order": "æå{0}æååºæåºr",
      "sorted by column {0}, in descending order": "æå{0}æéåºæåº",
      ", checked": "ï¼éä¸­",
      ", unchecked": "ï¼æªéä¸­"
    },
    "zh-TW": {
      "Select": "é¸å",
      "Select All": "å¨é¸",
      "sorted by column {0}, in ascending order": "æå{0}ææåªæåº",
      "sorted by column {0}, in descending order": "æå{0}æéåªæåº",
      ", checked": "ï¼é¸ä¸­",
      ", unchecked": "ï¼æªé¸ä¸­"
    },
    "pt-BR": {
      "Select": "Selecionar",
      "Select All": "Selecionar tudo",
      "sorted by column {0}, in ascending order": "Classificado por coluna {0} em ordem ascendente",
      "sorted by column {0}, in descending order": "Classificado por coluna {0} em ordem descendente",
      ", checked": ", marcada",
      ", unchecked": ", desmarcada"
    },
    "nl-NL": {
      "Select": "Selecteren",
      "Select All": "Alles selecteren",
      "sorted by column {0}, in ascending order": "Gesorteerd op kolom {0} in oplopende volgorde",
      "sorted by column {0}, in descending order": "Gesorteerd op kolom {0} in aflopende volgorde",
      ", checked": ", geselecteerd",
      ", unchecked": ", neit geselecteerd"
    },
    "da-DK": {
      "Select": "VÃ¦lg",
      "Select All": "VÃ¦lg alle",
      "sorted by column {0}, in ascending order": "Sorteret efter kolonne {0} i stigende rÃ¦kkefÃ¸lge",
      "sorted by column {0}, in descending order": "Sorteret efter kolonne {0} i faldende rÃ¦kkefÃ¸lge",
      ", checked": ", valgte",
      ", unchecked": ", ikke valgt"
    },
    "fi-FI": {
      "Select": "Valitse",
      "Select All": "Valitse kaikki",
      "sorted by column {0}, in ascending order": "Lajiteltu sarakkeen mukaan {0} nousevaan jÃ¤rjestykseen",
      "sorted by column {0}, in descending order": "Lajiteltu sarakkeen mukaan {0} laskevassa jÃ¤rjestyksessÃ¤",
      ", checked": ", valittu",
      ", unchecked": ", valittuna"
    },
    "nb-NO": {
      "Select": "Velg",
      "Select All": "Velg alle",
      "sorted by column {0}, in ascending order": "Sortert etter kolonne {0} i stigende rekkefÃ¸lge",
      "sorted by column {0}, in descending order": "Sortert etter kolonne {0} i synkende rekkefÃ¸lge",
      ", checked": ", valgt",
      ", unchecked": ", ikke valgt"
    },
    "sv-SE": {
      "Select": "Markera",
      "Select All": "Markera allt",
      "sorted by column {0}, in ascending order": "Sorterat efter kolumn {0} i stigande ordning",
      "sorted by column {0}, in descending order": "Sorterat efter kolumn {0} i fallande ordning",
      ", checked": ", markerad",
      ", unchecked": ", avmarkerad"
    },
    "cs-CZ": {
      "Select": "Vybrat",
      "Select All": "Vybrat vÅ¡e",
      "sorted by column {0}, in ascending order": "SeÅazeno podle sloupcovÃ½ch {0} ve vzestupnÃ©m poÅadÃ­",
      "sorted by column {0}, in descending order": "SeÅazeno podle sloupcovÃ½ch {0} v sestupnÃ©m poÅadÃ­",
      ", checked": ", vybrÃ¡no",
      ", unchecked": ", nenÃ­ vybrÃ¡no"
    },
    "pl-PL": {
      "Select": "Zaznacz",
      "Select All": "Zaznacz wszystko",
      "sorted by column {0}, in ascending order": "Posortowane wedÅug kolumny {0} w porzÄdku rosnÄcym",
      "sorted by column {0}, in descending order": "Posortowane wedÅug kolumny {0} w porzÄdku malejÄcym",
      ", checked": ", zaznaczone",
      ", unchecked": ", nie zaznaczone"
    },
    "ru-RU": {
      "Select": "ÐÑÐ±ÑÐ°ÑÑ",
      "Select All": "ÐÑÐ±ÑÐ°ÑÑ Ð²ÑÐµ",
      "sorted by column {0}, in ascending order": "Ð¡Ð¾ÑÑÐ¸ÑÐ¾Ð²ÐºÐ° Ð¿Ð¾ ÑÑÐ¾Ð»Ð±Ðµ {0} Ð² Ð¿Ð¾ÑÑÐ´ÐºÐµ Ð²Ð¾Ð·ÑÐ°ÑÑÐ°Ð½Ð¸Ñ",
      "sorted by column {0}, in descending order": "Ð¡Ð¾ÑÑÐ¸ÑÐ¾Ð²ÐºÐ° Ð¿Ð¾ ÐºÐ¾Ð»Ð¾Ð½ÐºÐµ {0} Ð² Ð¿Ð¾ÑÑÐ´ÐºÐµ ÑÐ±ÑÐ²Ð°Ð½Ð¸Ñ",
      ", checked": ", Ð²ÑÐ±ÑÐ°Ð½Ð½ÑÐ¹",
      ", unchecked": ", Ð½ÐµÐ¾ÑÐ¾Ð±ÑÐ°Ð½Ð½ÑÐ¹"
    },
    "tr-TR": {
      "Select": "SeÃ§",
      "Select All": "TÃ¼mÃ¼nÃ¼ SeÃ§",
      "sorted by column {0}, in ascending order": "Artan sÄ±rada {0} sÃ¼tununa gÃ¶re sÄ±ralanmÄ±Å",
      "sorted by column {0}, in descending order": "Azalan sÄ±rada {0} sÃ¼tununa gÃ¶re sÄ±ralanmÄ±Å",
      ", checked": ", seÃ§ilmiÅ",
      ", unchecked": ", seÃ§ilmemiÅ"
    }
  };

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /** @ignore */
  var isTableHeaderCell = function isTableHeaderCell(node) {
    return node.nodeName === 'TH' && node.getAttribute('is') === 'coral-table-headercell';
  };
  /** @ignore */


  var isTableCell = function isTableCell(node) {
    return node.nodeName === 'TD' && node.getAttribute('is') === 'coral-table-cell';
  };
  /** @ignore */


  var isTableRow = function isTableRow(node) {
    return node.nodeName === 'TR' && node.getAttribute('is') === 'coral-table-row';
  };
  /** @ignore */


  var isTableBody = function isTableBody(node) {
    return node.nodeName === 'TBODY' && node.getAttribute('is') === 'coral-table-body';
  };
  /** @ignore */


  var getIndexOf = function getIndexOf(el) {
    var parent = el.parentNode;

    if (!parent) {
      return -1;
    }

    return Array.prototype.indexOf.call(parent.children, el);
  };
  /** @ignore */


  var getSiblingsOf = function getSiblingsOf(el, selector, type) {
    var stack = []; // Returns siblings of el

    if (!type) {
      ['previousElementSibling', 'nextElementSibling'].forEach(function (direction) {
        var sibling = el;

        while (sibling[direction]) {
          sibling = sibling[direction];

          if (sibling.matches(selector)) {
            stack.push(sibling);
          }
        }
      });
    } else {
      var direction = type.indexOf('next') === 0 ? 'nextElementSibling' : 'previousElementSibling'; // All following siblings of el up to but not including the element matched by the selector

      if (type.indexOf('Until') !== -1) {
        var matches = function matches() {
          if (typeof selector === 'string') {
            return el[direction].matches(selector);
          }

          return el[direction] === selector;
        };

        while (el[direction] && !matches()) {
          stack.push(el = el[direction]);
        }
      } // All following siblings of el filtered by a selector.
      else if (type.indexOf('All') !== -1) {
          while (el[direction]) {
            el = el[direction];

            if (el.matches(selector)) {
              stack.push(el);
            }
          }
        } // Returns the sibling only if it matches that selector.
        else {
            var sibling = el[direction];
            return sibling && sibling.matches(selector) ? sibling : null;
          }
    }

    return stack;
  };
  /** @ignore */


  var listToArray$1 = function listToArray(list) {
    var res = [];

    for (var i = 0, listCount = res.length = list.length; i < listCount; i++) {
      res[i] = list[i];
    }

    return res;
  };
  /** @ignore */


  var getColumns = function getColumns(colgroup) {
    return listToArray$1(colgroup.querySelectorAll('col[is="coral-table-column"]'));
  };
  /** @ignore */


  var getRows = function getRows(sections) {
    var rows = [];
    sections.forEach(function (section) {
      if (section) {
        rows = rows.concat(listToArray$1(section.querySelectorAll('tr[is="coral-table-row"]')));
      }
    });
    return rows;
  };
  /** @ignore */


  var getCells = function getCells(row) {
    return listToArray$1(row.querySelectorAll('td[is="coral-table-cell"], th[is="coral-table-headercell"]'));
  };
  /** @ignore */


  var getContentCells = function getContentCells(row) {
    return listToArray$1(row.querySelectorAll('td[is="coral-table-cell"]'));
  };
  /** @ignore */


  var getHeaderCells = function getHeaderCells(row) {
    return listToArray$1(row.querySelectorAll('th[is="coral-table-headercell"]'));
  };
  /** @ignore */


  var getCellByIndex = function getCellByIndex(row, index) {
    return getCells(row).filter(function (cell) {
      return getIndexOf(cell) === index;
    })[0] || null;
  };
  /**
   Enumeration for {@link TableHead}, {@link TableBody} and {@link TableFoot} divider values.

   @typedef {Object} TableSectionDividerEnum

   @property {String} NONE
   No divider.
   @property {String} ROW
   Row divider.
   @property {String} COLUMN
   Column divider.
   @property {String} CELL
   Row and Column divider.
   */


  var divider = {
    NONE: 'none',
    ROW: 'row',
    COLUMN: 'column',
    CELL: 'cell'
  };
  /**
   Enumeration for {@link TableColumn} alignment options.

   @typedef {Object} TableColumnAlignmentEnum

   @property {String} LEFT
   Left alignment.
   @property {String} CENTER
   Center alignment.
   @property {String} RIGHT
   Right alignment.
   */

  var alignment = {
    LEFT: 'left',
    CENTER: 'center',
    RIGHT: 'right'
  };

  var CLASSNAME$1r = '_coral-Table-column';
  /**
   Enumeration for {@link TableColumn} sortable direction options.

   @typedef {Object} TableColumnSortableDirectionEnum

   @property {String} DEFAULT
   Default. No sorting applied.
   @property {String} ASCENDING
   Ascending sort.
   @property {String} DESCENDING
   Descending sort.
   */

  var sortableDirection = {
    DEFAULT: 'default',
    ASCENDING: 'ascending',
    DESCENDING: 'descending'
  };
  /**
   Enumeration for {@link TableColumn} sortable type options.

   @typedef {Object} TableColumnSortableTypeEnum

   @property {String} ALPHANUMERIC
   Alphanumeric type. If sorting is based on {@link TableCell#value}, use {String}.
   @property {String} NUMBER
   Number type. If sorting is based on {@link TableCell#value}, use {Number}.
   @property {String} DATE
   Date type. If sorting is based on {@link TableCell#value}, use {Date} in milliseconds.
   @property {String} CUSTOM
   Custom type. Sorting is based on user defined sorting.
   */

  var sortableType = {
    ALPHANUMERIC: 'alphanumeric',
    NUMBER: 'number',
    DATE: 'date',
    CUSTOM: 'custom'
  };
  /**
   @class Coral.Table.Column
   @classdesc A Table column component
   @htmltag coral-table-column
   @htmlbasetag col
   @extends {HTMLTableColElement}
   @extends {BaseComponent}
   */

  var TableColumn = /*#__PURE__*/function (_BaseComponent) {
    _inherits(TableColumn, _BaseComponent);

    var _super = _createSuper(TableColumn);

    function TableColumn() {
      _classCallCheck(this, TableColumn);

      return _super.apply(this, arguments);
    }

    _createClass(TableColumn, [{
      key: "_sort",

      /** @private */
      value: function _sort() {
        var newSortableDirection;

        if (this.sortableDirection === sortableDirection.DEFAULT) {
          newSortableDirection = sortableDirection.ASCENDING;
        } else if (this.sortableDirection === sortableDirection.ASCENDING) {
          newSortableDirection = sortableDirection.DESCENDING;
        } else if (this.sortableDirection === sortableDirection.DESCENDING) {
          newSortableDirection = sortableDirection.DEFAULT;
        }

        this.trigger('coral-table-column:_beforecolumnsort', {
          newSortableDirection: newSortableDirection
        });
      }
      /** @private */

    }, {
      key: "_doSort",
      value: function _doSort(onInitialization) {
        this.trigger('coral-table-column:_sort', {
          onInitialization: onInitialization,
          sortableDirection: sortableDirection,
          sortableType: sortableType
        });
      }
      /**
       Returns {@link TableColumn} sortable direction options.
        @return {TableColumnSortableDirectionEnum}
       */

    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(TableColumn.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1r); // Default reflected attributes

        if (!this._sortableType) {
          this.sortableType = sortableType.ALPHANUMERIC;
        }

        if (!this._sortableDirection) {
          this.sortableDirection = sortableDirection.DEFAULT;
        }

        if (!this._alignment) {
          this.alignment = alignment.LEFT;
        }
      }
      /**
       Triggered when {@link TableColumn#alignment} changed.
        @typedef {CustomEvent} coral-table-column:_alignmentchanged
        @private
       */

      /**
       Triggered when {@link TableColumn#fixedWidth} changed.
        @typedef {CustomEvent} coral-table-column:_fixedwidthchanged
        @private
       */

      /**
       Triggered when {@link TableColumn#orderable} changed.
        @typedef {CustomEvent} coral-table-column:_orderablechanged
        @private
       */

      /**
       Triggered when {@link TableColumn#sortable} changed.
        @typedef {CustomEvent} coral-table-column:_sortablechanged
        @private
       */

      /**
       Triggered when {@link TableColumn#sortableDirection} changed.
        @typedef {CustomEvent} coral-table-column:_sortabledirectionchanged
        @private
       */

      /**
       Triggered when {@link TableColumn#hidden} changed.
        @typedef {CustomEvent} coral-table-column:_hiddenchanged
        @private
       */

      /**
       Triggered before {@link TableColumn#sortableDirection} changed.
        @typedef {CustomEvent} coral-table-column:_beforecolumnsort
        @private
       */

      /**
       Triggered when {@link TableColumn#sortableDirection} changed.
        @typedef {CustomEvent} coral-table-column:_sort
        @private
       */

    }, {
      key: "alignment",

      /**
       The column cells alignment. The alignment should take the {@link i18n} configuration into account.
        @type {String}
       @default TableColumnAlignmentEnum.LEFT
       @htmlattribute alignment
       @htmlattributereflected
       */
      get: function get() {
        return this._alignment || alignment.LEFT;
      },
      set: function set(value) {
        var _this = this;

        var oldValue = this._alignment;
        value = transform.string(value).toLowerCase();
        this._alignment = validate.enumeration(alignment)(value) && value || alignment.LEFT;

        this._reflectAttribute('alignment', this._alignment); // Don't trigger on initialization if alignment is LEFT to improve performance


        if (!(typeof oldValue === 'undefined' && this._alignment === alignment.LEFT)) {
          window.requestAnimationFrame(function () {
            _this.trigger('coral-table-column:_alignmentchanged');
          });
        }
      }
      /**
       Whether the column has a fixed width.
        @type {Boolean}
       @default false
       @htmlattribute fixedwidth
       @htmlattributereflected
       */

    }, {
      key: "fixedWidth",
      get: function get() {
        return this._fixedWidth || false;
      },
      set: function set(value) {
        var _this2 = this;

        this._fixedWidth = transform.booleanAttr(value);

        this._reflectAttribute('fixedwidth', this._fixedWidth);

        window.requestAnimationFrame(function () {
          _this2.trigger('coral-table-column:_fixedwidthchanged');
        });
      }
      /**
       Whether the column is hidden.
        @type {Boolean}
       @default false
       @htmlattribute hidden
       @htmlattributereflected
       */

    }, {
      key: "hidden",
      get: function get() {
        return this._hidden || false;
      },
      set: function set(value) {
        var _this3 = this;

        this._hidden = transform.booleanAttr(value);

        this._reflectAttribute('hidden', this._hidden);

        window.requestAnimationFrame(function () {
          _this3.trigger('coral-table-column:_hiddenchanged');
        });
      }
      /**
       Whether the table column is orderable.
       Note that this does not affect the underlying data, only presentation.
        @type {Boolean}
       @default false
       @htmlattribute orderable
       @htmlattributereflected
       */

    }, {
      key: "orderable",
      get: function get() {
        return this._orderable || false;
      },
      set: function set(value) {
        var _this4 = this;

        this._orderable = transform.booleanAttr(value);

        this._reflectAttribute('orderable', this._orderable);

        window.requestAnimationFrame(function () {
          _this4.trigger('coral-table-column:_orderablechanged');
        });
      }
      /**
       Whether the column is sortable by user interaction.
        @type {Boolean}
       @default false
       @htmlattribute sortable
       @htmlattributereflected
       */

    }, {
      key: "sortable",
      get: function get() {
        return this._sortable || false;
      },
      set: function set(value) {
        var _this5 = this;

        this._sortable = transform.booleanAttr(value);

        this._reflectAttribute('sortable', this._sortable);

        window.requestAnimationFrame(function () {
          _this5.trigger('coral-table-column:_sortablechanged');
        });
      }
      /**
       The sorting type. See {@link TableColumnSortableTypeEnum}. If setting to <code>custom</code>, columns won't sort
       based on the default table sorting.
       Instead, a custom sorting can be performed when triggered by user interaction. This can be defined by listening to
       the {@link coral-table:beforecolumnsort} event.
        @type {String}
       @default TableColumnSortableTypeEnum.ALPHANUMERIC
       @htmlattribute sortabletype
       @htmlattributereflected
       */

    }, {
      key: "sortableType",
      get: function get() {
        return this._sortableType || sortableType.ALPHANUMERIC;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        this._sortableType = validate.enumeration(sortableType)(value) && value || sortableType.ALPHANUMERIC;

        this._reflectAttribute('sortabletype', this._sortableType);
      }
      /**
       The sorting direction. Sorts the column cells based on {@link TableCell#value}.
       If not present, the sort is based on the cell text content. See {@link TableColumnSortableDirectionEnum}.
        @type {String}
       @default TableColumnSortableDirectionEnum.DEFAULT
       @htmlattribute sortabledirection
       @htmlattributereflected
       */

    }, {
      key: "sortableDirection",
      get: function get() {
        return this._sortableDirection || sortableDirection.DEFAULT;
      },
      set: function set(value) {
        var _this6 = this;

        value = transform.string(value).toLowerCase();
        this._sortableDirection = validate.enumeration(sortableDirection)(value) && value || sortableDirection.DEFAULT;

        this._reflectAttribute('sortabledirection', this._sortableDirection); // Prevent sorting if unnecessary


        if (!this._preventSort) {
          this._doSort();

          window.requestAnimationFrame(function () {
            _this6.trigger('coral-table-column:_sortabledirectionchanged');
          });
        }
      }
    }], [{
      key: "sortableDirection",
      get: function get() {
        return sortableDirection;
      }
      /**
       Returns {@link TableColumn} sortable type options.
        @return {TableColumnSortableTypeEnum}
       */

    }, {
      key: "sortableType",
      get: function get() {
        return sortableType;
      }
      /**
       Returns {@link TableColumn} alignment options.
        @return {TableColumnAlignmentEnum}
       */

    }, {
      key: "alignment",
      get: function get() {
        return alignment;
      }
    }, {
      key: "_attributePropertyMap",
      get: function get() {
        return commons.extend(_get(_getPrototypeOf(TableColumn), "_attributePropertyMap", this), {
          fixedwidth: 'fixedWidth',
          sortabletype: 'sortableType',
          sortabledirection: 'sortableDirection'
        });
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(TableColumn), "observedAttributes", this).concat(['fixedwidth', 'hidden', 'alignment', 'orderable', 'sortable', 'sortabletype', 'sortabledirection']);
      }
    }]);

    return TableColumn;
  }(BaseComponent(HTMLTableColElement));

  var CLASSNAME$1s = '_coral-Table-cell';
  /**
   @class Coral.Table.Cell
   @classdesc A Table cell component
   @htmltag coral-table-cell
   @htmlbasetag td
   @extends {HTMLTableCellElement}
   @extends {BaseComponent}
   */

  var TableCell = /*#__PURE__*/function (_BaseComponent) {
    _inherits(TableCell, _BaseComponent);

    var _super = _createSuper(TableCell);

    function TableCell() {
      _classCallCheck(this, TableCell);

      return _super.apply(this, arguments);
    }

    _createClass(TableCell, [{
      key: "_setHandle",

      /** @private */
      value: function _setHandle(handle) {
        var _this = this;

        requestAnimationFrame(function () {
          // Specify handle directly on the cell if none found
          if (!_this.querySelector("[".concat(handle, "]"))) {
            _this.setAttribute(handle, '');
          }

          _this._syncAriaSelectedState();

          _this._syncSelectHandle();
        });
      }
      /** @private */

    }, {
      key: "_getHandle",
      value: function _getHandle(handle) {
        return this.hasAttribute(handle) ? this : this.querySelector("[".concat(handle, "]"));
      }
      /** @private */

    }, {
      key: "_toggleSelectable",
      value: function _toggleSelectable(selectable) {
        if (selectable) {
          this._setHandle('coral-table-cellselect');
        } else {
          // Remove the handle
          this.removeAttribute('coral-table-cellselect'); // Clear selection

          this.selected = false;
        }

        this._syncAriaSelectedState();
      }
      /** @private */

    }, {
      key: "_syncAriaSelectedState",
      value: function _syncAriaSelectedState() {
        this.classList.toggle('is-selected', this.selected);

        if (this._getHandle('coral-table-cellselect')) {
          this.setAttribute('aria-selected', this.selected);
        } else {
          this.removeAttribute('aria-selected');
        }
      }
      /** @private */

    }, {
      key: "_syncSelectHandle",
      value: function _syncSelectHandle() {
        // Check/uncheck the select handle
        var selectHandle = this.querySelector('coral-checkbox');

        if (selectHandle) {
          selectHandle[this.selected ? 'setAttribute' : 'removeAttribute']('checked', '');
        }
      }
      /** @ignore */

    }, {
      key: "attributeChangedCallback",

      /** @ignore */
      value: function attributeChangedCallback(name, oldValue, value) {
        if (name === '_selectable') {
          this._toggleSelectable(value !== null);
        } else {
          _get(_getPrototypeOf(TableCell.prototype), "attributeChangedCallback", this).call(this, name, oldValue, value);
        }
      }
      /** @ignore */

    }, {
      key: "render",
      value: function render() {
        _get(_getPrototypeOf(TableCell.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1s);
        this.id = this.id || commons.getUID();
      }
      /**
       Triggered before {@link TableCell#selected} is changed.
        @typedef {CustomEvent} coral-table-cell:_beforeselectedchanged
        @private
       */

      /**
       Triggered when {@link TableCell#selected} changed.
        @typedef {CustomEvent} coral-table-cell:_selectedchanged
        @private
       */

    }, {
      key: "content",
      // @compat
      get: function get() {
        return this;
      },
      set: function set(value) {
        // Support configs
        if (_typeof(value) === 'object') {
          for (var prop in value) {
            /** @ignore */
            this[prop] = value[prop];
          }
        }
      }
      /**
       Whether the table cell is selected.
        @type {Boolean}
       @default false
       @htmlattribute selected
       @htmlattributereflected
       */

    }, {
      key: "selected",
      get: function get() {
        return this._selected || false;
      },
      set: function set(value) {
        // Prevent selection if disabled
        if (this.hasAttribute('coral-table-cellselect') && this.hasAttribute('disabled') || this.querySelector('[coral-table-cellselect][disabled]')) {
          return;
        }

        this.trigger('coral-table-cell:_beforeselectedchanged');
        this._selected = transform.booleanAttr(value);

        this._reflectAttribute('selected', this._selected);

        this.trigger('coral-table-cell:_selectedchanged');

        this._syncAriaSelectedState();

        this._syncSelectHandle();
      }
      /**
       The cell's value. It is used to compare cells during a column sort. If not set, the sorting will be performed on the
       cell content. The content will be parse accordingly based on the column's <code>sortabletype</code> property.
        @type {String}
       @default ""
       @htmlattribute value
       @htmlattributereflected
       */

    }, {
      key: "value",
      get: function get() {
        return this.getAttribute('value') || '';
      },
      set: function set(value) {
        this.setAttribute('value', transform.string(value));
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(TableCell), "observedAttributes", this).concat(['selected', '_selectable']);
      }
    }]);

    return TableCell;
  }(BaseComponent(HTMLTableCellElement));

  var template$W = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["accessibilityState"] = document.createElement("div");
    el0.setAttribute("handle", "accessibilityState");
    el0.className += " u-coral-screenReaderOnly _coral-Table-row-accessibilityState";
    el0.setAttribute("aria-hidden", "true");
    el0.id = data_0["commons"]["getUID"]();
    frag.appendChild(el0);
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    return frag;
  };

  var CLASSNAME$1t = '_coral-Table-row';
  /**
   @class Coral.Table.Row
   @classdesc A Table row component
   @htmltag coral-table-row
   @htmlbasetag tr
   @extends {HTMLTableRowElement}
   @extends {BaseComponent}
   */

  var TableRow = /*#__PURE__*/function (_BaseComponent) {
    _inherits(TableRow, _BaseComponent);

    var _super = _createSuper(TableRow);

    /** @ignore */
    function TableRow() {
      var _this;

      _classCallCheck(this, TableRow);

      _this = _super.call(this); // Templates

      _this._elements = {};
      template$W.call(_this._elements, {
        commons: commons
      }); // Required for coral-table-row:change event

      _this._oldSelection = []; // Events

      _this._delegateEvents({
        // Private
        'coral-table-cell:_beforeselectedchanged': '_onBeforeCellSelectionChanged',
        'coral-table-cell:_selectedchanged': '_onCellSelectionChanged'
      }); // Initialize content MO


      _this._observer = new MutationObserver(_this._handleMutations.bind(_assertThisInitialized(_this)));

      _this._observer.observe(_assertThisInitialized(_this), {
        childList: true
      });

      return _this;
    }
    /**
     Whether the table row is locked.
      @type {Boolean}
     @default false
     @htmlattribute locked
     @htmlattributereflected
     */


    _createClass(TableRow, [{
      key: "_triggerChangeEvent",
      value: function _triggerChangeEvent() {
        var selectedItems = this.selectedItems;
        this.trigger('coral-table-row:_change', {
          oldSelection: this._oldSelection,
          selection: selectedItems
        });
        this._oldSelection = selectedItems;
      }
      /** @private */

    }, {
      key: "_onCellSelectionChanged",
      value: function _onCellSelectionChanged(event) {
        event.stopImmediatePropagation();

        this._triggerChangeEvent();
      }
      /** @private */

    }, {
      key: "_onBeforeCellSelectionChanged",
      value: function _onBeforeCellSelectionChanged(event) {
        event.stopImmediatePropagation(); // In single selection, if the added item is selected, the rest should be deselected

        var selectedItem = this.selectedItem;

        if (!this.multiple && selectedItem && !event.target.selected) {
          selectedItem.set('selected', false, true);
        }
      }
      /** @private */

    }, {
      key: "_syncAriaSelectedState",
      value: function _syncAriaSelectedState() {
        var _this2 = this;

        this.classList.toggle('is-selected', this.selected);
        var selectHandle = this.querySelector('[coral-table-rowselect]'); // @a11y Only update aria-selected if the table row can be selected

        if (!(this.hasAttribute('coral-table-rowselect') || selectHandle)) {
          this.removeAttribute('aria-selected');
          return;
        }

        var rowOrderHandle = this.querySelector('[coral-table-roworder]');
        var rowLockHandle = this.querySelector('[coral-table-rowlock]');
        var rowRemoveHandle = this.querySelector('[coral-row-remove]');
        var accessibilityState = this._elements.accessibilityState;

        var resetAccessibilityState = function resetAccessibilityState() {
          // @a11y remove aria-live
          _this2.removeAttribute('aria-live');

          _this2.removeAttribute('aria-atomic');

          _this2.removeAttribute('aria-relevant'); // @a11y Unhide the selectHandle, so that it will be resume being announced by assistive
          // technology


          if (selectHandle && selectHandle.tagName === 'CORAL-CHECKBOX') {
            selectHandle.removeAttribute('aria-hidden');
          } // @a11y Unhide the coral-table-roworder handle, so that it will be resume being announced by
          // assistive technology


          if (rowOrderHandle) {
            rowOrderHandle.removeAttribute('aria-hidden');
          } // @a11y Unhide the coral-table-rowlock handle, so that it will be resume being announced by
          // assistive technology


          if (rowLockHandle) {
            rowLockHandle.removeAttribute('aria-hidden');
          } // @a11y Unhide the coral-row-remove handle, so that it will be resume being announced by
          // assistive technology


          if (rowRemoveHandle) {
            rowRemoveHandle.removeAttribute('aria-hidden');
          }

          if (accessibilityState) {
            // @a11y Hide the _accessibilityState from assistive technology, so that it can not be read
            // using a screen reader separately from the row it helps label
            accessibilityState.setAttribute('aria-hidden', 'true'); // @a11y If the item is not selected, remove ', unchecked' to decrease verbosity.

            if (!_this2.selected) {
              accessibilityState.innerHTML = '';
            }
          }
        }; // @a11y set aria-selected


        this.setAttribute('aria-selected', this.selected);

        if (this._ariaLiveOnTimeout || this._ariaLiveOffTimeout) {
          clearTimeout(this._ariaLiveOnTimeout);
          clearTimeout(this._ariaLiveOffTimeout);
        } // @ally If _accessibilityState has been added to a cell within the row,


        if (accessibilityState) {
          resetAccessibilityState();
          this._ariaLiveOnTimeout = setTimeout(function () {
            // @a11y and the row or one of its descendants has focus,
            if (_this2 === document.activeElement || _this2.contains(document.activeElement)) {
              // @a11y Hide the "Select" checkbox so that it does not get announced with the state change.
              if (selectHandle && selectHandle.tagName === 'CORAL-CHECKBOX') {
                selectHandle.setAttribute('aria-hidden', 'true');
              } // @a11y Hide the coral-table-roworder handle so that it does not get announced with the
              // state change.


              if (rowOrderHandle) {
                rowOrderHandle.setAttribute('aria-hidden', 'true');
              } // @a11y Hide the coral-table-rowlock handle so that it does not get announced with the state
              // change.


              if (rowLockHandle) {
                rowLockHandle.setAttribute('aria-hidden', 'true');
              } // @a11y Hide the coral-row-remove handle so that it does not get announced with the state
              // change.


              if (rowRemoveHandle) {
                rowRemoveHandle.setAttribute('aria-hidden', 'true');
              } // @a11y The ChromeVox screenreader, used on Chromebook, announces the state change and
              // should not need aria-live, otherwise it double-voices the row.


              if (!window.cvox) {
                // @a11y Unhide the _accessibilityState so that it will get announced with the state change.
                accessibilityState.removeAttribute('aria-hidden'); // @ally use aria-live to announce the state change

                _this2.setAttribute('aria-live', 'assertive'); // @ally use aria-atomic="true" to announce the entire row


                _this2.setAttribute('aria-atomic', 'true');
              }

              _this2._ariaLiveOnTimeout = setTimeout(function () {
                // @ally Set the _accessibilityState text to read either ", checked" or ", unchecked",
                // which should trigger a live region announcement.
                accessibilityState.innerHTML = i18n.get(_this2.selected ? ', checked' : ', unchecked'); // @ally wait 250ms for row to announce

                _this2._ariaLiveOffTimeout = setTimeout(resetAccessibilityState, 250);
              }, 20);
            }
          }, 20);

          if (!(this === document.activeElement || this.contains(document.activeElement))) {
            accessibilityState.innerHTML = i18n.get(this.selected ? ', checked' : '');
          }
        }
      }
      /** @private */

    }, {
      key: "_syncAriaLabelledby",
      value: function _syncAriaLabelledby() {
        var _this3 = this;

        // @a11y if the row is not selectable, remove accessibilityState
        if (!(this.hasAttribute('coral-table-rowselect') || this.querySelector('[coral-table-rowselect]'))) {
          if (this._elements.accessibilityState.parentNode) {
            this.removeAttribute('aria-labelledby');
            this._elements.accessibilityState = this._elements.accessibilityState.parentNode.removeChild(this._elements.accessibilityState);
          }

          return;
        } // @a11y get a list of ids for cells


        var cells = this.items.getAll().filter(function (cell) {
          // @a11y exclude cells for coral-table-roworder, coral-table-rowlock or coral-row-remove
          return cell.id && !(cell.hasAttribute('coral-table-roworder') || cell.querySelector('[coral-table-roworder]') || cell.hasAttribute('coral-table-rowlock') || cell.querySelector('[coral-table-rowlock]') || cell.hasAttribute('coral-row-remove') || cell.querySelector('[coral-table-remove]'));
        });
        var rowHeaders = cells.filter(function (cell) {
          return cell.getAttribute('role') === 'rowheader' || cell.tagName === 'TH' && cell.getAttribute('scope') === 'row';
        });
        var cellForAccessibilityState;
        var ids = cells.map(function (cell) {
          var handle = cell.querySelector('[coral-table-rowselect]');

          if (handle) {
            cellForAccessibilityState = cell; // @a11y otherwise, if the selectHandle is a coral-checkbox,

            if (handle && handle.tagName === 'CORAL-CHECKBOX' && handle._elements) {
              // @a11y if the row is selected, don't add the coral-table-rowselect to accessibility name
              if (_this3.selected) {
                return;
              } // otherwise, include the checkbox input labelled "Select" in the accessibility name


              return handle._elements.input && handle._elements.input.id;
            }
          } // @a11y include row headers, or if no row header is defined,
          // all other cells in the row, in the accessibility name


          if (rowHeaders.length === 0 || rowHeaders.indexOf(cell) !== -1) {
            return cell.id;
          }
        }); // @a11y If an _accessibilityState has not been defined within one of the cells, add to the last
        // cell

        if (!cellForAccessibilityState && cells.length) {
          cellForAccessibilityState = cells[cells.length - 1];
        }

        if (cellForAccessibilityState) {
          cellForAccessibilityState.appendChild(this._elements.accessibilityState);
        } // @a11y Once defined,


        if (this._elements.accessibilityState.parentNode) {
          // @a11y add the _accessibilityState ", checked" or ", unchecked" as the last item in the
          // accessibility name
          ids.push(this._elements.accessibilityState.id);
        } // @a11y Update the aria-labelledby attribute for the row.


        this.setAttribute('aria-labelledby', ids.join(' '));
      }
      /** @private */

    }, {
      key: "_syncSelectHandle",
      value: function _syncSelectHandle() {
        var _this4 = this;

        // Check/uncheck the select handle
        var selectHandle = this.querySelector('[coral-table-rowselect]');

        if (selectHandle) {
          if (typeof selectHandle.indeterminate !== 'undefined') {
            selectHandle.indeterminate = false;
          }

          selectHandle[this.selected ? 'setAttribute' : 'removeAttribute']('checked', ''); // @a11y If the handle is a checkbox but lacks a label, label it with "Select".

          if (selectHandle.tagName === 'CORAL-CHECKBOX') {
            if (!selectHandle.labelled) {
              selectHandle.labelled = i18n.get('Select');
            } // @a11y provide a more explicit label for the checkbox than just "Select"


            if (this.hasAttribute('aria-labelledby')) {
              var ids = this.getAttribute('aria-labelledby').split(' ').filter(function (id) {
                return selectHandle._elements.input.id !== id && _this4._elements.accessibilityState.id !== id;
              }).join(' ');
              selectHandle.labelledBy = selectHandle._elements.input.id + ' ' + ids;
            }
          }
        }
      }
      /** @private */

    }, {
      key: "_toggleSelectable",
      value: function _toggleSelectable(selectable) {
        if (selectable) {
          this._setHandle('coral-table-rowselect');
        } else {
          // Clear selection but leave the handle if any
          this.set('selected', false, true);
        } // Sync the aria-labelledby attribute to include the _accessibilityState


        this._syncAriaLabelledby();
      }
      /** @private */

    }, {
      key: "_toggleOrderable",
      value: function _toggleOrderable(orderable) {
        if (orderable) {
          this._setHandle('coral-table-roworder');
        } // Remove DragAction instance
        else if (this.dragAction) {
            this.dragAction.destroy();
          }
      }
      /** @private */

    }, {
      key: "_toggleLockable",
      value: function _toggleLockable(lockable) {
        if (lockable) {
          this._setHandle('coral-table-rowlock');
        }
      }
      /** @private */

    }, {
      key: "_setHandle",
      value: function _setHandle(handle) {
        var _this5 = this;

        requestAnimationFrame(function () {
          // Specify handle directly on the row if none found
          if (!_this5.querySelector("[".concat(handle, "]"))) {
            _this5.setAttribute(handle, '');
          }

          _this5._syncSelectHandle();

          _this5._syncAriaLabelledby();

          _this5._syncAriaSelectedState();
        });
      }
      /** @private */

    }, {
      key: "_handleMutations",
      value: function _handleMutations(mutations) {
        var _this6 = this;

        mutations.forEach(function (mutation) {
          // Sync added nodes
          _this6.trigger('coral-table-row:_contentchanged', {
            addedNodes: mutation.addedNodes,
            removedNodes: mutation.removedNodes
          });

          _this6._syncAriaLabelledby();
        });
      }
      /** @ignore */

    }, {
      key: "attributeChangedCallback",

      /** @ignore */
      value: function attributeChangedCallback(name, oldValue, value) {
        if (name === '_selectable') {
          this._toggleSelectable(value !== null);
        } else if (name === '_orderable') {
          this._toggleOrderable(value !== null);
        } else if (name === '_lockable') {
          this._toggleLockable(value !== null);
        } else {
          _get(_getPrototypeOf(TableRow.prototype), "attributeChangedCallback", this).call(this, name, oldValue, value);
        }
      }
      /** @ignore */

    }, {
      key: "render",
      value: function render() {
        _get(_getPrototypeOf(TableRow.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1t);

        this._syncAriaLabelledby();
      }
      /**
       Triggered before {@link TableRow#selected} is changed.
        @typedef {CustomEvent} coral-table-row:_beforeselectedchanged
        @private
       */

      /**
       Triggered when {@link TableRow#selected} changed.
        @typedef {CustomEvent} coral-table-row:_selectedchanged
        @private
       */

      /**
       Triggered when {@link TableRow#locked} changed.
        @typedef {CustomEvent} coral-table-row:_lockedchanged
        @private
       */

      /**
       Triggered when {@link TableRow#multiple} changed.
        @typedef {CustomEvent} coral-table-row:_multiplechanged
        @private
       */

      /**
       Triggered when the {@link TableRow} selection changed.
        @typedef {CustomEvent} coral-table-row:_change
        @property {Array.<TableCell>} detail.oldSelection
       The old item selection. When {@link TableRow#multiple}, it includes an Array.
       @property {Array.<TableCell>} event.detail.selection
       The item selection. When {@link TableRow#multiple}, it includes an Array.
        @private
       */

    }, {
      key: "locked",
      get: function get() {
        return this._locked || false;
      },
      set: function set(value) {
        this._locked = transform.booleanAttr(value);

        this._reflectAttribute('locked', this._locked);

        this.trigger('coral-table-row:_lockedchanged');
      }
      /**
       Whether the table row is selected.
        @type {Boolean}
       @default false
       @htmlattribute selected
       @htmlattributereflected
       */

    }, {
      key: "selected",
      get: function get() {
        return this._selected || false;
      },
      set: function set(value) {
        // Prevent selection if disabled
        if (this.hasAttribute('coral-table-rowselect') && this.hasAttribute('disabled') || this.querySelector('[coral-table-rowselect][disabled]')) {
          return;
        }

        this.trigger('coral-table-row:_beforeselectedchanged');
        this._selected = transform.booleanAttr(value);

        this._reflectAttribute('selected', this._selected);

        this.trigger('coral-table-row:_selectedchanged');

        this._syncSelectHandle();

        this._syncAriaLabelledby();

        this._syncAriaSelectedState();
      }
      /**
       Whether the items are selectable.
        @type {Boolean}
       @default false
       @htmlattribute selectable
       @htmlattributereflected
       */

    }, {
      key: "selectable",
      get: function get() {
        return this._selectable || false;
      },
      set: function set(value) {
        var _this7 = this;

        this._selectable = transform.booleanAttr(value);

        this._reflectAttribute('selectable', this._selectable);

        this.items.getAll().forEach(function (cell) {
          cell[_this7._selectable ? 'setAttribute' : 'removeAttribute']('_selectable', '');
        });
      }
      /**
       Whether multiple items can be selected.
        @type {Boolean}
       @default false
       @htmlattribute multiple
       @htmlattributereflected
       */

    }, {
      key: "multiple",
      get: function get() {
        return this._multiple || false;
      },
      set: function set(value) {
        this._multiple = transform.booleanAttr(value);

        this._reflectAttribute('multiple', this._multiple);

        this.trigger('coral-table-row:_multiplechanged');
      }
      /**
       Returns an Array containing the selected items.
        @type {Array.<HTMLElement>}
       @readonly
       */

    }, {
      key: "selectedItems",
      get: function get() {
        return this.items._getAllSelected();
      }
      /**
       Returns the first selected item of the row. The value <code>null</code> is returned if no element is
       selected.
        @type {HTMLElement}
       @readonly
       */

    }, {
      key: "selectedItem",
      get: function get() {
        return this.items._getFirstSelected();
      }
      /**
       The Collection Interface that allows interacting with the items that the component contains.
        @type {SelectableCollection}
       @readonly
       */

    }, {
      key: "items",
      get: function get() {
        // Construct the collection on first request
        if (!this._items) {
          this._items = new SelectableCollection({
            host: this,
            itemBaseTagName: 'td',
            itemTagName: 'coral-table-cell'
          });
        }

        return this._items;
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(TableRow), "observedAttributes", this).concat(['locked', 'selected', 'multiple', 'selectable', '_selectable', '_orderable', '_lockable']);
      }
    }]);

    return TableRow;
  }(BaseComponent(HTMLTableRowElement));

  // divider changes

  var ALL_DIVIDER_CLASSES = [];

  for (var dividerValue in divider) {
    ALL_DIVIDER_CLASSES.push("_coral-Table-divider--".concat(divider[dividerValue]));
  }
  /**
   @base BaseTableSection
   @classdesc The base element for table sections
   */


  var BaseTableSection = function BaseTableSection(superClass) {
    return /*#__PURE__*/function (_superClass) {
      _inherits(_class, _superClass);

      var _super = _createSuper(_class);

      /** @ignore */
      function _class() {
        var _this;

        _classCallCheck(this, _class);

        _this = _super.call(this);
        _this._tagName = _this.getAttribute('is').toLowerCase();
        return _this;
      }
      /**
       The table section divider. See {@link TableSectionDividerEnum}.
        @type {String}
       @default TableSectionDividerEnum.ROW
       @htmlattributereflected
       @htmlattribute divider
       */


      _createClass(_class, [{
        key: "_toggleObserver",
        value: function _toggleObserver(enable) {
          this._observer = this._observer || new MutationObserver(this._handleMutations.bind(this));

          if (enable) {
            // Initialize content MO
            this._observer.observe(this, {
              childList: true,
              subtree: true
            });
          } else {
            this._observer.disconnect();
          }
        }
      }, {
        key: "_handleMutations",
        value: function _handleMutations(mutations) {
          var _this2 = this;

          mutations.forEach(function (mutation) {
            _this2.trigger("".concat(_this2._tagName, ":_contentchanged"), {
              addedNodes: mutation.addedNodes,
              removedNodes: mutation.removedNodes
            });
          });
        }
        /** @ignore */

      }, {
        key: "attributeChangedCallback",

        /** @ignore */
        value: function attributeChangedCallback(name, oldValue, value) {
          if (name === '_observe') {
            this._toggleObserver(value !== 'off');
          } else {
            _get(_getPrototypeOf(_class.prototype), "attributeChangedCallback", this).call(this, name, oldValue, value);
          }
        }
        /** @ignore */

      }, {
        key: "render",
        value: function render() {
          _get(_getPrototypeOf(_class.prototype), "render", this).call(this); // Default reflected attributes


          if (!this._divider) {
            this.divider = divider.ROW;
          }
        }
      }, {
        key: "divider",
        get: function get() {
          return this._divider || divider.ROW;
        },
        set: function set(value) {
          var _this$classList;

          value = transform.string(value).toLowerCase();
          this._divider = validate.enumeration(divider)(value) && value || divider.ROW;

          this._reflectAttribute('divider', this._divider);

          (_this$classList = this.classList).remove.apply(_this$classList, ALL_DIVIDER_CLASSES);

          this.classList.add("_coral-Table-divider--".concat(this.divider));
        }
      }], [{
        key: "observedAttributes",
        get: function get() {
          return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['divider', '_observe']);
        }
      }]);

      return _class;
    }(superClass);
  };

  var CLASSNAME$1u = '_coral-Table-head';
  /**
   @class Coral.Table.Head
   @classdesc A Table head component
   @htmltag coral-table-head
   @htmlbasetag thead
   @extends {HTMLTableSectionElement}
   @extends {BaseComponent}
   @extends {BaseTableSection}
   */

  var TableHead = /*#__PURE__*/function (_BaseTableSection) {
    _inherits(TableHead, _BaseTableSection);

    var _super = _createSuper(TableHead);

    /** @ignore */
    function TableHead() {
      var _this;

      _classCallCheck(this, TableHead);

      _this = _super.call(this);

      _this._toggleObserver(true);

      return _this;
    }
    /**
     Whether the table head is sticky. The table content becomes automatically scrollable if the table wrapper height
     is smaller than its content.
     Table exposes the <code>coral-table-scroll</code> attribute that allows in sticky mode to define the table
     scrolling container max-height. This is particularly useful if the table contains dynamic content.
      @type {Boolean}
     @default false
     @htmlattribute sticky
     @htmlattributereflected
     */


    _createClass(TableHead, [{
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(TableHead.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1u);
      }
      /**
       Triggered when the {@link TableHead} content changed.
        @typedef {CustomEvent} coral-table-head:_contentchanged
        @private
       */

      /**
       Triggered when {@link TableHead#sticky} changed.
        @typedef {CustomEvent} coral-table-head:_stickychanged
        @private
       */

    }, {
      key: "sticky",
      get: function get() {
        return this._sticky || false;
      },
      set: function set(value) {
        var _this2 = this;

        this._sticky = transform.booleanAttr(value);

        this._reflectAttribute('sticky', this._sticky); // Delay execution for better performance


        window.requestAnimationFrame(function () {
          _this2.trigger('coral-table-head:_stickychanged');
        });
      }
      /** @ignore */

    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(TableHead), "observedAttributes", this).concat(['sticky']);
      }
    }]);

    return TableHead;
  }(BaseTableSection(BaseComponent(HTMLTableSectionElement)));

  var CLASSNAME$1v = '_coral-Table-body';
  /**
   @class Coral.Table.Body
   @classdesc A Table body component
   @htmltag coral-table-body
   @htmlbasetag tbody
   @extends {HTMLTableSectionElement}
   @extends {BaseComponent}
   @extends {BaseTableSection}
   */

  var TableBody = /*#__PURE__*/function (_BaseTableSection) {
    _inherits(TableBody, _BaseTableSection);

    var _super = _createSuper(TableBody);

    /** @ignore */
    function TableBody() {
      var _this;

      _classCallCheck(this, TableBody);

      _this = _super.call(this);

      _this._toggleObserver(true);

      return _this;
    }
    /** @ignore */


    _createClass(TableBody, [{
      key: "render",
      value: function render() {
        _get(_getPrototypeOf(TableBody.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1v);

        if (getRows([this]).length === 0) {
          this.trigger('coral-table-body:_empty');
        }
      }
      /**
       Triggered when the {@link TableBody} content changed.
        @typedef {CustomEvent} coral-table-body:_contentchanged
        @private
       */

      /**
       Triggered when the {@link TableBody} is initialized without rows.
        @typedef {CustomEvent} coral-table-body:_empty
        @private
       */

    }]);

    return TableBody;
  }(BaseTableSection(BaseComponent(HTMLTableSectionElement)));

  var CLASSNAME$1w = '_coral-Table-foot';
  /**
   @class Coral.Table.Foot
   @classdesc A Table foot component
   @htmltag coral-table-foot
   @htmlbasetag tfoot
   @extends {HTMLTableSectionElement}
   @extends {BaseComponent}
   @extends {BaseTableSection}
   */

  var TableFoot = /*#__PURE__*/function (_BaseTableSection) {
    _inherits(TableFoot, _BaseTableSection);

    var _super = _createSuper(TableFoot);

    function TableFoot() {
      _classCallCheck(this, TableFoot);

      return _super.apply(this, arguments);
    }

    _createClass(TableFoot, [{
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(TableFoot.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1w);
      }
    }]);

    return TableFoot;
  }(BaseTableSection(BaseComponent(HTMLTableSectionElement)));

  var template$X = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["liveRegion"] = document.createElement("div");
    el0.setAttribute("handle", "liveRegion");
    el0.className += " u-coral-screenReaderOnly _coral-Table-liveRegion";
    el0.setAttribute("aria-hidden", "true");
    el0.setAttribute("aria-live", "off");
    el0.id = data_0["commons"]["getUID"]();
    frag.appendChild(el0);
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    var el2 = this["container"] = document.createElement("div");
    el2.setAttribute("handle", "container");
    el2.className += " _coral-Table-wrapper-container";
    el2.setAttribute("role", "presentation");
    el2.setAttribute("coral-table-scroll", "");
    var el3 = document.createTextNode("\n  ");
    el2.appendChild(el3);
    var el4 = this["hiddenStyle"] = document.createElement("style");
    el4.setAttribute("handle", "hiddenStyle");
    el2.appendChild(el4);
    var el5 = document.createTextNode("\n  ");
    el2.appendChild(el5);
    var el6 = this["alignmentStyle"] = document.createElement("style");
    el6.setAttribute("handle", "alignmentStyle");
    el2.appendChild(el6);
    var el7 = document.createTextNode("\n  ");
    el2.appendChild(el7);
    var el8 = this["table"] = document.createElement("table");
    el8.setAttribute("handle", "table");
    el8.className += " _coral-Table";
    el8.setAttribute("role", "grid");
    el8.setAttribute("aria-describedby", this["liveRegion"]["id"]);
    el2.appendChild(el8);
    var el9 = document.createTextNode("\n");
    el2.appendChild(el9);
    frag.appendChild(el2);
    var el10 = document.createTextNode("\n\n");
    frag.appendChild(el10);
    return frag;
  };

  var CLASSNAME$1x = '_coral-Table-wrapper';
  /**
   Enumeration for {@link Table} variants

   @typedef {Object} TableVariantEnum

   @property {String} DEFAULT
   A default table.
   @property {String} QUIET
   A quiet table with transparent borders and background.
   @property {String} LIST
   Not supported. Falls back to DEFAULT.
   */

  var variant$m = {
    DEFAULT: 'default',
    QUIET: 'quiet',
    LIST: 'list'
  };
  var ALL_VARIANT_CLASSES$c = [];

  for (var variantValue$a in variant$m) {
    ALL_VARIANT_CLASSES$c.push("".concat(CLASSNAME$1x, "--").concat(variant$m[variantValue$a]));
  }

  var IS_DISABLED = 'is-disabled';
  var IS_SORTED = 'is-sorted';
  var IS_UNSELECTABLE = 'is-unselectable';
  var IS_FIRST_ITEM_DRAGGED = 'is-draggedFirstItem';
  var IS_LAST_ITEM_DRAGGED = 'is-draggedLastItem';
  var IS_DRAGGING_CLASS$2 = 'is-dragging';
  var IS_BEFORE_CLASS$1 = 'is-before';
  var IS_AFTER_CLASS$1 = 'is-after';
  var IS_LAYOUTING = 'is-layouting';
  var IS_READY = 'is-ready';
  var KEY_SPACE = Keys.keyToCode('space');
  /**
   @class Coral.Table
   @classdesc A Table component is a container component to display and manipulate data in two dimensions.
   To define table actions on specific elements, handles can be used.
   A handle is given a special attribute :
   - <code>[coral-table-select]</code>. Select/unselect all table items.
   - <code>[coral-table-rowselect]</code>. Select/unselect the table item.
   - <code>[coral-table-roworder]</code>. Drag to order the table item.
   - <code>[coral-table-rowlock]</code>. Lock/unlock the table item.
   @htmltag coral-table
   @htmlbasetag table
   @extends {HTMLTableElement}
   @extends {BaseComponent}
   */

  var Table = /*#__PURE__*/function (_BaseComponent) {
    _inherits(Table, _BaseComponent);

    var _super = _createSuper(Table);

    /** @ignore */
    function Table() {
      var _this;

      _classCallCheck(this, Table);

      _this = _super.call(this); // Templates

      _this._elements = {
        head: _this.querySelector('thead[is="coral-table-head"]') || new TableHead(),
        body: _this.querySelector('tbody[is="coral-table-body"]') || new TableBody(),
        foot: _this.querySelector('tfoot[is="coral-table-foot"]') || new TableFoot(),
        columns: _this.querySelector('colgroup') || document.createElement('colgroup')
      };
      template$X.call(_this._elements, {
        commons: commons
      }); // Events

      _this._delegateEvents({
        // Table specific
        'global:coral-commons:_webfontactive': '_resetLayout',
        'change [coral-table-select]': '_onSelectAll',
        'capture:scroll [handle="container"]': '_onScroll',
        // Head specific
        'click thead[is="coral-table-head"] th[is="coral-table-headercell"]': '_onHeaderCellSort',
        'coral-dragaction:dragstart thead[is="coral-table-head"] th[is="coral-table-headercell"]': '_onHeaderCellDragStart',
        'coral-dragaction:drag thead[is="coral-table-head"] tr[is="coral-table-row"] > th[is="coral-table-headercell"]': '_onHeaderCellDrag',
        'coral-dragaction:dragend thead[is="coral-table-head"] tr[is="coral-table-row"] > th[is="coral-table-headercell"]': '_onHeaderCellDragEnd',
        // a11y
        'key:enter th[is="coral-table-headercell"]': '_onHeaderCellSort',
        'key:enter th[is="coral-table-headercell"] coral-table-headercell-content': '_onHeaderCellSort',
        'key:space th[is="coral-table-headercell"]': '_onHeaderCellSort',
        'key:space th[is="coral-table-headercell"] coral-table-headercell-content': '_onHeaderCellSort',
        // Body specific
        'click tbody[is="coral-table-body"] [coral-table-rowlock]': '_onRowLock',
        'click tbody[is="coral-table-body"] [coral-table-rowselect]': '_onRowSelect',
        'click tbody[is="coral-table-body"] tr[is="coral-table-row"][selectable] [coral-table-cellselect]': '_onCellSelect',
        'capture:mousedown tbody[is="coral-table-body"] [coral-table-roworder]:not([disabled])': '_onRowOrder',
        'capture:touchstart tbody[is="coral-table-body"] [coral-table-roworder]:not([disabled])': '_onRowOrder',
        'coral-dragaction:dragstart tbody[is="coral-table-body"] tr[is="coral-table-row"]': '_onRowDragStart',
        'coral-dragaction:drag tbody[is="coral-table-body"] tr[is="coral-table-row"]': '_onRowDrag',
        'coral-dragaction:dragover tbody[is="coral-table-body"] tr[is="coral-table-row"]': '_onRowDragOver',
        'coral-dragaction:dragend tbody[is="coral-table-body"] tr[is="coral-table-row"]': '_onRowDragEnd',
        // a11y
        'mousedown tbody[is="coral-table-body"] [coral-table-rowselect]': '_onRowDown',
        'key:enter tbody[is="coral-table-body"] tr[is="coral-table-row"]': '_onRowSelect',
        'key:space tbody[is="coral-table-body"] tr[is="coral-table-row"]': '_onRowSelect',
        'key:pageup tbody[is="coral-table-body"] tr[is="coral-table-row"]': '_onFocusPreviousItem',
        'key:pagedown tbody[is="coral-table-body"] tr[is="coral-table-row"]': '_onFocusNextItem',
        'key:left tbody[is="coral-table-body"] tr[is="coral-table-row"]': '_onFocusPreviousItem',
        'key:right tbody[is="coral-table-body"] tr[is="coral-table-row"]': '_onFocusNextItem',
        'key:up tbody[is="coral-table-body"] tr[is="coral-table-row"]': '_onFocusPreviousItem',
        'key:down tbody[is="coral-table-body"] tr[is="coral-table-row"]': '_onFocusNextItem',
        'key:home tbody[is="coral-table-body"] tr[is="coral-table-row"]': '_onFocusFirstItem',
        'key:end tbody[is="coral-table-body"] tr[is="coral-table-row"]': '_onFocusLastItem',
        'key:shift+pageup tbody[is="coral-table-body"] tr[is="coral-table-row"]': '_onSelectPreviousItem',
        'key:shift+pagedown tbody[is="coral-table-body"] tr[is="coral-table-row"]': '_onSelectNextItem',
        'key:shift+left tbody[is="coral-table-body"] tr[is="coral-table-row"]': '_onSelectPreviousItem',
        'key:shift+right tbody[is="coral-table-body"] tr[is="coral-table-row"]': '_onSelectNextItem',
        'key:shift+up tbody[is="coral-table-body"] tr[is="coral-table-row"]': '_onSelectPreviousItem',
        'key:shift+down tbody[is="coral-table-body"] tr[is="coral-table-row"]': '_onSelectNextItem',
        // Private
        'coral-table-row:_multiplechanged': '_onRowMultipleChanged',
        'coral-table-row:_beforeselectedchanged': '_onBeforeRowSelectionChanged',
        'coral-table-row:_selectedchanged': '_onRowSelectionChanged',
        'coral-table-row:_lockedchanged': '_onRowLockedChanged',
        'coral-table-row:_change': '_onRowChange',
        'coral-table-row:_contentchanged': '_onRowContentChanged',
        'coral-table-headercell:_contentchanged': '_resetLayout',
        'coral-table-head:_contentchanged': '_onHeadContentChanged',
        'coral-table-body:_contentchanged': '_onBodyContentChanged',
        'coral-table-body:_empty': '_onBodyEmpty',
        'coral-table-column:_alignmentchanged': '_onAlignmentChanged',
        'coral-table-column:_fixedwidthchanged': '_onFixedWidthChanged',
        'coral-table-column:_orderablechanged': '_onColumnOrderableChanged',
        'coral-table-column:_sortablechanged': '_onColumnSortableChanged',
        'coral-table-column:_sortabledirectionchanged': '_onColumnSortableDirectionChanged',
        'coral-table-column:_hiddenchanged': '_onColumnHiddenChanged',
        'coral-table-column:_beforecolumnsort': '_onBeforeColumnSort',
        'coral-table-column:_sort': '_onColumnSort',
        'coral-table-head:_stickychanged': '_onHeadStickyChanged'
      }); // Required for coral-table:change event


      _this._oldSelection = []; // References selected items in their selection order and is only used for keyboard selection

      _this._lastSelectedItems = {
        items: [],
        direction: null
      }; // Don't sort by default

      _this._allowSorting = false; // Debounce timer

      _this._timeout = null; // Debounce wait in milliseconds

      _this._wait = 50; // Used by resizing detector

      _this._resetLayout = _this._resetLayout.bind(_assertThisInitialized(_this)); // Init observer

      _this._toggleObserver(true);

      return _this;
    }
    /**
     The head of the table.
      @type {TableHead}
     @contentzone
     */


    _createClass(Table, [{
      key: "_onSelectAll",

      /** @private */
      value: function _onSelectAll(event) {
        if (this.selectable) {
          var rows = this._getSelectableItems();

          if (rows.length) {
            if (this.multiple) {
              var selected = event.target.checked;
              rows.forEach(function (row) {
                // Don't trigger too many events
                row.set('selected', selected, true);
              });
              rows = selected ? rows : []; // Synchronise the table select handle

              this._setSelectAllHandleState(selected ? 'checked' : 'unchecked');

              this.trigger('coral-table:change', {
                selection: rows,
                oldSelection: this._oldSelection
              }); // Sync used collection

              this._oldSelection = rows;
              this._lastSelectedItems.items = rows;
            } else {
              // Only select last item
              var lastItem = rows[rows.length - 1];
              lastItem.selected = !lastItem.selected;
            }
          }
        }
      }
    }, {
      key: "_triggerChangeEvent",
      value: function _triggerChangeEvent() {
        if (!this._preventTriggeringEvents) {
          var selectedItems = this.selectedItems;
          this.trigger('coral-table:change', {
            oldSelection: this._oldSelection,
            selection: selectedItems
          });
          this._oldSelection = selectedItems;
        }
      }
      /** @private */

    }, {
      key: "_onRowOrder",
      value: function _onRowOrder(event) {
        var table = this;
        var row = event.target.closest('tr[is="coral-table-row"]');

        if (row && table.orderable) {
          var head = table.head;
          var body = table.body;
          var sticky = head && head.sticky;
          var style = row.getAttribute('style');
          var index = getIndexOf(row);
          var oldBefore = row.nextElementSibling;
          var dragAction = new DragAction(row);
          var items = getRows([body]);
          var tableBoundingClientRect = table.getBoundingClientRect();
          var rowBoundingClientRect = row.getBoundingClientRect();

          if (row === items[0]) {
            table.classList.add(IS_FIRST_ITEM_DRAGGED);
          } else if (row === items[items.length - 1]) {
            table.classList.add(IS_LAST_ITEM_DRAGGED);
          }

          dragAction.axis = 'vertical'; // Handle the scroll in table

          dragAction.scroll = false; // Specify selection handle directly on the row if none found

          dragAction.handle = row.querySelector('[coral-table-roworder]'); // The row placeholder indicating where the dragged element will be dropped

          var placeholder = row.cloneNode(true);
          placeholder.classList.add('_coral-Table-row--placeholder'); // Prepare the row position before inserting its placeholder

          row.style.top = "".concat(rowBoundingClientRect.top - tableBoundingClientRect.top, "px"); // Prevent change event from triggering if the cloned node is selected

          table._preventTriggeringEvents = true;
          body.insertBefore(placeholder, row.nextElementSibling);
          window.requestAnimationFrame(function () {
            table._preventTriggeringEvents = false;
          }); // Store the data to avoid re-reading the layout on drag events

          var dragData = {
            placeholder: placeholder,
            index: index,
            oldBefore: oldBefore,
            // Backup styles to restore them later
            style: {
              row: style
            }
          }; // Required to handle the scrolling of the sticky table on drag events

          if (sticky) {
            dragData.sticky = sticky;
            dragData.tableTop = tableBoundingClientRect.top;
            dragData.tableSize = tableBoundingClientRect.height;
            dragData.headSize = parseFloat(table._elements.container.style.marginTop);
            dragData.dragElementSize = rowBoundingClientRect.height;
          }

          row.dragAction._dragData = dragData;
        }
      }
      /** @private */

    }, {
      key: "_onHeaderCellSort",
      value: function _onHeaderCellSort(event) {
        var table = this;
        var matchedTarget = event.matchedTarget.closest('th'); // Don't sort if the column was dragged

        if (!matchedTarget._isDragging) {
          var column = table._getColumn(matchedTarget); // Only sort if actually sortable and event not defaultPrevented


          if (column && column.sortable) {
            event.preventDefault();

            column._sort(); // Restore focus on the header cell in any case


            matchedTarget.focus();
          }
        }
      }
      /** @private */

    }, {
      key: "_onHeaderCellDragStart",
      value: function _onHeaderCellDragStart(event) {
        var table = this;
        var matchedTarget = event.matchedTarget;
        var dragElement = event.detail.dragElement;
        var siblingHeaderCellSelector = matchedTarget === dragElement ? 'th[is="coral-table-headercell"]' : 'th[is="coral-table-headercell"] coral-table-headercell-content';
        var tableBoundingClientRect = table.getBoundingClientRect(); // Store the data to be used on drag events

        dragElement.dragAction._dragData = {
          draggedColumnIndex: getIndexOf(matchedTarget),
          tableLeft: tableBoundingClientRect.left,
          tableSize: tableBoundingClientRect.width,
          dragElementSize: matchedTarget.getBoundingClientRect().width,
          tableScrollWidth: table._elements.container.scrollWidth
        };
        getSiblingsOf(matchedTarget, siblingHeaderCellSelector, 'prevAll').forEach(function (item) {
          item.classList.add(IS_BEFORE_CLASS$1);
        });
        getSiblingsOf(matchedTarget, siblingHeaderCellSelector, 'nextAll').forEach(function (item) {
          item.classList.add(IS_AFTER_CLASS$1);
        });
      }
      /** @private */

    }, {
      key: "_onHeaderCellDrag",
      value: function _onHeaderCellDrag(event) {
        var table = this;
        var container = table._elements.container;
        var matchedTarget = event.matchedTarget;
        var dragElement = event.detail.dragElement;
        var dragData = dragElement.dragAction._dragData;
        var row = matchedTarget.parentElement;
        var isHeaderCellDragged = matchedTarget === dragElement;
        var containerScrollLeft = container.scrollLeft;
        var documentScrollLeft = document.body.scrollLeft; // Prevent sorting on header cell click if the header cell is being dragged

        matchedTarget._isDragging = true; // Scroll left/right if table edge is reached

        var position = dragElement.getBoundingClientRect().left - dragData.tableLeft;
        var leftScrollLimit = 0;
        var rightScrollLimit = dragData.tableSize - dragData.dragElementSize;
        var scrollOffset = 10;

        if (position < leftScrollLimit) {
          container.scrollLeft -= scrollOffset;
        } // 2nd condition is required to avoid increasing the container scroll width
        else if (position > rightScrollLimit && containerScrollLeft + dragData.tableSize < dragData.tableScrollWidth) {
            container.scrollLeft += scrollOffset;
          } // Position sibling header cells based on the dragged element


        getHeaderCells(row).forEach(function (headerCell) {
          var draggedHeaderCell = isHeaderCellDragged ? headerCell : headerCell.content;

          if (!draggedHeaderCell.classList.contains(IS_DRAGGING_CLASS$2)) {
            var offsetLeft = draggedHeaderCell.getBoundingClientRect().left + documentScrollLeft;
            var isAfter = event.detail.pageX < offsetLeft + draggedHeaderCell.offsetWidth / 3;
            draggedHeaderCell.classList.toggle(IS_AFTER_CLASS$1, isAfter);
            draggedHeaderCell.classList.toggle(IS_BEFORE_CLASS$1, !isAfter);
            var columnIndex = getIndexOf(headerCell);
            var dragElementIndex = getIndexOf(matchedTarget); // Place headercell after

            if (draggedHeaderCell.classList.contains(IS_AFTER_CLASS$1)) {
              if (columnIndex < dragElementIndex) {
                // Position the header cells based on their siblings position
                if (isHeaderCellDragged) {
                  var nextHeaderCellWidth = draggedHeaderCell.clientWidth;
                  draggedHeaderCell.style.left = "".concat(nextHeaderCellWidth, "px");
                } else {
                  var nextHeaderCell = getSiblingsOf(headerCell, 'th[is="coral-table-headercell"]', 'next');
                  var nextHeaderCellLeftOffset = nextHeaderCell.getBoundingClientRect().left + documentScrollLeft;
                  draggedHeaderCell.style.left = "".concat(nextHeaderCellLeftOffset + containerScrollLeft, "px");
                }
              } else {
                draggedHeaderCell.style.left = '';
              }
            } // Place headerCell before


            if (draggedHeaderCell.classList.contains(IS_BEFORE_CLASS$1)) {
              if (columnIndex > dragElementIndex) {
                var prev = getSiblingsOf(headerCell, 'th[is="coral-table-headercell"]', 'prev'); // Position the header cells based on their siblings position

                if (isHeaderCellDragged) {
                  var beforeHeaderCellWidth = prev.clientWidth;
                  draggedHeaderCell.style.left = "".concat(-1 * beforeHeaderCellWidth, "px");
                } else {
                  var beforeHeaderCellLeftOffset = prev.getBoundingClientRect().left + documentScrollLeft;
                  draggedHeaderCell.style.left = "".concat(beforeHeaderCellLeftOffset + containerScrollLeft, "px");
                }
              } else {
                draggedHeaderCell.style.left = '';
              }
            }
          }
        });
      }
      /** @private */

    }, {
      key: "_onHeaderCellDragEnd",
      value: function _onHeaderCellDragEnd(event) {
        var table = this;
        var matchedTarget = event.matchedTarget;
        var dragElement = event.detail.dragElement;
        var dragData = dragElement.dragAction._dragData;

        var column = table._getColumn(matchedTarget);

        var headRows = getRows([table.head]);
        var isHeaderCellDragged = matchedTarget === dragElement;
        var row = matchedTarget.parentElement; // Select all cells in table body and foot given the index

        var getCellsByIndex = function getCellsByIndex(cellIndex) {
          var cellElements = [];
          var rows = getRows([table.body, table.foot]);
          rows.forEach(function (rowElement) {
            var cell = getCellByIndex(rowElement, cellIndex);

            if (cell) {
              cellElements.push(cell);
            }
          });
          return cellElements;
        };

        var cells = getCellsByIndex(getIndexOf(matchedTarget));
        var before = null;
        var after = null; // Siblings are either header cell or header cell content based on the current sticky state

        if (isHeaderCellDragged) {
          before = row.querySelector("th[is=\"coral-table-headercell\"].".concat(IS_AFTER_CLASS$1));
          after = row.querySelectorAll("th[is=\"coral-table-headercell\"].".concat(IS_BEFORE_CLASS$1));
          after = after.length ? after[after.length - 1] : null;
        } else {
          before = row.querySelector("th[is=\"coral-table-headercell\"] > coral-table-headercell-content.".concat(IS_AFTER_CLASS$1));
          before = before ? before.parentNode : null;
          after = row.querySelectorAll("th[is=\"coral-table-headercell\"] > coral-table-headercell-content.".concat(IS_BEFORE_CLASS$1));
          after = after.length ? after[after.length - 1].parentNode : null;
        } // Did header cell order change ?


        var swapped = !(before && before.previousElementSibling === matchedTarget || after && after.nextElementSibling === matchedTarget); // Switch whole columns based on the new position of the dragged element

        if (swapped) {
          var beforeColumn = before ? table._getColumn(before) : null; // Trigger the event on table

          var beforeEvent = table.trigger('coral-table:beforecolumndrag', {
            column: column,
            before: beforeColumn
          });
          var oldBefore = column.nextElementSibling;

          if (!beforeEvent.defaultPrevented) {
            // Insert the headercell at the new position
            if (before) {
              var beforeIndex = getIndexOf(before);
              var beforeCells = getCellsByIndex(beforeIndex);
              cells.forEach(function (cell, i) {
                cell.parentNode.insertBefore(cell, beforeCells[i]);
              }); // Sync <coral-table-column> by reordering it too

              var beforeCol = getColumns(table.columns)[beforeIndex];

              if (beforeCol && column) {
                table.columns.insertBefore(column, beforeCol);
              }

              row.insertBefore(matchedTarget, before);
            }

            if (after) {
              var afterIndex = getIndexOf(after);
              var afterCells = getCellsByIndex(afterIndex);
              cells.forEach(function (cell, i) {
                cell.parentNode.insertBefore(cell, afterCells[i].nextElementSibling);
              }); // Sync <coral-table-column> by reordering it too

              var afterCol = getColumns(table.columns)[afterIndex];

              if (afterCol && column) {
                table.columns.insertBefore(column, afterCol.nextElementSibling);
              }

              row.insertBefore(matchedTarget, after.nextElementSibling);
            } // Trigger the order event if the column position changed


            if (dragData.draggedColumnIndex !== getIndexOf(matchedTarget)) {
              var newBefore = getColumns(table.columns)[getIndexOf(column) + 1];
              table.trigger('coral-table:columndrag', {
                column: column,
                oldBefore: oldBefore,
                before: newBefore || null
              });
            }
          }
        } // Restoring default header cells styling


        headRows.forEach(function (rowElement) {
          getHeaderCells(rowElement).forEach(function (headerCell) {
            headerCell = isHeaderCellDragged ? headerCell : headerCell.content;
            headerCell.classList.remove(IS_AFTER_CLASS$1);
            headerCell.classList.remove(IS_BEFORE_CLASS$1);
            headerCell.style.left = '';
          });
        }); // Trigger a relayout

        table._resetLayout();

        window.requestAnimationFrame(function () {
          // Allows sorting again after dragging completed
          matchedTarget._isDragging = undefined; // Refocus the dragged element manually

          table._toggleElementTabIndex(dragElement, null, true);
        });
      }
      /** @private */

    }, {
      key: "_onCellSelect",
      value: function _onCellSelect(event) {
        var cell = event.target.closest('td[is="coral-table-cell"]');

        if (cell) {
          cell.selected = !cell.selected;
        }
      }
      /** @private */

    }, {
      key: "_onRowSelect",
      value: function _onRowSelect(event) {
        var table = this;
        var row = event.target.closest('tr[is="coral-table-row"]');

        if (row) {
          // Ignore selection if the row is locked
          if (table.lockable && row.locked) {
            return;
          } // Restore text-selection


          table.classList.remove(IS_UNSELECTABLE); // Prevent row selection when it's the selection handle and the target is an input

          if (table.selectable && (Keys.filterInputs(event) || !row.hasAttribute('coral-table-rowselect'))) {
            // Pressing space scrolls the sticky table to the bottom if scrollable
            if (event.keyCode === KEY_SPACE) {
              event.preventDefault();
            }

            if (event.shiftKey) {
              var lastSelectedItem = table._lastSelectedItems.items[table._lastSelectedItems.items.length - 1];
              var lastSelectedDirection = table._lastSelectedItems.direction; // If no selected items, by default set the first item as last selected item

              if (!table.selectedItem) {
                var rows = table._getSelectableItems();

                if (rows.length) {
                  lastSelectedItem = rows[0];
                  lastSelectedItem.set('selected', true, true);
                }
              } // Don't continue if table has no items or if the last selected item is the clicked item


              if (lastSelectedItem && getIndexOf(row) !== getIndexOf(lastSelectedItem)) {
                // Range selection direction
                var before = getIndexOf(row) < getIndexOf(lastSelectedItem);
                var rangeQuery = before ? 'prevUntil' : 'nextUntil'; // Store direction

                table._lastSelectedItems.direction = before ? 'up' : 'down';

                if (!row.selected) {
                  // Store selection range
                  var selectionRange = getSiblingsOf(lastSelectedItem, 'tr[is="coral-table-row"]:not([selected])', rangeQuery);
                  selectionRange[before ? 'push' : 'unshift'](lastSelectedItem); // Direction change

                  if (!before && lastSelectedDirection === 'up' || before && lastSelectedDirection === 'down') {
                    selectionRange.forEach(function (item) {
                      item.set('selected', false, true);
                    });
                  } // Select item


                  var selectionRangeRow = selectionRange[before ? 0 : selectionRange.length - 1];
                  selectionRangeRow.set('selected', true, true);
                  getSiblingsOf(selectionRangeRow, row, rangeQuery).forEach(function (item) {
                    item.set('selected', true, true);
                  });
                } else {
                  var selection = getSiblingsOf(lastSelectedItem, row, rangeQuery); // If some items are not selected

                  if (selection.some(function (item) {
                    return !item.hasAttribute('selected');
                  })) {
                    // Select all items in between
                    selection.forEach(function (item) {
                      item.set('selected', true, true);
                    }); // Deselect selected item right before/after the selection range

                    getSiblingsOf(row, 'tr[is="coral-table-row"]:not([selected])', rangeQuery).forEach(function (item) {
                      item.set('selected', false, true);
                    });
                  } else {
                    // Deselect items
                    selection[before ? 'push' : 'unshift'](lastSelectedItem);
                    selection.forEach(function (item) {
                      item.set('selected', false, true);
                    });
                  }
                }
              }
            } else {
              // Remove direction if simple click without shift key pressed
              table._lastSelectedItems.direction = null;
            } // Select the row that was clicked and keep the row selected if shift key was pressed


            row.selected = event.shiftKey ? true : !row.selected; // Don't focus the row if the target isn't the row and focusable

            table._focusItem(row, event.target === event.matchedTarget || event.target.tabIndex < 0);
          }
        }
      }
      /** @private */

    }, {
      key: "_onRowLock",
      value: function _onRowLock(event) {
        var table = this;

        if (table.lockable) {
          var row = event.target.closest('tr[is="coral-table-row"]');

          if (row) {
            event.preventDefault();
            event.stopPropagation();
            row.locked = !row.locked; // Refocus the locked/unlocked item manually

            window.requestAnimationFrame(function () {
              table._focusItem(row, true);
            });
          }
        }
      }
      /** @private */

    }, {
      key: "_onRowDown",
      value: function _onRowDown(event) {
        var table = this; // Prevent text-selection

        if (table.selectedItem && event.shiftKey) {
          table.classList.add(IS_UNSELECTABLE); // @polyfill IE
          // Store text selection feature

          var onSelectStart = document.onselectstart; // Kill text selection feature

          document.onselectstart = function () {
            return false;
          }; // Restore text selection feature


          window.requestAnimationFrame(function () {
            document.onselectstart = onSelectStart;
          });
        }
      }
      /** @private */

    }, {
      key: "_onRowDragStart",
      value: function _onRowDragStart(event) {
        var table = this;
        var head = table.head;
        var body = table.body;
        var dragElement = event.detail.dragElement;
        var dragData = dragElement.dragAction._dragData;
        dragData.style.cells = [];
        getCells(dragElement).forEach(function (cell) {
          // Backup styles to restore them later
          dragData.style.cells.push(cell.getAttribute('style')); // Cells will shrink otherwise

          cell.style.width = window.getComputedStyle(cell).width;
        });

        if (head && !head.sticky) {
          // @polyfill ie11
          // Element that scrolls the document.
          var scrollingElement = document.scrollingElement || document.documentElement;
          dragElement.style.top = "".concat(dragElement.getBoundingClientRect().top + scrollingElement.scrollTop, "px");
        }

        dragElement.style.position = 'absolute'; // Setting drop zones allows to listen for coral-dragaction:dragover event

        dragElement.dragAction.dropZone = body.querySelectorAll("tr[is=\"coral-table-row\"]:not(.".concat(IS_DRAGGING_CLASS$2, ")")); // We cannot rely on :focus since the row is being moved in the dom while dnd

        dragElement.classList.add('is-focused');
      }
      /** @private */

    }, {
      key: "_onRowDrag",
      value: function _onRowDrag(event) {
        var table = this;
        var body = table.body;
        var dragElement = event.detail.dragElement;
        var dragData = dragElement.dragAction._dragData;
        var firstRow = getRows([body])[0]; // Insert the placeholder at the top

        if (dragElement.getBoundingClientRect().top <= firstRow.getBoundingClientRect().top) {
          table._preventTriggeringEvents = true;
          body.insertBefore(dragData.placeholder, firstRow);
          window.requestAnimationFrame(function () {
            table._preventTriggeringEvents = false;
          });
        } // Scroll up/down if table edge is reached


        if (dragData.sticky) {
          var dragElementTop = dragElement.getBoundingClientRect().top;
          var position = dragElementTop - dragData.tableTop - dragData.headSize;
          var topScrollLimit = 0;
          var bottomScrollLimit = dragData.tableSize - dragData.dragElementSize - dragData.headSize;
          var scrollOffset = 10; // Handle the scrollbar position based on the dragged element position.
          // nextFrame is required else Chrome wouldn't take scrollTop changes in account when dragging the first row down

          window.requestAnimationFrame(function () {
            if (position < topScrollLimit) {
              table._elements.container.scrollTop -= scrollOffset;
            } else if (position > bottomScrollLimit) {
              table._elements.container.scrollTop += scrollOffset;
            }
          });
        }
      }
      /** @private */

    }, {
      key: "_onRowDragOver",
      value: function _onRowDragOver(event) {
        var table = this;
        var body = table.body;
        var dragElement = event.detail.dragElement;
        var dropElement = event.detail.dropElement;
        var dragData = dragElement.dragAction._dragData; // Swap the placeholder

        if (dragElement.getBoundingClientRect().top >= dropElement.getBoundingClientRect().top) {
          table._preventTriggeringEvents = true;
          body.insertBefore(dragData.placeholder, dropElement.nextElementSibling);
          window.requestAnimationFrame(function () {
            table._preventTriggeringEvents = false;
          });
        }
      }
      /** @private */

    }, {
      key: "_onRowDragEnd",
      value: function _onRowDragEnd(event) {
        var table = this;
        var body = table.body;
        var dragElement = event.detail.dragElement;
        var dragData = dragElement.dragAction._dragData;
        var before = dragData.placeholder.nextElementSibling; // Clean up

        table.classList.remove(IS_FIRST_ITEM_DRAGGED);
        table.classList.remove(IS_LAST_ITEM_DRAGGED);
        body.removeChild(dragData.placeholder);
        dragElement.dragAction.destroy(); // Restore specific styling

        dragElement.setAttribute('style', dragData.style.row || '');
        getCells(dragElement).forEach(function (cell, i) {
          cell.setAttribute('style', dragData.style.cells[i] || '');
        }); // Trigger the event on table

        var beforeEvent = table.trigger('coral-table:beforeroworder', {
          row: dragElement,
          before: before
        });

        if (!beforeEvent.defaultPrevented) {
          // Did row order change ?
          var rows = getRows([body]).filter(function (item) {
            return item !== dragElement;
          });

          if (dragData.index !== rows.indexOf(dragData.placeholder)) {
            // Insert the row at the new position and prevent change event from triggering
            table._preventTriggeringEvents = true;
            body.insertBefore(dragElement, before);
            window.requestAnimationFrame(function () {
              table._preventTriggeringEvents = false;
            }); // Trigger the order event if the row position changed

            table.trigger('coral-table:roworder', {
              row: dragElement,
              oldBefore: dragData.oldBefore,
              before: before
            });
          }
        } // Refocus the dragged element manually


        window.requestAnimationFrame(function () {
          dragElement.classList.remove('is-focused');

          table._focusItem(dragElement, true);
        });
      }
      /** @private */

    }, {
      key: "_onRowMultipleChanged",
      value: function _onRowMultipleChanged(event) {
        event.stopImmediatePropagation();
        var table = this;
        var row = event.target; // Deselect all except last

        if (!row.multiple) {
          var selectedItems = row.selectedItems;
          table._preventTriggeringEvents = true;
          selectedItems.forEach(function (cell, i) {
            cell.selected = i === selectedItems.length - 1;
          });
          window.requestAnimationFrame(function () {
            table._preventTriggeringEvents = false;
            table.trigger('coral-table:rowchange', {
              oldSelection: selectedItems,
              selection: row.selectedItems,
              row: row
            });
          });
        }
      }
      /** @private */

    }, {
      key: "_onBeforeRowSelectionChanged",
      value: function _onBeforeRowSelectionChanged(event) {
        event.stopImmediatePropagation(); // In single selection, if the added item is selected, the rest should be deselected

        var selectedItem = this.selectedItem;

        if (!this.multiple && selectedItem && !event.target.selected) {
          selectedItem.set('selected', false, true);

          this._removeLastSelectedItem(selectedItem);
        }
      }
      /** @private */

    }, {
      key: "_syncSelectAllHandle",
      value: function _syncSelectAllHandle(selectedItems, items) {
        if (items.length && selectedItems.length === items.length) {
          this._setSelectAllHandleState('checked');
        } else if (!selectedItems.length) {
          this._setSelectAllHandleState('unchecked');
        } else {
          this._setSelectAllHandleState('indeterminate');
        }
      }
      /** @private */

    }, {
      key: "_setSelectAllHandleState",
      value: function _setSelectAllHandleState(state) {
        var handle = this.querySelector('[coral-table-select]');

        if (handle) {
          // If the handle is a checkbox but lacks a label, label it with "Select All".
          if (handle.tagName === 'CORAL-CHECKBOX') {
            if (!handle.labelled) {
              handle.setAttribute('labelled', i18n.get('Select All'));
            }

            if (!handle.title) {
              handle.setAttribute('title', i18n.get('Select All'));
            }
          }

          if (state === 'checked') {
            handle.removeAttribute('indeterminate');
            handle.setAttribute('checked', '');
          } else if (state === 'unchecked') {
            handle.removeAttribute('indeterminate');
            handle.removeAttribute('checked');
          } else if (state === 'indeterminate') {
            handle.setAttribute('indeterminate', '');
          }
        }
      }
      /** @private */

    }, {
      key: "_onRowSelectionChanged",
      value: function _onRowSelectionChanged(event) {
        event.stopImmediatePropagation();

        this._triggerChangeEvent();

        var table = this;
        var body = table.body;
        var row = event.target; // Synchronise the table select handle

        if (body && body.contains(row)) {
          var selection = table.selectedItems;

          var rows = table._getSelectableItems(); // Sync select all handle


          table._syncSelectAllHandle(selection, rows); // Store or remove the row reference


          table[row.selected ? '_addLastSelectedItem' : '_removeLastSelectedItem'](row); // Store selected items range

          var lastSelectedItem = table._lastSelectedItems.items[table._lastSelectedItems.items.length - 1];
          var next = table._lastSelectedItems.direction === 'down';

          if (row.selected && lastSelectedItem && lastSelectedItem.selected && getSiblingsOf(lastSelectedItem, 'tr[is="coral-table-row"][selected]', next ? 'next' : 'prev')) {
            getSiblingsOf(lastSelectedItem, 'tr[is="coral-table-row"]:not([selected])', next ? 'nextUntil' : 'prevUntil').forEach(function (item) {
              table._addLastSelectedItem(item);
            });
          }
        }
      }
    }, {
      key: "_onRowLockedChanged",
      value: function _onRowLockedChanged(event) {
        event.stopImmediatePropagation();
        var table = this;
        var body = this.body;
        var row = event.target;

        if (body && body.contains(row)) {
          if (row.locked) {
            // Store the row index as reference to place it back if unlocked and its selection state
            row._rowIndex = getIndexOf(row); // Insert row at first position of its tbody

            table._preventTriggeringEvents = true;
            body.insertBefore(row, getRows([body])[0]);
            window.requestAnimationFrame(function () {
              table._preventTriggeringEvents = false;
            }); // Trigger event on table

            table.trigger('coral-table:rowlock', {
              row: row
            });
          } else {
            // Put the row back to its initial position
            if (row._rowIndex >= 0) {
              var beforeRow = getRows([body])[row._rowIndex];

              if (beforeRow) {
                // Insert row at its initial position
                table._preventTriggeringEvents = true;
                body.insertBefore(row, beforeRow.nextElementSibling);
                window.requestAnimationFrame(function () {
                  table._preventTriggeringEvents = false;
                });
              }
            } // Trigger event on table


            table.trigger('coral-table:rowunlock', {
              row: row
            });
          }
        }
      }
    }, {
      key: "_onHeadContentChanged",
      value: function _onHeadContentChanged(event) {
        event.stopImmediatePropagation();
        var table = this;
        var head = table.head;
        var addedNodes = event.detail.addedNodes;

        for (var i = 0; i < addedNodes.length; i++) {
          var node = addedNodes[i]; // Sync header cell whether sticky or not

          if (isTableHeaderCell(node)) {
            table._toggleStickyHeaderCell(node, head.sticky);
          }
        }
      }
      /** @private */

    }, {
      key: "_onBodyContentChanged",
      value: function _onBodyContentChanged(event) {
        if (event.stopImmediatePropagation) {
          event.stopImmediatePropagation();
        }

        var table = this;
        var addedNodes = event.detail.addedNodes;
        var removedNodes = event.detail.removedNodes;
        var addedNode = null;

        var selectItem = function selectItem(item) {
          item.selected = item === addedNode;
        };

        var changed = false; // Sync added nodes

        for (var i = 0; i < addedNodes.length; i++) {
          addedNode = addedNodes[i]; // Sync row state with table properties

          if (isTableRow(addedNode)) {
            changed = true;

            addedNode._toggleSelectable(table.selectable);

            addedNode._toggleOrderable(table.orderable);

            addedNode._toggleLockable(table.lockable); // @compat


            this._toggleSelectionCheckbox(addedNode);

            var selectedItems = table.selectedItems;

            if (addedNode.selected) {
              // In single selection, if the added item is selected, the rest should be deselected
              if (!table.multiple && selectedItems.length > 1) {
                selectedItems.forEach(selectItem);
              }

              table._triggerChangeEvent();
            } // Cells are selectable too


            if (addedNode.selectable) {
              addedNode.trigger('coral-table-row:_contentchanged', {
                addedNodes: getContentCells(addedNode),
                removedNodes: []
              });
            } // Trigger collection event


            if (!table._preventTriggeringEvents) {
              table.trigger('coral-collection:add', {
                item: addedNode
              });
            } // a11y


            table._toggleFocusable();
          }
        } // Sync removed nodes


        for (var k = 0; k < removedNodes.length; k++) {
          var removedNode = removedNodes[k];

          if (isTableRow(removedNode)) {
            changed = true; // If the focusable item is removed, the first item becomes the new focusable item

            if (removedNode.getAttribute('tabindex') === '0') {
              var firstItem = getRows([table.body])[0];

              if (firstItem) {
                table._focusItem(firstItem);
              }
            }

            if (removedNode.selected) {
              table._triggerChangeEvent();
            } // Sync _lastSelectedItems array


            var removedItemIndex = table._lastSelectedItems.items.indexOf(removedNode);

            if (removedItemIndex !== -1) {
              table._lastSelectedItems.items = table._lastSelectedItems.items.splice(removedItemIndex, 1);
            } // Trigger collection event


            if (!table._preventTriggeringEvents) {
              table.trigger('coral-collection:remove', {
                item: removedNode
              });
            }
          }
        }

        if (changed) {
          var items = this._getSelectableItems(); // Sync select all handle if any.


          table._syncSelectAllHandle(table.selectedItems, items); // Disable table features if no items.


          table._toggleInteractivity(items.length === 0);
        }
      }
      /** @private */

    }, {
      key: "_onBodyEmpty",
      value: function _onBodyEmpty(event) {
        event.stopImmediatePropagation();

        this._toggleInteractivity(true);
      }
      /** @private */

    }, {
      key: "_onRowChange",
      value: function _onRowChange(event) {
        event.stopImmediatePropagation();

        if (!this._preventTriggeringEvents) {
          this.trigger('coral-table:rowchange', {
            oldSelection: event.detail.oldSelection,
            selection: event.detail.selection,
            row: event.target
          });
        }
      }
      /** @private */

    }, {
      key: "_onRowContentChanged",
      value: function _onRowContentChanged(event) {
        event.stopImmediatePropagation();
        var table = this;
        var row = event.target;
        var addedNodes = event.detail.addedNodes;
        var addedNode = null;
        var removedNodes = event.detail.removedNodes;

        var selectItem = function selectItem(item) {
          item.selected = item === addedNode;
        }; // Sync added nodes


        for (var i = 0; i < addedNodes.length; i++) {
          addedNode = addedNodes[i]; // Sync row state with table properties

          if (isTableCell(addedNode)) {
            addedNode._toggleSelectable(row.selectable);

            var selectedItems = row.selectedItems;

            if (addedNode.selected) {
              // In single selection, if the added item is selected, the rest should be deselected
              if (!row.multiple && selectedItems.length > 1) {
                selectedItems.forEach(selectItem);
              }

              row._triggerChangeEvent();
            } // Trigger collection event


            if (!table._preventTriggeringEvents) {
              row.trigger('coral-collection:add', {
                item: addedNode
              });
            }
          } // Add appropriate scope depending on whether headercell is in THEAD or TBODY
          else if (isTableHeaderCell(addedNode)) {
              table._setHeaderCellScope(addedNode, row.parentNode);
            }
        } // Sync removed nodes


        for (var k = 0; k < removedNodes.length; k++) {
          var removedNode = removedNodes[k];

          if (isTableCell(removedNode)) {
            if (removedNode.selected) {
              row._triggerChangeEvent();
            } // Trigger collection event


            if (!table._preventTriggeringEvents) {
              row.trigger('coral-collection:remove', {
                item: removedNode
              });
            }
          }
        }
      }
      /** @private */

    }, {
      key: "_toggleInteractivity",
      value: function _toggleInteractivity(disable) {
        var table = this;
        var selectAll = table.querySelector('[coral-table-select]');

        if (selectAll) {
          selectAll.disabled = disable;
        }

        table.classList.toggle(IS_DISABLED, disable);
      }
    }, {
      key: "_onAlignmentChanged",
      value: function _onAlignmentChanged(event) {
        event.stopImmediatePropagation();

        this._resetAlignmentColumns();
      }
      /** @private */

    }, {
      key: "_onFixedWidthChanged",
      value: function _onFixedWidthChanged(event) {
        event.stopImmediatePropagation();
        var table = this;
        var head = table.head;
        var column = event.target;

        if (head) {
          var headRows = getRows([head]);
          var columnIndex = getIndexOf(event.target);
          headRows.forEach(function (row) {
            var headerCell = getCellByIndex(row, columnIndex);

            if (headerCell && headerCell.tagName === 'TH') {
              headerCell[column.fixedWidth ? 'setAttribute' : 'removeAttribute']('fixedwidth', '');
            }
          });
        }

        table._resetLayout();
      }
      /** @private */

    }, {
      key: "_onColumnOrderableChanged",
      value: function _onColumnOrderableChanged(event) {
        event.stopImmediatePropagation();
        var table = this;
        var head = this.head;
        var column = event.target;

        var headerCell = table._getColumnHeaderCell(column);

        if (headerCell) {
          // Move the drag handle
          table._toggleDragActionHandle(headerCell, head && head.sticky);

          table._resetLayout();
        }
      }
      /** @private */

    }, {
      key: "_onColumnSortableChanged",
      value: function _onColumnSortableChanged(event) {
        event.stopImmediatePropagation();
        var table = this;
        var head = this.head;
        var column = event.target;

        var headerCell = table._getColumnHeaderCell(column);

        if (headerCell) {
          // For icons (chevron up/down) styling
          headerCell[column.sortable ? 'setAttribute' : 'removeAttribute']('sortable', ''); // Toggle tab index. Sortable headercells are focusable.

          table._toggleHeaderCellTabIndex(headerCell, head && head.sticky);

          table._resetLayout();
        }
      }
    }, {
      key: "_onColumnSortableDirectionChanged",
      value: function _onColumnSortableDirectionChanged(event) {
        var _this2 = this;

        event.stopImmediatePropagation();
        var table = this;
        var column = event.target;
        var sortableDirection = TableColumn.sortableDirection; // Hide coral-table-roworder handles if table is sorted

        table.classList.toggle(IS_SORTED, table._isSorted());

        var headerCell = table._getColumnHeaderCell(column);

        if (headerCell) {
          // For icons (chevron up/down) styling
          headerCell.setAttribute('sortabledirection', column.sortableDirection);
          (table.head.sticky ? headerCell.content : headerCell).setAttribute('aria-sort', column.sortableDirection === sortableDirection.DEFAULT ? 'none' : column.sortableDirection);

          if (column.sortableDirection === sortableDirection.DEFAULT) {
            this._elements.liveRegion.innerText = '';
          } else {
            var textContent = headerCell.content.textContent.trim();

            if (textContent.length) {
              // Set live region to true so that sort description string will be announced.
              this._elements.liveRegion.setAttribute('aria-live', 'polite');

              this._elements.liveRegion.removeAttribute('aria-hidden');

              this._elements.liveRegion.innerText = i18n.get("sorted by column {0} in ".concat(column.sortableDirection, " order"), textContent); // @a11y wait 2.5 seconds to give screen reader enough time to announce the live region before silencing the it.

              window.setTimeout(function () {
                _this2._elements.liveRegion.setAttribute('aria-live', 'off');

                _this2._elements.liveRegion.setAttribute('aria-hidden', 'true');
              }, 2500);
            }
          }
        }
      }
    }, {
      key: "_onColumnHiddenChanged",
      value: function _onColumnHiddenChanged(event) {
        event.stopImmediatePropagation();

        this._resetHiddenColumns(true);
      }
    }, {
      key: "_onBeforeColumnSort",
      value: function _onBeforeColumnSort(event) {
        event.stopImmediatePropagation();
        var table = this;
        var column = event.target;
        var newSortableDirection = event.detail.newSortableDirection;
        var beforeEvent = table.trigger('coral-table:beforecolumnsort', {
          column: column,
          direction: newSortableDirection
        });

        if (!beforeEvent.defaultPrevented) {
          column.sortableDirection = newSortableDirection;
        }
      }
    }, {
      key: "_onColumnSort",
      value: function _onColumnSort(event) {
        var _this3 = this;

        event.stopImmediatePropagation(); // Don't sort yet

        if (!this._allowSorting) {
          return;
        }

        var table = this;
        var body = table.body;
        var column = event.target;
        var columnIndex = getIndexOf(column);

        var colHeaderCell = table._getColumnHeaderCell(column);

        var onInitialization = event.detail.onInitialization;
        var sortableDirection = event.detail.sortableDirection;
        var sortableType = event.detail.sortableType;
        var rows = getRows([body]);
        var cells = []; // Prevent change event from triggering when sorting

        if (table) {
          table._preventTriggeringEvents = true;
        } // Store a reference of the default row index for default sortable direction


        rows.forEach(function (row, i) {
          if (typeof row._defaultRowIndex === 'undefined') {
            row._defaultRowIndex = i;
          }

          var cell = getCellByIndex(row, columnIndex);

          if (cell) {
            cells.push(cell);
          }
        });

        if (column.sortableDirection === sortableDirection.ASCENDING) {
          // Remove sortable direction on sibling columns
          getSiblingsOf(column, 'col[is="coral-table-column"]').forEach(function (col) {
            col._preventSort = true;
            col.setAttribute('sortabledirection', sortableDirection.DEFAULT);
            col._preventSort = false;
          });

          if (colHeaderCell) {
            // For icons (chevron up/down) styling
            getSiblingsOf(colHeaderCell, 'th[is="coral-table-headercell"]').forEach(function (headerCell) {
              headerCell.setAttribute('sortabledirection', sortableDirection.DEFAULT);
              (table.head.sticky ? headerCell.content : headerCell).setAttribute('aria-sort', 'none');
            });
          } // Use cell value to sort and fallback if not specified


          cells.sort(function (a, b) {
            if (column.sortableType === sortableType.ALPHANUMERIC) {
              var aText = a.value ? a.value : a.textContent;
              var bText = b.value ? b.value : b.textContent;
              return aText.localeCompare(bText);
            } else if (column.sortableType === sortableType.NUMBER) {
              // Remove all spaces and replace commas with dots for decimal values
              var aNumber = parseFloat(a.value ? a.value : a.textContent.replace(/\s+/g, '').replace(/,/g, '.'));
              var bNumber = parseFloat(b.value ? b.value : b.textContent.replace(/\s+/g, '').replace(/,/g, '.'));
              return aNumber > bNumber ? 1 : -1;
            } else if (column.sortableType === sortableType.DATE) {
              var aDate = a.value ? new Date(parseInt(a.value, 10)) : new Date(a.textContent);
              var bDate = b.value ? new Date(parseInt(b.value, 10)) : new Date(b.textContent);
              return aDate > bDate ? 1 : -1;
            }
          }); // Only sort if not custom sorting

          if (column.sortableType !== sortableType.CUSTOM) {
            if (body) {
              // Insert the row at the new position if actually sorted
              cells.forEach(function (cell) {
                var row = cell.parentElement; // Prevent locked row to be sorted

                if (!row.locked) {
                  body.appendChild(row);
                }
              });
            } // Trigger on table


            table.trigger('coral-table:columnsort', {
              column: column
            });
          } // Table is in a sorted state. Disable orderable actions


          rows.forEach(function (row) {
            if (row.dragAction) {
              row.dragAction.destroy();
            }
          });
        } else if (column.sortableDirection === sortableDirection.DESCENDING) {
          getSiblingsOf(column, 'col[is="coral-table-column"]').forEach(function (col) {
            col._preventSort = true;
            col.setAttribute('sortabledirection', sortableDirection.DEFAULT);
            col._preventSort = false;
          });

          if (colHeaderCell) {
            getSiblingsOf(colHeaderCell, 'th[is="coral-table-headercell"]').forEach(function (headerCell) {
              headerCell.setAttribute('sortabledirection', sortableDirection.DEFAULT);
              (table.head.sticky ? headerCell.content : headerCell).setAttribute('aria-sort', 'none');
            });
          }

          cells.sort(function (a, b) {
            if (column.sortableType === sortableType.ALPHANUMERIC) {
              var aText = a.value ? a.value : a.textContent;
              var bText = b.value ? b.value : b.textContent;
              return bText.localeCompare(aText);
            } else if (column.sortableType === sortableType.NUMBER) {
              // Remove all spaces and replace commas with dots for decimal values
              var aNumber = parseFloat(a.value ? a.value : a.textContent.replace(/\s+/g, '').replace(/,/g, '.'));
              var bNumber = parseFloat(b.value ? b.value : b.textContent.replace(/\s+/g, '').replace(/,/g, '.'));
              return aNumber < bNumber ? 1 : -1;
            } else if (column.sortableType === sortableType.DATE) {
              var aDate = a.value ? new Date(parseInt(a.value, 10)) : new Date(a.textContent);
              var bDate = b.value ? new Date(parseInt(b.value, 10)) : new Date(b.textContent);
              return aDate < bDate ? 1 : -1;
            }
          }); // Only sort if not custom sorting

          if (column.sortableType !== sortableType.CUSTOM) {
            if (body) {
              // Insert the row at the new position if actually sorted
              cells.forEach(function (cell) {
                var row = cell.parentElement; // Prevent locked row to be sorted

                if (!row.locked) {
                  body.appendChild(row);
                }
              });
            } // Trigger on table


            table.trigger('coral-table:columnsort', {
              column: column
            });
          } // Table is in a sorted state. Disable orderable actions


          rows.forEach(function (row) {
            if (row.dragAction) {
              row.dragAction.destroy();
            }
          });
        } else if (column.sortableDirection === sortableDirection.DEFAULT && !onInitialization) {
          // Only sort if not custom sorting
          if (column.sortableType !== sortableType.CUSTOM) {
            // Put rows back to their initial position
            rows.sort(function (a, b) {
              return a._defaultRowIndex > b._defaultRowIndex ? 1 : -1;
            });
            rows.forEach(function (row) {
              // Prevent locked row to be sorted
              if (body && !row.locked) {
                body.appendChild(row);
              }
            }); // Trigger on table

            table.trigger('coral-table:columnsort', {
              column: column
            });
          }
        } // Allow triggering change events again after sorting


        window.requestAnimationFrame(function () {
          // a11y initialize column sort aria-describedby
          if (onInitialization && column.sortableDirection !== sortableDirection.DEFAULT) {
            var textContent = colHeaderCell.content.textContent.trim();

            if (textContent.length) {
              _this3._elements.liveRegion.innerText = i18n.get("sorted by column {0} in ".concat(column.sortableDirection, " order"), textContent);
            }
          }

          table._preventTriggeringEvents = false;
        });
      }
    }, {
      key: "_onHeadStickyChanged",
      value: function _onHeadStickyChanged(event) {
        event.stopImmediatePropagation(); // a11y

        this._toggleFocusable();

        var table = this;
        var head = event.target; // Wait next frame before reading and changing header cell layout

        window.requestAnimationFrame(function () {
          // Defines the head height
          var tableHeight = head.sticky ? "".concat(head.getBoundingClientRect().height, "px") : null;

          table._resetContainerLayout(tableHeight, table._elements.container.style.height);

          getRows([head]).forEach(function (row) {
            getHeaderCells(row).forEach(function (headerCell) {
              table._toggleStickyHeaderCell(headerCell, head.sticky);
            });
          }); // Make sure sticky styling is applied

          table.classList.toggle("".concat(CLASSNAME$1x, "--sticky"), head.sticky); // Layout sticky head

          table._preventResetLayout = false;

          table._resetLayout();
        });
      }
      /** @private */

    }, {
      key: "_getColumnHeaderCell",
      value: function _getColumnHeaderCell(column) {
        var table = this;
        var head = table.head;
        var headerCell = null;

        if (head) {
          var headRows = getRows([head]);
          var columnIndex = getIndexOf(column);

          if (headRows.length) {
            headerCell = getCellByIndex(headRows[headRows.length - 1], columnIndex);
            headerCell = headerCell && headerCell.tagName === 'TH' ? headerCell : null;
          }
        }

        return headerCell;
      }
      /** @private */

    }, {
      key: "_getColumn",
      value: function _getColumn(headerCell) {
        // Get the corresponding column
        return getColumns(this.columns)[getIndexOf(headerCell)] || null;
      }
      /** @private */

    }, {
      key: "_toggleStickyHeaderCell",
      value: function _toggleStickyHeaderCell(headerCell, sticky) {
        // Set the size
        this._layoutStickyCell(headerCell, sticky); // Define DragAction on the sticky cell instead of the headercell


        this._toggleDragActionHandle(headerCell, sticky); // Toggle tab index. Sortable headercells are focusable.


        this._toggleHeaderCellTabIndex(headerCell, sticky);
      }
    }, {
      key: "_layoutStickyCell",
      value: function _layoutStickyCell(headerCell, sticky) {
        if (sticky) {
          var computedStyle = window.getComputedStyle(headerCell); // Don't allow the column to shrink less than its minimum allowed

          if (!headerCell.style.minWidth) {
            var hasVisibleChildNodes = false; // In most cases, there's text content

            if (headerCell.textContent.trim().length) {
              hasVisibleChildNodes = true;
            } // Verify if there are any visible nodes without text content which could take layout space
            else {
                var headerCellChildren = headerCell.content.children;

                for (var i = 0; i < headerCellChildren.length && !hasVisibleChildNodes; i++) {
                  if (headerCellChildren[0].offsetParent) {
                    hasVisibleChildNodes = true;
                  }
                }
              }

            if (hasVisibleChildNodes) {
              var width = headerCell.content.getBoundingClientRect().width; // Don't set the width if the header cell is hidden

              if (width > 0) {
                headerCell.style.minWidth = "".concat(width, "px");
              }
            }
          }

          var cellWidth = parseFloat(computedStyle.width);
          var cellPadding = parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);
          var borderRightWidth = parseFloat(computedStyle.borderRightWidth); // Reflect headercell size on sticky cell

          headerCell.content.style.width = "".concat(cellWidth + cellPadding + borderRightWidth, "px");
        } else {
          // Restore headercell style
          headerCell.style.minWidth = '';
          headerCell.content.style.width = '';
          headerCell.content.style.height = '';
          headerCell.content.style.top = '';
          headerCell.content.style.marginLeft = '';
          headerCell.content.style.paddingTop = '';
        }
      }
      /** @private */

    }, {
      key: "_toggleDragActionHandle",
      value: function _toggleDragActionHandle(headerCell, sticky) {
        var column = this._getColumn(headerCell);

        if (headerCell.dragAction) {
          headerCell.dragAction.destroy();
        }

        if (headerCell.content.dragAction) {
          headerCell.content.dragAction.destroy();
        }

        if (column && column.orderable) {
          var dragAction = new DragAction(sticky ? headerCell.content : headerCell);
          dragAction.axis = 'horizontal'; // Handle the scroll in table

          dragAction.scroll = false;
          headerCell.setAttribute('orderable', '');
        } else {
          headerCell.removeAttribute('orderable');
        }
      }
      /** @private */

    }, {
      key: "_toggleFocusable",
      value: function _toggleFocusable() {
        var firstItem = getRows([this.body])[0];

        if (!firstItem) {
          return;
        }

        var focusableItem = this._getFocusableItem();

        if (this.selectable || this.lockable || this.orderable || this.head && this.head.sticky) {
          // First item is focusable by default but don't remove the tabindex of the existing focusable item
          if (!focusableItem) {
            this._toggleElementTabIndex(firstItem);
          }
        } else if (focusableItem) {
          // Basic table is not focusable
          focusableItem.removeAttribute('tabindex');
        }
      }
      /** @private */

    }, {
      key: "_toggleElementTabIndex",
      value: function _toggleElementTabIndex(element, oldFocusable, forceFocus) {
        if (oldFocusable) {
          oldFocusable.removeAttribute('tabindex');
        }

        element.setAttribute('tabindex', '0');

        if (forceFocus) {
          element.focus();
        }
      }
      /** @private */

    }, {
      key: "_toggleHeaderCellTabIndex",
      value: function _toggleHeaderCellTabIndex(headerCell, sticky) {
        var column = this._getColumn(headerCell);

        var sortable = column && (column.sortable || column.orderable);
        headerCell[sortable && !sticky ? 'setAttribute' : 'removeAttribute']('tabindex', '0');
        headerCell.content[sortable && sticky ? 'setAttribute' : 'removeAttribute']('tabindex', '0');
      }
      /** @private */

    }, {
      key: "_isSorted",
      value: function _isSorted() {
        var column = null;
        var isSorted = getColumns(this.columns).some(function (col) {
          column = col;
          return col.sortableDirection !== TableColumn.sortableDirection.DEFAULT;
        });
        return isSorted ? column : false;
      }
      /** @private */

    }, {
      key: "_focusEdgeItem",
      value: function _focusEdgeItem(event, first) {
        var items = getRows([this.body]);

        if (items.length) {
          event.preventDefault();

          var item = this._getFocusableItem();

          if (item) {
            item.removeAttribute('tabindex');
          }

          item = items[first ? 0 : items.length - 1];
          item.setAttribute('tabindex', '0');
          item.focus();
        }
      }
      /** @private */

    }, {
      key: "_focusSiblingItem",
      value: function _focusSiblingItem(event, next) {
        var item = this._getFocusableItem();

        if (item) {
          event.preventDefault();
          var siblingItem = getSiblingsOf(item, 'tr[is="coral-table-row"]', next ? 'next' : 'prev');

          if (siblingItem) {
            item.removeAttribute('tabindex');
            siblingItem.setAttribute('tabindex', '0');
            siblingItem.focus();
          }
        }
      }
      /** @private */

    }, {
      key: "_selectSiblingItem",
      value: function _selectSiblingItem(next) {
        var _this4 = this;

        if (this.selectable && this.multiple) {
          var selectedItems = this.selectedItems;
          var lastSelectedItem = this._lastSelectedItems.items[this._lastSelectedItems.items.length - 1];

          if (selectedItems.length) {
            // Prevent selection if we reached the edge
            if (next && lastSelectedItem.matches(':last-of-type') || !next && lastSelectedItem.matches(':first-of-type')) {
              return;
            } // Target sibling item


            var sibling = getSiblingsOf(lastSelectedItem, 'tr[is="coral-table-row"]', next ? 'next' : 'prev');

            if (!sibling.hasAttribute('selected')) {
              lastSelectedItem = sibling;
            } // Store last selection


            this._lastSelectedItems.direction = next ? 'down' : 'up'; // Toggle selection

            lastSelectedItem.selected = !lastSelectedItem.selected;
          } else if (getRows([this.body]).length) {
            var focusableItem = this._getFocusableItem(); // Store last selection


            this._lastSelectedItems.direction = next ? 'down' : 'up'; // Select focusable item by default if no items selected

            focusableItem.selected = true;
          }
        } // Focus last selected item


        window.requestAnimationFrame(function () {
          var itemToFocus = _this4._lastSelectedItems.items[_this4._lastSelectedItems.items.length - 1];

          if (itemToFocus) {
            _this4._focusItem(itemToFocus, true);
          }
        });
      }
      /** @private */

    }, {
      key: "_getFocusableItem",
      value: function _getFocusableItem() {
        return this.body && this.body.querySelector('tr[is="coral-table-row"][tabindex="0"]');
      }
      /** @private */

    }, {
      key: "_getFocusableHeaderCell",
      value: function _getFocusableHeaderCell() {
        return this.head && this.head.querySelector('th[is="coral-table-headercell"][tabindex="0"], coral-table-headercell-label[tabindex="0"]');
      }
      /** @private */

    }, {
      key: "_addLastSelectedItem",
      value: function _addLastSelectedItem(item) {
        if (this._lastSelectedItems.items.indexOf(item) === -1) {
          this._lastSelectedItems.items.push(item);
        } else {
          // Push it at the end
          this._removeLastSelectedItem(item);

          this._addLastSelectedItem(item);
        }
      }
      /** @private */

    }, {
      key: "_removeLastSelectedItem",
      value: function _removeLastSelectedItem(item) {
        this._lastSelectedItems.items.splice(this._lastSelectedItems.items.indexOf(item), 1);
      }
      /** @private */

    }, {
      key: "_focusItem",
      value: function _focusItem(item, forceFocus) {
        this._toggleElementTabIndex(item, this._getFocusableItem(), forceFocus);
      }
      /** @private */

    }, {
      key: "_onFocusFirstItem",
      value: function _onFocusFirstItem(event) {
        this._focusEdgeItem(event, true);
      }
      /** @private */

    }, {
      key: "_onFocusLastItem",
      value: function _onFocusLastItem(event) {
        this._focusEdgeItem(event, false);
      }
      /** @private */

    }, {
      key: "_onFocusNextItem",
      value: function _onFocusNextItem(event) {
        this._focusSiblingItem(event, true);
      }
      /** @private */

    }, {
      key: "_onFocusPreviousItem",
      value: function _onFocusPreviousItem(event) {
        this._focusSiblingItem(event, false);
      }
      /** @private */

    }, {
      key: "_onSelectNextItem",
      value: function _onSelectNextItem() {
        this._selectSiblingItem(true);
      }
      /** @private */

    }, {
      key: "_onSelectPreviousItem",
      value: function _onSelectPreviousItem() {
        this._selectSiblingItem(false);
      }
      /**
       * Call the layout method of table component
       *
       * @param {Boolean} forced
       * If true call the layout method immediately, else wait for timeout
       */

    }, {
      key: "resetLayout",
      value: function resetLayout(forced) {
        forced = transform.boolean(forced);

        if (forced === true) {
          this._doResetLayout();

          this._preventResetLayout = false;
        } else {
          this._resetLayout();
        }
      }
      /** @private */

    }, {
      key: "_doResetLayout",
      value: function _doResetLayout() {
        this.classList.add(IS_LAYOUTING);

        this._resizeStickyHead();

        this._resizeContainer();

        this.classList.remove(IS_LAYOUTING);
      }
      /** @private */

    }, {
      key: "_resetLayout",
      value: function _resetLayout() {
        var _this5 = this;

        if (this._preventResetLayout) {
          return;
        } // Debounce


        if (this._timeout !== null) {
          window.clearTimeout(this._timeout);
        }

        this._timeout = window.setTimeout(function () {
          _this5._timeout = null;

          _this5._doResetLayout(); // Mark table as ready


          _this5.classList.add(IS_READY);
        }, this._wait);
      }
      /** @private */

    }, {
      key: "_resizeStickyHead",
      value: function _resizeStickyHead() {
        var table = this;
        var head = table.head;

        if (head && head.sticky) {
          getRows([head]).forEach(function (row) {
            getHeaderCells(row).forEach(function (headerCell) {
              table._layoutStickyCell(headerCell, true);
            });
          });
        }
      }
      /** @private */

    }, {
      key: "_resizeContainer",
      value: function _resizeContainer() {
        var table = this;
        var head = table.head;

        if (head && head.sticky) {
          var calculatedHeadSize = 0;
          var previousRowHeight = 0; // Reset head layout

          getRows([head]).forEach(function (row, i) {
            var headerCells = getHeaderCells(row);

            if (headerCells.length) {
              var computedStyle = window.getComputedStyle(headerCells[0].content);
              var rowHeight = 0;
              var stickyHeaderCellMinHeight = parseFloat(computedStyle.minHeight); // Divider 'row' or 'cell'  adds a border top

              var borderTop = parseFloat(computedStyle.borderTopWidth);
              headerCells.forEach(function (headerCell) {
                // Reset to default
                headerCell.content.style.height = ''; // The highest header cell defines the row height

                rowHeight = Math.max(rowHeight, headerCell.content.getBoundingClientRect().height);
              }); // Add the row height to the table head height

              calculatedHeadSize += rowHeight;
              headerCells.forEach(function (headerCell) {
                // Expand the header cell height to the row height
                if (rowHeight - borderTop !== stickyHeaderCellMinHeight) {
                  headerCell.content.style.height = "".concat(rowHeight, "px");
                } // Vertically align text in sticky cell by getting the label height


                if (headerCell.content.textContent.trim().length && !headerCell.content.querySelector('coral-checkbox[coral-table-select]')) {
                  var stickyHeaderCellHeight = headerCell.content.getBoundingClientRect().height;
                  var span = document.createElement('span'); // Prevents a recursive table relayout that is triggered from changing the header cell content

                  table._preventResetLayout = true;

                  while (headerCell.content.firstChild) {
                    span.appendChild(headerCell.content.firstChild);
                  }

                  headerCell.content.appendChild(span);
                  var labelHeight = span.getBoundingClientRect().height;
                  var paddingTop = (stickyHeaderCellHeight - labelHeight) / 2;

                  while (span.firstChild) {
                    headerCell.content.appendChild(span.firstChild);
                  }

                  headerCell.content.removeChild(span);
                  headerCell.content.style.paddingTop = "".concat(paddingTop, "px");
                  window.requestAnimationFrame(function () {
                    table._preventResetLayout = false;
                  });
                } // Position the sticky cell


                previousRowHeight = previousRowHeight || rowHeight;
                headerCell.content.style.top = "".concat(i > 0 ? previousRowHeight * i + borderTop * (i - 1) : 0, "px");
              });
            }
          });
          var containerComputedStyle = window.getComputedStyle(this._elements.container);
          var borderTopWidth = parseFloat(containerComputedStyle.borderTopWidth);
          var borderBottomWidth = parseFloat(containerComputedStyle.borderBottomWidth);
          var containerBorderSize = borderTopWidth + borderBottomWidth;
          var containerMarginTop = "".concat(calculatedHeadSize, "px");
          var containerHeight = "calc(100% - ".concat(calculatedHeadSize + containerBorderSize, "px)");

          this._resetContainerLayout(containerMarginTop, containerHeight);
        } else {
          this._resetContainerLayout();
        }
      }
      /** @private */

    }, {
      key: "_resetContainerLayout",
      value: function _resetContainerLayout(marginTop, height) {
        this._elements.container.style.marginTop = marginTop || '';
        this._elements.container.style.height = height || '';
      }
      /** @private */

    }, {
      key: "_resetHiddenColumns",
      value: function _resetHiddenColumns(resetLayout) {
        var _this6 = this;

        this.id = this.id || commons.getUID(); // Delete styles

        this._elements.hiddenStyle.innerHTML = ''; // Render styles for each column

        getColumns(this.columns).forEach(function (column) {
          if (column.hidden) {
            var columnIndex = getIndexOf(column) + 1;
            _this6._elements.hiddenStyle.innerHTML += "\n           #".concat(_this6.id, " ._coral-Table-cell:nth-child(").concat(columnIndex, "),\n           #").concat(_this6.id, " ._coral-Table-headerCell:nth-child(").concat(columnIndex, ") {\n             display: none;\n           }\n        ");
          }
        });

        if (resetLayout) {
          this._resetLayout();
        }
      }
    }, {
      key: "_resetAlignmentColumns",
      value: function _resetAlignmentColumns() {
        var _this7 = this;

        this.id = this.id || commons.getUID(); // Delete styles

        this._elements.alignmentStyle.innerHTML = '';
        getColumns(this.columns).forEach(function (column) {
          var columnAlignment = column.alignment;
          var columnIndex = getIndexOf(column) + 1;
          _this7._elements.alignmentStyle.innerHTML += "\n         #".concat(_this7.id, " ._coral-Table-cell:nth-child(").concat(columnIndex, "),\n         #").concat(_this7.id, " ._coral-Table-headerCell:nth-child(").concat(columnIndex, ") {\n           text-align: ").concat(columnAlignment, ";\n         }\n      ");
        });
      }
      /** @private */

    }, {
      key: "_onScroll",
      value: function _onScroll() {
        var table = this;
        var head = table.head; // Ignore if only vertical scroll

        var scrollLeft = table._elements.container.scrollLeft;

        if (table._lastScrollLeft === scrollLeft) {
          return;
        }

        table._lastScrollLeft = scrollLeft;

        if (head && head.sticky) {
          // Trigger a reflow that will reposition the sticky cells for FF only.
          head.style.margin = '1px';
          window.requestAnimationFrame(function () {
            head.style.margin = ''; // In other browsers e.g Chrome or IE, we need to adjust the position of the sticky cells manually

            if (!table._preventLayoutStickyCellOnScroll) {
              var firstHeaderCell = head.querySelector('tr[is="coral-table-row"] th[is="coral-table-headercell"]');

              if (firstHeaderCell) {
                // Verify if the sticky cells need to be adjusted. If the first one didn't move, we can assume that they
                // all need to be adjusted. By default, the left offset is 1px because of the table border.
                if (table._layoutStickyCellOnScroll || firstHeaderCell.content.offsetLeft === 1) {
                  table._layoutStickyCellOnScroll = true;
                  getRows([head]).forEach(function (row) {
                    getHeaderCells(row).forEach(function (headerCell) {
                      var paddingLeft = parseFloat(window.getComputedStyle(headerCell).paddingLeft);
                      headerCell.content.style.marginLeft = "-".concat(scrollLeft + paddingLeft, "px");
                    });
                  });
                } else {
                  // We don't need to layout the sticky cells manually
                  table._preventLayoutStickyCellOnScroll = true;
                }
              }
            }
          });
        }
      } // @compat

    }, {
      key: "_toggleSelectionCheckbox",
      value: function _toggleSelectionCheckbox(row) {
        var cells = getContentCells(row);

        var renderCheckbox = function renderCheckbox(cell, process) {
          // Support cloneNode
          cell._checkbox = cell._checkbox || cell.querySelector('coral-checkbox'); // Render checkbox if none

          if (!cell._checkbox) {
            cell._checkbox = new Checkbox();
          }

          process(cell._checkbox); // Add checkbox

          cell.insertBefore(cell._checkbox, cell.firstChild);
        };

        cells.forEach(function (cell, i) {
          var isRowSelect = i === 0 && cell.hasAttribute('coral-table-rowselect');
          var isCellSelect = cell.hasAttribute('coral-table-cellselect') || cell.querySelector('coral-checkbox[coral-table-cellselect]');

          if (isRowSelect || isCellSelect) {
            var handle;

            if (isRowSelect) {
              handle = 'coral-table-rowselect';
            }

            if (isCellSelect) {
              handle = 'coral-table-cellselect';
            }

            renderCheckbox(cell, function (checkbox) {
              // Define selection handle
              if (isRowSelect) {
                cell.classList.add('_coral-Table-cell--check');
                cell.removeAttribute(handle);
                checkbox.setAttribute(handle, '');
              } else {
                cell.setAttribute(handle, '');
                checkbox.removeAttribute(handle);
              } // Sync selection


              var isSelected = (isRowSelect ? row : cell).hasAttribute('selected');
              checkbox[isSelected ? 'setAttribute' : 'removeAttribute']('checked', '');
            });
          }
        });
      }
      /** @private */

    }, {
      key: "_setHeaderCellScope",
      value: function _setHeaderCellScope(headerCell, tableSection) {
        // Add appropriate scope depending on whether header cell is in THEAD or TBODY
        var scope = tableSection.nodeName === 'THEAD' || tableSection.nodeName === 'TFOOT' ? 'col' : 'row';

        if (scope === 'col') {
          if (this.head && this.head.sticky) {
            headerCell.setAttribute('role', 'presentation');

            headerCell._elements.content.setAttribute('role', 'columnheader');
          } else {
            headerCell.setAttribute('role', 'columnheader');
          }
        } else {
          headerCell.setAttribute('role', 'rowheader');
        }

        headerCell.setAttribute('scope', scope);
      }
      /**  @private */

    }, {
      key: "_handleMutations",
      value: function _handleMutations(mutations) {
        var _this8 = this;

        mutations.forEach(function (mutation) {
          // Sync removed nodes
          for (var k = 0; k < mutation.removedNodes.length; k++) {
            var removedNode = mutation.removedNodes[k];

            if (isTableBody(removedNode)) {
              // Always make sure there's a body content zone
              if (!_this8.body) {
                _this8.body = new TableBody();
              }

              _this8._onBodyContentChanged({
                target: removedNode,
                detail: {
                  addedNodes: [],
                  removedNodes: getRows([removedNode])
                }
              });
            }
          }
        });

        this._resetLayout();
      }
    }, {
      key: "_getSelectableItems",
      value: function _getSelectableItems() {
        return this.items._getSelectableItems().filter(function (item) {
          return !item.querySelector('[coral-table-rowselect][disabled]');
        });
      }
    }, {
      key: "_toggleObserver",
      value: function _toggleObserver(enable) {
        this._observer = this._observer || new MutationObserver(this._handleMutations.bind(this));

        if (enable) {
          this._observer.observe(this, {
            childList: true,
            subtree: true
          });
        } else {
          this._observer.disconnect();
        }
      }
    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        var _this9 = this;

        _get(_getPrototypeOf(Table.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1x); // Wrapper should have role="presentation" because it wraps another table

        this.setAttribute('role', 'presentation'); // Default reflected attribute

        if (!this._variant) {
          this.variant = variant$m.DEFAULT;
        }

        var head = this._elements.head;
        var body = this._elements.body;
        var foot = this._elements.foot;
        var columns = this._elements.columns; // Disable observer while rendering template

        this._toggleObserver(false);

        this._elements.head.setAttribute('_observe', 'off');

        this._elements.body.setAttribute('_observe', 'off'); // Render template


        var frag = document.createDocumentFragment();
        frag.appendChild(this._elements.container);
        frag.appendChild(this._elements.liveRegion); // cloneNode support

        var wrapper = this.querySelector('._coral-Table-wrapper-container');

        if (wrapper) {
          wrapper.remove();
        }

        var liveRegion = this.querySelector('._coral-Table-liveRegion');

        if (liveRegion) {
          liveRegion.remove();
        } // Append frag


        this.appendChild(frag); // Call content zone inserts

        this.head = head;
        this.body = body;
        this.foot = foot;
        this.columns = columns; // Set header cell scope

        getRows([this._elements.table]).forEach(function (row) {
          getHeaderCells(row).forEach(function (headerCell) {
            _this9._setHeaderCellScope(headerCell, row.parentNode);
          });
        }); // With a thead and tfoot,

        if (this.head && this.foot) {
          var headRows = getRows([this.head]);
          var footRows = getRows([this.foot]); // if the number of rows in the thead and tfoot match

          if (headRows.length === footRows.length) {
            var redundantFooter = true; // and the textContent of each thead header cell matches the textContent of each tfoot header cell in the same column

            headRows.forEach(function (row, rowIndex) {
              return getHeaderCells(row).forEach(function (headerCell, cellIndex) {
                var footerCell = getHeaderCells(footRows[rowIndex])[cellIndex];

                if (!footerCell || headerCell.textContent.trim() !== footerCell.textContent.trim()) {
                  redundantFooter = false;
                }
              });
            }); // the tfoot is redundant and should be hidden to prevent double or triple voicing of table headers.

            if (redundantFooter) {
              this.foot.setAttribute('aria-hidden', 'true');
            }
          }
        } // Detect table size changes


        commons.addResizeListener(this, this._resetLayout); // Disable table features if no items.

        var items = this._getSelectableItems();

        this._toggleInteractivity(items.length === 0); // Sync selection state


        if (this.selectable) {
          var selectedItems = this.selectedItems; // Sync select all handle if any

          this._syncSelectAllHandle(selectedItems, items); // Sync used collections


          if (selectedItems.length) {
            this._oldSelection = selectedItems;
            this._lastSelectedItems.items = selectedItems;
          }
        } // Sync sorted


        this._allowSorting = true;

        var column = this._isSorted();

        if (column) {
          column._doSort(true);
        } // @compat


        if (this.body) {
          var rows = getRows([this.body]); // Use the first column as selection column

          rows.forEach(function (row) {
            return _this9._toggleSelectionCheckbox(row);
          });
        } // Enable observer again


        this._toggleObserver(true); // Mark table as ready


        if (!this.head || this.head && !this.head.hasAttribute('sticky')) {
          this.classList.add(IS_READY);
        }
      }
      /**
       Triggered before a {@link Table} column gets sorted by user interaction. Can be used to cancel column sorting and define
       custom sorting.
        @typedef {CustomEvent} coral-table:beforecolumnsort
        @property {TableColumn} detail.column
       The column to be sorted.
       @property {String} detail.direction
       The requested sorting direction for the column.
       */

      /**
       Triggered when a {@link Table} column is sorted.
        @typedef {CustomEvent} coral-table:columnsort
        @param {TableColumn} detail.column
       The sorted column.
       */

      /**
       Triggered before a {@link Table} column is dragged. Can be used to cancel column dragging.
        @typedef {CustomEvent} coral-table:beforecolumndrag
        @property {TableColumn} detail.column
       The dragged column.
       @property {TableColumn} detail.before
       The column will be inserted before this sibling column.
       If <code>null</code>, the column is inserted at the end.
       */

      /**
       Triggered when a {@link Table} column is dragged.
        @typedef {CustomEvent} coral-table:columndrag
        @property {TableColumn} detail.column
       The dragged column.
       @property {TableColumn} detail.oldBefore
       The column next sibling before the swap.
       If <code>null</code>, the column was the last item.
       @property {TableColumn} detail.before
       The column is inserted before this sibling column.
       If <code>null</code>, the column is inserted at the end.
       */

      /**
       Triggered before a {@link Table} row is ordered. Can be used to cancel row ordering.
        @typedef {CustomEvent} coral-table:beforeroworder
        @property {TableRow} detail.row
       The row to be ordered.
       @property {TableRow} detail.before
       The row will be inserted before this sibling row.
       If <code>null</code>, the row is inserted at the end.
       */

      /**
       Triggered when a {@link Table} row is ordered.
        @typedef {CustomEvent} coral-table:roworder
        @property {TableRow} detail.row
       The ordered row.
       @property {TableRow} detail.oldBefore
       The row next sibling before the swap.
       If <code>null</code>, the row was the last item.
       @param {TableRow} detail.before
       The row is inserted before this sibling row.
       If <code>null</code>, the row is inserted at the end.
       */

      /**
       Triggered when a {@linked Table} row is locked.
        @typedef {CustomEvent} coral-table:rowlock
        @property {TableRow} detail.row
       The locked row.
       */

      /**
       Triggered when {@link Table} a row is locked.
        @typedef {CustomEvent} coral-table:rowunlock
        @property {TableRow} detail.row
       The unlocked row.
       */

      /**
       Triggered when a {@link Table} row selection changed.
        @typedef {CustomEvent} coral-table:rowchange
        @property {Array.<TableCell>} detail.oldSelection
       The old item selection. When {@link TableRow#multiple}, it includes an Array.
       @property {Array.<TableCell>} detail.selection
       The item selection. When {@link Coral.Table.Row#multiple}, it includes an Array.
       @property {TableRow} detail.row
       The targeted row.
       */

      /**
       Triggered when the {@link Table} selection changed.
        @typedef {CustomEvent} coral-table:change
        @property {Array.<TableRow>} detail.oldSelection
       The old item selection. When {@link Table#multiple}, it includes an Array.
       @property {Array.<TableRow>} detail.selection
       The item selection. When {@link Table#multiple}, it includes an Array.
       */

    }, {
      key: "head",
      get: function get() {
        return this._getContentZone(this._elements.head);
      },
      set: function set(value) {
        this._setContentZone('head', value, {
          handle: 'head',
          tagName: 'thead',
          insert: function insert(head) {
            // Using the native table API allows to position the head element at the correct position.
            this._elements.table.tHead = head; // To init the head observer

            head.setAttribute('_observe', 'on');
          }
        });
      }
      /**
       The body of the table. Multiple bodies are not supported.
        @type {TableBody}
       @contentzone
       */

    }, {
      key: "body",
      get: function get() {
        return this._getContentZone(this._elements.body);
      },
      set: function set(value) {
        this._setContentZone('body', value, {
          handle: 'body',
          tagName: 'tbody',
          insert: function insert(body) {
            this._elements.table.appendChild(body);

            this.items._container = body; // To init the body observer

            body.setAttribute('_observe', 'on');
          }
        });
      }
      /**
       The foot of the table.
        @type {TableFoot}
       @contentzone
       */

    }, {
      key: "foot",
      get: function get() {
        return this._getContentZone(this._elements.foot);
      },
      set: function set(value) {
        this._setContentZone('foot', value, {
          handle: 'foot',
          tagName: 'tfoot',
          insert: function insert(foot) {
            // Using the native table API allows to position the foot element at the correct position.
            this._elements.table.tFoot = foot;
          }
        });
      }
      /**
       The columns of the table.
        @type {TableColumn}
       @contentzone
       */

    }, {
      key: "columns",
      get: function get() {
        return this._getContentZone(this._elements.columns);
      },
      set: function set(value) {
        this._setContentZone('columns', value, {
          handle: 'columns',
          tagName: 'colgroup',
          insert: function insert(content) {
            this._elements.table.appendChild(content);
          }
        });
      }
      /**
       The table's variant. See {@link TableVariantEnum}.
        @type {String}
       @default TableVariantEnum.DEFAULT
       @htmlattribute variant
       @htmlattributereflected
       */

    }, {
      key: "variant",
      get: function get() {
        return this._variant || variant$m.DEFAULT;
      },
      set: function set(value) {
        var _this$classList;

        value = transform.string(value).toLowerCase();
        this._variant = validate.enumeration(variant$m)(value) && value || variant$m.DEFAULT;

        this._reflectAttribute('variant', this._variant);

        (_this$classList = this.classList).remove.apply(_this$classList, ALL_VARIANT_CLASSES$c);

        this.classList.add("".concat(CLASSNAME$1x, "--").concat(this._variant));
      }
      /**
       Whether the items are selectable.
        @type {Boolean}
       @default false
       @htmlattribute selectable
       @htmlattributereflected
       */

    }, {
      key: "selectable",
      get: function get() {
        return this._selectable || false;
      },
      set: function set(value) {
        this._selectable = transform.booleanAttr(value);

        this._reflectAttribute('selectable', this._selectable);

        var rows = getRows([this.body]);

        if (this._selectable) {
          rows.forEach(function (row) {
            row.setAttribute('_selectable', '');
          });
        } else {
          // Clear selection
          rows.forEach(function (row) {
            row.removeAttribute('_selectable');
          });
          this.trigger('coral-table:change', {
            selection: [],
            oldSelection: this._oldSelection
          }); // Sync used collection

          this._oldSelection = [];
          this._lastSelectedItems.items = [];
        } // a11y


        this._toggleFocusable();
      }
      /**
       Whether the table is orderable. If the table is sorted, ordering handles are hidden.
        @type {Boolean}
       @default false
       @htmlattribute orderable
       @htmlattributereflected
       */

    }, {
      key: "orderable",
      get: function get() {
        return this._orderable || false;
      },
      set: function set(value) {
        var _this10 = this;

        this._orderable = transform.booleanAttr(value);

        this._reflectAttribute('orderable', this._orderable);

        getRows([this.body]).forEach(function (row) {
          row[_this10._orderable ? 'setAttribute' : 'removeAttribute']('_orderable', '');
        }); // a11y

        this._toggleFocusable();
      }
      /**
       Whether multiple items can be selected.
        @type {Boolean}
       @default false
       @htmlattribute multiple
       @htmlattributereflected
       */

    }, {
      key: "multiple",
      get: function get() {
        return this._multiple || false;
      },
      set: function set(value) {
        this._multiple = transform.booleanAttr(value);

        this._reflectAttribute('multiple', this._multiple);

        this._elements.table.setAttribute('aria-multiselectable', this._multiple); // Deselect all except last


        if (!this.multiple) {
          var selection = this.selectedItems;

          if (selection.length > 1) {
            selection.forEach(function (row, i) {
              // Don't trigger too many events
              row.set('selected', i === selection.length - 1, true);
            }); // Synchronise the table select handle

            var newSelection = this.selectedItems;

            if (newSelection.length) {
              this._setSelectAllHandleState('indeterminate');
            } else {
              this._setSelectAllHandleState('unchecked');
            }

            this.trigger('coral-table:change', {
              selection: newSelection,
              oldSelection: selection
            }); // Sync used collection

            this._oldSelection = newSelection;
            this._lastSelectedItems.items = newSelection;
          }
        }
      }
      /**
       Whether the table rows can be locked/unlocked. If rows are locked, they float to the top of the table and aren't
       affected by column sorting.
        @type {Boolean}
       @default false
       @htmlattribute lockable
       @htmlattributereflected
       */

    }, {
      key: "lockable",
      get: function get() {
        return this._lockable || false;
      },
      set: function set(value) {
        var _this11 = this;

        this._lockable = transform.booleanAttr(value);

        this._reflectAttribute('lockable', this._lockable);

        getRows([this.body]).forEach(function (row) {
          row[_this11._lockable ? 'setAttribute' : 'removeAttribute']('_lockable', '');
        }); // a11y

        this._toggleFocusable();
      }
      /**
       Specifies <code>aria-labelledby</code> value.
        @type {?String}
       @default null
       @htmlattribute labelledby
       */

    }, {
      key: "labelledBy",
      get: function get() {
        return this._elements.table.getAttribute('aria-labelledby');
      },
      set: function set(value) {
        value = transform.string(value);

        this._elements.table[value ? 'setAttribute' : 'removeAttribute']('aria-labelledby', value);
      }
      /**
       Specifies <code>aria-label</code> value.
        @type {String}
       @default null
       @htmlattribute labelled
       */

    }, {
      key: "labelled",
      get: function get() {
        return this._elements.table.getAttribute('aria-label');
      },
      set: function set(value) {
        value = transform.string(value);

        this._elements.table[value ? 'setAttribute' : 'removeAttribute']('aria-label', value);
      }
      /**
       Returns an Array containing the selected items.
        @type {Array.<HTMLElement>}
       @readonly
       */

    }, {
      key: "selectedItems",
      get: function get() {
        return this.items._getAllSelected();
      }
      /**
       Returns the first selected item of the table. The value <code>null</code> is returned if no element is
       selected.
        @type {HTMLElement}
       @readonly
       */

    }, {
      key: "selectedItem",
      get: function get() {
        return this.items._getFirstSelected();
      }
      /**
       The Collection Interface that allows interacting with the items that the component contains.
        @type {SelectableCollection}
       @readonly
       */

    }, {
      key: "items",
      get: function get() {
        // Construct the collection on first request
        if (!this._items) {
          this._items = new SelectableCollection({
            host: this,
            container: this.body,
            itemBaseTagName: 'tr',
            itemTagName: 'coral-table-row'
          });
        }

        return this._items;
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          tbody: 'body',
          thead: 'head',
          tfoot: 'foot',
          colgroup: 'columns'
        };
      }
      /**
       Returns {@link Table} variants.
        @return {TableVariantEnum}
       */

    }], [{
      key: "variant",
      get: function get() {
        return variant$m;
      }
      /**
       Returns divider options for {@link TableHead}, {@link TableBody} and {@link TableFoot}.
        @return {TableSectionDividerEnum}
       */

    }, {
      key: "divider",
      get: function get() {
        return divider;
      }
    }, {
      key: "_attributePropertyMap",
      get: function get() {
        return commons.extend(_get(_getPrototypeOf(Table), "_attributePropertyMap", this), {
          labelledby: 'labelledBy'
        });
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(Table), "observedAttributes", this).concat(['variant', 'selectable', 'orderable', 'labelled', 'labelledby', 'multiple', 'lockable']);
      }
    }]);

    return Table;
  }(BaseComponent(HTMLTableElement));

  var CLASSNAME$1y = '_coral-Table-headerCell';
  /**
   @class Coral.Table.HeaderCell
   @classdesc A Table header cell component
   @htmltag coral-table-headercell
   @htmlbasetag th
   @extends {HTMLTableCellElement}
   @extends {BaseComponent}
   */

  var TableHeaderCell = /*#__PURE__*/function (_BaseComponent) {
    _inherits(TableHeaderCell, _BaseComponent);

    var _super = _createSuper(TableHeaderCell);

    /** @ignore */
    function TableHeaderCell() {
      var _this;

      _classCallCheck(this, TableHeaderCell);

      _this = _super.call(this); // Templates

      _this._elements = {
        content: _this.querySelector('coral-table-headercell-content') || document.createElement('coral-table-headercell-content')
      }; // Watch for content changes in sticky header cell

      _this._stickyCellObserver = new MutationObserver(_this._handleMutations.bind(_assertThisInitialized(_this)));

      _this._stickyCellObserver.observe(_this._elements.content, {
        childList: true,
        subtree: true
      });

      return _this;
    }
    /**
     The header cell's content.
      @type {TableHeaderCellContent}
     @contentzone
     */


    _createClass(TableHeaderCell, [{
      key: "_handleMutations",

      /** @private */
      value: function _handleMutations() {
        this.trigger('coral-table-headercell:_contentchanged');
      }
    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(TableHeaderCell.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1y); // Fetch or create the content zone element

        var content = this._elements.content;

        if (!content.parentNode) {
          // Move component children into the content
          while (this.firstChild) {
            content.appendChild(this.firstChild);
          }
        } // Assign the content zone so the insert function will be called


        this.content = content;
      }
      /**
       Triggered when the {@link TableHeaderCell} content changed.
        @typedef {CustomEvent} coral-table-headercell:_contentchanged
        @private
       */

    }, {
      key: "content",
      get: function get() {
        return this._getContentZone(this._elements.content);
      },
      set: function set(value) {
        this._setContentZone('content', value, {
          handle: 'content',
          tagName: 'coral-table-headercell-content',
          insert: function insert(content) {
            this.appendChild(content);
          }
        });
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-table-headercell-content': 'content'
        };
      }
    }]);

    return TableHeaderCell;
  }(BaseComponent(HTMLTableCellElement));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Table.HeaderCell.Content
   @classdesc The Table HeaderCell content
   @htmltag coral-table-headercell-content
   @return {HTMLElement}
   */
  var TableHeaderCellContent = (function () {
    return document.createElement('coral-table-headercell-content');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons.extend(strings, {
    'coral-component-table': translations$m
  }); // Expose component on the Coral namespace

  commons._define('coral-table-column', TableColumn, {
    extends: 'col'
  });

  commons._define('coral-table-cell', TableCell, {
    extends: 'td'
  });

  commons._define('coral-table-headercell', TableHeaderCell, {
    extends: 'th'
  });

  commons._define('coral-table-row', TableRow, {
    extends: 'tr'
  });

  commons._define('coral-table-head', TableHead, {
    extends: 'thead'
  });

  commons._define('coral-table-body', TableBody, {
    extends: 'tbody'
  });

  commons._define('coral-table-foot', TableFoot, {
    extends: 'tfoot'
  });

  commons._define('coral-table', Table, {
    extends: 'table'
  });

  Table.Column = TableColumn;
  Table.Cell = TableCell;
  Table.HeaderCell = TableHeaderCell;
  Table.HeaderCell.Content = TableHeaderCellContent;
  Table.Row = TableRow;
  Table.Head = TableHead;
  Table.Body = TableBody;
  Table.Foot = TableFoot;

  var template$Y = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["icon"] = document.createElement("coral-icon");
    el0.setAttribute("handle", "icon");
    el0.setAttribute("size", "XS");
    el0.className += " _coral-Tabs-item-icon";
    el0.setAttribute("alt", "");
    frag.appendChild(el0);
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    return frag;
  };

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   Gets the target panel of the item.

   @private
   @param {HTMLElement|String} [targetValue]
   A specific target value to use.

   @returns {?HTMLElement}
   */
  function getTarget$1(targetValue) {
    if (targetValue instanceof Node) {
      // Just return the provided Node
      return targetValue;
    } // Dynamically get the target node based on target


    var newTarget = null;

    if (typeof targetValue === 'string' && targetValue.trim() !== '') {
      newTarget = document.querySelector(targetValue);
    }

    return newTarget;
  }

  var CLASSNAME$1z = '_coral-Tabs-item';
  /**
   @class Coral.Tab
   @classdesc A Tab component
   @htmltag coral-tab
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var Tab = /*#__PURE__*/function (_BaseLabellable) {
    _inherits(Tab, _BaseLabellable);

    var _super = _createSuper(Tab);

    /** @ignore */
    function Tab() {
      var _thisSuper, _this;

      _classCallCheck(this, Tab);

      _this = _super.call(this); // Templates

      _this._elements = {
        label: _this.querySelector('coral-tab-label') || document.createElement('coral-tab-label'),
        invalidIcon: _this.querySelector('._coral-Tabs-itemInvalidIcon') || _this._createInvalidIcon()
      };
      template$Y.call(_this._elements); // Listen for mutations

      _this._observer = new MutationObserver(function () {
        // Change icon size if the label is empty
        var icon = _this._elements.icon;

        if (icon) {
          icon.size = _this._elements.label.textContent.trim().length ? Icon.size.EXTRA_SMALL : Icon.size.SMALL;
        }

        _get((_thisSuper = _assertThisInitialized(_this), _getPrototypeOf(Tab.prototype)), "_toggleIconAriaHidden", _thisSuper).call(_thisSuper);

        _this.trigger('coral-tab:_sizechanged');
      }); // Watch for changes to the label element

      _this._observer.observe(_this._elements.label, {
        childList: true,
        characterData: true,
        subtree: true
      });

      return _this;
    }
    /**
     The label of the tab.
      @type {TabLabel}
     @contentzone
     */


    _createClass(Tab, [{
      key: "_toggleEllipsis",
      value: function _toggleEllipsis() {
        var _this2 = this;

        requestAnimationFrame(function () {
          _this2.classList.toggle('is-overflowing', _this2._elements.label.clientWidth > _this2.clientWidth);
        });
      }
      /**
       Selects the target item
        @ignore
       */

    }, {
      key: "_selectTarget",
      value: function _selectTarget() {
        var realTarget = getTarget$1(this.target); // if the target was define at the tab level, it has precedence over everything

        if (realTarget) {
          realTarget.setAttribute('selected', '');
        } // otherwise, we use the target defined at the tablist level
        else {
            var tabList = this.parentNode;

            if (tabList && tabList.target) {
              realTarget = getTarget$1(tabList.target);

              if (realTarget) {
                // we get the position of this tab inside the tablist
                var currentIndex = tabList.items.getAll().indexOf(this); // we select the item with the same index

                var targetItem = (realTarget.items ? realTarget.items.getAll() : realTarget.children)[currentIndex]; // we select the item if it exists

                if (targetItem) {
                  targetItem.setAttribute('selected', '');
                }
              }
            }
          }
      }
    }, {
      key: "_createInvalidIcon",
      value: function _createInvalidIcon() {
        var iconElement = document.createElement('coral-icon');
        iconElement.icon = 'alert';
        iconElement.size = Icon.size.EXTRA_SMALL;
        iconElement.setAttribute('aria-hidden', 'true');
        iconElement.classList.add('_coral-Tabs-itemInvalidIcon');

        if (!this._invalid) {
          iconElement.setAttribute('hidden', 'true');
        }

        return iconElement;
      }
    }, {
      key: "connectedCallback",

      /** @ignore */
      value: function connectedCallback() {
        _get(_getPrototypeOf(Tab.prototype), "connectedCallback", this).call(this); // Query the tab target once the tab item is inserted in the DOM


        if (this.selected) {
          this._selectTarget();
        }
      }
      /** @ignore */

    }, {
      key: "render",
      value: function render() {
        _get(_getPrototypeOf(Tab.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1z); // adds the role to support accessibility

        this.setAttribute('role', 'tab'); // Generate a unique ID for the tab panel if one isn't already present
        // This will be used for accessibility purposes

        this.setAttribute('id', this.id || commons.getUID()); // Create a fragment

        var frag = document.createDocumentFragment(); // Render the main template

        if (this.icon) {
          frag.appendChild(this._elements.icon);
        }

        if (this._elements.invalidIcon) {
          frag.append(this._elements.invalidIcon);
        }

        var label = this._elements.label; // Remove it so we can process children

        if (label.parentNode) {
          label.parentNode.removeChild(label);
        }

        while (this.firstChild) {
          var child = this.firstChild;

          if (child.nodeType === Node.TEXT_NODE || child.nodeType === Node.ELEMENT_NODE && child.getAttribute('handle') !== 'icon') {
            // Add non-template elements to the label
            label.appendChild(child);
          } else {
            this.removeChild(child);
          }
        } // Add the frag to the component


        this.appendChild(frag); // Assign the content zones, moving them into place in the process

        this.label = label;
      }
    }, {
      key: "label",
      get: function get() {
        return this._getContentZone(this._elements.label);
      },
      set: function set(value) {
        this._setContentZone('label', value, {
          handle: 'label',
          tagName: 'coral-tab-label',
          insert: function insert(label) {
            label.classList.add("".concat(CLASSNAME$1z, "Label"));
            this.appendChild(label);

            this._toggleEllipsis();
          }
        });
      }
      /**
       Specifies the name of the icon used inside the Tab. See {@link Icon} for valid icon names.
        @type {String}
       @default ""
       @htmlattribute icon
       */

    }, {
      key: "icon",
      get: function get() {
        var iconElement = this._elements.icon;
        return iconElement ? iconElement.icon : '';
      },
      set: function set(value) {
        var iconElement = this._elements.icon;
        iconElement.icon = value; // removes the icon element from the DOM.

        if (this.icon === '') {
          iconElement.remove();
          this.trigger('coral-tab:_sizechanged');
        } // adds the icon back since it was blown away by textContent
        else if (!iconElement.parentElement) {
            // Change icon size if the label is empty
            if (!this._elements.label.textContent.trim().length) {
              iconElement.size = Icon.size.SMALL;
            }

            _get(_getPrototypeOf(Tab.prototype), "_toggleIconAriaHidden", this).call(this);

            this.insertBefore(iconElement, this.firstChild);
            this.trigger('coral-tab:_sizechanged');
          }
      }
      /**
       Whether the current Tab is invalid.
        @type {Boolean}
       @default false
       @htmlattribute invalid
       @htmlattributereflected
       */

    }, {
      key: "invalid",
      get: function get() {
        return this._invalid || false;
      },
      set: function set(value) {
        this._invalid = transform.booleanAttr(value);

        this._reflectAttribute('invalid', this._invalid);

        this.classList.toggle('is-invalid', this._invalid);
        this.setAttribute('aria-invalid', this._invalid);

        if (this._invalid) {
          this._elements.invalidIcon.removeAttribute('hidden');
        } else {
          this._elements.invalidIcon.setAttribute('hidden', 'true');
        }
      }
      /**
       Whether this Tab is disabled. When set to true, this will prevent every user interacting with the Tab. If
       disabled is set to true for a selected Tab it will be deselected.
        @type {Boolean}
       @default false
       @htmlattribute disabled
       @htmlattributereflected
       */

    }, {
      key: "disabled",
      get: function get() {
        return this._disabled || false;
      },
      set: function set(value) {
        this._disabled = transform.booleanAttr(value);

        this._reflectAttribute('disabled', this._disabled);

        this.classList.toggle('is-disabled', this._disabled);
        this[this._disabled ? 'setAttribute' : 'removeAttribute']('aria-disabled', this._disabled);

        if (this._disabled && this.selected) {
          this.selected = false;
        }

        if (!this._disabled && !this.selected) {
          // We inform the parent to verify if this item should be selected because it's the only one left
          this.trigger('coral-tab:_validateselection');
        }
      }
      /**
       Whether the tab is selected.
       @type {Boolean}
       @default false
       @htmlattribute selected
       @htmlattributereflected
       */

    }, {
      key: "selected",
      get: function get() {
        return this._selected || false;
      },
      set: function set(value) {
        var _selected = transform.booleanAttr(value);

        if (this._selected === _selected) {
          return;
        }

        if (!_selected || _selected && !this.disabled) {
          this._selected = _selected;

          this._reflectAttribute('selected', this.disabled ? false : this._selected);

          this.classList.toggle('is-selected', this._selected);
          this.setAttribute('tabindex', this._selected ? '0' : '-1');
          this.setAttribute('aria-selected', this._selected); // in case the tab is selected, we need to communicate it to the panels.

          if (this._selected) {
            this._selectTarget();
          }

          this.trigger('coral-tab:_selectedchanged');
        }
      }
      /**
       The target element that will be selected when this Tab is selected. It accepts a CSS selector or a DOM element.
       If a CSS Selector is provided, the first matching element will be used.
        @type {?HTMLElement|String}
       @default null
       @htmlattribute target
       */

    }, {
      key: "target",
      get: function get() {
        return typeof this._target === 'string' ? this._target : this._target || null;
      },
      set: function set(value) {
        if (value === null || typeof value === 'string' || value instanceof Node) {
          this._target = value;
          var realTarget = getTarget$1(this.target); // we add proper accessibility if available

          if (realTarget) {
            // creates a 2 way binding for accessibility
            this.setAttribute('aria-controls', realTarget.id);
            realTarget.setAttribute('aria-labelledby', this.id); // adds role to panel to support accessibility

            realTarget.setAttribute('role', 'tabpanel');
          }
        }
      }
      /**
       Inherited from {@link BaseComponent#trackingElement}.
       */

    }, {
      key: "trackingElement",
      get: function get() {
        return typeof this._trackingElement === 'undefined' ? // keep spaces to only 1 max and trim. this mimics native html behaviors
        (this.label || this).textContent.replace(/\s{2,}/g, ' ').trim() : this._trackingElement;
      },
      set: function set(value) {
        _set(_getPrototypeOf(Tab.prototype), "trackingElement", value, this, true);
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-tab-label': 'label'
        };
      }
      /** @ignore */

    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(Tab), "observedAttributes", this).concat(['selected', 'disabled', 'icon', 'invalid', 'target']);
      }
    }]);

    return Tab;
  }(BaseLabellable(BaseComponent(HTMLElement)));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Tab.Label
   @classdesc Tab's label component
   @htmltag coral-tab-label
   @return {HTMLElement}
   */
  var TabLabel = (function () {
    return document.createElement('coral-tab-label');
  });

  var template$Z = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["line"] = document.createElement("div");
    el0.setAttribute("handle", "line");
    el0.setAttribute("hidden", "");
    el0.className += " _coral-Tabs-selectionIndicator";
    frag.appendChild(el0);
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    return frag;
  };

  /**
   Enumeration for {@link TabList} sizes.

   @typedef {Object} TabListSizeEnum

   @property {String} SMALL
   A small-sized tablist.
   @property {String} MEDIUM
   A medium-sized tablist. This is the default.
   @property {String} LARGE
   A large-sized tablist.
   */

  var size$8 = {
    SMALL: 'S',
    MEDIUM: 'M',
    LARGE: 'L'
  };
  /**
   Enumeration for {@link TabList} orientations.

   @typedef {Object} TabListOrientationEnum

   @property {String} HORIZONTAL
   Horizontal TabList, this is the default value.
   @property {String} VERTICAL
   Vertical TabList.
   */

  var orientation$3 = {
    HORIZONTAL: 'horizontal',
    VERTICAL: 'vertical'
  }; // the tablist's base classname

  var CLASSNAME$1A = '_coral-Tabs';
  /**
   @class Coral.TabList
   @classdesc A TabList component holds a collection of tabs.
   @htmltag coral-tablist
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var TabList = /*#__PURE__*/function (_BaseComponent) {
    _inherits(TabList, _BaseComponent);

    var _super = _createSuper(TabList);

    /** @ignore */
    function TabList() {
      var _this;

      _classCallCheck(this, TabList);

      _this = _super.call(this); // Templates

      _this._elements = {};
      template$Z.call(_this._elements); // Attach events

      _this._delegateEvents({
        'click > coral-tab': '_onTabClick',
        'key:home > coral-tab': '_onHomeKey',
        'key:end > coral-tab': '_onEndKey',
        'key:pagedown > coral-tab': '_selectNextItem',
        'key:right > coral-tab': '_selectNextItem',
        'key:down > coral-tab': '_selectNextItem',
        'key:pageup > coral-tab': '_selectPreviousItem',
        'key:left > coral-tab': '_selectPreviousItem',
        'key:up > coral-tab': '_selectPreviousItem',
        'global:coral-commons:_webfontactive': '_setLine',
        // private
        'coral-tab:_selectedchanged': '_onItemSelectedChanged',
        'coral-tab:_validateselection': '_onValidateSelection',
        'coral-tab:_sizechanged': '_setLine'
      }); // Used for eventing


      _this._oldSelection = null; // Debounce timer

      _this._timeout = null; // Debounce wait in milliseconds

      _this._wait = 50;
      _this._setLine = _this._setLine.bind(_assertThisInitialized(_this)); // Init the collection mutation observer

      _this.items._startHandlingItems(true);

      return _this;
    }
    /**
     The Collection Interface that allows interacting with the items that the component contains.
      @type {SelectableCollection}
     @readonly
     */


    _createClass(TabList, [{
      key: "_onItemAdded",

      /** @private */
      value: function _onItemAdded(item) {
        if (!this.selectedItem) {
          item.setAttribute('selected', '');
        } else {
          this._validateSelection(item);
        }
      }
      /** @private */

    }, {
      key: "_onItemRemoved",
      value: function _onItemRemoved() {
        if (!this.selectedItem) {
          this._selectFirstItem();
        }
      }
      /** @private */

    }, {
      key: "_onTabClick",
      value: function _onTabClick(event) {
        event.preventDefault();
        var item = event.matchedTarget;

        this._toggleItemSelectionAndFocus(item);

        this._trackEvent('click', 'coral-tab', event, item);
      }
      /** @private */

    }, {
      key: "_onHomeKey",
      value: function _onHomeKey(event) {
        event.preventDefault();

        var item = this.items._getFirstSelectable();

        this._toggleItemSelectionAndFocus(item);
      }
      /** @private */

    }, {
      key: "_onEndKey",
      value: function _onEndKey(event) {
        event.preventDefault();

        var item = this.items._getLastSelectable();

        this._toggleItemSelectionAndFocus(item);
      }
      /** @private */

    }, {
      key: "_selectNextItem",
      value: function _selectNextItem(event) {
        event.preventDefault();
        var item = this.selectedItem;

        this._toggleItemSelectionAndFocus(this.items._getNextSelectable(item));
      }
      /** @private */

    }, {
      key: "_selectPreviousItem",
      value: function _selectPreviousItem(event) {
        event.preventDefault();
        var item = this.selectedItem;

        this._toggleItemSelectionAndFocus(this.items._getPreviousSelectable(item));
      }
      /** @private */

    }, {
      key: "_toggleItemSelectionAndFocus",
      value: function _toggleItemSelectionAndFocus(item) {
        if (item && !item.hasAttribute('selected')) {
          item.setAttribute('selected', '');
          item.focus();
        }
      }
      /** @private */

    }, {
      key: "_onItemSelectedChanged",
      value: function _onItemSelectedChanged(event) {
        event.stopImmediatePropagation();

        this._validateSelection(event.target);
      }
      /** @private */

    }, {
      key: "_onValidateSelection",
      value: function _onValidateSelection(event) {
        event.stopImmediatePropagation();

        this._validateSelection();
      }
      /** @private */

    }, {
      key: "_selectFirstItem",
      value: function _selectFirstItem() {
        var item = this.items._getFirstSelectable();

        if (item) {
          item.setAttribute('selected', '');
        }
      }
      /** @private */

    }, {
      key: "_validateSelection",
      value: function _validateSelection(item) {
        var _this2 = this;

        var selectedItems = this.items._getAllSelected();

        if (item) {
          // Deselected item
          if (!item.hasAttribute('selected') && !selectedItems.length) {
            var siblingItem = this.items._getNextSelectable(item); // Next selectable item is forced to be selected if selection is cleared


            if (item !== siblingItem) {
              siblingItem.setAttribute('selected', '');
            }
          } // Selected item
          else if (item.hasAttribute('selected') && selectedItems.length > 1) {
              selectedItems.forEach(function (selectedItem) {
                if (selectedItem !== item) {
                  // Don't trigger change events
                  _this2._preventTriggeringEvents = true;
                  selectedItem.removeAttribute('selected');
                }
              }); // We can trigger change events again

              this._preventTriggeringEvents = false;
            }
        } else if (selectedItems.length > 1) {
          // If multiple items are selected, the last one wins
          item = selectedItems[selectedItems.length - 1];
          selectedItems.forEach(function (selectedItem) {
            if (selectedItem !== item) {
              // Don't trigger change events
              _this2._preventTriggeringEvents = true;
              selectedItem.removeAttribute('selected');
            }
          }); // We can trigger change events again

          this._preventTriggeringEvents = false;
        } // First selectable item is forced to be selected if no selection at all
        else if (!selectedItems.length) {
            this._selectFirstItem();
          }

        this._setLine();

        this._triggerChangeEvent();
      }
    }, {
      key: "_setLine",
      value: function _setLine() {
        var _this3 = this;

        !(this._setLineInQueue === true) && window.requestAnimationFrame(function () {
          delete _this3._setLineInQueue;
          var selectedItem = _this3.selectedItem; // Position line under the selected item

          if (selectedItem) {
            if (_this3.orientation === orientation$3.HORIZONTAL) {
              var padding = window.parseInt(window.getComputedStyle(selectedItem).paddingLeft);
              var left = selectedItem.offsetLeft + padding;
              var width = selectedItem.clientWidth - padding * 2; // Orientation changed

              if (_this3._previousOrientation !== _this3.orientation) {
                _this3._elements.line.style.height = '';
              }

              _this3._elements.line.style.width = "".concat(width, "px");
              _this3._elements.line.style.transform = "translate(".concat(left, "px, 0)");
            } else if (_this3.orientation === orientation$3.VERTICAL) {
              var top = selectedItem.offsetTop;
              var height = selectedItem.clientHeight; // Orientation changed

              if (_this3._previousOrientation !== _this3.orientation) {
                _this3._elements.line.style.width = '';
              }

              _this3._elements.line.style.height = "".concat(height, "px");
              _this3._elements.line.style.transform = "translate(0, ".concat(top, "px)");
            }

            _this3._elements.line.hidden = false;
          } else {
            // Hide line if no selected item
            _this3._elements.line.hidden = true;
          }

          _this3._previousOrientation = _this3.orientation;
        });
        this._setLineInQueue = true;
      }
      /** @private */

    }, {
      key: "_triggerChangeEvent",
      value: function _triggerChangeEvent() {
        var selectedItem = this.selectedItem;
        var oldSelection = this._oldSelection;

        if (!this._preventTriggeringEvents && selectedItem !== oldSelection) {
          this.trigger('coral-tablist:change', {
            oldSelection: oldSelection,
            selection: selectedItem
          });
          this._oldSelection = selectedItem;
        }
      }
      /**
       Returns {@link TabList} sizes.
        @return {TabListSizeEnum}
       */

    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(TabList.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1A); // adds the role to support accessibility

        this.setAttribute('role', 'tablist');
        this.setAttribute('aria-multiselectable', 'false'); // Default reflected attributes

        if (!this._size) {
          this.size = size$8.MEDIUM;
        }

        if (!this._orientation) {
          this.orientation = orientation$3.HORIZONTAL;
        } // Support cloneNode


        var template = this.querySelector('._coral-Tabs-selectionIndicator');

        if (template) {
          template.remove();
        } // Insert tab line


        this.appendChild(this._elements.line); // Don't trigger events once connected

        this._preventTriggeringEvents = true;

        this._validateSelection();

        this._preventTriggeringEvents = false;
        this._oldSelection = this.selectedItem; // Display line once tabList is shown

        commons.addResizeListener(this, this._setLine);
      }
      /**
       Triggered when the {@link TabList} selected item has changed.
        @typedef {CustomEvent} coral-tablist:change
        @property {Tab} event.detail.oldSelection
       The prior selected item(s).
       @property {Tab} event.detail.selection
       The newly selected item(s).
       */

    }, {
      key: "items",
      get: function get() {
        // just init on demand
        if (!this._items) {
          this._items = new SelectableCollection({
            host: this,
            itemTagName: 'coral-tab',
            onItemAdded: this._onItemAdded,
            onItemRemoved: this._onItemRemoved
          });
        }

        return this._items;
      }
      /**
       The selected item in the TabList.
        @type {HTMLElement}
       @readonly
       */

    }, {
      key: "selectedItem",
      get: function get() {
        return this.items._getLastSelected();
      }
      /**
       The target component that will be linked to the TabList. It accepts either a CSS selector or a DOM element. If a
       CSS Selector is provided, the first matching element will be used. Items will be selected based on the index. If
       both target and {@link Coral.Tab#target} are set, the second will have higher priority.
        @type {?HTMLElement|String}
       @default null
       @htmlattribute target
       */

    }, {
      key: "target",
      get: function get() {
        return typeof this._target === 'string' ? this._target : this._target || null;
      },
      set: function set(value) {
        var _this4 = this;

        if (value === null || typeof value === 'string' || value instanceof Node) {
          this._target = value; // we do in case the target was not yet in the DOM

          !(this._setTargetInQueue === true) && window.requestAnimationFrame(function () {
            delete _this4._setTargetInQueue;
            var realTarget = getTarget$1(_this4._target); // we add proper accessibility if available

            if (realTarget) {
              var tabItems = _this4.items.getAll();

              var panelItems = realTarget.items ? realTarget.items.getAll() : realTarget.children; // we need to add a11y to all component, no matter if they can be perfectly paired

              var maxItems = Math.max(tabItems.length, panelItems.length);
              var tab;
              var panel;

              for (var i = 0; i < maxItems; i++) {
                tab = tabItems[i];
                panel = panelItems[i]; // if the tab has its own target, we assume the target component will handle its own accessibility. if the
                // target is an empty string we simply ignore it

                if (tab && tab.target && tab.target.trim() !== '') {
                  continue;
                }

                if (tab && panel) {
                  // sets the required ids
                  tab.id = tab.id || commons.getUID();
                  panel.id = panel.id || commons.getUID(); // creates a 2 way binding for accessibility

                  tab.setAttribute('aria-controls', panel.id);
                  panel.setAttribute('aria-labelledby', tab.id); // adds role to panel to support accessibility

                  panel.setAttribute('role', 'tabpanel');
                } else if (tab) {
                  // cleans the aria since there is no matching panel
                  tab.removeAttribute('aria-controls');
                } else {
                  // cleans the aria since there is no matching tab
                  panel.removeAttribute('aria-labelledby');
                }
              }
            }
          });
          this._setTargetInQueue = true;
        }
      }
      /**
       The size of the TabList. It accepts both lower and upper case sizes. Currently only "M" (the default) and "L"
       are available.
       See {@link TabListSizeEnum}.
        @type {String}
       @default TabListSizeEnum.MEDIUM
       @htmlattribute size
       @htmlattributereflected
       */

    }, {
      key: "size",
      get: function get() {
        return this._size || size$8.MEDIUM;
      },
      set: function set(value) {
        value = transform.string(value).toUpperCase();
        this._size = validate.enumeration(size$8)(value) && value || size$8.MEDIUM;

        this._reflectAttribute('size', this._size); // Remove all variant classes


        this.classList.remove("".concat(CLASSNAME$1A, "--compact"), "".concat(CLASSNAME$1A, "--quiet"));

        if (this._size === size$8.SMALL) {
          this.classList.add("".concat(CLASSNAME$1A, "--compact"));
        } else if (this._size === size$8.LARGE) {
          this.classList.add("".concat(CLASSNAME$1A, "--quiet"));
        }
      }
      /**
       Orientation of the TabList. See {@link TabListOrientationEnum}.
        @type {String}
       @default TabListOrientationEnum.HORIZONTAL
       @htmlattribute orientation
       @htmlattributereflected
       */

    }, {
      key: "orientation",
      get: function get() {
        return this._orientation || orientation$3.HORIZONTAL;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        var newValue = typeof this._orientation === 'undefined';
        this._orientation = validate.enumeration(orientation$3)(value) && value || orientation$3.HORIZONTAL;

        if (newValue) {
          this._previousOrientation = this._orientation;
        }

        this._reflectAttribute('orientation', this._orientation);

        this.classList.toggle("".concat(CLASSNAME$1A, "--vertical"), this._orientation === orientation$3.VERTICAL);
        this.classList.toggle("".concat(CLASSNAME$1A, "--horizontal"), this._orientation === orientation$3.HORIZONTAL);

        this._setLine();
      }
    }], [{
      key: "size",
      get: function get() {
        return size$8;
      }
      /**
       Returns {@link TabList} orientation options.
        @return {TabListOrientationEnum}
       */

    }, {
      key: "orientation",
      get: function get() {
        return orientation$3;
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(TabList), "observedAttributes", this).concat(['target', 'size', 'orientation']);
      }
    }]);

    return TabList;
  }(BaseComponent(HTMLElement));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons._define('coral-tab', Tab);

  commons._define('coral-tablist', TabList);

  Tab.Label = TabLabel;

  /**
   Enumeration for {@link TabView} orientations.

   @typedef {Object} TabViewOrientationEnum

   @property {String} HORIZONTAL
   Tabs on top of the panels. This is the default.
   @property {String} VERTICAL
   Tabs are rendered on the side and match the height of the panels.
   */

  var orientation$4 = {
    HORIZONTAL: 'horizontal',
    VERTICAL: 'vertical'
  }; // the tabview's base classname

  var CLASSNAME$1B = '_coral-TabView';
  /**
   @class Coral.TabView
   @classdesc A TabView component is the wrapping container used to create the typical Tabbed pattern.
   This is intended to be used with a {@link TabList} and {@link PanelStack}.
   @htmltag coral-tabview
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var TabView = /*#__PURE__*/function (_BaseComponent) {
    _inherits(TabView, _BaseComponent);

    var _super = _createSuper(TabView);

    /** @ignore */
    function TabView() {
      var _this;

      _classCallCheck(this, TabView);

      _this = _super.call(this); // Prepare templates

      _this._elements = {
        // Fetch or create the content zone elements
        tabList: _this.querySelector('coral-tablist') || document.createElement('coral-tablist'),
        panelStack: _this.querySelector('coral-panelstack') || document.createElement('coral-panelstack')
      }; // Events

      _this._delegateEvents({
        'coral-tablist:change > coral-tablist': '_onTabListChange',
        'coral-panelstack:change > coral-panelstack': '_onPanelStackChange',
        'coral-collection:add > coral-tablist': '_syncTabListAndPanelStack',
        'coral-collection:remove > coral-tablist': '_syncTabListAndPanelStack',
        'coral-collection:add > coral-panelstack': '_syncTabListAndPanelStack',
        'coral-collection:remove > coral-panelstack': '_syncTabListAndPanelStack'
      });

      return _this;
    }
    /**
     The TabView's orientation. See {@link TabViewOrientationEnum}.
      @type {String}
     @default TabViewOrientationEnum.HORIZONTAL
     @htmlattribute orientation
     @htmlattributereflected
     */


    _createClass(TabView, [{
      key: "_onTabListChange",

      /**
       Detects a change in the TabList and triggers an event.
        @private
       */
      value: function _onTabListChange(event) {
        this.trigger('coral-tabview:change', {
          selection: event.detail.selection,
          oldSelection: event.detail.oldSelection
        });
      }
      /** @private */

    }, {
      key: "_onPanelStackChange",
      value: function _onPanelStackChange(event) {
        // everytime the panelstack changes, we verify that the tablist and panelstack are up to date
        if (event.detail.selection) {
          var tabSelector = event.detail.selection.getAttribute('aria-labelledby');
          var tab = document.getElementById(tabSelector); // we select the tab if this was not the case

          if (tab) {
            if (!tab.hasAttribute('selected')) {
              tab.setAttribute('selected', '');
            } else {
              this._trackEvent('display', 'coral-tab', event, event.detail.selection);
            }
          }
        }
      }
      /** @private */

    }, {
      key: "_syncTabListAndPanelStack",
      value: function _syncTabListAndPanelStack() {
        this._elements.tabList.target = this._elements.tabList.target;
      }
    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(TabView.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1B); // Default reflected attributes

        if (!this._orientation) {
          this.orientation = this.orientation;
        } // Fetch or create the content zone elements


        var tabs = this._elements.tabList;
        var panels = this._elements.panelStack; // Bind the tablist and panel stack together, using the panel id

        panels.id = panels.id || commons.getUID();
        tabs.setAttribute('target', "#".concat(panels.id)); // Assign the content zones.

        this.panelStack = panels;
        this.tabList = tabs;
      }
      /**
       Triggered when the {@link TabView} selected tab panel item has changed.
        @typedef {CustomEvent} coral-tabview:change
        @property {Tab} event.detail.selection
       The new selected tab panel item.
       @param {Tab} event.detail.oldSelection
       The prior selected tab panel item.
       */

    }, {
      key: "orientation",
      get: function get() {
        return this._elements.tabList.getAttribute('orientation') || orientation$4.HORIZONTAL;
      },
      set: function set(value) {
        // We rely on the tablist orientation enum so don't need to double check enums
        this._elements.tabList.setAttribute('orientation', value);

        this._reflectAttribute('orientation', this.orientation);

        this.classList[this.orientation === orientation$4.VERTICAL ? 'add' : 'remove']("".concat(CLASSNAME$1B, "--vertical"));
      }
      /**
       The TabList which handles all the tabs.
        @type {TabList}
       @contentzone
       */

    }, {
      key: "tabList",
      get: function get() {
        return this._getContentZone(this._elements.tabList);
      },
      set: function set(value) {
        // Support nested coral-tablist
        if (value instanceof HTMLElement && !value.parentNode || value.parentNode === this) {
          this._setContentZone('tabList', value, {
            handle: 'tabList',
            tagName: 'coral-tablist',
            insert: function insert(tabs) {
              tabs.setAttribute('tracking', 'off');
              this.insertBefore(tabs, this._elements.panelStack || null);
            }
          });
        }
      }
      /**
       The PanelStack which contains all the panels.
        @type {PanelStack}
       @contentzone
       */

    }, {
      key: "panelStack",
      get: function get() {
        return this._getContentZone(this._elements.panelStack);
      },
      set: function set(value) {
        // Support nested coral-panelstack
        if (value instanceof HTMLElement && !value.parentNode || value.parentNode === this) {
          this._setContentZone('panelStack', value, {
            handle: 'panelStack',
            tagName: 'coral-panelstack',
            insert: function insert(panels) {
              this.appendChild(panels);
            }
          });
        }
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-tablist': 'tabList',
          'coral-panelstack': 'panelStack'
        };
      }
      /**
       Returns {@link TabView} orientation options.
        @return {TabViewOrientationEnum}
       */

    }], [{
      key: "orientation",
      get: function get() {
        return orientation$4;
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(TabView), "observedAttributes", this).concat(['orientation']);
      }
    }]);

    return TabView;
  }(BaseComponent(HTMLElement));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons._define('coral-tabview', TabView);

  var template$_ = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["body"] = document.createElement("div");
    el0.className += " _coral-Toast-body";
    el0.setAttribute("handle", "body");
    frag.appendChild(el0);
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    var el2 = this["buttons"] = document.createElement("div");
    el2.className += " _coral-Toast-buttons";
    el2.setAttribute("handle", "buttons");
    var el3 = document.createTextNode("\n  ");
    el2.appendChild(el3);
    var el4 = document.createElement("button", "coral-button");
    el4.setAttribute("tracking", "off");
    el4.setAttribute("is", "coral-button");
    el4.setAttribute("type", "button");
    el4.setAttribute("variant", "_custom");
    el4.className += " _coral-ClearButton _coral-ClearButton--medium _coral-ClearButton--overBackground";
    el4.setAttribute("coral-close", "");
    var el5 = document.createTextNode("\n    ");
    el4.appendChild(el5);
    var el6 = document.createElement("coral-icon");
    el6.setAttribute("icon", "spectrum-css-icon-CrossMedium");
    el6.className += " _coral-UIIcon-CrossMedium";
    el4.appendChild(el6);
    var el7 = document.createTextNode("\n    ");
    el4.appendChild(el7);
    var el8 = this["buttonLabel"] = document.createElement("coral-button-label");
    el8.setAttribute("handle", "buttonLabel");
    el4.appendChild(el8);
    var el9 = document.createTextNode("\n  ");
    el4.appendChild(el9);
    el2.appendChild(el4);
    var el10 = document.createTextNode("\n");
    el2.appendChild(el10);
    frag.appendChild(el2);
    var el11 = document.createTextNode("\n");
    frag.appendChild(el11);
    return frag;
  };

  /**
   Enumeration for {@link Toast} variants.

   @typedef {Object} ToastVariantEnum

   @property {String} DEFAULT
   A neutral toast.
   @property {String} ERROR
   A toast to notify that an error has occurred or to warn the user of something important.
   @property {String} SUCCESS
   A toast to notify the user of a successful operation.
   @property {String} INFO
   A toast to notify the user of non-critical information.
   */

  var variant$n = {
    DEFAULT: 'default',
    ERROR: 'error',
    SUCCESS: 'success',
    INFO: 'info'
  };
  /**
   Enumeration for {@link Toast} placement values.

   @typedef {Object} ToastPlacementEnum

   @property {String} LEFT
   A toast anchored to the bottom left of screen.
   @property {String} CENTER
   A toast anchored to the bottom center of screen.
   @property {String} RIGHT
   A toast anchored to the bottom right of screen.
   */

  var placement$3 = {
    LEFT: 'left',
    CENTER: 'center',
    RIGHT: 'right'
  };
  var CLASSNAME$1C = '_coral-Toast'; // An array of all possible variant

  var ALL_VARIANT_CLASSES$d = [];

  for (var variantValue$b in variant$n) {
    ALL_VARIANT_CLASSES$d.push("".concat(CLASSNAME$1C, "--").concat(variant$n[variantValue$b]));
  }

  var PRIORITY_QUEUE = [];

  var queue$1 = function queue(el) {
    var priority;
    var type = transform.string(el.getAttribute('variant')).toLowerCase();

    if (type === variant$n.ERROR) {
      priority = el.action ? 1 : 2;
    } else if (type === variant$n.SUCCESS) {
      priority = el.action ? 3 : 6;
    } else if (type === variant$n.INFO) {
      priority = el.action ? 4 : 7;
    } else {
      priority = el.action ? 5 : 8;
    }

    PRIORITY_QUEUE.push({
      el: el,
      priority: priority
    });
  };

  var unqueue = function unqueue() {
    var next = null;
    [1, 2, 3, 4, 5, 6, 7, 8].some(function (priority) {
      return PRIORITY_QUEUE.some(function (item, index) {
        if (item.priority === priority) {
          next = {
            el: item.el,
            index: index
          };
          return true;
        }
      });
    });

    if (next !== null) {
      PRIORITY_QUEUE.splice(next.index, 1);
      next.el.open = true;
    }
  }; // Used to map icon with variant


  var capitalize$4 = function capitalize(s) {
    return s.charAt(0).toUpperCase() + s.slice(1);
  }; // Restriction filter for action button


  var isButton = function isButton(node) {
    return node.nodeName === 'BUTTON' && node.getAttribute('is') === 'coral-button' || node.nodeName === 'A' && node.getAttribute('is') === 'coral-anchorbutton';
  };
  /**
   @class Coral.Toast
   @classdesc Toasts display brief temporary notifications.
   They are noticeable but do not disrupt the user experience and do not require an action to be taken.
   @htmltag coral-toast
   @extends {HTMLElement}
   @extends {BaseComponent}
   @extends {BaseOverlay}
   */


  var Toast = /*#__PURE__*/function (_BaseOverlay) {
    _inherits(Toast, _BaseOverlay);

    var _super = _createSuper(Toast);

    /** @ignore */
    function Toast() {
      var _this;

      _classCallCheck(this, Toast);

      _this = _super.call(this); // Debounce wait time in milliseconds

      _this._wait = 50; // Override defaults from Overlay

      _this._overlayAnimationTime = _this.constructor.FADETIME;
      _this._focusOnShow = _this.constructor.focusOnShow.OFF;
      _this._returnFocus = _this.constructor.returnFocus.ON; // Prepare templates

      _this._elements = {
        // Fetch or create the content zone element
        content: _this.querySelector('coral-toast-content') || document.createElement('coral-toast-content')
      };
      template$_.call(_this._elements);

      _this._delegateEvents({
        'global:resize': '_debounceLayout',
        'global:key:escape': '_onEscape',
        'click [coral-close]': '_onCloseClick',
        'coral-overlay:close': '_onClose'
      }); // Layout any time the DOM changes


      _this._observer = new MutationObserver(function () {
        _this._debounceLayout();
      }); // Watch for changes

      _this._observer.observe(_assertThisInitialized(_this), {
        childList: true,
        subtree: true
      });

      return _this;
    }
    /**
     Whether the Toast will be dismissed automatically after a certain period. The minimum and default value is 5 seconds.
     The dismissible behavior can be disabled by setting the value to <code>0</code>.
     If an actionable toast is set to auto-dismiss, make sure that the action is still accessible elsewhere in the application.
      @type {?Number}
     @default 5000
     @htmlattribute autodismiss
     */


    _createClass(Toast, [{
      key: "_renderVariantIcon",
      value: function _renderVariantIcon() {
        if (this._elements.icon) {
          this._elements.icon.remove();
        }

        var variantValue = this.variant; // Default variant has no icon

        if (variantValue === variant$n.DEFAULT) {
          return;
        } // Inject the SVG icon


        var iconName = variantValue === variant$n.ERROR ? 'Alert' : capitalize$4(variantValue);

        var icon = Icon._renderSVG("spectrum-css-icon-".concat(iconName, "Medium"), ['_coral-Toast-typeIcon', "_coral-UIIcon-".concat(iconName, "Medium")]);

        this.insertAdjacentHTML('afterbegin', icon);
        this._elements.icon = this.querySelector('._coral-Toast-typeIcon');
      }
    }, {
      key: "_moveToDocumentBody",
      value: function _moveToDocumentBody() {
        // Not in the DOM
        if (!document.body.contains(this)) {
          document.body.appendChild(this);
        } // In the DOM but not a direct child of body
        else if (this.parentNode !== document.body) {
            this._ignoreConnectedCallback = true;
            this._repositioned = true;
            document.body.appendChild(this);
            this._ignoreConnectedCallback = false;
          }
      }
    }, {
      key: "_debounceLayout",
      value: function _debounceLayout() {
        var _this2 = this;

        // Debounce
        if (this._layoutTimeout !== null) {
          clearTimeout(this._layoutTimeout);
        }

        this._layoutTimeout = window.setTimeout(function () {
          _this2._layoutTimeout = null;

          _this2._position();
        }, this._wait);
      }
    }, {
      key: "_position",
      value: function _position() {
        var _this3 = this;

        if (this.open) {
          requestAnimationFrame(function () {
            if (_this3.placement === placement$3.CENTER) {
              _this3.style.left = "".concat(document.body.clientWidth / 2 - _this3.clientWidth / 2, "px");
              _this3.style.right = '';
            } else if (_this3.placement === placement$3.LEFT) {
              _this3.style.left = 0;
              _this3.style.right = '';
            } else if (_this3.placement === placement$3.RIGHT) {
              _this3.style.left = '';
              _this3.style.right = 0;
            }
          });
        }
      }
    }, {
      key: "_onEscape",
      value: function _onEscape(event) {
        if (this.open && this.classList.contains('is-open') && this._isTopOverlay()) {
          event.stopPropagation();
          this.open = false;
        }
      }
    }, {
      key: "_onCloseClick",
      value: function _onCloseClick(event) {
        var dismissTarget = event.matchedTarget;
        var dismissValue = dismissTarget.getAttribute('coral-close');

        if (!dismissValue || this.matches(dismissValue)) {
          this.open = false;
          event.stopPropagation();
        }
      }
    }, {
      key: "_onClose",
      value: function _onClose() {
        // Unmark it
        this._queued = false; // Continue emptying the queue

        unqueue();
      }
    }, {
      key: "connectedCallback",

      /** @ignore */
      value: function connectedCallback() {
        if (this._ignoreConnectedCallback) {
          return;
        }

        _get(_getPrototypeOf(Toast.prototype), "connectedCallback", this).call(this);
      }
      /** @ignore */

    }, {
      key: "render",
      value: function render() {
        _get(_getPrototypeOf(Toast.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1C); // Default reflected attributes

        if (!this._variant) {
          this.variant = variant$n.DEFAULT;
        } // Create a fragment


        var fragment = document.createDocumentFragment();
        var templateHandleNames = ['body', 'buttons']; // Render the template

        fragment.appendChild(this._elements.body);
        fragment.appendChild(this._elements.buttons);
        var content = this._elements.content;

        if (content.parentNode) {
          content.remove();
        }

        var action = this.action;

        if (action) {
          action.remove();
        }

        while (this.firstChild) {
          var child = this.firstChild;

          if (child.nodeType === Node.TEXT_NODE || child.nodeType === Node.ELEMENT_NODE && templateHandleNames.indexOf(child.getAttribute('handle')) === -1) {
            // Add non-template elements to the content
            content.appendChild(child);
          } else {
            // Remove anything else
            this.removeChild(child);
          }
        } // Insert template


        this.appendChild(fragment); // If default variant, does nothing

        this._renderVariantIcon(); // Assign the content zones


        this.content = this._elements.content;
        this.action = action;
      }
      /** @ignore */

    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        var _this4 = this;

        if (this._ignoreConnectedCallback) {
          return;
        }

        _get(_getPrototypeOf(Toast.prototype), "disconnectedCallback", this).call(this);

        if (this._queued) {
          var el = null;
          PRIORITY_QUEUE.some(function (item, index) {
            if (item.el === _this4) {
              _this4._queued = false;
              el = index;
              return true;
            }
          });

          if (el !== null) {
            PRIORITY_QUEUE.splice(el, 1);
          }
        }
      }
    }, {
      key: "autoDismiss",
      get: function get() {
        return typeof this._autoDismiss === 'number' ? this._autoDismiss : 5000;
      },
      set: function set(value) {
        value = transform.number(value);

        if (value !== null) {
          value = Math.abs(value); // Value can't be set lower than 5secs. 0 is an exception.

          if (value !== 0 && value < 5000) {
            commons._log('warn', 'Coral.Toast: the value for autoDismiss has to be 5 seconds minimum.');

            value = 5000;
          }

          this._autoDismiss = value;
        }
      }
      /**
       The actionable item marked with <code>[coral-toast-action]</code>.
       Restricted to {@link Button} or {@link AnchorButton} elements.
       Actionable toasts should not have a button with a redundant action. For example âdismissâ would be redundant as all
       toasts already have a close button.
        @type {HTMLElement}
       @readonly
       */

    }, {
      key: "action",
      get: function get() {
        return this._elements.action || this.querySelector('[coral-toast-action]');
      },
      set: function set(el) {
        if (!el) {
          return;
        }

        if (isButton(el)) {
          this._elements.action = el;
          el.setAttribute('coral-toast-action', '');
          el.setAttribute('variant', Button.variant._CUSTOM);
          el.classList.add('_coral-Button', '_coral-Button--overBackground', '_coral-Button--quiet');

          this._elements.body.appendChild(el);
        } else {
          commons._log('warn', 'Coral.Toast: provided action is not a Coral.Button or Coral.AnchorButton.');
        }
      }
      /**
       Inherited from {@link BaseOverlay#open}.
       */

    }, {
      key: "open",
      get: function get() {
        return _get(_getPrototypeOf(Toast.prototype), "open", this);
      },
      set: function set(value) {
        var _this5 = this;

        // Opening only if element is queued
        value = transform.booleanAttr(value);

        if (value && !this._queued) {
          this._open = value; // Mark it

          this._queued = true; // Clear timer

          if (this._dimissTimeout) {
            clearTimeout(this._dimissTimeout);
          } // Add it to the queue


          queue$1(this);
          requestAnimationFrame(function () {
            _this5._reflectAttribute('open', true); // If not child of document.body, we have to move it there


            _this5._moveToDocumentBody();

            requestAnimationFrame(function () {
              // Start emptying the queue
              if (document.querySelectorAll('coral-toast[open]').length === PRIORITY_QUEUE.length) {
                unqueue();
              }
            });
          });
          return;
        }

        _set(_getPrototypeOf(Toast.prototype), "open", value, this, true); // Ensure we're in the DOM


        if (this.open) {
          // Position the element
          this._position(); // Handles what to focus based on focusOnShow


          this._handleFocus(); // Use raf to wait for autoDismiss value to be set


          requestAnimationFrame(function () {
            // Only dismiss if value is different than 0
            if (_this5.autoDismiss !== 0) {
              _this5._dimissTimeout = window.setTimeout(function () {
                if (_this5.open && !_this5.contains(document.activeElement)) {
                  _this5.open = false;
                }
              }, _this5.autoDismiss);
            }
          });
        }
      }
      /**
       The Toast variant. See {@link ToastVariantEnum}.
        @type {String}
       @default ToastVariantEnum.DEFAULT
       @htmlattribute variant
       @htmlattributereflected
       */

    }, {
      key: "variant",
      get: function get() {
        return this._variant || variant$n.DEFAULT;
      },
      set: function set(value) {
        var _this$classList;

        value = transform.string(value).toLowerCase();
        this._variant = validate.enumeration(variant$n)(value) && value || variant$n.DEFAULT;

        this._reflectAttribute('variant', this._variant);

        this._renderVariantIcon(); // Remove all variant classes


        (_this$classList = this.classList).remove.apply(_this$classList, ALL_VARIANT_CLASSES$d); // Set new variant class


        this.classList.add("".concat(CLASSNAME$1C, "--").concat(this._variant)); // Set the role attribute to alert or status depending on
        // the variant so that the element turns into a live region

        this.setAttribute('role', this._variant);
      }
      /**
       The Toast content element.
        @type {ToastContent}
       @contentzone
       */

    }, {
      key: "content",
      get: function get() {
        return this._getContentZone(this._elements.content);
      },
      set: function set(value) {
        this._setContentZone('content', value, {
          handle: 'content',
          tagName: 'coral-toast-content',
          insert: function insert(content) {
            content.classList.add("".concat(CLASSNAME$1C, "-content")); // After the header

            this._elements.body.insertBefore(content, this._elements.body.firstChild);
          }
        });
      }
      /**
       The Toast placement. See {@link ToastPlacementEnum}.
        @type {String}
       @default ToastPlacementEnum.CENTER
       @htmlattribute placement
       */

    }, {
      key: "placement",
      get: function get() {
        return this._placement || placement$3.CENTER;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        this._placement = validate.enumeration(placement$3)(value) && value || placement$3.CENTER;

        this._debounceLayout();
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-toast-content': 'content'
        };
      }
    }], [{
      key: "_queue",
      get: function get() {
        return PRIORITY_QUEUE;
      }
      /**
       Returns {@link Toast} placement options.
        @return {ToastPlacementEnum}
       */

    }, {
      key: "placement",
      get: function get() {
        return placement$3;
      }
      /**
       Returns {@link Toast} variants.
        @return {ToastVariantEnum}
       */

    }, {
      key: "variant",
      get: function get() {
        return variant$n;
      }
    }, {
      key: "_attributePropertyMap",
      get: function get() {
        return commons.extend(_get(_getPrototypeOf(Toast), "_attributePropertyMap", this), {
          autodismiss: 'autoDismiss'
        });
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(Toast), "observedAttributes", this).concat(['variant', 'placement', 'autodismiss']);
      }
    }]);

    return Toast;
  }(BaseOverlay(BaseComponent(HTMLElement)));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Toast.Content
   @classdesc The Toast default content
   @htmltag coral-toast-content
   @return {HTMLElement}
   */
  var ToastContent = (function () {
    return document.createElement('coral-toast-content');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons._define('coral-toast', Toast);

  Toast.Content = ToastContent;

  var template$$ = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var data = data_0 = typeof data_0 === "undefined" ? {} : data_0;
    var el0 = this["header"] = document.createElement("div");
    el0.className += " _coral-TreeView-itemLink";
    el0.setAttribute("tabindex", "-1");
    el0.id = data_0["commons"]["getUID"]();
    el0.setAttribute("handle", "header");
    el0.setAttribute("role", "treeitem");
    var el1 = document.createTextNode("\n  ");
    el0.appendChild(el1);
    var el2 = this["selectedState"] = document.createElement("span");
    el2.className += " u-coral-screenReaderOnly";
    el2.setAttribute("handle", "selectedState");
    el2.setAttribute("role", "presentation");
    el2.id = data_0["commons"]["getUID"]();
    el0.appendChild(el2);
    var el3 = document.createTextNode("\n");
    el0.appendChild(el3);
    frag.appendChild(el0);
    var el4 = document.createTextNode("\n");
    frag.appendChild(el4);
    data = data_0;
    this.header.insertAdjacentHTML('afterbegin', data.Icon._renderSVG('spectrum-css-icon-ChevronRightMedium', ['_coral-TreeView-indicator', '_coral-UIIcon-ChevronRightMedium']));
    data_0 = data;
    var el6 = document.createTextNode("\n");
    frag.appendChild(el6);
    var el7 = this["subTreeContainer"] = document.createElement("div");
    el7.className += " _coral-TreeView";
    el7.setAttribute("handle", "subTreeContainer");
    el7.id = data_0["commons"]["getUID"]();
    el7.setAttribute("role", "group");
    frag.appendChild(el7);
    var el8 = document.createTextNode("\n");
    frag.appendChild(el8);
    return frag;
  };

  var CLASSNAME$1D = '_coral-TreeView-item';
  /**
   Enumeration for {@link TreeItem} variants.

   @typedef {Object} TreeItemVariantEnum

   @property {String} DRILLDOWN
   Default variant with icon to expand/collapse subtree.
   @property {String} LEAF
   Variant for leaf items. Icon to expand/collapse subtree is hidden.
   */

  var variant$o = {
    /* Default variant with icon to expand/collapse subtree. */
    DRILLDOWN: 'drilldown',

    /* Variant for leaf items. Icon to expand/collapse subtree is hidden. */
    LEAF: 'leaf'
  };
  var ALL_VARIANT_CLASSES$e = [];

  for (var variantValue$c in variant$o) {
    ALL_VARIANT_CLASSES$e.push("".concat(CLASSNAME$1D, "--").concat(variant$o[variantValue$c]));
  }

  var IS_TOUCH_DEVICE = 'ontouchstart' in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
  /**
   @class Coral.Tree.Item
   @classdesc A Tree item component
   @htmltag coral-tree-item
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var TreeItem = /*#__PURE__*/function (_BaseComponent) {
    _inherits(TreeItem, _BaseComponent);

    var _super = _createSuper(TreeItem);

    /** @ignore */
    function TreeItem() {
      var _this;

      _classCallCheck(this, TreeItem);

      _this = _super.call(this); // Prepare templates

      _this._elements = {
        // Create or fetch the content zones
        content: _this.querySelector('coral-tree-item-content') || document.createElement('coral-tree-item-content')
      };
      template$$.call(_this._elements, {
        Icon: Icon,
        commons: commons
      });

      if (!_this._elements.icon) {
        _this._elements.icon = _this._elements.header.querySelector('._coral-TreeView-indicator');
      } // Tells the collection to automatically detect the items and handle the events


      _this.items._startHandlingItems();

      return _this;
    }
    /**
     The parent tree. Returns <code>null</code> if item is the root.
      @type {HTMLElement}
     @readonly
     */


    _createClass(TreeItem, [{
      key: "_filterItem",

      /** @private */
      value: function _filterItem(item) {
        // Handle nesting check for parent tree item
        // Use parentNode for added items
        // Use _parent for removed items
        return item.parentNode && item.parentNode.parentNode === this || item._parent === this;
      }
      /** @private */

    }, {
      key: "_onItemAdded",
      value: function _onItemAdded(item) {
        item._parent = this;
        var header = this._elements.header;
        var subTreeContainer = this._elements.subTreeContainer;

        if (!header.hasAttribute('aria-owns')) {
          header.setAttribute('aria-owns', subTreeContainer.id);
        }
      }
      /** @private */

    }, {
      key: "_onItemRemoved",
      value: function _onItemRemoved(item) {
        item._parent = undefined; // If there are no items the subTreeContainer

        if (!this.items.length) {
          this._elements.header.removeAttribute('aria-owns');
        }
      }
      /**
       Handles the focus of the item.
        @ignore
       */

    }, {
      key: "focus",
      value: function focus() {
        this._elements.header.setAttribute('tabindex', '0');

        this._elements.header.focus();
      }
      /**
       Returns {@link TreeItem} variants.
        @return {TreeItemVariantEnum}
       */

    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(TreeItem.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1D);
        var header = this._elements.header;
        var subTreeContainer = this._elements.subTreeContainer;
        var content = this._elements.content;
        var selectedState = this._elements.selectedState; // a11ys

        content.id = content.id || commons.getUID();
        this.setAttribute('role', 'presentation');
        header.setAttribute('aria-labelledby', "".concat(content.id, " ").concat(selectedState.id));
        header.setAttribute('aria-selected', this.selected);
        subTreeContainer.setAttribute('aria-labelledby', content.id);
        selectedState.textContent = i18n.get(this.selected ? 'selected' : 'not selected');

        if (IS_TOUCH_DEVICE) {
          var icon = this._elements.icon || header.querySelector('._coral-TreeView-indicator');

          if (icon && !icon.id) {
            icon.id = commons.getUID();
          }

          icon.setAttribute('role', 'button');
          icon.setAttribute('tabindex', '-1');
          icon.setAttribute('aria-labelledby', icon.id + ' ' + content.id);
          icon.setAttribute('aria-label', i18n.get(this.expanded ? 'Collapse' : 'Expand'));
          icon.setAttribute('style', 'outline: none !important');
          icon.removeAttribute('aria-hidden');
          selectedState.setAttribute('role', 'button');
          selectedState.setAttribute('tabindex', '-1');
          selectedState.setAttribute('aria-labelledby', content.id + ' ' + selectedState.id);
          selectedState.setAttribute('aria-pressed', this.selected);
          selectedState.setAttribute('style', 'outline: none !important');
        } // Default reflected attributes


        if (!this._variant) {
          this.variant = variant$o.DRILLDOWN;
        }

        this.expanded = this.expanded; // Render the template and set element references

        var frag = document.createDocumentFragment();
        var templateHandleNames = ['header', 'icon', 'subTreeContainer'];
        var subTree = this.querySelector('._coral-TreeView');

        if (subTree) {
          var items = subTree.querySelectorAll('coral-tree-item');

          for (var i = 0; i < items.length; i++) {
            subTreeContainer.appendChild(items[i]);
          }
        } // Add templates into the frag


        frag.appendChild(header);
        frag.appendChild(subTreeContainer); // Assign the content zones, moving them into place in the process

        this.content = content; // Move any remaining elements into the content sub-component

        while (this.firstChild) {
          var child = this.firstChild;

          if (child.nodeName === 'CORAL-TREE-ITEM') {
            // Adding parent attribute to access the parent directly
            child._parent = this; // Add tree items to the sub tree container

            subTreeContainer.appendChild(child);
          } else if (child.nodeType === Node.TEXT_NODE || child.nodeType === Node.ELEMENT_NODE && templateHandleNames.indexOf(child.getAttribute('handle')) === -1) {
            // Add non-template elements to the content
            content.appendChild(child);
          } else {
            // Remove anything else element
            this.removeChild(child);
          }
        }

        if (this.variant === variant$o.DRILLDOWN && this.items.length && !header.hasAttribute('aria-owns')) {
          header.setAttribute('aria-owns', subTreeContainer.id);
        } // Lastly, add the fragment into the container


        this.appendChild(frag);
      }
      /**
       Triggered when {@link TreeItem#selected} changed.
        @typedef {CustomEvent} coral-tree-item:_selectedchanged
        @private
       */

      /**
       Triggered when {@link TreeItem#expanded} changed.
        @typedef {CustomEvent} coral-tree-item:_expandedchanged
        @private
       */

      /**
       Triggered when {@link TreeItem#hidden} changed.
        @typedef {CustomEvent} coral-tree-item:_hiddenchanged
        @private
       */

      /**
       Triggered when {@link TreeItem#disabled} changed.
        @typedef {CustomEvent} coral-tree-item:_disabledchanged
        @private
       */

    }, {
      key: "parent",
      get: function get() {
        return this._parent || null;
      }
      /**
       The content of this tree item.
        @type {TreeItemContent}
       @contentzone
       */

    }, {
      key: "content",
      get: function get() {
        return this._getContentZone(this._elements.content);
      },
      set: function set(value) {
        this._setContentZone('content', value, {
          handle: 'content',
          tagName: 'coral-tree-item-content',
          insert: function insert(content) {
            this._elements.header.appendChild(content);
          }
        });
      }
      /**
       The Collection Interface that allows interacting with the items that the component contains.
        @type {Collection}
       @readonly
       */

    }, {
      key: "items",
      get: function get() {
        // Construct the collection on first request
        if (!this._items) {
          this._items = new Collection$1({
            host: this,
            itemTagName: 'coral-tree-item',
            itemSelector: ':scope > coral-tree-item',
            container: this._elements.subTreeContainer,
            filter: this._filterItem.bind(this),
            onItemAdded: this._onItemAdded,
            onItemRemoved: this._onItemRemoved
          });
        }

        return this._items;
      }
      /**
       Whether the item is expanded. Expanded cannot be set to <code>true</code> if the item is disabled.
        @type {Boolean}
       @default false
       @htmlattribute expanded
       @htmlattributereflected
       */

    }, {
      key: "expanded",
      get: function get() {
        return this._expanded || false;
      },
      set: function set(value) {
        var _this2 = this;

        value = transform.booleanAttr(value);
        var triggerEvent = this.expanded !== value;
        this._expanded = value;

        this._reflectAttribute('expanded', this._expanded);

        var header = this._elements.header;
        var subTreeContainer = this._elements.subTreeContainer;
        this.classList.toggle('is-open', this._expanded);
        this.classList.toggle('is-collapsed', !this._expanded);

        if (this.variant !== variant$o.DRILLDOWN) {
          header.removeAttribute('aria-expanded');
          header.removeAttribute('aria-owns');
        } else if (this.items.length > 0) {
          header.setAttribute('aria-expanded', this._expanded);
          header.setAttribute('aria-owns', subTreeContainer.id);
        }

        if (this._expanded) {
          subTreeContainer.removeAttribute('aria-hidden');
        } else {
          subTreeContainer.setAttribute('aria-hidden', !this._expanded);
        }

        if (IS_TOUCH_DEVICE) {
          var icon = header.querySelector('._coral-TreeView-indicator');
          icon.setAttribute('aria-label', i18n.get(this._expanded ? 'Collapse' : 'Expand'));
        }

        this.trigger('coral-tree-item:_expandedchanged'); // Do animation in next frame to avoid a forced reflow

        window.requestAnimationFrame(function () {
          // Don't animate on initialization
          if (_this2._animate) {
            // Remove height as we want the drawer to naturally grow if content is added later
            commons.transitionEnd(subTreeContainer, function () {
              if (_this2.expanded) {
                subTreeContainer.style.height = '';
              } else {
                subTreeContainer.hidden = true;
              } // Trigger once the animation is over to inform coral-tree


              if (triggerEvent) {
                _this2.trigger('coral-tree-item:_afterexpandedchanged');
              }
            }); // Force height to enable transition

            if (!_this2.expanded) {
              subTreeContainer.style.height = "".concat(subTreeContainer.scrollHeight, "px");
            } else {
              subTreeContainer.hidden = false;
            } // We read the offset height to force a reflow, this is needed to start the transition between absolute values
            // https://blog.alexmaccaw.com/css-transitions under Redrawing
            // eslint-disable-next-line no-unused-vars


            var offsetHeight = subTreeContainer.offsetHeight;
            subTreeContainer.style.height = _this2.expanded ? "".concat(subTreeContainer.scrollHeight, "px") : 0;
          } else {
            // Make sure it's animated next time
            _this2._animate = true; // Hide it on initialization if closed

            if (!_this2.expanded) {
              subTreeContainer.style.height = 0;
              subTreeContainer.hidden = true;
            }
          }
        });
      }
      /**
       The item's variant. See {@link TreeItemVariantEnum}.
        @type {String}
       @default TreeItemVariant.DRILLDOWN
       @htmlattribute variant
       @htmlattributereflected
       */

    }, {
      key: "variant",
      get: function get() {
        return this._variant || variant$o.DRILLDOWN;
      },
      set: function set(value) {
        var _this$classList;

        value = transform.string(value).toLowerCase();
        this._variant = validate.enumeration(variant$o, value) && value || variant$o.DRILLDOWN; // removes every existing variant

        (_this$classList = this.classList).remove.apply(_this$classList, ALL_VARIANT_CLASSES$e);

        this.classList.add("".concat(CLASSNAME$1D, "--").concat(this._variant));
      }
      /**
       Whether the item is selected.
        @type {Boolean}
       @default false
       @htmlattribute selected
       @htmlattributereflected
       */

    }, {
      key: "selected",
      get: function get() {
        return this._selected || false;
      },
      set: function set(value) {
        this._selected = transform.booleanAttr(value);

        this._reflectAttribute('selected', this._selected);

        this._elements.header.classList.toggle('is-selected', this._selected);

        this._elements.header.setAttribute('aria-selected', this._selected);

        var selectedState = this._elements.selectedState;
        selectedState.textContent = i18n.get(this._selected ? 'selected' : 'not selected');

        if (IS_TOUCH_DEVICE) {
          selectedState.setAttribute('aria-pressed', this._selected);
        }

        this.trigger('coral-tree-item:_selectedchanged');
      }
      /**
       Whether this item is disabled.
        @type {Boolean}
       @default false
       @htmlattribute disabled
       @htmlattributereflected
       */

    }, {
      key: "disabled",
      get: function get() {
        return this._disabled || false;
      },
      set: function set(value) {
        this._disabled = transform.booleanAttr(value);

        this._reflectAttribute('disabled', this._disabled);

        this._elements.header.classList.toggle('is-disabled', this._disabled);

        this._elements.header[this._disabled ? 'setAttribute' : 'removeAttribute']('aria-disabled', this._disabled);

        this.trigger('coral-tree-item:_disabledchanged');
      }
      /**
       @ignore
       */

    }, {
      key: "hidden",
      get: function get() {
        return this.hasAttribute('hidden');
      },
      set: function set(value) {
        this._reflectAttribute('hidden', transform.booleanAttr(value)); // We redefine hidden to trigger an event


        this.trigger('coral-tree-item:_hiddenchanged');
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-tree-item-content': 'content'
        };
      }
      /** @ignore */

    }], [{
      key: "variant",
      get: function get() {
        return variant$o;
      }
    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(TreeItem), "observedAttributes", this).concat(['selected', 'disabled', 'variant', 'expanded', 'hidden']);
      }
    }]);

    return TreeItem;
  }(BaseComponent(HTMLElement));

  var CLASSNAME$1E = '_coral-TreeView';
  /**
   @class Coral.Tree
   @classdesc A Tree component is a container component to display collapsible content.
   Tree items don't expand by default. It's the developer's responsibility to handle it by listening to the
   {@link coral-collection:add} and {@link coral-collection:remove} events.
   @htmltag coral-tree
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var Tree = /*#__PURE__*/function (_BaseComponent) {
    _inherits(Tree, _BaseComponent);

    var _super = _createSuper(Tree);

    /** @ignore */
    function Tree() {
      var _this;

      _classCallCheck(this, Tree);

      _this = _super.call(this); // Attach events

      _this._delegateEvents({
        'click ._coral-TreeView-itemLink': '_onItemClick',
        'click ._coral-TreeView-indicator': '_onExpandCollapseClick',
        'coral-collection:add coral-tree-item': '_onCollectionChange',
        'coral-collection:remove coral-tree-item': '_onCollectionChange',
        // a11y
        'key:space ._coral-TreeView-itemLink': '_onItemClick',
        'key:space ._coral-TreeView-indicator': '_onExpandCollapseClick',
        'key:return ._coral-TreeView-itemLink, ._coral-TreeView-indicator': '_onExpandCollapseClick',
        'key:pageup ._coral-TreeView-itemLink, ._coral-TreeView-indicator': '_onFocusPreviousItem',
        'key:left ._coral-TreeView-itemLink, ._coral-TreeView-indicator': '_onCollapseItem',
        'key:up ._coral-TreeView-itemLink, ._coral-TreeView-indicator': '_onFocusPreviousItem',
        'key:pagedown ._coral-TreeView-itemLink, ._coral-TreeView-indicator': '_onFocusNextItem',
        'key:right ._coral-TreeView-itemLink, ._coral-TreeView-indicator': '_onExpandItem',
        'key:down ._coral-TreeView-itemLink, ._coral-TreeView-indicator': '_onFocusNextItem',
        'key:home ._coral-TreeView-itemLink, ._coral-TreeView-indicator': '_onFocusFirstItem',
        'key:end ._coral-TreeView-itemLink, ._coral-TreeView-indicator': '_onFocusLastItem',
        'capture:blur ._coral-TreeView-itemLink[tabindex="0"]': '_onItemBlur',
        // private
        'coral-tree-item:_selectedchanged': '_onItemSelectedChanged',
        'coral-tree-item:_disabledchanged': '_onFocusableChanged',
        'coral-tree-item:_expandedchanged': '_onFocusableChanged',
        'coral-tree-item:_afterexpandedchanged': '_onExpandedChanged',
        'coral-tree-item:_hiddenchanged': '_onFocusableChanged'
      }); // Used for eventing


      _this._oldSelection = []; // Init the collection mutation observer

      _this.items._startHandlingItems(true); // Listen for mutations for Torq compatibility


      var observer = new MutationObserver(function (mutations) {
        mutations.forEach(function (mutation) {
          for (var i = 0; i < mutation.addedNodes.length; i++) {
            var addedNode = mutation.addedNodes[i];

            if (addedNode.tagName === 'CORAL-TREE-ITEM') {
              // Move tree items to their container
              if (addedNode.parentNode.tagName === addedNode.tagName) {
                addedNode.parentNode._elements.subTreeContainer.appendChild(addedNode);
              }
            }
          }
        });
      });
      observer.observe(_assertThisInitialized(_this), {
        childList: true,
        subtree: true
      });
      return _this;
    }
    /**
     The Collection Interface that allows interacting with the items that the component contains.
      @type {SelectableCollection}
     @readonly
     */


    _createClass(Tree, [{
      key: "_onItemSelectedChanged",

      /** @private */
      value: function _onItemSelectedChanged(event) {
        event.stopImmediatePropagation();

        this._validateSelection(event.target);
      }
      /** @private */

    }, {
      key: "_validateSelection",
      value: function _validateSelection(item) {
        var _this2 = this;

        var selectedItems = this.selectedItems;

        if (!this.multiple) {
          // Last selected item wins if multiple selection while not allowed
          item = item || selectedItems[selectedItems.length - 1];

          if (item && item.hasAttribute('selected') && selectedItems.length > 1) {
            selectedItems.forEach(function (selectedItem) {
              if (selectedItem !== item) {
                // Don't trigger change events
                _this2._preventTriggeringEvents = true;
                selectedItem.removeAttribute('selected');
              }
            }); // We can trigger change events again

            this._preventTriggeringEvents = false;
          }
        }

        this._triggerChangeEvent();
      }
      /** @private */

    }, {
      key: "_triggerChangeEvent",
      value: function _triggerChangeEvent() {
        var selectedItems = this.selectedItems;
        var oldSelection = this._oldSelection;

        if (!this._preventTriggeringEvents && this._arraysAreDifferent(selectedItems, oldSelection)) {
          // We differentiate whether multiple is on or off and return an array or HTMLElement respectively
          if (this.multiple) {
            this.trigger('coral-tree:change', {
              oldSelection: oldSelection,
              selection: selectedItems
            });
          } else {
            // Return all items if we just switched from multiple=true to multiple=false and we had >1 selected items
            this.trigger('coral-tree:change', {
              oldSelection: oldSelection.length > 1 ? oldSelection : oldSelection[0] || null,
              selection: selectedItems[0] || null
            });
          }

          this._oldSelection = selectedItems;
        }
      }
      /** @private */

    }, {
      key: "_arraysAreDifferent",
      value: function _arraysAreDifferent(selection, oldSelection) {
        var diff = [];

        if (oldSelection.length === selection.length) {
          diff = oldSelection.filter(function (item) {
            return selection.indexOf(item) === -1;
          });
        } // since we guarantee that they are arrays, we can start by comparing their size


        return oldSelection.length !== selection.length || diff.length !== 0;
      }
      /** @private */

    }, {
      key: "_toggleItemAttribute",
      value: function _toggleItemAttribute(item, attributeName) {
        if (item) {
          item[item.hasAttribute(attributeName) ? 'removeAttribute' : 'setAttribute'](attributeName, '');
        }
      }
      /** @private */

    }, {
      key: "_onCollectionChange",
      value: function _onCollectionChange(event) {
        // Prevent triggering collection event twice. Only coral-tree collection events are propagated.
        event.stopImmediatePropagation();
      }
      /** @private */

    }, {
      key: "_onItemClick",
      value: function _onItemClick(event) {
        // Clickable item inside Tree Item should not trigger selection of item
        if (event.target.hasAttribute('coral-interactive') || event.target.closest('[coral-interactive]')) {
          return;
        } // If the indicator is clicked, expand/collapse the tree item


        if (event.target.closest('._coral-TreeView-indicator')) {
          this._onExpandCollapseClick(event);

          return;
        } // The click was performed on the header so we select the item (parentNode) the selection is toggled


        var item = event.target.closest('coral-tree-item');

        if (item && !item.hasAttribute('disabled')) {
          event.preventDefault();
          event.stopPropagation(); // We ignore the selection if the item is disabled

          this._toggleItemAttribute(item, 'selected');

          var focusable = this._getFocusable();

          if (focusable) {
            focusable.setAttribute('tabindex', '-1');
          }

          item._elements.header.setAttribute('tabindex', '0');

          item._elements.header.focus();
        }
      }
      /** @private */

    }, {
      key: "_onExpandCollapseClick",
      value: function _onExpandCollapseClick(event) {
        event.preventDefault();
        event.stopPropagation(); // The click was performed on the icon to expand/collapse  the sub tree

        var item = event.target.closest('coral-tree-item');

        if (item) {
          // We ignore the expand/collapse if the item is disabled
          if (item.hasAttribute('disabled')) {
            return;
          } // Toggle the expanded of the item:


          this._toggleItemAttribute(item, 'expanded');
        }
      }
      /** @private */

    }, {
      key: "_onExpandItem",
      value: function _onExpandItem(event) {
        event.preventDefault();
        event.stopPropagation(); // The click was performed on the icon to expand the sub tree

        var item = event.target.closest('coral-tree-item');

        if (item) {
          // We ignore the expand if the item is disabled
          if (item.hasAttribute('disabled')) {
            return;
          }

          if (!item.expanded && item.variant === TreeItem.variant.DRILLDOWN) {
            // If the item is not expanded, expand the item
            item.expanded = !item.expanded;

            item._elements.header.classList.add('focus-ring');
          } else if (item.items.length > 0) {
            // If the item is expanded, and contains items, focus the next item
            this._onFocusNextItem(event);
          }
        }
      }
      /** @private */

    }, {
      key: "_onCollapseItem",
      value: function _onCollapseItem(event) {
        event.preventDefault();
        event.stopPropagation(); // The click was performed on the icon to collapse the sub tree

        var item = event.target.closest('coral-tree-item');

        if (item) {
          // We ignore the expand if the item is disabled
          if (item.hasAttribute('disabled')) {
            return;
          }

          if (item.expanded && item.variant === TreeItem.variant.DRILLDOWN) {
            // If the item is not expanded, expand the item
            item.expanded = !item.expanded;

            item._elements.header.classList.add('focus-ring');
          } else if (item.parent) {
            item._elements.header.setAttribute('tabindex', '-1');

            item._elements.header.classList.remove('focus-ring');

            item.parent.focus();

            item.parent._elements.header.classList.add('focus-ring');
          }
        }
      }
      /** @private */

    }, {
      key: "_focusSiblingItem",
      value: function _focusSiblingItem(item, next) {
        var focusableItems = this._getFocusableItems(); // There's not enough items to change focus


        if (focusableItems.length < 2) {
          return;
        }

        var index = focusableItems.indexOf(item) + (next ? 1 : -1);
        var siblingItem = null; // If we reached the edge, target the other edge

        if (index > focusableItems.length - 1) {
          siblingItem = focusableItems[0];
        } else if (index < 0) {
          siblingItem = focusableItems[focusableItems.length - 1];
        } // Find the sibling item


        while (!siblingItem) {
          siblingItem = focusableItems[index]; // The item might be hidden because a parent is collapsed

          if (siblingItem.parentNode.closest('coral-tree-item.is-collapsed')) {
            if (next) {
              index++;
              siblingItem = index > focusableItems.length - 1 ? item : null;
            } else {
              index--;
              siblingItem = index < 0 ? item : null;
            }
          }
        } // Change focus


        if (siblingItem !== item) {
          item._elements.header.setAttribute('tabindex', '-1');

          item._elements.header.classList.remove('focus-ring');

          siblingItem._elements.header.setAttribute('tabindex', '0');

          siblingItem._elements.header.classList.add('focus-ring');

          siblingItem._elements.header.focus();
        }
      }
      /** @private */

    }, {
      key: "_focusEdgeItem",
      value: function _focusEdgeItem(last) {
        // Query the focusable item
        var focusable = this._getFocusable();

        if (focusable) {
          var focusableItems = this._getFocusableItems();

          var edgeItem = focusableItems[last ? focusableItems.length - 1 : 0]; // Change focus

          if (edgeItem !== focusable) {
            focusable.setAttribute('tabindex', '-1');

            edgeItem._elements.header.setAttribute('tabindex', '0');

            edgeItem._elements.header.focus();
          }
        }
      }
      /** @private */

    }, {
      key: "_onFocusNextItem",
      value: function _onFocusNextItem(event) {
        event.preventDefault();
        event.stopPropagation();
        var item = event.target.closest('coral-tree-item');

        if (item) {
          this._focusSiblingItem(item, true);
        }
      }
      /** @private */

    }, {
      key: "_onFocusPreviousItem",
      value: function _onFocusPreviousItem(event) {
        event.preventDefault();
        event.stopPropagation();
        var item = event.target.closest('coral-tree-item');

        if (item) {
          this._focusSiblingItem(item, false);
        }
      }
      /** @private */

    }, {
      key: "_onFocusFirstItem",
      value: function _onFocusFirstItem(event) {
        event.preventDefault();
        event.stopPropagation();

        this._focusEdgeItem(false);
      }
      /** @private */

    }, {
      key: "_onFocusLastItem",
      value: function _onFocusLastItem(event) {
        event.preventDefault();
        event.stopPropagation();

        this._focusEdgeItem(true);
      }
      /** @private */

    }, {
      key: "_onFocusableChanged",
      value: function _onFocusableChanged(event) {
        event.preventDefault();
        event.stopPropagation();

        if (event.target.contains(this._getFocusable())) {
          this._resetFocusableItem();
        }
      }
      /** @private */

    }, {
      key: "_onExpandedChanged",
      value: function _onExpandedChanged(event) {
        event.stopImmediatePropagation();
        var item = event.target;
        this.trigger("coral-tree:".concat(item.expanded ? 'expand' : 'collapse'), {
          item: item
        });
      }
      /** @private */

    }, {
      key: "_getFocusable",
      value: function _getFocusable() {
        return this.querySelector('coral-tree-item > ._coral-TreeView-itemLink[tabindex="0"]');
      }
      /** @private */

    }, {
      key: "_getFocusableItems",
      value: function _getFocusableItems() {
        return this.items.getAll().filter(function (item) {
          return !item.closest('coral-tree-item[disabled]') && !item.closest('coral-tree-item[hidden]');
        });
      }
      /** @private */

    }, {
      key: "_onItemBlur",
      value: function _onItemBlur() {
        var focused = this.querySelector('._coral-TreeView-itemLink.focus-ring');

        if (focused) {
          focused.classList.remove('focus-ring');
        }
      }
      /** @private */

    }, {
      key: "_resetFocusableItem",
      value: function _resetFocusableItem(item) {
        // Old focusable becomes unfocusable
        var focusable = this._getFocusable();

        if (focusable) {
          focusable.setAttribute('tabindex', '-1');
          focusable.classList.remove('focus-ring');
        } // Defined item or first item by default gets the focus


        item = item || this._getFocusableItems()[0];

        if (item) {
          item._elements.header.setAttribute('tabindex', '0');
        }
      }
      /** @private */

    }, {
      key: "_expandCollapseAll",
      value: function _expandCollapseAll(expand) {
        var coralTreeItems = this.querySelectorAll('coral-tree-item');

        if (coralTreeItems) {
          var item;
          var length = coralTreeItems.length;

          if (length > 0) {
            for (var index = 0; index < length; index++) {
              item = coralTreeItems[index];

              if (item) {
                item.expanded = expand;
              }
            }
          }
        }
      }
      /**
       Expand all the Tree Items
       */

    }, {
      key: "expandAll",
      value: function expandAll() {
        this._expandCollapseAll(true);
      }
      /**
       Collapse all the Tree Items
       */

    }, {
      key: "collapseAll",
      value: function collapseAll() {
        this._expandCollapseAll(false);
      }
      /** @ignore */

    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        var _this3 = this;

        _get(_getPrototypeOf(Tree.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1E); // a11y

        this.setAttribute('role', 'tree');
        this.setAttribute('aria-multiselectable', this.multiple); // Enable keyboard interaction

        requestAnimationFrame(function () {
          _this3._resetFocusableItem();
        }); // Don't trigger events once connected

        this._preventTriggeringEvents = true;

        this._validateSelection();

        this._preventTriggeringEvents = false;
        this._oldSelection = this.selectedItems;
      }
      /**
       Triggered when the {@link Tree} selection changed.
        @typedef {CustomEvent} coral-tree:change
        @property {Array.<TreeItem>} detail.oldSelection
       The old selected item.
       @property {Array.<TreeItem>} detail.selection
       The selected items.
       */

      /**
       Triggered when a {@link Tree} item expanded.
        @typedef {CustomEvent} coral-tree:expand
        @property {TreeItem} detail.item
       The expanded item.
       */

      /**
       Triggered when a {@link Tree} item collapsed.
        @typedef {CustomEvent} coral-tree:collapse
        @property {TreeItem} detail.item
       The collapsed item.
       */

    }, {
      key: "items",
      get: function get() {
        // just init on demand
        if (!this._items) {
          this._items = new SelectableCollection({
            host: this,
            itemTagName: 'coral-tree-item'
          });
        }

        return this._items;
      }
      /**
       Indicates whether the tree accepts multiple selected items.
       @type {Boolean}
       @default false
       @htmlattribute multiple
       @htmlattributereflected
       */

    }, {
      key: "multiple",
      get: function get() {
        return this._multiple || false;
      },
      set: function set(value) {
        this._multiple = transform.booleanAttr(value);

        this._reflectAttribute('multiple', this._multiple);

        this.setAttribute('aria-multiselectable', this._multiple);

        this._validateSelection();
      }
      /**
       Returns an Array containing the set selected items.
       @type {Array.<HTMLElement>}
       @readonly
       */

    }, {
      key: "selectedItems",
      get: function get() {
        return this.items._getAllSelected();
      }
      /**
       Returns the first selected item in the Tree. The value <code>null</code> is returned if no element is
       selected.
       @type {?HTMLElement}
       @readonly
       */

    }, {
      key: "selectedItem",
      get: function get() {
        return this.items._getAllSelected()[0] || null;
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(Tree), "observedAttributes", this).concat(['multiple']);
      }
    }]);

    return Tree;
  }(BaseComponent(HTMLElement));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Tree.Item.Content
   @classdesc Tree item's content component
   @htmltag coral-tree-item-content
   @return {HTMLElement}
   */
  var TreeItemContent = (function () {
    return document.createElement('coral-tree-item-content');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons._define('coral-tree-item', TreeItem);

  commons._define('coral-tree', Tree);

  Tree.Item = TreeItem;
  Tree.Item.Content = TreeItemContent;

  var CLASSNAME$1F = '_coral-WizardView';
  /**
   @class Coral.WizardView
   @classdesc A WizardView component is the wrapping container used to create the typical Wizard pattern. This is intended
   to be used with a {@link StepList} and a {@link PanelStack}.
   @htmltag coral-wizardview
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var WizardView = /*#__PURE__*/function (_BaseComponent) {
    _inherits(WizardView, _BaseComponent);

    var _super = _createSuper(WizardView);

    /** @ignore */
    function WizardView() {
      var _this;

      _classCallCheck(this, WizardView);

      _this = _super.call(this);

      _this._delegateEvents({
        'capture:click coral-steplist[coral-wizardview-steplist] > coral-step': '_onStepClick',
        'coral-steplist:change coral-steplist[coral-wizardview-steplist]': '_onStepListChange',
        'click [coral-wizardview-previous]': '_onPreviousClick',
        'click [coral-wizardview-next]': '_onNextClick'
      }); // Init the collection mutation observer


      _this.stepLists._startHandlingItems(true);

      _this.panelStacks._startHandlingItems(true); // Disable tracking for specific elements that are attached to the component.


      _this._observer = new MutationObserver(function (mutations) {
        mutations.forEach(function (mutation) {
          // Sync added nodes
          for (var i = 0; i < mutation.addedNodes.length; i++) {
            var addedNode = mutation.addedNodes[i];

            if (addedNode.setAttribute && (addedNode.hasAttribute('coral-wizardview-next') || addedNode.hasAttribute('coral-wizardview-previous') || addedNode.hasAttribute('coral-wizardview-steplist') || addedNode.hasAttribute('coral-wizardview-panelstack'))) {
              addedNode.setAttribute('tracking', 'off');
            }
          }
        });
      });

      _this._observer.observe(_assertThisInitialized(_this), {
        childList: true,
        subtree: true
      });

      return _this;
    }
    /**
     The set of controlled PanelStacks. Each PanelStack must have the <code>coral-wizardview-panelstack</code> attribute.
      @type {Collection}
     @readonly
     */


    _createClass(WizardView, [{
      key: "_onItemAdded",

      /**
       Called by the Collection when an item is added
        @private
       */
      value: function _onItemAdded(item) {
        this._selectItemByIndex(item, this._getSelectedIndex());
      }
    }, {
      key: "_onStepClick",
      value: function _onStepClick(event) {
        this._trackEvent('click', 'coral-wizardview-steplist-step', event, event.matchedTarget);
      }
      /**
       Handles the next button click.
        @private
       */

    }, {
      key: "_onNextClick",
      value: function _onNextClick(event) {
        // we stop propagation in case the wizard views are nested
        event.stopPropagation();
        this.next();
        var stepList = this.stepLists.first();

        var step = stepList.items.getAll()[this._getSelectedIndex()];

        this._trackEvent('click', 'coral-wizardview-next', event, step);
      }
      /**
       Handles the previous button click.
        @private
       */

    }, {
      key: "_onPreviousClick",
      value: function _onPreviousClick(event) {
        // we stop propagation in case the wizard views are nested
        event.stopPropagation();
        this.previous();
        var stepList = this.stepLists.first();

        var step = stepList.items.getAll()[this._getSelectedIndex()];

        this._trackEvent('click', 'coral-wizardview-previous', event, step);
      }
      /**
       Detects a change in the StepList and triggers an event.
        @private
       */

    }, {
      key: "_onStepListChange",
      value: function _onStepListChange(event) {
        // Stop propagation of the events to support nested panels
        event.stopPropagation(); // Get the step number

        var index = event.target.items.getAll().indexOf(event.detail.selection); // Sync the other StepLists

        this._selectStep(index);

        this.trigger('coral-wizardview:change', {
          selection: event.detail.selection,
          oldSelection: event.detail.oldSelection
        });

        this._trackEvent('change', 'coral-wizardview', event);
      }
      /** @private */

    }, {
      key: "_getSelectedIndex",
      value: function _getSelectedIndex() {
        var stepList = this.stepLists.first();

        if (!stepList) {
          return -1;
        }

        var stepIndex = -1;

        if (stepList.items) {
          stepIndex = stepList.items.getAll().indexOf(stepList.selectedItem);
        } else {
          // Manually get the selected step
          var steps = stepList.querySelectorAll('coral-step'); // Find the last selected step

          for (var i = steps.length - 1; i >= 0; i--) {
            if (steps[i].hasAttribute('selected')) {
              stepIndex = i;
              break;
            }
          }
        }

        return stepIndex;
      }
      /**
       Select the step according to the provided index.
        @param {*} component
       The StepList or PanelStack to select the step on.
       @param {Number} index
       The index of the step that should be selected.
        @private
       */

    }, {
      key: "_selectItemByIndex",
      value: function _selectItemByIndex(component, index) {
        var item = null; // we need to set an id to be able to find direct children

        component.id = component.id || commons.getUID(); // if collection api is available we use it to find the correct item

        if (component.items) {
          // Get the corresponding item
          item = component.items.getAll()[index];
        } // Resort to querying manually on immediately children
        else if (component.tagName === 'CORAL-STEPLIST') {
            // @polyfill IE - we use id since :scope is not supported
            item = component.querySelectorAll("#".concat(component.id, " > coral-step"))[index];
          } else if (component.tagName === 'CORAL-PANELSTACK') {
            // @polyfill IE - we use id since :scope is not supported
            item = component.querySelectorAll("#".concat(component.id, " > coral-panel"))[index];
          }

        if (item) {
          // we only select if not select to avoid mutations
          if (!item.hasAttribute('selected')) {
            item.setAttribute('selected', '');
          }
        } // if we did not find an item to select, it means that the "index" is not available in the component, therefore we
        // need to deselect all items
        else {
            // we use the component id to be able to find direct children
            if (component.tagName === 'CORAL-STEPLIST') {
              // @polyfill IE - we use id since :scope is not supported
              item = component.querySelector("#".concat(component.id, " > coral-step[selected]"));
            } else if (component.tagName === 'CORAL-PANELSTACK') {
              // @polyfill IE - we use id since :scope is not supported
              item = component.querySelector("#".concat(component.id, " > coral-panel[selected]"));
            }

            if (item) {
              item.removeAttribute('selected');
            }
          }
      }
      /** @private */

    }, {
      key: "_selectStep",
      value: function _selectStep(index) {
        var _this2 = this;

        // we apply the selection to all available steplists
        this.stepLists.getAll().forEach(function (stepList) {
          _this2._selectItemByIndex(stepList, index);
        }); // we apply the selection to all available panelstacks

        this.panelStacks.getAll().forEach(function (panelStack) {
          _this2._selectItemByIndex(panelStack, index);
        });
      }
      /**
       Sets the correct selected item in every PanelStack.
        @private
       */

    }, {
      key: "_syncPanelStackSelection",
      value: function _syncPanelStackSelection(defaultIndex) {
        var _this3 = this;

        // Find out which step we're on by checking the first StepList
        var index = this._getSelectedIndex();

        if (index === -1) {
          if (typeof defaultIndex !== 'undefined') {
            index = defaultIndex;
          } else {
            // No panel selected
            return;
          }
        }

        this.panelStacks.getAll().forEach(function (panelStack) {
          _this3._selectItemByIndex(panelStack, index);
        });
      }
      /**
       Selects the correct step in every StepList.
        @private
       */

    }, {
      key: "_syncStepListSelection",
      value: function _syncStepListSelection(defaultIndex) {
        var _this4 = this;

        // Find out which step we're on by checking the first StepList
        var index = this._getSelectedIndex();

        if (index === -1) {
          if (typeof defaultIndex !== 'undefined') {
            index = defaultIndex;
          } else {
            // No step selected
            return;
          }
        }

        this.stepLists.getAll().forEach(function (stepList) {
          _this4._selectItemByIndex(stepList, index);
        });
      }
      /**
       Shows the next step. If the WizardView is already in the last step nothing will happen.
        @emits {coral-wizardview:change}
       */

    }, {
      key: "next",
      value: function next() {
        var stepList = this.stepLists.first();

        if (!stepList) {
          return;
        } // Change to the next step


        stepList.next(); // Select the step everywhere

        this._selectStep(stepList.items.getAll().indexOf(stepList.selectedItem));
      }
      /**
       Shows the previous step. If the WizardView is already in the first step nothing will happen.
        @emits {coral-wizardview:change}
       */

    }, {
      key: "previous",
      value: function previous() {
        var stepList = this.stepLists.first();

        if (!stepList) {
          return;
        } // Change to the previous step


        stepList.previous(); // Select the step everywhere

        this._selectStep(stepList.items.getAll().indexOf(stepList.selectedItem));
      }
      /** @ignore */

    }, {
      key: "render",
      value: function render() {
        _get(_getPrototypeOf(WizardView.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1F);

        this._syncStepListSelection(0);

        this._syncPanelStackSelection(0); // Disable tracking for specific elements that are attached to the component.


        var selector = '[coral-wizardview-next],[coral-wizardview-previous],[coral-wizardview-steplist],[coral-wizardview-panelstack]';
        var items = this.querySelectorAll(selector);

        for (var i = 0; i < items.length; i++) {
          items[i].setAttribute('tracking', 'off');
        }
      }
      /**
       Triggered when the {@link WizardView} selected step list item has changed.
        @typedef {CustomEvent} coral-wizardview:change
        @property {Step} event.detail.selection
       The new selected step list item.
       @property {Step} event.detail.oldSelection
       The prior selected step list item.
       */

    }, {
      key: "panelStacks",
      get: function get() {
        // Construct the collection on first request:
        if (!this._panelStacks) {
          this._panelStacks = new Collection$1({
            host: this,
            itemTagName: 'coral-panelstack',
            // allows panelstack to be nested
            itemSelector: ':scope > coral-panelstack[coral-wizardview-panelstack]',
            onItemAdded: this._onItemAdded
          });
        }

        return this._panelStacks;
      }
      /**
       The set of controlling StepLists. Each StepList must have the <code>coral-wizardview-steplist</code> attribute.
        @type {Collection}
       @readonly
       */

    }, {
      key: "stepLists",
      get: function get() {
        // Construct the collection on first request:
        if (!this._stepLists) {
          this._stepLists = new Collection$1({
            host: this,
            itemTagName: 'coral-steplist',
            // allows steplist to be nested
            itemSelector: ':scope > coral-steplist[coral-wizardview-steplist]',
            onItemAdded: this._onItemAdded
          });
        }

        return this._stepLists;
      }
    }]);

    return WizardView;
  }(BaseComponent(HTMLElement));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons._define('coral-wizardview', WizardView);

  var name = "@adobe/coral-spectrum";
  var description = "Coral Spectrum is a JavaScript library of Web Components following Spectrum design patterns.";
  var version$1 = "4.10.15";
  var homepage = "https://github.com/adobe/coral-spectrum#readme";
  var license = "Apache-2.0";
  var repository = {
  	type: "git",
  	url: "https://github.com/adobe/coral-spectrum"
  };
  var author = {
  	name: "Stephan Ringel",
  	url: "https://github.com/icaraps"
  };
  var contributors = [
  	{
  		name: "Larry Davis",
  		url: "https://github.com/lazd"
  	},
  	{
  		name: "Oscar Bolanos",
  		url: "https://github.com/joekukish"
  	},
  	{
  		name: "Frank Karstens",
  		url: "https://github.com/karstens"
  	},
  	{
  		name: "Aaron Brownlee",
  		url: "https://github.com/misterbrownlee"
  	}
  ];
  var bugs = {
  	url: "https://github.com/adobe/coral-spectrum/issues"
  };
  var scripts = {
  	postinstall: "node scripts/spectrum-css.js",
  	build: "gulp build && gulp karma && gulp examples && gulp axe && gulp minify-css && gulp minify-js",
  	playground: "cd coral-component-playground && gulp build && cd .. && gulp playground",
  	docs: "gulp docs",
  	"semantic-release": "semantic-release"
  };
  var dependencies = {
  	"@adobe/focus-ring-polyfill": "0.1.5",
  	"@adobe/spectrum-css": "2.18.0",
  	"@adobe/vent": "1.0.0",
  	"core-js": "3.6.4",
  	"document-register-element": "1.14.3",
  	"normalize.css": "8.0.1",
  	"popper.js": "1.16.1",
  	"resize-observer-polyfill": "1.5.1"
  };
  var devDependencies = {
  	"@babel/core": "^7.10.2",
  	"@babel/preset-env": "^7.10.2",
  	"@semantic-release/changelog": "^5.0.1",
  	"@semantic-release/git": "^9.0.0",
  	"@semantic-release/github": "^7.0.7",
  	"babel-eslint": "^10.0.3",
  	browserslist: "^4.8.5",
  	chai: "^4.0.2",
  	codemirror: "^5.52.2",
  	commitizen: "^4.2.1",
  	"cz-conventional-changelog": "^3.3.0",
  	"deflate-js": "0.2.3",
  	del: "^4.1.1",
  	esdoc: "^1.0.3",
  	"esdoc-accessor-plugin": "^1.0.0",
  	"esdoc-importpath-plugin": "^1.0.1",
  	"esdoc-inject-script-plugin": "^1.0.0",
  	"esdoc-inject-style-plugin": "^1.0.0",
  	"esdoc-member-plugin": "^1.0.0",
  	"esdoc-standard-plugin": "^1.0.0",
  	"eslint-config-standard": "^12.0.0",
  	"eslint-plugin-babel": "^5.3.0",
  	"eslint-plugin-import": "^2.20.0",
  	"eslint-plugin-node": "^8.0.1",
  	"eslint-plugin-promise": "^4.2.1",
  	"eslint-plugin-standard": "^4.0.1",
  	"fancy-log": "^1.3.3",
  	"fs-extra": "^7.0.1",
  	"glob-all": "^3.2.1",
  	gulp: "^4.0.2",
  	"gulp-axe-webdriver": "^3.1.3",
  	"gulp-bump": "^3.1.3",
  	"gulp-clean-css": "^4.2.0",
  	"gulp-domly": "^0.1.0",
  	"gulp-eslint": "^6.0.0",
  	"gulp-gh-pages": "^0.6.0-6",
  	"gulp-git": "^2.10.0",
  	"gulp-merge-json": "^1.0.0",
  	"gulp-modify-file": "^1.0.0",
  	"gulp-plumber": "^1.1.0",
  	"gulp-postcss": "^8.0.0",
  	"gulp-rename": "^1.2.2",
  	"gulp-stylus": "^2.6.0",
  	"http-server": "^0.12.3",
  	inquirer: "^6.5.2",
  	karma: "^5.0.9",
  	"karma-chrome-launcher": "^2.2.0",
  	"karma-coverage-istanbul-reporter": "^2.1.1",
  	"karma-firefox-launcher": "^1.3.0",
  	"karma-html2js-preprocessor": "^1.1.0",
  	"karma-mocha": "^2.0.1",
  	"karma-mocha-reporter": "^2.2.5",
  	"karma-rollup-preprocessor": "^7.0.3",
  	"karma-sinon-chai": "^2.0.2",
  	minimist: "^1.2.0",
  	mocha: "^7.2.0",
  	moment: "^2.24.0",
  	"plugin-error": "^1.0.1",
  	"postcss-css-variables": "^0.13.0",
  	"postcss-merge-rules": "^4.0.3",
  	request: "^2.81.0",
  	rollup: "^1.29.1",
  	"rollup-plugin-babel": "^4.3.3",
  	"rollup-plugin-commonjs": "^9.3.4",
  	"rollup-plugin-istanbul": "^2.0.1",
  	"rollup-plugin-json": "^4.0.0",
  	"rollup-plugin-node-resolve": "^4.2.4",
  	"rollup-plugin-postcss": "^2.0.4",
  	"rollup-plugin-terser": "^5.2.0",
  	"rollup-pluginutils": "^2.8.2",
  	semver: "^6.3.0",
  	"semantic-release": "^17.1.1",
  	sinon: "^7.5.0",
  	"sinon-chai": "^3.4.0",
  	"stylus-svg": "^1.1.2",
  	through2: "^3.0.1"
  };
  var config$1 = {
  	commitizen: {
  		path: "./node_modules/cz-conventional-changelog"
  	}
  };
  var PACKAGE = {
  	name: name,
  	description: description,
  	version: version$1,
  	homepage: homepage,
  	license: license,
  	repository: repository,
  	author: author,
  	contributors: contributors,
  	bugs: bugs,
  	scripts: scripts,
  	dependencies: dependencies,
  	devDependencies: devDependencies,
  	config: config$1
  };

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  var version$2 = PACKAGE.version;

  exports.Accordion = Accordion;
  exports.ActionBar = ActionBar;
  exports.Alert = Alert;
  exports.AnchorButton = AnchorButton;
  exports.AnchorList = AnchorList;
  exports.Autocomplete = Autocomplete;
  exports.Banner = Banner;
  exports.Button = Button;
  exports.ButtonGroup = ButtonGroup;
  exports.ButtonList = ButtonList;
  exports.Calendar = Calendar;
  exports.Card = Card;
  exports.CharacterCount = CharacterCount;
  exports.Checkbox = Checkbox;
  exports.CheckboxGroup = CheckboxGroup;
  exports.Clock = Clock;
  exports.CoachMark = CoachMark;
  exports.Collection = Collection$1;
  exports.Color = Color;
  exports.ColorInput = ColorInput;
  exports.ColumnView = ColumnView;
  exports.Component = Component;
  exports.CycleButton = CycleButton;
  exports.DateTime = DateTime;
  exports.Datepicker = Datepicker;
  exports.Dialog = Dialog;
  exports.DragAction = DragAction;
  exports.Drawer = Drawer;
  exports.FileUpload = FileUpload;
  exports.Icon = Icon;
  exports.Keys = Keys;
  exports.List = List;
  exports.Masonry = Masonry;
  exports.Multifield = Multifield;
  exports.NumberInput = NumberInput;
  exports.Overlay = Overlay;
  exports.Panel = Panel;
  exports.PanelStack = PanelStack;
  exports.Popover = Popover;
  exports.Progress = Progress;
  exports.QuickActions = QuickActions;
  exports.Radio = Radio;
  exports.RadioGroup = RadioGroup;
  exports.RangedSlider = RangedSlider;
  exports.Search = Search;
  exports.Select = Select;
  exports.SelectList = SelectList;
  exports.SelectableCollection = SelectableCollection;
  exports.Shell = Shell;
  exports.SideNav = SideNav;
  exports.Slider = Slider;
  exports.SplitButton = SplitButton;
  exports.Status = Status;
  exports.Step = Step;
  exports.StepList = StepList;
  exports.Switch = Switch;
  exports.Tab = Tab;
  exports.TabList = TabList;
  exports.TabView = TabView;
  exports.Table = Table;
  exports.Tag = Tag;
  exports.TagList = TagList;
  exports.Textarea = Textarea;
  exports.Textfield = Textfield;
  exports.Toast = Toast;
  exports.Tooltip = Tooltip;
  exports.Tree = Tree;
  exports.TreeItem = TreeItem;
  exports.Wait = Wait;
  exports.WizardView = WizardView;
  exports.commons = commons;
  exports.events = events;
  exports.i18n = i18n;
  exports.keys = keys$1;
  exports.property = property;
  exports.register = register;
  exports.strings = strings;
  exports.tracking = tracking;
  exports.transform = transform;
  exports.validate = validate;
  exports.version = version$2;

  return exports;

}({}));
//# sourceMappingURL=coral.js.map
