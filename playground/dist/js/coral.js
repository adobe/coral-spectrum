(function () {
  'use strict';

  // Any copyright is dedicated to the Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
  // Source https://developer.mozilla.org/fr/docs/Web/API/Element/closest
  (function () {
    if (!Element.prototype.matches) Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
    if (!Element.prototype.closest) Element.prototype.closest = function (s) {
      var el = this;
      if (!document.documentElement.contains(el)) return null;

      do {
        if (el.matches(s)) return el;
        el = el.parentElement || el.parentNode;
      } while (el !== null && el.nodeType == 1);

      return null;
    };
  })();

  // Any copyright is dedicated to the Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
  // Source https://developer.mozilla.org/en/docs/Web/API/Element/matches
  (function () {
    if (!Element.prototype.matches) {
      Element.prototype.matches = Element.prototype.msMatchesSelector;
    }
  })();

  // Any copyright is dedicated to the Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
  // Source https://developer.mozilla.org/en-US/docs/Web/API/ChildNode/remove
  (function (arr) {
    arr.forEach(function (item) {
      if (item.hasOwnProperty('remove')) {
        return;
      }

      Object.defineProperty(item, 'remove', {
        configurable: true,
        enumerable: true,
        writable: true,
        value: function remove() {
          this.parentNode && this.parentNode.removeChild(this);
        }
      });
    });
  })([Element.prototype, CharacterData.prototype, DocumentType.prototype]);

  /**
   * classList.js: Cross-browser full element.classList implementation.
   * 1.1.20150312
   *
   * By Eli Grey, http://eligrey.com
   * License: Dedicated to the public domain.
   * See https://github.com/eligrey/classList.js/blob/master/LICENSE.md
   */
  // Source http://purl.eligrey.com/github/classList.js/blob/master/classList.js
  (function () {
    var testElement = document.createElement("_");
    testElement.classList.add("c1", "c2"); // Polyfill for IE 10/11 and Firefox <26, where classList.add and
    // classList.remove exist but support only one argument at a time.

    if (!testElement.classList.contains("c2")) {
      var createMethod = function createMethod(method) {
        var original = DOMTokenList.prototype[method];

        DOMTokenList.prototype[method] = function (token) {
          var i,
              len = arguments.length;

          for (i = 0; i < len; i++) {
            token = arguments[i];
            original.call(this, token);
          }
        };
      };

      createMethod('add');
      createMethod('remove');
    }

    testElement.classList.toggle("c3", false); // Polyfill for IE 10 and Firefox <24, where classList.toggle does not
    // support the second argument.

    if (testElement.classList.contains("c3")) {
      var _toggle = DOMTokenList.prototype.toggle;

      DOMTokenList.prototype.toggle = function (token, force) {
        if (1 in arguments && !this.contains(token) === !force) {
          return force;
        } else {
          return _toggle.call(this, token);
        }
      };
    } // Polyfill for IE11 SVG classList support


    if (!("classList" in document.createElementNS("http://www.w3.org/2000/svg", "g"))) {
      var descr = Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'classList');
      Object.defineProperty(SVGElement.prototype, 'classList', descr);
    }

    testElement = null;
  })();

  // Any copyright is dedicated to the Public Domain. http://creativecommons.org/publicdomain/zero/1.0/
  // Source https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent#Polyfill
  (function () {
    if (typeof window.CustomEvent === "function") return false;

    function CustomEvent(event, params) {
      params = params || {
        bubbles: false,
        cancelable: false,
        detail: undefined
      };
      var evt = document.createEvent('CustomEvent');
      evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
      return evt;
    }

    CustomEvent.prototype = window.Event.prototype;
    window.CustomEvent = CustomEvent;
  })();

  /**
   MIT License
   Copyright (c) 2018 Juan Valencia

   Permission is hereby granted, free of charge, to any person obtaining a copy
   of this software and associated documentation files (the "Software"), to deal
   in the Software without restriction, including without limitation the rights
   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   copies of the Software, and to permit persons to whom the Software is
   furnished to do so, subject to the following conditions:

   The above copyright notice and this permission notice shall be included in all
   copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   SOFTWARE.
   */
  // focus - focusOptions - preventScroll polyfill
  var supportsPreventScrollOption = false;

  try {
    var focusElem = document.createElement('div');
    focusElem.addEventListener('focus', function (event) {
      event.preventDefault();
      event.stopPropagation();
    }, true);
    focusElem.focus(Object.defineProperty({}, 'preventScroll', {
      get: function get() {
        supportsPreventScrollOption = true;
      }
    }));
  } catch (e) {}

  if (HTMLElement.prototype.nativeFocus === undefined && !supportsPreventScrollOption) {
    HTMLElement.prototype.nativeFocus = HTMLElement.prototype.focus;

    var getScrollParent = function getScrollParent(node) {
      var isElement = node instanceof HTMLElement;
      var overflowY = isElement && window.getComputedStyle(node).overflowY;
      var isScrollable = overflowY !== 'visible' && overflowY !== 'hidden';

      if (!node) {
        return null;
      } else if (isScrollable && node.scrollHeight >= node.clientHeight) {
        return node;
      }

      return getScrollParent(node.parentNode) || document.body;
    };

    var patchedFocus = function patchedFocus(args) {
      var scrollElement = getScrollParent(this);
      var actualPosition = scrollElement.scrollTop;
      this.nativeFocus();

      if (args && args.preventScroll) {
        // Hijacking the event loop order, since the focus() will trigger
        // internally an scroll that goes to the event loop
        setTimeout(function () {
          scrollElement.scrollTop = actualPosition;
        }, 0);
      }
    };

    HTMLElement.prototype.focus = patchedFocus;
  }

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn(this, result);
    };
  }

  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object);
      if (object === null) break;
    }

    return object;
  }

  function _get(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get;
    } else {
      _get = function _get(target, property, receiver) {
        var base = _superPropBase(target, property);

        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(receiver);
        }

        return desc.value;
      };
    }

    return _get(target, property, receiver || target);
  }

  function set(target, property, value, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.set) {
      set = Reflect.set;
    } else {
      set = function set(target, property, value, receiver) {
        var base = _superPropBase(target, property);

        var desc;

        if (base) {
          desc = Object.getOwnPropertyDescriptor(base, property);

          if (desc.set) {
            desc.set.call(receiver, value);
            return true;
          } else if (!desc.writable) {
            return false;
          }
        }

        desc = Object.getOwnPropertyDescriptor(receiver, property);

        if (desc) {
          if (!desc.writable) {
            return false;
          }

          desc.value = value;
          Object.defineProperty(receiver, property, desc);
        } else {
          _defineProperty(receiver, property, value);
        }

        return true;
      };
    }

    return set(target, property, value, receiver);
  }

  function _set(target, property, value, receiver, isStrict) {
    var s = set(target, property, value, receiver || target);

    if (!s && isStrict) {
      throw new Error('failed to set property');
    }

    return value;
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var check = function check(it) {
    return it && it.Math == Math && it;
  }; // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028


  var global_1 = // eslint-disable-next-line no-undef
  check((typeof globalThis === "undefined" ? "undefined" : _typeof(globalThis)) == 'object' && globalThis) || check((typeof window === "undefined" ? "undefined" : _typeof(window)) == 'object' && window) || check((typeof self === "undefined" ? "undefined" : _typeof(self)) == 'object' && self) || check(_typeof(commonjsGlobal) == 'object' && commonjsGlobal) || // eslint-disable-next-line no-new-func
  Function('return this')();

  var fails = function fails(exec) {
    try {
      return !!exec();
    } catch (error) {
      return true;
    }
  };

  var descriptors = !fails(function () {
    return Object.defineProperty({}, 1, {
      get: function get() {
        return 7;
      }
    })[1] != 7;
  });

  var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
  var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor; // Nashorn ~ JDK8 bug

  var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({
    1: 2
  }, 1); // `Object.prototype.propertyIsEnumerable` method implementation
  // https://tc39.github.io/ecma262/#sec-object.prototype.propertyisenumerable

  var f = NASHORN_BUG ? function propertyIsEnumerable(V) {
    var descriptor = getOwnPropertyDescriptor(this, V);
    return !!descriptor && descriptor.enumerable;
  } : nativePropertyIsEnumerable;
  var objectPropertyIsEnumerable = {
    f: f
  };

  var createPropertyDescriptor = function createPropertyDescriptor(bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value: value
    };
  };

  var toString = {}.toString;

  var classofRaw = function classofRaw(it) {
    return toString.call(it).slice(8, -1);
  };

  var split = ''.split; // fallback for non-array-like ES3 and non-enumerable old V8 strings

  var indexedObject = fails(function () {
    // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
    // eslint-disable-next-line no-prototype-builtins
    return !Object('z').propertyIsEnumerable(0);
  }) ? function (it) {
    return classofRaw(it) == 'String' ? split.call(it, '') : Object(it);
  } : Object;

  // `RequireObjectCoercible` abstract operation
  // https://tc39.github.io/ecma262/#sec-requireobjectcoercible
  var requireObjectCoercible = function requireObjectCoercible(it) {
    if (it == undefined) throw TypeError("Can't call method on " + it);
    return it;
  };

  var toIndexedObject = function toIndexedObject(it) {
    return indexedObject(requireObjectCoercible(it));
  };

  var isObject = function isObject(it) {
    return _typeof(it) === 'object' ? it !== null : typeof it === 'function';
  };

  // https://tc39.github.io/ecma262/#sec-toprimitive
  // instead of the ES6 spec version, we didn't implement @@toPrimitive case
  // and the second argument - flag - preferred type is a string

  var toPrimitive = function toPrimitive(input, PREFERRED_STRING) {
    if (!isObject(input)) return input;
    var fn, val;
    if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
    if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;
    if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
    throw TypeError("Can't convert object to primitive value");
  };

  var hasOwnProperty = {}.hasOwnProperty;

  var has = function has(it, key) {
    return hasOwnProperty.call(it, key);
  };

  var document$1 = global_1.document; // typeof document.createElement is 'object' in old IE

  var EXISTS = isObject(document$1) && isObject(document$1.createElement);

  var documentCreateElement = function documentCreateElement(it) {
    return EXISTS ? document$1.createElement(it) : {};
  };

  var ie8DomDefine = !descriptors && !fails(function () {
    return Object.defineProperty(documentCreateElement('div'), 'a', {
      get: function get() {
        return 7;
      }
    }).a != 7;
  });

  var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor; // `Object.getOwnPropertyDescriptor` method
  // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor

  var f$1 = descriptors ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
    O = toIndexedObject(O);
    P = toPrimitive(P, true);
    if (ie8DomDefine) try {
      return nativeGetOwnPropertyDescriptor(O, P);
    } catch (error) {
      /* empty */
    }
    if (has(O, P)) return createPropertyDescriptor(!objectPropertyIsEnumerable.f.call(O, P), O[P]);
  };
  var objectGetOwnPropertyDescriptor = {
    f: f$1
  };

  var anObject = function anObject(it) {
    if (!isObject(it)) {
      throw TypeError(String(it) + ' is not an object');
    }

    return it;
  };

  var nativeDefineProperty = Object.defineProperty; // `Object.defineProperty` method
  // https://tc39.github.io/ecma262/#sec-object.defineproperty

  var f$2 = descriptors ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
    anObject(O);
    P = toPrimitive(P, true);
    anObject(Attributes);
    if (ie8DomDefine) try {
      return nativeDefineProperty(O, P, Attributes);
    } catch (error) {
      /* empty */
    }
    if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
    if ('value' in Attributes) O[P] = Attributes.value;
    return O;
  };
  var objectDefineProperty = {
    f: f$2
  };

  var createNonEnumerableProperty = descriptors ? function (object, key, value) {
    return objectDefineProperty.f(object, key, createPropertyDescriptor(1, value));
  } : function (object, key, value) {
    object[key] = value;
    return object;
  };

  var setGlobal = function setGlobal(key, value) {
    try {
      createNonEnumerableProperty(global_1, key, value);
    } catch (error) {
      global_1[key] = value;
    }

    return value;
  };

  var SHARED = '__core-js_shared__';
  var store = global_1[SHARED] || setGlobal(SHARED, {});
  var sharedStore = store;

  var functionToString = Function.toString; // this helper broken in `3.4.1-3.4.4`, so we can't use `shared` helper

  if (typeof sharedStore.inspectSource != 'function') {
    sharedStore.inspectSource = function (it) {
      return functionToString.call(it);
    };
  }

  var inspectSource = sharedStore.inspectSource;

  var WeakMap$1 = global_1.WeakMap;
  var nativeWeakMap = typeof WeakMap$1 === 'function' && /native code/.test(inspectSource(WeakMap$1));

  var shared = createCommonjsModule(function (module) {
    (module.exports = function (key, value) {
      return sharedStore[key] || (sharedStore[key] = value !== undefined ? value : {});
    })('versions', []).push({
      version: '3.6.4',
      mode:  'global',
      copyright: '© 2020 Denis Pushkarev (zloirock.ru)'
    });
  });

  var id = 0;
  var postfix = Math.random();

  var uid = function uid(key) {
    return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
  };

  var keys = shared('keys');

  var sharedKey = function sharedKey(key) {
    return keys[key] || (keys[key] = uid(key));
  };

  var hiddenKeys = {};

  var WeakMap$2 = global_1.WeakMap;
  var set$1, get, has$1;

  var enforce = function enforce(it) {
    return has$1(it) ? get(it) : set$1(it, {});
  };

  var getterFor = function getterFor(TYPE) {
    return function (it) {
      var state;

      if (!isObject(it) || (state = get(it)).type !== TYPE) {
        throw TypeError('Incompatible receiver, ' + TYPE + ' required');
      }

      return state;
    };
  };

  if (nativeWeakMap) {
    var store$1 = new WeakMap$2();
    var wmget = store$1.get;
    var wmhas = store$1.has;
    var wmset = store$1.set;

    set$1 = function set(it, metadata) {
      wmset.call(store$1, it, metadata);
      return metadata;
    };

    get = function get(it) {
      return wmget.call(store$1, it) || {};
    };

    has$1 = function has(it) {
      return wmhas.call(store$1, it);
    };
  } else {
    var STATE = sharedKey('state');
    hiddenKeys[STATE] = true;

    set$1 = function set(it, metadata) {
      createNonEnumerableProperty(it, STATE, metadata);
      return metadata;
    };

    get = function get(it) {
      return has(it, STATE) ? it[STATE] : {};
    };

    has$1 = function has$1(it) {
      return has(it, STATE);
    };
  }

  var internalState = {
    set: set$1,
    get: get,
    has: has$1,
    enforce: enforce,
    getterFor: getterFor
  };

  var redefine = createCommonjsModule(function (module) {
    var getInternalState = internalState.get;
    var enforceInternalState = internalState.enforce;
    var TEMPLATE = String(String).split('String');
    (module.exports = function (O, key, value, options) {
      var unsafe = options ? !!options.unsafe : false;
      var simple = options ? !!options.enumerable : false;
      var noTargetGet = options ? !!options.noTargetGet : false;

      if (typeof value == 'function') {
        if (typeof key == 'string' && !has(value, 'name')) createNonEnumerableProperty(value, 'name', key);
        enforceInternalState(value).source = TEMPLATE.join(typeof key == 'string' ? key : '');
      }

      if (O === global_1) {
        if (simple) O[key] = value;else setGlobal(key, value);
        return;
      } else if (!unsafe) {
        delete O[key];
      } else if (!noTargetGet && O[key]) {
        simple = true;
      }

      if (simple) O[key] = value;else createNonEnumerableProperty(O, key, value); // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
    })(Function.prototype, 'toString', function toString() {
      return typeof this == 'function' && getInternalState(this).source || inspectSource(this);
    });
  });

  var path = global_1;

  var aFunction = function aFunction(variable) {
    return typeof variable == 'function' ? variable : undefined;
  };

  var getBuiltIn = function getBuiltIn(namespace, method) {
    return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global_1[namespace]) : path[namespace] && path[namespace][method] || global_1[namespace] && global_1[namespace][method];
  };

  var ceil = Math.ceil;
  var floor = Math.floor; // `ToInteger` abstract operation
  // https://tc39.github.io/ecma262/#sec-tointeger

  var toInteger = function toInteger(argument) {
    return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
  };

  var min = Math.min; // `ToLength` abstract operation
  // https://tc39.github.io/ecma262/#sec-tolength

  var toLength = function toLength(argument) {
    return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
  };

  var max = Math.max;
  var min$1 = Math.min; // Helper for a popular repeating case of the spec:
  // Let integer be ? ToInteger(index).
  // If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).

  var toAbsoluteIndex = function toAbsoluteIndex(index, length) {
    var integer = toInteger(index);
    return integer < 0 ? max(integer + length, 0) : min$1(integer, length);
  };

  var createMethod = function createMethod(IS_INCLUDES) {
    return function ($this, el, fromIndex) {
      var O = toIndexedObject($this);
      var length = toLength(O.length);
      var index = toAbsoluteIndex(fromIndex, length);
      var value; // Array#includes uses SameValueZero equality algorithm
      // eslint-disable-next-line no-self-compare

      if (IS_INCLUDES && el != el) while (length > index) {
        value = O[index++]; // eslint-disable-next-line no-self-compare

        if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not
      } else for (; length > index; index++) {
        if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
      }
      return !IS_INCLUDES && -1;
    };
  };

  var arrayIncludes = {
    // `Array.prototype.includes` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.includes
    includes: createMethod(true),
    // `Array.prototype.indexOf` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.indexof
    indexOf: createMethod(false)
  };

  var indexOf = arrayIncludes.indexOf;

  var objectKeysInternal = function objectKeysInternal(object, names) {
    var O = toIndexedObject(object);
    var i = 0;
    var result = [];
    var key;

    for (key in O) {
      !has(hiddenKeys, key) && has(O, key) && result.push(key);
    } // Don't enum bug & hidden keys


    while (names.length > i) {
      if (has(O, key = names[i++])) {
        ~indexOf(result, key) || result.push(key);
      }
    }

    return result;
  };

  // IE8- don't enum bug keys
  var enumBugKeys = ['constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf'];

  var hiddenKeys$1 = enumBugKeys.concat('length', 'prototype'); // `Object.getOwnPropertyNames` method
  // https://tc39.github.io/ecma262/#sec-object.getownpropertynames

  var f$3 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
    return objectKeysInternal(O, hiddenKeys$1);
  };

  var objectGetOwnPropertyNames = {
    f: f$3
  };

  var f$4 = Object.getOwnPropertySymbols;
  var objectGetOwnPropertySymbols = {
    f: f$4
  };

  var ownKeys = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
    var keys = objectGetOwnPropertyNames.f(anObject(it));
    var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;
    return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
  };

  var copyConstructorProperties = function copyConstructorProperties(target, source) {
    var keys = ownKeys(source);
    var defineProperty = objectDefineProperty.f;
    var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
    }
  };

  var replacement = /#|\.prototype\./;

  var isForced = function isForced(feature, detection) {
    var value = data[normalize(feature)];
    return value == POLYFILL ? true : value == NATIVE ? false : typeof detection == 'function' ? fails(detection) : !!detection;
  };

  var normalize = isForced.normalize = function (string) {
    return String(string).replace(replacement, '.').toLowerCase();
  };

  var data = isForced.data = {};
  var NATIVE = isForced.NATIVE = 'N';
  var POLYFILL = isForced.POLYFILL = 'P';
  var isForced_1 = isForced;

  var getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;
  /*
    options.target      - name of the target object
    options.global      - target is the global object
    options.stat        - export as static methods of target
    options.proto       - export as prototype methods of target
    options.real        - real prototype method for the `pure` version
    options.forced      - export even if the native feature is available
    options.bind        - bind methods to the target, required for the `pure` version
    options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
    options.unsafe      - use the simple assignment of property instead of delete + defineProperty
    options.sham        - add a flag to not completely full polyfills
    options.enumerable  - export as enumerable property
    options.noTargetGet - prevent calling a getter on target
  */

  var _export = function _export(options, source) {
    var TARGET = options.target;
    var GLOBAL = options.global;
    var STATIC = options.stat;
    var FORCED, target, key, targetProperty, sourceProperty, descriptor;

    if (GLOBAL) {
      target = global_1;
    } else if (STATIC) {
      target = global_1[TARGET] || setGlobal(TARGET, {});
    } else {
      target = (global_1[TARGET] || {}).prototype;
    }

    if (target) for (key in source) {
      sourceProperty = source[key];

      if (options.noTargetGet) {
        descriptor = getOwnPropertyDescriptor$1(target, key);
        targetProperty = descriptor && descriptor.value;
      } else targetProperty = target[key];

      FORCED = isForced_1(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced); // contained in target

      if (!FORCED && targetProperty !== undefined) {
        if (_typeof(sourceProperty) === _typeof(targetProperty)) continue;
        copyConstructorProperties(sourceProperty, targetProperty);
      } // add a flag to not completely full polyfills


      if (options.sham || targetProperty && targetProperty.sham) {
        createNonEnumerableProperty(sourceProperty, 'sham', true);
      } // extend global


      redefine(target, key, sourceProperty, options);
    }
  };

  var aFunction$1 = function aFunction(it) {
    if (typeof it != 'function') {
      throw TypeError(String(it) + ' is not a function');
    }

    return it;
  };

  var nativeApply = getBuiltIn('Reflect', 'apply');
  var functionApply = Function.apply; // MS Edge argumentsList argument is optional

  var OPTIONAL_ARGUMENTS_LIST = !fails(function () {
    nativeApply(function () {
      /* empty */
    });
  }); // `Reflect.apply` method
  // https://tc39.github.io/ecma262/#sec-reflect.apply

  _export({
    target: 'Reflect',
    stat: true,
    forced: OPTIONAL_ARGUMENTS_LIST
  }, {
    apply: function apply(target, thisArgument, argumentsList) {
      aFunction$1(target);
      anObject(argumentsList);
      return nativeApply ? nativeApply(target, thisArgument, argumentsList) : functionApply.call(target, thisArgument, argumentsList);
    }
  });

  // https://tc39.github.io/ecma262/#sec-object.keys

  var objectKeys = Object.keys || function keys(O) {
    return objectKeysInternal(O, enumBugKeys);
  };

  // https://tc39.github.io/ecma262/#sec-object.defineproperties

  var objectDefineProperties = descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
    anObject(O);
    var keys = objectKeys(Properties);
    var length = keys.length;
    var index = 0;
    var key;

    while (length > index) {
      objectDefineProperty.f(O, key = keys[index++], Properties[key]);
    }

    return O;
  };

  var html = getBuiltIn('document', 'documentElement');

  var GT = '>';
  var LT = '<';
  var PROTOTYPE = 'prototype';
  var SCRIPT = 'script';
  var IE_PROTO = sharedKey('IE_PROTO');

  var EmptyConstructor = function EmptyConstructor() {
    /* empty */
  };

  var scriptTag = function scriptTag(content) {
    return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
  }; // Create object with fake `null` prototype: use ActiveX Object with cleared prototype


  var NullProtoObjectViaActiveX = function NullProtoObjectViaActiveX(activeXDocument) {
    activeXDocument.write(scriptTag(''));
    activeXDocument.close();
    var temp = activeXDocument.parentWindow.Object;
    activeXDocument = null; // avoid memory leak

    return temp;
  }; // Create object with fake `null` prototype: use iframe Object with cleared prototype


  var NullProtoObjectViaIFrame = function NullProtoObjectViaIFrame() {
    // Thrash, waste and sodomy: IE GC bug
    var iframe = documentCreateElement('iframe');
    var JS = 'java' + SCRIPT + ':';
    var iframeDocument;
    iframe.style.display = 'none';
    html.appendChild(iframe); // https://github.com/zloirock/core-js/issues/475

    iframe.src = String(JS);
    iframeDocument = iframe.contentWindow.document;
    iframeDocument.open();
    iframeDocument.write(scriptTag('document.F=Object'));
    iframeDocument.close();
    return iframeDocument.F;
  }; // Check for document.domain and active x support
  // No need to use active x approach when document.domain is not set
  // see https://github.com/es-shims/es5-shim/issues/150
  // variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
  // avoid IE GC bug


  var activeXDocument;

  var _NullProtoObject = function NullProtoObject() {
    try {
      /* global ActiveXObject */
      activeXDocument = document.domain && new ActiveXObject('htmlfile');
    } catch (error) {
      /* ignore */
    }

    _NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
    var length = enumBugKeys.length;

    while (length--) {
      delete _NullProtoObject[PROTOTYPE][enumBugKeys[length]];
    }

    return _NullProtoObject();
  };

  hiddenKeys[IE_PROTO] = true; // `Object.create` method
  // https://tc39.github.io/ecma262/#sec-object.create

  var objectCreate = Object.create || function create(O, Properties) {
    var result;

    if (O !== null) {
      EmptyConstructor[PROTOTYPE] = anObject(O);
      result = new EmptyConstructor();
      EmptyConstructor[PROTOTYPE] = null; // add "__proto__" for Object.getPrototypeOf polyfill

      result[IE_PROTO] = O;
    } else result = _NullProtoObject();

    return Properties === undefined ? result : objectDefineProperties(result, Properties);
  };

  var slice = [].slice;
  var factories = {};

  var construct = function construct(C, argsLength, args) {
    if (!(argsLength in factories)) {
      for (var list = [], i = 0; i < argsLength; i++) {
        list[i] = 'a[' + i + ']';
      } // eslint-disable-next-line no-new-func


      factories[argsLength] = Function('C,a', 'return new C(' + list.join(',') + ')');
    }

    return factories[argsLength](C, args);
  }; // `Function.prototype.bind` method implementation
  // https://tc39.github.io/ecma262/#sec-function.prototype.bind


  var functionBind = Function.bind || function bind(that
  /* , ...args */
  ) {
    var fn = aFunction$1(this);
    var partArgs = slice.call(arguments, 1);

    var boundFunction = function bound()
    /* args... */
    {
      var args = partArgs.concat(slice.call(arguments));
      return this instanceof boundFunction ? construct(fn, args.length, args) : fn.apply(that, args);
    };

    if (isObject(fn.prototype)) boundFunction.prototype = fn.prototype;
    return boundFunction;
  };

  var nativeConstruct = getBuiltIn('Reflect', 'construct'); // `Reflect.construct` method
  // https://tc39.github.io/ecma262/#sec-reflect.construct
  // MS Edge supports only 2 arguments and argumentsList argument is optional
  // FF Nightly sets third argument as `new.target`, but does not create `this` from it

  var NEW_TARGET_BUG = fails(function () {
    function F() {
      /* empty */
    }

    return !(nativeConstruct(function () {
      /* empty */
    }, [], F) instanceof F);
  });
  var ARGS_BUG = !fails(function () {
    nativeConstruct(function () {
      /* empty */
    });
  });
  var FORCED = NEW_TARGET_BUG || ARGS_BUG;
  _export({
    target: 'Reflect',
    stat: true,
    forced: FORCED,
    sham: FORCED
  }, {
    construct: function construct(Target, args
    /* , newTarget */
    ) {
      aFunction$1(Target);
      anObject(args);
      var newTarget = arguments.length < 3 ? Target : aFunction$1(arguments[2]);
      if (ARGS_BUG && !NEW_TARGET_BUG) return nativeConstruct(Target, args, newTarget);

      if (Target == newTarget) {
        // w/o altered newTarget, optimization for 0-4 arguments
        switch (args.length) {
          case 0:
            return new Target();

          case 1:
            return new Target(args[0]);

          case 2:
            return new Target(args[0], args[1]);

          case 3:
            return new Target(args[0], args[1], args[2]);

          case 4:
            return new Target(args[0], args[1], args[2], args[3]);
        } // w/o altered newTarget, lot of arguments case


        var $args = [null];
        $args.push.apply($args, args);
        return new (functionBind.apply(Target, $args))();
      } // with altered newTarget, not support built-in constructors


      var proto = newTarget.prototype;
      var instance = objectCreate(isObject(proto) ? proto : Object.prototype);
      var result = Function.apply.call(Target, instance, args);
      return isObject(result) ? result : instance;
    }
  });

  var ERROR_INSTEAD_OF_FALSE = fails(function () {
    // eslint-disable-next-line no-undef
    Reflect.defineProperty(objectDefineProperty.f({}, 1, {
      value: 1
    }), 1, {
      value: 2
    });
  }); // `Reflect.defineProperty` method
  // https://tc39.github.io/ecma262/#sec-reflect.defineproperty

  _export({
    target: 'Reflect',
    stat: true,
    forced: ERROR_INSTEAD_OF_FALSE,
    sham: !descriptors
  }, {
    defineProperty: function defineProperty(target, propertyKey, attributes) {
      anObject(target);
      var key = toPrimitive(propertyKey, true);
      anObject(attributes);

      try {
        objectDefineProperty.f(target, key, attributes);
        return true;
      } catch (error) {
        return false;
      }
    }
  });

  var getOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f; // `Reflect.deleteProperty` method
  // https://tc39.github.io/ecma262/#sec-reflect.deleteproperty

  _export({
    target: 'Reflect',
    stat: true
  }, {
    deleteProperty: function deleteProperty(target, propertyKey) {
      var descriptor = getOwnPropertyDescriptor$2(anObject(target), propertyKey);
      return descriptor && !descriptor.configurable ? false : delete target[propertyKey];
    }
  });

  // https://tc39.github.io/ecma262/#sec-toobject

  var toObject = function toObject(argument) {
    return Object(requireObjectCoercible(argument));
  };

  var correctPrototypeGetter = !fails(function () {
    function F() {
      /* empty */
    }

    F.prototype.constructor = null;
    return Object.getPrototypeOf(new F()) !== F.prototype;
  });

  var IE_PROTO$1 = sharedKey('IE_PROTO');
  var ObjectPrototype = Object.prototype; // `Object.getPrototypeOf` method
  // https://tc39.github.io/ecma262/#sec-object.getprototypeof

  var objectGetPrototypeOf = correctPrototypeGetter ? Object.getPrototypeOf : function (O) {
    O = toObject(O);
    if (has(O, IE_PROTO$1)) return O[IE_PROTO$1];

    if (typeof O.constructor == 'function' && O instanceof O.constructor) {
      return O.constructor.prototype;
    }

    return O instanceof Object ? ObjectPrototype : null;
  };

  // https://tc39.github.io/ecma262/#sec-reflect.get

  function get$1(target, propertyKey
  /* , receiver */
  ) {
    var receiver = arguments.length < 3 ? target : arguments[2];
    var descriptor, prototype;
    if (anObject(target) === receiver) return target[propertyKey];
    if (descriptor = objectGetOwnPropertyDescriptor.f(target, propertyKey)) return has(descriptor, 'value') ? descriptor.value : descriptor.get === undefined ? undefined : descriptor.get.call(receiver);
    if (isObject(prototype = objectGetPrototypeOf(target))) return get$1(prototype, propertyKey, receiver);
  }

  _export({
    target: 'Reflect',
    stat: true
  }, {
    get: get$1
  });

  // https://tc39.github.io/ecma262/#sec-reflect.getownpropertydescriptor

  _export({
    target: 'Reflect',
    stat: true,
    sham: !descriptors
  }, {
    getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
      return objectGetOwnPropertyDescriptor.f(anObject(target), propertyKey);
    }
  });

  // https://tc39.github.io/ecma262/#sec-reflect.getprototypeof

  _export({
    target: 'Reflect',
    stat: true,
    sham: !correctPrototypeGetter
  }, {
    getPrototypeOf: function getPrototypeOf(target) {
      return objectGetPrototypeOf(anObject(target));
    }
  });

  // https://tc39.github.io/ecma262/#sec-reflect.has

  _export({
    target: 'Reflect',
    stat: true
  }, {
    has: function has(target, propertyKey) {
      return propertyKey in target;
    }
  });

  var objectIsExtensible = Object.isExtensible; // `Reflect.isExtensible` method
  // https://tc39.github.io/ecma262/#sec-reflect.isextensible

  _export({
    target: 'Reflect',
    stat: true
  }, {
    isExtensible: function isExtensible(target) {
      anObject(target);
      return objectIsExtensible ? objectIsExtensible(target) : true;
    }
  });

  // https://tc39.github.io/ecma262/#sec-reflect.ownkeys

  _export({
    target: 'Reflect',
    stat: true
  }, {
    ownKeys: ownKeys
  });

  var freezing = !fails(function () {
    return Object.isExtensible(Object.preventExtensions({}));
  });

  // https://tc39.github.io/ecma262/#sec-reflect.preventextensions

  _export({
    target: 'Reflect',
    stat: true,
    sham: !freezing
  }, {
    preventExtensions: function preventExtensions(target) {
      anObject(target);

      try {
        var objectPreventExtensions = getBuiltIn('Object', 'preventExtensions');
        if (objectPreventExtensions) objectPreventExtensions(target);
        return true;
      } catch (error) {
        return false;
      }
    }
  });

  // https://tc39.github.io/ecma262/#sec-reflect.set

  function set$2(target, propertyKey, V
  /* , receiver */
  ) {
    var receiver = arguments.length < 4 ? target : arguments[3];
    var ownDescriptor = objectGetOwnPropertyDescriptor.f(anObject(target), propertyKey);
    var existingDescriptor, prototype;

    if (!ownDescriptor) {
      if (isObject(prototype = objectGetPrototypeOf(target))) {
        return set$2(prototype, propertyKey, V, receiver);
      }

      ownDescriptor = createPropertyDescriptor(0);
    }

    if (has(ownDescriptor, 'value')) {
      if (ownDescriptor.writable === false || !isObject(receiver)) return false;

      if (existingDescriptor = objectGetOwnPropertyDescriptor.f(receiver, propertyKey)) {
        if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false;
        existingDescriptor.value = V;
        objectDefineProperty.f(receiver, propertyKey, existingDescriptor);
      } else objectDefineProperty.f(receiver, propertyKey, createPropertyDescriptor(0, V));

      return true;
    }

    return ownDescriptor.set === undefined ? false : (ownDescriptor.set.call(receiver, V), true);
  } // MS Edge 17-18 Reflect.set allows setting the property to object
  // with non-writable property on the prototype


  var MS_EDGE_BUG = fails(function () {
    var object = objectDefineProperty.f({}, 'a', {
      configurable: true
    }); // eslint-disable-next-line no-undef

    return Reflect.set(objectGetPrototypeOf(object), 'a', 1, object) !== false;
  });
  _export({
    target: 'Reflect',
    stat: true,
    forced: MS_EDGE_BUG
  }, {
    set: set$2
  });

  var aPossiblePrototype = function aPossiblePrototype(it) {
    if (!isObject(it) && it !== null) {
      throw TypeError("Can't set " + String(it) + ' as a prototype');
    }

    return it;
  };

  // https://tc39.github.io/ecma262/#sec-object.setprototypeof
  // Works with __proto__ only. Old v8 can't work with null proto objects.

  /* eslint-disable no-proto */

  var objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {
    var CORRECT_SETTER = false;
    var test = {};
    var setter;

    try {
      setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;
      setter.call(test, []);
      CORRECT_SETTER = test instanceof Array;
    } catch (error) {
      /* empty */
    }

    return function setPrototypeOf(O, proto) {
      anObject(O);
      aPossiblePrototype(proto);
      if (CORRECT_SETTER) setter.call(O, proto);else O.__proto__ = proto;
      return O;
    };
  }() : undefined);

  // https://tc39.github.io/ecma262/#sec-reflect.setprototypeof

  if (objectSetPrototypeOf) _export({
    target: 'Reflect',
    stat: true
  }, {
    setPrototypeOf: function setPrototypeOf(target, proto) {
      anObject(target);
      aPossiblePrototype(proto);

      try {
        objectSetPrototypeOf(target, proto);
        return true;
      } catch (error) {
        return false;
      }
    }
  });

  var reflect = path.Reflect;

  var nativeSymbol = !!Object.getOwnPropertySymbols && !fails(function () {
    // Chrome 38 Symbol has incorrect toString conversion
    // eslint-disable-next-line no-undef
    return !String(Symbol());
  });

  var useSymbolAsUid = nativeSymbol // eslint-disable-next-line no-undef
  && !Symbol.sham // eslint-disable-next-line no-undef
  && _typeof(Symbol.iterator) == 'symbol';

  var WellKnownSymbolsStore = shared('wks');
  var _Symbol = global_1.Symbol;
  var createWellKnownSymbol = useSymbolAsUid ? _Symbol : _Symbol && _Symbol.withoutSetter || uid;

  var wellKnownSymbol = function wellKnownSymbol(name) {
    if (!has(WellKnownSymbolsStore, name)) {
      if (nativeSymbol && has(_Symbol, name)) WellKnownSymbolsStore[name] = _Symbol[name];else WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);
    }

    return WellKnownSymbolsStore[name];
  };

  var TO_STRING_TAG = wellKnownSymbol('toStringTag');
  var test = {};
  test[TO_STRING_TAG] = 'z';
  var toStringTagSupport = String(test) === '[object z]';

  var TO_STRING_TAG$1 = wellKnownSymbol('toStringTag'); // ES3 wrong here

  var CORRECT_ARGUMENTS = classofRaw(function () {
    return arguments;
  }()) == 'Arguments'; // fallback for IE11 Script Access Denied error

  var tryGet = function tryGet(it, key) {
    try {
      return it[key];
    } catch (error) {
      /* empty */
    }
  }; // getting tag from ES6+ `Object.prototype.toString`


  var classof = toStringTagSupport ? classofRaw : function (it) {
    var O, tag, result;
    return it === undefined ? 'Undefined' : it === null ? 'Null' // @@toStringTag case
    : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG$1)) == 'string' ? tag // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O) // ES3 arguments fallback
    : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;
  };

  // https://tc39.github.io/ecma262/#sec-object.prototype.tostring


  var objectToString = toStringTagSupport ? {}.toString : function toString() {
    return '[object ' + classof(this) + ']';
  };

  // https://tc39.github.io/ecma262/#sec-object.prototype.tostring

  if (!toStringTagSupport) {
    redefine(Object.prototype, 'toString', objectToString, {
      unsafe: true
    });
  }

  var createMethod$1 = function createMethod(CONVERT_TO_STRING) {
    return function ($this, pos) {
      var S = String(requireObjectCoercible($this));
      var position = toInteger(pos);
      var size = S.length;
      var first, second;
      if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
      first = S.charCodeAt(position);
      return first < 0xD800 || first > 0xDBFF || position + 1 === size || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF ? CONVERT_TO_STRING ? S.charAt(position) : first : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
    };
  };

  var stringMultibyte = {
    // `String.prototype.codePointAt` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.codepointat
    codeAt: createMethod$1(false),
    // `String.prototype.at` method
    // https://github.com/mathiasbynens/String.prototype.at
    charAt: createMethod$1(true)
  };

  var ITERATOR = wellKnownSymbol('iterator');
  var BUGGY_SAFARI_ITERATORS = false;

  var returnThis = function returnThis() {
    return this;
  }; // `%IteratorPrototype%` object
  // https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object


  var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

  if ([].keys) {
    arrayIterator = [].keys(); // Safari 8 has buggy iterators w/o `next`

    if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;else {
      PrototypeOfArrayIteratorPrototype = objectGetPrototypeOf(objectGetPrototypeOf(arrayIterator));
      if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
    }
  }

  if (IteratorPrototype == undefined) IteratorPrototype = {}; // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()

  if ( !has(IteratorPrototype, ITERATOR)) {
    createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);
  }

  var iteratorsCore = {
    IteratorPrototype: IteratorPrototype,
    BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
  };

  var defineProperty = objectDefineProperty.f;
  var TO_STRING_TAG$2 = wellKnownSymbol('toStringTag');

  var setToStringTag = function setToStringTag(it, TAG, STATIC) {
    if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG$2)) {
      defineProperty(it, TO_STRING_TAG$2, {
        configurable: true,
        value: TAG
      });
    }
  };

  var iterators = {};

  var IteratorPrototype$1 = iteratorsCore.IteratorPrototype;

  var returnThis$1 = function returnThis() {
    return this;
  };

  var createIteratorConstructor = function createIteratorConstructor(IteratorConstructor, NAME, next) {
    var TO_STRING_TAG = NAME + ' Iterator';
    IteratorConstructor.prototype = objectCreate(IteratorPrototype$1, {
      next: createPropertyDescriptor(1, next)
    });
    setToStringTag(IteratorConstructor, TO_STRING_TAG, false);
    iterators[TO_STRING_TAG] = returnThis$1;
    return IteratorConstructor;
  };

  var IteratorPrototype$2 = iteratorsCore.IteratorPrototype;
  var BUGGY_SAFARI_ITERATORS$1 = iteratorsCore.BUGGY_SAFARI_ITERATORS;
  var ITERATOR$1 = wellKnownSymbol('iterator');
  var KEYS = 'keys';
  var VALUES = 'values';
  var ENTRIES = 'entries';

  var returnThis$2 = function returnThis() {
    return this;
  };

  var defineIterator = function defineIterator(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
    createIteratorConstructor(IteratorConstructor, NAME, next);

    var getIterationMethod = function getIterationMethod(KIND) {
      if (KIND === DEFAULT && defaultIterator) return defaultIterator;
      if (!BUGGY_SAFARI_ITERATORS$1 && KIND in IterablePrototype) return IterablePrototype[KIND];

      switch (KIND) {
        case KEYS:
          return function keys() {
            return new IteratorConstructor(this, KIND);
          };

        case VALUES:
          return function values() {
            return new IteratorConstructor(this, KIND);
          };

        case ENTRIES:
          return function entries() {
            return new IteratorConstructor(this, KIND);
          };
      }

      return function () {
        return new IteratorConstructor(this);
      };
    };

    var TO_STRING_TAG = NAME + ' Iterator';
    var INCORRECT_VALUES_NAME = false;
    var IterablePrototype = Iterable.prototype;
    var nativeIterator = IterablePrototype[ITERATOR$1] || IterablePrototype['@@iterator'] || DEFAULT && IterablePrototype[DEFAULT];
    var defaultIterator = !BUGGY_SAFARI_ITERATORS$1 && nativeIterator || getIterationMethod(DEFAULT);
    var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
    var CurrentIteratorPrototype, methods, KEY; // fix native

    if (anyNativeIterator) {
      CurrentIteratorPrototype = objectGetPrototypeOf(anyNativeIterator.call(new Iterable()));

      if (IteratorPrototype$2 !== Object.prototype && CurrentIteratorPrototype.next) {
        if ( objectGetPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype$2) {
          if (objectSetPrototypeOf) {
            objectSetPrototypeOf(CurrentIteratorPrototype, IteratorPrototype$2);
          } else if (typeof CurrentIteratorPrototype[ITERATOR$1] != 'function') {
            createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR$1, returnThis$2);
          }
        } // Set @@toStringTag to native iterators


        setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true);
      }
    } // fix Array#{values, @@iterator}.name in V8 / FF


    if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
      INCORRECT_VALUES_NAME = true;

      defaultIterator = function values() {
        return nativeIterator.call(this);
      };
    } // define iterator


    if ( IterablePrototype[ITERATOR$1] !== defaultIterator) {
      createNonEnumerableProperty(IterablePrototype, ITERATOR$1, defaultIterator);
    }

    iterators[NAME] = defaultIterator; // export additional methods

    if (DEFAULT) {
      methods = {
        values: getIterationMethod(VALUES),
        keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
        entries: getIterationMethod(ENTRIES)
      };
      if (FORCED) for (KEY in methods) {
        if (BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
          redefine(IterablePrototype, KEY, methods[KEY]);
        }
      } else _export({
        target: NAME,
        proto: true,
        forced: BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME
      }, methods);
    }

    return methods;
  };

  var charAt = stringMultibyte.charAt;
  var STRING_ITERATOR = 'String Iterator';
  var setInternalState = internalState.set;
  var getInternalState = internalState.getterFor(STRING_ITERATOR); // `String.prototype[@@iterator]` method
  // https://tc39.github.io/ecma262/#sec-string.prototype-@@iterator

  defineIterator(String, 'String', function (iterated) {
    setInternalState(this, {
      type: STRING_ITERATOR,
      string: String(iterated),
      index: 0
    }); // `%StringIteratorPrototype%.next` method
    // https://tc39.github.io/ecma262/#sec-%stringiteratorprototype%.next
  }, function next() {
    var state = getInternalState(this);
    var string = state.string;
    var index = state.index;
    var point;
    if (index >= string.length) return {
      value: undefined,
      done: true
    };
    point = charAt(string, index);
    state.index += point.length;
    return {
      value: point,
      done: false
    };
  });

  // iterable DOM collections
  // flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
  var domIterables = {
    CSSRuleList: 0,
    CSSStyleDeclaration: 0,
    CSSValueList: 0,
    ClientRectList: 0,
    DOMRectList: 0,
    DOMStringList: 0,
    DOMTokenList: 1,
    DataTransferItemList: 0,
    FileList: 0,
    HTMLAllCollection: 0,
    HTMLCollection: 0,
    HTMLFormElement: 0,
    HTMLSelectElement: 0,
    MediaList: 0,
    MimeTypeArray: 0,
    NamedNodeMap: 0,
    NodeList: 1,
    PaintRequestList: 0,
    Plugin: 0,
    PluginArray: 0,
    SVGLengthList: 0,
    SVGNumberList: 0,
    SVGPathSegList: 0,
    SVGPointList: 0,
    SVGStringList: 0,
    SVGTransformList: 0,
    SourceBufferList: 0,
    StyleSheetList: 0,
    TextTrackCueList: 0,
    TextTrackList: 0,
    TouchList: 0
  };

  var UNSCOPABLES = wellKnownSymbol('unscopables');
  var ArrayPrototype = Array.prototype; // Array.prototype[@@unscopables]
  // https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables

  if (ArrayPrototype[UNSCOPABLES] == undefined) {
    objectDefineProperty.f(ArrayPrototype, UNSCOPABLES, {
      configurable: true,
      value: objectCreate(null)
    });
  } // add a key to Array.prototype[@@unscopables]


  var addToUnscopables = function addToUnscopables(key) {
    ArrayPrototype[UNSCOPABLES][key] = true;
  };

  var ARRAY_ITERATOR = 'Array Iterator';
  var setInternalState$1 = internalState.set;
  var getInternalState$1 = internalState.getterFor(ARRAY_ITERATOR); // `Array.prototype.entries` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.entries
  // `Array.prototype.keys` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.keys
  // `Array.prototype.values` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.values
  // `Array.prototype[@@iterator]` method
  // https://tc39.github.io/ecma262/#sec-array.prototype-@@iterator
  // `CreateArrayIterator` internal method
  // https://tc39.github.io/ecma262/#sec-createarrayiterator

  var es_array_iterator = defineIterator(Array, 'Array', function (iterated, kind) {
    setInternalState$1(this, {
      type: ARRAY_ITERATOR,
      target: toIndexedObject(iterated),
      // target
      index: 0,
      // next index
      kind: kind // kind

    }); // `%ArrayIteratorPrototype%.next` method
    // https://tc39.github.io/ecma262/#sec-%arrayiteratorprototype%.next
  }, function () {
    var state = getInternalState$1(this);
    var target = state.target;
    var kind = state.kind;
    var index = state.index++;

    if (!target || index >= target.length) {
      state.target = undefined;
      return {
        value: undefined,
        done: true
      };
    }

    if (kind == 'keys') return {
      value: index,
      done: false
    };
    if (kind == 'values') return {
      value: target[index],
      done: false
    };
    return {
      value: [index, target[index]],
      done: false
    };
  }, 'values'); // argumentsList[@@iterator] is %ArrayProto_values%
  // https://tc39.github.io/ecma262/#sec-createunmappedargumentsobject
  // https://tc39.github.io/ecma262/#sec-createmappedargumentsobject

  iterators.Arguments = iterators.Array; // https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables

  addToUnscopables('keys');
  addToUnscopables('values');
  addToUnscopables('entries');

  var ITERATOR$2 = wellKnownSymbol('iterator');
  var TO_STRING_TAG$3 = wellKnownSymbol('toStringTag');
  var ArrayValues = es_array_iterator.values;

  for (var COLLECTION_NAME in domIterables) {
    var Collection = global_1[COLLECTION_NAME];
    var CollectionPrototype = Collection && Collection.prototype;

    if (CollectionPrototype) {
      // some Chrome versions have non-configurable methods on DOMTokenList
      if (CollectionPrototype[ITERATOR$2] !== ArrayValues) try {
        createNonEnumerableProperty(CollectionPrototype, ITERATOR$2, ArrayValues);
      } catch (error) {
        CollectionPrototype[ITERATOR$2] = ArrayValues;
      }

      if (!CollectionPrototype[TO_STRING_TAG$3]) {
        createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG$3, COLLECTION_NAME);
      }

      if (domIterables[COLLECTION_NAME]) for (var METHOD_NAME in es_array_iterator) {
        // some Chrome versions have non-configurable methods on DOMTokenList
        if (CollectionPrototype[METHOD_NAME] !== es_array_iterator[METHOD_NAME]) try {
          createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, es_array_iterator[METHOD_NAME]);
        } catch (error) {
          CollectionPrototype[METHOD_NAME] = es_array_iterator[METHOD_NAME];
        }
      }
    }
  }

  var nativePromiseConstructor = global_1.Promise;

  var redefineAll = function redefineAll(target, src, options) {
    for (var key in src) {
      redefine(target, key, src[key], options);
    }

    return target;
  };

  var SPECIES = wellKnownSymbol('species');

  var setSpecies = function setSpecies(CONSTRUCTOR_NAME) {
    var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
    var defineProperty = objectDefineProperty.f;

    if (descriptors && Constructor && !Constructor[SPECIES]) {
      defineProperty(Constructor, SPECIES, {
        configurable: true,
        get: function get() {
          return this;
        }
      });
    }
  };

  var anInstance = function anInstance(it, Constructor, name) {
    if (!(it instanceof Constructor)) {
      throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');
    }

    return it;
  };

  var ITERATOR$3 = wellKnownSymbol('iterator');
  var ArrayPrototype$1 = Array.prototype; // check on default Array iterator

  var isArrayIteratorMethod = function isArrayIteratorMethod(it) {
    return it !== undefined && (iterators.Array === it || ArrayPrototype$1[ITERATOR$3] === it);
  };

  var functionBindContext = function functionBindContext(fn, that, length) {
    aFunction$1(fn);
    if (that === undefined) return fn;

    switch (length) {
      case 0:
        return function () {
          return fn.call(that);
        };

      case 1:
        return function (a) {
          return fn.call(that, a);
        };

      case 2:
        return function (a, b) {
          return fn.call(that, a, b);
        };

      case 3:
        return function (a, b, c) {
          return fn.call(that, a, b, c);
        };
    }

    return function ()
    /* ...args */
    {
      return fn.apply(that, arguments);
    };
  };

  var ITERATOR$4 = wellKnownSymbol('iterator');

  var getIteratorMethod = function getIteratorMethod(it) {
    if (it != undefined) return it[ITERATOR$4] || it['@@iterator'] || iterators[classof(it)];
  };

  var callWithSafeIterationClosing = function callWithSafeIterationClosing(iterator, fn, value, ENTRIES) {
    try {
      return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value); // 7.4.6 IteratorClose(iterator, completion)
    } catch (error) {
      var returnMethod = iterator['return'];
      if (returnMethod !== undefined) anObject(returnMethod.call(iterator));
      throw error;
    }
  };

  var iterate_1 = createCommonjsModule(function (module) {
    var Result = function Result(stopped, result) {
      this.stopped = stopped;
      this.result = result;
    };

    var iterate = module.exports = function (iterable, fn, that, AS_ENTRIES, IS_ITERATOR) {
      var boundFunction = functionBindContext(fn, that, AS_ENTRIES ? 2 : 1);
      var iterator, iterFn, index, length, result, next, step;

      if (IS_ITERATOR) {
        iterator = iterable;
      } else {
        iterFn = getIteratorMethod(iterable);
        if (typeof iterFn != 'function') throw TypeError('Target is not iterable'); // optimisation for array iterators

        if (isArrayIteratorMethod(iterFn)) {
          for (index = 0, length = toLength(iterable.length); length > index; index++) {
            result = AS_ENTRIES ? boundFunction(anObject(step = iterable[index])[0], step[1]) : boundFunction(iterable[index]);
            if (result && result instanceof Result) return result;
          }

          return new Result(false);
        }

        iterator = iterFn.call(iterable);
      }

      next = iterator.next;

      while (!(step = next.call(iterator)).done) {
        result = callWithSafeIterationClosing(iterator, boundFunction, step.value, AS_ENTRIES);
        if (_typeof(result) == 'object' && result && result instanceof Result) return result;
      }

      return new Result(false);
    };

    iterate.stop = function (result) {
      return new Result(true, result);
    };
  });

  var ITERATOR$5 = wellKnownSymbol('iterator');
  var SAFE_CLOSING = false;

  try {
    var called = 0;
    var iteratorWithReturn = {
      next: function next() {
        return {
          done: !!called++
        };
      },
      'return': function _return() {
        SAFE_CLOSING = true;
      }
    };

    iteratorWithReturn[ITERATOR$5] = function () {
      return this;
    }; // eslint-disable-next-line no-throw-literal


    Array.from(iteratorWithReturn, function () {
      throw 2;
    });
  } catch (error) {
    /* empty */
  }

  var checkCorrectnessOfIteration = function checkCorrectnessOfIteration(exec, SKIP_CLOSING) {
    if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
    var ITERATION_SUPPORT = false;

    try {
      var object = {};

      object[ITERATOR$5] = function () {
        return {
          next: function next() {
            return {
              done: ITERATION_SUPPORT = true
            };
          }
        };
      };

      exec(object);
    } catch (error) {
      /* empty */
    }

    return ITERATION_SUPPORT;
  };

  var SPECIES$1 = wellKnownSymbol('species'); // `SpeciesConstructor` abstract operation
  // https://tc39.github.io/ecma262/#sec-speciesconstructor

  var speciesConstructor = function speciesConstructor(O, defaultConstructor) {
    var C = anObject(O).constructor;
    var S;
    return C === undefined || (S = anObject(C)[SPECIES$1]) == undefined ? defaultConstructor : aFunction$1(S);
  };

  var engineUserAgent = getBuiltIn('navigator', 'userAgent') || '';

  var engineIsIos = /(iphone|ipod|ipad).*applewebkit/i.test(engineUserAgent);

  var location$1 = global_1.location;
  var set$3 = global_1.setImmediate;
  var clear = global_1.clearImmediate;
  var process = global_1.process;
  var MessageChannel = global_1.MessageChannel;
  var Dispatch = global_1.Dispatch;
  var counter = 0;
  var queue = {};
  var ONREADYSTATECHANGE = 'onreadystatechange';
  var defer, channel, port;

  var run = function run(id) {
    // eslint-disable-next-line no-prototype-builtins
    if (queue.hasOwnProperty(id)) {
      var fn = queue[id];
      delete queue[id];
      fn();
    }
  };

  var runner = function runner(id) {
    return function () {
      run(id);
    };
  };

  var listener = function listener(event) {
    run(event.data);
  };

  var post = function post(id) {
    // old engines have not location.origin
    global_1.postMessage(id + '', location$1.protocol + '//' + location$1.host);
  }; // Node.js 0.9+ & IE10+ has setImmediate, otherwise:


  if (!set$3 || !clear) {
    set$3 = function setImmediate(fn) {
      var args = [];
      var i = 1;

      while (arguments.length > i) {
        args.push(arguments[i++]);
      }

      queue[++counter] = function () {
        // eslint-disable-next-line no-new-func
        (typeof fn == 'function' ? fn : Function(fn)).apply(undefined, args);
      };

      defer(counter);
      return counter;
    };

    clear = function clearImmediate(id) {
      delete queue[id];
    }; // Node.js 0.8-


    if (classofRaw(process) == 'process') {
      defer = function defer(id) {
        process.nextTick(runner(id));
      }; // Sphere (JS game engine) Dispatch API

    } else if (Dispatch && Dispatch.now) {
      defer = function defer(id) {
        Dispatch.now(runner(id));
      }; // Browsers with MessageChannel, includes WebWorkers
      // except iOS - https://github.com/zloirock/core-js/issues/624

    } else if (MessageChannel && !engineIsIos) {
      channel = new MessageChannel();
      port = channel.port2;
      channel.port1.onmessage = listener;
      defer = functionBindContext(port.postMessage, port, 1); // Browsers with postMessage, skip WebWorkers
      // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
    } else if (global_1.addEventListener && typeof postMessage == 'function' && !global_1.importScripts && !fails(post)) {
      defer = post;
      global_1.addEventListener('message', listener, false); // IE8-
    } else if (ONREADYSTATECHANGE in documentCreateElement('script')) {
      defer = function defer(id) {
        html.appendChild(documentCreateElement('script'))[ONREADYSTATECHANGE] = function () {
          html.removeChild(this);
          run(id);
        };
      }; // Rest old browsers

    } else {
      defer = function defer(id) {
        setTimeout(runner(id), 0);
      };
    }
  }

  var task = {
    set: set$3,
    clear: clear
  };

  var getOwnPropertyDescriptor$3 = objectGetOwnPropertyDescriptor.f;
  var macrotask = task.set;
  var MutationObserver$1 = global_1.MutationObserver || global_1.WebKitMutationObserver;
  var process$1 = global_1.process;
  var Promise$1 = global_1.Promise;
  var IS_NODE = classofRaw(process$1) == 'process'; // Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`

  var queueMicrotaskDescriptor = getOwnPropertyDescriptor$3(global_1, 'queueMicrotask');
  var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;
  var flush, head, last, notify, toggle, node, promise, then; // modern engines have queueMicrotask method

  if (!queueMicrotask) {
    flush = function flush() {
      var parent, fn;
      if (IS_NODE && (parent = process$1.domain)) parent.exit();

      while (head) {
        fn = head.fn;
        head = head.next;

        try {
          fn();
        } catch (error) {
          if (head) notify();else last = undefined;
          throw error;
        }
      }

      last = undefined;
      if (parent) parent.enter();
    }; // Node.js


    if (IS_NODE) {
      notify = function notify() {
        process$1.nextTick(flush);
      }; // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339

    } else if (MutationObserver$1 && !engineIsIos) {
      toggle = true;
      node = document.createTextNode('');
      new MutationObserver$1(flush).observe(node, {
        characterData: true
      });

      notify = function notify() {
        node.data = toggle = !toggle;
      }; // environments with maybe non-completely correct, but existent Promise

    } else if (Promise$1 && Promise$1.resolve) {
      // Promise.resolve without an argument throws an error in LG WebOS 2
      promise = Promise$1.resolve(undefined);
      then = promise.then;

      notify = function notify() {
        then.call(promise, flush);
      }; // for other environments - macrotask based on:
      // - setImmediate
      // - MessageChannel
      // - window.postMessag
      // - onreadystatechange
      // - setTimeout

    } else {
      notify = function notify() {
        // strange IE + webpack dev server bug - use .call(global)
        macrotask.call(global_1, flush);
      };
    }
  }

  var microtask = queueMicrotask || function (fn) {
    var task = {
      fn: fn,
      next: undefined
    };
    if (last) last.next = task;

    if (!head) {
      head = task;
      notify();
    }

    last = task;
  };

  var PromiseCapability = function PromiseCapability(C) {
    var resolve, reject;
    this.promise = new C(function ($$resolve, $$reject) {
      if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
      resolve = $$resolve;
      reject = $$reject;
    });
    this.resolve = aFunction$1(resolve);
    this.reject = aFunction$1(reject);
  }; // 25.4.1.5 NewPromiseCapability(C)


  var f$5 = function f(C) {
    return new PromiseCapability(C);
  };

  var newPromiseCapability = {
    f: f$5
  };

  var promiseResolve = function promiseResolve(C, x) {
    anObject(C);
    if (isObject(x) && x.constructor === C) return x;
    var promiseCapability = newPromiseCapability.f(C);
    var resolve = promiseCapability.resolve;
    resolve(x);
    return promiseCapability.promise;
  };

  var hostReportErrors = function hostReportErrors(a, b) {
    var console = global_1.console;

    if (console && console.error) {
      arguments.length === 1 ? console.error(a) : console.error(a, b);
    }
  };

  var perform = function perform(exec) {
    try {
      return {
        error: false,
        value: exec()
      };
    } catch (error) {
      return {
        error: true,
        value: error
      };
    }
  };

  var process$2 = global_1.process;
  var versions = process$2 && process$2.versions;
  var v8 = versions && versions.v8;
  var match, version;

  if (v8) {
    match = v8.split('.');
    version = match[0] + match[1];
  } else if (engineUserAgent) {
    match = engineUserAgent.match(/Edge\/(\d+)/);

    if (!match || match[1] >= 74) {
      match = engineUserAgent.match(/Chrome\/(\d+)/);
      if (match) version = match[1];
    }
  }

  var engineV8Version = version && +version;

  var task$1 = task.set;
  var SPECIES$2 = wellKnownSymbol('species');
  var PROMISE = 'Promise';
  var getInternalState$2 = internalState.get;
  var setInternalState$2 = internalState.set;
  var getInternalPromiseState = internalState.getterFor(PROMISE);
  var PromiseConstructor = nativePromiseConstructor;
  var TypeError$1 = global_1.TypeError;
  var document$2 = global_1.document;
  var process$3 = global_1.process;
  var $fetch = getBuiltIn('fetch');
  var newPromiseCapability$1 = newPromiseCapability.f;
  var newGenericPromiseCapability = newPromiseCapability$1;
  var IS_NODE$1 = classofRaw(process$3) == 'process';
  var DISPATCH_EVENT = !!(document$2 && document$2.createEvent && global_1.dispatchEvent);
  var UNHANDLED_REJECTION = 'unhandledrejection';
  var REJECTION_HANDLED = 'rejectionhandled';
  var PENDING = 0;
  var FULFILLED = 1;
  var REJECTED = 2;
  var HANDLED = 1;
  var UNHANDLED = 2;
  var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;
  var FORCED$1 = isForced_1(PROMISE, function () {
    var GLOBAL_CORE_JS_PROMISE = inspectSource(PromiseConstructor) !== String(PromiseConstructor);

    if (!GLOBAL_CORE_JS_PROMISE) {
      // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
      // We can't detect it synchronously, so just check versions
      if (engineV8Version === 66) return true; // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test

      if (!IS_NODE$1 && typeof PromiseRejectionEvent != 'function') return true;
    } // We need Promise#finally in the pure version for preventing prototype pollution
    // deoptimization and performance degradation
    // https://github.com/zloirock/core-js/issues/679

    if (engineV8Version >= 51 && /native code/.test(PromiseConstructor)) return false; // Detect correctness of subclassing with @@species support

    var promise = PromiseConstructor.resolve(1);

    var FakePromise = function FakePromise(exec) {
      exec(function () {
        /* empty */
      }, function () {
        /* empty */
      });
    };

    var constructor = promise.constructor = {};
    constructor[SPECIES$2] = FakePromise;
    return !(promise.then(function () {
      /* empty */
    }) instanceof FakePromise);
  });
  var INCORRECT_ITERATION = FORCED$1 || !checkCorrectnessOfIteration(function (iterable) {
    PromiseConstructor.all(iterable)['catch'](function () {
      /* empty */
    });
  }); // helpers

  var isThenable = function isThenable(it) {
    var then;
    return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
  };

  var notify$1 = function notify(promise, state, isReject) {
    if (state.notified) return;
    state.notified = true;
    var chain = state.reactions;
    microtask(function () {
      var value = state.value;
      var ok = state.state == FULFILLED;
      var index = 0; // variable length - can't use forEach

      while (chain.length > index) {
        var reaction = chain[index++];
        var handler = ok ? reaction.ok : reaction.fail;
        var resolve = reaction.resolve;
        var reject = reaction.reject;
        var domain = reaction.domain;
        var result, then, exited;

        try {
          if (handler) {
            if (!ok) {
              if (state.rejection === UNHANDLED) onHandleUnhandled(promise, state);
              state.rejection = HANDLED;
            }

            if (handler === true) result = value;else {
              if (domain) domain.enter();
              result = handler(value); // can throw

              if (domain) {
                domain.exit();
                exited = true;
              }
            }

            if (result === reaction.promise) {
              reject(TypeError$1('Promise-chain cycle'));
            } else if (then = isThenable(result)) {
              then.call(result, resolve, reject);
            } else resolve(result);
          } else reject(value);
        } catch (error) {
          if (domain && !exited) domain.exit();
          reject(error);
        }
      }

      state.reactions = [];
      state.notified = false;
      if (isReject && !state.rejection) onUnhandled(promise, state);
    });
  };

  var dispatchEvent = function dispatchEvent(name, promise, reason) {
    var event, handler;

    if (DISPATCH_EVENT) {
      event = document$2.createEvent('Event');
      event.promise = promise;
      event.reason = reason;
      event.initEvent(name, false, true);
      global_1.dispatchEvent(event);
    } else event = {
      promise: promise,
      reason: reason
    };

    if (handler = global_1['on' + name]) handler(event);else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);
  };

  var onUnhandled = function onUnhandled(promise, state) {
    task$1.call(global_1, function () {
      var value = state.value;
      var IS_UNHANDLED = isUnhandled(state);
      var result;

      if (IS_UNHANDLED) {
        result = perform(function () {
          if (IS_NODE$1) {
            process$3.emit('unhandledRejection', value, promise);
          } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
        }); // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should

        state.rejection = IS_NODE$1 || isUnhandled(state) ? UNHANDLED : HANDLED;
        if (result.error) throw result.value;
      }
    });
  };

  var isUnhandled = function isUnhandled(state) {
    return state.rejection !== HANDLED && !state.parent;
  };

  var onHandleUnhandled = function onHandleUnhandled(promise, state) {
    task$1.call(global_1, function () {
      if (IS_NODE$1) {
        process$3.emit('rejectionHandled', promise);
      } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
    });
  };

  var bind = function bind(fn, promise, state, unwrap) {
    return function (value) {
      fn(promise, state, value, unwrap);
    };
  };

  var internalReject = function internalReject(promise, state, value, unwrap) {
    if (state.done) return;
    state.done = true;
    if (unwrap) state = unwrap;
    state.value = value;
    state.state = REJECTED;
    notify$1(promise, state, true);
  };

  var internalResolve = function internalResolve(promise, state, value, unwrap) {
    if (state.done) return;
    state.done = true;
    if (unwrap) state = unwrap;

    try {
      if (promise === value) throw TypeError$1("Promise can't be resolved itself");
      var then = isThenable(value);

      if (then) {
        microtask(function () {
          var wrapper = {
            done: false
          };

          try {
            then.call(value, bind(internalResolve, promise, wrapper, state), bind(internalReject, promise, wrapper, state));
          } catch (error) {
            internalReject(promise, wrapper, error, state);
          }
        });
      } else {
        state.value = value;
        state.state = FULFILLED;
        notify$1(promise, state, false);
      }
    } catch (error) {
      internalReject(promise, {
        done: false
      }, error, state);
    }
  }; // constructor polyfill


  if (FORCED$1) {
    // 25.4.3.1 Promise(executor)
    PromiseConstructor = function Promise(executor) {
      anInstance(this, PromiseConstructor, PROMISE);
      aFunction$1(executor);
      Internal.call(this);
      var state = getInternalState$2(this);

      try {
        executor(bind(internalResolve, this, state), bind(internalReject, this, state));
      } catch (error) {
        internalReject(this, state, error);
      }
    }; // eslint-disable-next-line no-unused-vars


    Internal = function Promise(executor) {
      setInternalState$2(this, {
        type: PROMISE,
        done: false,
        notified: false,
        parent: false,
        reactions: [],
        rejection: false,
        state: PENDING,
        value: undefined
      });
    };

    Internal.prototype = redefineAll(PromiseConstructor.prototype, {
      // `Promise.prototype.then` method
      // https://tc39.github.io/ecma262/#sec-promise.prototype.then
      then: function then(onFulfilled, onRejected) {
        var state = getInternalPromiseState(this);
        var reaction = newPromiseCapability$1(speciesConstructor(this, PromiseConstructor));
        reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
        reaction.fail = typeof onRejected == 'function' && onRejected;
        reaction.domain = IS_NODE$1 ? process$3.domain : undefined;
        state.parent = true;
        state.reactions.push(reaction);
        if (state.state != PENDING) notify$1(this, state, false);
        return reaction.promise;
      },
      // `Promise.prototype.catch` method
      // https://tc39.github.io/ecma262/#sec-promise.prototype.catch
      'catch': function _catch(onRejected) {
        return this.then(undefined, onRejected);
      }
    });

    OwnPromiseCapability = function OwnPromiseCapability() {
      var promise = new Internal();
      var state = getInternalState$2(promise);
      this.promise = promise;
      this.resolve = bind(internalResolve, promise, state);
      this.reject = bind(internalReject, promise, state);
    };

    newPromiseCapability.f = newPromiseCapability$1 = function newPromiseCapability(C) {
      return C === PromiseConstructor || C === PromiseWrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
    };

    if ( typeof nativePromiseConstructor == 'function') {
      nativeThen = nativePromiseConstructor.prototype.then; // wrap native Promise#then for native async functions

      redefine(nativePromiseConstructor.prototype, 'then', function then(onFulfilled, onRejected) {
        var that = this;
        return new PromiseConstructor(function (resolve, reject) {
          nativeThen.call(that, resolve, reject);
        }).then(onFulfilled, onRejected); // https://github.com/zloirock/core-js/issues/640
      }, {
        unsafe: true
      }); // wrap fetch result

      if (typeof $fetch == 'function') _export({
        global: true,
        enumerable: true,
        forced: true
      }, {
        // eslint-disable-next-line no-unused-vars
        fetch: function fetch(input
        /* , init */
        ) {
          return promiseResolve(PromiseConstructor, $fetch.apply(global_1, arguments));
        }
      });
    }
  }

  _export({
    global: true,
    wrap: true,
    forced: FORCED$1
  }, {
    Promise: PromiseConstructor
  });
  setToStringTag(PromiseConstructor, PROMISE, false);
  setSpecies(PROMISE);
  PromiseWrapper = getBuiltIn(PROMISE); // statics

  _export({
    target: PROMISE,
    stat: true,
    forced: FORCED$1
  }, {
    // `Promise.reject` method
    // https://tc39.github.io/ecma262/#sec-promise.reject
    reject: function reject(r) {
      var capability = newPromiseCapability$1(this);
      capability.reject.call(undefined, r);
      return capability.promise;
    }
  });
  _export({
    target: PROMISE,
    stat: true,
    forced:  FORCED$1
  }, {
    // `Promise.resolve` method
    // https://tc39.github.io/ecma262/#sec-promise.resolve
    resolve: function resolve(x) {
      return promiseResolve( this, x);
    }
  });
  _export({
    target: PROMISE,
    stat: true,
    forced: INCORRECT_ITERATION
  }, {
    // `Promise.all` method
    // https://tc39.github.io/ecma262/#sec-promise.all
    all: function all(iterable) {
      var C = this;
      var capability = newPromiseCapability$1(C);
      var resolve = capability.resolve;
      var reject = capability.reject;
      var result = perform(function () {
        var $promiseResolve = aFunction$1(C.resolve);
        var values = [];
        var counter = 0;
        var remaining = 1;
        iterate_1(iterable, function (promise) {
          var index = counter++;
          var alreadyCalled = false;
          values.push(undefined);
          remaining++;
          $promiseResolve.call(C, promise).then(function (value) {
            if (alreadyCalled) return;
            alreadyCalled = true;
            values[index] = value;
            --remaining || resolve(values);
          }, reject);
        });
        --remaining || resolve(values);
      });
      if (result.error) reject(result.value);
      return capability.promise;
    },
    // `Promise.race` method
    // https://tc39.github.io/ecma262/#sec-promise.race
    race: function race(iterable) {
      var C = this;
      var capability = newPromiseCapability$1(C);
      var reject = capability.reject;
      var result = perform(function () {
        var $promiseResolve = aFunction$1(C.resolve);
        iterate_1(iterable, function (promise) {
          $promiseResolve.call(C, promise).then(capability.resolve, reject);
        });
      });
      if (result.error) reject(result.value);
      return capability.promise;
    }
  });

  // https://github.com/tc39/proposal-promise-allSettled


  _export({
    target: 'Promise',
    stat: true
  }, {
    allSettled: function allSettled(iterable) {
      var C = this;
      var capability = newPromiseCapability.f(C);
      var resolve = capability.resolve;
      var reject = capability.reject;
      var result = perform(function () {
        var promiseResolve = aFunction$1(C.resolve);
        var values = [];
        var counter = 0;
        var remaining = 1;
        iterate_1(iterable, function (promise) {
          var index = counter++;
          var alreadyCalled = false;
          values.push(undefined);
          remaining++;
          promiseResolve.call(C, promise).then(function (value) {
            if (alreadyCalled) return;
            alreadyCalled = true;
            values[index] = {
              status: 'fulfilled',
              value: value
            };
            --remaining || resolve(values);
          }, function (e) {
            if (alreadyCalled) return;
            alreadyCalled = true;
            values[index] = {
              status: 'rejected',
              reason: e
            };
            --remaining || resolve(values);
          });
        });
        --remaining || resolve(values);
      });
      if (result.error) reject(result.value);
      return capability.promise;
    }
  });

  var NON_GENERIC = !!nativePromiseConstructor && fails(function () {
    nativePromiseConstructor.prototype['finally'].call({
      then: function then() {
        /* empty */
      }
    }, function () {
      /* empty */
    });
  }); // `Promise.prototype.finally` method
  // https://tc39.github.io/ecma262/#sec-promise.prototype.finally

  _export({
    target: 'Promise',
    proto: true,
    real: true,
    forced: NON_GENERIC
  }, {
    'finally': function _finally(onFinally) {
      var C = speciesConstructor(this, getBuiltIn('Promise'));
      var isFunction = typeof onFinally == 'function';
      return this.then(isFunction ? function (x) {
        return promiseResolve(C, onFinally()).then(function () {
          return x;
        });
      } : onFinally, isFunction ? function (e) {
        return promiseResolve(C, onFinally()).then(function () {
          throw e;
        });
      } : onFinally);
    }
  }); // patch native Promise.prototype for native async functions

  if ( typeof nativePromiseConstructor == 'function' && !nativePromiseConstructor.prototype['finally']) {
    redefine(nativePromiseConstructor.prototype, 'finally', getBuiltIn('Promise').prototype['finally']);
  }

  var promise$1 = path.Promise;

  /**
   *  Copyright 2018 Adobe. All rights reserved.
   *  This file is licensed to you under the Apache License, Version 2.0 (the "License");
   *  you may not use this file except in compliance with the License. You may obtain a copy
   *  of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   *  Unless required by applicable law or agreed to in writing, software distributed under
   *  the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   *  OF ANY KIND, either express or implied. See the License for the specific language
   *  governing permissions and limitations under the License.
   */
  // Provides explicit indication of elements receiving focus through keyboard interaction rather than mouse or touch.
  (function (doc) {
    // In case file is imported in SSR context, don't polyfill anything
    if (!doc) {
      return;
    }

    var NAVIGATION_KEYS = ['Tab', 'ArrowUp', 'ArrowRight', 'ArrowDown', 'ArrowLeft', 'Home', 'End', 'PageUp', 'PageDown', 'Enter', ' ', 'Escape',
    /* IE9 and Firefox < 37 */
    'Up', 'Right', 'Down', 'Left', 'Esc'];
    var TEXT_INPUT_TYPES = ['text', 'date', 'datetime-local', 'email', 'month', 'number', 'password', 'search', 'tel', 'time', 'url', 'week'];
    var keyboardFocus = false;
    var elements = doc.getElementsByClassName('focus-ring');

    function onKeydownHandler(event) {
      if (event.ctrlKey || event.altKey || event.metaKey || NAVIGATION_KEYS.indexOf(event.key) === -1) {
        return;
      }

      keyboardFocus = true;

      if (doc.activeElement && doc.activeElement !== doc.body && doc.activeElement.tagName !== 'TEXTAREA' && !(doc.activeElement.tagName === 'INPUT' && TEXT_INPUT_TYPES.indexOf(doc.activeElement.type) !== -1)) {
        doc.activeElement.classList.add('focus-ring');
      }
    }

    function onMousedownHandler() {
      keyboardFocus = false;

      for (var i = 0; i < elements.length; i++) {
        elements[i].classList.remove('focus-ring');
      }
    }

    function onFocusHandler(event) {
      var classList = event.target.classList;

      if (classList && keyboardFocus) {
        classList.add('focus-ring');
      }
    }

    function onBlurHandler(event) {
      var classList = event.target.classList;
      classList && classList.remove('focus-ring');
    }

    doc.addEventListener('keydown', onKeydownHandler, true);
    doc.addEventListener('mousedown', onMousedownHandler, true);
    doc.addEventListener('focus', onFocusHandler, true);
    doc.addEventListener('blur', onBlurHandler, true);
  })(typeof window === "undefined" ? undefined : document);

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  // todo We force the polyfill but ideally we should not load it if not required
  if (window.customElements) {
    window.customElements.forcePolyfill = true;
  }

  (function () {
    var g = new function () {}();
    var aa = new Set("annotation-xml color-profile font-face font-face-src font-face-uri font-face-format font-face-name missing-glyph".split(" "));

    function k(b) {
      var a = aa.has(b);
      b = /^[a-z][.0-9_a-z]*-[\-.0-9_a-z]*$/.test(b);
      return !a && b;
    }

    function l(b) {
      var a = b.isConnected;
      if (void 0 !== a) return a;

      for (; b && !(b.__CE_isImportDocument || b instanceof Document);) {
        b = b.parentNode || (window.ShadowRoot && b instanceof ShadowRoot ? b.host : void 0);
      }

      return !(!b || !(b.__CE_isImportDocument || b instanceof Document));
    }

    function m(b, a) {
      for (; a && a !== b && !a.nextSibling;) {
        a = a.parentNode;
      }

      return a && a !== b ? a.nextSibling : null;
    }

    function n(b, a, d) {
      d = d ? d : new Set();

      for (var c = b; c;) {
        if (c.nodeType === Node.ELEMENT_NODE) {
          var e = c;
          a(e);
          var h = e.localName;

          if ("link" === h && "import" === e.getAttribute("rel")) {
            c = e.import;
            if (c instanceof Node && !d.has(c)) for (d.add(c), c = c.firstChild; c; c = c.nextSibling) {
              n(c, a, d);
            }
            c = m(b, e);
            continue;
          } else if ("template" === h) {
            c = m(b, e);
            continue;
          }

          if (e = e.__CE_shadowRoot) for (e = e.firstChild; e; e = e.nextSibling) {
            n(e, a, d);
          }
        }

        c = c.firstChild ? c.firstChild : m(b, c);
      }
    }

    function p(b, a, d) {
      b[a] = d;
    }

    function q() {
      this.a = new Map();
      this.f = new Map();
      this.m = [];
      this.b = !1;
    }

    function ba(b, a, d) {
      b.a.set(a, d);
      b.f.set(d.constructor, d);
    }

    function r(b, a) {
      b.b = !0;
      b.m.push(a);
    }

    function v(b, a) {
      b.b && n(a, function (a) {
        return w(b, a);
      });
    }

    function w(b, a) {
      if (b.b && !a.__CE_patched) {
        a.__CE_patched = !0;

        for (var d = 0; d < b.m.length; d++) {
          b.m[d](a);
        }
      }
    }

    function x(b, a) {
      var d = [];
      n(a, function (b) {
        return d.push(b);
      });

      for (a = 0; a < d.length; a++) {
        var c = d[a];
        1 === c.__CE_state ? b.connectedCallback(c) : y(b, c);
      }
    }

    function z(b, a) {
      var d = [];
      n(a, function (b) {
        return d.push(b);
      });

      for (a = 0; a < d.length; a++) {
        var c = d[a];
        1 === c.__CE_state && b.disconnectedCallback(c);
      }
    }

    function A(b, a, d) {
      d = d ? d : new Set();
      var c = [];
      n(a, function (e) {
        var a;
        if ("link" === e.localName && "import" === e.getAttribute("rel")) a = e.import, a instanceof Node && "complete" === a.readyState ? (a.__CE_isImportDocument = !0, a.__CE_hasRegistry = !0) : e.addEventListener("load", function () {
          var a = e.import;
          a.__CE_documentLoadHandled || (a.__CE_documentLoadHandled = !0, a.__CE_isImportDocument = !0, a.__CE_hasRegistry = !0, d.delete(a), A(b, a, d));
        });else {
          if (a = e.getAttribute("is")) e.__CE_is = a;
          c.push(e);
        }
      }, d);
      if (b.b) for (a = 0; a < c.length; a++) {
        w(b, c[a]);
      }

      for (a = 0; a < c.length; a++) {
        y(b, c[a]);
      }
    }

    function y(b, a) {
      if (void 0 === a.__CE_state) {
        var d = b.a.get(a.__CE_is || a.localName);

        if (d = d && d.localName === a.localName ? d : null) {
          d.constructionStack.push(a);
          var c = d.constructor;

          try {
            try {
              if (new c() !== a) throw Error("The custom element constructor did not produce the element being upgraded.");
            } finally {
              d.constructionStack.pop();
            }
          } catch (f) {
            throw a.__CE_state = 2, f;
          }

          a.__CE_state = 1;
          a.__CE_definition = d;
          if (d.attributeChangedCallback) for (d = d.observedAttributes, c = 0; c < d.length; c++) {
            var e = d[c],
                h = a.getAttribute(e);
            null !== h && b.attributeChangedCallback(a, e, null, h, null);
          }
          l(a) && b.connectedCallback(a);
        }
      }
    }

    q.prototype.connectedCallback = function (b) {
      var a = b.__CE_definition;
      a.connectedCallback && a.connectedCallback.call(b);
    };

    q.prototype.disconnectedCallback = function (b) {
      var a = b.__CE_definition;
      a.disconnectedCallback && a.disconnectedCallback.call(b);
    };

    q.prototype.attributeChangedCallback = function (b, a, d, c, e) {
      var h = b.__CE_definition;
      h.attributeChangedCallback && -1 < h.observedAttributes.indexOf(a) && h.attributeChangedCallback.call(b, a, d, c, e);
    };

    function B(b, a) {
      this.c = b;
      this.a = a;
      this.b = void 0;
      A(this.c, this.a);
      "loading" === this.a.readyState && (this.b = new MutationObserver(this.f.bind(this)), this.b.observe(this.a, {
        childList: !0,
        subtree: !0
      }));
    }

    function C(b) {
      b.b && b.b.disconnect();
    }

    B.prototype.f = function (b) {
      var a = this.a.readyState;
      "interactive" !== a && "complete" !== a || C(this);

      for (a = 0; a < b.length; a++) {
        for (var d = b[a].addedNodes, c = 0; c < d.length; c++) {
          A(this.c, d[c]);
        }
      }
    };

    function ca() {
      var b = this;
      this.b = this.a = void 0;
      this.f = new Promise(function (a) {
        b.b = a;
        b.a && a(b.a);
      });
    }

    function D(b) {
      if (b.a) throw Error("Already resolved.");
      b.a = void 0;
      b.b && b.b(void 0);
    }

    function E(b) {
      this.i = !1;
      this.c = b;
      this.l = new Map();

      this.j = function (b) {
        return b();
      };

      this.g = !1;
      this.h = [];
      this.s = new B(b, document);
    }

    E.prototype.define = function (b, a, d) {
      var c = this;
      if (!(a instanceof Function)) throw new TypeError("Custom element constructors must be functions.");
      if (!k(b)) throw new SyntaxError("The element name '" + b + "' is not valid.");
      if (this.c.a.get(b)) throw Error("A custom element with name '" + b + "' has already been defined.");
      var e = b;

      if (d && d.extends) {
        if (!this.enableCustomizedBuiltins) throw Error("Customized builtin elements are disabled by default. Set customElements.enableCustomizedBuiltins = true.");
        if (k(d.extends)) throw Error("A customized builtin element may not extend a custom element.");
        if (document.createElement(d.extends) instanceof window.HTMLUnknownElement) throw Error("Cannot extend '" + d.extends + "': is not a real HTML element");
        e = d.extends;
      }

      if (this.i) throw Error("A custom element is already being defined.");
      this.i = !0;
      var h, f, u, t, P;

      try {
        d = function d(b) {
          var a = Q[b];
          if (void 0 !== a && !(a instanceof Function)) throw Error("The '" + b + "' callback must be a function.");
          return a;
        };

        var Q = a.prototype;
        if (!(Q instanceof Object)) throw new TypeError("The custom element constructor's prototype is not an object.");
        h = d("connectedCallback");
        f = d("disconnectedCallback");
        u = d("adoptedCallback");
        t = d("attributeChangedCallback");
        P = a.observedAttributes || [];
      } catch (xa) {
        return;
      } finally {
        this.i = !1;
      }

      ba(this.c, b, {
        name: b,
        localName: e,
        constructor: a,
        connectedCallback: h,
        disconnectedCallback: f,
        adoptedCallback: u,
        attributeChangedCallback: t,
        observedAttributes: P,
        constructionStack: []
      });
      this.h.push(b);
      this.g || (this.g = !0, this.j(function () {
        if (!1 !== c.g) for (c.g = !1, A(c.c, document); 0 < c.h.length;) {
          var b = c.h.shift();
          (b = c.l.get(b)) && D(b);
        }
      }));
    };

    E.prototype.get = function (b) {
      if (b = this.c.a.get(b)) return b.constructor;
    };

    E.prototype.upgradeElement = function (b) {
      y(this.c, b);
    };

    E.prototype.whenDefined = function (b) {
      if (!k(b)) return Promise.reject(new SyntaxError("'" + b + "' is not a valid custom element name."));
      var a = this.l.get(b);
      if (a) return a.f;
      a = new ca();
      this.l.set(b, a);
      this.c.a.get(b) && -1 === this.h.indexOf(b) && D(a);
      return a.f;
    };

    E.prototype.u = function (b) {
      C(this.s);
      var a = this.j;

      this.j = function (d) {
        return b(function () {
          return a(d);
        });
      };
    };

    window.CustomElementRegistry = E;
    E.prototype.define = E.prototype.define;
    E.prototype.get = E.prototype.get;
    E.prototype.whenDefined = E.prototype.whenDefined;
    E.prototype.upgrade = E.prototype.upgradeElement;
    E.prototype.polyfillWrapFlushCallback = E.prototype.u;
    var F = window.Document.prototype.createElement,
        da = window.Document.prototype.createElementNS,
        ea = window.Document.prototype.importNode,
        fa = window.Document.prototype.prepend,
        ga = window.Document.prototype.append,
        G = window.Node.prototype.cloneNode,
        H = window.Node.prototype.appendChild,
        I = window.Node.prototype.insertBefore,
        J = window.Node.prototype.removeChild,
        K = window.Node.prototype.replaceChild,
        L = Object.getOwnPropertyDescriptor(window.Node.prototype, "textContent"),
        M = window.Element.prototype.attachShadow,
        N = Object.getOwnPropertyDescriptor(window.Element.prototype, "innerHTML"),
        O = window.Element.prototype.getAttribute,
        R = window.Element.prototype.setAttribute,
        S = window.Element.prototype.removeAttribute,
        T = window.Element.prototype.getAttributeNS,
        U = window.Element.prototype.setAttributeNS,
        V = window.Element.prototype.removeAttributeNS,
        W = window.Element.prototype.insertAdjacentElement,
        ha = window.Element.prototype.prepend,
        ia = window.Element.prototype.append,
        ja = window.Element.prototype.before,
        ka = window.Element.prototype.after,
        la = window.Element.prototype.replaceWith,
        ma = window.Element.prototype.remove,
        na = window.HTMLElement,
        X = Object.getOwnPropertyDescriptor(window.HTMLElement.prototype, "innerHTML"),
        oa = window.HTMLElement.prototype.insertAdjacentElement,
        pa = {
      Button: window.HTMLButtonElement,
      Canvas: window.HTMLCanvasElement,
      Data: window.HTMLDataElement,
      Head: window.HTMLHeadElement,
      Mod: window.HTMLModElement,
      TableCell: window.HTMLTableCellElement,
      TableCol: window.HTMLTableColElement,
      Anchor: window.HTMLAnchorElement,
      Area: window.HTMLAreaElement,
      Base: window.HTMLBaseElement,
      Body: window.HTMLBodyElement,
      BR: window.HTMLBRElement,
      DataList: window.HTMLDataListElement,
      Details: window.HTMLDetailsElement,
      Dialog: window.HTMLDialogElement,
      Div: window.HTMLDivElement,
      DList: window.HTMLDListElement,
      Embed: window.HTMLEmbedElement,
      FieldSet: window.HTMLFieldSetElement,
      Form: window.HTMLFormElement,
      Heading: window.HTMLHeadingElement,
      HR: window.HTMLHRElement,
      Html: window.HTMLHtmlElement,
      IFrame: window.HTMLIFrameElement,
      Image: window.HTMLImageElement,
      Input: window.HTMLInputElement,
      Keygen: window.HTMLKeygenElement,
      Label: window.HTMLLabelElement,
      Legend: window.HTMLLegendElement,
      LI: window.HTMLLIElement,
      Link: window.HTMLLinkElement,
      Map: window.HTMLMapElement,
      Media: window.HTMLMediaElement,
      Menu: window.HTMLMenuElement,
      MenuItem: window.HTMLMenuItemElement,
      Meta: window.HTMLMetaElement,
      Meter: window.HTMLMeterElement,
      Object: window.HTMLObjectElement,
      OList: window.HTMLOListElement,
      OptGroup: window.HTMLOptGroupElement,
      Option: window.HTMLOptionElement,
      Output: window.HTMLOutputElement,
      Paragraph: window.HTMLParagraphElement,
      Param: window.HTMLParamElement,
      Picture: window.HTMLPictureElement,
      Pre: window.HTMLPreElement,
      Progress: window.HTMLProgressElement,
      Quote: window.HTMLQuoteElement,
      Script: window.HTMLScriptElement,
      Select: window.HTMLSelectElement,
      Slot: window.HTMLSlotElement,
      Source: window.HTMLSourceElement,
      Span: window.HTMLSpanElement,
      Style: window.HTMLStyleElement,
      TableCaption: window.HTMLTableCaptionElement,
      Table: window.HTMLTableElement,
      TableRow: window.HTMLTableRowElement,
      TableSection: window.HTMLTableSectionElement,
      Template: window.HTMLTemplateElement,
      TextArea: window.HTMLTextAreaElement,
      Time: window.HTMLTimeElement,
      Title: window.HTMLTitleElement,
      Track: window.HTMLTrackElement,
      UList: window.HTMLUListElement,
      Unknown: window.HTMLUnknownElement
    };

    function qa() {
      var b = Y;

      window.HTMLElement = function () {
        function a() {
          var a = this.constructor,
              c = b.f.get(a);
          if (!c) throw Error("The custom element being constructed was not registered with `customElements`.");
          var e = c.constructionStack;
          if (!e.length) return e = F.call(document, c.localName), Object.setPrototypeOf(e, a.prototype), e.__CE_state = 1, e.__CE_definition = c, w(b, e), e;
          var c = e.length - 1,
              h = e[c];
          if (h === g) throw Error("The HTMLElement constructor was either called reentrantly for this constructor or called multiple times.");
          e[c] = g;
          Object.setPrototypeOf(h, a.prototype);
          w(b, h);
          return h;
        }

        a.prototype = na.prototype;
        return a;
      }();
    }

    function ra() {
      var b = Y;

      function a(a, e) {
        e && (window[a] = function () {
          function d() {
            var e = this.constructor,
                d = b.f.get(e);
            if (!d) throw Error("The custom element being constructed was not registered with `customElements`.");
            var c = d.constructionStack;
            if (!c.length) return c = F.call(document, d.localName), c.setAttribute("is", d.name), Object.setPrototypeOf(c, e.prototype), c.__CE_state = 1, c.__CE_definition = d, w(b, c), c;
            var d = c.length - 1,
                h = c[d];
            if (h === g) throw Error("The " + a + " constructor was either called reentrantly for this constructor or called multiple times.");
            c[d] = g;
            Object.setPrototypeOf(h, e.prototype);
            w(b, h);
            return h;
          }

          d.prototype = e.prototype;
          return d;
        }());
      }

      for (var d in pa) {
        a("HTML" + d + "Element", pa[d]);
      }
    }

    function sa(b, a, d) {
      a.prepend = function (a) {
        for (var e = [], c = 0; c < arguments.length; ++c) {
          e[c - 0] = arguments[c];
        }

        c = e.filter(function (b) {
          return b instanceof Node && l(b);
        });
        d.o.apply(this, e);

        for (var f = 0; f < c.length; f++) {
          z(b, c[f]);
        }

        if (l(this)) for (c = 0; c < e.length; c++) {
          f = e[c], f instanceof Element && x(b, f);
        }
      };

      a.append = function (a) {
        for (var e = [], c = 0; c < arguments.length; ++c) {
          e[c - 0] = arguments[c];
        }

        c = e.filter(function (b) {
          return b instanceof Node && l(b);
        });
        d.append.apply(this, e);

        for (var f = 0; f < c.length; f++) {
          z(b, c[f]);
        }

        if (l(this)) for (c = 0; c < e.length; c++) {
          f = e[c], f instanceof Element && x(b, f);
        }
      };
    }

    function ta() {
      var b = Y;
      p(Document.prototype, "createElement", function (a, d) {
        if (this.__CE_hasRegistry) {
          var c = b.a.get(d && d.is ? d.is : a);
          if (c) return new c.constructor();
        }

        a = F.call(this, a);
        d && d.is && (a.__CE_is = d.is, a.setAttribute("is", d.is));
        w(b, a);
        return a;
      });
      p(Document.prototype, "importNode", function (a, d) {
        a = ea.call(this, a, d);
        this.__CE_hasRegistry ? A(b, a) : v(b, a);
        return a;
      });
      p(Document.prototype, "createElementNS", function (a, d, c) {
        if (this.__CE_hasRegistry && (null === a || "http://www.w3.org/1999/xhtml" === a)) {
          var e = b.a.get(c && c.is ? c.is : d);
          if (e) return new e.constructor();
        }

        a = da.call(this, a, d);
        c && c.is && (a.__CE_is = c.is, a.setAttribute("is", c.is));
        w(b, a);
        return a;
      });
      sa(b, Document.prototype, {
        o: fa,
        append: ga
      });
    }

    function ua() {
      var b = Y;

      function a(a, c) {
        Object.defineProperty(a, "textContent", {
          enumerable: c.enumerable,
          configurable: !0,
          get: c.get,
          set: function set(a) {
            if (this.nodeType === Node.TEXT_NODE) c.set.call(this, a);else {
              var e = void 0;

              if (this.firstChild) {
                var d = this.childNodes,
                    u = d.length;
                if (0 < u && l(this)) for (var e = Array(u), t = 0; t < u; t++) {
                  e[t] = d[t];
                }
              }

              c.set.call(this, a);
              if (e) for (a = 0; a < e.length; a++) {
                z(b, e[a]);
              }
            }
          }
        });
      }

      p(Node.prototype, "insertBefore", function (a, c) {
        if (a instanceof DocumentFragment) {
          var e = Array.prototype.slice.apply(a.childNodes);
          a = I.call(this, a, c);
          if (l(this)) for (c = 0; c < e.length; c++) {
            x(b, e[c]);
          }
          return a;
        }

        e = l(a);
        c = I.call(this, a, c);
        e && z(b, a);
        l(this) && x(b, a);
        return c;
      });
      p(Node.prototype, "appendChild", function (a) {
        if (a instanceof DocumentFragment) {
          var c = Array.prototype.slice.apply(a.childNodes);
          a = H.call(this, a);
          if (l(this)) for (var e = 0; e < c.length; e++) {
            x(b, c[e]);
          }
          return a;
        }

        c = l(a);
        e = H.call(this, a);
        c && z(b, a);
        l(this) && x(b, a);
        return e;
      });
      p(Node.prototype, "cloneNode", function (a) {
        a = G.call(this, a);
        this.ownerDocument.__CE_hasRegistry ? A(b, a) : v(b, a);
        return a;
      });
      p(Node.prototype, "removeChild", function (a) {
        var c = l(a),
            e = J.call(this, a);
        c && z(b, a);
        return e;
      });
      p(Node.prototype, "replaceChild", function (a, c) {
        if (a instanceof DocumentFragment) {
          var e = Array.prototype.slice.apply(a.childNodes);
          a = K.call(this, a, c);
          if (l(this)) for (z(b, c), c = 0; c < e.length; c++) {
            x(b, e[c]);
          }
          return a;
        }

        var e = l(a),
            d = K.call(this, a, c),
            f = l(this);
        f && z(b, c);
        e && z(b, a);
        f && x(b, a);
        return d;
      });
      L && L.get ? a(Node.prototype, L) : r(b, function (b) {
        a(b, {
          enumerable: !0,
          configurable: !0,
          get: function get() {
            for (var a = [], b = 0; b < this.childNodes.length; b++) {
              a.push(this.childNodes[b].textContent);
            }

            return a.join("");
          },
          set: function set(a) {
            for (; this.firstChild;) {
              J.call(this, this.firstChild);
            }

            H.call(this, document.createTextNode(a));
          }
        });
      });
    }

    function va(b) {
      var a = Element.prototype;

      a.before = function (a) {
        for (var c = [], e = 0; e < arguments.length; ++e) {
          c[e - 0] = arguments[e];
        }

        e = c.filter(function (a) {
          return a instanceof Node && l(a);
        });
        ja.apply(this, c);

        for (var d = 0; d < e.length; d++) {
          z(b, e[d]);
        }

        if (l(this)) for (e = 0; e < c.length; e++) {
          d = c[e], d instanceof Element && x(b, d);
        }
      };

      a.after = function (a) {
        for (var c = [], e = 0; e < arguments.length; ++e) {
          c[e - 0] = arguments[e];
        }

        e = c.filter(function (a) {
          return a instanceof Node && l(a);
        });
        ka.apply(this, c);

        for (var d = 0; d < e.length; d++) {
          z(b, e[d]);
        }

        if (l(this)) for (e = 0; e < c.length; e++) {
          d = c[e], d instanceof Element && x(b, d);
        }
      };

      a.replaceWith = function (a) {
        for (var c = [], e = 0; e < arguments.length; ++e) {
          c[e - 0] = arguments[e];
        }

        var e = c.filter(function (a) {
          return a instanceof Node && l(a);
        }),
            d = l(this);
        la.apply(this, c);

        for (var f = 0; f < e.length; f++) {
          z(b, e[f]);
        }

        if (d) for (z(b, this), e = 0; e < c.length; e++) {
          d = c[e], d instanceof Element && x(b, d);
        }
      };

      a.remove = function () {
        var a = l(this);
        ma.call(this);
        a && z(b, this);
      };
    }

    function wa() {
      var b = Y;

      function a(a, c) {
        Object.defineProperty(a, "innerHTML", {
          enumerable: c.enumerable,
          configurable: !0,
          get: c.get,
          set: function set(a) {
            var e = this,
                d = void 0;
            l(this) && (d = [], n(this, function (a) {
              a !== e && d.push(a);
            }));
            c.set.call(this, a);
            if (d) for (var h = 0; h < d.length; h++) {
              var f = d[h];
              1 === f.__CE_state && b.disconnectedCallback(f);
            }
            this.ownerDocument.__CE_hasRegistry ? A(b, this) : v(b, this);
            return a;
          }
        });
      }

      function d(a, c) {
        p(a, "insertAdjacentElement", function (a, e) {
          var d = l(e);
          a = c.call(this, a, e);
          d && z(b, e);
          l(a) && x(b, e);
          return a;
        });
      }

      M ? p(Element.prototype, "attachShadow", function (a) {
        return this.__CE_shadowRoot = a = M.call(this, a);
      }) : console.warn("Custom Elements: `Element#attachShadow` was not patched.");
      if (N && N.get) a(Element.prototype, N);else if (X && X.get) a(HTMLElement.prototype, X);else {
        var c = F.call(document, "div");
        r(b, function (b) {
          a(b, {
            enumerable: !0,
            configurable: !0,
            get: function get() {
              return G.call(this, !0).innerHTML;
            },
            set: function set(a) {
              var b = "template" === this.localName ? this.content : this;

              for (c.innerHTML = a; 0 < b.childNodes.length;) {
                J.call(b, b.childNodes[0]);
              }

              for (; 0 < c.childNodes.length;) {
                H.call(b, c.childNodes[0]);
              }
            }
          });
        });
      }
      p(Element.prototype, "setAttribute", function (a, c) {
        if (1 !== this.__CE_state) return R.call(this, a, c);
        var e = O.call(this, a);
        R.call(this, a, c);
        c = O.call(this, a);
        b.attributeChangedCallback(this, a.toLowerCase(), e, c, null);
      });
      p(Element.prototype, "setAttributeNS", function (a, c, d) {
        if (1 !== this.__CE_state) return U.call(this, a, c, d);
        var e = T.call(this, a, c);
        U.call(this, a, c, d);
        d = T.call(this, a, c);
        b.attributeChangedCallback(this, c, e, d, a);
      });
      p(Element.prototype, "removeAttribute", function (a) {
        if (1 !== this.__CE_state) return S.call(this, a);
        var c = O.call(this, a);
        S.call(this, a);
        null !== c && b.attributeChangedCallback(this, a.toLowerCase(), c, null, null);
      });
      p(Element.prototype, "removeAttributeNS", function (a, c) {
        if (1 !== this.__CE_state) return V.call(this, a, c);
        var d = T.call(this, a, c);
        V.call(this, a, c);
        var e = T.call(this, a, c);
        d !== e && b.attributeChangedCallback(this, c, d, e, a);
      });
      oa ? d(HTMLElement.prototype, oa) : W ? d(Element.prototype, W) : console.warn("Custom Elements: `Element#insertAdjacentElement` was not patched.");
      sa(b, Element.prototype, {
        o: ha,
        append: ia
      });
      va(b);
    }
    /*
    Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
    This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
    The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
    The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
    Code distributed by Google as part of the polymer project is also
    subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
    */

    var Z = window.customElements;

    if (!Z || Z.forcePolyfill || "function" != typeof Z.define || "function" != typeof Z.get) {
      var Y = new q();
      qa();
      ra();
      ta();
      ua();
      wa();
      document.__CE_hasRegistry = !0;
      var customElements = new E(Y);
      customElements.enableCustomizedBuiltins = true;
      Object.defineProperty(window, "customElements", {
        configurable: !0,
        enumerable: !0,
        value: customElements
      });
    }
  }).call(self);

  var vent = createCommonjsModule(function (module, exports) {
    /*
    Copyright 2018 Adobe. All rights reserved.
    This file is licensed to you under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License. You may obtain a copy
    of the License at http://www.apache.org/licenses/LICENSE-2.0
    Unless required by applicable law or agreed to in writing, software distributed under
    the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
    OF ANY KIND, either express or implied. See the License for the specific language
    governing permissions and limitations under the License.
    */
    (function (root, factory) {
      {
        // CommonJS
        module.exports = factory();
      }
    })(commonjsGlobal, function () {
      // The next ID we'll use for scoped delegation
      var lastID = 0;
      /*
        Matches selectors that are scoped, such as:
          > selector
          :scope > selector
      */

      var scopedSelectorRegex = /^\s*(>|:scope\s*>)/;
      /**
        Check if the first array contains every element in the second array
         @ignore
      */

      function contains(set, subSet) {
        for (var i = 0; i < subSet.length; i++) {
          if (set.indexOf(subSet[i]) === -1) {
            return false;
          }
        }

        return true;
      }
      /**
        Check if the provided selector is scoped (has context)
         @ignore
      */


      function isScoped(selector) {
        return selector && scopedSelectorRegex.test(selector);
      }
      /**
        Replaces the stopPropagation() method of an event object
         @ignore
      */


      function ventStopPropagation() {
        this._ventPropagationStopped = true;
        Event.prototype.stopPropagation.call(this);
      }
      /**
        Replaces the stopImmediatePropagation() method of an event object
         @ignore
      */


      function ventStopImmediatePropagation() {
        this._ventImmediatePropagationStopped = true;
        Event.prototype.stopImmediatePropagation.call(this);
      }
      /**
        Get the right method to match selectors on
         @ignore
      */


      var matchesSelector = function () {
        var proto = Element.prototype;
        var matchesSelector = proto.matches || proto.matchesSelector || proto.webkitMatchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector || proto.oMatchesSelector;

        if (!matchesSelector) {
          throw new Error('Vent: Browser does not support matchesSelector');
        }

        return matchesSelector;
      }();
      /**
        @class Vent
        @classdesc DOM event delegation
         @param {HTMLElement|String} elementOrSelector
          The element or selector indicating the element to use as the delegation root.
      */


      function Vent(elementOrSelector) {
        if (this === root) {
          throw new Error('Vent must be invoked with the new keyword');
        }

        var root;

        if (typeof elementOrSelector === 'string') {
          root = document.querySelector(elementOrSelector);
        } else {
          root = elementOrSelector;
        } // Store a reference to the root element
        // This is the node at which we'll listen to events


        this.root = root; // Map of event names to array of events
        // Don't inherit from Object so we don't collide with properties on its prototype

        this._listenersByType = Object.create(null);
        /*
          A list of all of the listener objects tracked by this instance
          Each item takes the following form:
          {
            eventName: String,
            handler: Function,
            namespaces: Array<string>,
            selector: String | null,
            useCapture: Boolean,
            isScoped: Boolean
          }
        */

        this._allListeners = []; // Ensure listeners always execute in the scope of this instance

        this._executeCaptureListeners = this._executeCaptureListeners.bind(this);
        this._executeBubbleListeners = this._executeBubbleListeners.bind(this); // All Vent instances get an ID

        this._id = this._id || lastID++;
      }
      /**
        Check if the listener should fire on the given rooted target
         @ignore
      */


      Vent.prototype._listenerMatchesRootTarget = function (listener, target) {
        return (// When no selector is provided
          listener.selector === null && // Execute if we've landed on the root
          target === this.root
        );
      };
      /**
        Check if the listener should fire on the given delegated target
         @ignore
      */


      Vent.prototype._listenerMatchesDelegateTarget = function (listener, target) {
        return (// document does not support matches()
          target !== document && // Don't bother with delegation on the root element
          target !== this.root && // Check if the event is delegated
          listener.selector !== null && ( // Only execute  if the selector matches
          // Check if the selector has context
          listener.isScoped ? // Run the match using the root element's ID
          matchesSelector.call(target, '[__vent-id__="' + this._id + '"] ' + listener.selector) // Run the match without context
          : matchesSelector.call(target, listener.selector))
        );
      };
      /**
        Check if the listener matches the given event phase
         @ignore
      */


      Vent.prototype._listenerMatchesEventPhase = function (listener, useCapture) {
        // Check if the event is the in right phase
        return listener.useCapture === useCapture;
      };
      /**
        This function is responsible for checking if listeners should be executed for the current event
         @ignore
      */


      Vent.prototype._executeListenersAtElement = function (target, listeners, event, useCapture) {
        var listener;
        var returnValue; // Execute each listener that meets the criteria

        executeListeners: for (var listenerIndex = 0; listenerIndex < listeners.length; listenerIndex++) {
          listener = listeners[listenerIndex];

          if ( // Do not process events on disabled items #1
          !(event.type === 'click' && target.disabled === true) && ( // Check if the target element matches for this listener
          this._listenerMatchesRootTarget(listener, target) || this._listenerMatchesDelegateTarget(listener, target)) && this._listenerMatchesEventPhase(listener, useCapture)) {
            // Store the target that matches the event currently
            event.matchedTarget = target; // Call handlers in the scope of the delegate target, passing the event along

            returnValue = listener.handler.call(target, event); // Prevent default and stopPropagation if the handler returned false

            if (returnValue === false) {
              event.preventDefault();
              event.stopPropagation();
            }

            if (event._ventImmediatePropagationStopped) {
              // Do not process any more event handlers and stop bubbling
              break executeListeners;
            }
          } // end if

        } // end executeListeners

      };
      /**
        Handles all events added with Vent
         @private
        @memberof Vent
      */


      Vent.prototype._executeCaptureListeners = function (event) {
        var listeners = this._listenersByType[event.type];

        if (!listeners) {
          throw new Error('Vent: _executeListeners called in response to ' + event.type + ', but we are not listening to it');
        }

        if (listeners.length) {
          // Get a copy of the listeners
          // Without this, removing an event inside of a callback will cause errors
          listeners = listeners.slice(); // Decorate the event object so we know when stopPropagation is called

          this._decorateEvent(event); // Get the event's path through the DOM


          var eventPath = this._getPath(event); // Simulate the capture phase by trickling down the target list


          trickleDown: for (var eventPathIndex = eventPath.length - 1; eventPathIndex >= 0; eventPathIndex--) {
            if (!listeners.length) {
              // Stop trickling down if there are no more listeners to execute
              break trickleDown;
            }

            var currentTargetElement = eventPath[eventPathIndex];

            this._executeListenersAtElement(currentTargetElement, listeners, event, true); // Stop if a handler told us to stop trickling down the DOM


            if (event._ventImmediatePropagationStopped || event._ventPropagationStopped) {
              // Stop simulating trickle down
              break trickleDown;
            }
          }
        } // Clean up after Vent
        // We'll be re-decorating the event object in the bubble phase, if the event gets there


        this._undecorateEvent(event);
      };
      /**
        Handles all events added with Vent
         @private
        @memberof Vent
      */


      Vent.prototype._executeBubbleListeners = function (event) {
        var listeners = this._listenersByType[event.type];

        if (!listeners) {
          throw new Error('Vent: _executeListeners called in response to ' + event.type + ', but we are not listening to it');
        }

        if (listeners.length) {
          // Get a copy of the listeners
          // Without this, removing an event inside of a callback will cause errors
          listeners = listeners.slice(); // Decorate the event object so we know when stopPropagation is called

          this._decorateEvent(event);
          /*
            Figure out if the bubble phase should be simulated
             Both focus and blur do not bubble:
              https://developer.mozilla.org/en-US/docs/Web/Events/focus
              https://developer.mozilla.org/en-US/docs/Web/Events/blur
             However, focusin, focusout, change, and other events do.
          */


          var shouldBubble = event.type !== 'focus' && event.type !== 'blur'; // Re-use the event path as calculated during the capture phase

          var eventPath = this._getPath(event); // If listeners remain and propagation was not stopped, simulate the bubble phase by bubbling up the target list


          bubbleUp: for (var eventPathIndex = 0; eventPathIndex < eventPath.length; eventPathIndex++) {
            if (!listeners.length) {
              // Stop bubbling up if there are no more listeners to execute
              break bubbleUp;
            }

            var currentTargetElement = eventPath[eventPathIndex];

            this._executeListenersAtElement(currentTargetElement, listeners, event, false); // Stop simulating the bubble phase if a handler told us to


            if (event._ventImmediatePropagationStopped || event._ventPropagationStopped) {
              break bubbleUp;
            } // If the event shouldn't bubble, only simulate it on the target


            if (!shouldBubble) {
              break bubbleUp;
            }
          }
        } // Clean up after Vent


        this._undecorateEvent(event); // Clear the path


        event['_ventPath' + this._id] = null;
      };
      /**
        Override stopPropagation/stopImmediatePropagation so we know if we should stop processing events
      */


      Vent.prototype._decorateEvent = function (event) {
        event.stopPropagation = ventStopPropagation;
        event.stopImmediatePropagation = ventStopImmediatePropagation;
      };
      /**
        Restore the normal stopPropagation methods
      */


      Vent.prototype._undecorateEvent = function (event) {
        event.stopPropagation = Event.prototype.stopPropagation;
        event.stopImmediatePropagation = Event.prototype.stopImmediatePropagation;
      };
      /**
        Restore the normal stopPropagation methods
      */


      Vent.prototype._getPath = function (event) {
        if (event['_ventPath' + this._id]) {
          return event['_ventPath' + this._id];
        } // If the event was fired on a text node, delegation should assume the target is its parent


        var target = event.target;

        if (target.nodeType === Node.TEXT_NODE) {
          target = target.parentNode;
        } // Build an array of the DOM tree between the root and the element that dispatched the event
        // The HTML specification states that, if the tree is modified during dispatch, the event should bubble as it was before
        // Building this list before we dispatch allows us to simulate that behavior


        var pathEl = target;
        var eventPath = [];

         while (pathEl && pathEl !== this.root) {
          eventPath.push(pathEl);
          pathEl = pathEl.parentNode;
        }

        eventPath.push(this.root);
        event['_ventPath' + this._id] = eventPath;
        return eventPath;
      };
      /**
        Add an event listener.
        @memberof Vent
         @param {String} eventName
          The event name to listen for, including optional namespace(s).
        @param {String} [selector]
          The selector to use for event delegation.
        @param {Function} handler
          The function that will be called when the event is fired.
        @param {Boolean} [useCapture]
          Whether or not to listen during the capturing or bubbling phase.
         @returns {Vent} this, chainable.
      */


      Vent.prototype.on = function (eventName, selector, handler, useCapture) {
        if (typeof selector === 'function') {
          useCapture = handler;
          handler = selector;
          selector = null;
        }

        if (typeof handler !== 'function') {
          throw new Error('Vent: Cannot add listener with non-function handler');
        } // Be null if every falsy (undefined or empty string passed)


        if (!selector) {
          selector = null;
        }

        if (typeof useCapture === 'undefined') {
          // Force useCapture for focus and blur events
          if (eventName === 'focus' || eventName === 'blur') {
            // true by default for focus and blur events only
            useCapture = true;
          } else {
            // false by default
            // This matches the HTML API
            useCapture = false;
          }
        } // Extract namespaces


        var namespaces = null;
        var dotIndex = eventName.indexOf('.');

        if (dotIndex !== -1) {
          namespaces = eventName.slice(dotIndex + 1).split('.');
          eventName = eventName.slice(0, dotIndex);
        } // Get/create the list for the event type


        var listenerList = this._listenersByType[eventName];

        if (!listenerList) {
          listenerList = this._listenersByType[eventName] = []; // Add the actual listener

          this.root.addEventListener(eventName, this._executeCaptureListeners, true);
          this.root.addEventListener(eventName, this._executeBubbleListeners, false);
        } // Set the special ID attribute if the selector is scoped


        var listenerIsScoped = isScoped(selector);

        if (listenerIsScoped) {
          // Normalize selectors so they don't use :scope
          selector = selector.replace(scopedSelectorRegex, '>'); // Store a unique ID and set a special attribute we'll use to scope

          this.root.setAttribute('__vent-id__', this._id);
        } // Create an object with the event's information


        var eventObject = {
          eventName: eventName,
          handler: handler,
          namespaces: namespaces,
          selector: selector,
          useCapture: useCapture,
          isScoped: listenerIsScoped
        }; // Store relative to the current type and with everyone else

        listenerList.push(eventObject);

        this._allListeners.push(eventObject);
      };
      /**
        Remove an event listener.
        @memberof Vent
         @param {String} [eventName]
          The event name to stop listening for, including optional namespace(s).
        @param {String} [selector]
          The selector that was used for event delegation.
        @param {Function} [handler]
          The function that was passed to <code>on()</code>.
        @param {Boolean} [useCapture]
          Only remove listeners with <code>useCapture</code> set to the value passed in.
         @returns {Vent} this, chainable.
      */


      Vent.prototype.off = function (eventName, selector, handler, useCapture) {
        if (typeof selector === 'function') {
          useCapture = handler;
          handler = selector;
          selector = null;
        } // Be null if not provided


        if (typeof eventName === 'undefined') {
          eventName = null;
        }

        if (typeof selector === 'undefined') {
          selector = null;
        }

        if (typeof handler === 'undefined') {
          handler = null;
        }

        if (typeof useCapture === 'undefined') {
          useCapture = null;
        } // Extract namespaces


        var namespaces = null;

        if (eventName) {
          var dotIndex = eventName.indexOf('.');

          if (dotIndex !== -1) {
            namespaces = eventName.slice(dotIndex + 1).split('.');
            eventName = eventName.slice(0, dotIndex);
          }
        } // Be null


        if (eventName === '') {
          eventName = null;
        }

        var listener;
        var index;
        var listeners = this._allListeners;

        for (var i = 0; i < listeners.length; i++) {
          listener = listeners[i];

          if ((eventName === null || listener.eventName === eventName) && (selector === null || listener.selector === selector) && (handler === null || listener.handler === handler) && (useCapture === null || listener.useCapture === useCapture) && ( // Remove matching listeners, regardless of namespace
          namespaces === null || // Listener matches all specified namespaces
          listener.namespaces && contains(listener.namespaces, namespaces))) {
            // Remove the listeners info
            this._allListeners.splice(i, 1); // Array length changed, so check the same index on the next iteration


            i--; // Get index in listenersByType map

            if (!this._listenersByType[listener.eventName]) {
              throw new Error('Vent: Missing listenersByType for ' + listener.eventName);
            } // Find the event info in the other lookup list


            index = this._listenersByType[listener.eventName].indexOf(listener);

            if (index !== -1) {
              var mapList = this._listenersByType[listener.eventName]; // Remove from the map

              mapList.splice(index, 1); // Check if we've removed all the listeners for this event type

              if (mapList.length === 0) {
                // Remove the actual listener, if necessary
                this.root.removeEventListener(listener.eventName, this._executeCaptureListeners, true);
                this.root.removeEventListener(listener.eventName, this._executeBubbleListeners, false); // Avoid using delete operator for performance

                this._listenersByType[listener.eventName] = null;
              }
            } else {
              throw new Error('Vent: Event existed in allEvents, but did not exist in listenersByType');
            } // Don't stop now! We want to remove all matching listeners, so continue to loop

          }
        }

        return this;
      };

      if (typeof CustomEvent === 'function') {
        // Use native CustomEvent on platforms that support it
        // Note: defaultPrevented will not be set correctly if CustomEvent is polyfilled

        /**
          Dispatch a custom event at the root element.
          @memberof Vent
           @param {String} eventName
            The name of the event to dispatch.
          @param {Object} [options]
            CustomEvent options.
          @param {Object} [options.bubbles=true]
            Whether the event should bubble.
          @param {Object} [options.cancelable=true]
            Whether the event should be cancelable.
          @param {Object} [options.detail]
            Data to pass to handlers as <code>event.detail</code>
        */
        Vent.prototype.dispatch = function (eventName, options) {
          options = options || {};

          if (typeof options.bubbles === 'undefined') {
            options.bubbles = true;
          }

          if (typeof options.cancelable === 'undefined') {
            options.cancelable = true;
          }

          var event = new CustomEvent(eventName, options);
          this.root.dispatchEvent(event);
          return event;
        };
      } else {
        // Use createEvent for old browsers
        Vent.prototype.dispatch = function (eventName, options) {
          options = options || {};

          if (typeof options.bubbles === 'undefined') {
            options.bubbles = true;
          }

          if (typeof options.cancelable === 'undefined') {
            options.cancelable = true;
          }

          var event = document.createEvent('CustomEvent');
          event.initCustomEvent(eventName, options.bubbles, options.cancelable, options.detail); // Dispatch the event, checking the return value to see if preventDefault() was called

          var defaultPrevented = !this.root.dispatchEvent(event); // Check if the defaultPrevented status was correctly stored back to the event object

          if (defaultPrevented !== event.defaultPrevented) {
            // dispatchEvent() doesn't correctly set event.defaultPrevented in IE 9
            // However, it does return false if preventDefault() was called
            // Unfortunately, the returned event's defaultPrevented property is read-only
            // We need to work around this such that (patchedEvent instanceof Event) === true
            // First, we'll create an object that uses the event as its prototype
            // This gives us an object we can modify that is still technically an instanceof Event
            var patchedEvent = Object.create(event); // Next, we set the correct value for defaultPrevented on the new object
            // We cannot simply assign defaultPrevented, it causes a "Invalid Calling Object" error in IE 9
            // For some reason, defineProperty doesn't cause this

            Object.defineProperty(patchedEvent, 'defaultPrevented', {
              value: defaultPrevented
            });
            return patchedEvent;
          }

          return event;
        };
      }
      /**
        Destroy this instance, removing all events and references.
        @memberof Vent
      */


      Vent.prototype.destroy = function () {
        if (this.destroyed) {
          // Instance is already destroyed, do nothing
          return;
        } // Remove all events


        this.off(); // Remove all references

        this._listenersByType = null;
        this._allListeners = null;
        this.root = null;
        this.destroyed = true;
      };

      return Vent;
    });
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  // Patch to be able to use document.createElement(tagName, customElement) from custom elements v0
  var documentCreateElement$1 = document.createElement;

  document.createElement = function createElement() {
    if (typeof arguments[1] === 'string') {
      arguments[1] = {
        is: arguments[1]
      };
    }

    return documentCreateElement$1.apply(this, arguments);
  };

  /*! (C) Andrea Giammarchi - @WebReflection - ISC Style License */
  !function (e, t) {

    function n() {
      var e = A.splice(0, A.length);

      for (et = 0; e.length;) {
        e.shift().call(null, e.shift());
      }
    }

    function r(e, t) {
      for (var n = 0, r = e.length; n < r; n++) {
        T(e[n], t);
      }
    }

    function o(e) {
      for (var t, n = 0, r = e.length; n < r; n++) {
        t = e[n], V(t, ae[a(t)]);
      }
    }

    function l(e) {
      return function (t) {
        ke(t) && (T(t, e), ie.length && r(t.querySelectorAll(ie), e));
      };
    }

    function a(e) {
      var t = Ge.call(e, "is"),
          n = e.nodeName.toUpperCase(),
          r = ce.call(le, t ? ne + t.toUpperCase() : te + n);
      return t && -1 < r && !i(n, t) ? -1 : r;
    }

    function i(e, t) {
      return -1 < ie.indexOf(e + '[is="' + t + '"]');
    }

    function u(e) {
      var t = e.currentTarget,
          n = e.attrChange,
          r = e.attrName,
          o = e.target,
          l = e[Q] || 2,
          a = e[W] || 3;
      !at || o && o !== t || !t[j] || "style" === r || e.prevValue === e.newValue && ("" !== e.newValue || n !== l && n !== a) || t[j](r, n === l ? null : e.prevValue, n === a ? null : e.newValue);
    }

    function c(e) {
      var t = l(e);
      return function (e) {
        A.push(t, e.target), et && clearTimeout(et), et = setTimeout(n, 1);
      };
    }

    function s(e) {
      lt && (lt = !1, e.currentTarget.removeEventListener(J, s)), ie.length && r((e.target || y).querySelectorAll(ie), e.detail === B ? B : x), Ue && p();
    }

    function m(e, t) {
      var n = this;
      Xe.call(n, e, t), O.call(n, {
        target: n
      });
    }

    function f(e, t, n) {
      var r = t.apply(e, n),
          l = a(r);
      return -1 < l && V(r, ae[l]), n.pop() && ie.length && o(r.querySelectorAll(ie)), r;
    }

    function d(e, t) {
      Se(e, t), I ? I.observe(e, Ye) : (ot && (e.setAttribute = m, e[_] = D(e), e[k](ee, O)), e[k](Y, u)), e[X] && at && (e.created = !0, e[X](), e.created = !1);
    }

    function p() {
      for (var e, t = 0, n = xe.length; t < n; t++) {
        e = xe[t], ue.contains(e) || (n--, xe.splice(t--, 1), T(e, B));
      }
    }

    function h(e) {
      throw new Error("A " + e + " type is already registered");
    }

    function T(e, t) {
      var n,
          r,
          o = a(e);
      -1 < o && !Ze.call(e, "TEMPLATE") && (S(e, ae[o]), o = 0, t !== x || e[x] ? t !== B || e[B] || (e[x] = !1, e[B] = !0, r = "disconnected", o = 1) : (e[B] = !1, e[x] = !0, r = "connected", o = 1, Ue && ce.call(xe, e) < 0 && xe.push(e)), o && (n = e[t + q] || e[r + q]) && n.call(e));
    }

    function L() {}

    function M(e, t, n) {
      var r = n && n[Z] || "",
          o = t.prototype,
          l = Fe(o),
          a = t.observedAttributes || pe,
          i = {
        prototype: l
      };
      _e(l, X, {
        value: function value() {
          if (Ae) Ae = !1;else if (!this[He]) {
            this[He] = !0, new t(this), o[X] && o[X].call(this);
            var e = Oe[De.get(t)];
            (!be || e.create.length > 1) && H(this);
          }
        }
      }), _e(l, j, {
        value: function value(e) {
          -1 < ce.call(a, e) && o[j] && o[j].apply(this, arguments);
        }
      }), o[z] && _e(l, G, {
        value: o[z]
      }), o[K] && _e(l, $, {
        value: o[K]
      }), r && (i[Z] = r), e = e.toUpperCase(), Oe[e] = {
        constructor: t,
        create: r ? [r, Ie(e)] : [e]
      }, De.set(t, e), y[R](e.toLowerCase(), i), g(e), Ne[e].r();
    }

    function E(e) {
      var t = Oe[e.toUpperCase()];
      return t && t.constructor;
    }

    function v(e) {
      return "string" == typeof e ? e : e && e.is || "";
    }

    function H(e) {
      for (var t, n = e[j], r = n ? e.attributes : pe, o = r.length; o--;) {
        t = r[o], n.call(e, t.name || t.nodeName, null, t.value || t.nodeValue);
      }
    }

    function g(e) {
      return e = e.toUpperCase(), e in Ne || (Ne[e] = {}, Ne[e].p = new we(function (t) {
        Ne[e].r = t;
      })), Ne[e].p;
    }

    function b() {
      ge && delete e.customElements, de(e, "customElements", {
        configurable: !0,
        value: new L()
      }), de(e, "CustomElementRegistry", {
        configurable: !0,
        value: L
      });

      for (var t = w.get(/^HTML[A-Z]*[a-z]/), n = t.length; n--; function (t) {
        var n = e[t];

        if (n) {
          e[t] = function (e) {
            var t, r;
            return e || (e = this), e[He] || (Ae = !0, t = Oe[De.get(e.constructor)], r = be && 1 === t.create.length, e = r ? Reflect.construct(n, pe, t.constructor) : y.createElement.apply(y, t.create), e[He] = !0, Ae = !1, r || H(e)), e;
          }, e[t].prototype = n.prototype;

          try {
            n.prototype.constructor = e[t];
          } catch (r) {
            de(n, He, {
              value: e[t]
            });
          }
        }
      }(t[n])) {
      }

      y.createElement = function (e, t) {
        var n = v(t);
        return n ? We.call(this, e, Ie(n)) : We.call(this, e);
      }, tt || (rt = !0, y[R](""));
    }

    var y = e.document,
        C = e.Object,
        w = function (e) {
      var t,
          n,
          r,
          o,
          l = /^[A-Z]+[a-z]/,
          a = function a(e) {
        var t,
            n = [];

        for (t in u) {
          e.test(t) && n.push(t);
        }

        return n;
      },
          i = function i(e, t) {
        (t = t.toLowerCase()) in u || (u[e] = (u[e] || []).concat(t), u[t] = u[t.toUpperCase()] = e);
      },
          u = (C.create || C)(null),
          c = {};

      for (n in e) {
        for (o in e[n]) {
          for (r = e[n][o], u[o] = r, t = 0; t < r.length; t++) {
            u[r[t].toLowerCase()] = u[r[t].toUpperCase()] = o;
          }
        }
      }

      return c.get = function (e) {
        return "string" == typeof e ? u[e] || (l.test(e) ? [] : "") : a(e);
      }, c.set = function (e, t) {
        return l.test(e) ? i(e, t) : i(t, e), c;
      }, c;
    }({
      collections: {
        HTMLAllCollection: ["all"],
        HTMLCollection: ["forms"],
        HTMLFormControlsCollection: ["elements"],
        HTMLOptionsCollection: ["options"]
      },
      elements: {
        Element: ["element"],
        HTMLAnchorElement: ["a"],
        HTMLAppletElement: ["applet"],
        HTMLAreaElement: ["area"],
        HTMLAttachmentElement: ["attachment"],
        HTMLAudioElement: ["audio"],
        HTMLBRElement: ["br"],
        HTMLBaseElement: ["base"],
        HTMLBodyElement: ["body"],
        HTMLButtonElement: ["button"],
        HTMLCanvasElement: ["canvas"],
        HTMLContentElement: ["content"],
        HTMLDListElement: ["dl"],
        HTMLDataElement: ["data"],
        HTMLDataListElement: ["datalist"],
        HTMLDetailsElement: ["details"],
        HTMLDialogElement: ["dialog"],
        HTMLDirectoryElement: ["dir"],
        HTMLDivElement: ["div"],
        HTMLDocument: ["document"],
        HTMLElement: ["element", "abbr", "address", "article", "aside", "b", "bdi", "bdo", "cite", "code", "command", "dd", "dfn", "dt", "em", "figcaption", "figure", "footer", "header", "i", "kbd", "mark", "nav", "noscript", "rp", "rt", "ruby", "s", "samp", "section", "small", "strong", "sub", "summary", "sup", "u", "var", "wbr"],
        HTMLEmbedElement: ["embed"],
        HTMLFieldSetElement: ["fieldset"],
        HTMLFontElement: ["font"],
        HTMLFormElement: ["form"],
        HTMLFrameElement: ["frame"],
        HTMLFrameSetElement: ["frameset"],
        HTMLHRElement: ["hr"],
        HTMLHeadElement: ["head"],
        HTMLHeadingElement: ["h1", "h2", "h3", "h4", "h5", "h6"],
        HTMLHtmlElement: ["html"],
        HTMLIFrameElement: ["iframe"],
        HTMLImageElement: ["img"],
        HTMLInputElement: ["input"],
        HTMLKeygenElement: ["keygen"],
        HTMLLIElement: ["li"],
        HTMLLabelElement: ["label"],
        HTMLLegendElement: ["legend"],
        HTMLLinkElement: ["link"],
        HTMLMapElement: ["map"],
        HTMLMarqueeElement: ["marquee"],
        HTMLMediaElement: ["media"],
        HTMLMenuElement: ["menu"],
        HTMLMenuItemElement: ["menuitem"],
        HTMLMetaElement: ["meta"],
        HTMLMeterElement: ["meter"],
        HTMLModElement: ["del", "ins"],
        HTMLOListElement: ["ol"],
        HTMLObjectElement: ["object"],
        HTMLOptGroupElement: ["optgroup"],
        HTMLOptionElement: ["option"],
        HTMLOutputElement: ["output"],
        HTMLParagraphElement: ["p"],
        HTMLParamElement: ["param"],
        HTMLPictureElement: ["picture"],
        HTMLPreElement: ["pre"],
        HTMLProgressElement: ["progress"],
        HTMLQuoteElement: ["blockquote", "q", "quote"],
        HTMLScriptElement: ["script"],
        HTMLSelectElement: ["select"],
        HTMLShadowElement: ["shadow"],
        HTMLSlotElement: ["slot"],
        HTMLSourceElement: ["source"],
        HTMLSpanElement: ["span"],
        HTMLStyleElement: ["style"],
        HTMLTableCaptionElement: ["caption"],
        HTMLTableCellElement: ["td", "th"],
        HTMLTableColElement: ["col", "colgroup"],
        HTMLTableElement: ["table"],
        HTMLTableRowElement: ["tr"],
        HTMLTableSectionElement: ["thead", "tbody", "tfoot"],
        HTMLTemplateElement: ["template"],
        HTMLTextAreaElement: ["textarea"],
        HTMLTimeElement: ["time"],
        HTMLTitleElement: ["title"],
        HTMLTrackElement: ["track"],
        HTMLUListElement: ["ul"],
        HTMLUnknownElement: ["unknown", "vhgroupv", "vkeygen"],
        HTMLVideoElement: ["video"]
      },
      nodes: {
        Attr: ["node"],
        Audio: ["audio"],
        CDATASection: ["node"],
        CharacterData: ["node"],
        Comment: ["#comment"],
        Document: ["#document"],
        DocumentFragment: ["#document-fragment"],
        DocumentType: ["node"],
        HTMLDocument: ["#document"],
        Image: ["img"],
        Option: ["option"],
        ProcessingInstruction: ["node"],
        ShadowRoot: ["#shadow-root"],
        Text: ["#text"],
        XMLDocument: ["xml"]
      }
    });

    "object" != _typeof(t) && (t = {
      type: t || "auto"
    });

    var A,
        O,
        N,
        D,
        I,
        F,
        S,
        V,
        P,
        R = "registerElement",
        U = 1e5 * e.Math.random() >> 0,
        _ = "__" + R + U,
        k = "addEventListener",
        x = "attached",
        q = "Callback",
        B = "detached",
        Z = "extends",
        j = "attributeChanged" + q,
        G = x + q,
        z = "connected" + q,
        K = "disconnected" + q,
        X = "created" + q,
        $ = B + q,
        Q = "ADDITION",
        W = "REMOVAL",
        Y = "DOMAttrModified",
        J = "DOMContentLoaded",
        ee = "DOMSubtreeModified",
        te = "<",
        ne = "=",
        re = /^[A-Z][._A-Z0-9]*-[-._A-Z0-9]*$/,
        oe = ["ANNOTATION-XML", "COLOR-PROFILE", "FONT-FACE", "FONT-FACE-SRC", "FONT-FACE-URI", "FONT-FACE-FORMAT", "FONT-FACE-NAME", "MISSING-GLYPH"],
        le = [],
        ae = [],
        ie = "",
        ue = y.documentElement,
        ce = le.indexOf || function (e) {
      for (var t = this.length; t-- && this[t] !== e;) {
      }

      return t;
    },
        se = C.prototype,
        me = se.hasOwnProperty,
        fe = se.isPrototypeOf,
        de = C.defineProperty,
        pe = [],
        he = C.getOwnPropertyDescriptor,
        Te = C.getOwnPropertyNames,
        Le = C.getPrototypeOf,
        Me = C.setPrototypeOf,
        Ee = !!C.__proto__,
        He = "__dreCEv1",
        ge = e.customElements,
        be = !/^force/.test(t.type) && !!(ge && ge.define && ge.get && ge.whenDefined),
        ye = C.create || C,
        Ce = e.Map || function () {
      var e,
          t = [],
          n = [];
      return {
        get: function get(e) {
          return n[ce.call(t, e)];
        },
        set: function set(r, o) {
          e = ce.call(t, r), e < 0 ? n[t.push(r) - 1] = o : n[e] = o;
        }
      };
    },
        we = e.Promise || function (e) {
      function t(e) {
        for (r = !0; n.length;) {
          n.shift()(e);
        }
      }

      var n = [],
          r = !1,
          o = {
        "catch": function _catch() {
          return o;
        },
        then: function then(e) {
          return n.push(e), r && setTimeout(t, 1), o;
        }
      };
      return e(t), o;
    },
        Ae = !1,
        Oe = ye(null),
        Ne = ye(null),
        De = new Ce(),
        Ie = function Ie(e) {
      return e.toLowerCase();
    },
        Fe = C.create || function ct(e) {
      return e ? (ct.prototype = e, new ct()) : this;
    },
        Se = Me || (Ee ? function (e, t) {
      return e.__proto__ = t, e;
    } : Te && he ? function () {
      function e(e, t) {
        for (var n, r = Te(t), o = 0, l = r.length; o < l; o++) {
          n = r[o], me.call(e, n) || de(e, n, he(t, n));
        }
      }

      return function (t, n) {
        do {
          e(t, n);
        } while ((n = Le(n)) && !fe.call(n, t));

        return t;
      };
    }() : function (e, t) {
      for (var n in t) {
        e[n] = t[n];
      }

      return e;
    }),
        Ve = e.MutationObserver || e.WebKitMutationObserver,
        Pe = e.HTMLAnchorElement,
        Re = (e.HTMLElement || e.Element || e.Node).prototype,
        Ue = !fe.call(Re, ue),
        _e = Ue ? function (e, t, n) {
      return e[t] = n.value, e;
    } : de,
        ke = Ue ? function (e) {
      return 1 === e.nodeType;
    } : function (e) {
      return fe.call(Re, e);
    },
        xe = Ue && [],
        qe = Re.attachShadow,
        Be = Re.cloneNode,
        Ze = Re.closest || function (e) {
      for (var t = this; t && t.nodeName !== e;) {
        t = t.parentNode;
      }

      return t;
    },
        je = Re.dispatchEvent,
        Ge = Re.getAttribute,
        ze = Re.hasAttribute,
        Ke = Re.removeAttribute,
        Xe = Re.setAttribute,
        $e = y.createElement,
        Qe = y.importNode,
        We = $e,
        Ye = Ve && {
      attributes: !0,
      characterData: !0,
      attributeOldValue: !0
    },
        Je = Ve || function (e) {
      ot = !1, ue.removeEventListener(Y, Je);
    },
        et = 0,
        tt = R in y && !/^force-all/.test(t.type),
        nt = !0,
        rt = !1,
        ot = !0,
        lt = !0,
        at = !0;

    if (Ve && (P = y.createElement("div"), P.innerHTML = "<div><div></div></div>", new Ve(function (e, t) {
      if (e[0] && "childList" == e[0].type && !e[0].removedNodes[0].childNodes.length) {
        P = he(Re, "innerHTML");
        var n = P && P.set;
        n && de(Re, "innerHTML", {
          set: function set(e) {
            for (; this.lastChild;) {
              this.removeChild(this.lastChild);
            }

            n.call(this, e);
          }
        });
      }

      t.disconnect(), P = null;
    }).observe(P, {
      childList: !0,
      subtree: !0
    }), P.innerHTML = ""), tt || (Me || Ee ? (S = function S(e, t) {
      fe.call(t, e) || d(e, t);
    }, V = d) : (S = function S(e, t) {
      e[_] || (e[_] = C(!0), d(e, t));
    }, V = S), Ue ? (ot = !1, function () {
      var e = he(Re, k),
          t = e.value,
          n = function n(e) {
        var t = new CustomEvent(Y, {
          bubbles: !0
        });
        t.attrName = e, t.prevValue = Ge.call(this, e), t.newValue = null, t[W] = t.attrChange = 2, Ke.call(this, e), je.call(this, t);
      },
          r = function r(e, t) {
        var n = ze.call(this, e),
            r = n && Ge.call(this, e),
            o = new CustomEvent(Y, {
          bubbles: !0
        });
        Xe.call(this, e, t), o.attrName = e, o.prevValue = n ? r : null, o.newValue = t, n ? o.MODIFICATION = o.attrChange = 1 : o[Q] = o.attrChange = 0, je.call(this, o);
      },
          o = function o(e) {
        var t,
            n = e.currentTarget,
            r = n[_],
            o = e.propertyName;
        r.hasOwnProperty(o) && (r = r[o], t = new CustomEvent(Y, {
          bubbles: !0
        }), t.attrName = r.name, t.prevValue = r.value || null, t.newValue = r.value = n[o] || null, null == t.prevValue ? t[Q] = t.attrChange = 0 : t.MODIFICATION = t.attrChange = 1, je.call(n, t));
      };

      e.value = function (e, l, a) {
        e === Y && this[j] && this.setAttribute !== r && (this[_] = {
          className: {
            name: "class",
            value: this.className
          }
        }, this.setAttribute = r, this.removeAttribute = n, t.call(this, "propertychange", o)), t.call(this, e, l, a);
      }, de(Re, k, e);
    }()) : Ve || (ue[k](Y, Je), ue.setAttribute(_, 1), ue.removeAttribute(_), ot && (O = function O(e) {
      var t,
          n,
          r,
          o = this;

      if (o === e.target) {
        t = o[_], o[_] = n = D(o);

        for (r in n) {
          if (!(r in t)) return N(0, o, r, t[r], n[r], Q);
          if (n[r] !== t[r]) return N(1, o, r, t[r], n[r], "MODIFICATION");
        }

        for (r in t) {
          if (!(r in n)) return N(2, o, r, t[r], n[r], W);
        }
      }
    }, N = function N(e, t, n, r, o, l) {
      var a = {
        attrChange: e,
        currentTarget: t,
        attrName: n,
        prevValue: r,
        newValue: o
      };
      a[l] = e, u(a);
    }, D = function D(e) {
      for (var t, n, r = {}, o = e.attributes, l = 0, a = o.length; l < a; l++) {
        t = o[l], "setAttribute" !== (n = t.name) && (r[n] = t.value);
      }

      return r;
    })), y[R] = function (e, t) {
      if (n = e.toUpperCase(), nt && (nt = !1, Ve ? (I = function (e, t) {
        function n(e, t) {
          for (var n = 0, r = e.length; n < r; t(e[n++])) {
          }
        }

        return new Ve(function (r) {
          for (var o, l, a, i = 0, u = r.length; i < u; i++) {
            o = r[i], "childList" === o.type ? (n(o.addedNodes, e), n(o.removedNodes, t)) : (l = o.target, at && l[j] && "style" !== o.attributeName && (a = Ge.call(l, o.attributeName)) !== o.oldValue && l[j](o.attributeName, o.oldValue, a));
          }
        });
      }(l(x), l(B)), F = function F(e) {
        return I.observe(e, {
          childList: !0,
          subtree: !0
        }), e;
      }, F(y), qe && (Re.attachShadow = function () {
        return F(qe.apply(this, arguments));
      })) : (A = [], y[k]("DOMNodeInserted", c(x)), y[k]("DOMNodeRemoved", c(B))), y[k](J, s), y[k]("readystatechange", s), y.importNode = function (e, t) {
        switch (e.nodeType) {
          case 1:
            return f(y, Qe, [e, !!t]);

          case 11:
            for (var n = y.createDocumentFragment(), r = e.childNodes, o = r.length, l = 0; l < o; l++) {
              n.appendChild(y.importNode(r[l], !!t));
            }

            return n;

          default:
            return Be.call(e, !!t);
        }
      }, Re.cloneNode = function (e) {
        return f(this, Be, [!!e]);
      }), rt) return rt = !1;
      if (-2 < ce.call(le, ne + n) + ce.call(le, te + n) && h(e), !re.test(n) || -1 < ce.call(oe, n)) throw new Error("The type " + e + " is invalid");

      var n,
          o,
          a = function a() {
        return u ? y.createElement(m, n) : y.createElement(m);
      },
          i = t || se,
          u = me.call(i, Z),
          m = u ? t[Z].toUpperCase() : n;

      return u && -1 < ce.call(le, te + m) && h(m), o = le.push((u ? ne : te) + n) - 1, ie = ie.concat(ie.length ? "," : "", u ? m + '[is="' + e.toLowerCase() + '"]' : m), a.prototype = ae[o] = me.call(i, "prototype") ? i.prototype : Fe(Re), ie.length && r(y.querySelectorAll(ie), x), a;
    }, y.createElement = We = function We(e, t) {
      var n = v(t),
          r = n ? $e.call(y, e, Ie(n)) : $e.call(y, e),
          o = "" + e,
          l = ce.call(le, (n ? ne : te) + (n || o).toUpperCase()),
          a = -1 < l;
      return n && (r.setAttribute("is", n = n.toLowerCase()), a && (a = i(o.toUpperCase(), n))), at = !y.createElement.innerHTMLHelper, a && V(r, ae[l]), r;
    }), addEventListener("beforeunload", function () {
      delete y.createElement, delete y.importNode, delete y[R];
    }, !1), L.prototype = {
      constructor: L,
      define: be ? function (e, t, n) {
        if (n) M(e, t, n);else {
          var r = e.toUpperCase();
          Oe[r] = {
            constructor: t,
            create: [r]
          }, De.set(t, r), ge.define(e, t);
        }
      } : M,
      get: be ? function (e) {
        return ge.get(e) || E(e);
      } : E,
      whenDefined: be ? function (e) {
        return we.race([ge.whenDefined(e), g(e)]);
      } : g
    }, !ge || /^force/.test(t.type)) b();else if (!t.noBuiltIn) try {
      !function (t, n, r) {
        var o = new RegExp("^<a\\s+is=('|\")" + r + "\\1></a>$");
        if (n[Z] = "a", t.prototype = Fe(Pe.prototype), t.prototype.constructor = t, e.customElements.define(r, t, n), !o.test(y.createElement("a", {
          is: r
        }).outerHTML) || !o.test(new t().outerHTML)) throw n;
      }(function st() {
        return Reflect.construct(Pe, [], st);
      }, {}, "document-register-element-a" + U);
    } catch (it) {
      b();
    }
    if (!t.noBuiltIn) try {
      if ($e.call(y, "a", "a").outerHTML.indexOf("is") < 0) throw {};
    } catch (ut) {
      Ie = function Ie(e) {
        return {
          is: e.toLowerCase()
        };
      };
    }
  }(window);

  /*! (C) Andrea Giammarchi - @WebReflection - ISC Style License */
  var innerHTML = function (e) {
    var t,
        r,
        n = e.registerElement,
        a = e.createElement("div"),
        l = "document-register-element",
        i = n.innerHTML;
    if (i) return i;

    try {
      if (n.call(e, l, {
        prototype: Object.create(HTMLElement.prototype, {
          createdCallback: {
            value: Object
          }
        })
      }), a.innerHTML = "<" + l + "></" + l + ">", "createdCallback" in a.querySelector(l)) return n.innerHTML = function (e, t) {
        return e.innerHTML = t, e;
      };
    } catch (c) {}

    return r = [], t = function t(_t) {
      if (!("createdCallback" in _t || "attachedCallback" in _t || "detachedCallback" in _t || "attributeChangedCallback" in _t)) {
        e.createElement.innerHTMLHelper = !0;

        for (var r, n, a = _t.parentNode, l = _t.getAttribute("is"), i = _t.nodeName, c = e.createElement.apply(e, l ? [i, l] : [i]), d = _t.attributes, u = 0, o = d.length; u < o; u++) {
          r = d[u], c.setAttribute(r.name, r.value);
        }

        for (; n = _t.firstChild;) {
          c.appendChild(n);
        }

        e.createElement.innerHTMLHelper = !1, a && a.replaceChild(c, _t), c.createdCallback && (c.created = !0, c.createdCallback(), c.created = !1);
      }
    }, (e.registerElement = function (t, a) {
      var l = (a["extends"] ? a["extends"] + '[is="' + t + '"]' : t).toLowerCase();
      return r.indexOf(l) < 0 && r.push(l), n.apply(e, arguments);
    }).innerHTML = function (e, n) {
      e.innerHTML = n;

      for (var a = r.length ? e.querySelectorAll(r.join(",")) : [], l = a.length; l--; t(a[l])) {
      }

      return e;
    };
  }(document);

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /* eslint-disable-next-line no-empty-function */
  var f$6 = function f() {}; // Mostly empty functions to avoid breaking code


  if (!window.CustomElements) {
    window.CustomElements = {
      flags: {}
    };
    window.CustomElements.upgrade = f$6;
    window.CustomElements.upgradeAll = f$6;

    window.CustomElements.instanceof = function (el, ins) {
      return el instanceof ins;
    };

    window.CustomElements.upgradeDocumentTree = f$6;
    window.CustomElements.upgradeSubtree = f$6;
    window.CustomElements.addModule = f$6;
    window.CustomElements.initializeModules = f$6;
    window.CustomElements.takeRecords = f$6;
    window.CustomElements.takeRecords = f$6;
    window.CustomElements.watchShadow = f$6;
  }

  var ResizeObserver = createCommonjsModule(function (module, exports) {
    (function (global, factory) {
       module.exports = factory() ;
    })(commonjsGlobal, function () {
      /**
       * A collection of shims that provide minimal functionality of the ES6 collections.
       *
       * These implementations are not meant to be used outside of the ResizeObserver
       * modules as they cover only a limited range of use cases.
       */

      /* eslint-disable require-jsdoc, valid-jsdoc */

      var MapShim = function () {
        if (typeof Map !== 'undefined') {
          return Map;
        }
        /**
         * Returns index in provided array that matches the specified key.
         *
         * @param {Array<Array>} arr
         * @param {*} key
         * @returns {number}
         */


        function getIndex(arr, key) {
          var result = -1;
          arr.some(function (entry, index) {
            if (entry[0] === key) {
              result = index;
              return true;
            }

            return false;
          });
          return result;
        }

        return (
          /** @class */
          function () {
            function class_1() {
              this.__entries__ = [];
            }

            Object.defineProperty(class_1.prototype, "size", {
              /**
               * @returns {boolean}
               */
              get: function get() {
                return this.__entries__.length;
              },
              enumerable: true,
              configurable: true
            });
            /**
             * @param {*} key
             * @returns {*}
             */

            class_1.prototype.get = function (key) {
              var index = getIndex(this.__entries__, key);
              var entry = this.__entries__[index];
              return entry && entry[1];
            };
            /**
             * @param {*} key
             * @param {*} value
             * @returns {void}
             */


            class_1.prototype.set = function (key, value) {
              var index = getIndex(this.__entries__, key);

              if (~index) {
                this.__entries__[index][1] = value;
              } else {
                this.__entries__.push([key, value]);
              }
            };
            /**
             * @param {*} key
             * @returns {void}
             */


            class_1.prototype.delete = function (key) {
              var entries = this.__entries__;
              var index = getIndex(entries, key);

              if (~index) {
                entries.splice(index, 1);
              }
            };
            /**
             * @param {*} key
             * @returns {void}
             */


            class_1.prototype.has = function (key) {
              return !!~getIndex(this.__entries__, key);
            };
            /**
             * @returns {void}
             */


            class_1.prototype.clear = function () {
              this.__entries__.splice(0);
            };
            /**
             * @param {Function} callback
             * @param {*} [ctx=null]
             * @returns {void}
             */


            class_1.prototype.forEach = function (callback, ctx) {
              if (ctx === void 0) {
                ctx = null;
              }

              for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
                var entry = _a[_i];
                callback.call(ctx, entry[1], entry[0]);
              }
            };

            return class_1;
          }()
        );
      }();
      /**
       * Detects whether window and document objects are available in current environment.
       */


      var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document; // Returns global object of a current environment.

      var global$1 = function () {
        if (typeof commonjsGlobal !== 'undefined' && commonjsGlobal.Math === Math) {
          return commonjsGlobal;
        }

        if (typeof self !== 'undefined' && self.Math === Math) {
          return self;
        }

        if (typeof window !== 'undefined' && window.Math === Math) {
          return window;
        } // eslint-disable-next-line no-new-func


        return Function('return this')();
      }();
      /**
       * A shim for the requestAnimationFrame which falls back to the setTimeout if
       * first one is not supported.
       *
       * @returns {number} Requests' identifier.
       */


      var requestAnimationFrame$1 = function () {
        if (typeof requestAnimationFrame === 'function') {
          // It's required to use a bounded function because IE sometimes throws
          // an "Invalid calling object" error if rAF is invoked without the global
          // object on the left hand side.
          return requestAnimationFrame.bind(global$1);
        }

        return function (callback) {
          return setTimeout(function () {
            return callback(Date.now());
          }, 1000 / 60);
        };
      }(); // Defines minimum timeout before adding a trailing call.


      var trailingTimeout = 2;
      /**
       * Creates a wrapper function which ensures that provided callback will be
       * invoked only once during the specified delay period.
       *
       * @param {Function} callback - Function to be invoked after the delay period.
       * @param {number} delay - Delay after which to invoke callback.
       * @returns {Function}
       */

      function throttle(callback, delay) {
        var leadingCall = false,
            trailingCall = false,
            lastCallTime = 0;
        /**
         * Invokes the original callback function and schedules new invocation if
         * the "proxy" was called during current request.
         *
         * @returns {void}
         */

        function resolvePending() {
          if (leadingCall) {
            leadingCall = false;
            callback();
          }

          if (trailingCall) {
            proxy();
          }
        }
        /**
         * Callback invoked after the specified delay. It will further postpone
         * invocation of the original function delegating it to the
         * requestAnimationFrame.
         *
         * @returns {void}
         */


        function timeoutCallback() {
          requestAnimationFrame$1(resolvePending);
        }
        /**
         * Schedules invocation of the original function.
         *
         * @returns {void}
         */


        function proxy() {
          var timeStamp = Date.now();

          if (leadingCall) {
            // Reject immediately following calls.
            if (timeStamp - lastCallTime < trailingTimeout) {
              return;
            } // Schedule new call to be in invoked when the pending one is resolved.
            // This is important for "transitions" which never actually start
            // immediately so there is a chance that we might miss one if change
            // happens amids the pending invocation.


            trailingCall = true;
          } else {
            leadingCall = true;
            trailingCall = false;
            setTimeout(timeoutCallback, delay);
          }

          lastCallTime = timeStamp;
        }

        return proxy;
      } // Minimum delay before invoking the update of observers.


      var REFRESH_DELAY = 20; // A list of substrings of CSS properties used to find transition events that
      // might affect dimensions of observed elements.

      var transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight']; // Check if MutationObserver is available.

      var mutationObserverSupported = typeof MutationObserver !== 'undefined';
      /**
       * Singleton controller class which handles updates of ResizeObserver instances.
       */

      var ResizeObserverController =
      /** @class */
      function () {
        /**
         * Creates a new instance of ResizeObserverController.
         *
         * @private
         */
        function ResizeObserverController() {
          /**
           * Indicates whether DOM listeners have been added.
           *
           * @private {boolean}
           */
          this.connected_ = false;
          /**
           * Tells that controller has subscribed for Mutation Events.
           *
           * @private {boolean}
           */

          this.mutationEventsAdded_ = false;
          /**
           * Keeps reference to the instance of MutationObserver.
           *
           * @private {MutationObserver}
           */

          this.mutationsObserver_ = null;
          /**
           * A list of connected observers.
           *
           * @private {Array<ResizeObserverSPI>}
           */

          this.observers_ = [];
          this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
          this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
        }
        /**
         * Adds observer to observers list.
         *
         * @param {ResizeObserverSPI} observer - Observer to be added.
         * @returns {void}
         */


        ResizeObserverController.prototype.addObserver = function (observer) {
          if (!~this.observers_.indexOf(observer)) {
            this.observers_.push(observer);
          } // Add listeners if they haven't been added yet.


          if (!this.connected_) {
            this.connect_();
          }
        };
        /**
         * Removes observer from observers list.
         *
         * @param {ResizeObserverSPI} observer - Observer to be removed.
         * @returns {void}
         */


        ResizeObserverController.prototype.removeObserver = function (observer) {
          var observers = this.observers_;
          var index = observers.indexOf(observer); // Remove observer if it's present in registry.

          if (~index) {
            observers.splice(index, 1);
          } // Remove listeners if controller has no connected observers.


          if (!observers.length && this.connected_) {
            this.disconnect_();
          }
        };
        /**
         * Invokes the update of observers. It will continue running updates insofar
         * it detects changes.
         *
         * @returns {void}
         */


        ResizeObserverController.prototype.refresh = function () {
          var changesDetected = this.updateObservers_(); // Continue running updates if changes have been detected as there might
          // be future ones caused by CSS transitions.

          if (changesDetected) {
            this.refresh();
          }
        };
        /**
         * Updates every observer from observers list and notifies them of queued
         * entries.
         *
         * @private
         * @returns {boolean} Returns "true" if any observer has detected changes in
         *      dimensions of it's elements.
         */


        ResizeObserverController.prototype.updateObservers_ = function () {
          // Collect observers that have active observations.
          var activeObservers = this.observers_.filter(function (observer) {
            return observer.gatherActive(), observer.hasActive();
          }); // Deliver notifications in a separate cycle in order to avoid any
          // collisions between observers, e.g. when multiple instances of
          // ResizeObserver are tracking the same element and the callback of one
          // of them changes content dimensions of the observed target. Sometimes
          // this may result in notifications being blocked for the rest of observers.

          activeObservers.forEach(function (observer) {
            return observer.broadcastActive();
          });
          return activeObservers.length > 0;
        };
        /**
         * Initializes DOM listeners.
         *
         * @private
         * @returns {void}
         */


        ResizeObserverController.prototype.connect_ = function () {
          // Do nothing if running in a non-browser environment or if listeners
          // have been already added.
          if (!isBrowser || this.connected_) {
            return;
          } // Subscription to the "Transitionend" event is used as a workaround for
          // delayed transitions. This way it's possible to capture at least the
          // final state of an element.


          document.addEventListener('transitionend', this.onTransitionEnd_);
          window.addEventListener('resize', this.refresh);

          if (mutationObserverSupported) {
            this.mutationsObserver_ = new MutationObserver(this.refresh);
            this.mutationsObserver_.observe(document, {
              attributes: true,
              childList: true,
              characterData: true,
              subtree: true
            });
          } else {
            document.addEventListener('DOMSubtreeModified', this.refresh);
            this.mutationEventsAdded_ = true;
          }

          this.connected_ = true;
        };
        /**
         * Removes DOM listeners.
         *
         * @private
         * @returns {void}
         */


        ResizeObserverController.prototype.disconnect_ = function () {
          // Do nothing if running in a non-browser environment or if listeners
          // have been already removed.
          if (!isBrowser || !this.connected_) {
            return;
          }

          document.removeEventListener('transitionend', this.onTransitionEnd_);
          window.removeEventListener('resize', this.refresh);

          if (this.mutationsObserver_) {
            this.mutationsObserver_.disconnect();
          }

          if (this.mutationEventsAdded_) {
            document.removeEventListener('DOMSubtreeModified', this.refresh);
          }

          this.mutationsObserver_ = null;
          this.mutationEventsAdded_ = false;
          this.connected_ = false;
        };
        /**
         * "Transitionend" event handler.
         *
         * @private
         * @param {TransitionEvent} event
         * @returns {void}
         */


        ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {
          var _b = _a.propertyName,
              propertyName = _b === void 0 ? '' : _b; // Detect whether transition may affect dimensions of an element.

          var isReflowProperty = transitionKeys.some(function (key) {
            return !!~propertyName.indexOf(key);
          });

          if (isReflowProperty) {
            this.refresh();
          }
        };
        /**
         * Returns instance of the ResizeObserverController.
         *
         * @returns {ResizeObserverController}
         */


        ResizeObserverController.getInstance = function () {
          if (!this.instance_) {
            this.instance_ = new ResizeObserverController();
          }

          return this.instance_;
        };
        /**
         * Holds reference to the controller's instance.
         *
         * @private {ResizeObserverController}
         */


        ResizeObserverController.instance_ = null;
        return ResizeObserverController;
      }();
      /**
       * Defines non-writable/enumerable properties of the provided target object.
       *
       * @param {Object} target - Object for which to define properties.
       * @param {Object} props - Properties to be defined.
       * @returns {Object} Target object.
       */


      var defineConfigurable = function defineConfigurable(target, props) {
        for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
          var key = _a[_i];
          Object.defineProperty(target, key, {
            value: props[key],
            enumerable: false,
            writable: false,
            configurable: true
          });
        }

        return target;
      };
      /**
       * Returns the global object associated with provided element.
       *
       * @param {Object} target
       * @returns {Object}
       */


      var getWindowOf = function getWindowOf(target) {
        // Assume that the element is an instance of Node, which means that it
        // has the "ownerDocument" property from which we can retrieve a
        // corresponding global object.
        var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView; // Return the local global object if it's not possible extract one from
        // provided element.

        return ownerGlobal || global$1;
      }; // Placeholder of an empty content rectangle.


      var emptyRect = createRectInit(0, 0, 0, 0);
      /**
       * Converts provided string to a number.
       *
       * @param {number|string} value
       * @returns {number}
       */

      function toFloat(value) {
        return parseFloat(value) || 0;
      }
      /**
       * Extracts borders size from provided styles.
       *
       * @param {CSSStyleDeclaration} styles
       * @param {...string} positions - Borders positions (top, right, ...)
       * @returns {number}
       */


      function getBordersSize(styles) {
        var positions = [];

        for (var _i = 1; _i < arguments.length; _i++) {
          positions[_i - 1] = arguments[_i];
        }

        return positions.reduce(function (size, position) {
          var value = styles['border-' + position + '-width'];
          return size + toFloat(value);
        }, 0);
      }
      /**
       * Extracts paddings sizes from provided styles.
       *
       * @param {CSSStyleDeclaration} styles
       * @returns {Object} Paddings box.
       */


      function getPaddings(styles) {
        var positions = ['top', 'right', 'bottom', 'left'];
        var paddings = {};

        for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
          var position = positions_1[_i];
          var value = styles['padding-' + position];
          paddings[position] = toFloat(value);
        }

        return paddings;
      }
      /**
       * Calculates content rectangle of provided SVG element.
       *
       * @param {SVGGraphicsElement} target - Element content rectangle of which needs
       *      to be calculated.
       * @returns {DOMRectInit}
       */


      function getSVGContentRect(target) {
        var bbox = target.getBBox();
        return createRectInit(0, 0, bbox.width, bbox.height);
      }
      /**
       * Calculates content rectangle of provided HTMLElement.
       *
       * @param {HTMLElement} target - Element for which to calculate the content rectangle.
       * @returns {DOMRectInit}
       */


      function getHTMLElementContentRect(target) {
        // Client width & height properties can't be
        // used exclusively as they provide rounded values.
        var clientWidth = target.clientWidth,
            clientHeight = target.clientHeight; // By this condition we can catch all non-replaced inline, hidden and
        // detached elements. Though elements with width & height properties less
        // than 0.5 will be discarded as well.
        //
        // Without it we would need to implement separate methods for each of
        // those cases and it's not possible to perform a precise and performance
        // effective test for hidden elements. E.g. even jQuery's ':visible' filter
        // gives wrong results for elements with width & height less than 0.5.

        if (!clientWidth && !clientHeight) {
          return emptyRect;
        }

        var styles = getWindowOf(target).getComputedStyle(target);
        var paddings = getPaddings(styles);
        var horizPad = paddings.left + paddings.right;
        var vertPad = paddings.top + paddings.bottom; // Computed styles of width & height are being used because they are the
        // only dimensions available to JS that contain non-rounded values. It could
        // be possible to utilize the getBoundingClientRect if only it's data wasn't
        // affected by CSS transformations let alone paddings, borders and scroll bars.

        var width = toFloat(styles.width),
            height = toFloat(styles.height); // Width & height include paddings and borders when the 'border-box' box
        // model is applied (except for IE).

        if (styles.boxSizing === 'border-box') {
          // Following conditions are required to handle Internet Explorer which
          // doesn't include paddings and borders to computed CSS dimensions.
          //
          // We can say that if CSS dimensions + paddings are equal to the "client"
          // properties then it's either IE, and thus we don't need to subtract
          // anything, or an element merely doesn't have paddings/borders styles.
          if (Math.round(width + horizPad) !== clientWidth) {
            width -= getBordersSize(styles, 'left', 'right') + horizPad;
          }

          if (Math.round(height + vertPad) !== clientHeight) {
            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;
          }
        } // Following steps can't be applied to the document's root element as its
        // client[Width/Height] properties represent viewport area of the window.
        // Besides, it's as well not necessary as the <html> itself neither has
        // rendered scroll bars nor it can be clipped.


        if (!isDocumentElement(target)) {
          // In some browsers (only in Firefox, actually) CSS width & height
          // include scroll bars size which can be removed at this step as scroll
          // bars are the only difference between rounded dimensions + paddings
          // and "client" properties, though that is not always true in Chrome.
          var vertScrollbar = Math.round(width + horizPad) - clientWidth;
          var horizScrollbar = Math.round(height + vertPad) - clientHeight; // Chrome has a rather weird rounding of "client" properties.
          // E.g. for an element with content width of 314.2px it sometimes gives
          // the client width of 315px and for the width of 314.7px it may give
          // 314px. And it doesn't happen all the time. So just ignore this delta
          // as a non-relevant.

          if (Math.abs(vertScrollbar) !== 1) {
            width -= vertScrollbar;
          }

          if (Math.abs(horizScrollbar) !== 1) {
            height -= horizScrollbar;
          }
        }

        return createRectInit(paddings.left, paddings.top, width, height);
      }
      /**
       * Checks whether provided element is an instance of the SVGGraphicsElement.
       *
       * @param {Element} target - Element to be checked.
       * @returns {boolean}
       */


      var isSVGGraphicsElement = function () {
        // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement
        // interface.
        if (typeof SVGGraphicsElement !== 'undefined') {
          return function (target) {
            return target instanceof getWindowOf(target).SVGGraphicsElement;
          };
        } // If it's so, then check that element is at least an instance of the
        // SVGElement and that it has the "getBBox" method.
        // eslint-disable-next-line no-extra-parens


        return function (target) {
          return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === 'function';
        };
      }();
      /**
       * Checks whether provided element is a document element (<html>).
       *
       * @param {Element} target - Element to be checked.
       * @returns {boolean}
       */


      function isDocumentElement(target) {
        return target === getWindowOf(target).document.documentElement;
      }
      /**
       * Calculates an appropriate content rectangle for provided html or svg element.
       *
       * @param {Element} target - Element content rectangle of which needs to be calculated.
       * @returns {DOMRectInit}
       */


      function getContentRect(target) {
        if (!isBrowser) {
          return emptyRect;
        }

        if (isSVGGraphicsElement(target)) {
          return getSVGContentRect(target);
        }

        return getHTMLElementContentRect(target);
      }
      /**
       * Creates rectangle with an interface of the DOMRectReadOnly.
       * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly
       *
       * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.
       * @returns {DOMRectReadOnly}
       */


      function createReadOnlyRect(_a) {
        var x = _a.x,
            y = _a.y,
            width = _a.width,
            height = _a.height; // If DOMRectReadOnly is available use it as a prototype for the rectangle.

        var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;
        var rect = Object.create(Constr.prototype); // Rectangle's properties are not writable and non-enumerable.

        defineConfigurable(rect, {
          x: x,
          y: y,
          width: width,
          height: height,
          top: y,
          right: x + width,
          bottom: height + y,
          left: x
        });
        return rect;
      }
      /**
       * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.
       * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit
       *
       * @param {number} x - X coordinate.
       * @param {number} y - Y coordinate.
       * @param {number} width - Rectangle's width.
       * @param {number} height - Rectangle's height.
       * @returns {DOMRectInit}
       */


      function createRectInit(x, y, width, height) {
        return {
          x: x,
          y: y,
          width: width,
          height: height
        };
      }
      /**
       * Class that is responsible for computations of the content rectangle of
       * provided DOM element and for keeping track of it's changes.
       */


      var ResizeObservation =
      /** @class */
      function () {
        /**
         * Creates an instance of ResizeObservation.
         *
         * @param {Element} target - Element to be observed.
         */
        function ResizeObservation(target) {
          /**
           * Broadcasted width of content rectangle.
           *
           * @type {number}
           */
          this.broadcastWidth = 0;
          /**
           * Broadcasted height of content rectangle.
           *
           * @type {number}
           */

          this.broadcastHeight = 0;
          /**
           * Reference to the last observed content rectangle.
           *
           * @private {DOMRectInit}
           */

          this.contentRect_ = createRectInit(0, 0, 0, 0);
          this.target = target;
        }
        /**
         * Updates content rectangle and tells whether it's width or height properties
         * have changed since the last broadcast.
         *
         * @returns {boolean}
         */


        ResizeObservation.prototype.isActive = function () {
          var rect = getContentRect(this.target);
          this.contentRect_ = rect;
          return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
        };
        /**
         * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
         * from the corresponding properties of the last observed content rectangle.
         *
         * @returns {DOMRectInit} Last observed content rectangle.
         */


        ResizeObservation.prototype.broadcastRect = function () {
          var rect = this.contentRect_;
          this.broadcastWidth = rect.width;
          this.broadcastHeight = rect.height;
          return rect;
        };

        return ResizeObservation;
      }();

      var ResizeObserverEntry =
      /** @class */
      function () {
        /**
         * Creates an instance of ResizeObserverEntry.
         *
         * @param {Element} target - Element that is being observed.
         * @param {DOMRectInit} rectInit - Data of the element's content rectangle.
         */
        function ResizeObserverEntry(target, rectInit) {
          var contentRect = createReadOnlyRect(rectInit); // According to the specification following properties are not writable
          // and are also not enumerable in the native implementation.
          //
          // Property accessors are not being used as they'd require to define a
          // private WeakMap storage which may cause memory leaks in browsers that
          // don't support this type of collections.

          defineConfigurable(this, {
            target: target,
            contentRect: contentRect
          });
        }

        return ResizeObserverEntry;
      }();

      var ResizeObserverSPI =
      /** @class */
      function () {
        /**
         * Creates a new instance of ResizeObserver.
         *
         * @param {ResizeObserverCallback} callback - Callback function that is invoked
         *      when one of the observed elements changes it's content dimensions.
         * @param {ResizeObserverController} controller - Controller instance which
         *      is responsible for the updates of observer.
         * @param {ResizeObserver} callbackCtx - Reference to the public
         *      ResizeObserver instance which will be passed to callback function.
         */
        function ResizeObserverSPI(callback, controller, callbackCtx) {
          /**
           * Collection of resize observations that have detected changes in dimensions
           * of elements.
           *
           * @private {Array<ResizeObservation>}
           */
          this.activeObservations_ = [];
          /**
           * Registry of the ResizeObservation instances.
           *
           * @private {Map<Element, ResizeObservation>}
           */

          this.observations_ = new MapShim();

          if (typeof callback !== 'function') {
            throw new TypeError('The callback provided as parameter 1 is not a function.');
          }

          this.callback_ = callback;
          this.controller_ = controller;
          this.callbackCtx_ = callbackCtx;
        }
        /**
         * Starts observing provided element.
         *
         * @param {Element} target - Element to be observed.
         * @returns {void}
         */


        ResizeObserverSPI.prototype.observe = function (target) {
          if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
          } // Do nothing if current environment doesn't have the Element interface.


          if (typeof Element === 'undefined' || !(Element instanceof Object)) {
            return;
          }

          if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
          }

          var observations = this.observations_; // Do nothing if element is already being observed.

          if (observations.has(target)) {
            return;
          }

          observations.set(target, new ResizeObservation(target));
          this.controller_.addObserver(this); // Force the update of observations.

          this.controller_.refresh();
        };
        /**
         * Stops observing provided element.
         *
         * @param {Element} target - Element to stop observing.
         * @returns {void}
         */


        ResizeObserverSPI.prototype.unobserve = function (target) {
          if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
          } // Do nothing if current environment doesn't have the Element interface.


          if (typeof Element === 'undefined' || !(Element instanceof Object)) {
            return;
          }

          if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
          }

          var observations = this.observations_; // Do nothing if element is not being observed.

          if (!observations.has(target)) {
            return;
          }

          observations.delete(target);

          if (!observations.size) {
            this.controller_.removeObserver(this);
          }
        };
        /**
         * Stops observing all elements.
         *
         * @returns {void}
         */


        ResizeObserverSPI.prototype.disconnect = function () {
          this.clearActive();
          this.observations_.clear();
          this.controller_.removeObserver(this);
        };
        /**
         * Collects observation instances the associated element of which has changed
         * it's content rectangle.
         *
         * @returns {void}
         */


        ResizeObserverSPI.prototype.gatherActive = function () {
          var _this = this;

          this.clearActive();
          this.observations_.forEach(function (observation) {
            if (observation.isActive()) {
              _this.activeObservations_.push(observation);
            }
          });
        };
        /**
         * Invokes initial callback function with a list of ResizeObserverEntry
         * instances collected from active resize observations.
         *
         * @returns {void}
         */


        ResizeObserverSPI.prototype.broadcastActive = function () {
          // Do nothing if observer doesn't have active observations.
          if (!this.hasActive()) {
            return;
          }

          var ctx = this.callbackCtx_; // Create ResizeObserverEntry instance for every active observation.

          var entries = this.activeObservations_.map(function (observation) {
            return new ResizeObserverEntry(observation.target, observation.broadcastRect());
          });
          this.callback_.call(ctx, entries, ctx);
          this.clearActive();
        };
        /**
         * Clears the collection of active observations.
         *
         * @returns {void}
         */


        ResizeObserverSPI.prototype.clearActive = function () {
          this.activeObservations_.splice(0);
        };
        /**
         * Tells whether observer has active observations.
         *
         * @returns {boolean}
         */


        ResizeObserverSPI.prototype.hasActive = function () {
          return this.activeObservations_.length > 0;
        };

        return ResizeObserverSPI;
      }(); // Registry of internal observers. If WeakMap is not available use current shim
      // for the Map collection as it has all required methods and because WeakMap
      // can't be fully polyfilled anyway.


      var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();
      /**
       * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation
       * exposing only those methods and properties that are defined in the spec.
       */

      var ResizeObserver =
      /** @class */
      function () {
        /**
         * Creates a new instance of ResizeObserver.
         *
         * @param {ResizeObserverCallback} callback - Callback that is invoked when
         *      dimensions of the observed elements change.
         */
        function ResizeObserver(callback) {
          if (!(this instanceof ResizeObserver)) {
            throw new TypeError('Cannot call a class as a function.');
          }

          if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
          }

          var controller = ResizeObserverController.getInstance();
          var observer = new ResizeObserverSPI(callback, controller, this);
          observers.set(this, observer);
        }

        return ResizeObserver;
      }(); // Expose public methods of ResizeObserver.


      ['observe', 'unobserve', 'disconnect'].forEach(function (method) {
        ResizeObserver.prototype[method] = function () {
          var _a;

          return (_a = observers.get(this))[method].apply(_a, arguments);
        };
      });

      var index = function () {
        // Export existing implementation if available.
        if (typeof global$1.ResizeObserver !== 'undefined') {
          return global$1.ResizeObserver;
        }

        return ResizeObserver;
      }();

      return index;
    });
  });

  var nextID = 0; // Remove namespace from global options

  var cleanOption = function cleanOption(name) {
    name = name.replace('coral', '');
    return name.charAt(0).toLowerCase() + name.slice(1);
  }; // Threshold time in milliseconds that the setTimeout will wait for the transitionEnd event to be triggered.


  var TRANSITION_DURATION_THRESHOLD = 100; // Based on jQuery's :focusable selector

  var FOCUSABLE_ELEMENTS = ['input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'a[href]', 'area[href]', 'summary', 'iframe', 'object', 'embed', 'audio[controls]', 'video[controls]', '[contenteditable]', '[tabindex]']; // To support Coral.commons.ready and differentiate lightweight tags from defined elements

  var CORAL_COMPONENTS = [];
  /**
   Converts CSS time to milliseconds. It supports both s and ms units. If the provided value has an unrecogenized unit,
   zero will be returned.

   @private
   @param {String} time
   The time string to convert to milliseconds.
   @returns {Number} the time in milliseconds.
   */

  function cssTimeToMilliseconds(time) {
    var num = parseFloat(time, 10);
    var unit = time.match(/m?s/);

    if (unit) {
      unit = unit[0];
    }

    if (unit === 's') {
      return num * 1000;
    } else if (unit === 'ms') {
      return num;
    } // unrecognized unit, so we return 0


    return 0;
  }
  /**
   @private

   @param first
   @param second
   @return {Function}
   */


  function returnFirst(first, second) {
    // eslint-disable-next-line func-names
    return function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var ret = first.apply(this, args);
      second.apply(this, args);
      return ret;
    };
  }
  /**
   Check if the provided object is a function

   @ignore

   @param {*} object
   The object to test

   @returns {Boolean} Whether the provided object is a function.
   */


  function isFunction(object) {
    return typeof object === 'function';
  }
  /**
   Utility belt.
   */


  var Commons = /*#__PURE__*/function () {
    /** @ignore */
    function Commons() {
      var _this = this;

      _classCallCheck(this, Commons);

      // Create a Map to link elements to observe to their resize event callbacks
      this._resizeObserverMap = new WeakMap();
      this._resizeObserver = new ResizeObserver(function (entries) {
        for (var i = 0; i < entries.length; i++) {
          var observedElement = entries[i].target;

          var allCallbacks = _this._resizeObserverMap.get(observedElement);

          if (allCallbacks) {
            for (var j = 0; j < allCallbacks.length; j++) {
              allCallbacks[j].call(observedElement);
            }
          }
        }
      });
      var focusableElements = FOCUSABLE_ELEMENTS.slice();
      this._focusableElementsSelector = focusableElements.join(',');
      focusableElements[focusableElements.length - 1] += ':not([tabindex="-1"])';
      this._tabbableElementsSelector = focusableElements.join(':not([tabindex="-1"]),');
      this._coralSelector = ''; // @IE11

      if (!document.currentScript) {
        var scripts = document.getElementsByTagName('script');
        this._script = scripts[scripts.length - 1];
      } else {
        this._script = document.currentScript;
      }
    }
    /**
     Returns Coral global options retrieved on the <code><script></code> data attributes including:
     - <code>[data-coral-icons]</code>: source folder of the SVG icons. If the icon collections have a custom name,
     they have to be loaded manually using {@link Icon.load}.
     - <code>[data-coral-icons-external]</code>: Whether SVG icons are always referenced as external resource. Possible values are "on" (default), "off" or "js" to load icons from a script.
     - <code>[data-coral-typekit]</code>: custom typekit id used to load the fonts.
     - <code>[data-coral-logging]</code>: defines logging level. Possible values are "on" (default) or "off".
      @returns {Object}
     The global options object.
     */


    _createClass(Commons, [{
      key: "_log",

      /**
       Utility function for logging.
        @param {String} level
       Logging level
       @param {String} args
       Logging message
       */
      value: function _log(level) {
        if (console[level] && this.options.logging !== 'off') {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }

          console[level].apply(null, args);
        }
      }
      /**
       Copy the properties from all provided objects into the first object.
        @param {Object} dest
       The object to copy properties to
       @param {...Object} source
       An object to copy properties from. Additional objects can be passed as subsequent arguments.
        @returns {Object}
       The destination object, <code>dest</code>
       */

    }, {
      key: "extend",
      value: function extend() {
        var dest = arguments.length <= 0 ? undefined : arguments[0];

        for (var i = 1, ni = arguments.length; i < ni; i++) {
          var source = i < 0 || arguments.length <= i ? undefined : arguments[i];

          for (var prop in source) {
            dest[prop] = source[prop];
          }
        }

        return dest;
      }
      /**
       Copy the properties from the source object to the destination object, but calls the callback if the property is
       already present on the destination object.
        @param {Object} dest
       The object to copy properties to
       @param {...Object} source
       An object to copy properties from. Additional objects can be passed as subsequent arguments.
       @param {CommonsHandleCollision} [handleCollision]
       Called if the property being copied is already present on the destination.
       The return value will be used as the property value.
        @returns {Object}
       The destination object, <code>dest</code>
       */

    }, {
      key: "augment",
      value: function augment() {
        var dest = arguments.length <= 0 ? undefined : arguments[0];
        var handleCollision;
        var argCount = arguments.length;
        var lastArg = argCount - 1 < 0 || arguments.length <= argCount - 1 ? undefined : arguments[argCount - 1];

        if (typeof lastArg === 'function') {
          handleCollision = lastArg; // Don't attempt to augment using the last argument

          argCount--;
        }

        for (var i = 1; i < argCount; i++) {
          var source = i < 0 || arguments.length <= i ? undefined : arguments[i];

          for (var prop in source) {
            if (typeof dest[prop] !== 'undefined') {
              if (typeof handleCollision === 'function') {
                // Call the handleCollision callback if the property is already present
                var ret = handleCollision(dest[prop], source[prop], prop, dest, source);

                if (typeof ret !== 'undefined') {
                  dest[prop] = ret;
                }
              } // Otherwise, do nothing

            } else {
              dest[prop] = source[prop];
            }
          }
        }

        return dest;
      }
      /**
       Return a new object with the swapped keys and values of the provided object.
        @param {Object} obj
       The object to copy.
        @returns {Object}
       An object with its keys as the values and values as the keys of the source object.
       */

    }, {
      key: "swapKeysAndValues",
      value: function swapKeysAndValues(obj) {
        var map = {};

        for (var key in obj) {
          map[obj[key]] = key;
        }

        return map;
      }
      /**
       Execute the provided callback on the next animation frame.
        @param {Function} onNextFrame
       The callback to execute.
       */

    }, {
      key: "nextFrame",
      value: function nextFrame(onNextFrame) {
        return window.requestAnimationFrame(function () {
          if (typeof onNextFrame === 'function') {
            onNextFrame();
          }
        });
      }
      /**
       Execute the provided callback once a CSS transition has ended. This method listens for the next transitionEnd event
       on the given DOM element. In case the provided element does not have a transition defined, the callback will be
       called in the next macrotask to allow a normal application execution flow. It cannot be used to listen continuously
       on transitionEnd events.
       @param {HTMLElement} element
       The DOM element that is affected by the CSS transition.
       @param {CommonsTransitionEndCallback} onTransitionEndCallback
       The callback to execute.
       */

    }, {
      key: "transitionEnd",
      value: function transitionEnd(element, onTransitionEndCallback) {
        var propertyName;
        var hasTransitionEnded = false;
        var transitionEndEventName = null;
        var transitions = {
          transition: 'transitionend',
          WebkitTransition: 'webkitTransitionEnd',
          MozTransition: 'transitionend',
          MSTransition: 'msTransitionEnd'
        };
        var transitionEndTimeout = null;

        var onTransitionEnd = function onTransitionEnd(event) {
          var transitionStoppedByTimeout = typeof event === 'undefined';

          if (!hasTransitionEnded) {
            hasTransitionEnded = true;
            clearTimeout(transitionEndTimeout); // Remove event listener (if any was used by the current browser)

            element.removeEventListener(transitionEndEventName, onTransitionEnd); // Call callback with specified element

            onTransitionEndCallback({
              target: element,
              cssTransitionSupported: true,
              transitionStoppedByTimeout: transitionStoppedByTimeout
            });
          }
        }; // Find transitionEnd event name used by browser


        for (propertyName in transitions) {
          if (element.style[propertyName] !== undefined) {
            transitionEndEventName = transitions[propertyName];
            break;
          }
        }

        if (transitionEndEventName !== null) {
          var timeoutDelay = 0; // Gets the animation time (in milliseconds) using the computed style

          var transitionDuration = cssTimeToMilliseconds(window.getComputedStyle(element).transitionDuration); // We only setup the event listener if there is a valid transition

          if (transitionDuration !== 0) {
            // Register on transitionEnd event
            element.addEventListener(transitionEndEventName, onTransitionEnd); // As a fallback we use the transitionDuration plus a threshold. This can happen in IE10/11 where
            // transitionEnd events are sometimes skipped

            timeoutDelay = transitionDuration + TRANSITION_DURATION_THRESHOLD;
          } // Fallback in case the event does not trigger (IE10/11) or if the element does not have a valid transition


          transitionEndTimeout = window.setTimeout(onTransitionEnd, timeoutDelay);
        }
      }
      /**
       Register a Coral component as Custom Element V1
        @param {String} name
       Custom element namespace
       @param {Function} constructor
       Constructor for the custom element
       @param {Object} options
       E.g for built-in custom elements
       */

    }, {
      key: "_define",
      value: function _define(name, constructor, options) {
        window.customElements.define(name, constructor, options);
        CORAL_COMPONENTS.push(name);
      }
      /**
       Checks if Coral components and all nested Coral components are defined as Custom Elements.
        @param {HTMLElement} element
       The element that should be watched.
       @param {CommonsReadyCallback} onDefined
       The callback to call when all components are ready.
        @see https://developer.mozilla.org/en-US/docs/Web/Web_Components/Custom_Elements
       */

    }, {
      key: "ready",
      value: function ready(element, onDefined) {
        var root = element;

        if (typeof element === 'function') {
          onDefined = element;
          root = document.body;
        }

        if (!root) {
          root = document.body;
        }

        if (!(root instanceof HTMLElement)) {
          // commons.ready should not be blocking by default
          onDefined(root);
          return;
        } // @todo use ':not(:defined)' once supported ?


        this._coralSelector = this._coralSelector || CORAL_COMPONENTS.join(',');
        var elements = root.querySelectorAll(this._coralSelector); // Holds promises that resolve when the elements is defined

        var promises = []; // Don't forget to check root

        if (root !== document.body && !root._componentReady && root.matches(this._coralSelector)) {
          var name = (root.getAttribute('is') || root.tagName).toLowerCase();
          promises.push(window.customElements.whenDefined(name));
        } // Check all descending elements


        for (var i = 0; i < elements.length; i++) {
          var el = elements[i];

          if (!el._componentReady) {
            var _name = (el.getAttribute('is') || el.tagName).toLowerCase();

            promises.push(window.customElements.whenDefined(_name));
          }
        } // Call callback once all defined


        if (promises.length) {
          Promise.all(promises).then(function () {
            onDefined(element instanceof HTMLElement && element || window);
          }).catch(function (err) {
            console.error(err);
          });
        } else {
          // Call callback by default if all defined already
          onDefined(element instanceof HTMLElement && element || window);
        }
      }
      /**
       Assign an object given a nested path
        @param {Object} root
       The root object on which the path should be traversed.
       @param {String} path
       The path at which the object should be assignment.
       @param {String} obj
       The object to assign at path.
        @throws Will throw an error if the path is not present on the object.
       */

    }, {
      key: "setSubProperty",
      value: function setSubProperty(root, path, obj) {
        var nsParts = path.split('.');
        var curObj = root;

        if (nsParts.length === 1) {
          // Assign immediately
          curObj[path] = obj;
          return;
        } // Make sure we can assign at the requested location


        while (nsParts.length > 1) {
          var part = nsParts.shift();

          if (curObj[part]) {
            curObj = curObj[part];
          } else {
            throw new Error("Coral.commons.setSubProperty: could not set ".concat(path, ", part ").concat(part, " not found"));
          }
        } // Do the actual assignment


        curObj[nsParts.shift()] = obj;
      }
      /**
       Get the value of the property at the given nested path.
        @param {Object} root
       The root object on which the path should be traversed.
       @param {String} path
       The path of the sub-property to return.
        @returns {*}
       The value of the provided property.
        @throws Will throw an error if the path is not present on the object.
       */

    }, {
      key: "getSubProperty",
      value: function getSubProperty(root, path) {
        var nsParts = path.split('.');
        var curObj = root;

        if (nsParts.length === 1) {
          // Return property immediately
          return curObj[path];
        } // Make sure we can assign at the requested location


        while (nsParts.length) {
          var part = nsParts.shift(); // The property might be undefined, and that's OK if it's the last part

          if (nsParts.length === 0 || typeof curObj[part] !== 'undefined') {
            curObj = curObj[part];
          } else {
            throw new Error("Coral.commons.getSubProperty: could not get ".concat(path, ", part ").concat(part, " not found"));
          }
        }

        return curObj;
      }
      /**
       Apply a mixin to the given object.
        @param {Object} target
       The object to apply the mixin to.
       @param {Object|Function} mixin
       The mixin to apply.
       @param {Object} options
       An object to pass to functional mixins.
       */

    }, {
      key: "_applyMixin",
      value: function _applyMixin(target, mixin, options) {
        var mixinType = _typeof(mixin);

        if (mixinType === 'function') {
          mixin(target, options);
        } else if (mixinType === 'object' && mixin !== null) {
          this.extend(target, mixin);
        } else {
          throw new Error("Coral.commons.mixin: Cannot mix in ".concat(mixinType, " to ").concat(target.toString()));
        }
      }
      /**
       Mix a set of mixins to a target object.
        @private
        @param {Object} target
       The target prototype or instance on which to apply mixins.
       @param {Object|CoralMixin|Array<Object|CoralMixin>} mixins
       A mixin or set of mixins to apply.
       @param {Object} options
       An object that will be passed to functional mixins as the second argument (options).
       */

    }, {
      key: "mixin",
      value: function mixin(target, mixins, options) {
        if (Array.isArray(mixins)) {
          for (var i = 0; i < mixins.length; i++) {
            this._applyMixin(target, mixins[i], options);
          }
        } else {
          this._applyMixin(target, mixins, options);
        }
      }
      /**
       Get a unique ID.
        @returns {String} unique identifier.
       */

    }, {
      key: "getUID",
      value: function getUID() {
        return "coral-id-".concat(nextID++);
      }
      /**
       Call all of the provided functions, in order, returning the return value of the specified function.
        @param {...Function} func
       A function to call
       @param {Number} [nth=0]
       A zero-based index indicating the noth argument to return the value of.
       If the nth argument is not a function, <code>null</code> will be returned.
        @returns {Function} The aggregate function.
       */

    }, {
      key: "callAll",
      value: function callAll() {
        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }

        var nth = args[args.length - 1];

        if (typeof nth !== 'number') {
          nth = 0;
        } // Get the function whose value we should return


        var funcToReturn = args[nth]; // Only use arguments that are functions

        var functions = Array.prototype.filter.call(args, isFunction);

        if (functions.length === 2 && nth === 0) {
          // Most common usecase: two valid functions passed
          return returnFirst(functions[0], functions[1]);
        } else if (functions.length === 1) {
          // Common usecase: one valid function passed
          return functions[0];
        } else if (functions.length === 0) {
          return function () {// Fail case: no valid functions passed
          };
        }

        if (typeof funcToReturn !== 'function') {
          // If the argument at the provided index wasn't a function, just return the value of the first valid function
          funcToReturn = functions[0];
        } // eslint-disable-next-line func-names


        return function () {
          var finalRet;
          var ret;
          var func; // Skip first arg

          for (var i = 0; i < functions.length; i++) {
            func = functions[i];
            ret = func.apply(this, args); // Store return value of desired function

            if (func === funcToReturn) {
              finalRet = ret;
            }
          }

          return finalRet;
        };
      }
      /**
       Adds a resize listener to the given element.
        @param {HTMLElement} element
       The element to add the resize event to.
       @param {Function} onResize
       The resize callback.
       */
      // eslint-disable-next-line func-names

    }, {
      key: "addResizeListener",
      value: function addResizeListener(element, onResize) {
        // Map callback to element
        if (!this._resizeObserverMap.has(element)) {
          this._resizeObserverMap.set(element, []);
        }

        this._resizeObserverMap.get(element).push(onResize); // Observe element resize events


        this._resizeObserver.observe(element);
      }
      /**
       Removes a resize listener from the given element.
        @param {HTMLElement} element
       The element to remove the resize event from.
       @param {Function} onResize
       The resize callback.
       */
      // eslint-disable-next-line func-names

    }, {
      key: "removeResizeListener",
      value: function removeResizeListener(element, onResize) {
        // Stop observing element resize events
        this._resizeObserver.unobserve(element);

        this._resizeObserver.disconnect(element); // Remove event from map


        var onResizeEvents = this._resizeObserverMap.get(element);

        if (onResizeEvents) {
          var index = onResizeEvents.indexOf(onResize);

          if (index !== -1) {
            onResizeEvents.splice(index, 1);
          }
        }
      }
      /**
       Caution: the selector doesn't verify if elements are visible.
        @type {String}
       @readonly
       @see https://www.w3.org/TR/html5/editing.html#focus-management
       */

    }, {
      key: "options",
      get: function get() {
        var options = {};
        var props = this._script.dataset;

        for (var key in props) {
          // Detect Coral namespaced options
          if (key.indexOf('coral') === 0) {
            options[cleanOption(key)] = props[key];
          }
        }

        return options;
      }
    }, {
      key: "FOCUSABLE_ELEMENT_SELECTOR",
      get: function get() {
        return this._focusableElementsSelector;
      }
      /**
       Caution: the selector doesn't verify if elements are visible.
        @type {String}
       @readonly
       @see https://www.w3.org/TR/html5/editing.html#sequential-focus-navigation-and-the-tabindex-attribute
       */

    }, {
      key: "TABBABLE_ELEMENT_SELECTOR",
      get: function get() {
        return this._tabbableElementsSelector;
      }
    }]);

    return Commons;
  }();
  /**
   Called when a property already exists on the destination object.

   @typedef {function} CommonsHandleCollision

   @param {*} oldValue
   The value currently present on the destination object.
   @param {*} newValue
   The value on the destination object.
   @param {*} prop
   The property that collided.
   @param {*} dest
   The destination object.
   @param {*} source
   The source object.

   @returns {*} The value to use. If <code>undefined</code>, the old value will be used.
   */

  /**
   Execute the callback once a CSS transition has ended.

   @typedef {function} CommonsTransitionEndCallback

   @param event
   The event passed to the callback.
   @param {HTMLElement} event.target
   The DOM element that was affected by the CSS transition.
   @param {Boolean} event.cssTransitionSupported
   Whether CSS transitions are supported by the browser.
   @param {Boolean} event.transitionStoppedByTimeout
   Whether the CSS transition has been ended by a timeout (should only happen as a fallback).
   */

  /**
   Execute the callback once a component and sub-components are ready. See {@link Commons.ready}.

   @typedef {function} CommonsReadyCallback
   @param {HTMLElement} element
   The element that is ready.
   */

  /**
   A functional mixin.

   @typedef {Object} CoralMixin

   @private

   @param {Object} target
   The target prototype or instance to apply the mixin to.
   @param {Object} options
   Options for this mixin.
   @param {Coral~PropertyDescriptor.properties} options.properties
   The properties object as passed to <code>Coral.register</code>. This can be modified in place.
   */

  /**
   A utility belt.

   @type {Commons}
   */


  var commons = new Commons();

  /**
   Events helper.
   */

  var Events = /*#__PURE__*/function () {
    /**
     @param {HTMLElement|String} elementOrSelector
     The element or selector indicating the element to use as the delegation root.
     */
    function Events(elementOrSelector) {
      _classCallCheck(this, Events);

      this._vent = new vent(elementOrSelector);
    }
    /**
     Add an event listener.
      @param {String} eventName
     The event name to listen for, including optional namespace(s).
     @param {String} [selector]
     The selector to use for event delegation.
     @param {Function} handler
     The function that will be called when the event is fired.
     @param {Boolean} [useCapture]
     Whether or not to listen during the capturing or bubbling phase.
     @returns {Events} this, chainable.
     */


    _createClass(Events, [{
      key: "on",
      value: function on(eventName, selector, handler, useCapture) {
        this._vent.on(eventName, selector, handler, useCapture);

        return this;
      }
      /**
       Remove an event listener.
        @param {String} [eventName]
       The event name to stop listening for, including optional namespace(s).
       @param {String} [selector]
       The selector that was used for event delegation.
       @param {Function} [handler]
       The function that was passed to <code>on()</code>.
       @param {Boolean} [useCapture]
       Only remove listeners with <code>useCapture</code> set to the value passed in.
       @returns {Event} this, chainable.
       */

    }, {
      key: "off",
      value: function off(eventName, selector, handler, useCapture) {
        this._vent.off(eventName, selector, handler, useCapture);

        return this;
      }
      /**
       Dispatch a custom event at the root element.
        @param {String} eventName
       The name of the event to dispatch.
       @param {Object} [options]
       CustomEvent options.
       @param {Object} [options.bubbles=true]
       Whether the event should bubble.
       @param {Object} [options.cancelable=true]
       Whether the event should be cancelable.
       @param {Object} [options.detail]
       Data to pass to handlers as <code>event.detail</code>
       @returns {CustomEvent} dispatched event.
       */

    }, {
      key: "dispatch",
      value: function dispatch(eventName, options) {
        return this._vent.dispatch(eventName, options);
      }
      /**
       Destroy this instance, removing all events and references.
       */

    }, {
      key: "destroy",
      value: function destroy() {
        this._vent.destroy();
      }
    }]);

    return Events;
  }();
  /**
   An enhanced event helper.

   @type {Events}
   */


  var events = new Events(window);

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var typeKitId = commons && commons.options.typekit;

  if (!typeKitId) {
    // On pageload, determine to current pages language setting.
    // If it is english language or unset use the 1st Adobe font web project id (smaller size),
    // otherwise use the 2nd kit with all the language settings (larger size)
    typeKitId = document.querySelector('[lang]:not([lang^="en"])') === null ? 'mge7bvf' : 'rok6rmo';
  }

  var config = {
    kitId: typeKitId,
    scriptTimeout: 3000,
    active: function active() {
      events.dispatch('coral-commons:_webfontactive');
    }
  };

  if (!window.Typekit) {
    // we load the typescript only once
    var h = document.getElementsByTagName('html')[0];
    h.classList.add('wf-loading');
    var t = window.setTimeout(function () {
      h.classList.remove('wf-loading');
      h.classList.add('wf-inactive');
    }, config.scriptTimeout);
    var tk = document.createElement('script');
    var d = false; // Always load over https

    tk.src = "https://use.typekit.net/".concat(config.kitId, ".js");
    tk.type = 'text/javascript';
    tk.async = 'true';

    tk.onload = tk.onreadystatechange = function () {
      var a = this.readyState;

      if (d || a && a !== 'complete' && a !== 'loaded') {
        return;
      }

      d = true;
      clearTimeout(t);

      try {
        window.Typekit.load(config);
      } catch (b) {}
    };

    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(tk, s);
  } else {
    // If Typekit is loaded externally, listen with a MO for active fonts
    var root = document.documentElement;

    if (root.className.indexOf('wf-inactive') !== -1 || root.className.indexOf('wf-loading') !== -1) {
      var webFontLoadObserver = new MutationObserver(function () {
        if (root.className.indexOf('wf-active') !== -1) {
          webFontLoadObserver.disconnect();
          events.dispatch('coral-commons:_webfontactive');
        }
      }); // Watch for class changes

      webFontLoadObserver.observe(root, {
        attributes: true,
        attributeFilter: ['class']
      });
    }
  }

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   Enumeration for {@link i18n} locales.

   @typedef {Object} I18nLocalesEnum

   @property {String} en
   English (U.S.)
   @property {String} en-us
   English (U.S.)
   @property {String} cs
   Czech (Czechia)
   @property {String} cs-cz
   Czech (Czechia)
   @property {String} da
   Danish (Denmark)
   @property {String} da-dk
   Danish (Denmark)
   @property {String} de
   German (Germany)
   @property {String} de-de
   German (Germany)
   @property {String} es
   Spanish (Spain)
   @property {String} es-es
   Spanish (Spain)
   @property {String} fi
   Finnish (Finland)
   @property {String} fi-fi
   Finnish (Finland)
   @property {String} fr
   French (France)
   @property {String} fr-fr
   French (France)
   @property {String} it
   Italian (Italy)
   @property {String} it-it
   Italian (Italy)
   @property {String} ja
   Japanese (Japan)
   @property {String} ja-jp
   Japanese (Japan)
   @property {String} ko
   Korean (Korea)
   @property {String} ko-kr
   Korean (Korea)
   @property {String} nb
   Norwegian Bokmål (Norway)
   @property {String} nb-no
   Norwegian Bokmål (Norway)
   @property {String} nl
   Dutch (Netherlands)
   @property {String} nl-nl
   Dutch (Netherlands)
   @property {String} pl
   Polish (Poland)
   @property {String} pl-pl
   Polish (Poland)
   @property {String} pt
   Portuguese (Brazil)
   @property {String} pt-br
   Portuguese (Brazil)
   @property {String} ru
   Russian (Russia)
   @property {String} ru-ru
   Russian (Russia)
   @property {String} sv
   Swedish (Sweden)
   @property {String} sv-se
   Swedish (Sweden)
   @property {String} tr
   Turkish (Turkey)
   @property {String} tr-tr
   Turkish (Turkey)
   @property {String} zh-cn
   Simplified Chinese
   @property {String} zh-hans-cn
   Simplified Chinese
   @property {String} zh-hans
   Simplified Chinese
   @property {String} zh-tw
   Traditional Chinese
   @property {String} zh-hant-tw
   Traditional Chinese
   @property {String} zh-hant
   Traditional Chinese
   */
  var locales = {
    'en': 'en-US',
    'en-us': 'en-US',
    'cs': 'cs-CZ',
    'cs-cz': 'cs-CZ',
    'da': 'da-DK',
    'da-dk': 'da-DK',
    'de': 'de-DE',
    'de-de': 'de-DE',
    'es': 'es-ES',
    'es-es': 'es-ES',
    'fi': 'fi-FI',
    'fi-fi': 'fi-FI',
    'fr': 'fr-FR',
    'fr-fr': 'fr-FR',
    'it': 'it-IT',
    'it-it': 'it-IT',
    'ja': 'ja-JP',
    'ja-jp': 'ja-JP',
    'ko': 'ko-KR',
    'ko-kr': 'ko-KR',
    'nb': 'nb-NO',
    'nb-no': 'nb-NO',
    'nl': 'nl-NL',
    'pl': 'pl-PL',
    'pl-pl': 'pl-PL',
    'nl-nl': 'nl-NL',
    'pt': 'pt-BR',
    'pt-br': 'pt-BR',
    'ru': 'ru-RU',
    'ru-ru': 'ru-RU',
    'sv': 'sv-SE',
    'sv-se': 'sv-SE',
    'tr': 'tr-TR',
    'tr-tr': 'tr-TR',
    'zh-cn': 'zh-CN',
    'zh-hans-cn': 'zh-CN',
    'zh-hans': 'zh-CN',
    'zh-tw': 'zh-TW',
    'zh-hant-tw': 'zh-TW',
    'zh-hant': 'zh-TW'
  };
  /**
   Used to store i18n strings.

   @type {Object}
   @property {String} strings.generic
   */

  var strings = {
    generic: {}
  };
  /**
   I18n service to get/set localized strings.
   */

  var I18nProvider = /*#__PURE__*/function () {
    /**
     @param {Object} [options]
     Options for this combo handler.
     @param {String} [options.locale]
     The <code>locale</code> property defines the locale of the I18nProvider.
     */
    function I18nProvider(options) {
      _classCallCheck(this, I18nProvider);

      options = options || {}; // Default locale

      this._locale = 'en-US';

      if (options.locale) {
        this._locale = options.locale;
      }

      this._evaluate = /(\{.+?\})/g;
    }
    /**
     Sets a localized string.
      @param {String} key the key to set
     @param {String} value the value associated with the given key.
     @example
     Coral.i18n.set('English string', 'Translated string');
     Coral.i18n.set('English string: {0}', 'Translated string: {0}');
     Coral.i18n.set('English string: {0}, {1}, and {2}', 'Translated string: {2}, {0}, and {1}');
     Coral.i18n.set('English string: {name}', 'Translated string: {name}');
     Coral.i18n.set('English string: {name1}, {name2}, and {name3}', 'Translated string: {name3}, {name1}, and {name2}');
     */

    /**
     Sets multiple localized strings.
      @param {Array<String, String>} map  a key-value map to add to the strings dictionary.
     @example
     Coral.i18n.set([
     ['English string 1', 'Translated string 1'],
     ['English string 2', 'Translated string 2'],
     ['English string 1 with {0} items','Translated string 1 with {0} items'],
     ['English string 2 with {0} items','Translated string 2 with {0} items'],
     ['English string 1: {0}, {1}, and {2}','Translated string 1: {2}, {0}, and {1}'],
     ['English string 2: {0}, {1}, and {2}','Translated string 2: {2}, {0}, and {1}'],
     ['English string 1: {name}', 'Translated string 1: {name}'],
     ['English string 2: {name}', 'Translated string 2: {name}'],
     ['English string 1: {name1}, {name2}, and {name3}', 'Translated string 1: {name3}, {name1}, and {name2}'],
     ['English string 2: {name1}, {name2}, and {name3}', 'Translated string 2: {name3}, {name1}, and {name2}']
     ]);
     */

    /**
     Sets a localized string, using translation hint.
      @param {String} key the key to set
     @param {String} value the value associated with the given key.
     @param {String} translation_hint the translation hint associated with the given key.
     @example
     Coral.i18n.set('English string', 'Translated string 1', 'Translation hint 1');
     Coral.i18n.set('English string', 'Translated string 2', 'Translation hint 2');
     Coral.i18n.set('English string with {0} items' , 'Translated string 1 with {0} items', 'Translation hint 1');
     Coral.i18n.set('English string with {0} items' , 'Translated string 2 with {0} items', 'Translation hint 2');
     Coral.i18n.set('English string: {0}, {1}, and {2}', 'Translated string 1: {2}, {0}, and {1}', 'Translation hint 1');
     Coral.i18n.set('English string: {0}, {1}, and {2}', 'Translated string 2: {2}, {0}, and {1}', 'Translation hint 2');
     Coral.i18n.set('English string: {name}', 'Translated string 1: {name}', 'Translation hint 1');
     Coral.i18n.set('English string: {name}', 'Translated string 2: {name}', 'Translation hint 2');
     Coral.i18n.set('English string: {name1}, {name2}, and {name3}', 'Translated string 1: {name3}, {name1}, and {name2}', 'Translation hint 1');
     Coral.i18n.set('English string: {name1}, {name2}, and {name3}', 'Translated string 2: {name3}, {name1}, and {name2}', 'Translation hint 2');
     */

    /**
     Sets multiple localized strings, using translation hints.
      @param {Array<String, String, String>} map
     A key-value object map to add to the strings dictionary.
     @example
     Coral.i18n.set([
     ['English string', 'Translated string 1', 'Translation hint 1'],
     ['English string', 'Translated string 2', 'Translation hint 2'],
     ['English string with {0} items', 'Translated string 1 with {0} items', 'Translation hint 1'],
     ['English string with {0} items', 'Translated string 2 with {0} items', 'Translation hint 2'],
     ['English string with {0}, {1} and {2} items', 'Translated string 1 with {0}, {1} and {2} items', 'Translation hint 1'],
     ['English string with {0}, {1} and {2} items', 'Translated string 2 with {0}, {1} and {2} items', 'Translation hint 2'],
     ['English string: {name}', 'Translated string 1: {name}', 'Translation hint 1'],
     ['English string: {name}', 'Translated string 2: {name}', 'Translation hint 2'],
     ['English string: {name1}, {name2}, and {name3}', 'Translated string 1: {name3}, {name1}, and {name2}', 'Translation hint 1'],
     ['English string: {name1}, {name2}, and {name3}', 'Translated string 2: {name3}, {name1}, and {name2}', 'Translation hint 2']
     ]);
     */
    // eslint-disable-next-line func-names


    _createClass(I18nProvider, [{
      key: "set",
      value: function set() {
        strings.generic[this._locale] = strings.generic[this._locale] || {};
        var key, value, translationHint;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        if (args.length === 0) {
          // Return empty string if called without arguments
          return '';
        } else if (args.length === 1) {
          if (!args[0]) {
            throw new Error('Coral.i18n.set: Single argument must be an array of arrays of key/value/(translation hint).');
          } // multiple keys
          else if (_typeof(args[0]) === 'object' && _typeof(args[0][0]) === 'object') {
              for (var i = 0; i < args[0].length; i++) {
                key = args[0][i][0];
                value = args[0][i][1];
                translationHint = args[0][i][2];

                if (translationHint) {
                  key = "".concat(key, "/[translation hint:").concat(translationHint.replace(/&period;/g, '.'), "]");
                }

                strings.generic[this._locale][key] = value;
              }
            } else {
              throw new Error('Coral.i18n.set: Single argument must be an array of key-value pairs.');
            }
        } // single key, no translation hint
        else if (args.length === 2) {
            if (typeof args[0] === 'string' && !!args[0] && typeof args[1] === 'string' && !!args[1]) {
              key = args[0];
              value = args[1];
              strings.generic[this._locale][key] = value;
            } else {
              throw new Error('Coral.i18n.set: Both arguments must be non-empty string values.');
            }
          } // single key, with translation hint
          else if (args.length === 3) {
              if (typeof args[0] === 'string' && typeof args[1] === 'string' && typeof args[2] === 'string') {
                key = args[0];
                value = args[1];
                translationHint = args[2];

                if (translationHint !== 'null') {
                  key = "".concat(key, "/[translation hint:").concat(translationHint.replace(/&period;/g, '.'), "]");
                }

                strings.generic[this._locale][key] = value;
              } else {
                throw new Error('Coral.i18n.set: All arguments must be of string type.');
              }
            } else {
              throw new Error('Coral.i18n.set: Too many arguments provided.');
            }

        return this;
      }
      /**
       Gets a localized string, using named arguments, and translation hint.
        @param {String} key the key of the string to retrieve
       @param {Object} args one more named arguments
       @param {String} translation_hint context information for translators
       @returns {String} the localized string with arguments
       @example
       Coral.i18n.get('English string: {name}', { name: 'foo' }, 'Translation hint 1'); // => 'Translated string 1: foo'
       Coral.i18n.get('English string: {name}', { name: 'foo' }, 'Translation hint 2'); // => 'Translated string 2: foo'
       Coral.i18n.get('English string: {name1}, {name2}, and {name3}', { name1: 'foo', name2: 'bar', name3: 'qux' }, 'Translation hint 1'); // => 'Translated string 1: qux, foo, and bar'
       Coral.i18n.get('English string: {name1}, {name2}, and {name3}', { name1: 'foo', name2: 'bar', name3: 'qux' }, 'Translation hint 2'); // => 'Translated string 2: qux, foo, and bar'
       */

      /**
       Gets a localized string, using arguments, and translation hint.
        @param {String} key the key of the string to retrieve
       @param {String} args one more arguments
       @param {String} translation_hint context information for translators
       @returns {String} the localized string with arguments
       @example
       Coral.i18n.get('English string: {0}', 10, 'Translation hint 1'); // => 'Translated string 1: 10')
       Coral.i18n.get('English string: {0}', 10, 'Translation hint 2'); // => 'Translated string 2: 10')
       Coral.i18n.get('English string: {0}, {1}, and {2}', 10, 20, 30, 'Translation hint 1'); // => 'Translated string 1: 30, 10, and 20'
       Coral.i18n.get('English string: {0}, {1}, and {2}', 10, 20, 30, 'Translation hint 2'); // => 'Translated string 2: 30, 10, and 20'
       */

      /**
       Gets a localized string, using translation hint.
        @param {String} key the key of the string to retrieve
       @param {String} translation_hint context information for translators
       @returns {String} the localized string
       @example
       Coral.i18n.get('English string', 'Translation hint 1'); // => 'Translated string 1'
       Coral.i18n.get('English string', 'Translation hint 2'); // => 'Translated string 2'
       */

      /**
       Gets a localized string, using named arguments.
        @param {String} key the key of the string to retrieve
       @param {Object} args one more named arguments
       @returns {String} the localized string with arguments
       @example
       Coral.i18n.get('English string: {name}', { name: 'foo' }); // => 'Translated string: foo'
       Coral.i18n.get('English string: {name1}, {name2}, and {name3}', { name1: 'foo', name2: 'bar', name3: 'qux' }); // => 'Translated string: qux, foo, and bar'
       */

      /**
       Gets a localized string, using arguments.
        @param {String} key the key of the string to retrieve
       @param {String} args one more arguments
       @returns {String} the localized string with arguments
       @example
       Coral.i18n.get('English string: {0}', 10); // => 'Translated string: 10'
       Coral.i18n.get('English string: {0}, {1}, and {2}', 10, 20, 30); // => 'Translated string: 30, 10, and 20'
       */

      /**
       Gets a localized string.
        @param {String} key the key of the string to retrieve
       @returns {String} the localized string
       @example
       Coral.i18n.get('English string'); // => 'Translated String'
       */
      // eslint-disable-next-line func-names

    }, {
      key: "get",
      value: function get() {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        if (args.length === 0) {
          // Return empty string if called without arguments
          return '';
        } // The first argument is always the key
        // Aladdin server stores periods in keys as HTML entities, so we need to match this


        var key = args[0].replace('.', '&period;'); // The number of required variables can be determined by parsing the string

        var placeholderMatches = key.match(this._evaluate);
        var variablePlaceholderCount = placeholderMatches ? placeholderMatches.length : 0; // The hint we'll use to translate

        var translationHint = '';
        var variables = {};
        var variableCount = 0;
        var i; // Verify the number of provided arguments matches the placeholder count

        if (args[1] !== null && _typeof(args[1]) === 'object') {
          variables = args[1]; // Check if provided variables object is complete

          var placeholderName = '';

          for (i = 0; i < placeholderMatches.length; i++) {
            placeholderName = placeholderMatches[i].slice(1).slice(0, -1);

            if (variables[placeholderName] === null || typeof variables[placeholderName] === 'undefined') {
              throw new Error("Coral.i18n.get: Named key \"".concat(placeholderName, "\" not present in provided object."));
            }
          } // If an additional argument is present, it's the translation hint


          if (typeof args[2] === 'string') {
            translationHint = args[2];
          }
        } else {
          // Assume no translation hint
          variableCount = args.length - 1;

          if (variableCount === variablePlaceholderCount + 1) {
            // If we've got an extra argument, assume it's a translation hint
            translationHint = args[args.length - 1];
          } else if (variableCount !== variablePlaceholderCount) {
            throw new Error("Coral.i18n.get: Number of variable placeholders (".concat(variablePlaceholderCount, ") does not match number of variables (").concat(variableCount, ")."));
          } // Build variables object


          for (i = 0; i < variableCount; i++) {
            variables[i] = args[i + 1];
          }
        } // Include translation hint


        if (translationHint) {
          key = "".concat(key, "/[translation hint:").concat(translationHint, "]");
        } // Fetch the string


        var str = key;

        for (var component in strings) {
          if (typeof strings[component] !== 'undefined' && typeof strings[component][this._locale] !== 'undefined') {
            str = strings[component][this._locale][key] || str;
          }
        } // Optimization for a string with no placeholder
        // e.g. Coral.i18n.get('English string');


        if (variablePlaceholderCount === 0) {
          return str;
        } // Replace all variables


        return str.replace(this._evaluate, function (name) {
          name = name.slice(1).slice(0, -1);
          return variables[name];
        }); // @todo use .toLocaleString(Coral.i18n.locale) in a future release
      }
      /**
       I18n current locale value. See {@link I18nLocalesEnum}.
       @type {String}
       */

    }, {
      key: "locale",
      get: function get() {
        return this._locale;
      },
      set: function set(newLocale) {
        this._locale = newLocale;
      }
    }]);

    return I18nProvider;
  }(); // sets default locale, based on document lang attribute, if it exists, or en-US otherwise


  var docLang = document.documentElement.lang.toLowerCase();
  var locale = locales[docLang] || 'en-US';
  /**
   An i18n service.

   @type {I18nProvider}
   */

  var i18n = new I18nProvider({
    locale: locale
  });

  /**
   A map of modifier names to their corresponding keycodes.
   @ignore
   */

  var modifierCodes = {
    '⇧': 16,
    'shift': 16,
    '⌥': 18,
    'alt': 18,
    'option': 18,
    '⌃': 17,
    'ctrl': 17,
    'control': 17,
    '⌘': 91,
    'cmd': 91,
    'command': 91,
    'meta': 91
  };
  /**
   Used to check if a key is a modifier.
   @ignore
   */

  var modifierCodeMap = {
    16: true,
    17: true,
    18: true,
    91: true,
    224: true
  };
  /**
   A list of modifier event property names in sorted key code order. Used to add keycodes for modifiers.
   @ignore
   */

  var modifierEventPropertyNames = ['shiftKey', 'ctrlKey', 'altKey', 'metaKey'];
  /**
   A map of key codes to normalize. These are duplicate keys such as the number pad.
   @ignore
   */

  var normalizedCodes = {
    // Numpad 0-9
    96: 48,
    97: 49,
    98: 50,
    99: 51,
    100: 52,
    101: 53,
    102: 54,
    103: 55,
    104: 56,
    105: 57
  }; // These keys are also implicitely used external

  var specialKeyCodes = {
    backspace: 8,
    tab: 9,
    // real event key is "enter" this will be mapped internally
    return: 13,
    pause: 19,
    capslock: 20,
    esc: 27,
    escape: 27,
    // real event key is " " this will be mapped internally
    space: 32,
    pageup: 33,
    pagedown: 34,
    end: 35,
    home: 36,
    // real event key is "arrowLeft" this will be mapped internally
    left: 37,
    // real event key is "arrowUp" this will be mapped internally
    up: 38,
    // real event key is "arrowRight" this will be mapped internally
    right: 39,
    // real event key is "arrowDown" this will be mapped internally
    down: 40,
    insert: 45,
    del: 46,
    delete: 46,
    period: 190,
    plus: 107,
    minus: 189,
    f1: 112,
    f2: 113,
    f3: 114,
    f4: 115,
    f5: 116,
    f6: 117,
    f7: 118,
    f8: 119,
    f9: 120,
    f10: 121,
    f11: 122,
    f12: 123,
    f13: 124,
    f14: 125,
    f15: 126,
    f16: 127,
    f17: 128,
    f18: 129,
    f19: 130,
    numlock: 144,
    scroll: 145
  }; // Match a namespaced event, such as ctrl+r.myNS

  var namespaceRE = /(.*?)(\..+)$/; // Match a selector that requires context

  var needsContextRE = /^[\x20\t\r\n\f]*[>+~]/;
  /**
   The set of tags to ignore hot keys when focused within for the default filter.

   @ignore
   */

  var restrictedTagNames = {
    INPUT: true,
    SELECT: true,
    TEXTAREA: true,
    // Support alphanumeric search
    'CORAL-SELECTLIST-ITEM': true
  };
  /**
   Normalize duplicate codes.
   @ignore
   */

  function normalizeCode(code) {
    return normalizedCodes[code] || code;
  }

  function mapSpecialEventKeyToSpecialAPIDefinition(eventKey) {
    // The official event.key is not compatible with this API special key registration, so map them
    switch (eventKey) {
      case 'enter':
        return 'return';

      case ' ':
        return 'space';

      case 'arrowup':
        return 'up';

      case 'arrowdown':
        return 'down';

      case 'arrowleft':
        return 'left';

      case 'arrowright':
        return 'right';

      default:
        return eventKey;
    }
  }
  /**
   Convert a key to its character code representation.

   @ignore

   @param key
   @return {*|Number}
   */


  function _keyToCode(key) {
    key = mapSpecialEventKeyToSpecialAPIDefinition(key.toLowerCase()); // Map special string representations to their character code equivalent

    var code = specialKeyCodes[key] || modifierCodes[key];

    if (!code && key.length > 1) {
      throw new Error("Coral.Keys: Key ".concat(key, " not recognized"));
    } // Return the special code from the map or the char code repesenting the character


    return code || key.toUpperCase().charCodeAt(0);
  }

  function cleanupFilteredListeners(keycombo, listeners, event) {
    var result = [];

    if (!listeners || !event.key || keycombo.indexOf('+') > 0) {
      return listeners;
    } // Check there is no registration conflict for same code registrations
    // For example: "." keyCharCode is 46 and "delete" keyCode is also 46


    var key = mapSpecialEventKeyToSpecialAPIDefinition(event.key.toLowerCase());

    for (var i = 0; i < listeners.length; i++) {
      if (listeners[i].originalString.indexOf(key) === 0 || key.indexOf(listeners[i].originalString) === 0) {
        result.push(listeners[i]);
      }
    }

    return result;
  }
  /**
   Handle key combination events.
   */


  var Keys = /*#__PURE__*/function () {
    /**
     @param {*} elOrSelector
     The selector or element to listen for keyboard events on. This should be the common parent of all
     elements you wish to listen for events on.
     @param {Object} [options]
     Options for this combo handler.
     @param {Function} [options.context]
     The desired value of the <code>this</code> keyword context when executing listeners. Defaults to the element on
     which the event is listened for.
     @param {Function} [options.preventDefault=false]
     Whether to prevent the default behavior when a key combo is matched.
     @param {Function} [options.stopPropagation=false]
     Whether to stop propagation when a key combo is matched.
     @param {Function} [options.filter]
     The filter function for keyboard events. This can be used to stop events from being triggered when they originate
     from specific elements. Defaults to {@link Keys.filterInputs}.
     */
    function Keys(elOrSelector, options) {
      _classCallCheck(this, Keys);

      options = options || {};

      if (typeof elOrSelector === 'undefined') {
        throw new Error("Coral.Keys: Cannot create a combo handler for ".concat(elOrSelector));
      } // Cache the element object


      this._el = typeof elOrSelector === 'string' ? document.querySelector(elOrSelector) : elOrSelector; // Use provided context

      this._context = options.context;
      /**
       The filter function to use when evaluating keypresses
       */

      this._filter = options.filter || this.constructor.filterInputs;
      /**
       Whether to prevent default
       */

      this._preventDefault = options.preventDefault || false;
      /**
       Whether to stop propagation and prevent default
       */

      this._stopPropagation = options.stopPropagation || false;
      /**
       A map of key code combinations to arrays of listener functions
       */

      this._keyListeners = [];
      /**
       A an array of key sequences objects
       */

      this._keySequences = [];
      /**
       The sorted array of currently pressed keycodes
       */

      this._currentKeys = [];
      /**
       The joined string representation of currently pressed keycodes
       */

      this._currentKeyCombo = [];
      /**
       The timeout that corresponds to sequences
       */

      this._sequenceTimeout = null;
      this._handleKeyDown = this._handleKeyDown.bind(this);
      this._handleKeyUp = this._handleKeyUp.bind(this);
      this._resetSequence = this._resetSequence.bind(this);
      this.reset = this.reset.bind(this); // Initialize immediately

      this.init();
    }

    _createClass(Keys, [{
      key: "_resetSequence",
      value: function _resetSequence() {
        window.clearTimeout(this._sequenceTimeout);

        this._keySequences.forEach(function (sequence) {
          // Reset each sequence
          sequence.currentPart = 0;
        });
      }
    }, {
      key: "_setCurrentKeyCombo",
      value: function _setCurrentKeyCombo(event) {
        // Build string for modifiers
        var currentModifiers = [];

        for (var i = 0; i < modifierEventPropertyNames.length; i++) {
          var propName = modifierEventPropertyNames[i];

          if (event[propName]) {
            currentModifiers.push(modifierCodes[propName.slice(0, -3)]);
          }
        } // Store current key combo


        this._currentKeyCombo = this._currentKeys.concat(currentModifiers).sort().join('+');
      }
      /**
       Reset the state of this instance. This resets the currently pressed keys.
        @function reset
        @returns {Keys} this, chainable.
       */

    }, {
      key: "reset",
      value: function reset() {
        // Only reset variables related to currently pressed keys
        // Don't mess with sequences
        this._currentKeys = [];
        this._currentKeyCombo = '';
        return this;
      }
    }, {
      key: "_processSequences",
      value: function _processSequences() {
        var _this = this;

        var activeSequenceListeners = []; // Check each sequence's state

        this._keySequences.forEach(function (sequence) {
          if (sequence.parts[sequence.currentPart] === _this._currentKeyCombo) {
            // If the current key combo in the sequence was pressed, increment the pointer
            sequence.currentPart++;
          } else {
            // Reset the sequence if a key was encountered out of sequence
            sequence.currentPart = 0;
          }

          if (sequence.currentPart === sequence.parts.length) {
            // If we've reached the end of the sequence, add it to the list of active sequences
            activeSequenceListeners.push(sequence); // Reset the sequence's state so it can be triggered again

            sequence.currentPart = 0;
          }
        });

        return activeSequenceListeners;
      }
    }, {
      key: "_executeListeners",
      value: function _executeListeners(event, keyup) {
        // Don't do anything if we don't have any keys pressed
        if (!this._currentKeyCombo) {
          return;
        } // Evaluate whether we should filter this keypress


        if (!this._filter(event)) {
          return;
        }

        var target = event.target || event.srcElement;
        var doc = Object.prototype.toString.call(event.currentTarget) === '[object Window]' ? event.currentTarget.document : event.currentTarget;
        var listeners = []; // Execute listeners associated with the current key combination

        var comboListeners = this._keyListeners[this._currentKeyCombo];
        comboListeners = cleanupFilteredListeners(this._currentKeyCombo, comboListeners, event); // If it is a combo key combination but we listen on the final key combination result or on special single char like "/"
        // E.g. we listen on "/" but the user presses "Shift+7" on a german-swiss keyboard
        // or we listen on "/" on the single key event on a US layout keyboard

        if (!keyup && !comboListeners) {
          if (event.key) {
            comboListeners = this._keyListeners[event.key.charCodeAt(0)];
            comboListeners = cleanupFilteredListeners(this._currentKeyCombo, comboListeners, event);
          }
        }

        var sequenceListeners;

        if (!keyup) {
          // Process sequences and get listeners associated with the current sequence
          // Don't do this on keyup as this breaks sequences with modifiers
          sequenceListeners = this._processSequences();
        }

        if (comboListeners && comboListeners.length) {
          listeners = listeners.concat(comboListeners);
        }

        if (sequenceListeners && sequenceListeners.length) {
          listeners = listeners.concat(sequenceListeners);
        }

        if (listeners && listeners.length) {
          for (var i = 0; i < listeners.length; i++) {
            var listener = listeners[i]; // Perform event delegation

            if (listener.selector) {
              var selector = ''; // This allows us to match when the delegation selector includes context

              if (listener.needsContext) {
                doc.id = doc.id || commons.getUID();
                selector = "#".concat(doc.id, " ");
              }

              var matches = Array.prototype.indexOf.call(doc.querySelectorAll(selector + listener.selector), target) >= 0; // Skip if the originating element doesn't match the selector

              if (!matches) {
                continue;
              }
            } // Add data to event object


            if (typeof listener.data !== 'undefined') {
              event.data = listener.data;
            } // Add matchedTarget


            event.matchedTarget = target; // Add keys that triggered the event

            event.keys = listener.originalString;
            listener.listener.call(this._context || doc, event);
          } // Don't do the default thing


          if (this._preventDefault) {
            event.preventDefault();
          }

          if (this._stopPropagation) {
            event.stopPropagation();
          }
        }
      }
    }, {
      key: "_handleKeyDown",
      value: function _handleKeyDown(event) {
        window.clearTimeout(this._sequenceTimeout);
        this._sequenceTimeout = window.setTimeout(this._resetSequence, this.constructor.sequenceTime); // Store pressed key in array

        var key = normalizeCode(event.keyCode); // Don't do anything when a modifier is pressed

        if (modifierCodeMap[key]) {
          return;
        }

        if (this._currentKeys.indexOf(key) === -1) {
          this._currentKeys.push(key);

          this._setCurrentKeyCombo(event);
        }

        this._executeListeners(event); // Workaround: keyup events are never triggered while the command key is down, so reset the list of keys


        if (event.metaKey) {
          this.reset();
        }

        if (!event.target.parentNode) {
          // Workaround: keyup events are never triggered if the element does not have a parent node
          this.reset();
        }
      }
    }, {
      key: "_handleKeyUp",
      value: function _handleKeyUp(event) {
        var key = normalizeCode(event.keyCode);

        if (modifierCodeMap[key]) {
          // Workaround: keyup events are not triggered when command key is down on Mac, so if the command key is
          // released, consider all keys released
          // Test: comment this out, press K, press L, press Command, release L, release Command, then release K -- L is
          // triggered. This also prevents handlers for related key combos to be triggered
          // Test: comment this out, press Control, press Alt, press A, press S, release Alt, release S -- Control+A is
          // triggered
          this.reset(); // We don't ever want to execute handlers when a modifier is released, and we can't since they don't end up in
          // currentKeys. If we weren't doing the index check below, that could result in key combo handlers for ctrl+r to
          // be triggered when someone released alt first after triggering ctrl+alt+r. In any case, return to avoid the
          // uselss extra work

          return;
        } // Remove key from array


        var index = this._currentKeys.indexOf(key);

        if (index !== -1) {
          this._currentKeys.splice(index, 1); // If too many keys are pressed, then one is removed, make sure to check for a match


          this._setCurrentKeyCombo(event);

          this._executeListeners(event, true);
        }
      }
    }, {
      key: "_keySequenceStringToArray",
      value: function _keySequenceStringToArray(keyCombo) {
        return keyCombo.toString().split('-').map(this._keyComboToCodeString);
      }
      /**
       Add a key combo listener.
        @function on
       @param {String} keyCombo
       The key combination to listen for, such as <code>'ctrl-f'</code>.
       @param {String} [selector]
       A selector to use for event delegation.
       @param {String} [data]
       Data to pass to listeners as <code>event.data</code>.
       @param {Function} listener
       The listener to execute when this key combination is pressed. Executes on keydown, or, if too many keys are
       pressed and one is released, resulting in the correct key combination, executes on keyup.
        @returns {Keys} this, chainable.
       */

    }, {
      key: "on",
      value: function on(keyCombo, selector, data, listener) {
        // keyCombo can be a map of keyCombos to handlers
        if (_typeof(keyCombo) === 'object') {
          // ( keyCombo-Object, selector, data )
          if (typeof selector !== 'string') {
            // ( keyCombo-Object, data )
            // ( keyCombo-Object, null, data )
            data = data || selector;
            selector = undefined;
          }

          for (var combo in keyCombo) {
            this.on(combo, selector, data, keyCombo[combo]);
          }

          return this;
        }

        if (typeof data === 'undefined' && typeof listener === 'undefined') {
          // ( keyCombo, listener )
          listener = selector;
          data = selector = undefined;
        } else if (typeof listener === 'undefined') {
          if (typeof selector === 'string') {
            // ( keyCombo, selector, listener )
            listener = data;
            data = undefined;
          } else {
            // ( keyCombo, data, listener )
            listener = data;
            data = selector;
            selector = undefined;
          }
        }

        if (typeof listener !== 'function') {
          throw new Error("Coral.Keys: Cannot add listener of type ".concat(_typeof(listener)));
        }

        var namespace;
        var namespaceMatch = namespaceRE.exec(keyCombo);

        if (namespaceMatch) {
          keyCombo = namespaceMatch[1];
          namespace = namespaceMatch[2];
        } // Determine if this selector needs context when evaluating event delegation
        // A selector needs context when it includes things like >, ~, :first-child, etc


        var needsContext = selector ? needsContextRE.test(selector) : false; // Check if the string is a sequence or a keypress

        if (keyCombo.toString().indexOf('-') !== -1 && keyCombo.toString().length > 1) {
          // It's a sequence!
          // Divide it into its parts and convert to a code string
          var sequenceParts = this._keySequenceStringToArray(keyCombo); // Store the listener and associated information in the list for this sequence


          this._keySequences.push({
            originalString: keyCombo,
            currentPart: 0,
            parts: sequenceParts,
            needsContext: needsContext,
            selector: selector,
            listener: listener,
            data: data,
            namespace: namespace
          });
        } else {
          var originalString = keyCombo.toString(); // It's a key combo!

          keyCombo = this._keyComboToCodeString(keyCombo);
          var listeners = this._keyListeners[keyCombo] = this._keyListeners[keyCombo] || []; // Store the listener and associated information in the list for this keyCombo

          listeners.push({
            originalString: originalString,
            // Determine if this selector needs context when evaluating event delegation
            // A selector needs context when it includes things like >, ~, :first-child, etc
            needsContext: selector ? needsContextRE.test(selector) : false,
            selector: selector,
            listener: listener,
            data: data,
            namespace: namespace
          });
        }

        return this;
      }
    }, {
      key: "_offByKeyComboString",
      value: function _offByKeyComboString(keyComboString, namespace, selector, listener) {
        var i;
        var listeners = this._keyListeners[keyComboString];

        if (listeners && listeners.length) {
          if (typeof selector === 'undefined' && typeof listener === 'undefined' && typeof namespace === 'undefined') {
            // Unbind all listeners for this key combo
            listeners.length = 0;
          } else if (typeof listener === 'undefined') {
            // Unbind all listeners of a specific selector and or namespace
            for (i = 0; i < listeners.length; i++) {
              // This comparison works because selector and namespace are undefined by default
              if (listeners[i].selector === selector && listeners[i].namespace === namespace) {
                listeners.splice(i, 1);
                i--;
              }
            }
          } else {
            // Unbind a specific listener, optionally on a specific selector and specific namespace
            for (i = 0; i < listeners.length; i++) {
              if (listeners[i].listener === listener && listeners[i].selector === selector && listeners[i].namespace === namespace) {
                listeners.splice(i, 1);
                i--;
              }
            }
          }
        }
      }
      /**
       Remove a key combo listener.
        @function off
       @param {String} keyCombo
       The key combination to listen for, such as <code>'ctrl-f'</code>.
       @param {String} [selector]
       A selector to use for event delegation.
       @param {Function} listener
       The listener that was passed to on.
        @returns {Keys} this, chainable.
       */

    }, {
      key: "off",
      value: function off(keyCombo, selector, listener) {
        if (typeof listener === 'undefined') {
          listener = selector;
          selector = undefined;
        }

        var i;
        var namespace;
        var namespaceMatch = namespaceRE.exec(keyCombo);

        if (namespaceMatch) {
          keyCombo = namespaceMatch[1];
          namespace = namespaceMatch[2];
        }

        if (keyCombo === '' && namespace !== undefined) {
          // If we have a namespace by no keyCombo, remove all events of the namespace for each key combo
          for (keyCombo in this._keyListeners) {
            this._offByKeyComboString(keyCombo, namespace, selector, listener);
          } // Remove sequences


          for (i = 0; i < this._keySequences.length; i++) {
            if (this._keySequences[i].namespace === namespace) {
              this._keySequences.splice(i, 1);

              i--;
            }
          }

          return this;
        }

        if (keyCombo.indexOf('-') !== -1) {
          // Unbind a specific key sequence listener, optionally on a specific selector and specific namespace
          for (i = 0; i < this._keySequences.length; i++) {
            if ((keyCombo === undefined || this._keySequences[i].originalString === keyCombo) && (listener === undefined || this._keySequences[i].listener === listener) && (selector === undefined || this._keySequences[i].selector === selector) && (namespace === undefined || this._keySequences[i].namespace === namespace)) {
              this._keySequences.splice(i, 1);

              i--;
            }
          }
        } else {
          keyCombo = this._keyComboToCodeString(keyCombo);

          this._offByKeyComboString(keyCombo, namespace, selector, listener);
        }

        return this;
      }
      /**
       Destroy this instance. This removes all event listeners, references, and state.
        @function destroy
       @param {Boolean} globalsOnly
       Whether only global listeners should be removed
        @returns {Keys} this, chainable.
       */

    }, {
      key: "destroy",
      value: function destroy(globalsOnly) {
        if (!globalsOnly) {
          this._keyListeners = null;
          this._currentKeys = null;
          this._currentKeyCombo = null;

          this._el.removeEventListener('keydown', this._handleKeyDown);
        }

        window.removeEventListener('keyup', this._handleKeyUp, true);
        window.removeEventListener('focus', this.reset);
        return this;
      }
      /**
       Initialize an instance created without the <code>new</code> keyword or revive a destroyed instance. This method
       will be called automatically if an instance is created with <code>new Coral.keys</code>.
        @function init
       @param {Boolean} globalsOnly
       Whether only global listeners should be added
        @returns {Keys} this, chainable.
       */

    }, {
      key: "init",
      value: function init(globalsOnly) {
        if (!globalsOnly) {
          // Reset all variable states
          this._currentKeys = [];
          this._currentKeyCombo = '';
          this._keyListeners = {};
          this._keySequences = [];

          this._el.addEventListener('keydown', this._handleKeyDown);
        } // Remove window event listeners first to avoid memory leak


        this.destroy(true); // Watching on capture so it is immune to stopPropagation(). It's very important this event
        // is handled so key entries previously added on keydown can be cleared out.
        // If multiple identical EventListeners are registered on the same EventTarget with the same parameters the
        // duplicate instances are discarded. They do not cause the EventListener to be called twice.

        window.addEventListener('keyup', this._handleKeyUp, true);
        window.addEventListener('focus', this.reset);
        return this;
      }
      /**
       The default keycombo event filter function. Ignores key combos triggered on input, select, and textarea.
        @param event
       The event passed
        @returns {Boolean} True, if event.target is not editable and event.target.tagname is not restricted
       */

    }, {
      key: "_keyComboToCodeString",

      /**
       Convert a combination of keys separated by + into the corresponding code string.
       @ignore
       */
      value: function _keyComboToCodeString(keyCombo) {
        // if single "+"
        if (keyCombo === '+') {
          return _keyToCode(keyCombo);
        }

        return keyCombo // Convert to string so numbers are supported
        .toString().split('+').map(_keyToCode) // Sort keys for easy comparison
        .sort().join('+');
      }
    }], [{
      key: "filterInputs",
      value: function filterInputs(event) {
        // Escape keycode doesn't have to be filtered
        if (event.keyCode === specialKeyCodes.escape) {
          return true;
        }

        var target = event.target;
        var tagName = target.tagName;
        var isContentEditable = target.isContentEditable;
        var isRestrictedTag = restrictedTagNames[tagName];
        return !isContentEditable && !isRestrictedTag;
      }
      /**
       Convert a key to its character code representation.
        @param {String} key
       The key character that needs to be converted. If the String contains more than one character, an error will be
       produced.
        @returns {Number} The character code of the given String.
       */

    }, {
      key: "keyToCode",
      value: function keyToCode(key) {
        return _keyToCode(key);
      }
      /**
       The time allowed between keypresses for a sequence in miliseconds
       @type {Number}
       @default 1500
       */

    }, {
      key: "sequenceTime",
      get: function get() {
        return 1500;
      }
    }]);

    return Keys;
  }();
  /**
   A key listener for global hotkeys is exposed for document eventing handling.

   @type {Keys}
   */
  // Register against the documentElement, <html>, so event delegation works


  var keys$1 = new Keys(document.documentElement, {
    // Don't let global hotkeys trigger default actions
    stopPropagation: true,
    preventDefault: true
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   Set of property value transformation functions.
   */
  var Transformation = /*#__PURE__*/function () {
    function Transformation() {
      _classCallCheck(this, Transformation);
    }

    _createClass(Transformation, [{
      key: "boolean",

      /**
       Transform the provided value into a boolean. Follows the behavior of JavaScript thruty/falsy.
        @param {*} value
       The value to convert to Boolean.
        @returns {Boolean} The corresponding boolean value.
       */
      value: function boolean(value) {
        return !!value;
      }
      /**
       Transform the provided value into a boolean. Follows the behavior of the HTML specification, in which the existence of
       the attribute indicates <code>true</code> regardless of the attribute's value. If the value is a boolean, it ignores
       the transformation.
        @param {*} value
       The value to convert to Boolean.
        @returns {Boolean} The corresponding boolean value.
       */

    }, {
      key: "booleanAttr",
      value: function booleanAttr(value) {
        return typeof value === 'boolean' ? value : !(value === null || typeof value === 'undefined');
      }
      /**
       Transforms the provided value into a floating point number.
        @param {*} value
       The value to convert to a Number.
        @returns {?Number} The corresponding number or <code>null</code> if the passed value cannot be converted to a number.
       */

    }, {
      key: "number",
      value: function number(value) {
        value = parseFloat(value);
        return isNaN(value) ? null : value;
      }
      /**
       Transforms the provided value into a floating number. The conversion is strict in the sense that if non numeric values
       are detected, <code>null</code> is returned instead.
        @param {*} value
       The value to be converted to a Number.
        @retuns {?Number} The corresponding number or <code>null</code> if the passed value cannot be converted to number.
       */

    }, {
      key: "float",
      value: function float(value) {
        if (/^(-|\+)?([0-9]+(\.[0-9]+)?|Infinity)$/.test(value)) {
          return Number(value);
        }

        return null;
      }
      /**
       Transform the provided value into a string. When given <code>null</code> or <code>undefined</code> it will be
       converted to an empty string("").
        @param {*} value
       The value to convert to String.
        @returns {String} The corresponding string value.
       */

    }, {
      key: "string",
      value: function string(value) {
        if (value === null || typeof value === 'undefined') {
          return '';
        }

        return typeof value === 'string' ? value : String(value);
      }
    }]);

    return Transformation;
  }();
  /**
   A type transform utility.

   @type {Transformation}
   */


  var transform = new Transformation();

  /**
   Set of property value validation functions.
   */

  var Validation = /*#__PURE__*/function () {
    function Validation() {
      _classCallCheck(this, Validation);
    }

    _createClass(Validation, [{
      key: "valueMustChange",

      /**
       Ensures that the value has changed.
        @param {*} newValue
       The new value.
       @param {*} oldValue
       The existing value.
        @returns {Boolean} <code>true</code> if the values are different.
       */
      value: function valueMustChange(newValue, oldValue) {
        // We can use exact equality here as validation functions are called after transform. Thus, the input value will be
        // converted to the same type as a stored value
        return newValue !== oldValue;
      }
      /**
       Ensures that the new value is within the enumeration. The enumeration can be given as an array of values or as a
       key/value Object. Take into consideration that enumerations are case sensitive.
        @example // Enumeration as Array
       Coral.validate.enumeration(['xs', 's', 'm', 'l']);
       @example // Enumeration as Object
       Coral.validate.enumeration({EXTRA_SMALL : 'xs', SMALL : 's', MEDIUM : 'm', LARGE : 'l'});
       @param {Object} enumeration
       Object that represents an enum.
        @returns {ValidationFunction}
       a validation function that ensures that the given value is within the enumeration.
       */

    }, {
      key: "enumeration",
      value: function enumeration(_enumeration) {
        // Reverses the enumeration, so that we can check that the variable new value exists inside
        var enumReversed = commons.swapKeysAndValues(_enumeration); // Returns a new function that matches the newValue, oldValue signature

        return function (newValue) {
          return typeof enumReversed[newValue] !== 'undefined';
        };
      }
    }]);

    return Validation;
  }();
  /**
   Signature of the function used to validate new input. It accepts a newValue and an oldValue which are used to
   determine if the newValue is valid.

   @typedef {function} ValidationFunction

   @param {*} newValue
   The new value to validate.
   @param {*} oldValue
   The existing value.

   @returns {Boolean} <code>true</code> if the validation succeeded, otherwise <code>false</code>.
   */

  /**
   A property transform utility.

   @type {Validation}
   */


  var validate = new Validation();

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   Signature function used to track the usage of Coral components. By default, there is no out of the box
   implementation as tracking is agnostic of the underlying technology.

   You need to implement a new tracker and add it with: <code>Coral.tracking.addListener(fn(){ });</code>

   The <code>fn()</code> callback will receive multiple arguments:
   * <code>trackData</code> - an object with fixed structure e.g. <code>{type: "button", eventType: "click", element: "save settings", feature: "sites"}</code>
   * <code>event</code> - the CustomEvent or MouseEvent details object.
   * <code>component</code> - the component reference object.

   Using the above data you can map it to your own analytics tracker.
   */
  var Tracking = /*#__PURE__*/function () {
    /* @ignore */
    function Tracking() {
      _classCallCheck(this, Tracking);

      /**
       All registered trackers.
        @type {Array<Function>}
       */
      this._trackers = [];
    }
    /**
     Returns <code>true</code> if the tracking is disabled for the given component, otherwise false.
      @param {HTMLElement} component
     @returns {Boolean}
     */


    _createClass(Tracking, [{
      key: "_isTrackingDisabledForComponent",
      value: function _isTrackingDisabledForComponent(component) {
        return component && typeof component.tracking !== 'undefined' && component.tracking === component.constructor.tracking.OFF;
      }
      /**
       Get tracking annotations from the parent Component to which the event was bound.
        @param {BaseComponent} component
       @returns {{trackingElement: String, trackingElement: String}}
       */

    }, {
      key: "_getTrackingDataFromComponentAttr",
      value: function _getTrackingDataFromComponentAttr(component) {
        if (this._isTrackingDisabledForComponent(component)) {
          return {
            trackingElement: '',
            trackingFeature: ''
          };
        } // Eg. from DOM trackingfeature="sites"


        var trackingFeature = component.trackingFeature || ''; // Eg. from DOM trackingelement="rail toggle"

        var trackingElement = component.trackingElement || '';
        return {
          trackingFeature: trackingFeature,
          trackingElement: trackingElement
        };
      }
      /**
       Returns a tracking data object that can be used to compile data to send to an actual Analytics tracker.
        @param {String} eventType
       @param {String} targetType
       @param {CustomEvent} event
       @param {BaseComponent} component
       @param {BaseComponent} childComponent
       @returns {Object} An object with the tracking data.
       */

    }, {
      key: "_createTrackingData",
      value: function _createTrackingData(eventType, targetType, event, component, childComponent) {
        var parentComponentType = (component.getAttribute('is') || component.tagName).toLowerCase(); // Gather data into the Coral Tracking structure.

        var trackDataFromAttr = this._getTrackingDataFromComponentAttr(component); // Compile data

        /**
         The default Coral tracking data object
         filled with values from root Component and child Component (if exists).
         @type {{targetType: string, targetElement: string, eventType: string, rootElement: string, rootFeature: string, rootType: string}}
         */


        return {
          targetType: targetType || parentComponentType || '',
          targetElement: childComponent && childComponent.trackingElement ? childComponent.trackingElement : component.trackingElement,
          eventType: eventType || event.type,
          rootElement: trackDataFromAttr.trackingElement,
          rootFeature: trackDataFromAttr.trackingFeature,
          rootType: parentComponentType
        };
      }
      /**
       Add a tracking callback. This will be invoked every time a tracking event is emitted.
        @param {TrackingCallback} trackingCallback
       The callback to execute.
       */

    }, {
      key: "addListener",
      value: function addListener(trackingCallback) {
        if (typeof trackingCallback !== 'function') {
          throw new Error('Coral.Tracking: Tracker must be a function callback.');
        }

        if (this._trackers.indexOf(trackingCallback) !== -1) {
          throw new Error('Coral.Tracking: Tracker callback cannot be added twice.');
        }

        this._trackers.push(trackingCallback);
      }
      /**
       Removes a tracker.
        @param {TrackingCallback} trackingCallback
       */

    }, {
      key: "removeListener",
      value: function removeListener(trackingCallback) {
        this._trackers = this._trackers.filter(function (trackerFn) {
          return trackerFn !== trackingCallback;
        });
      }
      /**
       Notify all trackers subscribed.
        @param {String} eventType
       Eg. click, select, etc.
       @param {String} targetType
       Eg. cycle button, cycle button item, etc.
       @param {CustomEvent} event
       @param {BaseComponent} component
       @param {BaseComponent} childComponent
       Optional, in case the event occurred on a child component.
       @returns {Boolean} if the event was dispatch to at least 1 tracker.
       */

    }, {
      key: "track",
      value: function track(eventType, targetType, event, component, childComponent) {
        if (this._trackers.length === 0 || this._isTrackingDisabledForComponent(component) || this._isTrackingDisabledForComponent(childComponent)) {
          return false;
        }

        var args = Array.prototype.slice.call(arguments, [2]);

        var trackingData = this._createTrackingData(eventType, targetType, event, component, childComponent);

        this._trackers.forEach(function (trackerFn) {
          trackerFn.apply(null, [trackingData].concat(args));
        });

        return true;
      }
    }]);

    return Tracking;
  }();
  /**
   Executes the callback when ever there is an interaction inside the component that needs to be tracked. This can be used
   to get insight on how users interact with the page and the features that available.

   @typedef {function} TrackingCallback

   @param {Object} trackData
   Object containing the data to be tracked. It contains the properties <code>type</code>, <code>eventType</code>,
   <code>element</code> and <code>feature</code>.
   @param {CustomEvent} event
   Underlying event that was generated by the user
   @param {HTMLElement} component
   Component that triggered the tracking event.
   */

  /**
   Tracking API to get insight on component usage.

   @type {Tracking}
   */


  var tracking = new Tracking();

  var delegateEventSplitter = /^(\S+)\s*(.*)$/; // Enum value is referenced for speed

  var ELEMENT_NODE = Node.ELEMENT_NODE;
  /**
   Return the method corresponding to the method name or the function, if passed.

   @ignore
   */

  function getListenerFromMethodNameOrFunction(obj, eventName, methodNameOrFunction) {
    // Try to get the method
    if (typeof methodNameOrFunction === 'function') {
      return methodNameOrFunction;
    } else if (typeof methodNameOrFunction === 'string') {
      if (!obj[methodNameOrFunction]) {
        throw new Error('Coral.Component: Unable to add ' + eventName + ' listener for ' + obj.toString() + ', method ' + methodNameOrFunction + ' not found');
      }

      var listener = obj[methodNameOrFunction];

      if (typeof listener !== 'function') {
        throw new Error('Coral.Component: Unable to add ' + eventName + ' listener for ' + obj.toString() + ', listener is a ' + _typeof(listener) + ' but should be a function');
      }

      return listener;
    } else if (methodNameOrFunction) {
      // If we're passed something that's truthy (like an object), but it's not a valid method name or a function, get
      // angry
      throw new Error('Coral.Component: Unable to add ' + eventName + ' listener for ' + obj.toString() + ', ' + methodNameOrFunction + ' is neither a method name or a function');
    }

    return null;
  }
  /**
   @class Component
   @classdesc The base element for all Coral components
   @extends {HTMLElement}
   */


  var Component = function Component() {
    throw new Error('Coral.Component is not meant to be invoked directly. Inherit from its prototype instead.');
  }; // Inherit from HTMLElement


  Component.prototype = Object.create(HTMLElement.prototype); // Store a reference to properties

  Component.prototype._properties = {};
  /**
   Return this component's name.

   @ignore
   */

  Component.prototype.toString = function () {
    if (this._namespace === window.Coral) {
      return "Coral.".concat(this._componentName);
    }

    return this._componentName;
  };
  /**
   Events map. Key is Backbone-style event description, value is string indicating method name or function. Handlers
   are always called with <code>this</code> as the element.

   @type {Object}
   @protected
   */


  Component.prototype._events = {};
  /**
   Called when the component is being constructed. This method applies the CSS class, renders the component, binds
   events, and sets initial property values.

   {@link Component#_initialize} is called after the above operations are complete.
   @protected
   */

  Component.prototype.createdCallback = function () {
    // We have to add toString directly on the instance or it doesn't work in IE 9
    // A side-effect of this is that toString cannot be overridden
    if (this.toString !== Component.prototype.toString) {
      this.toString = Component.prototype.toString;
    } // Track which properties have been set
    // This is used when setting defaults


    this._setProps = {};
    this._syncQueue = []; // Make sure context is correct when called by nextFrame

    this._syncDOM = this._syncDOM.bind(this); // Create a Vent instance to handle local events

    this._vent = new Vent(this); // Apply the class name

    if (this._className) {
      this.classList.add.apply(this.classList, this._className.split(' '));
    } // Create the elements property before the template. Templates that use handle="someName" attrs will need this


    this._elements = {}; // Render template, if necessary

    if (typeof this._render === 'function') {
      this._render();
    }

    var prop;
    var attr;
    var value;
    var descriptor;
    var methods; // A hash where all the content zone names are stored using the tagName as key and property as value

    this._contentZones = {}; // A list of attribute values indexed by property name
    // prop -> attrValue

    var attrValues = {}; // Build a cache of attribute values provided via the markup and check for content zones

    for (prop in this._properties) {
      descriptor = this._properties[prop];

      if (descriptor.contentZone) {
        // Check if the tag name is unique
        if (this._contentZones[descriptor.tagName]) {
          commons._log('warn', 'Coral.Component: content zone for "%s" is already defined', descriptor.tagName);
        } // Add the prop to the hash


        this._contentZones[descriptor.tagName] = prop;
      } // Use the attribute name specified by the map


      attr = descriptor.attribute || prop; // Fetch the attribute corresponding to the property from the element

      attrValues[prop] = this.getAttribute(attr);
    } // Apply default values for all properties and their associated attributes


    for (prop in this._properties) {
      descriptor = this._properties[prop];
      methods = descriptor._methods; // Get the attribute value from the cache

      value = attrValues[prop];

      if (value !== null) {
        // Since the value is loaded as an attribute, it needs to be transformed from its attribute value
        if (methods.attributeTransform) {
          value = methods.attributeTransform.call(this, value, descriptor.default);
        } // Run the value transform function


        if (descriptor.transform) {
          value = methods.transform.call(this, value, descriptor.default);
        } // Check if the value valdiates


        if (methods.validate) {
          for (var i = 0; i < methods.validate.length; i++) {
            // Don't pass the old value
            if (!methods.validate[i].call(this, value)) {
              // If it fails validation, we'll use the default
              value = null;
              break;
            }
          }
        }
      }

      if (value === null) {
        // If the property has already been set in another setter, don't apply the default
        if (this._setProps[prop]) {
          continue;
        } // If the default is a function we call it


        if (typeof descriptor.default === 'function') {
          // Call method if the default value is a method
          value = descriptor.default.call(this);
        } else {
          // Otherwise we set it from the descriptor directly
          value = descriptor.default;
        } // If the value that came out of the default is undefined,
        // this means that the property does not really have a default value
        // so we continue in order to avoid setting it


        if (typeof value === 'undefined') {
          continue;
        }
      } // Invoke the setter silently so we don't trigger "change" events on initialization


      this.set(prop, value, true);
    }

    this._delegateEvents(); // Call the initialize method, if necessary


    if (typeof this._initialize === 'function') {
      this._initialize();
    } // Add MutationObserver for content zones


    if (Object.keys(this._contentZones).length) {
      // Watch for childlist modifications
      this._observer = new MutationObserver(this._handleContentZones.bind(this));

      this._observer.observe(this, {
        childList: true,
        subtree: false // don't care about nested stuff

      });
    } // Trigger ready event


    this._componentReady = true;
  };
  /**
   Detects when items are added and removed to make sure that the state of the content zone is accurate.

   @param {Array.<MutationRecord>} records

   @private
   */


  Component.prototype._handleContentZones = function (records) {
    var record;
    var addedNodes;
    var removedNodes;
    var node;
    var tagName;
    var propertyName;

    for (var i = 0, recordsCount = records.length; i < recordsCount; i++) {
      record = records[i];
      addedNodes = record.addedNodes;
      removedNodes = record.removedNodes; // Handle removed nodes

      for (var k = 0, removedNodesCount = removedNodes.length; k < removedNodesCount; k++) {
        node = removedNodes[k]; // only bother with element nodes

        if (node.nodeType === ELEMENT_NODE) {
          tagName = node.tagName.toLowerCase(); // we use the content zone hash to check if there is an item assigned

          propertyName = this._contentZones[tagName]; // the content zone needs to be cleared if it matches the previous item; while calling the insert, content
          // zones are removed and added again in the correct location triggering a mutation

          if (propertyName && this[propertyName] === node && node.parentNode === null) {
            this[propertyName] = undefined;
          }
        }
      } // Handle added nodes


      for (var j = 0, addedNodesCount = addedNodes.length; j < addedNodesCount; j++) {
        node = addedNodes[j]; // only bother with element nodes

        if (node.nodeType === ELEMENT_NODE) {
          tagName = node.tagName.toLowerCase(); // check if the added node matches a content zone; use the content zone hash to find if the tag name exists

          propertyName = this._contentZones[tagName]; // we update the content zone if the value is different than the current

          if (propertyName && this[propertyName] !== node) {
            // assign to content zone
            this[propertyName] = node;
          }
        }
      }
    }
  };
  /**
   Called after the element has been constructed, template rendered, and attributes applied.

   @function _initialize
   @protected
   @memberof Component#
   */

  /**
   The CSS class name to apply to the element.

   @type {String}
   @member _className
   @protected
   @memberof Component#
   */

  /**
   Called during construction, is responsible for rendering any required sub-elements.

   @function _render
   @protected
   @memberof Component#
   */

  /**
   The filter function for keyboard events. By default, any child element can trigger keyboard events. You can pass
   {@link Coral.Keys.filterInputs} to avoid listening to key events triggered from within inputs.

   @function _filterKeys
   @protected
   @memberof Component#
   */


  Component.prototype._filterKeys = function () {
    return true;
  };
  /**
   Called when this element is inserted into the DOM.

   @fires Component#coral-component:attached
   @private
   */


  Component.prototype.attachedCallback = function () {
    this.trigger('coral-component:attached'); // A component that is in the DOM should respond to global events

    this._delegateGlobalEvents();
  };
  /**
   Called when this element is removed from the DOM.

   @fires Component#coral-component:detached
   @private
   */


  Component.prototype.detachedCallback = function () {
    this.trigger('coral-component:detached'); // A component that isn't in the DOM should not be responding to global events

    this._undelegateGlobalEvents();
  };
  /**
   Apply attribute changes by invoking setters. This creates a one-way relationship between attributes and properties.
   Changing an attribute updates the property, but changing the property does not update the attribute.

   @private
   */


  Component.prototype.attributeChangedCallback = function (attrName, oldValue, newValue) {
    // Use the property name from the attribute map, otherwise just set the property by the same name
    var propName = this._attributes[attrName] || attrName; // Case 1: We are handling sets/gets for this property

    var descriptor = this._properties[propName];

    if (typeof descriptor !== 'undefined') {
      if (descriptor.attribute === null) {
        // Don't set properties that have explicitly asked to have no corresponding attribute
        return;
      }

      ['attributeTransform', 'transform'].forEach(function (v) {
        // Use the stored methods
        var transform = descriptor._methods[v];

        if (transform) {
          newValue = transform.call(this, newValue, descriptor.default);
        }
      }, this); // Don't bother with the setter unless the value changed

      if (newValue !== this[propName]) {
        // Just invoke setter
        this[propName] = newValue;
      }
    } // Case 2: We have a passive setter for this attribute


    if (this._properties['_' + propName]) {
      this._properties['_' + propName].set.call(this, newValue);
    }
  };
  /**
   Queue a DOM sync for the next animation frame. In order for this to work as expected, sync methods should never
   rely on the result of another value being synced.

   @protected
   */


  Component.prototype._queueSync = function () {
    for (var i = 0, ni = arguments.length; i < ni; i++) {
      var propName = arguments[i]; // Check if a sync is already queued

      var currentIndex = this._syncQueue.indexOf(propName);

      if (currentIndex !== -1) {
        // Move to the bottom of the queue.
        // This is necessary if a sync has already been queued for a property,
        // but another property sync is queued and specifies that this sync should come later.
        // This happens when Button.text is synced, as it wants to sync icon afterwards
        this._syncQueue.splice(currentIndex, 1);
      } // Queue the sync


      this._syncQueue.push(propName);
    }

    if (!this._syncPending) {
      window.requestAnimationFrame(this._syncDOM);
      this._syncPending = true;
    }
  };
  /**
   Sync the specified property to the DOM.

   @param {String} propName
   The name of the property to sync.
   @param {Boolean} [leaveInQueue=false]
   Whether the property should be left in the queue.

   @protected
   */


  Component.prototype._syncProp = function (propName, leaveInQueue) {
    // De-queue each sync operation
    var method = this._properties[propName].sync;

    if (method) {
      method.call(this);
    } else {
      commons._log('warn', 'Coral.Component: sync method for %s is not defined', propName);
    }

    if (!leaveInQueue) {
      var index = this._syncQueue.indexOf(propName);

      if (index !== -1) {
        this._syncQueue.splice(index, 1);
      }
    }
  };
  /**
   Sync all changed properties to the DOM.

   @protected
   */


  Component.prototype._syncDOM = function () {
    var propName; // De-queue each sync operation

    while (propName = this._syncQueue.shift()) {
      // Sync the property, and avoid removing it because we already have
      this._syncProp(propName, true);
    }

    this._syncPending = false;
  };
  /**
   Add local event and key combo listeners for this component, store global event/key combo listeners for later.

   @private

   @returns {Component} this, chainable.
   */


  Component.prototype._delegateEvents = function () {
    /*
     Add listeners to new event
     - Include in hash
     Add listeners to existing event
     - Override method and use super
     Remove existing event
     - Pass null
     */
    var match;
    var eventName;
    var eventInfo;
    var listener;
    var selector;
    var elements;
    var isGlobal;
    var isKey;
    var isResize;
    var isCapture;

    for (eventInfo in this._events) {
      listener = this._events[eventInfo]; // Extract the event name and the selector

      match = eventInfo.match(delegateEventSplitter);
      eventName = match[1] + '.CoralComponent';
      selector = match[2];

      if (selector === '') {
        // instead of null because the key module checks for undefined
        selector = undefined;
      } // Try to get the method corresponding to the value in the map


      listener = getListenerFromMethodNameOrFunction(this, eventName, listener);

      if (listener) {
        // Always execute in the context of the object
        // @todo is this necessary? this should be correct anyway
        listener = listener.bind(this); // Check if the listener is on the window

        isGlobal = eventName.indexOf('global:') === 0;

        if (isGlobal) {
          eventName = eventName.substr(7);
        } // Check if the listener is a capture listener


        isCapture = eventName.indexOf('capture:') === 0;

        if (isCapture) {
          // @todo Limitation: It should be possible to do capture:global:, but it isn't
          eventName = eventName.substr(8);
        } // Check if the listener is a key listener


        isKey = eventName.indexOf('key:') === 0;

        if (isKey) {
          if (isCapture) {
            throw new Error('Coral.Keys does not currently support listening to key events with capture');
          }

          eventName = eventName.substr(4);
        } // Check if the listener is a resize listener


        isResize = eventName.indexOf('resize') === 0;

        if (isResize) {
          if (isCapture) {
            throw new Error('Coral.commons.addResizeListener does not currently support listening to resize event with capture');
          }
        }

        if (isGlobal) {
          // Store for adding/removal
          if (isKey) {
            this._globalKeys = this._globalKeys || [];

            this._globalKeys.push({
              keyCombo: eventName,
              selector: selector,
              listener: listener
            });
          } else {
            this._globalEvents = this._globalEvents || [];

            this._globalEvents.push({
              eventName: eventName,
              selector: selector,
              listener: listener,
              isCapture: isCapture
            });
          }
        } else {
          // Events on the element itself
          if (isKey) {
            // Create the keys instance only if its needed
            this._keys = this._keys || new Keys(this, {
              filter: this._filterKeys,
              // Execute key listeners in the context of the element
              context: this
            }); // Add listener locally

            this._keys.on(eventName, selector, listener);
          } else if (isResize) {
            if (selector) {
              elements = document.querySelectorAll(selector);

              for (var i = 0; i < elements.length; ++i) {
                commons.addResizeListener(elements[i], listener);
              }
            } else {
              commons.addResizeListener(this, listener);
            }
          } else {
            this._vent.on(eventName, selector, listener, isCapture);
          }
        }
      }
    }
  };
  /**
   Remove global event listeners for this component.

   @private

   @returns {Component} this, chainable.
   */


  Component.prototype._undelegateGlobalEvents = function () {
    var i;

    if (this._globalEvents) {
      // Remove global event listeners
      for (i = 0; i < this._globalEvents.length; i++) {
        var event = this._globalEvents[i];
        events.off(event.eventName, event.selector, event.listener, event.isCapture);
      }
    }

    if (this._globalKeys) {
      // Remove global key listeners
      for (i = 0; i < this._globalKeys.length; i++) {
        var key = this._globalKeys[i];
        keys$1.off(key.keyCombo, key.selector, key.listener);
      }
    }

    if (this._keys) {
      this._keys.destroy(true);
    }

    return this;
  };
  /**
   Add global event listeners for this component.

   @private

   @returns {Component} this, chainable.
   */


  Component.prototype._delegateGlobalEvents = function () {
    var i;

    if (this._globalEvents) {
      // Add global event listeners
      for (i = 0; i < this._globalEvents.length; i++) {
        var event = this._globalEvents[i];
        events.on(event.eventName, event.selector, event.listener, event.isCapture);
      }
    }

    if (this._globalKeys) {
      // Add global key listeners
      for (i = 0; i < this._globalKeys.length; i++) {
        var key = this._globalKeys[i];
        keys$1.on(key.keyCombo, key.selector, key.listener);
      }
    }

    if (this._keys) {
      this._keys.init(true);
    }

    return this;
  };
  /**
   Add an event listener.

   @param {String} eventName
   The event name to listen for.
   @param {String} [selector]
   The selector to use for event delegation.
   @param {Function} func
   The function that will be called when the event is triggered.
   @param {Boolean} [useCapture=false]
   Whether or not to listen during the capturing or bubbling phase.

   @returns {Component} this, chainable.
   */


  Component.prototype.on = function (eventName, selector, func, useCapture) {
    this._vent.on(eventName, selector, func, useCapture);

    return this;
  };
  /**
   Remove an event listener.

   @param {String} eventName
   The event name to stop listening for.
   @param {String} [selector]
   The selector that was used for event delegation.
   @param {Function} func
   The function that was passed to <code>on()</code>.
   @param {Boolean} [useCapture]
   Only remove listeners with <code>useCapture</code> set to the value passed in.

   @returns {Component} this, chainable.
   */


  Component.prototype.off = function (eventName, selector, func, useCapture) {
    this._vent.off(eventName, selector, func, useCapture);

    return this;
  };
  /**
   Trigger an event.

   @param {String} eventName
   The event name to trigger.
   @param {Object} [props]
   Additional properties to make available to handlers as <code>event.detail</code>.
   @param {Boolean} [bubbles=true]
   Set to <code>false</code> to prevent the event from bubbling.
   @param {Boolean} [cancelable=true]
   Set to <code>false</code> to prevent the event from being cancelable.

   @returns {CustomEvent} CustomEvent object
   */


  Component.prototype.trigger = function (eventName, props, bubbles, cancelable) {
    // When 'bubbles' is not set, then default to true:
    bubbles = bubbles || bubbles === undefined; // When 'cancelable' is not set, then default to true:

    cancelable = cancelable || cancelable === undefined; // CustomEvent is polyfilled for IE via Polymer:
    // https://github.com/Polymer/CustomElements/blob/master/src/boot.js#L84-L93

    var event = new CustomEvent(eventName, {
      bubbles: bubbles,
      cancelable: cancelable,
      detail: props
    }); // default value in case the dispatching fails

    var defaultPrevented = false;

    try {
      // leads to NS_ERROR_UNEXPECTED in Firefox
      // https://bugzilla.mozilla.org/show_bug.cgi?id=329509
      defaultPrevented = !this.dispatchEvent(event);
    } catch (e) {} // Check if the defaultPrevented status was correctly stored back to the event object


    if (defaultPrevented !== event.defaultPrevented) {
      // dispatchEvent() doesn't correctly set event.defaultPrevented in IE 9
      // However, it does return false if preventDefault() was called
      // Unfortunately, the returned event's defaultPrevented property is read-only
      // We need to work around this such that (patchedEvent instanceof Event) === true
      // First, we'll create an object that uses the event as its prototype
      // This gives us an object we can modify that is still technically an instanceof Event
      var patchedEvent = Object.create(event); // Next, we set the correct value for defaultPrevented on the new object
      // We cannot simply assign defaultPrevented, it causes a "Invalid Calling Object" error in IE 9
      // For some reason, defineProperty doesn't cause this

      Object.defineProperty(patchedEvent, 'defaultPrevented', {
        value: defaultPrevented
      });
      return patchedEvent;
    }

    return event;
  };
  /**
   Non-destructively remove this element. It can be re-added by simply appending it to the document again.
   It will be garbage collected if there are no more references to it.
   */


  Component.prototype.remove = function () {
    if (this.parentNode) {
      // Just remove the element from its parent. This will automatically invoke detachedCallback
      this.parentNode.removeChild(this);
    }
  };
  /**
   @ignore
   @private
   */


  Component.prototype._doSet = function (property, value, silent) {
    // Get property descriptor from constructor. Property descriptors are stored on constructor with methods
    // dereferenced to actual functions
    var descriptor = this._properties && this._properties[property];

    if (descriptor) {
      if (descriptor.contentZone && !(value instanceof HTMLElement) && this[property].set) {
        // If the property is a content zone and the passed value is not a HTML element,
        // assume we're setting multiple properties of the existing content zone with an object
        this[property].set(value);
      } // In case the Content Zone is not a Component, we still want to be able to set the new values into it
      else if (descriptor.contentZone && !(value instanceof HTMLElement) && _typeof(value) === 'object' && this[property] instanceof HTMLElement) {
          Object.keys(value).forEach(function (prop) {
            this[prop] = value[prop];
          }, this[property]);
        } else if (descriptor._methods && descriptor._methods.set) {
          // Call and pass true silent
          // Use the actual setter method instead of the original method so events are triggered etc
          descriptor._methods.set.call(this, value, !!silent);
        } else {
          this[property] = value;
        }
    } else {
      // Simply set the property if it doesn't exist or has no setter
      this[property] = value;
    }
  };
  /**
   Set a single property.

   @name Component#set
   @function

   @param {String} property
   The name of the property to set.
   @param {*} value
   The value to set the property to.
   @param {Boolean} silent
   If true, events should not be triggered as a result of this set.

   @returns {Component} this, chainable.
   */

  /**
   Set multiple properties.

   @name Component#set
   @function

   @param {Object.<String, *>} properties
   An object of property/value pairs to set.
   @param {Boolean} silent
   If true, events should not be triggered as a result of this set.

   @returns {Component} this, chainable.
   */


  Component.prototype.set = function (propertyOrProperties, valueOrSilent, silent) {
    var property;
    var properties;
    var value;

    if (typeof propertyOrProperties === 'string') {
      // Set a single property
      property = propertyOrProperties;
      value = valueOrSilent;

      this._doSet(property, value, silent);
    } else {
      properties = propertyOrProperties;
      silent = valueOrSilent; // Set a map of properties

      for (property in properties) {
        value = properties[property];

        this._doSet(property, value, silent);
      }
    }

    return this;
  };
  /**
   Get the value of a property.

   @param {String} property
   The name of the property to fetch the value of.

   @returns {*} Property value.
   */


  Component.prototype.get = function (property) {
    return this[property];
  };
  /**
   Show this component.

   @returns {Component} this, chainable
   */


  Component.prototype.show = function () {
    if (!this.hidden) {
      return this;
    }

    this.hidden = false;
    return this;
  };
  /**
   Hide this component.

   @returns {Component} this, chainable
   */


  Component.prototype.hide = function () {
    if (this.hidden) {
      return this;
    }

    this.hidden = true;
    return this;
  }; // Copy all methods for baseTagName-style inheritance


  Component.prototype._methods = {};

  for (var prop in Component.prototype) {
    if (Component.prototype.hasOwnProperty(prop)) {
      Component.prototype._methods[prop] = Component.prototype[prop];
    }
  }

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  /**
   A property descriptor.

   @typedef {Object} Coral~PropertyDescriptor
   @property {Function} [transform=null]
   The value transformation function. Values passed to setters will be ran through this function first.
   @property {Function} [attributeTransform=transform]
   The value transformation function for attribute. The value given by <code>attributeChangedCallback</code> will be
   ran through this function first before passed to setters.
   @property {Coral.validate~validationFunction} [validate={@link Coral.validate.valueMustChange}]
   The value validation function. A validation function that takes two arguments, <code>newValue</code> and
   <code>oldValue</code>, returning true if the setter should run or false if not.
   @property {String|Function} [trigger=null]
   The name of the event to trigger after this property changes, or a {Function} to call that will trigger the event.
   The function is passed the <code>newValue</code> and <code>oldValue</code>.
   @property {String|Function} [triggerBefore=null]
   The name of the event to trigger before this property changes, a {Function} to call that will trigger the event,
   or <code>true</code> to set the name automatically. The function is passed the <code>newValue</code> and
   <code>oldValue</code> and must return the Event object for <code>preventDefault()</code> to work within handlers. If
   set to <code>true</code>, {@link Coral~PropertyDescriptor} must be a string with a colon in it, such as
   <code>coral-component:change</code>, which results in <code>coral-component:beforechange</code>. If set to
   <code>false</code>, no event will be triggered before the setter is ran.
   @property {String} [attribute=propName]
   The name of the attribute corresponding to this property. If not provided, the property name itself will be used.
   If <code>null</code> is provided, the property will not be set by a corresponding attribute.
   @property {Boolean} [reflectAttribute=false]
   Whether this property should be reflected as an attribute when changed. This is useful when you want to style CSS
   according to the property's existence or value.
   @property {Function} [sync=null]
   The method to be called when this property's value should be synced to the DOM.
   @property {String|Array.<String>} [alsoSync=null]
   A property or list of properties that should be synced after this property is synced.
   @property {Function} [set={@link Coral~defaultSet}]
   The setter for this property.
   @property {Function} [get={@link Coral~defaultGet}]
   The getter for this property.
   @property {Boolean} [override=false]
   Whether this property descriptor should completely override. If <code>false</code>, this descriptor will augment
   the existing descriptor. See {@link Coral.register.augmentProperties} for details.
   @property {Boolean} [contentZone=false]
   Whether this property represents a content zone. Content zones are treated differently when set() is invoked such
   that the provided value is passed to the content zone's set() method.
   */
  // These properties won't be treated as methods

  var specialProperties = {
    extend: true,
    properties: true,
    events: true,
    _elements: true,
    name: true,
    namespace: true,
    tagName: true,
    baseTagName: true,
    className: true
  };

  function noop() {}

  function passThrough(value) {
    return value;
  }
  /**
   Creates an array with validation functions for the given properties. If no validate is specified, then the default
   validator is used.
   @ignore
   */


  function makeValidate(descriptor) {
    if (!descriptor.validate) {
      return [validate.valueMustChange];
    }

    if (Array.isArray(descriptor.validate)) {
      return descriptor.validate;
    }

    return [descriptor.validate];
  }
  /**
   Make a attribute reflect function for the given property. If the property is not reflected, return a noop.
   @ignore
   */


  function makeReflect(propName, descriptor) {
    if (!descriptor.reflectAttribute) {
      return noop;
    }

    var attrName = descriptor.attribute || propName;
    return function doReflect(value, silent) {
      // Reflect the property
      if (value === false || value === null) {
        // Non-truthy attributes should be destroyed
        this.removeAttribute(attrName);
      } else {
        // Boolean true for a value just means the property should exist
        if (value === true) {
          value = '';
        } // Only perform the set if the attribute is of a different value
        // This avoids triggering mutation observers unnecessarily


        if (this.getAttribute(attrName) !== value) {
          this.setAttribute(attrName, value);
        }
      }
    };
  }
  /**
   Make an event trigger function for the given property. If no event should be triggered, return a noop.
   @ignore
   */


  function makeTrigger(trigger) {
    if (!trigger) {
      return noop;
    }

    if (typeof trigger === 'function') {
      return trigger;
    }

    var eventName = trigger;
    return function doTrigger(newValue, oldValue) {
      // Trigger an event that has the new and old values under detail
      return this.trigger(eventName, {
        oldValue: oldValue,
        value: newValue
      });
    };
  }
  /**
   Make a queue sync function for the given property. If nothing needs to be synced, return a noop.
   @ignore
   */


  function makeQueueSync(propName, descriptor) {
    var propList = descriptor.alsoSync;
    var sync = descriptor.sync;

    if (!sync && !propList) {
      return noop;
    }

    if (propList) {
      // Other properties in addition to ours
      if (Array.isArray(propList)) {
        propList.unshift(propName);
      } else {
        propList = [propName, propList];
      }

      return function doMultiSync(value) {
        // Sync the list of properties
        this._queueSync.apply(this, propList);
      };
    }

    return function doSync(value) {
      // Sync the property
      this._queueSync(propName);
    };
  }
  /**
   Create and store the methods back to the property descriptor, then store the descriptor on the prototype.
   This enables overriding descriptor parts.

   @ignore
   */


  function storeDescriptor(proto, propName, descriptor) {
    // triggerBefore can be function, boolean, or string
    var triggerBeforeValue;

    if (typeof descriptor.triggerBefore === 'function' || typeof descriptor.triggerBefore === 'string') {
      // Directly use string or function, makeTrigger will do the rest
      triggerBeforeValue = descriptor.triggerBefore;
    } else if (descriptor.triggerBefore === true) {
      // Automatically set name based on descriptor.trigger
      if (typeof descriptor.trigger === 'string' && descriptor.trigger.indexOf(':') !== -1) {
        triggerBeforeValue = descriptor.trigger.replace(':', ':before');
      } else {
        throw new Error('Coral.register: Cannot automatically set "before" event name unless descriptor.trigger ' + 'is a string that conatins a colon');
      }
    } // Use provided setter, or make a setter that sets a "private" underscore-prefixed variable


    descriptor.set = descriptor.set || makeBasicSetter(propName); // Use provided getter, or make a getter that returns a "private" underscore-prefixed variable

    descriptor.get = descriptor.get || makeBasicGetter(propName); // Store methods

    var inheritedMethods = descriptor._methods;
    descriptor._methods = {}; // store references to inherited methods in descriptor._methods

    if (inheritedMethods) {
      for (var methodName in inheritedMethods) {
        descriptor._methods[methodName] = inheritedMethods[methodName];
      }
    }

    descriptor._methods.triggerBefore = makeTrigger(triggerBeforeValue);
    descriptor._methods.trigger = makeTrigger(descriptor.trigger);
    descriptor._methods.transform = descriptor.transform || passThrough;
    descriptor._methods.attributeTransform = descriptor.attributeTransform || passThrough;
    descriptor._methods.reflectAttribute = makeReflect(propName, descriptor);
    descriptor._methods.queueSync = makeQueueSync(propName, descriptor); // We need to store the list of validators back on the descriptor as we modify this inside of makeValidate

    descriptor._methods.validate = makeValidate(descriptor); // Store reverse mapping of attribute -> property

    if (descriptor.attribute) {
      proto._attributes[descriptor.attribute] = propName;
    } else {
      // Remove the mapping in case it was overridden
      proto._attributes[descriptor.attribute] = null;
    } // Store the descriptor


    proto._properties[propName] = descriptor;
  }
  /**
   Create a generic getter.

   @param {String} propName
   The property name whose getter should be invoked.

   @ignore
   */


  function makeGetter(propName) {
    return function getter() {
      // Invoke the original getter
      return this._properties[propName].get.call(this);
    };
  }
  /**
   Create a genertic setter.

   @param {String} propName
   The name of the property.

   @alias register.makeSetter

   @returns {Function} The setter function.
   */


  function makeSetter(propName) {
    return function setter(value, silent) {
      var descriptor = this._properties[propName];
      var methods = descriptor._methods; // Transform the value, passing the default
      // The default value cannot be cached in the outer closure as that would prevent monkey-patching

      var newValue = methods.transform.call(this, value, this._properties[propName].default); // Store the old value before the setter is invoked

      var oldValue = this[propName]; // Performs all the validations until one of them fails

      var self = this;
      var failed = methods.validate.some(function (validator) {
        return !validator.call(self, newValue, oldValue);
      }); // If a validation failed then we return

      if (failed) {
        return;
      }

      if (!silent) {
        var event = methods.triggerBefore.call(this, newValue, oldValue);

        if (event && event.defaultPrevented) {
          // Allow calls to preventDefault() to stop events
          return;
        }
      } // Invoke the original setter


      descriptor.set.call(this, newValue, silent); // Reflect the attribute

      methods.reflectAttribute.call(this, newValue); // Queue property sync. Do this before trigger, in case an event listener wants to unroll the sync queue

      methods.queueSync.call(this); // Trigger an event

      if (!silent) {
        methods.trigger.call(this, newValue, oldValue);
      } // Store that this prop has been set
      // This is used during initialization when deciding whether to apply default values


      this._setProps[propName] = true;
    };
  }

  function makeBasicGetter(propName) {
    var tempVarName = '_' + propName;
    /**
     Gets the corresponding underscore prefixed "private" property by the same name.
      @function Coral~defaultGet
     @returns The prefixed property
     */

    return function getter() {
      return this[tempVarName];
    };
  }

  function makeBasicSetter(propName) {
    var tempVarName = '_' + propName;
    /**
     Sets the corresponding underscore prefixed "private" property by the same name.
      @param {*} value  The value to set
     @function Coral~defaultSet
     */

    return function setter(value) {
      this[tempVarName] = value;
    };
  }
  /**
   Define a set of {@link Coral~PropertyDescriptors} on the passed object

   @param {Object} proto
   The object to define properties on, usually a prototype.
   @param {Object.<String, Coral~PropertyDescriptor>} properties
   A map of property names to their corresponding descriptors.

   @alias register.defineProperties
   */


  function defineProperties(proto, properties) {
    // Loop over properties and define them on the prototype
    for (var propName in properties) {
      if (!properties[propName]) {
        // Skip properties that were removed to avoid redefinition
        continue;
      }

      defineProperty$1(proto, propName, properties[propName]);
    }
  }
  /**
   Define a single {@link Coral~PropertyDescriptors} on the passed object

   @param {Object} proto
   The object to define properties on, usually a prototype.
   @param {String} propName
   The name of the property.
   @param {Coral~PropertyDescriptor} descriptor
   A property descriptor

   @alias register.defineProperty
   */


  function defineProperty$1(proto, propName, descriptor) {
    // Handle mixin case
    if (typeof descriptor === 'function') {
      // Let descriptor apply itself to the prototype
      // This allows it to add methods
      // Use its return value as the actual descriptor
      descriptor = descriptor(proto, propName); // If nothing is returned, we're done with this property

      if (!descriptor) {
        throw new Error('Coral.register.defineProperty: Property function did not return a descriptor for ' + propName);
      }
    } // Store the associated methods


    storeDescriptor(proto, propName, descriptor); // Create the generic setters and getters for this property
    // Store them back so we can access them for silent sets
    // These do not need to be overridden as they delegate to this._properties._methods

    var actualSetter = descriptor._methods.set = makeSetter(propName);
    var actualGetter = descriptor._methods.get = makeGetter(propName); // Define the property

    Object.defineProperty(proto, propName, {
      // All properties are enumerable
      enumerable: true,
      // No properties are configurable
      configurable: false,
      set: actualSetter,
      get: actualGetter
    });
  }

  var tagPrototypes = {};
  /**
   Memoized getProtoTypeOf for HTML tags
   @ignore
   */

  function getPrototypeOfTag(tagName) {
    tagPrototypes[tagName] = tagPrototypes[tagName] || Object.getPrototypeOf(document.createElement(tagName));
    return tagPrototypes[tagName];
  }
  /**
   Register a Coral component, setting up inheritance, mixins, properties, and the associated custom element.

   @memberof Coral
   @static

   @param {Object} options
   Component options.
   @param {Object} options.namespace
   Namespace where to store the constructor.
   @param {String} options.name
   Name of the constructor (i.e. 'Accordion.Item'). The constructor will be available under 'Coral' at the path
   specified by the name.
   @param {String} options.tagName
   Name of the new element (i.e 'coral-component').
   @param {String} [options.baseTagName = (none)]
   Name of the tag to extend (i.e. 'button'). This is only required when extending an existing HTML element such that
   the <code>&lt;button is="custom-element"&gt;</code> style will be used.
   @param {Object} [options.extend = Coral.Component]
   Base class of the component. When extending an existing HTML element, this should match the interface implemented
   by the tag -- that is, for <code>baseTagName: 'button'</code> you should pass
   <code>extend: HTMLButtonElement</code>.
   @param {Array.<Object|Coral~mixin>} [options.mixins]
   Mixin or {Array} of mixins to add. Mixins can be an {Object} or a {Coral~mixin}.
   @param {Object.<String, Coral~PropertyDescriptor>} [options.properties]
   A map of property names to their corresponding descriptors.
   @param {Object} [options.events]
   Map of the events and their handler.
   @param {Object} [options._elements]
   Map of elements and their locations used for caching.
   */


  var register = function register(options) {
    // Throw away options.extend if baseTagName provided and the prototype isn't part of Coral.Component
    if (options.extend && !options.extend.prototype._methods) {
      options.extend = Component;
    } // Extend Coral.Component if nothing is provided


    var extend = options.extend || Component; // We'll use the prototype of the argument passed constructor we're extending

    var baseComponentProto = extend.prototype;
    var actualPrototype = baseComponentProto; // Use passed or be an empty object so mixins can add properties to components that don't define any
    // Don't modify the passed properties object directly

    var properties = options.properties ? commons.extend({}, options.properties) : {};

    if (options.baseTagName) {
      // If we're extending a base tag, we need to use its prototype, not the Component's
      actualPrototype = getPrototypeOfTag(options.baseTagName);
    } // Setup the prototype chain


    var proto = Object.create(actualPrototype); // Store a reference to the next component's prototype in the chain
    // This allows us to crawl up the component prototype chain later

    proto._proto = baseComponentProto;

    if (options.baseTagName) {
      var protoChain = []; // Build the prototype chain

      var curBaseProto = baseComponentProto;

      while (curBaseProto && curBaseProto._methods) {
        protoChain.unshift(curBaseProto);
        curBaseProto = curBaseProto._proto;
      } // Iterate over the prototype chain and mix all the methods in


      while (curBaseProto = protoChain.shift()) {
        for (var methodName in curBaseProto._methods) {
          proto[methodName] = curBaseProto[methodName];
        }
      } // Note that we'll already get a flattened list of properties from _properties
      // So we don't have to do something similar there

    } // Create attribute -> property mappings and the property descriptor map
    // Do this before we mixin/override properties as storeDescriptor() will write back to _attributes and _properties


    proto._attributes = commons.extend({}, baseComponentProto._attributes);
    proto._properties = {}; // Define and inherit events from parent class

    proto._events = commons.extend({}, baseComponentProto._events, options.events); // Define and inherit sub-elements from parent class

    proto._elements = commons.extend({}, baseComponentProto._elements, options._elements); // Store the name and namespace on the prototype
    // the toString method of Coral.Component uses this

    proto._componentName = options.name;
    proto._namespace = options.namespace || window.Coral; // CSS className

    proto._className = options.className; // Add methods to the prototype, and store them in an object for easy access
    // We'll use this object when extending base tagnames later

    var _methods = proto._methods = {};

    for (var method in options) {
      if (!specialProperties[method]) {
        proto[method] = _methods[method] = options[method];
      }
    } // Add mixins to the prototype
    // Do this before combining properties to allow seemless modification of properties overridden by mixins


    if (options.mixins) {
      commons.mixin(proto, // A single Object, Function, or Array thereof
      options.mixins, {
        // Pass properties so functional mixins can augment them
        properties: properties
      });
    } // Store and override property descriptors


    commons.augment(proto._properties, baseComponentProto._properties, properties, function (existingDesc, newDesc, propName) {
      // Drop properties that are not defined
      if (!newDesc) {
        return null;
      } // The child component (newDesc) determines whether to ignore the base component's descriptor


      if (newDesc.override === true) {
        // The new component wants to ignore the base component's descriptor
        return newDesc;
      } // Combine and override as necessary
      // The order of arguments seems backwards because we use this method in Coral.register.augmentProperties
      // This makes it so the existing setter is called first
      // It also makes it so the new descriptor will override other properties


      var combinedDesc = commons.augment( // Don't modify the existing descriptor
      {}, newDesc, existingDesc, handleAugmentPropertyCollision); // Store the new methods and descriptor

      storeDescriptor(proto, propName, combinedDesc); // The property is already defined, so tell defineProperties not to define it again

      properties[propName] = undefined; // storeDescriptor() already stored the descriptor, but we have to return it anyway

      return combinedDesc;
    }); // Removed properties that have been removed by inheriting components

    for (var propName in proto._properties) {
      if (!proto._properties[propName]) {
        delete proto._properties[propName];
      }
    } // Define properties last
    // This allows mixins to merge and modify properties


    if (options.baseTagName) {
      // Define ALL properties as we don't pick up any from the prototype
      defineProperties(proto, proto._properties);
    } else {
      // Define just the new properties
      defineProperties(proto, properties);
    } // The options to be passed to registerElement


    var registrationOptions = {
      prototype: proto
    };

    if (options.baseTagName) {
      // When a base tag is provided, we need to tell registerElement
      registrationOptions.extends = options.baseTagName;
    } // Register the element
    // This returns a constructor


    var Constructor = document.registerElement(options.tagName, registrationOptions); // Assign the constructor at the correct location

    commons.setSubProperty(options.namespace || window.Coral || window, options.name, Constructor);
    return Constructor;
  }; // Expose globally


  register.defineProperties = defineProperties;
  register.defineProperty = defineProperty$1;
  /**
   Augment a set of property descriptors with another set.
   The <code>dest</code> property descriptors map is modified in place.
   The individual property descriptors (values of <code>dest</code>) are not modified.

   @param {Object<String,Coral~PropertyDescriptor>} dest
   The set of property descriptors to agument.
   @param {Object<String,Coral~PropertyDescriptor>} source
   The set of property descriptors to use.
   @param {Coral.commons~handleCollision} [handleCollision]
   Called if the descriptor property being copied is already present on the destination.
   The return value will be used as the property value.
   By default, if <code>sync</code> or <code>set</code> collides, both provided methods will be called.
   By default, if any other descriptor property collides, the destination's value will be used.
   */

  register.augmentProperties = function (dest, source, handleCollision) {
    commons.augment(dest, source, function (existingDesc, newDesc, propName) {
      // The mixin target (dest) determines whether to ignore the mixin's properties
      if (existingDesc.override === true) {
        // The mixin target (dest) wants to ignore the mixin's descriptor
        return existingDesc;
      } // Deep-augment individual property descriptor properties


      var combinedDesc = commons.augment( // Don't modify the existing descriptor
      {}, existingDesc, newDesc, handleCollision || handleAugmentPropertyCollision);
      return combinedDesc;
    });
  };
  /**
   Default collision handler when augmenting properties
   @ignore
   */


  function handleAugmentPropertyCollision(destValue, sourceValue, descPropName) {
    switch (descPropName) {
      case 'sync':
      case 'set':
        // Use both methods
        return callBoth(sourceValue, destValue);

      default:
        // Use component's value
        return destValue;
    }
  }
  /**
   Return a function that calls both functions and ignores their return values
   @ignore
   */


  function callBoth(first, second) {
    return function () {
      first.apply(this, arguments);
      second.apply(this, arguments);
    };
  }

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  /**
   Property descriptor factory factories
   @namespace
   */

  var property = {};
  /**
   A factory that creates descriptor factories that proxy a local property/attribute to a sub-property.
   This factory should be used when you need the property of an sub-object to be set or queued for sync when a local
   property changes.
   This is especially useful for setting the innerHTML or other properties of sub-elements.

   @param {Coral~PropertyDescriptor} descriptor
   The property descriptor
   @param {String} path
   The path under <code>this</code> to proxy to. For instance, <code>_elements.header.innerHTML</code> would proxy
   to the <code>innerHTML</code> of the element with the handle <code>header</code>
   @param {Boolean} [needsDOMSync=false]
   Whether the property set should happen asynchronously on the next animation frame.

   @returns {Function} The descriptor factory.
   */

  property.proxy = function (descriptor) {
    // Store the path
    var path = descriptor.path;

    function setProxy(value, silent) {
      /* jshint validthis: true */
      commons.setSubProperty(this, path, value);
    }

    function getProxy() {
      /* jshint validthis: true */
      return commons.getSubProperty(this, path);
    }

    var functionalDescriptor = function functionalDescriptor(proto, propName) {
      var tempPropName = '_' + propName;

      if (descriptor.needsDOMSync) {
        // If a sync needs to happen, define a method
        descriptor.sync = function () {
          commons.setSubProperty(this, path, this[tempPropName]); // Use undefined here, not null

          this[tempPropName] = undefined;
        };

        descriptor.set = function (value, silent) {
          this[tempPropName] = value;
        };

        descriptor.get = function () {
          // Return the temporary variable if it's set, otherwise get the property we're proxying
          return typeof this[tempPropName] === 'undefined' ? commons.getSubProperty(this, path) : this[tempPropName];
        };
      } else {
        // If we don't need to sync, simply delegate to the property
        // @todo test if it's faster to compose a function with new Function()
        descriptor.set = setProxy;
        descriptor.get = getProxy;
        descriptor.sync = null;
      }

      return descriptor;
    }; // Override by default
    // Store this on the function so Coral.register can check it


    functionalDescriptor.override = typeof descriptor.override !== 'undefined' ? descriptor.override : true; // Return a function that sets up the property

    return functionalDescriptor;
  };
  /**
   A factory that creates descriptor factories that proxy a local property/attribute to a sub-element's attribute.

   This is useful when you want to proxy a property/attrubute to a sub-element as an attribute set/removal.
   For instance, you may want to proxy the <code>aria-labelledby</code> property of a field component to the actual
   input inside of the component for accessibility purposes.

   When using this property factory, be sure to specify a property name not implemented by the browser already.

   @param {Coral~PropertyDescriptor} descriptor
   The property descriptor.
   @param {String} descriptor.attribute
   The attribute to proxy.
   @param {String} descriptor.handle
   The handle of the element to proxy the attribute to.
   */


  property.proxyAttr = function (descriptor) {
    var attribute = descriptor.attribute;
    var handle = descriptor.handle;

    var functionalDescriptor = function functionalDescriptor(proto, propName) {
      return commons.extend({
        attribute: attribute,
        set: function set(value) {
          // Both false and null should remove the attribute
          // This supports the behavior of Coral.transform.boolean as well as non-transformed attributes
          // Any other value, including empty string, should set it
          this._elements[handle][value === false || value === null ? 'removeAttribute' : 'setAttribute'](attribute, value);
        },
        get: function get() {
          return this._elements[handle].getAttribute(attribute);
        }
      }, descriptor);
    }; // Override by default
    // Store this on the function so Coral.register can check it


    functionalDescriptor.override = typeof descriptor.override !== 'undefined' ? descriptor.override : true;
    return functionalDescriptor;
  };
  /**
   A factory that creates descriptor factories for content zones.

   @param {Coral~PropertyDescriptor} descriptor
   The property descriptor.
   @param {String} descriptor.handle
   The handle of the element to proxy the attribute to.
   @param {String} [descriptor.tagName]
   The tag name to expect. If not provided, any tag will be accepted.
   @param {Function} [descriptor.set]
   Executed after the property is set.
   @param {Function} [descriptor.get]
   An alternate getter. If not provided, the element specified by the handle will be returned.
   @param {Function} [descriptor.insert]
   The method that inserts the content zone into the element.
   @param {Boolean} defaultContentZone
   Set to true if this is the default content zone that {@link Coral.Component#render} moves orphaned elements into.
   */


  property.contentZone = function (descriptor) {
    var handle = descriptor.handle;
    var expectedTagName = descriptor.tagName;
    var additionalSetter = descriptor.set;
    var alternateGetter = descriptor.get;
    var insert = descriptor.insert;

    var functionalDescriptor = function functionalDescriptor(proto, propName) {
      if (descriptor.defaultContentZone) {
        // Alias the setter/getter to the content zone's property
        Object.defineProperty(proto, 'defaultContentZone', {
          set: function set(value) {
            this[propName] = value;
          },
          get: function get() {
            return this[propName];
          }
        });
      } // Combine the provided descriptor with the factory's properties
      // Give precidence to the factory's properties


      return commons.extend({}, descriptor, {
        contentZone: true,
        set: function set(value) {
          var oldNode;

          if (!!value) {
            if (!(value instanceof HTMLElement)) {
              throw new Error('DOMException: Failed to set the "' + propName + '" property on "' + this.toString() + '": The provided value is not of type "HTMLElement".');
            }

            if (expectedTagName && value.tagName.toLowerCase() !== expectedTagName) {
              throw new Error('DOMException: Failed to set the "' + propName + '" property on "' + this.toString() + '": The new ' + propName + ' element is of type "' + value.tagName + '". It must be a "' + expectedTagName.toUpperCase() + '" element.');
            }

            oldNode = this._elements[handle]; // Replace the existing element

            if (insert) {
              // Remove old node
              if (oldNode && oldNode.parentNode) {
                oldNode.parentNode.removeChild(oldNode);
              } // Insert new node


              insert.call(this, value);
            } else {
              if (oldNode && oldNode.parentNode) {
                commons._log('warn', this._componentName + ' does not define an insert method for content zone ' + handle + ', falling back to replace.'); // Old way -- assume we have an old node


                this._elements[handle].parentNode.replaceChild(value, this._elements[handle]);
              } else {
                commons._log('error', this._componentName + ' does not define an insert method for content zone ' + handle + ', falling back to append.'); // Just append, which may introduce bugs, but at least doesn't crazy


                this.appendChild(value);
              }
            }
          } else {
            // we need to remove the content zone if it exists
            oldNode = this._elements[handle];

            if (oldNode && oldNode.parentNode) {
              oldNode.parentNode.removeChild(oldNode);
            }
          } // Re-assign the handle to the new element


          this._elements[handle] = value; // Invoke the setter

          if (typeof additionalSetter === 'function') {
            additionalSetter.call(this, value);
          }
        },
        get: alternateGetter || function () {
          return this._elements[handle];
        }
      });
    };

    return functionalDescriptor;
  };

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  window.Vent = window.Vent || vent;

  var delegateEventSplitter$1 = /^(\S+)\s*(.*)$/;
  /**
   Enumeration representing the tracking options.

   @typedef {Object} TrackingEnum

   @property {String} ON
   Enables tracking of the component interactions.
   @property {String} OFF
   Disables tracking of the component interactions.
   */

  var tracking$1 = {
    ON: 'on',
    OFF: 'off'
  };
  /**
   Return the method corresponding to the method name or the function, if passed.
   @ignore
   */

  var getListenerFromMethodNameOrFunction$1 = function getListenerFromMethodNameOrFunction(obj, eventName, methodNameOrFunction) {
    // Try to get the method
    if (typeof methodNameOrFunction === 'function') {
      return methodNameOrFunction;
    } else if (typeof methodNameOrFunction === 'string') {
      if (!obj[methodNameOrFunction]) {
        throw new Error("Coral.Component: Unable to add ".concat(eventName, " listener for ").concat(obj.toString(), ", method\n      ").concat(methodNameOrFunction, " not found"));
      }

      var listener = obj[methodNameOrFunction];

      if (typeof listener !== 'function') {
        throw new Error("Coral.Component: Unable to add ".concat(eventName, " listener for ").concat(obj.toString(), ", listener is a\n      ").concat(_typeof(listener), " but should be a function"));
      }

      return listener;
    } else if (methodNameOrFunction) {
      // If we're passed something that's truthy (like an object), but it's not a valid method name or a function, get
      // angry
      throw new Error("Coral.Component: Unable to add ".concat(eventName, " listener for ").concat(obj.toString(), ", ").concat(methodNameOrFunction, "\n    is neither a method name or a function"));
    }

    return null;
  };
  /**
   Add local event and key combo listeners for this component, store global event/key combo listeners for later.
   @ignore
   */


  var delegateEvents = function delegateEvents() {
    /*
     Add listeners to new event
     - Include in hash
     Add listeners to existing event
     - Override method and use super
     Remove existing event
     - Pass null
     */
    var match;
    var eventName;
    var eventInfo;
    var listener;
    var selector;
    var elements;
    var isGlobal;
    var isKey;
    var isResize;
    var isCapture;

    for (eventInfo in this._events) {
      listener = this._events[eventInfo]; // Extract the event name and the selector

      match = eventInfo.match(delegateEventSplitter$1);
      eventName = "".concat(match[1], ".CoralComponent");
      selector = match[2];

      if (selector === '') {
        // instead of null because the key module checks for undefined
        selector = undefined;
      } // Try to get the method corresponding to the value in the map


      listener = getListenerFromMethodNameOrFunction$1(this, eventName, listener);

      if (listener) {
        // Always execute in the context of the object
        // @todo is this necessary? this should be correct anyway
        listener = listener.bind(this); // Check if the listener is on the window

        isGlobal = eventName.indexOf('global:') === 0;

        if (isGlobal) {
          eventName = eventName.substr(7);
        } // Check if the listener is a capture listener


        isCapture = eventName.indexOf('capture:') === 0;

        if (isCapture) {
          // @todo Limitation: It should be possible to do capture:global:, but it isn't
          eventName = eventName.substr(8);
        } // Check if the listener is a key listener


        isKey = eventName.indexOf('key:') === 0;

        if (isKey) {
          if (isCapture) {
            throw new Error('Coral.Keys does not currently support listening to key events with capture');
          }

          eventName = eventName.substr(4);
        } // Check if the listener is a resize listener


        isResize = eventName.indexOf('resize') === 0;

        if (isResize) {
          if (isCapture) {
            throw new Error('Coral.commons.addResizeListener does not currently support listening to resize event with capture');
          }
        }

        if (isGlobal) {
          // Store for adding/removal
          if (isKey) {
            this._globalKeys = this._globalKeys || [];

            this._globalKeys.push({
              keyCombo: eventName,
              selector: selector,
              listener: listener
            });
          } else {
            this._globalEvents = this._globalEvents || [];

            this._globalEvents.push({
              eventName: eventName,
              selector: selector,
              listener: listener,
              isCapture: isCapture
            });
          }
        } // Events on the element itself
        else if (isKey) {
            // Create the keys instance only if its needed
            this._keys = this._keys || new Keys(this, {
              // The filter function for keyboard events.
              filter: this._filterKeys,
              // Execute key listeners in the context of the element
              context: this
            }); // Add listener locally

            this._keys.on(eventName, selector, listener);
          } else if (isResize) {
            if (selector) {
              elements = document.querySelectorAll(selector);

              for (var i = 0; i < elements.length; ++i) {
                commons.addResizeListener(elements[i], listener);
              }
            } else {
              commons.addResizeListener(this, listener);
            }
          } else {
            this._vent.on(eventName, selector, listener, isCapture);
          }
      }
    }
  };
  /**
   Attach global event listeners for this component.
   @ignore
   */


  var delegateGlobalEvents = function delegateGlobalEvents() {
    var i;

    if (this._globalEvents) {
      // Remove global event listeners
      for (i = 0; i < this._globalEvents.length; i++) {
        var event = this._globalEvents[i];
        events.on(event.eventName, event.selector, event.listener, event.isCapture);
      }
    }

    if (this._globalKeys) {
      // Remove global key listeners
      for (i = 0; i < this._globalKeys.length; i++) {
        var key = this._globalKeys[i];
        keys$1.on(key.keyCombo, key.selector, key.listener);
      }
    }

    if (this._keys) {
      this._keys.init(true);
    }
  };
  /**
   Remove global event listeners for this component.
   @ignore
   */


  var undelegateGlobalEvents = function undelegateGlobalEvents() {
    var i;

    if (this._globalEvents) {
      // Remove global event listeners
      for (i = 0; i < this._globalEvents.length; i++) {
        var event = this._globalEvents[i];
        events.off(event.eventName, event.selector, event.listener, event.isCapture);
      }
    }

    if (this._globalKeys) {
      // Remove global key listeners
      for (i = 0; i < this._globalKeys.length; i++) {
        var key = this._globalKeys[i];
        keys$1.off(key.keyCombo, key.selector, key.listener);
      }
    }

    if (this._keys) {
      this._keys.destroy(true);
    }
  }; // Used to find upper case characters


  var REG_EXP_UPPERCASE = /[A-Z]/g;
  /**
   Returns the constructor namespace
   @ignore
   */

  var getConstructorName = function getConstructorName(constructor) {
    // Will contain the namespace of the constructor in reversed order
    var constructorName = []; // Keep a reference on the passed constructor

    var originalConstructor = constructor; // Traverses Coral constructors if not already done to set the namespace

    if (!constructor._namespace) {
      // Set namespace on Coral constructors until 'constructor' is found
      var find = function find(obj, constructorToFind) {
        var found = false;

        var type = _typeof(obj);

        if (obj && type === 'object' || type === 'function') {
          var subObj = Object.keys(obj);

          for (var i = 0; i < subObj.length; i++) {
            var key = subObj[i]; // Components are capitalized

            if (key[0].match(REG_EXP_UPPERCASE) !== null) {
              // Keep a reference of the constructor name and its parent
              obj[key]._namespace = {
                parent: obj,
                value: key
              };
              found = obj[key] === constructorToFind;

              if (found) {
                break;
              } else {
                found = find(obj[key], constructorToFind);
              }
            }
          }
        }

        return found;
      }; // Look for the constructor in the Coral namespace


      find(window.Coral, constructor);
    } // Climb up the constructor namespace


    while (constructor) {
      if (constructor._namespace) {
        constructorName.push(constructor._namespace.value);
        constructor = constructor._namespace.parent;
      } else {
        constructor = false;
      }
    } // Build the full namespace string and save it for reuse


    originalConstructor._componentName = constructorName.reverse().join('.');
    return originalConstructor._componentName;
  };
  /**
   * recursively update the _ignoreConnectedCallback value
   * for children coral-component, if parent has ignored the callback
   * its child should also ignore the callback hooks
   * @private
   */


  var _recursiveIgnoreConnectedCallback = function _recursiveIgnoreConnectedCallback(el, value) {
    var children = Array.from(el.children);

    for (var i = 0; i < children.length; i++) {
      var child = children[i]; // todo better check for coral-component

      if (typeof child._ignoreConnectedCallback === 'boolean') {
        child._ignoreConnectedCallback = value;
      } else {
        _recursiveIgnoreConnectedCallback(child, value);
      }
    }
  };
  /**
   @base BaseComponent
   @classdesc The base element for all Coral components
   */


  var BaseComponent = function BaseComponent(superClass) {
    return /*#__PURE__*/function (_superClass) {
      _inherits(_class, _superClass);

      var _super = _createSuper(_class);

      /** @ignore */
      function _class() {
        var _this;

        _classCallCheck(this, _class);

        _this = _super.call(this); // Attach Vent

        _this._vent = new vent(_assertThisInitialized(_this));
        _this._events = {}; // Content zone MO for virtual DOM support

        if (_this._contentZones) {
          _this._contentZoneObserver = new MutationObserver(function (mutations) {
            mutations.forEach(function (mutation) {
              for (var i = 0; i < mutation.addedNodes.length; i++) {
                var addedNode = mutation.addedNodes[i];

                for (var name in _this._contentZones) {
                  var contentZone = _this._contentZones[name];

                  if (addedNode.nodeName.toLowerCase() === name && !addedNode._contentZoned) {
                    // Insert the content zone at the right position

                    /** @ignore */
                    _this[contentZone] = addedNode;
                  }
                }
              }
            });
          });

          _this._contentZoneObserver.observe(_assertThisInitialized(_this), {
            childList: true,
            subtree: true
          });
        }

        return _this;
      }
      /**
       Tracking of events. This provides insight on the usage of the components. It accepts "ON" and "OFF". In order to
       successfully track the events, {Tracking} needs to be configured.
        @type {String}
       @default TrackingEnum.ON
       @htmlattribute tracking
       */


      _createClass(_class, [{
        key: "_filterKeys",
        // The filter function for keyboard events. By default, any child element can trigger keyboard events.
        // You can pass {@link Keys.filterInputs} to avoid listening to key events triggered from within
        // inputs.
        value: function _filterKeys() {
          return true;
        } // Attach event listeners including global ones

      }, {
        key: "_delegateEvents",
        value: function _delegateEvents(eventMap) {
          this._events = commons.extend(this._events, eventMap);
          delegateEvents.call(this); // Once events are attached, we dispose them

          this._events = {};
        } // Returns the content zone if the component is connected and contains the content zone else null
        // Ideally content zones will be replaced by shadow dom and <slot> elements

      }, {
        key: "_getContentZone",
        value: function _getContentZone(contentZone) {
          if (document.documentElement.contains(this)) {
            return this.contains(contentZone) && contentZone || null;
          } // Return the content zone by default


          return contentZone;
        } // Sets the value as content zone for the property given the specified options
        // Ideally content zones will be replaced by shadow dom and <slot> elements

      }, {
        key: "_setContentZone",
        value: function _setContentZone(property, value, options) {
          var handle = options.handle;
          var expectedTagName = options.tagName;
          var additionalSetter = options.set;
          var insert = options.insert;
          var oldNode;

          if (value) {
            if (!(value instanceof HTMLElement)) {
              throw new Error("DOMException: Failed to set the \"".concat(property, "\" property on \"").concat(this.toString(), "\":\n        The provided value is not of type \"HTMLElement\"."));
            }

            if (expectedTagName && value.tagName.toLowerCase() !== expectedTagName) {
              throw new Error("DOMException: Failed to set the \"".concat(property, "\" property on \"").concat(this.toString(), "\": The new\n        ").concat(property, " element is of type \"").concat(value.tagName, "\". It must be a \"").concat(expectedTagName.toUpperCase(), "\" element."));
            }

            oldNode = this._elements[handle]; // Flag it for the content zone MO

            value._contentZoned = true; // Replace the existing element

            if (insert) {
              // Remove old node
              if (oldNode && oldNode.parentNode) {
                oldNode.parentNode.removeChild(oldNode);
              } // Insert new node


              insert.call(this, value);
            } else if (oldNode && oldNode.parentNode) {
              commons._log('warn', "".concat(this._componentName, " does not define an insert method for content zone ").concat(handle, ", falling back to replace.")); // Old way -- assume we have an old node


              this._elements[handle].parentNode.replaceChild(value, this._elements[handle]);
            } else {
              commons._log('error', "".concat(this._componentName, " does not define an insert method for content zone ").concat(handle, ", falling back to append.")); // Just append, which may introduce bugs, but at least doesn't crazy


              this.appendChild(value);
            }
          } else {
            // we need to remove the content zone if it exists
            oldNode = this._elements[handle];

            if (oldNode && oldNode.parentNode) {
              oldNode.parentNode.removeChild(oldNode);
            }
          } // Re-assign the handle to the new element


          this._elements[handle] = value; // Invoke the setter

          if (typeof additionalSetter === 'function') {
            additionalSetter.call(this, value);
          }
        } // Handles the reflection of properties by using a flag to prevent setting the property by changing the attribute

      }, {
        key: "_reflectAttribute",
        value: function _reflectAttribute(attributeName, value) {
          if (typeof value === 'boolean') {
            if (value && !this.hasAttribute(attributeName)) {
              this._reflectedAttribute = true;
              this.setAttribute(attributeName, '');
              this._reflectedAttribute = false;
            } else if (!value && this.hasAttribute(attributeName)) {
              this._reflectedAttribute = true;
              this.removeAttribute(attributeName);
              this._reflectedAttribute = false;
            }
          } else if (this.getAttribute(attributeName) !== String(value)) {
            this._reflectedAttribute = true;
            this.setAttribute(attributeName, value);
            this._reflectedAttribute = false;
          }
        }
        /**
         Notifies external listeners about an internal interaction. This method is used internally in every
         component's method that we want to track.
          @param {String} eventType The event type. Eg. click, select, etc.
         @param {String} targetType The element type being used. Eg. cyclebutton, cyclebuttonitem, etc.
         @param {CustomEvent} event
         @param {BaseComponent} childComponent - Optional, in case the event occurred on a child component.
          @returns {BaseComponent}
         */

      }, {
        key: "_trackEvent",
        value: function _trackEvent(eventType, targetType, event, childComponent) {
          if (this.tracking === this.constructor.tracking.ON) {
            tracking.track(eventType, targetType, event, this, childComponent);
          }

          return this;
        }
        /**
         Returns the component name.
          @return {String}
         */

      }, {
        key: "toString",
        value: function toString() {
          return "Coral.".concat(this._componentName);
        }
        /**
         Add an event listener.
          @param {String} eventName
         The event name to listen for.
         @param {String} [selector]
         The selector to use for event delegation.
         @param {Function} func
         The function that will be called when the event is triggered.
         @param {Boolean} [useCapture=false]
         Whether or not to listen during the capturing or bubbling phase.
         @returns {BaseComponent} this, chainable.
         */

      }, {
        key: "on",
        value: function on(eventName, selector, func, useCapture) {
          this._vent.on(eventName, selector, func, useCapture);

          return this;
        }
        /**
         Remove an event listener.
          @param {String} eventName
         The event name to stop listening for.
         @param {String} [selector]
         The selector that was used for event delegation.
         @param {Function} func
         The function that was passed to <code>on()</code>.
         @param {Boolean} [useCapture]
         Only remove listeners with <code>useCapture</code> set to the value passed in.
         @returns {BaseComponent} this, chainable.
         */

      }, {
        key: "off",
        value: function off(eventName, selector, func, useCapture) {
          this._vent.off(eventName, selector, func, useCapture);

          return this;
        }
        /**
         Trigger an event.
          @param {String} eventName
         The event name to trigger.
         @param {Object} [props]
         Additional properties to make available to handlers as <code>event.detail</code>.
         @param {Boolean} [bubbles=true]
         Set to <code>false</code> to prevent the event from bubbling.
         @param {Boolean} [cancelable=true]
         Set to <code>false</code> to prevent the event from being cancelable.
         @returns {CustomEvent} CustomEvent object
         */

      }, {
        key: "trigger",
        value: function trigger(eventName, props, bubbles, cancelable) {
          // When 'bubbles' is not set, then default to true:
          bubbles = bubbles || bubbles === undefined; // When 'cancelable' is not set, then default to true:

          cancelable = cancelable || cancelable === undefined;
          var event = new CustomEvent(eventName, {
            bubbles: bubbles,
            cancelable: cancelable,
            detail: props
          }); // Don't trigger the event if silenced

          if (this._silenced) {
            return event;
          } // default value in case the dispatching fails


          var defaultPrevented = false;

          try {
            // leads to NS_ERROR_UNEXPECTED in Firefox
            // https://bugzilla.mozilla.org/show_bug.cgi?id=329509
            defaultPrevented = !this.dispatchEvent(event);
          } // eslint-disable-next-line no-empty
          catch (e) {} // Check if the defaultPrevented status was correctly stored back to the event object


          if (defaultPrevented !== event.defaultPrevented) {
            // dispatchEvent() doesn't correctly set event.defaultPrevented in IE 9
            // However, it does return false if preventDefault() was called
            // Unfortunately, the returned event's defaultPrevented property is read-only
            // We need to work around this such that (patchedEvent instanceof Event) === true
            // First, we'll create an object that uses the event as its prototype
            // This gives us an object we can modify that is still technically an instanceof Event
            var patchedEvent = Object.create(event); // Next, we set the correct value for defaultPrevented on the new object
            // We cannot simply assign defaultPrevented, it causes a "Invalid Calling Object" error in IE 9
            // For some reason, defineProperty doesn't cause this

            Object.defineProperty(patchedEvent, 'defaultPrevented', {
              value: defaultPrevented
            });
            return patchedEvent;
          }

          return event;
        }
        /**
         Set multiple properties.
          @param {Object.<String, *>} properties
         An object of property/value pairs to set.
         @param {Boolean} silent
         If true, events should not be triggered as a result of this set.
          @returns {BaseComponent} this, chainable.
         */

      }, {
        key: "set",
        value: function set(propertyOrProperties, valueOrSilent, silent) {
          var _this2 = this;

          var property;
          var properties;
          var value;

          var isContentZone = function isContentZone(prop) {
            return _this2._contentZones && commons.swapKeysAndValues(_this2._contentZones)[prop];
          };

          var updateContentZone = function updateContentZone(prop, val) {
            // If content zone exists and we only want to update properties on the content zone
            if (_this2[prop] instanceof HTMLElement && !(val instanceof HTMLElement)) {
              for (var contentZoneProperty in val) {
                /** @ignore */
                _this2[prop][contentZoneProperty] = val[contentZoneProperty];
              }
            } // Else assign the new value to the content zone
            else {
                /** @ignore */
                _this2[prop] = val;
              }
          };

          var setProperty = function setProperty(prop, val) {
            if (isContentZone(prop)) {
              updateContentZone(prop, val);
            } else {
              _this2._silenced = silent;
              /** @ignore */

              _this2[prop] = val;
              _this2._silenced = false;
            }
          };

          if (typeof propertyOrProperties === 'string') {
            // Set a single property
            property = propertyOrProperties;
            value = valueOrSilent;
            setProperty(property, value);
          } else {
            properties = propertyOrProperties;
            silent = valueOrSilent; // Set a map of properties

            for (property in properties) {
              value = properties[property];
              setProperty(property, value);
            }
          }

          return this;
        }
        /**
         Get the value of a property.
          @param {String} property
         The name of the property to fetch the value of.
         @returns {*} Property value.
         */

      }, {
        key: "get",
        value: function get(property) {
          return this[property];
        }
        /**
         Show this component.
          @returns {BaseComponent} this, chainable
         */

      }, {
        key: "show",
        value: function show() {
          if (!this.hidden) {
            return this;
          }
          /** @ignore */


          this.hidden = false;
          return this;
        }
        /**
         Hide this component.
         @returns {BaseComponent} this, chainable
         */

      }, {
        key: "hide",
        value: function hide() {
          if (this.hidden) {
            return this;
          }
          /** @ignore */


          this.hidden = true;
          return this;
        }
        /**
          This should be executed when messenger is connect event is connected.
          It will add the parent as a listener in child messenger.
          @ignore
         */

      }, {
        key: "_onMessengerConnected",
        value: function _onMessengerConnected(event) {
          event.stopImmediatePropagation();
          var handler = event.detail.handler;

          if (typeof handler === 'function') {
            handler(this);
          } else {
            throw new Error("Messenger handler should be a function");
          }
        }
        /**
         specify whether the connected and disconnected hooks are ignore for component
         @returns true when ignored
         @private
         */

      }, {
        key: "attributeChangedCallback",

        /** @ignore */
        // eslint-disable-next-line no-unused-vars
        value: function attributeChangedCallback(name, oldValue, value) {
          var self = this;

          if (!self._reflectedAttribute) {
            // Use the attribute/property mapping
            self[self.constructor._attributePropertyMap[name] || name] = value;
          }
        }
        /**
         called when we need to suspend state and properties, when
         disconnected callback are skipped.
         @private
         */

      }, {
        key: "_suspendCallback",
        value: function _suspendCallback() {} // do nothing

        /**
         called when we need to re-initialise state and properties, when
         connected callback are skipped.
         @private
         */

      }, {
        key: "_resumeCallback",
        value: function _resumeCallback() {} // do nothing

        /** @ignore */

      }, {
        key: "connectedCallback",
        value: function connectedCallback() {
          // A component that is reattached should respond to global events again
          // Attach global listener when component is connected to DOM
          // this would avoid memory leak when element is created but never connected.
          delegateGlobalEvents.call(this);
          this._disconnected = false;

          if (!this._rendered) {
            this.render();
          }
        }
        /** @ignore */

      }, {
        key: "render",
        value: function render() {
          this._rendered = true;
        }
        /** @ignore */

      }, {
        key: "disconnectedCallback",
        value: function disconnectedCallback() {
          // A component that isn't in the DOM should not be responding to global events
          this._disconnected = true;
          undelegateGlobalEvents.call(this);
        }
      }, {
        key: "tracking",
        get: function get() {
          return this._tracking || this.getAttribute('tracking') || tracking$1.ON;
        },
        set: function set(value) {
          value = transform.string(value).toLowerCase();
          this._tracking = validate.enumeration(tracking$1)(value) && value || tracking$1.ON;
        }
        /**
         The string representing the feature being tracked. This provides additional context to the analytics trackers
         about the feature that the element enables.
          @type {String}
         @default ""
         @htmlattribute trackingfeature
         */

      }, {
        key: "trackingFeature",
        get: function get() {
          return this._trackingFeature || this.getAttribute('trackingFeature') || '';
        },
        set: function set(value) {
          this._trackingFeature = transform.string(value);
        }
        /**
         The string representing the element name being tracked. This providex additional context to the trackers about the
         element that was interacted with.
          @type {String}
         @default ""
         @htmlattribute trackingelement
         */

      }, {
        key: "trackingElement",
        get: function get() {
          return this._trackingElement || this.getAttribute('trackingElement') || '';
        },
        set: function set(value) {
          this._trackingElement = transform.string(value);
        } // Constructs and returns the component name based on the constructor

      }, {
        key: "_componentName",
        get: function get() {
          return this.constructor._componentName || getConstructorName(this.constructor);
        }
      }, {
        key: "_ignoreConnectedCallback",
        get: function get() {
          return this.__ignoreConnectedCallback || false;
        },
        set: function set(value) {
          value = transform.booleanAttr(value);

          if (value !== this.__ignoreConnectedCallback) {
            this.__ignoreConnectedCallback = value;

            _recursiveIgnoreConnectedCallback(this, value);
          }
        }
        /**
         Returns {@link BaseComponent} tracking options.
          @return {TrackingEnum}
         */

      }], [{
        key: "tracking",
        get: function get() {
          return tracking$1;
        }
      }, {
        key: "_attributePropertyMap",
        get: function get() {
          return {
            trackingelement: 'trackingElement',
            trackingfeature: 'trackingFeature'
          };
        }
        /** @ignore */

      }, {
        key: "observedAttributes",
        get: function get() {
          return ['tracking', 'trackingelement', 'trackingfeature', 'trackingFeature'];
        }
      }]);

      return _class;
    }(superClass);
  };

  var LABELLABLE_ELEMENTS_SELECTOR = 'button,input:not([type=hidden]),keygen,meter,output,progress,select,textarea'; // @polyfill ie11
  // IE11 throws syntax error because of the "not()" in the selector for some reason in ColorInputColorProperties

  if (navigator.userAgent.indexOf('MSIE') !== -1 || navigator.appVersion.indexOf('Trident/') > 0) {
    LABELLABLE_ELEMENTS_SELECTOR = 'button,keygen,meter,output,progress,select,textarea,'; // Since we can't use :not() we have to indicate all input types

    ['text', 'password', 'submit', 'reset', 'radio', 'checkbox', 'button', 'color', 'date', 'datetime-local', 'email', 'month', 'number', 'range', 'search', 'tel', 'time', 'url', 'week'].forEach(function (type) {
      LABELLABLE_ELEMENTS_SELECTOR += "input[type=".concat(type, "],");
    }); // Remove last ","

    LABELLABLE_ELEMENTS_SELECTOR = LABELLABLE_ELEMENTS_SELECTOR.slice(0, -1);
  } // _onInputChange is only triggered on non-hidden inputs


  var TARGET_INPUT_SELECTOR = 'input:not([type=hidden])';
  /**
   @base BaseFormField
   @classdesc The base element for Form Field components. If not extending a {@link HTMLInputElement}, following
   properties should be implemented at least :
   - <code>disabled</code>. Whether this field is disabled or not.
   - <code>invalid</code>. Whether the current value of this field is invalid or not.
   - <code>name</code>. Name used to submit the data in a form.
   - <code>readOnly</code>. Whether this field is readOnly or not. Indicating that the user cannot modify the value of the control.
   - <code>required</code>. Whether this field is required or not.
   - <code>value</code>. This field's current value.
   */

  var BaseFormField = function BaseFormField(superClass) {
    return /*#__PURE__*/function (_superClass) {
      _inherits(_class, _superClass);

      var _super = _createSuper(_class);

      /** @ignore */
      function _class() {
        var _this;

        _classCallCheck(this, _class);

        _this = _super.call(this);
        _this._events = {
          'capture:change input': '_onTargetInputChange',
          'global:reset': '_onFormReset'
        };
        return _this;
      }
      /**
       Whether this field is disabled or not.
        @type {Boolean}
       @default false
       @htmlattribute disabled
       @htmlattributereflected
       @abstract
       */

      /**
       Whether the current value of this field is invalid or not.
        @type {Boolean}
       @default false
       @htmlattribute invalid
       @htmlattributereflected
       @abstract
       */

      /**
       Name used to submit the data in a form.
        @type {String}
       @default ""
       @htmlattribute name
       @htmlattributereflected
       @abstract
       */

      /**
       Whether this field is readOnly or not. Indicating that the user cannot modify the value of the control.
       This is ignored for checkbox, radio or fileupload.
        @type {Boolean}
       @default false
       @htmlattribute readonly
       @htmlattributereflected
       @abstract
       */

      /**
       Whether this field is required or not.
        @type {Boolean}
       @default false
       @htmlattribute required
       @htmlattributereflected
       @abstract
       */

      /**
       This field's current value.
        @type {String}
       @default ""
       @htmlattribute value
       @abstract
       */

      /**
       Whether the current value of this field is invalid or not.
        @type {Boolean}
       @default false
       @htmlattribute invalid
       @htmlattributereflected
       */


      _createClass(_class, [{
        key: "_getLabellableElement",

        /**
         Gets the element that should get the label. In case none of the valid labelelable items are found, the component
         will be labelled instead.
         @protected
         @returns {HTMLElement} the labellable element.
         */
        value: function _getLabellableElement() {
          // Use predefined element or query it
          var element = this._labellableElement || this.querySelector(LABELLABLE_ELEMENTS_SELECTOR); // Use the found element or the container

          return element || this;
        }
        /**
         Gets the internal input that the BaseFormField would watch for change. By default, it searches if the
         <code>_getLabellableElement()</code> is an input. Components can override this function to be able to provide a
         different implementation. In case the value is <code>null</code>, the change event will be handled no matter
         the input that produced it.
         @protected
         @return {HTMLElement} the input to watch for changes.
         */

      }, {
        key: "_getTargetChangeInput",
        value: function _getTargetChangeInput() {
          // we use this._targetChangeInput as an internal cache to avoid querying the DOM again every time
          return this._targetChangeInput || ( // assignment returns the value
          this._targetChangeInput = this._getLabellableElement().matches(TARGET_INPUT_SELECTOR) ? this._getLabellableElement() : null);
        }
        /**
         Function called whenever the target component triggers a change event. <code>_getTargetChangeInput</code> is used
         internally to determine if the input belongs to the component. If the component decides to override this function,
         the default from the base will not be called.
         @protected
         */

      }, {
        key: "_onInputChange",
        value: function _onInputChange(event) {
          // stops the current event
          event.stopPropagation();
          /** @ignore */

          this[this._componentTargetProperty] = event.target[this._eventTargetProperty]; // Explicitly re-emit the change event after the property has been set

          if (this._triggerChangeEvent) {
            this.trigger('change');
          }
        }
        /**
         Resets the formField when a reset is triggered on the parent form.
         @protected
         */

      }, {
        key: "_onFormReset",
        value: function _onFormReset(event) {
          if (event.target.contains(this)) {
            this.reset();
          }
        }
        /**
         We capture every input change and validate that it belongs to our target input. If this is the case,
         <code>_onInputChange</code> will be called with the same event.
         @protected
         */

      }, {
        key: "_onTargetInputChange",
        value: function _onTargetInputChange(event) {
          var targetInput = this._getTargetChangeInput(); // if the targetInput is null we still call _onInputChange to be backwards compatible


          if (targetInput === event.target || targetInput === null) {
            // we call _onInputChange since the target matches
            this._onInputChange(event);
          }
        }
        /**
         A utility method for adding the appropriate <code>for</code> attribute to any <code>label</code> elements
         referenced by the <code>labelledBy</code> property value.
         @param {String} labelledBy
         The value of the <code>labelledBy<code> property providing a space-delimited list of the <code>id</code>
         attributes for elements that label the formField.
         @param {String} elementId
         The <code>id</code> of the formField or one of its descendants that should be labelled by
         <code>label</code> elements referenced by the <code>labelledBy</code> property value.
         @param {Boolean} remove
         Whether the existing <code>for</code> attributes should be removed.
         @protected
         */

      }, {
        key: "_updateForAttributes",
        value: function _updateForAttributes(labelledBy, elementId, remove) {
          // labelledby contains whitespace sparated items, so we need to separate each individual id
          var labelIds = labelledBy.split(/\s+/); // we update the 'for' attribute for every id.

          labelIds.forEach(function (currentValue) {
            var labelElement = document.getElementById(currentValue);

            if (labelElement && labelElement.tagName === 'LABEL') {
              var forAttribute = labelElement.getAttribute('for');

              if (remove) {
                // we just remove it when it is our target
                if (forAttribute === elementId) {
                  labelElement.removeAttribute('for');
                }
              } else {
                // if we do not have to remove, it does not matter the current value of the label, we can set it in every
                // case
                labelElement.setAttribute('for', elementId);
              }
            }
          });
        }
        /**
         Clears the <code>value</code> of formField to the default value.
         */

      }, {
        key: "clear",
        value: function clear() {
          /** @ignore */
          this.value = '';
        }
        /**
         Resets the <code>value</code> to the initial value.
         */

      }, {
        key: "reset",
        value: function reset() {
          // since the 'value' property is not reflected, form components use it to restore the initial value. When a
          // component has support for values, this method needs to be overwritten

          /** @ignore */
          this.value = transform.string(this.getAttribute('value'));
        }
      }, {
        key: "invalid",
        get: function get() {
          return this._invalid || false;
        },
        set: function set(value) {
          value = transform.booleanAttr(value);

          this._reflectAttribute('invalid', value);

          if (validate.valueMustChange(this._invalid, value)) {
            this._invalid = value;
            this.setAttribute('aria-invalid', value);
            this.classList.toggle('is-invalid', value);
          }
        }
        /**
         Reflects the <code>aria-describedby</code> attribute to the labellable element e.g. inner input.
          @type {String}
         @default null
         @htmlattribute describedby
         */

      }, {
        key: "describedBy",
        get: function get() {
          return this._getLabellableElement().getAttribute('aria-describedby');
        },
        set: function set(value) {
          value = transform.string(value);

          this._getLabellableElement()[value ? 'setAttribute' : 'removeAttribute']('aria-describedby', value);
        }
        /**
         Reflects the <code>aria-label</code> attribute to the labellable element e.g. inner input.
          @type {String}
         @default null
         @htmlattribute labelled
         */

      }, {
        key: "labelled",
        get: function get() {
          return this._getLabellableElement().getAttribute('aria-label');
        },
        set: function set(value) {
          value = transform.string(value);

          this._getLabellableElement()[value ? 'setAttribute' : 'removeAttribute']('aria-label', value);
        }
        /**
         Reference to a space delimited set of ids for the HTML elements that provide a label for the formField.
         Implementers should override this method to ensure that the appropriate descendant elements are labelled using the
         <code>aria-labelledby</code> attribute. This will ensure that the component is properly identified for
         accessibility purposes. It reflects the <code>aria-labelledby</code> attribute to the DOM.
         @type {?String}
         @default null
         @htmlattribute labelledby
         */

      }, {
        key: "labelledBy",
        get: function get() {
          return this._getLabellableElement().getAttribute('aria-labelledby');
        },
        set: function set(value) {
          value = transform.string(value); // gets the element that will get the label assigned. the _getLabellableElement method should be overriden to
          // allow other bevaviors.

          var element = this._getLabellableElement(); // we get and assign the it that will be passed around


          var elementId = element.id = element.id || commons.getUID();
          var currentLabelledBy = element.getAttribute('aria-labelledby'); // we clear the old label assignments

          if (currentLabelledBy && currentLabelledBy !== value) {
            this._updateForAttributes(currentLabelledBy, elementId, true);
          }

          if (value) {
            element.setAttribute('aria-labelledby', value);

            if (element.matches(LABELLABLE_ELEMENTS_SELECTOR)) {
              this._updateForAttributes(value, elementId);
            }
          } else {
            // since no labelledby value was set, we remove everything
            element.removeAttribute('aria-labelledby');
          }
        }
        /**
         Target property inside the component that will be updated when a change event is triggered.
         @type {String}
         @default "value"
         @protected
         */

      }, {
        key: "_componentTargetProperty",
        get: function get() {
          return 'value';
        }
        /**
         Target property that will be taken from <code>event.target</code> and set into
         {@link BaseFormField#_componentTargetProperty} when a change event is triggered.
         @type {String}
         @default "value"
         @protected
         */

      }, {
        key: "_eventTargetProperty",
        get: function get() {
          return 'value';
        }
        /**
         Whether the change event needs to be triggered when {@link BaseFormField#_onInputChange} is called.
         @type {Boolean}
         @default true
         @protected
         */

      }, {
        key: "_triggerChangeEvent",
        get: function get() {
          return true;
        }
      }], [{
        key: "_attributePropertyMap",
        get: function get() {
          return commons.extend(_get(_getPrototypeOf(_class), "_attributePropertyMap", this), {
            describedby: 'describedBy',
            labelledby: 'labelledBy',
            readonly: 'readOnly'
          });
        } // We don't want to watch existing attributes for components that extend native HTML elements

      }, {
        key: "_nativeObservedAttributes",
        get: function get() {
          return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['describedby', 'labelled', 'labelledby', 'invalid']);
        }
        /** @ignore */

      }, {
        key: "observedAttributes",
        get: function get() {
          return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['describedby', 'labelled', 'labelledby', 'invalid', 'readonly', 'name', 'value', 'disabled', 'required']);
        }
      }]);

      return _class;
    }(superClass);
  };

  /**
   * Copyright 2021 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   * Decorator will be used to intercept any call before passing it to actual element.
   * kind of wrapper around each coral component
   * @private
   */
  var Decorator = function Decorator(superClass) {
    return /*#__PURE__*/function (_superClass) {
      _inherits(_class, _superClass);

      var _super = _createSuper(_class);

      function _class() {
        _classCallCheck(this, _class);

        return _super.apply(this, arguments);
      }

      _createClass(_class, [{
        key: "_resumeCallback",

        /** @ignore */
        value: function _resumeCallback() {
          _get(_getPrototypeOf(_class.prototype), "_resumeCallback", this).call(this);
        }
        /** @ignore */

      }, {
        key: "_suspendCallback",
        value: function _suspendCallback() {
          _get(_getPrototypeOf(_class.prototype), "_suspendCallback", this).call(this);
        }
        /** @ignore */

      }, {
        key: "connectedCallback",
        value: function connectedCallback() {
          if (!this.isConnected) {
            // component is not connected  do nothing
            return;
          } else if (this._disconnected === false || this._ignoreConnectedCallback === true) {
            // either component is being moved around DOM or callback are ignored, resume suspended component
            // use this hook to only change required state and properties.
            // avoid executing whole connect and disconnect hooks
            this._resumeCallback();
          } else {
            // normal flow
            _get(_getPrototypeOf(_class.prototype), "connectedCallback", this).call(this);
          }
        }
        /** @ignore */

      }, {
        key: "disconnectedCallback",
        value: function disconnectedCallback() {
          if (!(this._disconnected === false)) {
            // component is already disconnected do nothing
            return;
          } else if (this.isConnected || this._ignoreConnectedCallback === true) {
            // either component is being moved around DOM or callback are ignored, only suspend component.
            // use this hook to only change required state and properties.
            // avoid executing whole connect and disconnect hooks
            this._suspendCallback();
          } else {
            // normal flow
            _get(_getPrototypeOf(_class.prototype), "disconnectedCallback", this).call(this);
          }
        }
      }]);

      return _class;
    }(superClass);
  };

  /**
   Enumeration for {@link Textfield} variants.

   @typedef {Object} TextfieldVariantEnum

   @property {String} DEFAULT
   A default textfield.
   @property {String} QUIET
   A textfield with no border or background.
   */

  var variant = {
    DEFAULT: 'default',
    QUIET: 'quiet'
  }; // the textfield's base classname

  var CLASSNAME = '_coral-Textfield'; // Builds a string containing all possible variant classnames. This will be used to remove classnames when the variant
  // changes

  var ALL_VARIANT_CLASSES = [];

  for (var variantValue in variant) {
    ALL_VARIANT_CLASSES.push("".concat(CLASSNAME, "--").concat(variant[variantValue]));
  }
  /**
   @class Coral.Textfield
   @classdesc A Textfield component is the default single line text form field.
   @htmltag coral-textfield
   @htmlbasetag input
   @extends {HTMLInputElement}
   @extends {BaseComponent}
   @extends {BaseFormField}
   */


  var Textfield = Decorator( /*#__PURE__*/function (_BaseFormField) {
    _inherits(_class, _BaseFormField);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this);

      _this._delegateEvents(_this._events);

      return _this;
    }
    /**
     The textfield's variant. See {@link TextfieldVariantEnum}.
      @type {String}
     @default TextfieldVariantEnum.DEFAULT
     @htmlattribute variant
     @htmlattributereflected
     */


    _createClass(_class, [{
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME); // Default reflected attributes

        if (!this._variant) {
          this.variant = variant.DEFAULT;
        }
      }
    }, {
      key: "variant",
      get: function get() {
        return this._variant || variant.DEFAULT;
      },
      set: function set(value) {
        var _this$classList;

        value = transform.string(value).toLowerCase();
        this._variant = validate.enumeration(variant)(value) && value || variant.DEFAULT;

        this._reflectAttribute('variant', this._variant); // removes every existing variant


        (_this$classList = this.classList).remove.apply(_this$classList, ALL_VARIANT_CLASSES);

        if (this._variant !== variant.DEFAULT) {
          this.classList.add("".concat(CLASSNAME, "--").concat(this._variant));
        }
      }
      /**
       Returns {@link Textfield} variants.
        @return {TextfieldVariantEnum}
       */

    }], [{
      key: "variant",
      get: function get() {
        return variant;
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "_nativeObservedAttributes", this).concat(['variant']);
      }
    }]);

    return _class;
  }(BaseFormField(BaseComponent(HTMLInputElement))));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons._define('coral-textfield', Textfield, {
    extends: 'input'
  });

  /**
   * Copyright 2020 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @base BaseLabellable
   @classdesc Accessibility helper for components with label and icon properties
   */
  var BaseLabellable = function BaseLabellable(superClass) {
    return /*#__PURE__*/function (_superClass) {
      _inherits(_class, _superClass);

      var _super = _createSuper(_class);

      function _class() {
        _classCallCheck(this, _class);

        return _super.apply(this, arguments);
      }

      _createClass(_class, [{
        key: "_observeLabel",
        value: function _observeLabel() {
          this._observableLabel = this._observableLabel || this._elements.label || this._elements.content; // Listen for mutations

          this._observer = new MutationObserver(this._toggleIconAriaHidden.bind(this)); // Watch for changes to the content element

          this._observer.observe(this._observableLabel, {
            // Catch changes to childList
            childList: true,
            // Catch changes to textContent
            characterData: true,
            // Monitor any child node
            subtree: true
          });
        } // Hides the icon from screen readers to avoid duplicated labels

      }, {
        key: "_toggleIconAriaHidden",
        value: function _toggleIconAriaHidden() {
          this._renderedLabel = this._renderedLabel || this.label || this.content; // toggle aria-hidden if tab is labelled

          if (this._elements.icon) {
            var isLabelled = this._renderedLabel && this._renderedLabel.textContent.trim().length || this.getAttribute('aria-label') !== null || this.getAttribute('aria-labelledby') !== null;

            this._elements.icon[isLabelled ? 'setAttribute' : 'removeAttribute']('aria-hidden', 'true');
          }
        }
        /** @ignore */

      }, {
        key: "attributeChangedCallback",

        /** @ignore */
        value: function attributeChangedCallback(name, oldValue, value) {
          if (name === 'aria-label' || name === 'aria-labelledby') {
            this._toggleIconAriaHidden();
          } else {
            _get(_getPrototypeOf(_class.prototype), "attributeChangedCallback", this).call(this, name, oldValue, value);
          }
        }
      }], [{
        key: "observedAttributes",
        get: function get() {
          return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['aria-label', 'aria-labelledby']);
        }
      }]);

      return _class;
    }(superClass);
  };

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var ICON_MAP = {
    "aBC": {
      "deprecated": true,
      "spectrumIcon": "ABC"
    },
    "abc": {
      "spectrumIcon": "ABC"
    },
    "accordionDown": {
      "spectrumIcon": "ChevronDown"
    },
    "accordionLeft": {
      "spectrumIcon": "ChevronDoubleLeft"
    },
    "accordionRight": {
      "spectrumIcon": "ChevronDoubleRight"
    },
    "accordionUp": {
      "spectrumIcon": "ChevronUp"
    },
    "adjust": {
      "spectrumIcon": "Exposure"
    },
    "adobe": {
      "spectrumIcon": "AdobeLogo"
    },
    "adobeAdvertisingCloudColor": {
      "spectrumIconDark": "AdobeAdvertisingCloudColor_Dark",
      "spectrumIconLight": "AdobeAdvertisingCloudColor_Light"
    },
    "adobeAnalyticsColor": {
      "spectrumIconDark": "AdobeAnalyticsColor_Dark",
      "spectrumIconLight": "AdobeAnalyticsColor_Light"
    },
    "adobeAnalyticsColorLight": {
      "spectrumIcon": "AdobeAnalyticsColor_Light"
    },
    "adobeAnalyticsColorDark": {
      "spectrumIcon": "AdobeAnalyticsColor_Dark"
    },
    "adobeAudienceManagerColor": {
      "spectrumIconDark": "AdobeAudienceManagerColor_Dark",
      "spectrumIconLight": "AdobeAudienceManagerColor_Light"
    },
    "adobeAudienceManagerColorLight": {
      "spectrumIcon": "AdobeAudienceManagerColor_Light"
    },
    "adobeAudienceManagerColorDark": {
      "spectrumIcon": "AdobeAudienceManagerColor_Dark"
    },
    "adobeCampaignColor": {
      "spectrumIconDark": "AdobeCampaignColor_Dark",
      "spectrumIconLight": "AdobeCampaignColor_Light"
    },
    "adobeCampaignColorLight": {
      "spectrumIcon": "AdobeCampaignColor_Light"
    },
    "adobeCampaignColorDark": {
      "spectrumIcon": "AdobeCampaignColor_Dark"
    },
    "adobeExperienceCloudColor": {
      "spectrumIcon": "AdobeExperienceCloudColor"
    },
    "adobeExperienceManagerColor": {
      "spectrumIconDark": "AdobeExperienceManagerColor_Dark",
      "spectrumIconLight": "AdobeExperienceManagerColor_Light"
    },
    "adobeExperienceManagerColorLight": {
      "spectrumIcon": "AdobeExperienceManagerColor_Light"
    },
    "adobeExperienceManagerColorDark": {
      "spectrumIcon": "AdobeExperienceManagerColor_Dark"
    },
    "adobeExperiencePlatformColor": {
      "spectrumIcon": "AdobeExperiencePlatformColor"
    },
    "adobeMediaOptimizerColor": {
      "spectrumIconDark": "AdobeMediaOptimizerColor_Dark",
      "spectrumIconLight": "AdobeMediaOptimizerColor_Light"
    },
    "adobeMediaOptimizerColorLight": {
      "spectrumIcon": "AdobeMediaOptimizerColor_Light"
    },
    "adobeMediaOptimizerColorDark": {
      "spectrumIcon": "AdobeMediaOptimizerColor_Dark"
    },
    "adobePrimetimeColor": {
      "spectrumIconDark": "AdobePrimetimeColor_Dark",
      "spectrumIconLight": "AdobePrimetimeColor_Light"
    },
    "adobePrimetimeColorLight": {
      "spectrumIcon": "AdobePrimetimeColor_Light"
    },
    "adobePrimetimeColorDark": {
      "spectrumIcon": "AdobePrimetimeColor_Dark"
    },
    "adobeSocialColor": {
      "spectrumIconDark": "AdobeSocialColor_Dark",
      "spectrumIconLight": "AdobeSocialColor_Light"
    },
    "adobeSocialColorLight": {
      "spectrumIcon": "AdobeSocialColor_Light"
    },
    "adobeSocialColorDark": {
      "spectrumIcon": "AdobeSocialColor_Dark"
    },
    "adobeTargetColor": {
      "spectrumIconDark": "AdobeTargetColor_Dark",
      "spectrumIconLight": "AdobeTargetColor_Light"
    },
    "adobeTargetColorLight": {
      "spectrumIcon": "AdobeTargetColor_Light"
    },
    "adobeTargetColorDark": {
      "spectrumIcon": "AdobeTargetColor_Dark"
    },
    "annotate": {
      "spectrumIcon": "AnnotatePen"
    },
    "automate": {
      "spectrumIcon": "Gears"
    },
    "breadcrumb": {
      "spectrumIcon": "Menu"
    },
    "calendarCheckColor": {
      "spectrumIcon": "CalendarCheckColor_Light"
    },
    "campaignRemove": {
      "spectrumIcon": "CampaignClose"
    },
    "check": {
      "spectrumIcon": "Checkmark"
    },
    "checkCircle": {
      "spectrumIcon": "CheckmarkCircle"
    },
    "closedCaptions": {
      "spectrumIcon": "CloseCaptions"
    },
    "coverImage": {
      "spectrumIcon": "FacebookCoverImage"
    },
    "deviceMobile": {
      "spectrumIcon": "DevicePhone"
    },
    "deviceTv": {
      "deprecated": true,
      "spectrumIcon": "DeviceTV"
    },
    "downloaded": {
      "spectrumIcon": "Download"
    },
    "downloadFromCloud": {
      "deprecated": true,
      "spectrumIcon": "Download"
    },
    "dPS": {
      "deprecated": true,
      "spectrumIcon": "DPS"
    },
    "dps": {
      "spectrumIcon": "DPS"
    },
    "draw": {
      "spectrumIcon": "AnnotatePen"
    },
    "emailAlert": {
      "spectrumIcon": "Alert"
    },
    "emotionAdmirationColor": {
      "spectrumIcon": "EmotionAdmirationColor_Light"
    },
    "emotionAngerColor": {
      "spectrumIcon": "EmotionAngerColor_Light"
    },
    "emotionAnticipationColor": {
      "spectrumIcon": "EmotionAnticipationColor_Light"
    },
    "emotionDisgustColor": {
      "spectrumIcon": "EmotionDisgustColor_Light"
    },
    "emotionFearColor": {
      "spectrumIcon": "EmotionFearColor_Light"
    },
    "emotionJoyColor": {
      "spectrumIcon": "EmotionJoyColor_Light"
    },
    "emotionSadnessColor": {
      "spectrumIcon": "EmotionSadnessColor_Light"
    },
    "emotionSurpriseColor": {
      "spectrumIcon": "EmotionSurpriseColor_Light"
    },
    "exclude": {
      "spectrumIcon": "Cancel"
    },
    "eyedropper": {
      "spectrumIcon": "Sampler"
    },
    "facebookCircleColor": {
      "spectrumIcon": "FacebookCircleColor_Light"
    },
    "facebookColor": {
      "spectrumIcon": "FacebookColor_Light"
    },
    "file": {
      "spectrumIcon": "Document"
    },
    "fileGlobe2": {
      "spectrumIcon": "FileGlobe"
    },
    "film": {
      "spectrumIcon": "Filmroll"
    },
    "flickrColor": {
      "spectrumIcon": "FlickrColor_Light"
    },
    "folderDefault": {
      "spectrumIcon": "FolderAdobe"
    },
    "folderLockedDefault": {
      "spectrumIcon": "FolderLockedAdobe"
    },
    "gear": {
      "spectrumIcon": "Settings"
    },
    "googleAnalyticsColor": {
      "spectrumIcon": "GoogleAnalyticsColor_Light"
    },
    "googlePlusCircleColor": {
      "spectrumIcon": "GooglePlusCircleColor_Light"
    },
    "googlePlusColor": {
      "spectrumIcon": "GooglePlusColor_Light"
    },
    "graphBarStackedHorizontal": {
      "spectrumIcon": "GraphBarHorizontalStacked"
    },
    "graphBarStackedVertical": {
      "spectrumIcon": "GraphBarVertical"
    },
    "graphTrendRounded": {
      "spectrumIcon": "GraphTrend"
    },
    "helpCircle": {
      "spectrumIcon": "Help"
    },
    "hTML5": {
      "deprecated": true,
      "spectrumIcon": "HTML5"
    },
    "html5": {
      "spectrumIcon": "HTML5"
    },
    "imageCheckColor": {
      "spectrumIcon": "ImageCheckColor_Light"
    },
    "imageMap": {
      "spectrumIcon": "ImageMapRectangle"
    },
    "infoCircle": {
      "spectrumIcon": "Info"
    },
    "instagramCircleColor": {
      "spectrumIcon": "InstagramCircleColor_Light"
    },
    "instagramColor": {
      "spectrumIcon": "InstagramColor_Light"
    },
    "linkCheckColor": {
      "spectrumIcon": "LinkCheckColor_Light"
    },
    "linkedInCircleColor": {
      "spectrumIcon": "LinkedInCircleColor_Light"
    },
    "linkedInColor": {
      "spectrumIcon": "LinkedInColor_Light"
    },
    "lockOff": {
      "spectrumIcon": "LockOpen"
    },
    "lockOn": {
      "spectrumIcon": "LockClosed"
    },
    "magentoCommerceColor": {
      "spectrumIconDark": "MagentoCommerceColor_Dark",
      "spectrumIconLight": "MagentoCommerceColor_Light"
    },
    "minus": {
      "spectrumIcon": "Remove"
    },
    "minusCircle": {
      "spectrumIcon": "RemoveCircle"
    },
    "navigation": {
      "spectrumIcon": "Rail"
    },
    "newsgatorColor": {
      "spectrumIcon": "NewsgatorColor_Light"
    },
    "open": {
      "spectrumIcon": "FolderOpen"
    },
    "os": {
      "spectrumIcon": "OS"
    },
    "oS": {
      "deprecated": true,
      "spectrumIcon": "OS"
    },
    "page": {
      "spectrumIcon": "WebPage"
    },
    "pages": {
      "spectrumIcon": "WebPages"
    },
    "paintBucket": {
      "spectrumIcon": "ColorFill"
    },
    "pausePlay": {
      "spectrumIcon": "StepForward"
    },
    "pausePlayCircle": {
      "spectrumIcon": "StepForwardCircle"
    },
    "popOut": {
      "spectrumIcon": "ArrowUpRight"
    },
    "projectCameraColor": {
      "spectrumIcon": "ProjectCameraColor_Light"
    },
    "projectColor": {
      "spectrumIcon": "ProjectColor_Light"
    },
    "projectPlayColor": {
      "spectrumIcon": "ProjectPlayColor_Light"
    },
    "projectRefreshColor": {
      "spectrumIcon": "ProjectRefreshColor_Light"
    },
    "publish": {
      "spectrumIcon": "Send"
    },
    "reflectHorizontal": {
      "spectrumIcon": "FlipHorizontal"
    },
    "reflectVertical": {
      "spectrumIcon": "FlipVertical"
    },
    "rSS": {
      "deprecated": true,
      "spectrumIcon": "RSS"
    },
    "rss": {
      "spectrumIcon": "RSS"
    },
    "save": {
      "spectrumIcon": "SaveFloppy"
    },
    "saveAs": {
      "spectrumIcon": "SaveAsFloppy"
    },
    "select": {
      "spectrumIcon": "SelectBox"
    },
    "selectAll": {
      "spectrumIcon": "SelectBoxAll"
    },
    "sinaWeiboCircleColor": {
      "spectrumIcon": "SinaWeiboCircleColor_Light"
    },
    "sinaWeiboColor": {
      "spectrumIcon": "SinaWeiboColor_Light"
    },
    "sms": {
      "spectrumIcon": "SMS"
    },
    "sMS": {
      "deprecated": true,
      "spectrumIcon": "SMS"
    },
    "sMSLightning": {
      "deprecated": true,
      "spectrumIcon": "SMSLightning"
    },
    "smsLightning": {
      "spectrumIcon": "SMSLightning"
    },
    "sMSRefresh": {
      "deprecated": true,
      "spectrumIcon": "SMSRefresh"
    },
    "smsRefresh": {
      "spectrumIcon": "SMSRefresh"
    },
    "star": {
      "spectrumIcon": "Star"
    },
    "starFill": {
      "spectrumIcon": "Star"
    },
    "starStroke": {
      "spectrumIcon": "StarOutline"
    },
    "stop": {
      "spectrumIcon": "StopCircle"
    },
    "tableCellMergeColor": {
      "spectrumIconActive": "TableCellMergeColor_Active",
      "spectrumIconDark": "TableCellMergeColor_Dark",
      "spectrumIconLight": "TableCellMergeColor_Light"
    },
    "tableColumnAddLeftColor": {
      "spectrumIconActive": "TableColumnAddLeftColor_Active",
      "spectrumIconDark": "TableColumnAddLeftColor_Dark",
      "spectrumIconLight": "TableColumnAddLeftColor_Light"
    },
    "tableColumnAddRightColor": {
      "spectrumIconActive": "TableColumnAddRightColor_Active",
      "spectrumIconDark": "TableColumnAddRightColor_Dark",
      "spectrumIconLight": "TableColumnAddLeftColor_Light"
    },
    "tableColumnMergeColor": {
      "spectrumIconActive": "TableColumnMergeColor_Active",
      "spectrumIconDark": "TableColumnMergeColor_Dark",
      "spectrumIconLight": "TableColumnMergeColor_Light"
    },
    "tableColumnRemoveCenterColor": {
      "spectrumIconActive": "TableColumnRemoveCenterColor_Active",
      "spectrumIconDark": "TableColumnRemoveCenterColor_Dark",
      "spectrumIconLight": "TableColumnRemoveCenterColor_Light"
    },
    "tableColumnSplitColor": {
      "spectrumIconActive": "TableColumnSplitColor_Active",
      "spectrumIconDark": "TableColumnSplitColor_Dark",
      "spectrumIconLight": "TableColumnSplitColor_Light"
    },
    "tableRowAddBottomColor": {
      "spectrumIconActive": "TableRowAddBottomColor_Active",
      "spectrumIconDark": "TableRowAddBottomColor_Dark",
      "spectrumIconLight": "TableRowAddBottomColor_Light"
    },
    "tableRowAddTopColor": {
      "spectrumIconActive": "TableRowAddTopColor_Active",
      "spectrumIconDark": "TableRowAddTopColor_Dark",
      "spectrumIconLight": "TableRowAddTopColor_Light"
    },
    "tableRowMergeColor": {
      "spectrumIconActive": "TableRowMergeColor_Active",
      "spectrumIconDark": "TableRowMergeColor_Dark",
      "spectrumIconLight": "TableRowMergeColor_Light"
    },
    "tableRowRemoveCenterColor": {
      "spectrumIconActive": "TableRowRemoveCenterColor_Active",
      "spectrumIconDark": "TableRowRemoveCenterColor_Dark",
      "spectrumIconLight": "TableRowRemoveCenterColor_Light"
    },
    "tableRowSplitColor": {
      "spectrumIconActive": "TableRowSplitColor_Active",
      "spectrumIconDark": "TableRowSplitColor_Dark",
      "spectrumIconLight": "TableRowSplitColor_Light"
    },
    "tableSelectColumnColor": {
      "spectrumIconActive": "TableSelectColumnColor_Active",
      "spectrumIconDark": "TableSelectColumnColor_Dark",
      "spectrumIconLight": "TableSelectColumnColor_Light"
    },
    "tableSelectRowColor": {
      "spectrumIconActive": "TableSelectRowColor_Active",
      "spectrumIconDark": "TableSelectRowColor_Dark",
      "spectrumIconLight": "TableSelectRowColor_Light"
    },
    "tag": {
      "spectrumIcon": "Label"
    },
    "tagExclude": {
      "spectrumIcon": "LabelExclude"
    },
    "tags": {
      "spectrumIcon": "Labels"
    },
    "targetCheckColor": {
      "spectrumIcon": "TargetCheckColor_Light"
    },
    "textCenter": {
      "spectrumIcon": "TextAlignCenter"
    },
    "textJustified": {
      "spectrumIcon": "TextAlignJustify"
    },
    "textLeft": {
      "spectrumIcon": "TextAlignLeft"
    },
    "textLetteredLowercase": {
      "spectrumIcon": "TextLetteredLowerCase"
    },
    "textLetteredUppercase": {
      "spectrumIcon": "TextLetteredUpperCase"
    },
    "textRight": {
      "spectrumIcon": "TextAlignRight"
    },
    "triangleDown": {
      "spectrumIcon": "ChevronDown"
    },
    "triangleRight": {
      "spectrumIcon": "ChevronRight"
    },
    "twitterCircleColor": {
      "spectrumIcon": "TwitterCircleColor_Light"
    },
    "twitterColor": {
      "spectrumIcon": "TwitterColor_Light"
    },
    "unflag": {
      "spectrumIcon": "FlagExclude"
    },
    "unpublish": {
      "spectrumIcon": "GlobeRemove"
    },
    "upload": {
      "spectrumIcon": "UploadToCloud"
    },
    "usa": {
      "spectrumIcon": "USA"
    },
    "uSA": {
      "deprecated": true,
      "spectrumIcon": "USA"
    },
    "userCircleColor": {
      "spectrumIconDark": "UserCircleColor_Dark",
      "spectrumIconLight": "UserCircleColor_Light"
    },
    "userGroupCircleColor": {
      "spectrumIconDark": "UserGroupCircleColor_Dark",
      "spectrumIconLight": "UserGroupCircleColor_Light"
    },
    "users": {
      "spectrumIcon": "UserGroup"
    },
    "viewOff": {
      "spectrumIcon": "VisibilityOff"
    },
    "viewOn": {
      "spectrumIcon": "Visibility"
    },
    "vk": {
      "spectrumIcon": "VK"
    },
    "vK": {
      "deprecated": true,
      "spectrumIcon": "VK"
    },
    "wand": {
      "spectrumIcon": "MagicWand"
    },
    "windowsColor": {
      "spectrumIcon": "WindowsColor_Light"
    },
    "wordpressColor": {
      "spectrumIcon": "WordpressColor_Light"
    },
    "write": {
      "spectrumIcon": "AnnotatePen"
    },
    "youTubeCircleColor": {
      "spectrumIcon": "YouTubeCircleColor_Light"
    },
    "youTubeColor": {
      "spectrumIcon": "YouTubeColor_Light"
    }
  };

  var SPECTRUM_ICONS_PATH = 'dist/resources/spectrum-icons.svg';

  var SPECTRUM_ICONS_COLOR_PATH = 'dist/resources/spectrum-icons-color.svg';

  var SPECTRUM_CSS_ICONS_PATH = 'dist/resources/spectrum-css-icons.svg';

  /**
   * Copyright 2020 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var SPECTRUM_ICONS = 'spectrum-icons';
  var SPECTRUM_ICONS_COLOR = 'spectrum-icons-color';
  var SPECTRUM_CSS_ICONS = 'spectrum-css-icons';

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  function handleError(string) {
    string = "Coral.Icon#load: ".concat(string);
    var error = new Error(string);
    console.error(error.toString());
  }

  function injectSVG(svgURL) {
    // 200 for web servers, 0 for CEP panels
    if (this.status !== 200 && this.status !== 0) {
      handleError("failed to fetch icons, server returned ".concat(this.status));
      return;
    } // Parse the SVG


    var parser = new DOMParser();

    try {
      var doc = parser.parseFromString(this.responseText, 'image/svg+xml');
      var svg = doc.firstChild; // Make sure a real SVG was returned

      if (svg && svg.tagName === 'svg') {
        if (svgURL.indexOf(SPECTRUM_ICONS_COLOR) !== -1) {
          // Insert it into the body
          if (document.body) {
            document.body.appendChild(svg);
          } else {
            document.addEventListener('DOMContentLoaded', function () {
              document.body.appendChild(svg);
            });
          }
        } else {
          document.head.appendChild(svg);
        }
      } else {
        handleError('parsed SVG document contained something other than an SVG');
      }
    } catch (err) {
      handleError("error parsing SVG: ".concat(err));
    }
  }

  function loadIcons(svgURL) {
    if (svgURL.slice(-3) === '.js') {
      // Injects the SVG icons in the document
      var script = document.createElement('script');
      script.async = true;
      script.type = 'text/javascript';
      script.src = svgURL;
      document.head.appendChild(script);
    } else {
      // Request the SVG icons
      var req = new XMLHttpRequest();
      req.open('GET', svgURL, true);
      req.addEventListener('load', injectSVG.bind(req, svgURL));
      req.addEventListener('error', function () {
        handleError('Request failed');
      });
      req.send();
    }
  }

  var SPECTRUM_ICONS_IDENTIFIER = 'spectrum-';
  var SPECTRUM_COLORED_ICONS_IDENTIFIER = ['ColorLight', 'Color_Light', 'ColorDark', 'Color_Dark', 'ColorActive', 'Color_Active', // Unique colored icons
  'AdobeExperienceCloudColor', 'AdobeExperiencePlatformColor'];
  var resourcesPath = (commons.options.icons || '').trim();

  if (resourcesPath.length && resourcesPath[resourcesPath.length - 1] !== '/') {
    resourcesPath += '/';
  } // @IE11


  var IS_IE11 = !window.ActiveXObject && 'ActiveXObject' in window;
  var iconsExternal = commons.options.iconsExternal || 'on';

  if (IS_IE11) {
    iconsExternal = 'off';
  }

  var resolveIconsPath = function resolveIconsPath(iconsPath) {
    var path = commons._script.src;
    return "".concat(path.split('/').slice(0, -iconsPath.split('/').length).join('/'), "/").concat(iconsPath);
  };
  /**
   Regex used to match URLs. Assume it's a URL if it has a slash, colon, or dot.

   @ignore
   */


  var URL_REGEX = /\/|:|\./g;
  /**
   Regex used to match unresolved templates e.g. for data-binding

   @ignore
   */

  var TEMPLATE_REGEX = /.*\{\{.+\}\}.*/g;
  /**
   Regex used to split camel case icon names into more screen-reader friendly alt text.

   @ignore
   */

  var SPLIT_CAMELCASE_REGEX = /([a-z])([A-Z0-9])/g;
  /**
   Regex used to match the sized spectrum icon prefix

   @ignore
   */

  var SPECTRUM_ICONS_IDENTIFIER_REGEX = /^spectrum(?:-css)?-icon(?:-\d{1,3})?-/gi;
  /**
   Regex used match the variant postfix for an icon

   @ignore
   */

  var ICONS_VARIANT_POSTFIX_REGEX = /(Outline)?(Filled)?(Small|Medium|Large)?(Color)?_?(Active|Dark|Light)?$/;
  /**
   Translation hint used for localizing default alt text for an icon

   @ignore
   */

  var ICON_ALT_TRANSLATION_HINT = 'default icon alt text';
  /**
   Returns capitalized string. This is used to map the icons with their SVG counterpart.

   @ignore
   @param {String} s
   @return {String}
   */

  var capitalize = function capitalize(s) {
    return s.charAt(0).toUpperCase() + s.slice(1);
  };
  /**
   Enumeration for {@link Icon} sizes.

   @typedef {Object} IconSizeEnum

   @property {String} EXTRA_EXTRA_SMALL
   Extra extra small size icon, typically 9px size.
   @property {String} EXTRA_SMALL
   Extra small size icon, typically 12px size.
   @property {String} SMALL
   Small size icon, typically 18px size. This is the default size.
   @property {String} MEDIUM
   Medium size icon, typically 24px size.
   @property {String} LARGE
   Large icon, typically 36px size.
   @property {String} EXTRA_LARGE
   Extra large icon, typically 48px size.
   @property {String} EXTRA_EXTRA_LARGE
   Extra extra large icon, typically 72px size.
   */


  var size = {
    EXTRA_EXTRA_SMALL: 'XXS',
    EXTRA_SMALL: 'XS',
    SMALL: 'S',
    MEDIUM: 'M',
    LARGE: 'L',
    EXTRA_LARGE: 'XL',
    EXTRA_EXTRA_LARGE: 'XXL'
  };
  /**
   Enumeration for {@link Icon} autoAriaLabel value.

   @typedef {Object} IconAutoAriaLabelEnum

   @property {String} ON
   The aria-label attribute is automatically set based on the icon name.
   @property {String} OFF
   The aria-label attribute is not set and has to be provided explicitly.
   */

  var autoAriaLabel = {
    ON: 'on',
    OFF: 'off'
  }; // icon's base classname

  var CLASSNAME$1 = '_coral-Icon'; // builds an array containing all possible size classnames. this will be used to remove classnames when the size
  // changes

  var ALL_SIZE_CLASSES = [];

  for (var sizeValue in size) {
    ALL_SIZE_CLASSES.push("".concat(CLASSNAME$1, "--size").concat(size[sizeValue]));
  } // Based on https://github.com/adobe/spectrum-css/tree/master/icons


  var sizeMap = {
    XXS: 18,
    XS: 24,
    S: 18,
    M: 24,
    L: 18,
    XL: 24,
    XXL: 24
  };
  /**
   @class Coral.Icon
   @classdesc An Icon component. Icon ships with a set of SVG icons.
   @htmltag coral-icon
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var Icon = Decorator( /*#__PURE__*/function (_BaseComponent) {
    _inherits(_class, _BaseComponent);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this);
      _this._elements = {};
      return _this;
    }
    /**
     Whether aria-label is set automatically. See {@link IconAutoAriaLabelEnum}.
      @type {String}
     @default IconAutoAriaLabelEnum.OFF
     */


    _createClass(_class, [{
      key: "_updateIcon",
      value: function _updateIcon() {
        var iconId = this.icon; // If icon name is passed, we have to build the icon Id based on the icon name

        if (iconId.indexOf(SPECTRUM_ICONS_IDENTIFIER) !== 0) {
          var iconMapped = ICON_MAP[iconId];
          var iconName; // Restore default state

          this.removeAttribute('_context');

          if (iconMapped) {
            if (iconMapped.spectrumIcon) {
              // Use the default mapped icon
              iconName = iconMapped.spectrumIcon;
            } else {
              // Verify if icon should be light or dark by looking up parents theme
              var closest = this.closest('.coral--light, .coral--dark, .coral--lightest, .coral--darkest');

              if (closest) {
                if (closest.classList.contains('coral--light') || closest.classList.contains('coral--lightest')) {
                  // Use light icon
                  iconName = iconMapped.spectrumIconLight;
                } else {
                  // Use dark icon
                  iconName = iconMapped.spectrumIconDark;
                }
              } // Use light by default
              else {
                  iconName = iconMapped.spectrumIconLight;
                } // Mark icon as contextual icon because the icon name is defined based on the theme


              this.setAttribute('_context', '');
            } // Inform user about icon name changes


            if (iconName) {
              commons._log('warn', "Coral.Icon: the icon ".concat(iconId, " has been deprecated. Please use ").concat(iconName, " instead."));
            } else {
              commons._log('warn', "Coral.Icon: the icon ".concat(iconId, " has been removed. Please contact Icons@Adobe."));
            }
          } // In most cases, using the capitalized icon name maps to the spectrum icon name
          else {
              iconName = capitalize(iconId);
            } // Verify if icon name is a colored icon


          if (SPECTRUM_COLORED_ICONS_IDENTIFIER.some(function (identifier) {
            return iconName.indexOf(identifier) !== -1;
          })) {
            // Colored icons are 24 by default
            iconId = "spectrum-icon-24-".concat(iconName);
          } else {
            var sizeAttribute = this.getAttribute('size');
            var iconSize = sizeMap[sizeAttribute && sizeAttribute.toUpperCase() || size.SMALL];
            iconId = "spectrum-icon-".concat(iconSize, "-").concat(iconName);
          }
        } // Insert SVG Icon using HTML because DOMly doesn't support document.createElementNS for <use> element


        this.insertAdjacentHTML('beforeend', this.constructor._renderSVG(iconId));
        this._elements.svg = this.lastElementChild;
      }
      /**
       Updates the aria-label or img alt attribute depending on value of alt, title, icon and autoAriaLabel.
        In cases where the alt attribute has been removed or set to an empty string,
       for example, when the alt property is undefined and we add the attribute alt=''
       to explicitly override the default behavior, or when we remove an alt attribute
       thus restoring the default behavior, we make sure to update the alt text.
       @private
       */

    }, {
      key: "_updateAltText",
      value: function _updateAltText(value) {
        var hasAutoAriaLabel = this.autoAriaLabel === autoAriaLabel.ON;
        var img = this._elements.image;
        var isImage = this.contains(img); // alt should be prioritized over title

        var altText = typeof this.alt === 'string' ? this.alt : this.title;

        if (typeof value === 'string') {
          altText = this.alt || value;
        } else if (isImage) {
          altText = altText || img.getAttribute('alt') || img.getAttribute('title') || '';
        } else if (hasAutoAriaLabel) {
          var iconName = this.icon.replace(SPECTRUM_ICONS_IDENTIFIER_REGEX, '');
          iconName = iconName.replace(ICONS_VARIANT_POSTFIX_REGEX, '');
          altText = i18n.get(iconName.replace(SPLIT_CAMELCASE_REGEX, '$1 $2').toLowerCase(), ICON_ALT_TRANSLATION_HINT);
        } // If no other role has been set, provide the appropriate
        // role depending on whether or not the icon is an arbitrary image URL.


        var role = this.getAttribute('role');
        var roleOverride = role && role !== 'presentation' && role !== 'img';

        if (!roleOverride) {
          this.setAttribute('role', isImage ? 'presentation' : 'img');
        } // Set accessibility attributes accordingly


        if (isImage) {
          hasAutoAriaLabel && this.removeAttribute('aria-label');
          img.setAttribute('alt', altText);
        } else if (altText === '') {
          this.removeAttribute('aria-label');

          if (!roleOverride) {
            this.removeAttribute('role');
          }
        } else if (altText) {
          this.setAttribute('aria-label', altText);
        }
      }
      /**
       Whether SVG icons are referenced as external resource (on/off)
        @return {String}
       */

    }, {
      key: "attributeChangedCallback",

      /** @ignore */
      value: function attributeChangedCallback(name, oldValue, value) {
        if (name === 'alt' || name === 'title') {
          this._updateAltText(value);
        } else {
          _get(_getPrototypeOf(_class.prototype), "attributeChangedCallback", this).call(this, name, oldValue, value);
        }
      }
      /** @ignore */

    }, {
      key: "connectedCallback",
      value: function connectedCallback() {
        _get(_getPrototypeOf(_class.prototype), "connectedCallback", this).call(this); // Contextual icons need to be checked again


        if (this.hasAttribute('_context')) {
          this.icon = this.icon;
        }
      }
      /** @ignore */

    }, {
      key: "render",
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1); // Set default size

        if (!this._size) {
          this.size = size.SMALL;
        }

        var img = this.querySelector("img:not(.".concat(CLASSNAME$1, "--image)"));

        if (img) {
          this._elements.image = img;
          this._hasRawImage = true;
          this.icon = img.getAttribute('src');
          this._hasRawImage = false;
        }
      }
    }, {
      key: "autoAriaLabel",
      get: function get() {
        return this._autoAriaLabel || autoAriaLabel.OFF;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        value = validate.enumeration(autoAriaLabel)(value) && value || autoAriaLabel.OFF;

        if (validate.valueMustChange(this._autoAriaLabel, value)) {
          this._autoAriaLabel = value;

          this._updateAltText();
        }
      }
      /**
       Icon name.
        @type {String}
       @default ""
       @htmlattribute icon
       @htmlattributereflected
       */

    }, {
      key: "icon",
      get: function get() {
        return this._icon || '';
      },
      set: function set(value) {
        var _this2 = this;

        var icon = transform.string(value).trim(); // Avoid rendering the same icon

        if (icon !== this._icon || this.hasAttribute('_context')) {
          this._icon = icon;

          this._reflectAttribute('icon', this._icon); // Ignore unresolved templates


          if (this._icon.match(TEMPLATE_REGEX)) {
            return;
          } // Use the existing img


          if (this._hasRawImage) {
            this._elements.image.classList.add(CLASSNAME$1, "".concat(CLASSNAME$1, "--image"));

            this._updateAltText();

            return;
          } // Remove image and SVG elements


          ['image', 'svg'].forEach(function (type) {
            var el = _this2._elements[type] || _this2.querySelector(".".concat(CLASSNAME$1, "--").concat(type));

            if (el) {
              el.remove();
            }
          }); // Sets the desired icon

          if (this._icon) {
            // Detect if it's a URL
            if (this._icon.match(URL_REGEX)) {
              // Create an image and add it to the icon
              this._elements.image = this._elements.image || document.createElement('img');
              this._elements.image.className = "".concat(CLASSNAME$1, " ").concat(CLASSNAME$1, "--image");
              this._elements.image.src = this.icon;
              this.appendChild(this._elements.image);
            } else {
              this._updateIcon();
            }
          }

          this._updateAltText();
        }
      }
      /**
       Size of the icon. It accepts both lower and upper case sizes. See {@link IconSizeEnum}.
        @type {String}
       @default IconSizeEnum.SMALL
       @htmlattribute size
       @htmlattributereflected
       */

    }, {
      key: "size",
      get: function get() {
        return this._size || size.SMALL;
      },
      set: function set(value) {
        var oldSize = this._size;
        value = transform.string(value).toUpperCase();
        value = validate.enumeration(size)(value) && value || size.SMALL;

        this._reflectAttribute('size', value);

        if (validate.valueMustChange(this._size, value)) {
          var _this$classList;

          this._size = value; // removes all the existing sizes

          (_this$classList = this.classList).remove.apply(_this$classList, ALL_SIZE_CLASSES); // adds the new size


          this.classList.add("".concat(CLASSNAME$1, "--size").concat(value)); // We need to update the icon if the size changed

          if (oldSize && oldSize !== value && this.contains(this._elements.svg)) {
            this._elements.svg.remove();

            this._updateIcon();
          }

          this._updateAltText();
        }
      }
      /** @private */

    }, {
      key: "title",
      get: function get() {
        return this.getAttribute('title');
      },
      set: function set(value) {
        this.setAttribute('title', value);
      }
      /** @private */

    }, {
      key: "alt",
      get: function get() {
        return this.getAttribute('alt');
      },
      set: function set(value) {
        this.setAttribute('alt', value);
      }
    }], [{
      key: "_iconsExternal",
      value: function _iconsExternal() {
        return iconsExternal;
      }
      /**
       Returns the SVG markup.
        @param {String} iconId
       @param {Array.<String>} additionalClasses
       @return {String}
       */

    }, {
      key: "_renderSVG",
      value: function _renderSVG(iconId) {
        var additionalClasses = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
        additionalClasses.unshift(CLASSNAME$1);
        additionalClasses.unshift("".concat(CLASSNAME$1, "--svg"));
        var iconPath = "#".concat(iconId); // If not colored icons

        if (this._iconsExternal() === 'on' && !SPECTRUM_COLORED_ICONS_IDENTIFIER.some(function (identifier) {
          return iconId.indexOf(identifier) !== -1;
        })) {
          // Generate spectrum-css-icons path
          if (iconId.indexOf('spectrum-css') === 0) {
            iconPath = resourcesPath ? "".concat(resourcesPath).concat(SPECTRUM_CSS_ICONS, ".svg#").concat(iconId) : "".concat(resolveIconsPath(SPECTRUM_CSS_ICONS_PATH), "#").concat(iconId);
          } // Generate spectrum-icons path
          else {
              iconPath = resourcesPath ? "".concat(resourcesPath).concat(SPECTRUM_ICONS, ".svg#").concat(iconId) : "".concat(resolveIconsPath(SPECTRUM_ICONS_PATH), "#").concat(iconId);
            }
        }

        return "\n      <svg focusable=\"false\" aria-hidden=\"true\" class=\"".concat(additionalClasses.join(' '), "\">\n        <use xlink:href=\"").concat(iconPath, "\"></use>\n      </svg>\n    ");
      }
      /**
       Returns {@link Icon} sizes.
        @return {IconSizeEnum}
       */

    }, {
      key: "load",

      /**
       Loads the SVG icons. It's requesting the icons based on the JS file path by default.
        @param {String} [url] SVG icons url.
       */
      value: function load(url) {
        var resolveIconsPath = function resolveIconsPath(iconsPath) {
          var path = commons._script.src;

          if (iconsExternal === 'js') {
            iconsPath = iconsPath.replace('.svg', '.js');
          }

          return "".concat(path.split('/').slice(0, -iconsPath.split('/').length).join('/'), "/").concat(iconsPath);
        };

        if (url === SPECTRUM_ICONS) {
          url = resolveIconsPath(SPECTRUM_ICONS_PATH);
        } else if (url === SPECTRUM_ICONS_COLOR) {
          url = resolveIconsPath(SPECTRUM_ICONS_COLOR_PATH);
        } else if (url === SPECTRUM_CSS_ICONS) {
          url = resolveIconsPath(SPECTRUM_CSS_ICONS_PATH);
        }

        loadIcons(url);
      }
    }, {
      key: "size",
      get: function get() {
        return size;
      }
      /**
       Returns {@link Icon} autoAriaLabel options.
        @return {IconAutoAriaLabelEnum}
       */

    }, {
      key: "autoAriaLabel",
      get: function get() {
        return autoAriaLabel;
      }
    }, {
      key: "_attributePropertyMap",
      get: function get() {
        return commons.extend(_get(_getPrototypeOf(_class), "_attributePropertyMap", this), {
          autoarialabel: 'autoAriaLabel'
        });
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['autoarialabel', 'icon', 'size', 'alt', 'title']);
      }
    }]);

    return _class;
  }(BaseComponent(HTMLElement))); // Load icon collections by default

  var iconCollections = [SPECTRUM_ICONS_COLOR];
  var extension = '.svg';

  if (Icon._iconsExternal() === 'off' || Icon._iconsExternal() === 'js') {
    iconCollections.push(SPECTRUM_CSS_ICONS);
    iconCollections.push(SPECTRUM_ICONS);

    if (Icon._iconsExternal() === 'js') {
      extension = '.js';
    }
  }

  iconCollections.forEach(function (iconSet) {
    return Icon.load(resourcesPath ? "".concat(resourcesPath).concat(iconSet).concat(extension) : iconSet);
  });

  /**
   * Copyright 2020 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var translations = {
    "en-US": {
      "123/[translation hint:default icon alt text]": "123",
      "alert/[translation hint:default icon alt text]": "Alert",
      "arrow down/[translation hint:default icon alt text]": "Arrow Down",
      "arrow left/[translation hint:default icon alt text]": "Arrow Left",
      "arrow up/[translation hint:default icon alt text]": "Arrow Up",
      "asterisk/[translation hint:default icon alt text]": "Asterisk",
      "checkmark/[translation hint:default icon alt text]": "Checkmark",
      "chevron down/[translation hint:default icon alt text]": "Expand",
      "chevron left/[translation hint:default icon alt text]": "Back",
      "chevron right/[translation hint:default icon alt text]": "Expand",
      "chevron up/[translation hint:default icon alt text]": "Collapse",
      "corner triangle/[translation hint:default icon alt text]": "Expand",
      "cross/[translation hint:default icon alt text]": "Close",
      "dash/[translation hint:default icon alt text]": "Dash",
      "double gripper/[translation hint:default icon alt text]": "Double Gripper",
      "help/[translation hint:default icon alt text]": "Help",
      "info/[translation hint:default icon alt text]": "Info",
      "magnifier/[translation hint:default icon alt text]": "Magnifier",
      "skip left/[translation hint:default icon alt text]": "Skip Left",
      "skip right/[translation hint:default icon alt text]": "Skip Right",
      "star/[translation hint:default icon alt text]": "Star",
      "success/[translation hint:default icon alt text]": "Success",
      "triple gripper/[translation hint:default icon alt text]": "Triple Gripper",
      "3dmaterials/[translation hint:default icon alt text]": "3D Materials",
      "abc/[translation hint:default icon alt text]": "ABC",
      "actions/[translation hint:default icon alt text]": "Actions",
      "ad display/[translation hint:default icon alt text]": "Ad Display",
      "ad print/[translation hint:default icon alt text]": "Ad Print",
      "add/[translation hint:default icon alt text]": "Add",
      "add circle/[translation hint:default icon alt text]": "Add",
      "add to/[translation hint:default icon alt text]": "Add To",
      "add to selection/[translation hint:default icon alt text]": "Add To Selection",
      "adobe advertising cloud/[translation hint:default icon alt text]": "Adobe Advertising Cloud",
      "adobe analytics/[translation hint:default icon alt text]": "Adobe Analytics",
      "adobe analytics cloud/[translation hint:default icon alt text]": "Adobe Analytics Cloud",
      "adobe audience manager/[translation hint:default icon alt text]": "Adobe Audience Manager",
      "adobe campaign/[translation hint:default icon alt text]": "Adobe Campaign",
      "adobe connect/[translation hint:default icon alt text]": "Adobe Connect",
      "adobe document cloud/[translation hint:default icon alt text]": "Adobe Document Cloud",
      "adobe experience cloud/[translation hint:default icon alt text]": "Adobe Experience Cloud",
      "adobe experience manager/[translation hint:default icon alt text]": "Adobe Experience Manager",
      "adobe logo/[translation hint:default icon alt text]": "Adobe Logo",
      "adobe marketing cloud/[translation hint:default icon alt text]": "Adobe Marketing Cloud",
      "adobe media optimizer/[translation hint:default icon alt text]": "Adobe Media Optimizer",
      "adobe primetime/[translation hint:default icon alt text]": "Adobe Primetime",
      "adobe send now/[translation hint:default icon alt text]": "Adobe Send Now",
      "adobe sign/[translation hint:default icon alt text]": "Adobe Sign",
      "adobe social/[translation hint:default icon alt text]": "Adobe Social",
      "adobe target/[translation hint:default icon alt text]": "Adobe Target",
      "after effects/[translation hint:default icon alt text]": "After Effects",
      "alert add/[translation hint:default icon alt text]": "Alert Add",
      "alert check/[translation hint:default icon alt text]": "Alert Check",
      "alert circle/[translation hint:default icon alt text]": "Alert",
      "alias/[translation hint:default icon alt text]": "Alias",
      "align bottom/[translation hint:default icon alt text]": "Align Bottom",
      "align center/[translation hint:default icon alt text]": "Align Center",
      "align left/[translation hint:default icon alt text]": "Align Left",
      "align middle/[translation hint:default icon alt text]": "Align Middle",
      "align right/[translation hint:default icon alt text]": "Align Right",
      "align top/[translation hint:default icon alt text]": "Align Top",
      "amazon web services/[translation hint:default icon alt text]": "Amazon Web Services",
      "anchor/[translation hint:default icon alt text]": "Anchor",
      "anchor select/[translation hint:default icon alt text]": "Select Anchor",
      "android/[translation hint:default icon alt text]": "Android",
      "annotate/[translation hint:default icon alt text]": "Annotate",
      "annotate pen/[translation hint:default icon alt text]": "Annotate Pen",
      "answer/[translation hint:default icon alt text]": "Answer",
      "answer favorite/[translation hint:default icon alt text]": "Favorite Answer",
      "app/[translation hint:default icon alt text]": "App",
      "app refresh/[translation hint:default icon alt text]": "App Refresh",
      "apple/[translation hint:default icon alt text]": "Apple",
      "apple files/[translation hint:default icon alt text]": "Apple Files",
      "approve reject/[translation hint:default icon alt text]": "Approve Reject",
      "apps/[translation hint:default icon alt text]": "Apps",
      "archive/[translation hint:default icon alt text]": "Archive",
      "archive remove/[translation hint:default icon alt text]": "Remove Archive",
      "arrow right/[translation hint:default icon alt text]": "Arrow Right",
      "arrow up right/[translation hint:default icon alt text]": "Arrow Up Right",
      "artboard/[translation hint:default icon alt text]": "Artboard",
      "article/[translation hint:default icon alt text]": "Article",
      "asset/[translation hint:default icon alt text]": "Asset",
      "asset check/[translation hint:default icon alt text]": "Asset Check",
      "assets added/[translation hint:default icon alt text]": "Assets Added",
      "assets downloaded/[translation hint:default icon alt text]": "Assets Downloaded",
      "assets expired/[translation hint:default icon alt text]": "Assets Expired",
      "assets linked published/[translation hint:default icon alt text]": "Assets Linked Published",
      "assets modified/[translation hint:default icon alt text]": "Assets Modified",
      "assets published/[translation hint:default icon alt text]": "Assets Published",
      "at/[translation hint:default icon alt text]": "At",
      "attach/[translation hint:default icon alt text]": "Attach",
      "attachment exclude/[translation hint:default icon alt text]": "Attachment Exclude",
      "attributes/[translation hint:default icon alt text]": "Attributes",
      "audio/[translation hint:default icon alt text]": "Audio",
      "automated segment/[translation hint:default icon alt text]": "Automated Segment",
      "back/[translation hint:default icon alt text]": "Back",
      "back 30seconds/[translation hint:default icon alt text]": "Back 30 Seconds",
      "back android/[translation hint:default icon alt text]": "Back Android",
      "beaker/[translation hint:default icon alt text]": "Beaker",
      "beaker check/[translation hint:default icon alt text]": "Beaker Check",
      "beaker share/[translation hint:default icon alt text]": "Beaker Share",
      "behance/[translation hint:default icon alt text]": "Behance",
      "bell/[translation hint:default icon alt text]": "Bell",
      "bid rule/[translation hint:default icon alt text]": "Bid Rule",
      "bid rule add/[translation hint:default icon alt text]": "Bid Rule Add",
      "bitly/[translation hint:default icon alt text]": "Bitly",
      "blackberry/[translation hint:default icon alt text]": "Blackberry",
      "blog/[translation hint:default icon alt text]": "Blog",
      "blower/[translation hint:default icon alt text]": "Blower",
      "blur/[translation hint:default icon alt text]": "Blur",
      "book/[translation hint:default icon alt text]": "Book",
      "bookmark/[translation hint:default icon alt text]": "Bookmark",
      "boolean/[translation hint:default icon alt text]": "Boolean",
      "border/[translation hint:default icon alt text]": "Border",
      "box/[translation hint:default icon alt text]": "Box",
      "box add/[translation hint:default icon alt text]": "Box Add",
      "box export/[translation hint:default icon alt text]": "Box Export",
      "box import/[translation hint:default icon alt text]": "Box Import",
      "brackets/[translation hint:default icon alt text]": "Brackets",
      "brackets square/[translation hint:default icon alt text]": "Brackets Square",
      "branch 1/[translation hint:default icon alt text]": "Branch 1",
      "branch 2/[translation hint:default icon alt text]": "Branch 2",
      "branch 3/[translation hint:default icon alt text]": "Branch 3",
      "branch circle/[translation hint:default icon alt text]": "Branch",
      "breadcrumb navigation/[translation hint:default icon alt text]": "Breadcrumb Navigation",
      "breakdown/[translation hint:default icon alt text]": "Breakdown",
      "breakdown add/[translation hint:default icon alt text]": "Breakdown Add",
      "briefcase/[translation hint:default icon alt text]": "Briefcase",
      "browse/[translation hint:default icon alt text]": "Browse",
      "brush/[translation hint:default icon alt text]": "Brush",
      "bug/[translation hint:default icon alt text]": "Bug",
      "building/[translation hint:default icon alt text]": "Building",
      "bulk edit users/[translation hint:default icon alt text]": "Bulk Edit Users",
      "button/[translation hint:default icon alt text]": "Button",
      "cclibrary/[translation hint:default icon alt text]": "CC Library",
      "calculator/[translation hint:default icon alt text]": "Calculator",
      "calendar/[translation hint:default icon alt text]": "Calendar",
      "calendar add/[translation hint:default icon alt text]": "Calendar Add",
      "calendar locked/[translation hint:default icon alt text]": "Calendar Locked",
      "calendar unlocked/[translation hint:default icon alt text]": "Calendar Unlocked",
      "call center/[translation hint:default icon alt text]": "Call Center",
      "camera/[translation hint:default icon alt text]": "Camera",
      "camera flip/[translation hint:default icon alt text]": "Camera Flip",
      "camera refresh/[translation hint:default icon alt text]": "Camera Refresh",
      "campaign/[translation hint:default icon alt text]": "Campaign",
      "campaign add/[translation hint:default icon alt text]": "Campaign Add",
      "campaign close/[translation hint:default icon alt text]": "Campaign Close",
      "campaign delete/[translation hint:default icon alt text]": "Campaign Delete",
      "campaign edit/[translation hint:default icon alt text]": "Campaign Edit",
      "cancel/[translation hint:default icon alt text]": "Cancel",
      "capitals/[translation hint:default icon alt text]": "Capitals",
      "captcha/[translation hint:default icon alt text]": "Captcha",
      "card/[translation hint:default icon alt text]": "Card",
      "channel/[translation hint:default icon alt text]": "Channel",
      "chat/[translation hint:default icon alt text]": "Chat",
      "chat add/[translation hint:default icon alt text]": "Chat Add",
      "check pause/[translation hint:default icon alt text]": "Check Pause",
      "checkmark circle/[translation hint:default icon alt text]": "Checkmark",
      "chevron double left/[translation hint:default icon alt text]": "Back",
      "chevron double right/[translation hint:default icon alt text]": "Forward",
      "chevron up down/[translation hint:default icon alt text]": "Sortable",
      "chrome/[translation hint:default icon alt text]": "Chrome",
      "circle/[translation hint:default icon alt text]": "Circle",
      "classic grid view/[translation hint:default icon alt text]": "Classic Grid View",
      "clock/[translation hint:default icon alt text]": "Clock",
      "clock check/[translation hint:default icon alt text]": "Clock Check",
      "clone stamp/[translation hint:default icon alt text]": "Clone Stamp",
      "close/[translation hint:default icon alt text]": "Close",
      "close captions/[translation hint:default icon alt text]": "Close Captions",
      "close circle/[translation hint:default icon alt text]": "Close",
      "cloud/[translation hint:default icon alt text]": "Cloud",
      "cloud disconnected/[translation hint:default icon alt text]": "Cloud Disconnected",
      "cloud error/[translation hint:default icon alt text]": "Cloud Error",
      "code/[translation hint:default icon alt text]": "Code",
      "collection/[translation hint:default icon alt text]": "Collection",
      "collection add/[translation hint:default icon alt text]": "Collection Add",
      "collection add to/[translation hint:default icon alt text]": "Collection Add To",
      "collection check/[translation hint:default icon alt text]": "Collection Check",
      "collection edit/[translation hint:default icon alt text]": "Collection Edit",
      "collection exclude/[translation hint:default icon alt text]": "Collection Exclude",
      "collection link/[translation hint:default icon alt text]": "Collection Link",
      "color fill/[translation hint:default icon alt text]": "Color Fill",
      "color palette/[translation hint:default icon alt text]": "Color Palette",
      "color wheel/[translation hint:default icon alt text]": "Color Wheel",
      "column settings/[translation hint:default icon alt text]": "Column Settings",
      "column two a/[translation hint:default icon alt text]": "Column Two A",
      "column two b/[translation hint:default icon alt text]": "Column Two B",
      "column two c/[translation hint:default icon alt text]": "Column Two C",
      "comment/[translation hint:default icon alt text]": "Comment",
      "compare/[translation hint:default icon alt text]": "Compare",
      "compass/[translation hint:default icon alt text]": "Compass",
      "condition/[translation hint:default icon alt text]": "Condition",
      "confidence four/[translation hint:default icon alt text]": "Confidence Four",
      "confidence one/[translation hint:default icon alt text]": "Confidence One",
      "confidence three/[translation hint:default icon alt text]": "Confidence Three",
      "confidence two/[translation hint:default icon alt text]": "Confidence Two",
      "contrast/[translation hint:default icon alt text]": "Contrast",
      "conversion funnel/[translation hint:default icon alt text]": "Conversion Funnel",
      "copy/[translation hint:default icon alt text]": "Copy",
      "cover image/[translation hint:default icon alt text]": "Cover Image",
      "creative cloud/[translation hint:default icon alt text]": "Creative Cloud",
      "credit card/[translation hint:default icon alt text]": "Credit Card",
      "crop/[translation hint:default icon alt text]": "Crop",
      "crop lightning/[translation hint:default icon alt text]": "Crop Lightning",
      "crop rotate/[translation hint:default icon alt text]": "Crop Rotate",
      "crosshairs/[translation hint:default icon alt text]": "Crosshairs",
      "curate/[translation hint:default icon alt text]": "Curate",
      "cut/[translation hint:default icon alt text]": "Cut",
      "dps/[translation hint:default icon alt text]": "DPS",
      "dashboard/[translation hint:default icon alt text]": "Dashboard",
      "data/[translation hint:default icon alt text]": "Data",
      "data add/[translation hint:default icon alt text]": "Data Add",
      "data adobe/[translation hint:default icon alt text]": "Data Adobe",
      "data book/[translation hint:default icon alt text]": "Data Book",
      "data check/[translation hint:default icon alt text]": "Data Check",
      "data correlated/[translation hint:default icon alt text]": "Data Correlated",
      "data download/[translation hint:default icon alt text]": "Data Download",
      "data edit/[translation hint:default icon alt text]": "Data Edit",
      "data mapping/[translation hint:default icon alt text]": "Data Mapping",
      "data refresh/[translation hint:default icon alt text]": "Data Refresh",
      "data remove/[translation hint:default icon alt text]": "Data Remove",
      "data settings/[translation hint:default icon alt text]": "Data Settings",
      "data unavailable/[translation hint:default icon alt text]": "Data Unavailable",
      "data upload/[translation hint:default icon alt text]": "Data Upload",
      "data user/[translation hint:default icon alt text]": "Data User",
      "date/[translation hint:default icon alt text]": "Date",
      "date input/[translation hint:default icon alt text]": "Date Input",
      "deduplication/[translation hint:default icon alt text]": "Deduplication",
      "delegate/[translation hint:default icon alt text]": "Delegate",
      "delete/[translation hint:default icon alt text]": "Delete",
      "delivery fusion/[translation hint:default icon alt text]": "Delivery Fusion",
      "demographic/[translation hint:default icon alt text]": "Demographic",
      "deselect/[translation hint:default icon alt text]": "Deselect",
      "deselect circular/[translation hint:default icon alt text]": "Deselect",
      "desktop and mobile/[translation hint:default icon alt text]": "Desktop And Mobile",
      "device desktop/[translation hint:default icon alt text]": "Device Desktop",
      "device laptop/[translation hint:default icon alt text]": "Device Laptop",
      "device phone/[translation hint:default icon alt text]": "Device Phone",
      "device phone refresh/[translation hint:default icon alt text]": "Device Phone Refresh",
      "device preview/[translation hint:default icon alt text]": "Device Preview",
      "device rotate landscape/[translation hint:default icon alt text]": "Device Rotate Landscape",
      "device rotate portrait/[translation hint:default icon alt text]": "Device Rotate Portrait",
      "device tv/[translation hint:default icon alt text]": "Device TV",
      "device tablet/[translation hint:default icon alt text]": "Device Tablet",
      "devices/[translation hint:default icon alt text]": "Devices",
      "dimension/[translation hint:default icon alt text]": "Dimension",
      "disqus/[translation hint:default icon alt text]": "Disqus",
      "distribute bottom edge/[translation hint:default icon alt text]": "Distribute Bottom Edge",
      "distribute horizontal center/[translation hint:default icon alt text]": "Distribute Horizontal Center",
      "distribute horizontally/[translation hint:default icon alt text]": "Distribute Horizontally",
      "distribute left edge/[translation hint:default icon alt text]": "Distribute Left Edge",
      "distribute right edge/[translation hint:default icon alt text]": "Distribute Right Edge",
      "distribute space horiz/[translation hint:default icon alt text]": "Distribute Space Horizontally",
      "distribute space vert/[translation hint:default icon alt text]": "Distribute Space Vertically",
      "distribute top edge/[translation hint:default icon alt text]": "Distribute Top Edge",
      "distribute vertical center/[translation hint:default icon alt text]": "Distribute Vertical Center",
      "distribute vertically/[translation hint:default icon alt text]": "Distribute Vertically",
      "divide/[translation hint:default icon alt text]": "Divide",
      "divide path/[translation hint:default icon alt text]": "Divide Path",
      "document/[translation hint:default icon alt text]": "Document",
      "document fragment/[translation hint:default icon alt text]": "Document Fragment",
      "document fragment group/[translation hint:default icon alt text]": "Document Fragment Group",
      "document refresh/[translation hint:default icon alt text]": "Document Refresh",
      "dolly/[translation hint:default icon alt text]": "Dolly",
      "download/[translation hint:default icon alt text]": "Download",
      "download from cloud/[translation hint:default icon alt text]": "Download From Cloud",
      "draft/[translation hint:default icon alt text]": "Draft",
      "drag handle/[translation hint:default icon alt text]": "Drag Handle",
      "draw/[translation hint:default icon alt text]": "Draw",
      "dropdown/[translation hint:default icon alt text]": "Dropdown",
      "duplicate/[translation hint:default icon alt text]": "Duplicate",
      "edit/[translation hint:default icon alt text]": "Edit",
      "edit circle/[translation hint:default icon alt text]": "Edit",
      "edit exclude/[translation hint:default icon alt text]": "Edit Exclude",
      "edit in/[translation hint:default icon alt text]": "Edit In",
      "education/[translation hint:default icon alt text]": "Education",
      "effects/[translation hint:default icon alt text]": "Effects",
      "efficient/[translation hint:default icon alt text]": "Efficient",
      "ellipse/[translation hint:default icon alt text]": "Ellipse",
      "email/[translation hint:default icon alt text]": "Email",
      "email cancel/[translation hint:default icon alt text]": "Email Cancel",
      "email check/[translation hint:default icon alt text]": "Email Check",
      "email exclude/[translation hint:default icon alt text]": "Email Exclude",
      "email gear/[translation hint:default icon alt text]": "Email Gear",
      "email key/[translation hint:default icon alt text]": "Email Key",
      "email lightning/[translation hint:default icon alt text]": "Email Lightning",
      "email notification/[translation hint:default icon alt text]": "Email Notification",
      "email refresh/[translation hint:default icon alt text]": "Email Refresh",
      "email schedule/[translation hint:default icon alt text]": "Email Schedule",
      "engagement/[translation hint:default icon alt text]": "Engagement",
      "erase/[translation hint:default icon alt text]": "Erase",
      "event/[translation hint:default icon alt text]": "Event",
      "event exclude/[translation hint:default icon alt text]": "Event Exclude",
      "event share/[translation hint:default icon alt text]": "Event Share",
      "events/[translation hint:default icon alt text]": "Events",
      "exclude overlap/[translation hint:default icon alt text]": "Exclude Overlap",
      "experience/[translation hint:default icon alt text]": "Experience",
      "experience add/[translation hint:default icon alt text]": "Experience Add",
      "experience add to/[translation hint:default icon alt text]": "Experience Add To",
      "experience export/[translation hint:default icon alt text]": "Experience Export",
      "experience import/[translation hint:default icon alt text]": "Experience Import",
      "export/[translation hint:default icon alt text]": "Export",
      "export original/[translation hint:default icon alt text]": "Export Original",
      "exposure/[translation hint:default icon alt text]": "Exposure",
      "extension/[translation hint:default icon alt text]": "Extension",
      "facebook/[translation hint:default icon alt text]": "Facebook",
      "facebook cover image/[translation hint:default icon alt text]": "Facebook Cover Image",
      "fast/[translation hint:default icon alt text]": "Fast",
      "fast forward/[translation hint:default icon alt text]": "Fast Forward",
      "fast forward circle/[translation hint:default icon alt text]": "Fast Forward",
      "feed/[translation hint:default icon alt text]": "Feed",
      "feed add/[translation hint:default icon alt text]": "Feed Add",
      "feed management/[translation hint:default icon alt text]": "Feed Management",
      "feedback/[translation hint:default icon alt text]": "Feedback",
      "file add/[translation hint:default icon alt text]": "File Add",
      "file csv/[translation hint:default icon alt text]": "File CSV",
      "file campaign/[translation hint:default icon alt text]": "File Campaign",
      "file chart/[translation hint:default icon alt text]": "File Chart",
      "file checked out/[translation hint:default icon alt text]": "File Checked Out",
      "file code/[translation hint:default icon alt text]": "File Code",
      "file data/[translation hint:default icon alt text]": "File Data",
      "file email/[translation hint:default icon alt text]": "File Email",
      "file excel/[translation hint:default icon alt text]": "File Excel",
      "file folder/[translation hint:default icon alt text]": "File Folder",
      "file gear/[translation hint:default icon alt text]": "File Gear",
      "file globe/[translation hint:default icon alt text]": "File Globe",
      "file html/[translation hint:default icon alt text]": "File HTML",
      "file important/[translation hint:default icon alt text]": "File Important",
      "file json/[translation hint:default icon alt text]": "File JSON",
      "file key/[translation hint:default icon alt text]": "File Key",
      "file mobile/[translation hint:default icon alt text]": "File Mobile",
      "file pdf/[translation hint:default icon alt text]": "File PDF",
      "file share/[translation hint:default icon alt text]": "File Share",
      "file single web page/[translation hint:default icon alt text]": "File Single Web Page",
      "file space/[translation hint:default icon alt text]": "File Space",
      "file template/[translation hint:default icon alt text]": "File Template",
      "file txt/[translation hint:default icon alt text]": "File Txt",
      "file user/[translation hint:default icon alt text]": "File User",
      "file word/[translation hint:default icon alt text]": "File Word",
      "file workflow/[translation hint:default icon alt text]": "File Workflow",
      "file xml/[translation hint:default icon alt text]": "File XML",
      "file zip/[translation hint:default icon alt text]": "File Zip",
      "filing cabinet/[translation hint:default icon alt text]": "Filing Cabinet",
      "fill sign/[translation hint:default icon alt text]": "Fill Sign",
      "filmroll/[translation hint:default icon alt text]": "Filmroll",
      "filmroll auto add/[translation hint:default icon alt text]": "Filmroll Auto Add",
      "filter/[translation hint:default icon alt text]": "Filter",
      "filter add/[translation hint:default icon alt text]": "Filter Add",
      "filter check/[translation hint:default icon alt text]": "Filter Check",
      "filter delete/[translation hint:default icon alt text]": "Filter Delete",
      "filter edit/[translation hint:default icon alt text]": "Filter Edit",
      "filter heart/[translation hint:default icon alt text]": "Filter Heart",
      "filter remove/[translation hint:default icon alt text]": "Filter Remove",
      "filter star/[translation hint:default icon alt text]": "Filter Star",
      "find and replace/[translation hint:default icon alt text]": "Find And Replace",
      "firefox/[translation hint:default icon alt text]": "Firefox",
      "flag/[translation hint:default icon alt text]": "Flag",
      "flag exclude/[translation hint:default icon alt text]": "Flag Exclude",
      "flash/[translation hint:default icon alt text]": "Flash",
      "flash auto/[translation hint:default icon alt text]": "Flash Auto",
      "flash off/[translation hint:default icon alt text]": "Flash Off",
      "flash on/[translation hint:default icon alt text]": "Flash On",
      "flashlight off/[translation hint:default icon alt text]": "Flashlight Off",
      "flashlight on/[translation hint:default icon alt text]": "Flashlight On",
      "flickr/[translation hint:default icon alt text]": "Flickr",
      "flip horizontal/[translation hint:default icon alt text]": "Flip Horizontal",
      "flip vertical/[translation hint:default icon alt text]": "Flip Vertical",
      "folder/[translation hint:default icon alt text]": "Folder",
      "folder 2/[translation hint:default icon alt text]": "Folder",
      "folder add/[translation hint:default icon alt text]": "Folder Add",
      "folder add to/[translation hint:default icon alt text]": "Folder Add To",
      "folder adobe/[translation hint:default icon alt text]": "Folder Adobe",
      "folder archive/[translation hint:default icon alt text]": "Folder Archive",
      "folder delete/[translation hint:default icon alt text]": "Folder Delete",
      "folder gear/[translation hint:default icon alt text]": "Folder Gear",
      "folder locked/[translation hint:default icon alt text]": "Folder Locked",
      "folder locked adobe/[translation hint:default icon alt text]": "Folder Locked Adobe",
      "folder open/[translation hint:default icon alt text]": "Folder Open",
      "folder remove/[translation hint:default icon alt text]": "Folder Remove",
      "folder search/[translation hint:default icon alt text]": "Folder Search",
      "folder user/[translation hint:default icon alt text]": "Folder User",
      "follow/[translation hint:default icon alt text]": "Follow",
      "follow off/[translation hint:default icon alt text]": "Follow Off",
      "for placement only/[translation hint:default icon alt text]": "For Placement Only",
      "forecast/[translation hint:default icon alt text]": "Forecast",
      "form/[translation hint:default icon alt text]": "Form",
      "forward/[translation hint:default icon alt text]": "Forward",
      "full screen/[translation hint:default icon alt text]": "Full Screen",
      "full screen exit/[translation hint:default icon alt text]": "Full Screen Exit",
      "function/[translation hint:default icon alt text]": "Function",
      "game/[translation hint:default icon alt text]": "Game",
      "gauge 1/[translation hint:default icon alt text]": "Gauge 1",
      "gauge 2/[translation hint:default icon alt text]": "Gauge 2",
      "gauge 3/[translation hint:default icon alt text]": "Gauge 3",
      "gauge 4/[translation hint:default icon alt text]": "Gauge 4",
      "gauge 5/[translation hint:default icon alt text]": "Gauge 5",
      "gears/[translation hint:default icon alt text]": "Gears",
      "gears add/[translation hint:default icon alt text]": "Gears Add",
      "gears delete/[translation hint:default icon alt text]": "Gears Delete",
      "gears edit/[translation hint:default icon alt text]": "Gears Edit",
      "gender female/[translation hint:default icon alt text]": "Gender Female",
      "gender male/[translation hint:default icon alt text]": "Gender Male",
      "gift/[translation hint:default icon alt text]": "Gift",
      "git hub/[translation hint:default icon alt text]": "Git Hub",
      "globe/[translation hint:default icon alt text]": "Globe",
      "globe check/[translation hint:default icon alt text]": "Globe Check",
      "globe clock/[translation hint:default icon alt text]": "Globe Clock",
      "globe enter/[translation hint:default icon alt text]": "Globe Enter",
      "globe exit/[translation hint:default icon alt text]": "Globe Exit",
      "globe grid/[translation hint:default icon alt text]": "Globe Grid",
      "globe remove/[translation hint:default icon alt text]": "Globe Remove",
      "globe search/[translation hint:default icon alt text]": "Globe Search",
      "globe strike/[translation hint:default icon alt text]": "Globe Strike",
      "globe strike clock/[translation hint:default icon alt text]": "Globe Strike Clock",
      "google/[translation hint:default icon alt text]": "Google",
      "google analytics/[translation hint:default icon alt text]": "Google Analytics",
      "google play store/[translation hint:default icon alt text]": "Google Play Store",
      "google plus/[translation hint:default icon alt text]": "Google Plus",
      "google plus 1/[translation hint:default icon alt text]": "Google Plus",
      "gradient/[translation hint:default icon alt text]": "Gradient",
      "graph area/[translation hint:default icon alt text]": "Graph Area",
      "graph area stacked/[translation hint:default icon alt text]": "Graph Area Stacked",
      "graph bar horizontal/[translation hint:default icon alt text]": "Graph Bar Horizontal",
      "graph bar horizontal add/[translation hint:default icon alt text]": "Graph Bar Horizontal Add",
      "graph bar horizontal stacked/[translation hint:default icon alt text]": "Graph Bar Horizontal Stacked",
      "graph bar vertical/[translation hint:default icon alt text]": "Graph Bar Vertical",
      "graph bar vertical add/[translation hint:default icon alt text]": "Graph Bar Vertical Add",
      "graph bar vertical stacked/[translation hint:default icon alt text]": "Graph Bar Vertical Stacked",
      "graph bubble/[translation hint:default icon alt text]": "Graph Bubble",
      "graph bullet/[translation hint:default icon alt text]": "Graph Bullet",
      "graph confidence bands/[translation hint:default icon alt text]": "Graph Confidence Bands",
      "graph donut/[translation hint:default icon alt text]": "Graph Donut",
      "graph donut add/[translation hint:default icon alt text]": "Graph Donut Add",
      "graph gantt/[translation hint:default icon alt text]": "Graph Gantt",
      "graph histogram/[translation hint:default icon alt text]": "Graph Histogram",
      "graph pathing/[translation hint:default icon alt text]": "Graph Pathing",
      "graph pie/[translation hint:default icon alt text]": "Graph Pie",
      "graph profit curve/[translation hint:default icon alt text]": "Graph Profit Curve",
      "graph scatter/[translation hint:default icon alt text]": "Graph Scatter",
      "graph stream/[translation hint:default icon alt text]": "Graph Stream",
      "graph stream ranked/[translation hint:default icon alt text]": "Graph Stream Ranked",
      "graph stream ranked add/[translation hint:default icon alt text]": "Graph Stream Ranked Add",
      "graph sunburst/[translation hint:default icon alt text]": "Graph Sunburst",
      "graph tree/[translation hint:default icon alt text]": "Graph Tree",
      "graph trend/[translation hint:default icon alt text]": "Graph Trend",
      "graph trend add/[translation hint:default icon alt text]": "Graph Trend Add",
      "graph trend alert/[translation hint:default icon alt text]": "Graph Trend Alert",
      "graphic/[translation hint:default icon alt text]": "Graphic",
      "group/[translation hint:default icon alt text]": "Group",
      "html5/[translation hint:default icon alt text]": "HTML5",
      "hammer/[translation hint:default icon alt text]": "Hammer",
      "hand/[translation hint:default icon alt text]": "Hand",
      "hand 0/[translation hint:default icon alt text]": "Hand 0",
      "hand 1/[translation hint:default icon alt text]": "Hand 1",
      "hand 2/[translation hint:default icon alt text]": "Hand 2",
      "hand 3/[translation hint:default icon alt text]": "Hand 3",
      "hand 4/[translation hint:default icon alt text]": "Hand 4",
      "heal/[translation hint:default icon alt text]": "Heal",
      "heart/[translation hint:default icon alt text]": "Heart",
      "histogram/[translation hint:default icon alt text]": "Histogram",
      "history/[translation hint:default icon alt text]": "History",
      "home/[translation hint:default icon alt text]": "Home",
      "homepage/[translation hint:default icon alt text]": "Homepage",
      "illustrator/[translation hint:default icon alt text]": "Illustrator",
      "image/[translation hint:default icon alt text]": "Image",
      "image add/[translation hint:default icon alt text]": "Image Add",
      "image album/[translation hint:default icon alt text]": "Image Album",
      "image auto mode/[translation hint:default icon alt text]": "Image Auto Mode",
      "image carousel/[translation hint:default icon alt text]": "Image Carousel",
      "image check/[translation hint:default icon alt text]": "Image Check",
      "image checked out/[translation hint:default icon alt text]": "Image Checked Out",
      "image map circle/[translation hint:default icon alt text]": "Image Map Circle",
      "image map polygon/[translation hint:default icon alt text]": "Image Map Polygon",
      "image map rectangle/[translation hint:default icon alt text]": "Image Map Rectangle",
      "image next/[translation hint:default icon alt text]": "Image Next",
      "image profile/[translation hint:default icon alt text]": "Image Profile",
      "image search/[translation hint:default icon alt text]": "Image Search",
      "image text/[translation hint:default icon alt text]": "Image Text",
      "images/[translation hint:default icon alt text]": "Images",
      "import/[translation hint:default icon alt text]": "Import",
      "in design/[translation hint:default icon alt text]": "In Design",
      "inbox/[translation hint:default icon alt text]": "Inbox",
      "individual/[translation hint:default icon alt text]": "Individual",
      "instagram/[translation hint:default icon alt text]": "Instagram",
      "internet explorer/[translation hint:default icon alt text]": "Internet Explorer",
      "intersect overlap/[translation hint:default icon alt text]": "Intersect Overlap",
      "invert adj/[translation hint:default icon alt text]": "Invert Adj",
      "journey/[translation hint:default icon alt text]": "Journey",
      "journey action/[translation hint:default icon alt text]": "Journey Action",
      "journey data/[translation hint:default icon alt text]": "Journey Data",
      "journey event/[translation hint:default icon alt text]": "Journey Event",
      "journey event 2/[translation hint:default icon alt text]": "Journey Event",
      "journey reports/[translation hint:default icon alt text]": "Journey Reports",
      "journey voyager/[translation hint:default icon alt text]": "Journey Voyager",
      "jump to top/[translation hint:default icon alt text]": "Jump To Top",
      "key/[translation hint:default icon alt text]": "Key",
      "key clock/[translation hint:default icon alt text]": "Key Clock",
      "key exclude/[translation hint:default icon alt text]": "Key Exclude",
      "keyboard/[translation hint:default icon alt text]": "Keyboard",
      "label/[translation hint:default icon alt text]": "Label",
      "label exclude/[translation hint:default icon alt text]": "Label Exclude",
      "labels/[translation hint:default icon alt text]": "Labels",
      "landscape/[translation hint:default icon alt text]": "Landscape",
      "launch/[translation hint:default icon alt text]": "Launch",
      "layers/[translation hint:default icon alt text]": "Layers",
      "layers backward/[translation hint:default icon alt text]": "Layers Backward",
      "layers bring to front/[translation hint:default icon alt text]": "Layers Bring To Front",
      "layers forward/[translation hint:default icon alt text]": "Layers Forward",
      "layers send to back/[translation hint:default icon alt text]": "Layers Send To Back",
      "lightroom/[translation hint:default icon alt text]": "Lightroom",
      "line/[translation hint:default icon alt text]": "Line",
      "line height/[translation hint:default icon alt text]": "Line Height",
      "linear gradient/[translation hint:default icon alt text]": "Linear Gradient",
      "link/[translation hint:default icon alt text]": "Link",
      "link check/[translation hint:default icon alt text]": "Link Check",
      "link facebook/[translation hint:default icon alt text]": "Link Facebook",
      "link globe/[translation hint:default icon alt text]": "Link Globe",
      "link nav/[translation hint:default icon alt text]": "Link Nav",
      "link off/[translation hint:default icon alt text]": "Link Off",
      "link out/[translation hint:default icon alt text]": "Link Out",
      "link page/[translation hint:default icon alt text]": "Link Page",
      "link user/[translation hint:default icon alt text]": "Link User",
      "linked in/[translation hint:default icon alt text]": "LinkedIn",
      "linux/[translation hint:default icon alt text]": "Linux",
      "location/[translation hint:default icon alt text]": "Location",
      "location based date/[translation hint:default icon alt text]": "Location Based Date",
      "location based event/[translation hint:default icon alt text]": "Location Based Event",
      "location contribution/[translation hint:default icon alt text]": "Location Contribution",
      "lock closed/[translation hint:default icon alt text]": "Lock Closed",
      "lock open/[translation hint:default icon alt text]": "Lock Open",
      "log out/[translation hint:default icon alt text]": "Log Out",
      "login/[translation hint:default icon alt text]": "Login",
      "looks/[translation hint:default icon alt text]": "Looks",
      "loupe view/[translation hint:default icon alt text]": "Loupe View",
      "mbox/[translation hint:default icon alt text]": "MBox",
      "magento commerce/[translation hint:default icon alt text]": "Magento Commerce",
      "magic wand/[translation hint:default icon alt text]": "Magic Wand",
      "magnify/[translation hint:default icon alt text]": "Magnify",
      "mailbox/[translation hint:default icon alt text]": "Mailbox",
      "map view/[translation hint:default icon alt text]": "Map View",
      "margin bottom/[translation hint:default icon alt text]": "Margin Bottom",
      "margin left/[translation hint:default icon alt text]": "Margin Left",
      "margin right/[translation hint:default icon alt text]": "Margin Right",
      "margin top/[translation hint:default icon alt text]": "Margin Top",
      "marketing activities/[translation hint:default icon alt text]": "Marketing Activities",
      "maximize/[translation hint:default icon alt text]": "Maximize",
      "measure/[translation hint:default icon alt text]": "Measure",
      "menu/[translation hint:default icon alt text]": "Menu",
      "merge/[translation hint:default icon alt text]": "Merge",
      "merge layers/[translation hint:default icon alt text]": "Merge Layers",
      "messenger/[translation hint:default icon alt text]": "Messenger",
      "minimize/[translation hint:default icon alt text]": "Minimize",
      "mobile services/[translation hint:default icon alt text]": "Mobile Services",
      "modern grid view/[translation hint:default icon alt text]": "Modern Grid View",
      "money/[translation hint:default icon alt text]": "Money",
      "moon/[translation hint:default icon alt text]": "Moon",
      "more/[translation hint:default icon alt text]": "More",
      "more circle/[translation hint:default icon alt text]": "More",
      "more small list/[translation hint:default icon alt text]": "More Small List",
      "more small list vert/[translation hint:default icon alt text]": "More Small List Vert",
      "more vertical/[translation hint:default icon alt text]": "More Vertical",
      "move/[translation hint:default icon alt text]": "Move",
      "move left right/[translation hint:default icon alt text]": "Move Left or Right",
      "move to/[translation hint:default icon alt text]": "Move To",
      "move up down/[translation hint:default icon alt text]": "Move Up or Down",
      "movie camera/[translation hint:default icon alt text]": "Movie Camera",
      "multiple/[translation hint:default icon alt text]": "Multiple",
      "multiple add/[translation hint:default icon alt text]": "Multiple Add",
      "multiple check/[translation hint:default icon alt text]": "Multiple Check",
      "multiple exclude/[translation hint:default icon alt text]": "Multiple Exclude",
      "muse/[translation hint:default icon alt text]": "Muse",
      "naming order/[translation hint:default icon alt text]": "Naming Order",
      "new item/[translation hint:default icon alt text]": "New Item",
      "news/[translation hint:default icon alt text]": "News",
      "news add/[translation hint:default icon alt text]": "News Add",
      "newsgator/[translation hint:default icon alt text]": "Newsgator",
      "nielsen/[translation hint:default icon alt text]": "Nielsen",
      "no edit/[translation hint:default icon alt text]": "No Edit",
      "note/[translation hint:default icon alt text]": "Note",
      "note add/[translation hint:default icon alt text]": "Note Add",
      "os/[translation hint:default icon alt text]": "OS",
      "offer/[translation hint:default icon alt text]": "Offer",
      "offer delete/[translation hint:default icon alt text]": "Delete Offer",
      "on air/[translation hint:default icon alt text]": "On Air",
      "one drive/[translation hint:default icon alt text]": "One Drive",
      "open in/[translation hint:default icon alt text]": "Open In",
      "open recent/[translation hint:default icon alt text]": "Open Recent",
      "opera/[translation hint:default icon alt text]": "Opera",
      "orbit/[translation hint:default icon alt text]": "Orbit",
      "organisations/[translation hint:default icon alt text]": "Organisations",
      "organize/[translation hint:default icon alt text]": "Organize",
      "outline path/[translation hint:default icon alt text]": "Outline Path",
      "pdfchecked out/[translation hint:default icon alt text]": "PDF Checked Out",
      "padding bottom/[translation hint:default icon alt text]": "Padding Bottom",
      "padding left/[translation hint:default icon alt text]": "Padding Left",
      "padding right/[translation hint:default icon alt text]": "Padding Right",
      "padding top/[translation hint:default icon alt text]": "Padding Top",
      "page break/[translation hint:default icon alt text]": "Page Break",
      "page exclude/[translation hint:default icon alt text]": "Page Exclude",
      "page gear/[translation hint:default icon alt text]": "Page Gear",
      "page rule/[translation hint:default icon alt text]": "Page Rule",
      "page share/[translation hint:default icon alt text]": "Page Share",
      "page tag/[translation hint:default icon alt text]": "Page Tag",
      "pages exclude/[translation hint:default icon alt text]": "Pages Exclude",
      "pan/[translation hint:default icon alt text]": "Pan",
      "panel/[translation hint:default icon alt text]": "Panel",
      "paste/[translation hint:default icon alt text]": "Paste",
      "paste html/[translation hint:default icon alt text]": "Paste HTML",
      "paste list/[translation hint:default icon alt text]": "Paste List",
      "paste text/[translation hint:default icon alt text]": "Paste Text",
      "pattern/[translation hint:default icon alt text]": "Pattern",
      "pause/[translation hint:default icon alt text]": "Pause",
      "pause circle/[translation hint:default icon alt text]": "Pause",
      "pawn/[translation hint:default icon alt text]": "Pawn",
      "pending/[translation hint:default icon alt text]": "Pending",
      "people group/[translation hint:default icon alt text]": "People Group",
      "personalization field/[translation hint:default icon alt text]": "Personalization Field",
      "perspective/[translation hint:default icon alt text]": "Perspective",
      "phone gap/[translation hint:default icon alt text]": "PhoneGap",
      "phone gap builder/[translation hint:default icon alt text]": "PhoneGap Builder",
      "photoshop/[translation hint:default icon alt text]": "Photoshop",
      "pin off/[translation hint:default icon alt text]": "Pin Off",
      "pin on/[translation hint:default icon alt text]": "Pin On",
      "pinterest/[translation hint:default icon alt text]": "Pinterest",
      "pivot/[translation hint:default icon alt text]": "Pivot",
      "platform data mapping/[translation hint:default icon alt text]": "Platform Data Mapping",
      "play/[translation hint:default icon alt text]": "Play",
      "play circle/[translation hint:default icon alt text]": "Play",
      "plug/[translation hint:default icon alt text]": "Plug",
      "polygon/[translation hint:default icon alt text]": "Polygon",
      "polygon select/[translation hint:default icon alt text]": "Polygon Select",
      "pop in/[translation hint:default icon alt text]": "Pop In",
      "portrait/[translation hint:default icon alt text]": "Portrait",
      "premiere pro/[translation hint:default icon alt text]": "Premiere Pro",
      "preset/[translation hint:default icon alt text]": "Preset",
      "preview/[translation hint:default icon alt text]": "Preview",
      "print/[translation hint:default icon alt text]": "Print",
      "print preview/[translation hint:default icon alt text]": "Print Preview",
      "project/[translation hint:default icon alt text]": "Project",
      "project add/[translation hint:default icon alt text]": "Project Add",
      "project edit/[translation hint:default icon alt text]": "Project Edit",
      "project name edit/[translation hint:default icon alt text]": "Project Name Edit",
      "promote/[translation hint:default icon alt text]": "Promote",
      "properties/[translation hint:default icon alt text]": "Properties",
      "properties copy/[translation hint:default icon alt text]": "Properties Copy",
      "public/[translation hint:default icon alt text]": "Public",
      "publish check/[translation hint:default icon alt text]": "Publish Check",
      "publish pending/[translation hint:default icon alt text]": "Publish Pending",
      "publish reject/[translation hint:default icon alt text]": "Publish Reject",
      "publish remove/[translation hint:default icon alt text]": "Publish Remove",
      "publish schedule/[translation hint:default icon alt text]": "Publish Schedule",
      "push notification/[translation hint:default icon alt text]": "Push Notification",
      "question/[translation hint:default icon alt text]": "Question",
      "quick select/[translation hint:default icon alt text]": "Quick Select",
      "rss/[translation hint:default icon alt text]": "RSS",
      "radial gradient/[translation hint:default icon alt text]": "Radial Gradient",
      "rail/[translation hint:default icon alt text]": "Rail",
      "rail bottom/[translation hint:default icon alt text]": "Rail Bottom",
      "rail left/[translation hint:default icon alt text]": "Rail Left",
      "rail right/[translation hint:default icon alt text]": "Rail Right",
      "rail right close/[translation hint:default icon alt text]": "Close Rail Right",
      "rail right open/[translation hint:default icon alt text]": "Open Rail Right",
      "rail top/[translation hint:default icon alt text]": "Rail Top",
      "range mask/[translation hint:default icon alt text]": "Range Mask",
      "rect select/[translation hint:default icon alt text]": "Rect Select",
      "rectangle/[translation hint:default icon alt text]": "Rectangle",
      "redo/[translation hint:default icon alt text]": "Redo",
      "refresh/[translation hint:default icon alt text]": "Refresh",
      "region select/[translation hint:default icon alt text]": "Region Select",
      "relevance/[translation hint:default icon alt text]": "Relevance",
      "remove/[translation hint:default icon alt text]": "Remove",
      "remove circle/[translation hint:default icon alt text]": "Remove",
      "rename/[translation hint:default icon alt text]": "Rename",
      "reorder/[translation hint:default icon alt text]": "Reorder",
      "replay/[translation hint:default icon alt text]": "Replay",
      "replies/[translation hint:default icon alt text]": "Replies",
      "reply/[translation hint:default icon alt text]": "Reply",
      "reply all/[translation hint:default icon alt text]": "Reply All",
      "report/[translation hint:default icon alt text]": "Report",
      "report add/[translation hint:default icon alt text]": "Report Add",
      "resize/[translation hint:default icon alt text]": "Resize",
      "retweet/[translation hint:default icon alt text]": "Retweet",
      "reuse/[translation hint:default icon alt text]": "Reuse",
      "revenue/[translation hint:default icon alt text]": "Revenue",
      "revert/[translation hint:default icon alt text]": "Revert",
      "rewind/[translation hint:default icon alt text]": "Rewind",
      "rewind circle/[translation hint:default icon alt text]": "Rewind",
      "ribbon/[translation hint:default icon alt text]": "Ribbon",
      "rotate ccw/[translation hint:default icon alt text]": "Rotate CCW",
      "rotate ccwbold/[translation hint:default icon alt text]": "Rotate CCW",
      "rotate cw/[translation hint:default icon alt text]": "Rotate CW",
      "rotate cwbold/[translation hint:default icon alt text]": "Rotate CW",
      "rotate left/[translation hint:default icon alt text]": "Rotate Left",
      "rotate right/[translation hint:default icon alt text]": "Rotate Right",
      "sms/[translation hint:default icon alt text]": "SMS",
      "smskey/[translation hint:default icon alt text]": "SMS Key",
      "smslightning/[translation hint:default icon alt text]": "SMS Lightning",
      "smsrefresh/[translation hint:default icon alt text]": "SMS Refresh",
      "sqlquery/[translation hint:default icon alt text]": "SQL Query",
      "safari/[translation hint:default icon alt text]": "Safari",
      "sampler/[translation hint:default icon alt text]": "Sampler",
      "save as floppy/[translation hint:default icon alt text]": "Save As Floppy",
      "save floppy/[translation hint:default icon alt text]": "Save Floppy",
      "save to/[translation hint:default icon alt text]": "Save To",
      "scribble/[translation hint:default icon alt text]": "Scribble",
      "search/[translation hint:default icon alt text]": "Search",
      "seat/[translation hint:default icon alt text]": "Seat",
      "seat add/[translation hint:default icon alt text]": "Seat Add",
      "segments/[translation hint:default icon alt text]": "Segments",
      "select/[translation hint:default icon alt text]": "Select",
      "select add/[translation hint:default icon alt text]": "Select Add",
      "select box/[translation hint:default icon alt text]": "Select Box",
      "select box all/[translation hint:default icon alt text]": "Select Box All",
      "select circular/[translation hint:default icon alt text]": "Select Circular",
      "select container/[translation hint:default icon alt text]": "Select Container",
      "select gear/[translation hint:default icon alt text]": "Select Gear",
      "select intersect/[translation hint:default icon alt text]": "Select Intersect",
      "select substract/[translation hint:default icon alt text]": "Select Substract",
      "selection/[translation hint:default icon alt text]": "Selection",
      "selection checked/[translation hint:default icon alt text]": "Selection Checked",
      "selection move/[translation hint:default icon alt text]": "Selection Move",
      "send/[translation hint:default icon alt text]": "Send",
      "send for signature/[translation hint:default icon alt text]": "Send For Signature",
      "sentiment negative/[translation hint:default icon alt text]": "Sentiment Negative",
      "sentiment neutral/[translation hint:default icon alt text]": "Sentiment Neutral",
      "sentiment positive/[translation hint:default icon alt text]": "Sentiment Positive",
      "separator/[translation hint:default icon alt text]": "Separator",
      "servers/[translation hint:default icon alt text]": "Servers",
      "settings/[translation hint:default icon alt text]": "Settings",
      "shapes/[translation hint:default icon alt text]": "Shapes",
      "share/[translation hint:default icon alt text]": "Share",
      "share android/[translation hint:default icon alt text]": "Share",
      "share check/[translation hint:default icon alt text]": "Share Check",
      "share windows/[translation hint:default icon alt text]": "Share",
      "sharpen/[translation hint:default icon alt text]": "Sharpen",
      "shield/[translation hint:default icon alt text]": "Shield",
      "shopping cart/[translation hint:default icon alt text]": "Shopping Cart",
      "show all layers/[translation hint:default icon alt text]": "Show All Layers",
      "show menu/[translation hint:default icon alt text]": "Show Menu",
      "show one layer/[translation hint:default icon alt text]": "Show One Layer",
      "shuffle/[translation hint:default icon alt text]": "Shuffle",
      "sina weibo/[translation hint:default icon alt text]": "Sina Weibo",
      "slice/[translation hint:default icon alt text]": "Slice",
      "slow/[translation hint:default icon alt text]": "Slow",
      "small caps/[translation hint:default icon alt text]": "Small Caps",
      "snapshot/[translation hint:default icon alt text]": "Snapshot",
      "social network/[translation hint:default icon alt text]": "Social Network",
      "sort order down/[translation hint:default icon alt text]": "Sort Order Down",
      "sort order up/[translation hint:default icon alt text]": "Sort Order Up",
      "spam/[translation hint:default icon alt text]": "Spam",
      "spellcheck/[translation hint:default icon alt text]": "Spellcheck",
      "spin/[translation hint:default icon alt text]": "Spin",
      "split view/[translation hint:default icon alt text]": "Split View",
      "spot heal/[translation hint:default icon alt text]": "Spot Heal",
      "stage/[translation hint:default icon alt text]": "Stage",
      "stamp/[translation hint:default icon alt text]": "Stamp",
      "starburst/[translation hint:default icon alt text]": "Starburst",
      "step backward/[translation hint:default icon alt text]": "Step Backward",
      "step backward circle/[translation hint:default icon alt text]": "Step Backward",
      "step forward/[translation hint:default icon alt text]": "Step Forward",
      "step forward circle/[translation hint:default icon alt text]": "Step Forward",
      "stock/[translation hint:default icon alt text]": "Stock",
      "stop/[translation hint:default icon alt text]": "Stop",
      "stop circle/[translation hint:default icon alt text]": "Stop",
      "stopwatch/[translation hint:default icon alt text]": "Stopwatch",
      "straighten/[translation hint:default icon alt text]": "Straighten",
      "stroke width/[translation hint:default icon alt text]": "Stroke Width",
      "subscribe/[translation hint:default icon alt text]": "Subscribe",
      "substract back path/[translation hint:default icon alt text]": "Substract Back Path",
      "substract from selection/[translation hint:default icon alt text]": "Substract From Selection",
      "subtract front path/[translation hint:default icon alt text]": "Subtract Front Path",
      "success metric/[translation hint:default icon alt text]": "Success Metric",
      "summarize/[translation hint:default icon alt text]": "Summarize",
      "survey/[translation hint:default icon alt text]": "Survey",
      "switch/[translation hint:default icon alt text]": "Switch",
      "sync/[translation hint:default icon alt text]": "Sync",
      "sync remove/[translation hint:default icon alt text]": "Sync Remove",
      "table/[translation hint:default icon alt text]": "Table",
      "table add/[translation hint:default icon alt text]": "Table Add",
      "table and chart/[translation hint:default icon alt text]": "Table And Chart",
      "table column add left/[translation hint:default icon alt text]": "Table Column Add Left",
      "table column add right/[translation hint:default icon alt text]": "Table Column Add Right",
      "table column merge/[translation hint:default icon alt text]": "Table Column Merge",
      "table column remove center/[translation hint:default icon alt text]": "Table Column Remove Center",
      "table column split/[translation hint:default icon alt text]": "Table Column Split",
      "table edit/[translation hint:default icon alt text]": "Table Edit",
      "table histogram/[translation hint:default icon alt text]": "Table Histogram",
      "table merge cells/[translation hint:default icon alt text]": "Table Merge Cells",
      "table row add bottom/[translation hint:default icon alt text]": "Table Row Add Bottom",
      "table row add top/[translation hint:default icon alt text]": "Table Row Add Top",
      "table row merge/[translation hint:default icon alt text]": "Table Row Merge",
      "table row remove center/[translation hint:default icon alt text]": "Table Row Remove Center",
      "table row split/[translation hint:default icon alt text]": "Table Row Split",
      "table select column/[translation hint:default icon alt text]": "Table Select Column",
      "table select row/[translation hint:default icon alt text]": "Table Select Row",
      "tableau/[translation hint:default icon alt text]": "Tableau",
      "tag bold/[translation hint:default icon alt text]": "Tag Bold",
      "tag italic/[translation hint:default icon alt text]": "Tag Italic",
      "tag underline/[translation hint:default icon alt text]": "Tag Underline",
      "target/[translation hint:default icon alt text]": "Target",
      "targeted/[translation hint:default icon alt text]": "Targeted",
      "task list/[translation hint:default icon alt text]": "Task List",
      "teapot/[translation hint:default icon alt text]": "Teapot",
      "temperature/[translation hint:default icon alt text]": "Temperature",
      "test ab/[translation hint:default icon alt text]": "Test AB",
      "test abedit/[translation hint:default icon alt text]": "Test AB Edit",
      "test abgear/[translation hint:default icon alt text]": "Test AB Gear",
      "test abremove/[translation hint:default icon alt text]": "Test AB Remove",
      "test profile/[translation hint:default icon alt text]": "Test Profile",
      "text/[translation hint:default icon alt text]": "Text",
      "text add/[translation hint:default icon alt text]": "Text Add",
      "text align center/[translation hint:default icon alt text]": "Text Align Center",
      "text align justify/[translation hint:default icon alt text]": "Text Align Justify",
      "text align left/[translation hint:default icon alt text]": "Text Align Left",
      "text align right/[translation hint:default icon alt text]": "Text Align Right",
      "text baseline shift/[translation hint:default icon alt text]": "Text Baseline Shift",
      "text bold/[translation hint:default icon alt text]": "Text Bold",
      "text bulleted/[translation hint:default icon alt text]": "Text Bulleted",
      "text bulleted attach/[translation hint:default icon alt text]": "Text Bulleted Attach",
      "text bulleted hierarchy/[translation hint:default icon alt text]": "Text Bulleted Hierarchy",
      "text bulleted hierarchy exclude/[translation hint:default icon alt text]": "Text Bulleted Hierarchy Exclude",
      "text decrease/[translation hint:default icon alt text]": "Text Decrease",
      "text edit/[translation hint:default icon alt text]": "Text Edit",
      "text exclude/[translation hint:default icon alt text]": "Text Exclude",
      "text increase/[translation hint:default icon alt text]": "Text Increase",
      "text indent decrease/[translation hint:default icon alt text]": "Text Indent Decrease",
      "text indent increase/[translation hint:default icon alt text]": "Text Indent Increase",
      "text italic/[translation hint:default icon alt text]": "Text Italic",
      "text kerning/[translation hint:default icon alt text]": "Text Kerning",
      "text lettered lower case/[translation hint:default icon alt text]": "Text Lettered Lower Case",
      "text lettered upper case/[translation hint:default icon alt text]": "Text Lettered Upper Case",
      "text numbered/[translation hint:default icon alt text]": "Text Numbered",
      "text paragraph/[translation hint:default icon alt text]": "Text Paragraph",
      "text roman lowercase/[translation hint:default icon alt text]": "Text Roman Lowercase",
      "text roman uppercase/[translation hint:default icon alt text]": "Text Roman Uppercase",
      "text size/[translation hint:default icon alt text]": "Text Size",
      "text size add/[translation hint:default icon alt text]": "Text Size Add",
      "text space after/[translation hint:default icon alt text]": "Text Space After",
      "text space before/[translation hint:default icon alt text]": "Text Space Before",
      "text strikethrough/[translation hint:default icon alt text]": "Text Strikethrough",
      "text stroke/[translation hint:default icon alt text]": "Text Stroke",
      "text style/[translation hint:default icon alt text]": "Text Style",
      "text subscript/[translation hint:default icon alt text]": "Text Subscript",
      "text superscript/[translation hint:default icon alt text]": "Text Superscript",
      "text tracking/[translation hint:default icon alt text]": "Text Tracking",
      "text underline/[translation hint:default icon alt text]": "Text Underline",
      "thumb down/[translation hint:default icon alt text]": "Thumb Down",
      "thumb up/[translation hint:default icon alt text]": "Thumb Up",
      "tips/[translation hint:default icon alt text]": "Tips",
      "transfer to platform/[translation hint:default icon alt text]": "Transfer To Platform",
      "transparency/[translation hint:default icon alt text]": "Transparency",
      "trap/[translation hint:default icon alt text]": "Trap",
      "tree collapse/[translation hint:default icon alt text]": "Tree Collapse",
      "tree collapse all/[translation hint:default icon alt text]": "Tree Collapse All",
      "tree expand/[translation hint:default icon alt text]": "Tree Expand",
      "tree expand all/[translation hint:default icon alt text]": "Tree Expand All",
      "trend inspect/[translation hint:default icon alt text]": "Trend Inspect",
      "trim path/[translation hint:default icon alt text]": "Trim Path",
      "trophy/[translation hint:default icon alt text]": "Trophy",
      "tumblr/[translation hint:default icon alt text]": "Tumblr",
      "twitter/[translation hint:default icon alt text]": "Twitter",
      "type/[translation hint:default icon alt text]": "Type",
      "usa/[translation hint:default icon alt text]": "USA",
      "underline/[translation hint:default icon alt text]": "Underline",
      "undo/[translation hint:default icon alt text]": "Undo",
      "ungroup/[translation hint:default icon alt text]": "Ungroup",
      "unlink/[translation hint:default icon alt text]": "Unlink",
      "unmerge/[translation hint:default icon alt text]": "Unmerge",
      "upload to cloud/[translation hint:default icon alt text]": "Upload To Cloud",
      "user/[translation hint:default icon alt text]": "User",
      "user activity/[translation hint:default icon alt text]": "User Activity",
      "user add/[translation hint:default icon alt text]": "User Add",
      "user admin/[translation hint:default icon alt text]": "User Admin",
      "user arrow/[translation hint:default icon alt text]": "User Arrow",
      "user checked out/[translation hint:default icon alt text]": "User Checked Out",
      "user edit/[translation hint:default icon alt text]": "User Edit",
      "user exclude/[translation hint:default icon alt text]": "User Exclude",
      "user group/[translation hint:default icon alt text]": "User Group",
      "user lock/[translation hint:default icon alt text]": "User Lock",
      "user share/[translation hint:default icon alt text]": "User Share",
      "users add/[translation hint:default icon alt text]": "Users Add",
      "users exclude/[translation hint:default icon alt text]": "Users Exclude",
      "users lock/[translation hint:default icon alt text]": "Users Lock",
      "users share/[translation hint:default icon alt text]": "Users Share",
      "vk/[translation hint:default icon alt text]": "VK",
      "variable/[translation hint:default icon alt text]": "Variable",
      "vector draw/[translation hint:default icon alt text]": "Vector Draw",
      "video checked out/[translation hint:default icon alt text]": "Video Checked Out",
      "video/[translation hint:default icon alt text]": "Video",
      "view all tags/[translation hint:default icon alt text]": "View All Tags",
      "view bi week/[translation hint:default icon alt text]": "View Bi-Week",
      "view card/[translation hint:default icon alt text]": "View Card",
      "view column/[translation hint:default icon alt text]": "View Column",
      "view day/[translation hint:default icon alt text]": "View Day",
      "view detail/[translation hint:default icon alt text]": "View Detail",
      "view grid/[translation hint:default icon alt text]": "View Grid",
      "view list/[translation hint:default icon alt text]": "View List",
      "view row/[translation hint:default icon alt text]": "View Row",
      "view single/[translation hint:default icon alt text]": "View Single",
      "view stack/[translation hint:default icon alt text]": "View Stack",
      "view week/[translation hint:default icon alt text]": "View Week",
      "viewed mark as/[translation hint:default icon alt text]": "Viewed Mark As",
      "vignette/[translation hint:default icon alt text]": "Vignette",
      "visibility/[translation hint:default icon alt text]": "Visibility",
      "visibility off/[translation hint:default icon alt text]": "Visibility Off",
      "visit/[translation hint:default icon alt text]": "Visit",
      "visit share/[translation hint:default icon alt text]": "Visit Share",
      "voice over/[translation hint:default icon alt text]": "Voice Over",
      "volume mute/[translation hint:default icon alt text]": "Volume Mute",
      "volume one/[translation hint:default icon alt text]": "Volume One",
      "volume three/[translation hint:default icon alt text]": "Volume Three",
      "volume two/[translation hint:default icon alt text]": "Volume Two",
      "watch/[translation hint:default icon alt text]": "Watch",
      "web page/[translation hint:default icon alt text]": "Web Page",
      "web pages/[translation hint:default icon alt text]": "Web Pages",
      "whats app/[translation hint:default icon alt text]": "Whats App",
      "windows 7/[translation hint:default icon alt text]": "Windows 7",
      "windows 8/[translation hint:default icon alt text]": "Windows 8",
      "wordpress/[translation hint:default icon alt text]": "Wordpress",
      "workflow/[translation hint:default icon alt text]": "Workflow",
      "workflow add/[translation hint:default icon alt text]": "Workflow Add",
      "wrench/[translation hint:default icon alt text]": "Wrench",
      "xd/[translation hint:default icon alt text]": "XD",
      "you tube/[translation hint:default icon alt text]": "YouTube",
      "zoom in/[translation hint:default icon alt text]": "Zoom In",
      "zoom out/[translation hint:default icon alt text]": "Zoom Out",
      "adobe experience platform/[translation hint:default icon alt text]": "Adobe Experience Platform",
      "calendar check/[translation hint:default icon alt text]": "Calendar Check",
      "emotion admiration/[translation hint:default icon alt text]": "Emotion: Admiration",
      "emotion anger/[translation hint:default icon alt text]": "Emotion: Anger",
      "emotion anticipation/[translation hint:default icon alt text]": "Emotion: Anticipation",
      "emotion disgust/[translation hint:default icon alt text]": "Emotion: Disgust",
      "emotion fear/[translation hint:default icon alt text]": "Emotion: Fear",
      "emotion joy/[translation hint:default icon alt text]": "Emotion: Joy",
      "emotion sadness/[translation hint:default icon alt text]": "Emotion: Sadness",
      "emotion surprise/[translation hint:default icon alt text]": "Emotion: Surprise",
      "facebook circle/[translation hint:default icon alt text]": "Facebook",
      "google plus circle/[translation hint:default icon alt text]": "Google Plus",
      "instagram circle/[translation hint:default icon alt text]": "Instagram",
      "linked in circle/[translation hint:default icon alt text]": "LinkedIn",
      "mc marketo engage/[translation hint:default icon alt text]": "Marketo Engage",
      "project camera/[translation hint:default icon alt text]": "Project Camera",
      "project play/[translation hint:default icon alt text]": "Project Play",
      "project refresh/[translation hint:default icon alt text]": "Project Refresh",
      "sina weibo circle/[translation hint:default icon alt text]": "Sina Weibo",
      "table cell merge/[translation hint:default icon alt text]": "Table Cell Merge",
      "target check/[translation hint:default icon alt text]": "Target Check",
      "twitter circle/[translation hint:default icon alt text]": "Twitter",
      "user circle/[translation hint:default icon alt text]": "User",
      "user group circle/[translation hint:default icon alt text]": "User Group",
      "windows/[translation hint:default icon alt text]": "Windows",
      "you tube circle/[translation hint:default icon alt text]": "YouTube"
    }
  };

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons.extend(strings, {
    'coral-component-icon': translations
  }); // Expose component on the Coral namespace

  commons._define('coral-icon', Icon);

  /**
   Enumeration for {@link Button}, {@link AnchorButton} icon sizes.

   @typedef {Object} ButtonIconSizeEnum

   @property {String} EXTRA_EXTRA_SMALL
   Extra extra small size icon, typically 9px size.
   @property {String} EXTRA_SMALL
   Extra small size icon, typically 12px size.
   @property {String} SMALL
   Small size icon, typically 18px size. This is the default size.
   @property {String} MEDIUM
   Medium size icon, typically 24px size.
   */

  var iconSize = {};
  var excludedIconSizes = [Icon.size.LARGE, Icon.size.EXTRA_LARGE, Icon.size.EXTRA_EXTRA_LARGE];

  for (var key in Icon.size) {
    // Populate button icon sizes by excluding the largest icon sizes
    if (excludedIconSizes.indexOf(Icon.size[key]) === -1) {
      iconSize[key] = Icon.size[key];
    }
  }
  /**
   Enumeration for {@link Button}, {@link AnchorButton} variants.

   @typedef {Object} ButtonVariantEnum

   @property {String} CTA
   A button that is meant to grab the user's attention.
   @property {String} PRIMARY
   A button that is meant to grab the user's attention.
   @property {String} QUIET
   A quiet button that indicates that the button's action is the primary action.
   @property {String} SECONDARY
   A button that indicates that the button's action is the secondary action.
   @property {String} QUIET_SECONDARY
   A quiet secondary button.
   @property {String} ACTION
   An action button.
   @property {String} QUIET_ACTION
   A quiet action button.
   @property {String} MINIMAL
   A quiet minimalistic button.
   @property {String} WARNING
   A button that indicates that the button's action is dangerous.
   @property {String} QUIET_WARNING
   A quiet warning button,
   @property {String} OVER_BACKGROUND
   A button to be placed on top of colored background.
   @property {String} DEFAULT
   The default button look and feel.
   */


  var variant$1 = {
    CTA: 'cta',
    PRIMARY: 'primary',
    SECONDARY: 'secondary',
    QUIET: 'quiet',
    MINIMAL: 'minimal',
    WARNING: 'warning',
    ACTION: 'action',
    QUIET_ACTION: 'quietaction',
    QUIET_SECONDARY: 'quietsecondary',
    QUIET_WARNING: 'quietwarning',
    OVER_BACKGROUND: 'overbackground',
    DEFAULT: 'default',
    // Private to be used for custom Button classes like field buttons
    _CUSTOM: '_custom'
  }; // the button's base classname

  var CLASSNAME$2 = '_coral-Button';
  var ACTION_CLASSNAME = '_coral-ActionButton';
  var ALL_VARIANT_CLASSES$1 = ["".concat(CLASSNAME$2, "--cta"), "".concat(CLASSNAME$2, "--primary"), "".concat(CLASSNAME$2, "--secondary"), "".concat(CLASSNAME$2, "--warning"), "".concat(CLASSNAME$2, "--quiet"), "".concat(ACTION_CLASSNAME, "--quiet"), "".concat(CLASSNAME$2, "--overBackground")];
  var VARIANT_MAP = {
    cta: [CLASSNAME$2, ALL_VARIANT_CLASSES$1[0]],
    primary: [CLASSNAME$2, ALL_VARIANT_CLASSES$1[0]],
    secondary: [CLASSNAME$2, ALL_VARIANT_CLASSES$1[2]],
    warning: [CLASSNAME$2, ALL_VARIANT_CLASSES$1[3]],
    quiet: [CLASSNAME$2, ALL_VARIANT_CLASSES$1[1], ALL_VARIANT_CLASSES$1[4]],
    minimal: [CLASSNAME$2, ALL_VARIANT_CLASSES$1[2], ALL_VARIANT_CLASSES$1[4]],
    default: [CLASSNAME$2, ALL_VARIANT_CLASSES$1[1]],
    action: [ACTION_CLASSNAME],
    quietaction: [ACTION_CLASSNAME, ALL_VARIANT_CLASSES$1[5]],
    quietsecondary: [CLASSNAME$2, ALL_VARIANT_CLASSES$1[2], ALL_VARIANT_CLASSES$1[4]],
    quietwarning: [CLASSNAME$2, ALL_VARIANT_CLASSES$1[3], ALL_VARIANT_CLASSES$1[4]],
    overbackground: [CLASSNAME$2, ALL_VARIANT_CLASSES$1[6]]
  };
  /**
   Enumeration for {@link BaseButton} sizes.

   @typedef {Object} ButtonSizeEnum

   @property {String} MEDIUM
   A medium button is the default, normal sized button.
   @property {String} LARGE
   Not supported. Falls back to MEDIUM.
   */

  var size$1 = {
    MEDIUM: 'M',
    LARGE: 'L'
  };
  /**
   Enumeration for {@link BaseButton} icon position options.

   @typedef {Object} ButtonIconPositionEnum

   @property {String} RIGHT
   Position should be right of the button label.
   @property {String} LEFT
   Position should be left of the button label.
   */

  var iconPosition = {
    RIGHT: 'right',
    LEFT: 'left'
  };
  /**
   @base BaseButton
   @classdesc The base element for Button components
   */

  var BaseButton = function BaseButton(superClass) {
    return /*#__PURE__*/function (_BaseLabellable) {
      _inherits(_class, _BaseLabellable);

      var _super = _createSuper(_class);

      /** @ignore */
      function _class() {
        var _thisSuper, _this;

        _classCallCheck(this, _class);

        _this = _super.call(this); // Templates

        _this._elements = {
          // Create or fetch the label element
          label: _this.querySelector(_this._contentZoneTagName) || document.createElement(_this._contentZoneTagName),
          icon: _this.querySelector('coral-icon')
        }; // Events

        _this._events = {
          mousedown: '_onMouseDown',
          click: '_onClick'
        };

        _get((_thisSuper = _assertThisInitialized(_this), _getPrototypeOf(_class.prototype)), "_observeLabel", _thisSuper).call(_thisSuper);

        return _this;
      }
      /**
       The label of the button.
       @type {HTMLElement}
       @contentzone
       */


      _createClass(_class, [{
        key: "_onClick",
        value: function _onClick(event) {
          if (!this.disabled) {
            this._trackEvent('click', this.getAttribute('is'), event);
          }
        }
        /** @ignore */

      }, {
        key: "_updateIcon",
        value: function _updateIcon(value) {
          if (!this._updatedIcon && this._elements.icon) {
            return;
          }

          this._updatedIcon = true;
          var iconSizeValue = this.iconSize;
          var iconAutoAriaLabelValue = this.iconAutoAriaLabel;

          var iconElement = this._getIconElement();

          iconElement.icon = value; // Update size as well

          iconElement.size = iconSizeValue; // Update autoAriaLabel as well

          iconElement.autoAriaLabel = iconAutoAriaLabelValue; // removes the icon element from the DOM.

          if (this.icon === '') {
            iconElement.remove();
          } // add or adjust the icon. Add it back since it was blown away by textContent
          else if (!iconElement.parentNode || this._iconPosition) {
              if (this.contains(this.label)) {
                // insertBefore with <code>null</code> appends
                this.insertBefore(iconElement, this.iconPosition === iconPosition.LEFT ? this.label : this.label.nextElementSibling);
              }
            }

          _get(_getPrototypeOf(_class.prototype), "_toggleIconAriaHidden", this).call(this);
        }
        /** @ignore */

      }, {
        key: "_getIconElement",
        value: function _getIconElement() {
          if (!this._elements.icon) {
            this._elements.icon = new Icon();
            this._elements.icon.size = this.iconSize;
          }

          return this._elements.icon;
        }
        /**
         Forces button to receive focus on mousedown
         @param {MouseEvent} event mousedown event
         @ignore
         */

      }, {
        key: "_onMouseDown",
        value: function _onMouseDown(event) {
          var target = event.matchedTarget; // Wait a frame or button won't receive focus in Safari.

          window.requestAnimationFrame(function () {
            if (target !== document.activeElement) {
              target.focus();
            }
          });
        }
      }, {
        key: "_updateLabel",
        value: function _updateLabel(label) {
          label = label || this._elements.label;
          label.classList.remove("".concat(CLASSNAME$2, "-label"), "".concat(ACTION_CLASSNAME, "-label"));

          if (this._variant !== variant$1._CUSTOM) {
            if (this._variant === variant$1.ACTION || this._variant === variant$1.QUIET_ACTION) {
              label.classList.add("".concat(ACTION_CLASSNAME, "-label"));
            } else {
              label.classList.add("".concat(CLASSNAME$2, "-label"));
            }
          }
        }
        /** @private */

      }, {
        key: "render",

        /** @ignore */
        value: function render() {
          _get(_getPrototypeOf(_class.prototype), "render", this).call(this); // Default reflected attributes


          if (!this._variant) {
            this.variant = variant$1.DEFAULT;
          }

          if (!this._size) {
            this.size = size$1.MEDIUM;
          } // Create a fragment


          var fragment = document.createDocumentFragment();
          var label = this._elements.label;
          var contentZoneProvided = label.parentNode; // Remove it so we can process children

          if (contentZoneProvided) {
            this.removeChild(label);
          }

          var iconAdded = false; // Process remaining elements as necessary

          while (this.firstChild) {
            var child = this.firstChild;

            if (child.nodeName === 'CORAL-ICON') {
              // Don't add duplicated icons
              if (iconAdded) {
                this.removeChild(child);
              } else {
                // Conserve existing icon element to content
                this._elements.icon = child;
                fragment.appendChild(child);
                iconAdded = true;
              }
            } // Avoid content zone to be voracious
            else if (contentZoneProvided) {
                fragment.appendChild(child);
              } else {
                // Move anything else into the label
                label.appendChild(child);
              }
          } // Add the frag to the component


          this.appendChild(fragment); // Assign the content zones, moving them into place in the process

          this.label = label; // Make sure the icon is well positioned

          this._updatedIcon = true;

          this._updateIcon(this.icon);
        }
        /**
         Triggered when {@link BaseButton#selected} changed.
          @typedef {CustomEvent} coral-button:_selectedchanged
          @private
         */

        /**
         Triggered when {@link BaseButton#value} changed.
          @typedef {CustomEvent} coral-button:_valuechanged
          @private
         */

      }, {
        key: "label",
        get: function get() {
          return this._getContentZone(this._elements.label);
        },
        set: function set(value) {
          this._setContentZone('label', value, {
            handle: 'label',
            tagName: this._contentZoneTagName,
            insert: function insert(label) {
              // Update label styles
              this._updateLabel(label); // Ensure there's no extra space left for icon only buttons


              if (label.innerHTML.trim() === '') {
                label.textContent = '';
              }

              if (this.iconPosition === iconPosition.LEFT) {
                this.appendChild(label);
              } else {
                this.insertBefore(label, this.firstChild);
              }
            }
          });
        }
        /**
         Position of the icon relative to the label. If no <code>iconPosition</code> is provided, it will be set on the
         left side by default.
         See {@link ButtonIconPositionEnum}.
          @type {String}
         @default ButtonIconPositionEnum.LEFT
         @htmlattribute iconposition
         @htmlattributereflected
         */

      }, {
        key: "iconPosition",
        get: function get() {
          return this._iconPosition || iconPosition.LEFT;
        },
        set: function set(value) {
          value = transform.string(value).toLowerCase();
          value = validate.enumeration(iconPosition)(value) && value || iconPosition.LEFT;

          this._reflectAttribute('iconposition', value);

          if (validate.valueMustChange(this._iconPosition, value)) {
            this._iconPosition = value;

            this._updateIcon(this.icon);
          }
        }
        /**
         Specifies the icon name used inside the button. See {@link Icon} for valid icon names.
          @type {String}
         @default ""
         @htmlattribute icon
         */

      }, {
        key: "icon",
        get: function get() {
          if (this._elements.icon) {
            return this._elements.icon.getAttribute('icon') || '';
          }

          return this._icon || '';
        },
        set: function set(value) {
          value = transform.string(value);

          if (validate.valueMustChange(this._icon, value)) {
            this._icon = value;

            this._updateIcon(value);
          }
        }
        /**
         Size of the icon. It accepts both lower and upper case sizes. See {@link ButtonIconSizeEnum}.
          @type {String}
         @default ButtonIconSizeEnum.SMALL
         @htmlattribute iconsize
         */

      }, {
        key: "iconSize",
        get: function get() {
          if (this._elements.icon) {
            return this._elements.icon.getAttribute('size') || Icon.size.SMALL;
          }

          return this._iconSize || Icon.size.SMALL;
        },
        set: function set(value) {
          value = transform.string(value).toUpperCase();
          value = validate.enumeration(Icon.size)(value) && value || Icon.size.SMALL;

          if (validate.valueMustChange(this._iconSize, value)) {
            this._iconSize = value;
            this._updatedIcon && this._getIconElement().setAttribute('size', value);
          }
        }
        /**
         Whether aria-label is set automatically. See {@link IconAutoAriaLabelEnum}.
          @type {String}
         @default IconAutoAriaLabelEnum.OFF
         @htmlattribute autoarialabel
         */

      }, {
        key: "iconAutoAriaLabel",
        get: function get() {
          if (this._elements.icon) {
            return this._elements.icon.getAttribute('autoarialabel') || Icon.autoAriaLabel.OFF;
          }

          return this._iconAutoAriaLabel || Icon.autoAriaLabel.OFF;
        },
        set: function set(value) {
          value = transform.string(value).toLowerCase();
          value = validate.enumeration(Icon.autoAriaLabel)(value) && value || Icon.autoAriaLabel.OFF;

          if (validate.valueMustChange(this._iconAutoAriaLabel, value)) {
            this._iconAutoAriaLabel = value;
            this._updatedIcon && this._getIconElement().setAttribute('autoarialabel', value);
          }
        }
        /**
         The size of the button. It accepts both lower and upper case sizes. See {@link ButtonSizeEnum}.
         Currently only "MEDIUM" is supported.
          @type {String}
         @default ButtonSizeEnum.MEDIUM
         @htmlattribute size
         @htmlattributereflected
         */

      }, {
        key: "size",
        get: function get() {
          return this._size || size$1.MEDIUM;
        },
        set: function set(value) {
          value = transform.string(value).toUpperCase();
          this._size = validate.enumeration(size$1)(value) && value || size$1.MEDIUM;

          this._reflectAttribute('size', this._size);
        }
        /**
         Whether the button is selected.
          @type {Boolean}
         @default false
         @htmlattribute selected
         @htmlattributereflected
         */

      }, {
        key: "selected",
        get: function get() {
          return this._selected || false;
        },
        set: function set(value) {
          value = transform.booleanAttr(value);

          this._reflectAttribute('selected', value);

          if (validate.valueMustChange(this._selected, value)) {
            this._selected = value;
            this.classList.toggle('is-selected', value);
            this.trigger('coral-button:_selectedchanged');
          }
        } // We just reflect it but we also trigger an event to be used by button group

        /** @ignore */

      }, {
        key: "value",
        get: function get() {
          return this.getAttribute('value');
        },
        set: function set(value) {
          this._reflectAttribute('value', value);

          this.trigger('coral-button:_valuechanged');
        }
        /**
         Expands the button to the full width of the parent.
          @type {Boolean}
         @default false
         @htmlattribute block
         @htmlattributereflected
         */

      }, {
        key: "block",
        get: function get() {
          return this._block || false;
        },
        set: function set(value) {
          value = transform.booleanAttr(value);

          this._reflectAttribute('block', value);

          if (validate.valueMustChange(this._block, value)) {
            this._block = value;
            this.classList.toggle("".concat(CLASSNAME$2, "--block"), value);
          }
        }
        /**
         The button's variant. See {@link ButtonVariantEnum}.
          @type {String}
         @default ButtonVariantEnum.DEFAULT
         @htmlattribute variant
         @htmlattributereflected
         */

      }, {
        key: "variant",
        get: function get() {
          return this._variant || variant$1.DEFAULT;
        },
        set: function set(value) {
          value = transform.string(value).toLowerCase();
          value = validate.enumeration(variant$1)(value) && value || variant$1.DEFAULT;

          this._reflectAttribute('variant', value);

          if (validate.valueMustChange(this._variant, value)) {
            var _this$classList;

            this._variant = value; // removes every existing variant

            this.classList.remove(CLASSNAME$2, ACTION_CLASSNAME);

            (_this$classList = this.classList).remove.apply(_this$classList, ALL_VARIANT_CLASSES$1);

            if (value === variant$1._CUSTOM) {
              this.classList.remove(CLASSNAME$2);
            } else {
              var _this$classList2;

              (_this$classList2 = this.classList).add.apply(_this$classList2, _toConsumableArray(VARIANT_MAP[value]));

              if (value === variant$1.ACTION || value === variant$1.QUIET_ACTION) {
                this.classList.remove(CLASSNAME$2);
              }
            } // Update label styles


            this._updateLabel();
          }
        }
        /**
         Inherited from {@link BaseComponent#trackingElement}.
         */

      }, {
        key: "trackingElement",
        get: function get() {
          return typeof this._trackingElement === 'undefined' ? // keep spaces to only 1 max and trim. this mimics native html behaviors
          (this.label || this).textContent.replace(/\s{2,}/g, ' ').trim() || this.icon : this._trackingElement;
        },
        set: function set(value) {
          _set(_getPrototypeOf(_class.prototype), "trackingElement", value, this, true);
        }
      }, {
        key: "_contentZoneTagName",
        get: function get() {
          return Object.keys(this._contentZones)[0];
        }
      }, {
        key: "_contentZones",
        get: function get() {
          return {
            'coral-button-label': 'label'
          };
        }
        /**
         Returns {@link BaseButton} sizes.
          @return {ButtonSizeEnum}
         */

      }], [{
        key: "size",
        get: function get() {
          return size$1;
        }
        /**
         Returns {@link BaseButton} variants.
          @return {ButtonVariantEnum}
         */

      }, {
        key: "variant",
        get: function get() {
          return variant$1;
        }
        /**
         Returns {@link BaseButton} icon positions.
          @return {ButtonIconPositionEnum}
         */

      }, {
        key: "iconPosition",
        get: function get() {
          return iconPosition;
        }
        /**
         Returns {@link BaseButton} icon sizes.
          @return {ButtonIconSizeEnum}
         */

      }, {
        key: "iconSize",
        get: function get() {
          return iconSize;
        }
      }, {
        key: "_attributePropertyMap",
        get: function get() {
          return commons.extend(_get(_getPrototypeOf(_class), "_attributePropertyMap", this), {
            iconposition: 'iconPosition',
            iconsize: 'iconSize',
            iconautoarialabel: 'iconAutoAriaLabel'
          });
        }
        /** @ignore */

      }, {
        key: "observedAttributes",
        get: function get() {
          return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['iconposition', 'iconsize', 'icon', 'iconautoarialabel', 'size', 'selected', 'block', 'variant', 'value']);
        }
      }]);

      return _class;
    }(BaseLabellable(superClass));
  };

  /**
   @class Coral.Button
   @classdesc A Button component containing text and/or an icon.
   @htmltag coral-button
   @htmlbasetag button
   @extends {HTMLButtonElement}
   @extends {BaseComponent}
   @extends {BaseButton}
   */

  var Button = Decorator( /*#__PURE__*/function (_BaseButton) {
    _inherits(_class, _BaseButton);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this); // Events

      _this._delegateEvents(_this._events);

      return _this;
    }

    return _class;
  }(BaseButton(BaseComponent(HTMLButtonElement))));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Button.Label
   @classdesc The Button label content
   @htmltag coral-button-label
   @return {HTMLElement}
   */
  var ButtonLabel = (function () {
    return document.createElement('coral-button-label');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons._define('coral-button', Button, {
    extends: 'button'
  });

  Button.Label = ButtonLabel;

  var CLASSNAME$3 = '_coral-Textfield';
  /**
   Enumeration for {@link Textarea} variants.

   @typedef {Object} TextareaVariantEnum

   @property {String} DEFAULT
   A default textarea.
   @property {String} QUIET
   A textarea with no border or background.
   */

  var variant$2 = {
    DEFAULT: 'default',
    QUIET: 'quiet'
  }; // Builds a string containing all possible variant classnames. This will be used to remove classnames when the variant
  // changes

  var ALL_VARIANT_CLASSES$2 = [];

  for (var variantValue$1 in variant$2) {
    ALL_VARIANT_CLASSES$2.push("".concat(CLASSNAME$3, "--").concat(variant$2[variantValue$1]));
  }
  /**
   @class Coral.Textarea
   @classdesc A Textarea component is the default multi-line text form field.
   @htmltag coral-textarea
   @htmlbasetag textarea
   @extends {HTMLTextAreaElement}
   @extends {BaseComponent}
   @extends {BaseFormField}
   */


  var Textarea = Decorator( /*#__PURE__*/function (_BaseFormField) {
    _inherits(_class, _BaseFormField);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this);

      _this._delegateEvents(commons.extend(_this._events, {
        input: '_onInput'
      }));

      return _this;
    }
    /**
     The textarea's variant. See {@link TextareaVariantEnum}.
      @type {String}
     @default TextareaVariantEnum.DEFAULT
     @htmlattribute variant
     @htmlattributereflected
     */


    _createClass(_class, [{
      key: "reset",

      /**
       Inherited from {@link BaseFormField#reset}.
       */
      value: function reset() {
        // The textarea uses the textContent to save the old value and not the value attribute

        /** @ignore */
        this.value = this.textContent; // Reset height if quiet variant

        this._onInput();
      }
      /** @private */

    }, {
      key: "_onInput",
      value: function _onInput() {
        var _this2 = this;

        if (this.variant === variant$2.QUIET) {
          requestAnimationFrame(function () {
            _this2.style.height = 'auto';
            _this2.style.height = "".concat(_this2.scrollHeight, "px");
          });
        }
      }
      /**
       Returns {@link Textarea} variants.
        @return {TextareaVariantEnum}
       */

    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$3, "".concat(CLASSNAME$3, "--multiline")); // Default reflected attributes

        if (!this._variant) {
          this.variant = variant$2.DEFAULT;
        }
      }
    }, {
      key: "variant",
      get: function get() {
        return this._variant || variant$2.DEFAULT;
      },
      set: function set(value) {
        var _this$classList;

        value = transform.string(value).toLowerCase();
        this._variant = validate.enumeration(variant$2)(value) && value || variant$2.DEFAULT;

        this._reflectAttribute('variant', this._variant); // removes every existing variant


        (_this$classList = this.classList).remove.apply(_this$classList, ALL_VARIANT_CLASSES$2);

        if (this._variant !== variant$2.DEFAULT) {
          this.classList.add("".concat(CLASSNAME$3, "--").concat(this._variant));
        } // Restore the original height


        if (this._variant === variant$2.QUIET) {
          this._defaultHeight = this._defaultHeight || this.style.height;
        } else {
          this.style.height = this._defaultHeight;
          this._defaultHeight = undefined;
        }

        this._onInput();
      }
    }], [{
      key: "variant",
      get: function get() {
        return variant$2;
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "_nativeObservedAttributes", this).concat(['variant']);
      }
    }]);

    return _class;
  }(BaseFormField(BaseComponent(HTMLTextAreaElement))));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons._define('coral-textarea', Textarea, {
    extends: 'textarea'
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var translations$1 = {
    "en-US": {
      "Select": "Select",
      "invalid": "invalid"
    },
    "fr-FR": {
      "Select": "Sélectionner",
      "invalid": "Non valide"
    },
    "de-DE": {
      "Select": "Auswählen",
      "invalid": "Ungültig"
    },
    "it-IT": {
      "Select": "Seleziona",
      "invalid": "Non valido"
    },
    "es-ES": {
      "Select": "Seleccionar",
      "invalid": "No válido"
    },
    "pt-BR": {
      "Select": "Selecionar",
      "invalid": "Inválido"
    },
    "ja-JP": {
      "Select": "選択",
      "invalid": "無効です"
    },
    "ko-KR": {
      "Select": "선택",
      "invalid": "올바르지 않음"
    },
    "zh-CN": {
      "Select": "选择",
      "invalid": "无效"
    },
    "zh-TW": {
      "Select": "選取",
      "invalid": "無效"
    },
    "nl-NL": {
      "Select": "Selecteren",
      "invalid": "Ongeldig"
    },
    "da-DK": {
      "Select": "Vælg",
      "invalid": "Ugyldig"
    },
    "fi-FI": {
      "Select": "Valitse",
      "invalid": "Virheellinen"
    },
    "nb-NO": {
      "Select": "Velg",
      "invalid": "Ugyldig"
    },
    "sv-SE": {
      "Select": "Välj",
      "invalid": "Ogiltig"
    },
    "cs-CZ": {
      "Select": "Vybrat",
      "invalid": "Neplatný"
    },
    "pl-PL": {
      "Select": "Wybierz",
      "invalid": "Nieprawidłowy"
    },
    "ru-RU": {
      "Select": "Выберите",
      "invalid": "Недопустимый"
    },
    "tr-TR": {
      "Select": "Seç",
      "invalid": "Geçersiz"
    }
  };

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /** @private */
  function listToArray(list) {
    var res = [];

    for (var i = 0, listCount = res.length = list.length; i < listCount; i++) {
      res[i] = list[i];
    }

    return res;
  }

  /**
   Unique id used to idenfity the collection.

   @private
   */

  var nextID$1 = 0;
  /**
   Attribute used to identify the items of a collection.

   @private
   */

  var COLLECTION_ID = 'coral-collection-id-';
  /**
   Selector used to determine if nested items should be allowed.

   @private
   */

  var SCOPE_SELECTOR = ':scope > ';
  /** @private */

  function getTagSelector(tag, nativeTag) {
    return nativeTag ? "".concat(nativeTag, "[is=\"").concat(tag, "\"]") : tag;
  }
  /**
   Helper function used to determine if the item should be filtered. If the filter is <code>undefined</code>, then the
   item will pass the filter.

   @param {HTMLElement} item
   The item that should be filtered.
   @param {Function} filter
   Function used to filter the item

   @returns {Boolean} true if the item passes the filter, otherwise false.

   @private
   */


  function filterItem(item, filter) {
    return typeof filter !== 'function' || filter(item);
  }
  /**
   Collection provides a standardized way to manipulate items in a component.
   */


  var Collection$1 = /*#__PURE__*/function () {
    /**
     @param {HTMLElement} options.host
     The element that hosts the collection.
     @param {String} options.itemTagName
     The tag name of the elements that constitute a collection item.
     @param {String} options.itemBaseTagName
     The optional base tag name of the elements that constitute a collection item. This is required for elements that
     extend native elements, like Button.
     @param {String} [options.itemSelector]
     Optional, derived from itemTagName and itemBaseTagName by default. Used to query the host element for its
     collection items.
     @param {HTMLElement} [options.container]
     Optional element that wraps the collection. Defines where the new items will be added when <code>add</code> method
     is called. Is the same as options.host by default.
     @param {CollectionFilter} [options.filter]
     Optional function used to filter the results.
     @param {CollectionOnItemAdded} [options.onItemAdded]
     Function called once an item is added to the DOM. If the Collection has been configured to handle the items
     automatically, the callback will be called once the collection detects that the item has been added to the DOM and
     not synchronously with <code>add()</code>.
     @param {CollectionOnItemRemoved} [options.onItemRemoved]
     Function called once an item is removed from the DOM. If the Collection has been configured to handle the items
     automatically, the callback will be called once the collection detects that the item has been removed from the DOM
     not synchronously with <code>add()</code>.
     @param {CollectionOnChange} [options.onCollectionChange]
     Function called after there has been a change in the collection. This allows components to handle state changes
     after an item(s) has been added or removed. This callback will only be called if the Collection is configured to
     handle the items automatically.
     is <code>true</code>.
     */
    function Collection(options) {
      _classCallCheck(this, Collection);

      options = options || {}; // we create an unique collection identifier

      this._id = nextID$1++;
      this._host = options.host;
      this._itemTagName = options.itemTagName;
      this._itemBaseTagName = options.itemBaseTagName;
      this._itemTagNameFilter = [];
      this._itemBaseTagName && this._itemTagNameFilter.push(this._itemBaseTagName.toUpperCase());
      this._itemTagName && this._itemTagNameFilter.push(this._itemTagName.toUpperCase());
      this._itemSelector = options.itemSelector || getTagSelector(this._itemTagName, this._itemBaseTagName); // the container where the new items are added

      this._container = options.container || this._host;
      this._filter = options.filter;
      this._onlyHandleChildren = typeof options.onlyHandleChildren === 'boolean' ? options.onlyHandleChildren : false; // internal variable to determine if collection events will be handled internally

      this._handleItems = false; // we provide support for the :scope selector and swap it for an id

      if (this._itemSelector && this._itemSelector.indexOf(SCOPE_SELECTOR) === 0) {
        this._container.id = this._container.id || COLLECTION_ID + this._id; // we create a special selector to make sure that the items are direct children of the container. given that
        // :scope is not fully supported by all browsers, we use an id to query

        this._allItemsSelector = this._itemSelector.replace(SCOPE_SELECTOR, "#".concat(this._container.id, " > ")); // we remove the :scope from the selector to be able to use it to determine if the item matches the collection

        this._itemSelector = this._itemSelector.replace(SCOPE_SELECTOR, ''); // in case they match, we enable this optimization

        if (this._itemSelector === this._itemTagName) {
          this._useItemTagName = this._itemSelector.toUpperCase();
        }
      } // live collections are not supported when nested items is used
      else {
          this._allItemsSelector = this._itemSelector; // live collections can only be used when a tagname is used to query the items

          if (this._container && this._allItemsSelector === this._itemTagName) {
            this._liveCollection = true;
            this._useItemTagName = this._allItemsSelector.toUpperCase();
          }
        }

      this._onItemAdded = options.onItemAdded;
      this._onItemRemoved = options.onItemRemoved;
      this._onCollectionChange = options.onCollectionChange;
    }
    /**
     Number of items inside the Collection.
      @type {Number}
     @default 0
     */


    _createClass(Collection, [{
      key: "add",

      /**
       Adds an item to the Collection. The item can be either a <code>HTMLElement</code> or an Object with the item
       properties. If the index is not provided the element appended to the end. If <code>options.onItemAdded</code> was
       provided, it will be called after the element is added from the DOM.
        @param {HTMLElement|Object} item
       The item to add to the Collection.
       @param {HTMLElement} [insertBefore]
       Existing item used as a reference to insert the new item before. If the value is <code>null</code>, then the new
       item will be added at the end.
        @emits {coral-collection:add}
        @returns {HTMLElement} the item added.
       */
      value: function add(item, insertBefore) {
        // container and itemtagname are the minimum options that need to be provided to automatically handle this function
        if (this._container && this._itemTagName) {
          if (!(item instanceof HTMLElement)) {
            // creates an instance of an item from the object
            if (this._itemBaseTagName) {
              item = document.createElement(this._itemBaseTagName, {
                is: this._itemTagName
              }).set(item, true);
            } else {
              item = document.createElement(this._itemTagName).set(item, true);
            }
          } // inserts the element in the specified container


          this._container.insertBefore(item, insertBefore || null); // when items are handled automatically there is no need to call this immediately


          if (!this._handleItems && typeof this._onItemAdded === 'function' && this._host && filterItem(item, this._filter)) {
            this._onItemAdded.call(this._host, item);
          }

          return item;
        }

        throw new Error('Please provide host and itemTagName or override add() to provide your own implementation.');
      }
      /**
       Removes all the items from the Collection.
        @returns {Array.<HTMLElement>} an Array with all the removed items.
       */

    }, {
      key: "clear",
      value: function clear() {
        var items = this.getAll();
        var removed = [];

        for (var i = items.length - 1; i > -1; i--) {
          removed.push(this.remove(items[i]));
        }

        return removed;
      }
      /**
       Returns an array with all the items inside the Collection. Each element is of type <code>HTMLElement</code>.
        @returns {Array.<HTMLElement>} an Array with all the items inside the collection.
       */

    }, {
      key: "getAll",
      value: function getAll() {
        // in order to perform the automatic getAll query, the _host and _allItemsSelector must be provided
        if (this._container && this._allItemsSelector) {
          var items = this._liveCollection ? // instead of querying the DOM, we just convert the live collection to an array, this way we obtain a
          // "snapshot" of the DOM
          listToArray(this._container.getElementsByTagName(this._allItemsSelector)) : listToArray(this._container.querySelectorAll(this._allItemsSelector));

          if (this._filter) {
            items = items.filter(this._filter);
          }

          return items;
        }

        throw new Error('Please provide host and itemTagName or override getAll() to provide your own implementation.');
      }
      /**
       Removes the given item from the Collection. If <code>options.onItemRemoved</code> was provided, it will be called
       after the element is removed from the DOM.
        @param {HTMLElement} item
       The item to add to the Collection.
        @emits {coral-collection:remove}
        @returns {HTMLElement} the item removed.
       */

    }, {
      key: "remove",
      value: function remove(item) {
        if (item.parentNode) {
          item.parentNode.removeChild(item); // when items are handled automatically there is no need to call this immediatelly

          if (!this._handleItems && typeof this._onItemRemoved === 'function' && this._host && filterItem(item, this._filter)) {
            this._onItemRemoved.call(this._host, item);
          }
        }

        return item;
      }
      /**
       Returns the first item of the collection.
        @returns {?HTMLElement} the first item of the collection.
       */

    }, {
      key: "first",
      value: function first() {
        // Use getAll() so filter() is applied
        return this.getAll()[0] || null;
      }
      /**
       Returns the last item of the collection.
        @returns {?HTMLElement} the last item of the collection.
       */

    }, {
      key: "last",
      value: function last() {
        // Use getAll() so filter() is applied
        var all = this.getAll();
        return all[all.length - 1] || null;
      }
      /**
       Checks if the given Node belongs to the current collection. It is said that a Node belongs to a given collection
       if it passes <code>options.filter</code> and it matches <code>options.itemSelector</code>.
        @param {Node} node
       The node to check if it belongs to the collection.
        @returns {Boolean} true if the node is part of the collection, otherwise false.
        @protected
       */

    }, {
      key: "_isPartOfCollection",
      value: function _isPartOfCollection(node) {
        // Only element nodes are allowed
        var tagName = node.tagName;
        return node.nodeType === Node.ELEMENT_NODE && (this._itemTagNameFilter.length === 0 || this._itemTagNameFilter.includes(tagName)) && filterItem(node, this._filter) && ( // this is an optimization to avoid using matches
        this._useItemTagName ? this._useItemTagName === tagName : node.matches(this._itemSelector));
      }
      /**
       Handles the attachment of an item to the collection. It triggers automatically the collection event.
        @param {HTMLElement} item
       The item that was attached to the collection.
        @emits {coral-collection:add}
        @protected
       */

    }, {
      key: "_onItemAttached",
      value: function _onItemAttached(item) {
        // if options.onItemAdded was provided, we call the function
        if (typeof this._onItemAdded === 'function') {
          this._onItemAdded.call(this._host, item);
        } // the usage of trigger assumes that the host is a coral component


        this._host.trigger('coral-collection:add', {
          item: item
        });
      }
      /**
       Handles the detachment of a item to the collection. It triggers automatically the collection event.
        @param {HTMLElement} item
       The item that was detached of the collection
        @emits {coral-collection:remove}
        @protected
       */

    }, {
      key: "_onItemDetached",
      value: function _onItemDetached(item) {
        // if options.onItemRemoved was provided, we call the function
        if (typeof this._onItemRemoved === 'function') {
          this._onItemRemoved.call(this._host, item);
        } // the usage of trigger assumes that the host is a coral component


        this._host.trigger('coral-collection:remove', {
          item: item
        });
      }
      /**
       Handles the collection changes. It automatically triggers the collection change event.
       @param {Array<HTMLElement>} addedNodes The items that was added to the collection
       @param {Array<HTMLElement>} removedNodes The items that was removed from the collection
       @emits {coral-collection:change}
       @protected
       */

    }, {
      key: "_onCollectionMutation",
      value: function _onCollectionMutation(addedNodes, removedNodes) {
        // if options.onCollectionChange was provided, we call the function
        if (typeof this._onCollectionChange === 'function') {
          this._onCollectionChange.call(this._host, addedNodes, removedNodes);
        } // the usage of trigger assumes that the host is a coral component


        this._host.trigger('coral-collection:change', {
          addedItems: addedNodes,
          removedItems: removedNodes
        });
      }
      /**
       Enables the automatic detection of collection items. The collection will take care of triggering the appropriate
       collection event when an item is added or removed, as well the related callbacks. Components can decide to skip the
       initialization of the starting items by providing <code>skipInitialItems</code> as <code>false</code>.
        @param {Boolean} [skipInitialItems=false]
       If <code>true</code>, <code>onItemAdded</code> will be called for every starting item. A collection event will not
       be triggered for these items.
        @protected
       */

    }, {
      key: "_startHandlingItems",
      value: function _startHandlingItems(skipInitialItems) {
        if (this._host && this._container) {
          // we reuse the observer if it already exists, this way we do not need to disconnect it if this function is called
          // again
          this._observer = this._observer || new MutationObserver(this._handleMutation.bind(this)); // this changes the way that _onItemAdded and _onItemRemoved behave, since they well be delayed until a mutation
          // detects them

          this._handleItems = true;

          if (this._onlyHandleChildren) {
            this._observer.observe(this._container, {
              // we only need to observe for items that were added and removed, no need to check attributes and contents
              childList: true
            });
          } else {
            this._observer.observe(this._container, {
              // we only need to observe for items that were added and removed, no need to check attributes and contents
              childList: true,
              // we need to listen to subtree mutations as items may not be direct children
              subtree: true
            });
          } // by default we handle the initial items unless otherwise indicated


          if (skipInitialItems !== true) {
            // since we are handling the items for the component, we need to make sure the _onItemAdded is called for the
            // initial items. collection events will not be triggered for these items as they represent the initial state
            var items;
            var itemCount = 0;

            if (typeof this._onItemAdded === 'function' || typeof this._onCollectionChange === 'function') {
              items = this.getAll();
              itemCount = items.length;
            }

            if (typeof this._onItemAdded === 'function') {
              for (var i = 0; i < itemCount; i++) {
                this._onItemAdded.call(this._host, items[i]);
              }
            } // we only call the _onCollectionChange callback if there are items inside the collection


            if (itemCount > 0 && typeof this._onCollectionChange === 'function') {
              this._onCollectionChange.call(this._host, items, []);
            }
          }
        } else {
          throw new Error('Please provide options.host and/or options.container to enable handling the items.');
        }
      }
      /**
       Stops handling the items.
        @protected
       */

    }, {
      key: "_stopHandlingItems",
      value: function _stopHandlingItems() {
        if (this._observer) {
          this._observer.disconnect();
        }
      }
      /**
       Handles every time that an element is added or removed from the <code>options.container</code>. By default the
       collection events will be triggered. If <code>options.onItemAdded</code> or <code>options.onItemRemoved</code> were
       provided, they will be called where it applies.
        @param Array.<Object> mutations
       Array that contains the <code>MutationRecord> relevant to every registered mutation.
        @protected
       */

    }, {
      key: "_handleMutation",
      value: function _handleMutation(mutations) {
        var mutation;
        var mutationsCount = mutations.length;
        var item;
        var addedNodes;
        var addedNodesCount;
        var removedNodes;
        var removedNodesCount;
        var validAddedNodes = [];
        var validRemovedNodes = []; // we need to count every addition and removal to notify the component that the collection changed

        var itemChanges = 0;

        for (var i = 0; i < mutationsCount; i++) {
          mutation = mutations[i];
          addedNodes = mutation.addedNodes;
          addedNodesCount = addedNodes.length;

          for (var j = 0; j < addedNodesCount; j++) {
            item = addedNodes[j]; // filters the item

            if (this._isPartOfCollection(item)) {
              itemChanges++;
              validAddedNodes.push(item);

              this._onItemAttached(item);
            }
          }

          removedNodes = mutation.removedNodes;
          removedNodesCount = removedNodes.length;

          for (var k = 0; k < removedNodesCount; k++) {
            item = removedNodes[k]; // filters the item

            if (this._isPartOfCollection(item)) {
              itemChanges++;
              validRemovedNodes.push(item);

              this._onItemDetached(item);
            }
          }
        } // if changes were done to the collection we need to notify the component. we do this after all the mutations were
        // processed to make sure we only do it once


        if (itemChanges !== 0 && this._host) {
          this._onCollectionMutation(validAddedNodes, validRemovedNodes);
        }
      }
      /**
       Triggered when an item is added to the {@link Collection}. {@link Collection} events are not synchronous so the DOM
       may reflect a different reality although every addition or removal will be reported.
        @typedef {CustomEvent} coral-collection:add
        @property {HTMLElement} detail.item
       The item that was added.
       */

      /**
       Triggered when an item is removed from a {@link Collection}. {@link Collection} events are not synchronous so the DOM
       may reflect a different reality although every addition or removal will be reported.
        @typedef {CustomEvent} coral-collection:remove
        @property {HTMLElement} detail.item
       The item that was removed.
       */

      /**
       * Triggered when either items are added or removed from {@link Collection}. {@link Collection} events are not synchronous so the DOM
       * may reflect a different reality although every addition or removal will be reported. This event describes that {@link Collection} has
       * changed or modified.
       *
       * @event coral-collection:change
       * @type {Object}
       * @property {Array<HTMLElement>} detail.addedItems - Items that are added to collection
       * @property {Array<HTMLElement>} detail.removedItems - Items that are removed from collection
       */

      /**
       Signature of the function called to determine if an element should be included in the {@link Collection}. If the function
       returns <code>true</code> for the given element it will be part of the collection, otherwise it will be excluded.
        @typedef {function} CollectionFilter
        @param {HTMLElement} element
       The item to check whether it should be part of the collection.
        @returns {Boolean} true if should be part of the collection, otherwise false.
       */

      /**
       Signature of the function called when ever an item is added to the {@link Collection}.
        @typedef {function} CollectionOnItemAdded
        @param {HTMLElement} item
       The item that was added to the collection.
       */

      /**
       Signature of the function called when ever an item is removed from the {@link Collection}.
        @typedef {function} CollectionOnItemRemoved
        @param {HTMLElement} item
       The item that was added to the collection.
       */

      /**
       Signature of the function called when there is a change in the {@link Collection}. The items that where added and removed
       will be provided.
        @typedef {function} CollectionOnChange
        @param {Array.<HTMLElement>} addedNodes
       An array that contains the items that were added to the collection.
       @param {Array.<HTMLElement>} removedNodes
       An array that contains the items that were removed from the collection.
       */

    }, {
      key: "length",
      get: function get() {
        return this.getAll().length;
      }
    }]);

    return Collection;
  }();

  /**
   Collection capable of handling non-nested items with a selected attribute. It is useful to manage the
   internal state of selection. It currently does not support options.filter for the selection related functions.
   */

  var SelectableCollection = /*#__PURE__*/function (_Collection) {
    _inherits(SelectableCollection, _Collection);

    var _super = _createSuper(SelectableCollection);

    function SelectableCollection(options) {
      var _this;

      _classCallCheck(this, SelectableCollection);

      _this = _super.call(this, options);

      if (_this._filter) {
        commons._log('warn', 'Coral.SelectableCollection does not support the options.filter');
      } // disabled items will not be a selection candicate although hidden items might


      _this._selectableItemSelector = _this._allItemsSelector.split(',').map(function (selector) {
        return "".concat(selector, ":not([disabled])");
      }).join(',');
      _this._selectedItemSelector = _this._allItemsSelector.split(',').map(function (selector) {
        return "".concat(selector, "[selected]");
      }).join(',');
      _this._deselectAllExceptSelector = _this._selectedItemSelector;
      return _this;
    }
    /**
     Returns the selectable items. Items that are disabled quality for selection. On the other hand, hidden items
     can be selected as this is the default behavior in HTML. Please note that an already selected item could be
     returned, since the selection could be toggled.
      @returns {Array.<HTMLElement>}
     an array of items whose selection could be toggled.
      @protected
     */


    _createClass(SelectableCollection, [{
      key: "_getSelectableItems",
      value: function _getSelectableItems() {
        return listToArray(this._container.querySelectorAll(this._selectableItemSelector));
      }
      /**
       Returns the first selectable item. Items that are disabled quality for selection. On the other hand, hidden items
       can be selected as this is the default behavior in HTML. Please note that an already selected item could be
       returned, since the selection could be toggled.
        @returns {HTMLElement}
       an item whose selection could be toggled.
        @protected
       */

    }, {
      key: "_getFirstSelectable",
      value: function _getFirstSelectable() {
        return this._container.querySelector(this._selectableItemSelector) || null;
      }
      /**
       Returns the last selectable item. Items that are disabled quality for selection. On the other hand, hidden items
       can be selected as this is the default behavior in HTML. Please note that an already selected item could be
       returned, since the selection could be toggled.
        @returns {HTMLElement}
       an item whose selection could be toggled.
        @protected
       */

    }, {
      key: "_getLastSelectable",
      value: function _getLastSelectable() {
        var items = this._container.querySelectorAll(this._selectableItemSelector);

        return items[items.length - 1] || null;
      }
      /**
       Returns the previous selectable item.
        @param {HTMLElement} item
       The reference item.
        @returns {HTMLElement}
       an item whose selection could be toggled.
        @protected
       */

    }, {
      key: "_getPreviousSelectable",
      value: function _getPreviousSelectable(item) {
        var items = this.getAll();
        var index = items.indexOf(item);
        var sibling = index > 0 ? items[index - 1] : null;

        while (sibling) {
          if (sibling.matches(this._selectableItemSelector)) {
            break;
          } else {
            index--;
            sibling = index > 0 ? items[index - 1] : null;
          }
        } // in case the item is not specified, or it is not inside the collection, we need to return the first selectable


        return sibling || (item.matches(this._selectableItemSelector) ? item : this._getFirstSelectable());
      }
      /**
       Returns the next selectable item.
        @param {HTMLElement} item
       The reference item.
        @returns {HTMLElement}
       an item whose selection could be toggled.
        @protected
       */

    }, {
      key: "_getNextSelectable",
      value: function _getNextSelectable(item) {
        var items = this.getAll();
        var index = items.indexOf(item);
        var sibling = index < items.length - 1 ? items[index + 1] : null;

        while (sibling) {
          if (sibling.matches(this._selectableItemSelector)) {
            break;
          } else {
            index++;
            sibling = index < items.length - 1 ? items[index + 1] : null;
          }
        }

        return sibling || item;
      }
      /**
       Returns the first item that is selected in the Collection. It allows to configure the attribute used for selection
       so that components that use 'selected' and 'active' can share the same implementation.
        @param {String} [selectedAttribute=selected]
       the attribute that will be used to check for selection.
        @returns HTMLElement the first selected item.
        @protected
       */

    }, {
      key: "_getFirstSelected",
      value: function _getFirstSelected(selectedAttribute) {
        var selector = this._selectedItemSelector;

        if (typeof selectedAttribute === 'string') {
          selector = selector.replace('[selected]', "[".concat(selectedAttribute, "]"));
        }

        return this._container.querySelector(selector) || null;
      }
      /**
       Returns the last item that is selected in the Collection. It allows to configure the attribute used for selection
       so that components that use 'selected' and 'active' can share the same implementation.
        @param {String} [selectedAttribute=selected]
       the attribute that will be used to check for selection.
        @returns HTMLElment the last selected item.
        @protected
       */

    }, {
      key: "_getLastSelected",
      value: function _getLastSelected(selectedAttribute) {
        var selector = this._selectedItemSelector;

        if (typeof selectedAttribute === 'string') {
          selector = selector.replace('[selected]', "[".concat(selectedAttribute, "]"));
        } // last-of-type did not work so we need to query all


        var items = this._container.querySelectorAll(selector);

        return items[items.length - 1] || null;
      }
      /**
       Returns an array that contains all the items that are selected.
        @param {String} [selectedAttribute=selected]
       the attribute that will be used to check for selection.
        @protected
        @returns Array.<HTMLElement> an array with all the selected items.
       */

    }, {
      key: "_getAllSelected",
      value: function _getAllSelected(selectedAttribute) {
        var selector = this._selectedItemSelector;

        if (typeof selectedAttribute === 'string') {
          selector = selector.replace('[selected]', "[".concat(selectedAttribute, "]"));
        }

        return listToArray(this._container.querySelectorAll(selector));
      }
      /**
       Deselects all the items except the first selected item in the Collection. By default the <code>selected</code>
       attribute will be removed. The attribute to remove is configurable via the <code>selectedAttribute</code> parameter.
       The selected attribute will be removed no matter if the item is <code>disabled</code> or <code>hidden</code>.
        @param {String} [selectedAttribute=selected]
       the attribute that will be used to check for selection. This attribute will be removed from the matching elements.
        @protected
       */

    }, {
      key: "_deselectAllExceptFirst",
      value: function _deselectAllExceptFirst(selectedAttribute) {
        var selector = this._deselectAllExceptSelector;
        var attributeToRemove = selectedAttribute || 'selected';

        if (typeof selectedAttribute === 'string') {
          selector = selector.replace('[selected]', "[".concat(selectedAttribute, "]"));
        } // we select all the selected attributes except the last one


        var items = this._container.querySelectorAll(selector);

        var itemsCount = items.length; // ignores the first item of the list, everything else is deselected

        for (var i = 1; i < itemsCount; i++) {
          // we use remoteAttribute since we do not know if the element is upgraded
          items[i].removeAttribute(attributeToRemove);
        }
      }
      /**
       Deselects all the items except the last selected item in the Collecton. By default the <code>selected</code>
       attribute will be removed. The attribute to remove is configurable via the <code>selectedAttribute</code> parameter.
        @param {String} [selectedAttribute=selected]
       the attribute that will be used to check for selection. This attribute will be removed from the matching elements.
        @protected
       */

    }, {
      key: "_deselectAllExceptLast",
      value: function _deselectAllExceptLast(selectedAttribute) {
        var selector = this._deselectAllExceptSelector;
        var attributeToRemove = selectedAttribute || 'selected';

        if (typeof selectedAttribute === 'string') {
          selector = selector.replace('[selected]', "[".concat(selectedAttribute, "]"));
        } // we query for all matching items with the given attribute


        var items = this._container.querySelectorAll(selector); // we ignore the last item


        var itemsCount = items.length - 1;

        for (var i = 0; i < itemsCount; i++) {
          // we use remoteAttribute since we do not know if the element is upgraded
          items[i].removeAttribute(attributeToRemove);
        }
      }
      /**
       Deselects all the items except the given item. The provided attribute will be remove from all matching items. By
       default the <code>selected</code> attribute will be removed. The attribute to remove is configurable via the
       <code>selectedAttribute</code> parameter.
        @name Coral.SelectableCollection#_deselectAllExcept
       @function
        @param {HTMLElement} [itemOrSelectedAttribute]
       The item to keep selected. If the item is not provided, all elements will be deselected.
        @param {String} [selectedAttribute=selected]
       the attribute that will be used to check for selection. This attribute will be removed from the matching elements.
        @protected
       */

    }, {
      key: "_deselectAllExcept",
      value: function _deselectAllExcept(itemOrSelectedAttribute, selectedAttribute) {
        // if no selectedAttribute we use the unmodified selector as default
        var selector = this._deselectAllExceptSelector;
        var item;
        var attributeToRemove; // an item was not provided so we use it as 'selectedAttribute'

        if (typeof itemOrSelectedAttribute === 'string') {
          item = null;
          attributeToRemove = itemOrSelectedAttribute || 'selected';
          selector = selector.replace('[selected]', "[".concat(attributeToRemove, "]"));
        } else {
          item = itemOrSelectedAttribute;
          attributeToRemove = selectedAttribute || 'selected';

          if (typeof selectedAttribute === 'string') {
            selector = selector.replace('[selected]', "[".concat(attributeToRemove, "]"));
          }
        } // we query for all matching items with the given attribute


        var items = this._container.querySelectorAll(selector);

        var itemsCount = items.length;

        for (var i = 0; i < itemsCount; i++) {
          // we use remoteAttribute since we do not know if the element is upgraded
          if (item !== items[i]) {
            items[i].removeAttribute(attributeToRemove);
          }
        }
      }
    }]);

    return SelectableCollection;
  }(Collection$1);

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var translations$2 = {
    "en-US": {
      "Remove": "Remove"
    },
    "fr-FR": {
      "Remove": "Supprimer"
    },
    "de-DE": {
      "Remove": "Entfernen"
    },
    "it-IT": {
      "Remove": "Rimuovi"
    },
    "es-ES": {
      "Remove": "Eliminar"
    },
    "pt-BR": {
      "Remove": "Remover"
    },
    "ja-JP": {
      "Remove": "削除"
    },
    "ko-KR": {
      "Remove": "제거"
    },
    "zh-CN": {
      "Remove": "删除"
    },
    "zh-TW": {
      "Remove": "移除"
    },
    "nl-NL": {
      "Remove": "Verwijderen"
    },
    "da-DK": {
      "Remove": "Fjern"
    },
    "fi-FI": {
      "Remove": "Poista"
    },
    "nb-NO": {
      "Remove": "Fjern"
    },
    "sv-SE": {
      "Remove": "Ta bort"
    },
    "cs-CZ": {
      "Remove": "Odebrat"
    },
    "pl-PL": {
      "Remove": "Usuń"
    },
    "ru-RU": {
      "Remove": "Удалить"
    },
    "tr-TR": {
      "Remove": "Kaldır"
    }
  };

  var template = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var data = data_0 = typeof data_0 === "undefined" ? {} : data_0;
    var el0 = this["buttonCell"] = document.createElement("span");
    el0.setAttribute("handle", "buttonCell");
    el0.setAttribute("hidden", "");
    var el1 = document.createTextNode("\n  ");
    el0.appendChild(el1);
    var el2 = this["button"] = document.createElement("button", "coral-button");
    el2.setAttribute("tracking", "off");
    el2.setAttribute("handle", "button");
    el2.setAttribute("is", "coral-button");
    el2.setAttribute("type", "button");
    el2.setAttribute("variant", "_custom");
    el2.className += " _coral-ClearButton _coral-ClearButton--small _coral-Tags-item-removeButton";
    el2.setAttribute("title", data_0["i18n"]["get"]('Remove'));
    el2.setAttribute("hidden", "");
    el2.setAttribute("tabindex", "-1");
    el2.setAttribute("coral-close", "");
    var el3 = document.createTextNode("\n    ");
    el2.appendChild(el3);
    var el4 = this["buttonLabel"] = document.createElement("coral-button-label");
    el4.setAttribute("handle", "buttonLabel");
    el2.appendChild(el4);
    var el5 = document.createTextNode("\n  ");
    el2.appendChild(el5);
    el0.appendChild(el2);
    var el6 = document.createTextNode("\n");
    el0.appendChild(el6);
    frag.appendChild(el0);
    var el7 = document.createTextNode("\n");
    frag.appendChild(el7);
    data = data_0; // Don't wait for button MO to pick up the label

    this.button._elements.label = this.buttonLabel; // Render close icon

    this.button.insertAdjacentHTML('beforeend', data.Icon._renderSVG('spectrum-css-icon-CrossSmall', ['_coral-UIIcon-CrossSmall']));
    data_0 = data;
    var el9 = document.createTextNode("\n");
    frag.appendChild(el9);
    return frag;
  };

  var CLASSNAME$4 = '_coral-Tags-item';
  var LABEL_CLASSNAME = '_coral-Label';
  /**
   Enumeration for {@link Tag} sizes. Only colored tags can have different sizes.

   @typedef {Object} TagSizeEnum

   @property {String} SMALL
   A small sized tag.
   @property {String} MEDIUM
   A default sized tag.
   @property {String} LARGE
   A large sized tag.
   */

  var size$2 = {
    SMALL: 'S',
    MEDIUM: 'M',
    LARGE: 'L'
  };
  /**
   Enumeration for {@link Tag} colors.

   @typedef {Object} TagColorEnum

   @property {String} DEFAULT
   @property {String} GREY
   @property {String} BLUE
   @property {String} RED
   @property {String} ORANGE
   @property {String} GREEN
   @property {String} YELLOW
   @property {String} SEA_FOAM
   @property {String} FUCHSIA
   @property {String} LIGHT_BLUE
   Not supported. Falls back to BLUE.
   @property {String} PERIWINKLE
   Not supported. Falls back to BLUE.
   @property {String} CYAN
   Not supported. Falls back to BLUE.
   @property {String} PLUM
   Not supported. Falls back to RED.
   @property {String} MAGENTA
   Not supported. Falls back to RED.
   @property {String} TANGERINE
   Not supported. Falls back to ORANGE.
   @property {String} CHARTREUSE
   Not supported. Falls back to GREEN.
   @property {String} KELLY_GREEN
   Not supported. Falls back to GREEN.
   */

  var color = {
    DEFAULT: '',
    GREY: 'grey',
    BLUE: 'blue',
    RED: 'red',
    ORANGE: 'orange',
    GREEN: 'green',
    LIGHT_BLUE: 'lightblue',
    PERIWINKLE: 'periwinkle',
    PLUM: 'plum',
    FUCHSIA: 'fuchsia',
    MAGENTA: 'magenta',
    TANGERINE: 'tangerine',
    YELLOW: 'yellow',
    CHARTREUSE: 'chartreuse',
    KELLY_GREEN: 'kellygreen',
    SEA_FOAM: 'seafoam',
    CYAN: 'cyan'
  };
  var colorMap = {
    lightblue: 'blue',
    periwinkle: 'blue',
    cyan: 'blue',
    plum: 'red',
    magenta: 'red',
    tangerine: 'orange',
    chartreuse: 'green',
    kelly_green: 'green'
  };
  var swappedSize = commons.swapKeysAndValues(size$2); // builds a string containing all possible color classnames. this will be used to remove classnames when the color
  // changes

  var ALL_COLOR_CLASSES = [];

  for (var colorValue in color) {
    ALL_COLOR_CLASSES.push("".concat(LABEL_CLASSNAME, "--").concat(color[colorValue]));
  } // builds a string containing all possible size classnames. this will be used to remove classnames when the size
  // changes


  var ALL_SIZE_CLASSES$1 = [];

  for (var sizeValue$1 in Object.keys(size$2)) {
    ALL_SIZE_CLASSES$1.push("".concat(LABEL_CLASSNAME, "--").concat(sizeValue$1));
  }

  var QUIET_CLASSNAME = "".concat(CLASSNAME$4, "--quiet");
  var MULTILINE_CLASSNAME = "".concat(CLASSNAME$4, "--multiline"); // Store coordinates of a mouse down event to compare against mouseup coordinates.
  /**
   @class Coral.Tag
   @classdesc A Tag component
   @htmltag coral-tag
   @extends {HTMLElement}
   @extends {BaseComponent}
   */


  var Tag = Decorator( /*#__PURE__*/function (_BaseComponent) {
    _inherits(_class, _BaseComponent);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this); // Attach events

      _this._delegateEvents({
        'click [handle="button"]': '_onRemoveButtonClick',
        'key:backspace': '_onRemoveButtonClick',
        'key:delete': '_onRemoveButtonClick'
      }); // Prepare templates


      _this._elements = {
        // Create or fetch the label element.
        label: _this.querySelector('coral-tag-label') || document.createElement('coral-tag-label')
      };
      template.call(_this._elements, {
        i18n: i18n,
        Icon: Icon
      });
      return _this;
    }
    /**
     The tag's label element.
      @type {TagLabel}
     @contentzone
     */


    _createClass(_class, [{
      key: "_toggleTagVariant",

      /**
       Toggle between Tag and Label styles
        @private
       */
      value: function _toggleTagVariant() {
        var _this$classList, _this$classList2;

        var isColored = this.color !== color.DEFAULT; // Base

        this.classList.toggle(CLASSNAME$4, !isColored);
        this.classList.toggle(LABEL_CLASSNAME, isColored); // Closable

        this.classList.toggle("".concat(CLASSNAME$4, "--deletable"), !isColored); // Quiet

        this.classList.toggle(QUIET_CLASSNAME, !isColored && this.quiet); // Size

        (_this$classList = this.classList).remove.apply(_this$classList, ALL_SIZE_CLASSES$1);

        this.classList.toggle("".concat(LABEL_CLASSNAME, "--").concat(swappedSize[this.size].toLowerCase()), isColored); // Color

        (_this$classList2 = this.classList).remove.apply(_this$classList2, ALL_COLOR_CLASSES);

        this.classList.toggle("".concat(LABEL_CLASSNAME, "--").concat(this.color), isColored);
      }
      /**
       Inherited from {@link BaseComponent#trackingElement}.
       */

    }, {
      key: "_onRemoveButtonClick",

      /** @private */
      value: function _onRemoveButtonClick(event) {
        event.preventDefault();

        if (this.closable && !this._elements.button.disabled) {
          event.stopPropagation();
          this.focus();
          var host = this._host;
          this.remove();

          if (host) {
            host._onTagButtonClicked(this, event);
          }
        }
      }
      /**
       Updates the aria-label property from the button and label elements.
        @ignore
       */

    }, {
      key: "_updateAriaLabel",
      value: function _updateAriaLabel() {
        var button = this._elements.button;
        var buttonCell = this._elements.buttonCell;
        var label = this._elements.label; // In the edge case that this is a Tag without a TagList,
        // just treat the Tag as a container element without special labelling.

        if (this.getAttribute('role') !== 'row') {
          buttonCell.removeAttribute('role');
          label.removeAttribute('role');

          if (this.getAttribute('aria-labelledby') === label.id) {
            this.removeAttribute('aria-labelledby');
          }

          return;
        }

        buttonCell.setAttribute('role', 'gridcell');
        label.setAttribute('role', this._closable ? 'rowheader' : 'gridcell');
        var buttonAriaLabel = button.getAttribute('title');
        var labelTextContent = label.textContent; // button should be labelled, "Remove: labelTextContent".

        button.setAttribute('aria-label', "".concat(buttonAriaLabel, ": ").concat(labelTextContent));

        if (!label.id) {
          label.id = commons.getUID();
        }

        this.setAttribute('aria-labelledby', label.id);
      }
    }, {
      key: "attributeChangedCallback",

      /** @ignore */
      value: function attributeChangedCallback(name, oldValue, value) {
        // This is required by TagList but we don't need to expose disabled publicly as API
        if (name === 'disabled') {
          this._elements.button.disabled = value;
        } // This is required by TagList but we don't need to expose disabled publicly as API
        else if (name === 'role') {
            this._updateAriaLabel();
          } else {
            _get(_getPrototypeOf(_class.prototype), "attributeChangedCallback", this).call(this, name, oldValue, value);
          }
      }
      /** @ignore */

    }, {
      key: "connectedCallback",
      value: function connectedCallback() {
        _get(_getPrototypeOf(_class.prototype), "connectedCallback", this).call(this); // Used to inform the tag list that it's added


        this.trigger('coral-tag:_connected');
      }
      /** @ignore */

    }, {
      key: "render",
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this); // Default reflected attributes


        if (!this._size) {
          this.size = size$2.MEDIUM;
        }

        if (!this._color) {
          this.color = color.DEFAULT;
        }

        var templateHandleNames = ['input', 'button', 'buttonCell'];
        var label = this._elements.label; // Remove it so we can process children

        if (label.parentNode) {
          this.removeChild(label);
        } // Process remaining elements as necessary


        while (this.firstChild) {
          var child = this.firstChild;

          if (child.nodeType === Node.TEXT_NODE || templateHandleNames.indexOf(child.getAttribute('handle')) === -1) {
            // Add non-template elements to the label
            label.appendChild(child);
          } else {
            // Remove anything else
            this.removeChild(child);
          }
        } // Assign the content zones, moving them into place in the process


        this.label = label;
      }
      /** @ignore */

    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        _get(_getPrototypeOf(_class.prototype), "disconnectedCallback", this).call(this); // Used to inform the tag list that it's removed synchronously


        if (this._host) {
          this._host._onItemDisconnected(this);
        }
      }
      /**
       Triggered when the {@link Tag} value is changed.
        @typedef {CustomEvent} coral-tag:_valuechanged
        @private
       */

      /**
       Triggered when the {@link Tag} is added to the document.
        @typedef {CustomEvent} coral-tag:_connected
        @private
       */

    }, {
      key: "label",
      get: function get() {
        return this._getContentZone(this._elements.label);
      },
      set: function set(value) {
        this._setContentZone('label', value, {
          handle: 'label',
          tagName: 'coral-tag-label',
          insert: function insert(label) {
            label.classList.add("".concat(CLASSNAME$4, "Label"));
            this.insertBefore(label, this.firstChild);

            this._updateAriaLabel();
          }
        });
      }
      /**
       Whether this component can be closed.
        @type {Boolean}
       @default false
       @htmlattribute closable
       @htmlattributereflected
       */

    }, {
      key: "closable",
      get: function get() {
        return this._closable || false;
      },
      set: function set(value) {
        this._closable = transform.booleanAttr(value);

        this._reflectAttribute('closable', this._closable); // Only tags are closable


        this._toggleTagVariant();

        if (this._closable && !this.contains(this._elements.buttonCell)) {
          // Insert the buttonCell if it was not added to the DOM
          this.appendChild(this._elements.buttonCell);
        }

        this._elements.button.hidden = !this._closable;
        this._elements.button.tabIndex = this._elements.button.hidden ? -1 : 0;
        this._elements.buttonCell.hidden = !this._closable;

        this._updateAriaLabel();
      }
      /**
       Value of the tag. If not explicitly set, the value of <code>Node.textContent</code> is returned.
        @type {String}
       @default ""
       @htmlattribute value
       @htmlattributereflected
       */

    }, {
      key: "value",
      get: function get() {
        return typeof this._value === 'string' ? this._value : this.textContent.replace(/\s{2,}/g, ' ').trim();
      },
      set: function set(value) {
        var _value = transform.string(value);

        this._value = _value;

        this._reflectAttribute('value', this._value);

        this.trigger('coral-tag:_valuechanged');
      }
      /**
       A quiet tag to differentiate it from default tag.
        @type {Boolean}
       @default false
       @htmlattribute quiet
       @htmlattributereflected
       */

    }, {
      key: "quiet",
      get: function get() {
        return this._quiet || false;
      },
      set: function set(value) {
        this._quiet = transform.booleanAttr(value);

        this._reflectAttribute('quiet', this._quiet); // Only tags are quiet


        this._toggleTagVariant();
      }
      /**
       A multiline tag for block-level layout with multiline text.
        @type {Boolean}
       @default false
       @htmlattribute multiline
       @htmlattributereflected
       */

    }, {
      key: "multiline",
      get: function get() {
        return this._multiline || false;
      },
      set: function set(value) {
        this._multiline = transform.booleanAttr(value);

        this._reflectAttribute('multiline', this._multiline);

        this.classList.toggle(MULTILINE_CLASSNAME, this._multiline);
      }
      /**
       The tag's size. See {@link {TagSizeEnum}. Only colored tags can have different sizes.
        @type {String}
       @default TagSizeEnum.MEDIUM
       @htmlattribute size
       @htmlattributereflected
       */

    }, {
      key: "size",
      get: function get() {
        return this._size || size$2.MEDIUM;
      },
      set: function set(value) {
        value = this._host ? size$2.MEDIUM : transform.string(value).toUpperCase();
        this._size = validate.enumeration(size$2)(value) && value || size$2.MEDIUM;

        this._reflectAttribute('size', this._size);

        this._toggleTagVariant();
      }
      /**
       The tags's color. See {@link TagColorEnum}.
        @type {String}
       @default Coral.Tag.color.DEFAULT
       @htmlattribute color
       @htmlattributereflected
       */

    }, {
      key: "color",
      get: function get() {
        return this._color || color.DEFAULT;
      },
      set: function set(value) {
        value = this._host ? color.DEFAULT : transform.string(value).toLowerCase();
        this._color = validate.enumeration(color)(value) && value || color.DEFAULT; // Map unsupported colors

        if (Object.keys(colorMap).indexOf(this._color) !== -1) {
          this._color = colorMap[this._color];
        }

        this._reflectAttribute('color', this._color);

        this._toggleTagVariant();
      }
    }, {
      key: "trackingElement",
      get: function get() {
        // it uses the name as the first fallback since it is not localized, otherwise it uses the label
        return typeof this._trackingElement === 'undefined' ? // keep spaces to only 1 max and trim. this mimics native html behaviors
        this.value || (this.label || this).textContent.replace(/\s{2,}/g, ' ').trim() : this._trackingElement;
      },
      set: function set(value) {
        _set(_getPrototypeOf(_class.prototype), "trackingElement", value, this, true);
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-tag-label': 'label'
        };
      }
      /**
       Returns {@link Tag} sizes.
        @return {TagSizeEnum}
       */

    }], [{
      key: "size",
      get: function get() {
        return size$2;
      }
      /**
       Returns {@link Tag} colors.
        @return {TagColorEnum}
       */

    }, {
      key: "color",
      get: function get() {
        return color;
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['closable', 'value', 'quiet', 'multiline', 'size', 'color', 'disabled', 'role']);
      }
    }]);

    return _class;
  }(BaseComponent(HTMLElement)));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Tag.Label
   @classdesc Tag's label component
   @htmltag coral-tag-label
   @return {HTMLElement}
   */
  var TagLabel = (function () {
    return document.createElement('coral-tag-label');
  });

  var CLASSNAME$5 = '_coral-Tags'; // Collection

  var ITEM_TAGNAME = 'coral-tag';
  /**
   Extracts the value from the item in case no explicit value was provided.
   @param {HTMLElement} item
   the item whose value will be extracted.
   @returns {String} the value that will be submitted for this item.
   @private
   */

  var itemValueFromDOM = function itemValueFromDOM(item) {
    var attr = item.getAttribute('value'); // checking explicitly for null allows to differentiate between non set values and empty strings

    return attr !== null ? attr : item.textContent.replace(/\s{2,}/g, ' ').trim();
  };
  /**
   @class Coral.TagList
   @classdesc A TagList component is a form field container to manipulate tags.
   @htmltag coral-taglist
   @extends {HTMLElement}
   @extends {BaseComponent}
   @extends {BaseFormField}
   */


  var TagList = Decorator( /*#__PURE__*/function (_BaseFormField) {
    _inherits(_class, _BaseFormField);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this); // Attach events

      _this._delegateEvents(commons.extend(_this._events, {
        'capture:focus coral-tag': '_onItemFocus',
        'capture:blur coral-tag': '_onItemBlur',
        'key:right coral-tag': '_onNextItemFocus',
        'key:down coral-tag': '_onNextItemFocus',
        'key:pagedown coral-tag': '_onNextItemFocus',
        'key:left coral-tag': '_onPreviousItemFocus',
        'key:up coral-tag': '_onPreviousItemFocus',
        'key:pageup coral-tag': '_onPreviousItemFocus',
        'key:home coral-tag': '_onFirstItemFocus',
        'key:end coral-tag': '_onLastItemFocus',
        // Accessibility
        'capture:focus coral-tag:not(.is-disabled)': '_onItemFocusIn',
        'capture:blur coral-tag:not(.is-disabled)': '_onItemFocusOut',
        // Private
        'coral-tag:_valuechanged': '_onTagValueChanged',
        'coral-tag:_connected': '_onTagConnected'
      })); // Pre-define labellable element


      _this._labellableElement = _assertThisInitialized(_this);
      _this._itemToFocusAfterDelete = null;
      return _this;
    }
    /**
     Changing the values will redefine the component's items.
      @type {Array.<String>}
     @emits {change}
     */


    _createClass(_class, [{
      key: "_attachInputToItem",

      /** @private */
      value: function _attachInputToItem(item) {
        if (!item._input) {
          item._input = document.createElement('input');
          item._input.type = 'hidden'; // We do this so it is recognized by Coral.Tag and handled if cloned

          item._input.setAttribute('handle', 'input');
        }

        var input = item._input;
        input.disabled = this.disabled;
        input.name = this.name;
        input.value = item.value;

        if (!item.contains(input)) {
          item.appendChild(input);
        }
      }
      /** @private */

    }, {
      key: "_prepareItem",
      value: function _prepareItem(attachedItem) {
        var items = this.items.getAll(); // Prevents to add duplicates based on the tag value

        var duplicate = items.some(function (tag) {
          if (itemValueFromDOM(tag) === itemValueFromDOM(attachedItem) && tag !== attachedItem) {
            (items.indexOf(tag) < items.indexOf(attachedItem) ? attachedItem : tag).remove();
            return true;
          }

          return false;
        });

        if (duplicate) {
          return;
        } // create corresponding input field


        this._attachInputToItem(attachedItem); // Set tag defaults


        attachedItem.setAttribute('color', Tag.color.DEFAULT);
        attachedItem.setAttribute('size', Tag.size.SMALL); // adds the role to support accessibility

        attachedItem.setAttribute('role', 'row'); // adds role to parent to support accessibility, if it doesn't already have it

        if (this.getAttribute('role') === null) {
          this.setAttribute('role', 'grid');
        }

        if (!this.disabled) {
          attachedItem.setAttribute('tabindex', '-1');
        }

        attachedItem[this.readOnly ? 'removeAttribute' : 'setAttribute']('closable', ''); // add tabindex to first item if none existing

        if (!this.disabled && !this.querySelector("".concat(ITEM_TAGNAME, "[tabindex=\"0\"]"))) {
          var first = items[0];

          if (first) {
            first.setAttribute('tabindex', '0');
          }
        } // Keep a reference on the host in case the tag gets removed


        attachedItem._host = this; // triggers the Coral.Collection event

        this.trigger('coral-collection:add', {
          item: attachedItem
        });
      }
      /** @private */

    }, {
      key: "_onItemDisconnected",
      value: function _onItemDisconnected(detachedItem) {
        var _this2 = this;

        // Cleans the tag from TagList specific values
        detachedItem.removeAttribute('role'); // Removes role from taglist if it has no tag elements

        if (this.items.length <= 0) {
          this.removeAttribute('role');
        }

        detachedItem.removeAttribute('tabindex');
        detachedItem._host = undefined;
        var parentElement = this.parentElement;

        if (this.items.length === 0 && parentElement) {
          // If all tags are removed, call focus method on parent element
          if (typeof parentElement.focus === 'function') {
            parentElement.focus();
          }

          var self = this;
          commons.nextFrame(function () {
            // if the parentElement did not receive focus or move focus to some other element
            if (document.activeElement.tagName === 'BODY') {
              if (_this2.items.length > 0) {
                self.items.first().focus();
              } else {
                // make the TagList focusable
                self.tabIndex = -1;
                self.classList.add('u-coral-screenReaderOnly');
                self.style.outline = '0';
                self.innerHTML = ' ';

                var onBlurFocusManagement = function onBlurFocusManagement() {
                  self.removeAttribute('tabindex');
                  self.classList.remove('u-coral-screenReaderOnly');
                  self.style.outline = '';
                  self.innerHTML = '';

                  self._vent.off('blur.focusManagement');
                };

                self._vent.on('blur.focusManagement', null, onBlurFocusManagement);

                if (!parentElement.contains(document.activeElement)) {
                  self.focus();
                } else {
                  onBlurFocusManagement();
                }
              }
            }
          });
        } else if (this._itemToFocusAfterDelete) {
          this._itemToFocusAfterDelete.focus();
        } // triggers the Coral.Collection event


        this.trigger('coral-collection:remove', {
          item: detachedItem
        });
      }
      /** @private */

    }, {
      key: "_onItemFocus",
      value: function _onItemFocus(event) {
        if (!this.disabled) {
          this.setAttribute('aria-live', 'polite');
          var tag = event.matchedTarget; // add tabindex to first item and remove from previous focused item

          this.items.getAll().forEach(function (item) {
            if (item !== tag) {
              item.setAttribute('tabindex', '-1');
            }
          });
          tag.setAttribute('tabindex', '0');

          this._setItemToFocusOnDelete(tag);
        }
      }
      /** @private */

    }, {
      key: "_onItemBlur",
      value: function _onItemBlur(event) {
        if (!this.disabled) {
          this.setAttribute('aria-live', 'off');
          var tag = event.matchedTarget;

          this._setItemToFocusOnDelete(tag);
        }
      }
      /** @private */

    }, {
      key: "_onSiblingItemFocus",
      value: function _onSiblingItemFocus(event, sibling) {
        if (!this.disabled) {
          event.preventDefault();
          var item = event.target[sibling];

          while (item) {
            if (item.tagName.toLowerCase() === ITEM_TAGNAME && !item.hidden) {
              item.focus();
              break;
            } else {
              item = item[sibling];
            }
          }
        }
      }
      /** @private */

    }, {
      key: "_onNextItemFocus",
      value: function _onNextItemFocus(event) {
        this._onSiblingItemFocus(event, 'nextElementSibling');
      }
      /** @private */

    }, {
      key: "_onPreviousItemFocus",
      value: function _onPreviousItemFocus(event) {
        this._onSiblingItemFocus(event, 'previousElementSibling');
      }
      /** @private */

    }, {
      key: "_onFirstItemFocus",
      value: function _onFirstItemFocus(event) {
        event.preventDefault();
        var length = this.items.length;

        if (length > 0) {
          this.items.getAll()[0].focus();
        }
      }
      /** @private */

    }, {
      key: "_onLastItemFocus",
      value: function _onLastItemFocus(event) {
        event.preventDefault();
        var length = this.items.length;

        if (length > 0) {
          this.items.getAll()[length - 1].focus();
        }
      }
    }, {
      key: "_onItemFocusIn",
      value: function _onItemFocusIn(event) {
        event.matchedTarget.classList.add('focus-ring');
      }
    }, {
      key: "_onItemFocusOut",
      value: function _onItemFocusOut(event) {
        event.matchedTarget.classList.remove('focus-ring');
      }
      /** @private */

    }, {
      key: "_onTagButtonClicked",
      value: function _onTagButtonClicked(item, event) {
        this.trigger('change');

        this._trackEvent('remove', 'coral-tag', event, item);
      }
      /** @private */

    }, {
      key: "_onTagValueChanged",
      value: function _onTagValueChanged(event) {
        event.stopImmediatePropagation();
        var tag = event.target;

        if (tag._input) {
          tag._input.value = tag.value;
        }
      }
      /** @private */

    }, {
      key: "_setItemToFocusOnDelete",
      value: function _setItemToFocusOnDelete(tag) {
        var _this3 = this;

        var itemToFocusAfterDelete = tag.nextElementSibling; // Next item will be focusable if the focused tag is removed

        while (itemToFocusAfterDelete) {
          if (itemToFocusAfterDelete.tagName.toLowerCase() === ITEM_TAGNAME && !itemToFocusAfterDelete.hidden) {
            this._itemToFocusAfterDelete = itemToFocusAfterDelete;
            return;
          }

          itemToFocusAfterDelete = itemToFocusAfterDelete.nextElementSibling;
        }

        itemToFocusAfterDelete = tag.previousElementSibling; // Previous item will be focusable if the focused tag is removed

        while (itemToFocusAfterDelete) {
          if (itemToFocusAfterDelete.tagName.toLowerCase() === ITEM_TAGNAME && !itemToFocusAfterDelete.hidden) {
            this._itemToFocusAfterDelete = itemToFocusAfterDelete;
            break;
          } else {
            itemToFocusAfterDelete = itemToFocusAfterDelete.previousElementSibling;
          }
        }

        window.requestAnimationFrame(function () {
          if (tag.parentElement !== null && !_this3.contains(document.activeElement)) {
            itemToFocusAfterDelete = undefined;
          }
        });
      }
      /** @private */

    }, {
      key: "_onTagConnected",
      value: function _onTagConnected(event) {
        event.stopImmediatePropagation();
        var item = event.target;

        this._prepareItem(item);
      }
      /**
       Inherited from {@link BaseFormField#reset}.
       */

    }, {
      key: "reset",
      value: function reset() {
        // reset the values to the initial values
        this.values = this._initialValues;
      }
      /** @ignore */

    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        var _this4 = this;

        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$5); // adds the role to support accessibility

        if (this.items.length > 0) {
          this.setAttribute('role', 'grid');
        } else {
          this.removeAttribute('role');
        }
        this.setAttribute('aria-live', 'off');
        this.setAttribute('aria-atomic', 'false');
        this.setAttribute('aria-relevant', 'additions'); // Since tagList can have multiple values, we have to store them all to be able to reset them

        if (this.hasAttribute('value')) {
          this._initialValues = [this.getAttribute('value')];
        } else {
          this._initialValues = this.items.getAll().map(function (item) {
            return itemValueFromDOM(item);
          });
        } // Prepare items


        this.items.getAll().forEach(function (item) {
          _this4._prepareItem(item);
        });
      }
    }, {
      key: "values",
      get: function get() {
        return this.items.getAll().map(function (item) {
          return item.value;
        });
      },
      set: function set(values) {
        var _this5 = this;

        if (Array.isArray(values)) {
          this.items.clear();
          values.forEach(function (value) {
            var item = new Tag().set({
              label: {
                innerHTML: value
              },
              value: value
            });

            _this5._attachInputToItem(item);

            _this5.items.add(item);
          });
        }
      }
      /**
       The Collection Interface that allows interacting with the items that the component contains.
        @type {Collection}
       @readonly
       */

    }, {
      key: "items",
      get: function get() {
        // just init on demand
        if (!this._items) {
          this._items = new Collection$1({
            host: this,
            itemTagName: ITEM_TAGNAME
          });
        }

        return this._items;
      }
      /**
       Name used to submit the data in a form.
       @type {String}
       @default ""
       @htmlattribute name
       @htmlattributereflected
       */

    }, {
      key: "name",
      get: function get() {
        return this._name || '';
      },
      set: function set(value) {
        var _this6 = this;

        this._name = transform.string(value);

        this._reflectAttribute('name', value);

        this.items.getAll().forEach(function (item) {
          if (item._input) {
            item._input.name = _this6._name;
          }
        });
      }
      /**
       This field's current value.
       @type {String}
       @default ""
       @htmlattribute value
       */

    }, {
      key: "value",
      get: function get() {
        var all = this.items.getAll();
        return all.length ? all[0].value : '';
      },
      set: function set(value) {
        this.items.clear();

        if (value) {
          var item = new Tag().set({
            label: {
              innerHTML: value
            },
            value: value
          });

          this._attachInputToItem(item);

          this.items.add(item);
        }
      }
      /**
       Whether this field is disabled or not.
       @type {Boolean}
       @default false
       @htmlattribute disabled
       @htmlattributereflected
       */

    }, {
      key: "disabled",
      get: function get() {
        return this._disabled || false;
      },
      set: function set(value) {
        var _this7 = this;

        this._disabled = transform.booleanAttr(value);

        this._reflectAttribute('disabled', this._disabled);

        this.items.getAll().forEach(function (item) {
          item.classList.toggle('is-disabled', _this7._disabled);

          if (item._input) {
            item._input.disabled = _this7._disabled;
          }
        }); // a11y

        this[this._disabled ? 'setAttribute' : 'removeAttribute']('aria-disabled', this._disabled);
      } // JSDoc inherited

    }, {
      key: "invalid",
      get: function get() {
        return _get(_getPrototypeOf(_class.prototype), "invalid", this);
      },
      set: function set(value) {
        var _this8 = this;

        _set(_getPrototypeOf(_class.prototype), "invalid", value, this, true);

        this.items.getAll().forEach(function (item) {
          item.classList.toggle('is-invalid', _this8._invalid);
        });
      }
      /**
       Whether this field is readOnly or not. Indicating that the user cannot modify the value of the control.
       @type {Boolean}
       @default false
       @htmlattribute readonly
       @htmlattributereflected
       */

    }, {
      key: "readOnly",
      get: function get() {
        return this._readOnly || false;
      },
      set: function set(value) {
        var _this9 = this;

        this._readOnly = transform.booleanAttr(value);

        this._reflectAttribute('readonly', this._readOnly);

        this.items.getAll().forEach(function (item) {
          item.closable = !_this9._readOnly;
        });
      }
      /**
       Whether this field is required or not.
       @type {Boolean}
       @default false
       @htmlattribute required
       @htmlattributereflected
       */

    }, {
      key: "required",
      get: function get() {
        return this._required || false;
      },
      set: function set(value) {
        this._required = transform.booleanAttr(value);

        this._reflectAttribute('required', this._required);
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['closable', 'value', 'quiet', 'multiline', 'size', 'color']);
      }
    }]);

    return _class;
  }(BaseFormField(BaseComponent(HTMLElement))));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons.extend(strings, {
    'coral-component-taglist': translations$2
  }); // Expose component on the Coral namespace

  commons._define('coral-tag', Tag);

  commons._define('coral-taglist', TagList);

  Tag.Label = TagLabel;

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var translations$3 = {
    "en-US": {
      "List": "List"
    },
    "fr-FR": {
      "List": "Liste"
    },
    "de-DE": {
      "List": "Liste"
    },
    "it-IT": {
      "List": "Elenco"
    },
    "es-ES": {
      "List": "Mostrar"
    },
    "pt-BR": {
      "List": "Lista"
    },
    "ja-JP": {
      "List": "リスト"
    },
    "ko-KR": {
      "List": "목록"
    },
    "zh-CN": {
      "List": "列表"
    },
    "zh-TW": {
      "List": "清單"
    },
    "nl-NL": {
      "List": "Lijst"
    },
    "da-DK": {
      "List": "Liste"
    },
    "fi-FI": {
      "List": "Lista"
    },
    "nb-NO": {
      "List": "Liste"
    },
    "sv-SE": {
      "List": "Lista"
    },
    "cs-CZ": {
      "List": "Seznam"
    },
    "pl-PL": {
      "List": "Lista"
    },
    "ru-RU": {
      "List": "список"
    },
    "tr-TR": {
      "List": "Liste"
    }
  };

  var CLASSNAME$6 = '_coral-Menu';
  /**
   Enumeration for {@link BaseList} interactions.

   @typedef {Object} ListInteractionEnum

   @property {String} ON
   Keyboard interaction is enabled.
   @property {String} OFF
   Keyboard interaction is disabled.
   */

  var interaction = {
    ON: 'on',
    OFF: 'off'
  };
  /**
   @base BaseList
   @classdesc The base element for List components
   */

  var BaseList = function BaseList(superClass) {
    return /*#__PURE__*/function (_superClass) {
      _inherits(_class, _superClass);

      var _super = _createSuper(_class);

      /** @ignore */
      function _class() {
        var _this;

        _classCallCheck(this, _class);

        _this = _super.call(this);
        _this._events = {
          'mouseenter': '_onMouseEnter',
          // Keyboard interaction
          'key:down [coral-list-item]': '_focusNextItem',
          'key:right [coral-list-item]': '_focusNextItem',
          'key:left [coral-list-item]': '_focusPreviousItem',
          'key:up [coral-list-item]': '_focusPreviousItem',
          'key:pageup [coral-list-item]': '_focusPreviousItem',
          'key:pagedown [coral-list-item]': '_focusNextItem',
          'key:home [coral-list-item]': '_focusFirstItem',
          'key:end [coral-list-item]': '_focusLastItem'
        };
        return _this;
      }
      /**
       The Collection Interface that allows interacting with the items that the component contains.
        @type {SelectableCollection}
       @readonly
       */


      _createClass(_class, [{
        key: "_eventIsAtTarget",

        /**
         Returns true if the event is at the matched target.
          @private
         */
        value: function _eventIsAtTarget(event) {
          var target = event.target;
          var listItem = event.matchedTarget;
          var isAtTarget = target === listItem;

          if (isAtTarget) {
            // Don't let arrow keys etc scroll the page
            event.preventDefault();
          }

          return isAtTarget;
        }
      }, {
        key: "_onMouseEnter",
        value: function _onMouseEnter() {
          if (this.contains(document.activeElement)) {
            document.activeElement.blur();
          }
        }
        /** @private */

      }, {
        key: "_focusFirstItem",
        value: function _focusFirstItem(event) {
          if (this.interaction === interaction.OFF || !this._eventIsAtTarget(event)) {
            return;
          }

          var items = this._getSelectableItems();

          items[0].focus();
        }
        /** @private */

      }, {
        key: "_focusLastItem",
        value: function _focusLastItem(event) {
          if (this.interaction === interaction.OFF || !this._eventIsAtTarget(event)) {
            return;
          }

          var items = this._getSelectableItems();

          items[items.length - 1].focus();
        }
        /** @private */

      }, {
        key: "_focusNextItem",
        value: function _focusNextItem(event) {
          if (this.interaction === interaction.OFF || !this._eventIsAtTarget(event)) {
            return;
          }

          var target = event.matchedTarget;

          var items = this._getSelectableItems();

          var index = items.indexOf(target);

          if (index === -1) {
            // Invalid state
            return;
          }

          if (index < items.length - 1) {
            items[index + 1].focus();
          } else {
            items[0].focus();
          }
        }
        /** @private */

      }, {
        key: "_focusPreviousItem",
        value: function _focusPreviousItem(event) {
          if (this.interaction === interaction.OFF || !this._eventIsAtTarget(event)) {
            return;
          }

          var target = event.matchedTarget;

          var items = this._getSelectableItems();

          var index = items.indexOf(target);

          if (index === -1) {
            // Invalid state
            return;
          }

          if (index > 0) {
            items[index - 1].focus();
          } else {
            items[items.length - 1].focus();
          }
        }
        /** @private */

      }, {
        key: "_getSelectableItems",
        value: function _getSelectableItems() {
          // Also checks if item is visible
          return this.items._getSelectableItems().filter(function (item) {
            return !item.hasAttribute('hidden') && item.offsetParent;
          });
        }
        /** @ignore */

      }, {
        key: "focus",
        value: function focus() {
          if (!this.contains(document.activeElement)) {
            var items = this._getSelectableItems();

            if (items.length > 0) {
              items[0].focus();
            }
          }
        }
        /**
         Returns {@link BaseList} interaction options.
          @return {ListInteractionEnum}
         */

      }, {
        key: "render",

        /** @ignore */
        value: function render() {
          _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

          this.classList.add(CLASSNAME$6); // Default reflected attributes

          if (!this._interaction) {
            this.interaction = interaction.ON;
          }
        }
      }, {
        key: "items",
        get: function get() {
          // Construct the collection on first request:
          if (!this._items) {
            this._items = new SelectableCollection({
              itemTagName: this._itemTagName,
              itemBaseTagName: this._itemBaseTagName,
              itemSelector: 'coral-list-item, button[is="coral-buttonlist-item"], a[is="coral-anchorlist-item"]',
              host: this
            });
          }

          return this._items;
        }
        /** @private */

      }, {
        key: "_itemTagName",
        get: function get() {
          // Used for Collection
          return 'coral-list-item';
        }
        /**
         Whether interaction with the component is enabled. See {@link ListInteractionEnum}.
          @type {String}
         @default ListInteractionEnum.ON
         @htmlattribute interaction
         @htmlattributereflected
         */

      }, {
        key: "interaction",
        get: function get() {
          return this._interaction || interaction.ON;
        },
        set: function set(value) {
          value = transform.string(value).toLowerCase();
          this._interaction = validate.enumeration(interaction)(value) && value || interaction.ON;

          this._reflectAttribute('interaction', this._interaction);
        }
      }], [{
        key: "interaction",
        get: function get() {
          return interaction;
        }
        /** @ignore */

      }, {
        key: "observedAttributes",
        get: function get() {
          return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['interaction']);
        }
      }]);

      return _class;
    }(superClass);
  };

  var CLASSNAME$7 = '_coral-Menu-item';
  /**
   @base BaseListItem
   @classdesc The base element for List Item components
   */

  var BaseListItem = function BaseListItem(superClass) {
    return /*#__PURE__*/function (_BaseLabellable) {
      _inherits(_class, _BaseLabellable);

      var _super = _createSuper(_class);

      /** @ignore */
      function _class() {
        var _thisSuper, _this;

        _classCallCheck(this, _class);

        _this = _super.call(this); // Templates

        _this._elements = {
          // Fetch or create the content zone element
          content: _this.querySelector('coral-list-item-content') || document.createElement('coral-list-item-content')
        };

        _get((_thisSuper = _assertThisInitialized(_this), _getPrototypeOf(_class.prototype)), "_observeLabel", _thisSuper).call(_thisSuper);

        return _this;
      }
      /**
       The content of the help item.
        @type {ListItemContent}
       @contentzone
       */


      _createClass(_class, [{
        key: "_getIconElement",
        value: function _getIconElement() {
          if (!this._elements.icon) {
            this._elements.icon = this.querySelector('._coral-Menu-item-icon') || new Icon();
            this._elements.icon.size = Icon.size.SMALL;

            this._elements.icon.classList.add('_coral-Menu-item-icon');
          }

          return this._elements.icon;
        }
      }, {
        key: "render",

        /** @ignore */
        value: function render() {
          _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

          this.classList.add(CLASSNAME$7); // The attribute that makes different types of list items co-exist
          // This is also used for event delegation

          this.setAttribute('coral-list-item', ''); // Fetch or create the content content zone element

          var content = this._elements.content; // This stops the content zone from being voracious

          if (!content.parentNode) {
            // move the contents of the item into the content zone
            while (this.firstChild) {
              content.appendChild(this.firstChild);
            }
          } // Assign the content zones, moving them into place in the process


          this.icon = this.icon;
          this.content = content;
        }
      }, {
        key: "content",
        get: function get() {
          return this._getContentZone(this._elements.content);
        },
        set: function set(value) {
          var _this2 = this;

          this._setContentZone('content', value, {
            handle: 'content',
            tagName: 'coral-list-item-content',
            insert: function insert(content) {
              content.classList.add("".concat(CLASSNAME$7, "Label"));

              _this2.appendChild(content);

              _get(_getPrototypeOf(_class.prototype), "_toggleIconAriaHidden", _this2).call(_this2);
            }
          });
        }
        /**
         Whether this item is disabled.
          @default false
         @type {Boolean}
         @htmlattribute disabled
         @htmlattributereflected
         */

      }, {
        key: "disabled",
        get: function get() {
          return this._disabled || false;
        },
        set: function set(value) {
          value = transform.booleanAttr(value);

          this._reflectAttribute('disabled', value);

          if (validate.valueMustChange(this._disabled, value)) {
            this._disabled = value;
            this.classList.toggle('is-disabled', value);
            this[value ? 'setAttribute' : 'removeAttribute']('aria-disabled', value);
          }
        }
        /**
         The icon to display. See {@link Icon}.
          @type {String}
         @default ""
         @htmlattribute icon
         */

      }, {
        key: "icon",
        get: function get() {
          var el = this._getIconElement();

          return el.icon;
        },
        set: function set(value) {
          var el = this._getIconElement();

          if (transform.string(value) === '') {
            el.remove();
          } else {
            this.insertBefore(el, this.firstChild);
          }

          el.icon = value;

          _get(_getPrototypeOf(_class.prototype), "_toggleIconAriaHidden", this).call(this);
        }
      }, {
        key: "_contentZones",
        get: function get() {
          return {
            'coral-list-item-content': 'content'
          };
        }
        /** @ignore */

      }], [{
        key: "observedAttributes",
        get: function get() {
          return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['disabled', 'icon']);
        }
      }]);

      return _class;
    }(BaseLabellable(superClass));
  };

  /**
   @class Coral.List
   @classdesc A List component that supports multi-line text, icons, and text wrapping with ellipsis.
   @htmltag coral-list
   @extends {HTMLElement}
   @extends {BaseComponent}
   @extends {BaseList}
   */

  var List = Decorator( /*#__PURE__*/function (_BaseList) {
    _inherits(_class, _BaseList);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this); // Events

      _this._delegateEvents(_this._events);

      return _this;
    }

    return _class;
  }(BaseList(BaseComponent(HTMLElement))));

  var CLASSNAME$8 = '_coral-Menu-divider';
  /**
   @class Coral.List.Divider
   @classdesc The List divider
   @htmltag coral-list-divider
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var ListDivider = Decorator( /*#__PURE__*/function (_BaseComponent) {
    _inherits(_class, _BaseComponent);

    var _super = _createSuper(_class);

    function _class() {
      _classCallCheck(this, _class);

      return _super.apply(this, arguments);
    }

    _createClass(_class, [{
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$8); // a11y

        this.setAttribute('role', 'separator');
      }
    }]);

    return _class;
  }(BaseComponent(HTMLElement)));

  /**
   @class Coral.List.Item
   @classdesc A List item component
   @htmltag coral-list-item
   @extends {HTMLElement}
   @extends {BaseComponent}
   @extends {BaseListItem}
   */

  var ListItem = Decorator( /*#__PURE__*/function (_BaseListItem) {
    _inherits(_class, _BaseListItem);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this); // Events

      _this._delegateEvents(_this._events);

      return _this;
    }

    return _class;
  }(BaseListItem(BaseComponent(HTMLElement))));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.List.Item.Content
   @classdesc The List item content
   @htmltag coral-list-item-content
   @return {HTMLElement}
   */
  var ListItemContent = (function () {
    return document.createElement('coral-list-item-content');
  });

  var CLASSNAME$9 = '_coral-AnchorList';
  /**
   @class Coral.AnchorList
   @classdesc An AnchorList component that supports multi-line text, icons, and text wrapping with ellipsis.
   @htmltag coral-anchorlist
   @extends {HTMLElement}
   @extends {BaseComponent}
   @extends {BaseList}
   */

  var AnchorList = Decorator( /*#__PURE__*/function (_BaseList) {
    _inherits(_class, _BaseList);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this); // Events

      _this._delegateEvents(commons.extend(_this._events, {
        'click [coral-list-item]': '_onItemClick'
      }));

      return _this;
    }
    /** @private */


    _createClass(_class, [{
      key: "_onItemClick",
      value: function _onItemClick(event) {
        this._trackEvent('click', 'coral-anchorlist-item', event, event.matchedTarget);
      }
      /** @ignore */

    }, {
      key: "render",
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$9);
      }
    }, {
      key: "_itemTagName",
      get: function get() {
        // Used for Collection
        return 'coral-anchorlist-item';
      }
      /** @private */

    }, {
      key: "_itemBaseTagName",
      get: function get() {
        // Used for Collection
        return 'a';
      }
    }]);

    return _class;
  }(BaseList(BaseComponent(HTMLElement))));

  var CLASSNAME$a = '_coral-AnchorList-item';
  /**
   @class Coral.AnchorList.Item
   @classdesc An AnchorList item component
   @htmltag coral-anchorlist-item
   @extends {HTMLAnchorElement}
   @extends {BaseComponent}
   @extends {BaseListItem}
   */

  var AnchorListItem = Decorator( /*#__PURE__*/function (_BaseListItem) {
    _inherits(_class, _BaseListItem);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this); // Events

      _this._delegateEvents({
        click: '_onClick'
      });

      return _this;
    }
    /**
     Whether this field is disabled or not.
     @type {Boolean}
     @default false
     @htmlattribute disabled
     @htmlattributereflected
     */


    _createClass(_class, [{
      key: "_onClick",

      /** @private */
      value: function _onClick(event) {
        // Support disabled property
        if (this.disabled) {
          event.preventDefault();
        }
      }
      /** @ignore */

    }, {
      key: "render",
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$a);
      }
    }, {
      key: "disabled",
      get: function get() {
        return _get(_getPrototypeOf(_class.prototype), "disabled", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(_class.prototype), "disabled", value, this, true);

        if (this.disabled) {
          // It's not tabbable anymore
          this.setAttribute('tabindex', '-1');
        } else {
          // Now it's tabbable
          this.setAttribute('tabindex', '0');
        }
      }
      /**
       Inherited from {@link BaseComponent#trackingElement}.
       */

    }, {
      key: "trackingElement",
      get: function get() {
        return typeof this._trackingElement === 'undefined' ? // keep spaces to only 1 max and trim. this mimics native html behaviors
        (this.content || this).textContent.replace(/\s{2,}/g, ' ').trim() : this._trackingElement;
      },
      set: function set(value) {
        _set(_getPrototypeOf(_class.prototype), "trackingElement", value, this, true);
      }
    }]);

    return _class;
  }(BaseListItem(BaseComponent(HTMLAnchorElement))));

  var CLASSNAME$b = '_coral-ButtonList';
  /**
   @class Coral.ButtonList
   @classdesc A ButtonList component that supports multi-line text, icons, and text wrapping with ellipsis.
   @htmltag coral-buttonlist
   @extends {HTMLElement}
   @extends {BaseComponent}
   @extends {BaseList}
   */

  var ButtonList = Decorator( /*#__PURE__*/function (_BaseList) {
    _inherits(_class, _BaseList);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this); // Events

      _this._delegateEvents(commons.extend(_this._events, {
        'click [coral-list-item]': '_onItemClick'
      }));

      return _this;
    }
    /** @private */


    _createClass(_class, [{
      key: "_onItemClick",
      value: function _onItemClick(event) {
        this._trackEvent('click', 'coral-buttonlist-item', event, event.matchedTarget);
      }
      /** @ignore */

    }, {
      key: "render",
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$b);
      }
    }, {
      key: "_itemTagName",
      get: function get() {
        // Used for Collection
        return 'coral-buttonlist-item';
      }
      /** @private */

    }, {
      key: "_itemBaseTagName",
      get: function get() {
        // Used for Collection
        return 'button';
      }
    }]);

    return _class;
  }(BaseList(BaseComponent(HTMLElement))));

  var CLASSNAME$c = '_coral-ButtonList-item';
  /**
   @class Coral.ButtonList.Item
   @classdesc An ButtonList item component
   @htmltag coral-buttonlist-item
   @extends {HTMLButtonElement}
   @extends {BaseComponent}
   @extends {BaseListItem}
   */

  var ButtonListItem = Decorator( /*#__PURE__*/function (_BaseListItem) {
    _inherits(_class, _BaseListItem);

    var _super = _createSuper(_class);

    function _class() {
      _classCallCheck(this, _class);

      return _super.apply(this, arguments);
    }

    _createClass(_class, [{
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$c);
      }
    }, {
      key: "trackingElement",

      /**
       Inherited from {@link BaseComponent#trackingElement}.
       */
      get: function get() {
        return typeof this._trackingElement === 'undefined' ? // keep spaces to only 1 max and trim. this mimics native html behaviors
        (this.content || this).textContent.replace(/\s{2,}/g, ' ').trim() : this._trackingElement;
      },
      set: function set(value) {
        _set(_getPrototypeOf(_class.prototype), "trackingElement", value, this, true);
      }
    }]);

    return _class;
  }(BaseListItem(BaseComponent(HTMLButtonElement))));

  var template$1 = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["track"] = document.createElement("div");
    el0.setAttribute("handle", "track");
    el0.className += " _coral-CircleLoader-track";
    frag.appendChild(el0);
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    var el2 = this["fills"] = document.createElement("div");
    el2.setAttribute("handle", "fills");
    el2.className += " _coral-CircleLoader-fills";
    var el3 = document.createTextNode("\n  ");
    el2.appendChild(el3);
    var el4 = document.createElement("div");
    el4.className += " _coral-CircleLoader-fillMask1";
    var el5 = document.createTextNode("\n    ");
    el4.appendChild(el5);
    var el6 = this["subMask1"] = document.createElement("div");
    el6.setAttribute("handle", "subMask1");
    el6.className += " _coral-CircleLoader-fillSubMask1";
    var el7 = document.createTextNode("\n      ");
    el6.appendChild(el7);
    var el8 = document.createElement("div");
    el8.className += " _coral-CircleLoader-fill";
    el6.appendChild(el8);
    var el9 = document.createTextNode("\n    ");
    el6.appendChild(el9);
    el4.appendChild(el6);
    var el10 = document.createTextNode("\n  ");
    el4.appendChild(el10);
    el2.appendChild(el4);
    var el11 = document.createTextNode("\n  ");
    el2.appendChild(el11);
    var el12 = document.createElement("div");
    el12.className += " _coral-CircleLoader-fillMask2";
    var el13 = document.createTextNode("\n    ");
    el12.appendChild(el13);
    var el14 = this["subMask2"] = document.createElement("div");
    el14.setAttribute("handle", "subMask2");
    el14.className += " _coral-CircleLoader-fillSubMask2";
    var el15 = document.createTextNode("\n      ");
    el14.appendChild(el15);
    var el16 = document.createElement("div");
    el16.className += " _coral-CircleLoader-fill";
    el14.appendChild(el16);
    var el17 = document.createTextNode("\n    ");
    el14.appendChild(el17);
    el12.appendChild(el14);
    var el18 = document.createTextNode("\n  ");
    el12.appendChild(el18);
    el2.appendChild(el12);
    var el19 = document.createTextNode("\n");
    el2.appendChild(el19);
    frag.appendChild(el2);
    var el20 = document.createTextNode("\n\n");
    frag.appendChild(el20);
    return frag;
  };

  /**
   Enumeration for {@link Wait} variants.

   @typedef {Object} WaitVariantEnum

   @property {String} DEFAULT
   The default variant.
   @property {String} DOTS
   Not supported. Falls back to DEFAULT.
   */

  var variant$3 = {
    DEFAULT: 'default',
    DOTS: 'dots'
  };
  /**
   Enumeration for {@link Wait} sizes.

   @typedef {Object} WaitSizeEnum

   @property {String} SMALL
   A small wait indicator.
   @property {String} MEDIUM
   A medium wait indicator. This is the default size.
   @property {String} LARGE
   A large wait indicator.
   */

  var size$3 = {
    SMALL: 'S',
    MEDIUM: 'M',
    LARGE: 'L'
  }; // the waits's base classname

  var CLASSNAME$d = '_coral-CircleLoader';
  /**
   @class Coral.Wait
   @classdesc A Wait component to be used to indicate a process that is in-progress for an indefinite amount of time.
   When the time is known, {@link Progress} should be used instead.
   @htmltag coral-wait
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var Wait = Decorator( /*#__PURE__*/function (_BaseComponent) {
    _inherits(_class, _BaseComponent);

    var _super = _createSuper(_class);

    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this); // Prepare templates

      _this._elements = {};
      template$1.call(_this._elements);
      return _this;
    }
    /**
     The size of the wait indicator. Currently 'S' (the default), 'M' and 'L' are available.
     See {@link WaitSizeEnum}.
      @type {String}
     @default WaitSizeEnum.MEDIUM
     @htmlattribute size
     @htmlattributereflected
     */


    _createClass(_class, [{
      key: "attributeChangedCallback",

      /** @ignore */
      value: function attributeChangedCallback(name, oldValue, value) {
        if (name === 'indeterminate' && transform.booleanAttr(value)) {
          // Remember current value in case indeterminate is toggled back
          this._oldValue = this._value || 0;
        }

        _get(_getPrototypeOf(_class.prototype), "attributeChangedCallback", this).call(this, name, oldValue, value);
      }
      /** @ignore */

    }, {
      key: "render",
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$d); // ARIA

        this.setAttribute('role', 'progressbar'); // Default reflected attributes

        if (!this._size) {
          this.size = size$3.MEDIUM;
        }

        if (!this._variant) {
          this.variant = variant$3.DEFAULT;
        } // If no value is specified, indeterminate is set


        if (!this._value) {
          this.indeterminate = true;
        } // Centering reads the size


        if (this.centered) {
          this.centered = this.centered;
        } // Support cloneNode


        var template = this.querySelectorAll('._coral-CircleLoader-track, ._coral-CircleLoader-fills');

        for (var i = 0; i < template.length; i++) {
          template[i].remove();
        } // Render template


        this.appendChild(this._elements.track);
        this.appendChild(this._elements.fills);
      }
      /**
       Triggered when the {@link Wait} value is changed.
        @typedef {CustomEvent} coral-wait:change
       */

    }, {
      key: "size",
      get: function get() {
        return this._size || size$3.MEDIUM;
      },
      set: function set(value) {
        value = transform.string(value).toUpperCase();
        this._size = validate.enumeration(size$3)(value) && value || size$3.MEDIUM;

        this._reflectAttribute('size', this._size); // large css change


        this.classList.toggle("".concat(CLASSNAME$d, "--large"), this._size === size$3.LARGE); // small css change

        this.classList.toggle("".concat(CLASSNAME$d, "--small"), this._size === size$3.SMALL);
      }
      /**
       Whether the component is centered or not. The container needs to have the style <code>position: relative</code>
       for the centering to work correctly.
       @type {Boolean}
       @default false
       @htmlattribute centered
       @htmlattributereflected
       */

    }, {
      key: "centered",
      get: function get() {
        return this._centered || false;
      },
      set: function set(value) {
        this._centered = transform.booleanAttr(value);

        this._reflectAttribute('centered', this._centered);

        this.classList.toggle("".concat(CLASSNAME$d, "--centered"), this._centered);
      }
      /**
       The wait's variant. See {@link WaitVariantEnum}.
        @type {String}
       @default WaitVariantEnum.DEFAULT
       @htmlattribute variant
       @htmlattributereflected
       */

    }, {
      key: "variant",
      get: function get() {
        return this._variant || variant$3.DEFAULT;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        this._variant = validate.enumeration(variant$3)(value) && value || variant$3.DEFAULT;

        this._reflectAttribute('variant', this._variant);
      }
      /**
       Whether to hide the current value and show an animation. Set to true for operations whose progress cannot be
       determined.
        @type {Boolean}
       @default false
       @htmlattribute indeterminate
       @htmlattributereflected
       */

    }, {
      key: "indeterminate",
      get: function get() {
        return this._indeterminate || false;
      },
      set: function set(value) {
        this._indeterminate = transform.booleanAttr(value);

        this._reflectAttribute('indeterminate', this._indeterminate);

        if (this._indeterminate) {
          this.classList.add("".concat(CLASSNAME$d, "--indeterminate")); // ARIA: Remove attributes

          this.removeAttribute('aria-valuenow');
          this.removeAttribute('aria-valuemin');
          this.removeAttribute('aria-valuemax');
          this.value = 0;
        } else {
          this.classList.remove("".concat(CLASSNAME$d, "--indeterminate")); // ARIA: Add attributes

          this.setAttribute('aria-valuemin', '0');
          this.setAttribute('aria-valuemax', '100');
          this.value = this._oldValue;
        }
      }
      /**
       The current progress in percent. If no value is set on initialization, wait is forced into indeterminate state.
        @type {Number}
       @default 0
       @emits {coral-wait:change}
       @htmlattribute value
       @htmlattributereflected
       */

    }, {
      key: "value",
      get: function get() {
        return this.hasAttribute('indeterminate') ? 0 : this._value || 0;
      },
      set: function set(value) {
        value = transform.number(value) || 0; // Stay within bounds

        if (value > 100) {
          value = 100;
        } else if (value < 0) {
          value = 0;
        }

        this._value = value;

        this._reflectAttribute('value', this._value);

        var subMask1 = this._elements.subMask1;
        var subMask2 = this._elements.subMask2;

        if (!this.hasAttribute('indeterminate')) {
          var angle;

          if (value > 0 && value <= 50) {
            angle = -180 + value / 50 * 180;
            subMask1.style.transform = "rotate(".concat(angle, "deg)");
            subMask2.style.transform = 'rotate(-180deg)';
          } else if (value > 50) {
            angle = -180 + (value - 50) / 50 * 180;
            subMask1.style.transform = 'rotate(0deg)';
            subMask2.style.transform = "rotate(".concat(angle, "deg)");
          } else {
            subMask1.style.transform = '';
            subMask2.style.transform = '';
          } // ARIA: Reflect value for screenreaders


          this.setAttribute('aria-valuenow', this._value);
          this.setAttribute('aria-valuemin', '0');
          this.setAttribute('aria-valuemax', '100');
        } else {
          subMask1.style.transform = '';
          subMask2.style.transform = '';
        }

        this.trigger('coral-wait:change');
      }
      /**
       Returns {@link Wait} sizes.
        @return {WaitSizeEnum}
       */

    }], [{
      key: "size",
      get: function get() {
        return size$3;
      }
      /**
       Returns {@link Wait} variants.
        @return {WaitVariantEnum}
       */

    }, {
      key: "variant",
      get: function get() {
        return variant$3;
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['size', 'centered', 'variant', 'value', 'indeterminate']);
      }
    }]);

    return _class;
  }(BaseComponent(HTMLElement)));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons._define('coral-wait', Wait);

  var template$2 = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["loadIndicator"] = document.createElement("div");
    el0.setAttribute("handle", "loadIndicator");
    el0.className += " _coral-SelectList-loading";
    var el1 = document.createTextNode("\n  ");
    el0.appendChild(el1);
    var el2 = document.createElement("coral-wait");
    el2.setAttribute("centered", "");
    el0.appendChild(el2);
    var el3 = document.createTextNode("\n");
    el0.appendChild(el3);
    frag.appendChild(el0);
    var el4 = document.createTextNode("\n");
    frag.appendChild(el4);
    return frag;
  };

  var KEYPRESS_TIMEOUT_DURATION = 1000;
  /**
   The distance, in pixels, from the bottom of the SelectList at which we trigger a scrollbottom event. For example, a
   value of 50 would indicate a scrollbottom event should be triggered when the user scrolls to within 50 pixels of the
   bottom.

   @type {Number}
   @ignore
   */

  var SCROLL_BOTTOM_THRESHOLD = 50;
  /**
   The number of milliseconds for which scroll events should be debounced.

   @type {Number}
   @ignore
   */

  var SCROLL_DEBOUNCE = 100;
  /** @ignore */

  var ITEM_TAG_NAME = 'coral-selectlist-item';
  /** @ignore */

  var GROUP_TAG_NAME = 'coral-selectlist-group';
  var CLASSNAME$e = '_coral-Menu';
  /**
   @class Coral.SelectList
   @classdesc A SelectList component is a selectable list of items.
   @htmltag coral-selectlist
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var SelectList = Decorator( /*#__PURE__*/function (_BaseComponent) {
    _inherits(_class, _BaseComponent);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this); // Attach events

      _this._delegateEvents({
        'scroll': '_onScroll',
        'mouseenter': '_onMouseEnter',
        'capture:blur': '_onBlur',
        'click coral-selectlist-item': '_onItemClick',
        'key:space coral-selectlist-item': '_onToggleItemKey',
        'key:return coral-selectlist-item': '_onToggleItemKey',
        'key:pageup coral-selectlist-item': '_focusPreviousItem',
        'key:left coral-selectlist-item': '_focusPreviousItem',
        'key:up coral-selectlist-item': '_focusPreviousItem',
        'key:pagedown coral-selectlist-item': '_focusNextItem',
        'key:right coral-selectlist-item': '_focusNextItem',
        'key:down coral-selectlist-item': '_focusNextItem',
        'key:home coral-selectlist-item': '_onHomeKey',
        'key:end coral-selectlist-item': '_onEndKey',
        'keypress coral-selectlist-item': '_onKeyPress',
        // private
        'coral-selectlist-item:_selectedchanged': '_onItemSelectedChanged'
      });

      _this._keypressTimeoutDuration = KEYPRESS_TIMEOUT_DURATION; // Templates

      _this._elements = {};
      template$2.call(_this._elements); // Used for eventing

      _this._oldSelection = []; // Used for interaction

      _this._keypressTimeoutID = null;
      _this._keypressSearchString = ''; // we correctly bind the scroll event

      _this._onDebouncedScroll = _this._onDebouncedScroll.bind(_assertThisInitialized(_this)); // Init the collection mutation observer

      _this.items._startHandlingItems(true);

      return _this;
    }
    /**
     The Collection Interface that allows interacting with the {@link SelectListGroup} elements that the
     SelectList contains. This includes items nested inside groups. To manage items contained within a specific
     group, see {@link SelectListGroup#items}.
      @type {SelectableCollection}
     @readonly
     */


    _createClass(_class, [{
      key: "_toggleItemSelection",

      /** @private */
      value: function _toggleItemSelection(item) {
        if (item) {
          var beforeChangeEvent = this.trigger('coral-selectlist:beforechange', {
            item: item
          });

          if (!beforeChangeEvent.defaultPrevented) {
            item[item.hasAttribute('selected') ? 'removeAttribute' : 'setAttribute']('selected', '');
          }
        }
      }
      /** @private */

    }, {
      key: "_onBlur",
      value: function _onBlur() {
        // required otherwise the latest item that had the focus would get it again instead of the selected item
        this._resetTabTarget();
      }
      /** @private */

    }, {
      key: "_onItemClick",
      value: function _onItemClick(event) {
        event.preventDefault();
        event.stopPropagation();
        var item = event.matchedTarget;

        this._toggleItemSelection(item);

        this._focusItem(item);
      }
      /** @private */

    }, {
      key: "_focusItem",
      value: function _focusItem(item) {
        if (item) {
          item.focus();
        }

        this._tabTarget = item;
      }
      /** @private */

    }, {
      key: "_onToggleItemKey",
      value: function _onToggleItemKey(event) {
        event.preventDefault();
        event.stopPropagation();
        var item = event.target;

        this._toggleItemSelection(item);

        this._focusItem(item);
      }
      /** @private */

    }, {
      key: "_focusPreviousItem",
      value: function _focusPreviousItem(event) {
        event.preventDefault();

        this._focusItem(this.items._getPreviousSelectable(event.target));
      }
      /** @private */

    }, {
      key: "_focusNextItem",
      value: function _focusNextItem(event) {
        event.preventDefault();

        this._focusItem(this.items._getNextSelectable(event.target));
      }
    }, {
      key: "_focusFirstItem",
      value: function _focusFirstItem() {
        this._focusItem(this.items._getFirstSelectable());
      }
    }, {
      key: "_focusLastItem",
      value: function _focusLastItem() {
        this._focusItem(this.items._getLastSelectable());
      }
      /** @private */

    }, {
      key: "_onHomeKey",
      value: function _onHomeKey(event) {
        event.preventDefault();

        this._focusFirstItem();
      }
      /** @private */

    }, {
      key: "_onEndKey",
      value: function _onEndKey(event) {
        event.preventDefault();

        this._focusLastItem();
      }
      /**
       Handles keypress event for alphanumeric search.
        @param {KeyboardEvent} event
       The keyboard event.
       @private
       */

    }, {
      key: "_onKeyPress",
      value: function _onKeyPress(event) {
        var _this2 = this;

        // The string entered when the key was pressed
        var newString = String.fromCharCode(event.which); // Clear the timeout before the _keypressSearchString is cleared

        window.clearTimeout(this._keypressTimeoutID); // If the character entered does not match the last character entered, append it to the _keypressSearchString

        if (newString !== this._keypressSearchString) {
          this._keypressSearchString += newString;
        } // Set a timeout so that _keypressSearchString is cleared after 1 second


        this._keypressTimeoutID = window.setTimeout(function () {
          _this2._keypressSearchString = '';
        }, this._keypressTimeoutDuration); // Search within selectable items

        var selectableItems = this.items._getSelectableItems().filter(function (item) {
          return !item.hasAttribute('hidden') && item.offsetParent;
        }); // Remember the index of the focused item within the array of selectable items


        var currentIndex = selectableItems.indexOf(this._tabTarget);
        this._keypressSearchString = this._keypressSearchString.trim().toLowerCase();
        var start; // If the currentIndex is -1, meaning no item has focus, start from the beginning

        if (currentIndex === -1) {
          start = 0;
        } else if (this._keypressSearchString.length === 1) {
          // Otherwise, if there is only one character to compare, start comparing from the next item after the currently
          // focused item. This allows us to iterate through items beginning with the same character
          start = currentIndex + 1;
        } else {
          start = currentIndex;
        }

        var newFocusItem;
        var comparison;
        var item; // Compare _keypressSearchString against item text until a match is found

        for (var i = start; i < selectableItems.length; i++) {
          item = selectableItems[i];
          comparison = item.textContent.trim().toLowerCase();

          if (comparison.indexOf(this._keypressSearchString) === 0) {
            newFocusItem = item;
            break;
          }
        } // If no match is found, continue searching for a match starting from the top


        if (!newFocusItem) {
          for (var j = 0; j < start; j++) {
            item = selectableItems[j];
            comparison = item.textContent.trim().toLowerCase();

            if (comparison.indexOf(this._keypressSearchString) === 0) {
              newFocusItem = item;
              break;
            }
          }
        } // If a match has been found, focus the matched item


        if (newFocusItem !== undefined) {
          this._focusItem(newFocusItem); // Keyboard is being used so apply focus-ring


          var focusedItem = this.querySelector('.focus-ring');

          if (focusedItem) {
            focusedItem.classList.remove('focus-ring');
          }

          newFocusItem.classList.add('focus-ring');
        }
      }
      /**
       Determine what item should get focus (if any) when the user tries to tab into the SelectList. This should be the
       first selected item, or the first selectable item otherwise. When neither is available, it cannot be tabbed into
       the SelectList.
        @private
       */

    }, {
      key: "_resetTabTarget",
      value: function _resetTabTarget() {
        var forceFirst = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

        var items = this.items._getAllSelected().filter(function (item) {
          return !item.hasAttribute('hidden') && item.offsetParent;
        });

        if (items.length === 0) {
          items = this.items._getSelectableItems().filter(function (item) {
            return !item.hasAttribute('hidden') && item.offsetParent;
          });
        }

        this._tabTarget = forceFirst ? items[0] : items.find(function (item) {
          return item.tabIndex === 0;
        }) || items[0];
      }
      /** @private */

    }, {
      key: "_onScroll",
      value: function _onScroll() {
        window.clearTimeout(this._scrollTimeout);
        this._scrollTimeout = window.setTimeout(this._onDebouncedScroll, SCROLL_DEBOUNCE);
      }
    }, {
      key: "_onMouseEnter",
      value: function _onMouseEnter() {
        if (this.contains(document.activeElement)) {
          document.activeElement.blur();
        }
      }
      /**
       @emits {coral-selectlist:scrollbottom}
        @private
       */

    }, {
      key: "_onDebouncedScroll",
      value: function _onDebouncedScroll() {
        if (this.scrollTop >= this.scrollHeight - this.clientHeight - SCROLL_BOTTOM_THRESHOLD) {
          this.trigger('coral-selectlist:scrollbottom');
        }
      }
      /** @private */

    }, {
      key: "_onItemSelectedChanged",
      value: function _onItemSelectedChanged(event) {
        event.stopImmediatePropagation();

        this._validateSelection(event.target);
      }
      /** @private */

    }, {
      key: "_validateSelection",
      value: function _validateSelection(item) {
        var _this3 = this;

        var selectedItems = this.selectedItems;

        if (!this.multiple) {
          // Last selected item wins if multiple selection while not allowed
          item = item || selectedItems[selectedItems.length - 1];

          if (item && item.hasAttribute('selected') && selectedItems.length > 1) {
            selectedItems.forEach(function (selectedItem) {
              if (selectedItem !== item) {
                // Don't trigger change events
                _this3._preventTriggeringEvents = true;
                selectedItem.removeAttribute('selected');
              }
            }); // We can trigger change events again

            this._preventTriggeringEvents = false;
          }
        }

        this._resetTabTarget();

        this._triggerChangeEvent();
      }
      /** @private */

    }, {
      key: "_triggerChangeEvent",
      value: function _triggerChangeEvent() {
        var selectedItems = this.selectedItems;
        var oldSelection = this._oldSelection;

        if (!this._preventTriggeringEvents && this._arraysAreDifferent(selectedItems, oldSelection)) {
          // We differentiate whether multiple is on or off and return an array or HTMLElement respectively
          if (this.multiple) {
            this.trigger('coral-selectlist:change', {
              oldSelection: oldSelection,
              selection: selectedItems
            });
          } else {
            // Return all items if we just switched from multiple=true to multiple=false and we had >1 selected items
            this.trigger('coral-selectlist:change', {
              oldSelection: oldSelection.length > 1 ? oldSelection : oldSelection[0] || null,
              selection: selectedItems[0] || null
            });
          }

          this._oldSelection = selectedItems;
        }
      }
      /** @private */

    }, {
      key: "_arraysAreDifferent",
      value: function _arraysAreDifferent(selection, oldSelection) {
        var diff = [];

        if (oldSelection.length === selection.length) {
          diff = oldSelection.filter(function (item) {
            return selection.indexOf(item) === -1;
          });
        } // since we guarantee that they are arrays, we can start by comparing their size


        return oldSelection.length !== selection.length || diff.length !== 0;
      }
      /** @ignore */

    }, {
      key: "focus",
      value: function focus() {
        // Avoids moving the focus once it is already inside the component
        if (!this.contains(document.activeElement)) {
          this._resetTabTarget();

          this._focusItem(this._tabTarget);
        }
      }
      /** @ignore */

    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        this.classList.add(CLASSNAME$e); // adds the role to support accessibility

        if (!this.hasAttribute('role')) {
          this.setAttribute('role', 'listbox');
        }

        if (!this.hasAttribute('aria-label')) {
          this.setAttribute('aria-label', i18n.get('List'));
        } // Don't trigger events once connected


        this._preventTriggeringEvents = true;

        this._validateSelection();

        this._preventTriggeringEvents = false;
        this._oldSelection = this.selectedItems;
      }
      /**
       Triggered when the user scrolls to near the bottom of the {@link SelectList}. This can be useful for when additional items can
       be loaded asynchronously (i.e., infinite scrolling).
        @typedef {CustomEvent} coral-selectlist:scrollbottom
       */

      /**
       Triggered before the {@link SelectList} selected item is changed on user interaction. Can be used to cancel selection.
        @typedef {CustomEvent} coral-selectlist:change
        @property {SelectListItem} event.detail.item
       The selected item.
       */

      /**
       Triggered when the {@link SelectList} selected item has changed.
        @typedef {CustomEvent} coral-selectlist:change
        @property {SelectListItem} detail.oldSelection
       The prior selected item(s).
       @property {SelectListItem} detail.selection
       The newly selected item(s).
       */

    }, {
      key: "groups",
      get: function get() {
        // just init on demand
        if (!this._groups) {
          this._groups = new SelectableCollection({
            host: this,
            itemTagName: GROUP_TAG_NAME,
            onItemAdded: this._validateSelection,
            onItemRemoved: this._validateSelection
          });
        }

        return this._groups;
      }
      /**
       The Collection Interface that allows interacting with the items that the component contains.
        @type {SelectableCollection}
       @readonly
       */

    }, {
      key: "items",
      get: function get() {
        // just init on demand
        if (!this._items) {
          this._items = new SelectableCollection({
            host: this,
            itemTagName: ITEM_TAG_NAME,
            onItemAdded: this._validateSelection,
            onItemRemoved: this._validateSelection
          });
        }

        return this._items;
      }
      /**
       The selected item in the SelectList.
        @type {HTMLElement}
       @readonly
       */

    }, {
      key: "selectedItem",
      get: function get() {
        return this.items._getAllSelected()[0] || null;
      }
      /**
       The selected items of the SelectList.
        @type {Array.<HTMLElement>}
       @readonly
       */

    }, {
      key: "selectedItems",
      get: function get() {
        return this.items._getAllSelected();
      }
      /**
       Indicates whether the SelectList accepts multiple selected items.
       @type {Boolean}
       @default false
       @htmlattribute multiple
       @htmlattributereflected
       */

    }, {
      key: "multiple",
      get: function get() {
        return this._multiple || false;
      },
      set: function set(value) {
        this._multiple = transform.booleanAttr(value);

        this._reflectAttribute('multiple', this._multiple);

        this[this._multiple ? 'setAttribute' : 'removeAttribute']('aria-multiselectable', this._multiple);

        this._validateSelection();
      }
      /**
       Whether items are being loaded for the SelectList. Toggling this merely shows or hides a loading indicator.
        @default false
       @type {Boolean}
       @htmlattribute loading
       @htmlattributereflected
       */

    }, {
      key: "loading",
      get: function get() {
        return this._loading || false;
      },
      set: function set(value) {
        this._loading = transform.booleanAttr(value);

        this._reflectAttribute('loading', this._loading);

        var load = this._elements.loadIndicator;

        if (this.loading) {
          // we decide first if we need to scroll to the bottom since adding the load will change the dimentions
          var scrollToBottom = this.scrollTop >= this.scrollHeight - this.clientHeight; // inserts the item at the end

          this.appendChild(load); // we make the load indicator visible

          if (scrollToBottom) {
            /** @ignore */
            this.scrollTop = this.scrollHeight;
          }
        } else {
          load.remove();
        }
      }
      /** @private **/

    }, {
      key: "_tabTarget",
      get: function get() {
        return this.__tabTarget || null;
      },
      set: function set(value) {
        this.__tabTarget = value; // Set all but the current set _tabTarget to not be a tab target:

        this.items._getSelectableItems().forEach(function (item) {
          item.setAttribute('tabindex', !value || item === value ? 0 : -1);
        });
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['loading', 'multiple']);
      }
    }]);

    return _class;
  }(BaseComponent(HTMLElement)));

  var CLASSNAME$f = '_coral-SelectList-group';
  /**
   @class Coral.SelectList.Group
   @classdesc A SelectList group component
   @htmltag coral-selectlist-group
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var SelectListGroup = Decorator( /*#__PURE__*/function (_BaseComponent) {
    _inherits(_class, _BaseComponent);

    var _super = _createSuper(_class);

    function _class() {
      _classCallCheck(this, _class);

      return _super.apply(this, arguments);
    }

    _createClass(_class, [{
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$f);
        this.setAttribute('role', 'group');
      }
    }, {
      key: "label",

      /**
       The label of the group. It reflects the <code>label</code> attribute to the DOM.
        @type {String}
       @default ""
       @htmlattribute label
       @htmlattributereflected
       */
      get: function get() {
        return this._label || '';
      },
      set: function set(value) {
        this._label = transform.string(value);

        this._reflectAttribute('label', this._label);

        this.setAttribute('aria-label', this._label);
      }
      /**
       The Collection Interface that allows interacting with the items that the component contains.
        @type {SelectableCollection}
       @readonly
       */

    }, {
      key: "items",
      get: function get() {
        // just init on demand
        if (!this._items) {
          this._items = new SelectableCollection({
            host: this,
            itemTagName: 'coral-selectlist-item'
          });
        }

        return this._items;
      }
      /** @ignore */

    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['label']);
      }
    }]);

    return _class;
  }(BaseComponent(HTMLElement)));

  var template$3 = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var data = data_0 = typeof data_0 === "undefined" ? {} : data_0;
    var el0 = this["checkIcon"] = document.createElement("span");
    el0.className += " _coral-SelectList-icon";
    el0.setAttribute("handle", "checkIcon");
    el0.setAttribute("hidden", "");
    var el1 = document.createTextNode("\n  ");
    el0.appendChild(el1);
    data = data_0;
    this.checkIcon.innerHTML = data.Icon._renderSVG('spectrum-css-icon-CheckmarkMedium', ['_coral-UIIcon-CheckmarkMedium', '_coral-Menu-checkmark']);
    data_0 = data;
    var el3 = document.createTextNode("\n");
    el0.appendChild(el3);
    frag.appendChild(el0);
    var el4 = document.createTextNode("\n");
    frag.appendChild(el4);
    return frag;
  };

  var CLASSNAME$g = '_coral-Menu-item';
  var VALID_ARIA_SELECTED_ROLES = ['columnheader', 'gridcell', 'option', 'row', 'rowheader', 'tab', 'treeitem'];
  var VALID_ARIA_SELECTED_ROLES_REGEXP = new RegExp("^(".concat(VALID_ARIA_SELECTED_ROLES.join('|'), ")$"));
  /**
   @class Coral.SelectList.Item
   @classdesc A SelectList item component
   @htmltag coral-selectlist-item
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var SelectListItem = Decorator( /*#__PURE__*/function (_BaseComponent) {
    _inherits(_class, _BaseComponent);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this); // Templates

      _this._elements = {
        // Fetch or create the content zone element
        content: _this.querySelector('coral-selectlist-item-content') || document.createElement('coral-selectlist-item-content')
      };
      template$3.call(_this._elements, {
        Icon: Icon
      });
      return _this;
    }
    /**
     Value of the item. If not explicitly set, the value of <code>Node.textContent</code> is returned.
      @type {String}
     @default ""
     @htmlattribute value
     @htmlattributereflected
     */


    _createClass(_class, [{
      key: "_getIconElement",
      value: function _getIconElement() {
        if (!this._elements.icon) {
          this._elements.icon = this.querySelector('._coral-Menu-item-icon') || new Icon();
          this._elements.icon.size = Icon.size.SMALL;

          this._elements.icon.classList.add('_coral-Menu-item-icon');
        }

        return this._elements.icon;
      }
      /**
       Whether the item is selected.
        @type {Boolean}
       @default false
       @htmlattribute selected
       @htmlattributereflected
       */

    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$g);

        if (!this.hasAttribute('role')) {
          this.setAttribute('role', 'option');
        } // Support cloneNode


        var template = this.querySelector('._coral-SelectList-icon');

        if (template) {
          template.remove();
        } // Fetch or create the content content zone element


        var content = this._elements.content; // Move any remaining elements into the content sub-component

        if (!content.parentNode) {
          while (this.firstChild) {
            content.appendChild(this.firstChild);
          }
        } // Add template


        this.appendChild(this._elements.checkIcon); // Assign the content zones, moving them into place in the process

        this.content = content;
      }
    }, {
      key: "value",
      get: function get() {
        return typeof this._value === 'string' ? this._value : this.textContent.replace(/\s{2,}/g, ' ').trim();
      },
      set: function set(value) {
        this._value = transform.string(value);

        this._reflectAttribute('value', this._value);
      }
      /**
       The content element for the item.
        @type {SelectListItemContent}
       @contentzone
       */

    }, {
      key: "content",
      get: function get() {
        return this._getContentZone(this._elements.content);
      },
      set: function set(value) {
        this._setContentZone('content', value, {
          handle: 'content',
          tagName: 'coral-selectlist-item-content',
          insert: function insert(content) {
            content.classList.add("".concat(CLASSNAME$g, "Label")); // Remove content icon before processing content zone

            var checkIcon = this._elements.checkIcon;
            var contentIcon; // @polyfill ie11
            // IE11 throws syntax error because of the "not()" in the selector if the element is not in the DOM.

            if (navigator.userAgent.indexOf('MSIE') !== -1 || navigator.appVersion.includes('Trident/')) {
              var allContentIcons = Array.prototype.slice.call(content.querySelectorAll('coral-icon'));
              var allContentMenuIcons = Array.prototype.slice.call(content.querySelectorAll('coral-icon._coral-Menu-item-icon'));
              var contentIcons = allContentIcons.filter(function (icon) {
                return allContentMenuIcons.indexOf(icon) === -1;
              });
              contentIcon = contentIcons.length > 0 ? contentIcons[0] : undefined;
            } else {
              contentIcon = content.querySelector('coral-icon:not(._coral-Menu-item-icon)');
            }

            if (contentIcon && contentIcon.icon) {
              contentIcon.remove();
              this.icon = contentIcon.icon;

              var iconElement = this._getIconElement();

              if (contentIcon.alt || contentIcon.title) {
                if (contentIcon.title) {
                  iconElement.title = contentIcon.title;
                }

                if (contentIcon.alt) {
                  iconElement.alt = contentIcon.alt;
                }
              } else {
                iconElement.alt = '';
              }
            }

            this.insertBefore(content, this.contains(checkIcon) ? checkIcon : null);
          }
        });
      }
      /**
       The icon to display. See {@link Icon}.
        @type {String}
       @default ""
       @htmlattribute icon
       */

    }, {
      key: "icon",
      get: function get() {
        var el = this._getIconElement();

        return el.icon;
      },
      set: function set(value) {
        var el = this._getIconElement();

        if (transform.string(value) === '') {
          el.remove();
        } else {
          this.insertBefore(el, this.firstChild);
        }

        el.icon = value;
      }
    }, {
      key: "selected",
      get: function get() {
        return this._selected || false;
      },
      set: function set(value) {
        var _selected = transform.booleanAttr(value);

        if (this._selected === _selected) {
          return;
        }

        this._selected = _selected;

        this._reflectAttribute('selected', this.disabled ? false : this._selected);

        this.classList.toggle('is-selected', this._selected);

        if (this.hasAttribute('role') && VALID_ARIA_SELECTED_ROLES_REGEXP.test(this.getAttribute('role'))) {
          this.setAttribute('aria-selected', this._selected);
        } // Toggle check icon


        this._elements.checkIcon.hidden = !this._selected;
        this.trigger('coral-selectlist-item:_selectedchanged');
      }
      /**
       Whether this item is disabled.
        @type {Boolean}
       @default false
       @htmlattribute disabled
       @htmlattributereflected
       */

    }, {
      key: "disabled",
      get: function get() {
        return this._disabled || false;
      },
      set: function set(value) {
        this._disabled = transform.booleanAttr(value);

        this._reflectAttribute('disabled', this._disabled);

        this.classList.toggle('is-disabled', this._disabled);
        this[this._disabled ? 'setAttribute' : 'removeAttribute']('aria-disabled', this._disabled);
        this.selected = this.selected;
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-selectlist-item-content': 'content'
        };
      }
      /** @ignore */

    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['selected', 'disabled', 'value']);
      }
    }]);

    return _class;
  }(BaseComponent(HTMLElement)));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.SelectList.Item.Content
   @classdesc The SelectList Item content
   @htmltag coral-selectlist-item-content
   @return {HTMLElement}
   */
  var SelectListItemContent = (function () {
    return document.createElement('coral-selectlist-item-content');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons.extend(strings, {
    'coral-component-selectlist': translations$3
  }); // Expose component on the Coral namespace

  commons._define('coral-anchorlist-item', AnchorListItem, {
    extends: 'a'
  });

  commons._define('coral-anchorlist', AnchorList);

  commons._define('coral-buttonlist-item', ButtonListItem, {
    extends: 'button'
  });

  commons._define('coral-buttonlist', ButtonList);

  commons._define('coral-selectlist-group', SelectListGroup);

  commons._define('coral-selectlist-item', SelectListItem);

  commons._define('coral-selectlist', SelectList);

  commons._define('coral-list-divider', ListDivider);

  commons._define('coral-list-item', ListItem);

  commons._define('coral-list', List);

  List.Divider = ListDivider;
  List.Item = ListItem;
  List.Item.Content = ListItemContent;
  AnchorList.Item = AnchorListItem;
  ButtonList.Item = ButtonListItem;
  SelectList.Group = SelectListGroup;
  SelectList.Item = SelectListItem;
  SelectList.Item.Content = SelectListItemContent;

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var translations$4 = {
    "en-US": {
      "Close": "Close"
    },
    "de-DE": {
      "Close": "Schließen"
    },
    "fr-FR": {
      "Close": "Fermer"
    },
    "it-IT": {
      "Close": "Chiudi"
    },
    "ja-JP": {
      "Close": "閉じる"
    },
    "es-ES": {
      "Close": "Cerrar"
    },
    "ko-KR": {
      "Close": "닫기"
    },
    "zh-CN": {
      "Close": "关闭"
    },
    "zh-TW": {
      "Close": "關閉"
    },
    "pt-BR": {
      "Close": "Fechar"
    },
    "nl-NL": {
      "Close": "Sluiten"
    },
    "da-DK": {
      "Close": "Luk"
    },
    "fi-FI": {
      "Close": "Sulje"
    },
    "nb-NO": {
      "Close": "Lukk"
    },
    "sv-SE": {
      "Close": "Stäng"
    },
    "cs-CZ": {
      "Close": "Zavřít"
    },
    "pl-PL": {
      "Close": "Zamknij"
    },
    "ru-RU": {
      "Close": "Закрыть"
    },
    "tr-TR": {
      "Close": "Kapat"
    }
  };

  var template$4 = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["topTabCapture"] = document.createElement("div");
    el0.setAttribute("handle", "topTabCapture");
    el0.setAttribute("coral-tabcapture", "top");
    el0.setAttribute("tabindex", "0");
    el0.setAttribute("role", "presentation");
    frag.appendChild(el0);
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    var el2 = this["intermediateTabCapture"] = document.createElement("div");
    el2.setAttribute("handle", "intermediateTabCapture");
    el2.setAttribute("coral-tabcapture", "intermediate");
    el2.setAttribute("tabindex", "0");
    el2.setAttribute("role", "presentation");
    frag.appendChild(el2);
    var el3 = document.createTextNode("\n");
    frag.appendChild(el3);
    var el4 = this["bottomTabCapture"] = document.createElement("div");
    el4.setAttribute("handle", "bottomTabCapture");
    el4.setAttribute("coral-tabcapture", "bottom");
    el4.setAttribute("tabindex", "0");
    el4.setAttribute("role", "presentation");
    frag.appendChild(el4);
    var el5 = document.createTextNode("\n");
    frag.appendChild(el5);
    return frag;
  };

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   Enumeration for {@link BaseOverlay} trap options.

   @typedef {Object} OverlayTrapFocusEnum

   @property {String} ON
   Focus is trapped such that the use cannot focus outside of the overlay.
   @property {String} OFF
   The user can focus outside the overlay as normal.
   */
  var trapFocus = {
    ON: 'on',
    OFF: 'off'
  };
  /**
   Enumeration for {@link BaseOverlay} scroll focus options.

   @typedef {Object} OverlayScrollOnFocusEnum

   @property {String} ON
   Scroll the document to bring the newly-focused element into view.
   @property {String} OFF
   Document will not scroll on focus.
   */

  var scrollOnFocus = {
    ON: 'on',
    OFF: 'off'
  };
  /**
   Enumeration for {@link BaseOverlay} return focus options.

   @typedef {Object} OverlayReturnFocusEnum

   @property {String} ON
   When the overlay is closed, the element that was focused before the it was shown will be focused again.
   @property {String} OFF
   Nothing will be focused when the overlay is closed.
   */

  var returnFocus = {
    ON: 'on',
    OFF: 'off'
  };
  /**
   Enumeration for {@link BaseOverlay} focus behavior options.

   @typedef {Object} OverlayFocusOnShowEnum

   @property {String} ON
   When the overlay is opened, it will be focused.
   @property {String} OFF
   The overlay will not focus itself when opened.
   */

  var focusOnShow = {
    ON: 'on',
    OFF: 'off'
  };
  /**
   The time it should take for {@link BaseOverlay} to fade in milliseconds.
   Important: This should be greater than or equal to the CSS transition time.

   @typedef {Number} OverlayFadeTime
   */

  var FADETIME = 350;

  var CLASSNAME$h = '_coral-BaseOverlay'; // Includes overlay itself

  var COMPONENTS_WITH_OVERLAY = "\n  coral-actionbar,\n  coral-autocomplete,\n  coral-colorinput,\n  coral-cyclebutton,\n  coral-datepicker,\n  coral-dialog,\n  coral-overlay,\n  coral-popover,\n  coral-quickactions,\n  coral-select,\n  coral-tooltip\n"; // The tab capture element that lives at the top of the body

  var topTabCaptureEl;
  var bottomTabCaptureEl; // A reference to the backdrop element

  var backdropEl; // The starting zIndex for overlays

  var startZIndex = 10000; // Tab keycode

  var TAB_KEY = 9; // A stack interface for overlays

  var overlayStack = [];
  var OverlayManager = {};
  /**
   Return focus option
   */

  function preventScroll(instance) {
    return {
      preventScroll: instance.scrollOnFocus === scrollOnFocus.OFF
    };
  }
  /**
   Cancel the backdrop hide mid-animation.
   */


  var fadeTimeout;

  function cancelBackdropHide() {
    window.clearTimeout(fadeTimeout);
  }
  /**
   Set aria-hidden on every immediate child except the one passed, which should not be hidden.
   */


  function hideEverythingBut(instance) {
    // ARIA: Hide all the things
    var children = document.body.children;

    for (var i = 0; i < children.length; i++) {
      var child = children[i]; // If it's not a parent of or not the instance itself, it needs to be hidden

      if (child !== instance && child.contains && !child.contains(instance)) {
        var currentAriaHidden = child.getAttribute('aria-hidden');

        if (currentAriaHidden) {
          // Store the previous value of aria-hidden if present
          // Don't blow away the previously stored value
          child._previousAriaHidden = child._previousAriaHidden || currentAriaHidden;

          if (currentAriaHidden === 'true') {
            // It's already true, don't bother setting
            continue;
          }
        } else {
          // Nothing is hidden by default, store that
          child._previousAriaHidden = 'false';
        } // Hide it


        child.setAttribute('aria-hidden', 'true');
      }
    } // Always show ourselves


    instance.setAttribute('aria-hidden', 'false');
  }
  /**
   Actually reposition the backdrop to be under the topmost overlay.
   */


  function doRepositionBackdrop() {
    // Position under the topmost overlay
    var top = OverlayManager.top();

    if (top) {
      // The backdrop, if shown, should be positioned under the topmost overlay that does have a backdrop
      for (var i = overlayStack.length - 1; i > -1; i--) {
        if (overlayStack[i].backdrop) {
          backdropEl.style.zIndex = overlayStack[i].zIndex - 1;
          break;
        }
      } // ARIA: Set hidden properly


      hideEverythingBut(top.instance);
    }
  }

  OverlayManager = {
    pop: function pop(instance) {
      // Get overlay index
      var index = this.indexOf(instance);

      if (index === -1) {
        return null;
      } // Get the overlay


      var overlay = overlayStack[index]; // Remove from the stack

      overlayStack.splice(index, 1); // Return the passed overlay or the found overlay

      return overlay;
    },
    push: function push(instance) {
      // Pop overlay
      var overlay = this.pop(instance) || {
        instance: instance
      }; // Get the new highest zIndex

      var zIndex = this.getHighestZIndex() + 10; // Store the zIndex

      overlay.zIndex = zIndex;
      instance.style.zIndex = zIndex; // Push it

      overlayStack.push(overlay);

      if (overlay.backdrop) {
        // If the backdrop is shown, we'll need to reposition it
        // Generally, a component will not call _pushOverlay unnecessarily
        // However, attachedCallback is asynchronous in polyfilld environments,
        // so _pushOverlay will be called when shown and when attached
        doRepositionBackdrop();
      }

      return overlay;
    },
    indexOf: function indexOf(instance) {
      // Loop over stack
      // Find overlay
      // Return index
      for (var i = 0; i < overlayStack.length; i++) {
        if (overlayStack[i].instance === instance) {
          return i;
        }
      }

      return -1;
    },
    get: function get(instance) {
      // Get overlay index
      var index = this.indexOf(instance); // Return overlay

      return index === -1 ? null : overlayStack[index];
    },
    top: function top() {
      var length = overlayStack.length;
      return length === 0 ? null : overlayStack[length - 1];
    },
    getHighestZIndex: function getHighestZIndex() {
      var overlay = this.top();
      return overlay ? overlay.zIndex : startZIndex;
    },
    some: function some() {
      return overlayStack.some.apply(overlayStack, arguments);
    },
    forEach: function forEach() {
      return overlayStack.forEach.apply(overlayStack, arguments);
    }
  };
  /**
   Create the global tab capture element.
   */

  function createDocumentTabCaptureEls() {
    if (!topTabCaptureEl) {
      topTabCaptureEl = document.createElement('div');
      topTabCaptureEl.setAttribute('coral-tabcapture', '');
      topTabCaptureEl.setAttribute('role', 'presentation');
      topTabCaptureEl.tabIndex = 0;
      document.body.insertBefore(topTabCaptureEl, document.body.firstChild);
      topTabCaptureEl.addEventListener('focus', function () {
        var top = OverlayManager.top();

        if (top && top.instance.trapFocus === trapFocus.ON) {
          // Focus on the first tabbable element of the top overlay
          Array.prototype.some.call(top.instance.querySelectorAll(commons.TABBABLE_ELEMENT_SELECTOR), function (item) {
            if (item.offsetParent !== null && !item.hasAttribute('coral-tabcapture')) {
              item.focus(preventScroll(top));
              return true;
            }

            return false;
          });
        }
      });
      bottomTabCaptureEl = document.createElement('div');
      bottomTabCaptureEl.setAttribute('coral-tabcapture', '');
      bottomTabCaptureEl.setAttribute('role', 'presentation');
      bottomTabCaptureEl.tabIndex = 0;
      document.body.appendChild(bottomTabCaptureEl);
      bottomTabCaptureEl.addEventListener('focus', function () {
        var top = OverlayManager.top();

        if (top && top.instance.trapFocus === trapFocus.ON) {
          var tabbableElement = Array.prototype.filter.call(top.instance.querySelectorAll(commons.TABBABLE_ELEMENT_SELECTOR), function (item) {
            return item.offsetParent !== null && !item.hasAttribute('coral-tabcapture');
          }).pop(); // Focus on the last tabbable element of the top overlay

          if (tabbableElement) {
            tabbableElement.focus(preventScroll(top));
          }
        }
      });
    } else {
      if (document.body.firstElementChild !== topTabCaptureEl) {
        // Make sure we stay at the very top
        document.body.insertBefore(topTabCaptureEl, document.body.firstChild);
      }

      if (document.body.lastElementChild !== bottomTabCaptureEl) {
        // Make sure we stay at the very bottom
        document.body.appendChild(bottomTabCaptureEl);
      }
    } // Make sure the tab capture elemenst are shown


    topTabCaptureEl.style.display = 'inline';
    bottomTabCaptureEl.style.display = 'inline';
  }
  /**
   Called after all overlays are hidden and we shouldn't capture the first tab into the page.
   */


  function hideDocumentTabCaptureEls() {
    if (topTabCaptureEl) {
      topTabCaptureEl.style.display = 'none';
      bottomTabCaptureEl.style.display = 'none';
    }
  }
  /**
   Show or restore the aria-hidden state of every child of body.
   */


  function showEverything() {
    // ARIA: Show all the things
    var children = document.body.children;

    for (var i = 0; i < children.length; i++) {
      var child = children[i]; // Restore the previous aria-hidden value

      child.setAttribute('aria-hidden', child._previousAriaHidden || 'false');
    }
  }
  /**
   Actually hide the backdrop.
   */


  function doBackdropHide() {
    document.body.classList.remove('u-coral-noscroll'); // Start animation

    window.requestAnimationFrame(function () {
      backdropEl.classList.remove('is-open');
      cancelBackdropHide();
      fadeTimeout = window.setTimeout(function () {
        backdropEl.style.display = 'none';
      }, FADETIME);
    }); // Set flag for testing

    backdropEl._isOpen = false; // Wait for animation to complete

    showEverything();
  }
  /**
   Hide the backdrop if no overlays are using it.
   */


  function hideOrRepositionBackdrop() {
    if (!backdropEl || !backdropEl._isOpen) {
      // Do nothing if the backdrop isn't shown
      return;
    } // Loop over all overlays


    var keepBackdrop = OverlayManager.some(function (overlay) {
      // Check for backdrop usage
      return !!overlay.backdrop;
    });

    if (!keepBackdrop) {
      // Hide the backdrop
      doBackdropHide();
    } else {
      // Reposition the backdrop
      doRepositionBackdrop();
    } // Hide/create the document-level tab capture element as necessary
    // This only applies to modal overlays (those that have backdrops)


    var top = OverlayManager.top();

    if (!top || !(top.instance.trapFocus === trapFocus.ON && top.instance._requestedBackdrop)) {
      hideDocumentTabCaptureEls();
    } else if (top && top.instance.trapFocus === trapFocus.ON && top.instance._requestedBackdrop) {
      createDocumentTabCaptureEls();
    }
  }
  /**
   Handles clicks to the backdrop, calling backdropClickedCallback for every overlay
   */


  function handleBackdropClick(event) {
    OverlayManager.forEach(function (overlay) {
      if (typeof overlay.instance.backdropClickedCallback === 'function') {
        overlay.instance.backdropClickedCallback(event);
      }
    });
  }
  /**
   Actually show the backdrop.
   */


  function doBackdropShow(zIndex, instance) {
    document.body.classList.add('u-coral-noscroll');

    if (!backdropEl) {
      backdropEl = document.createElement('div');
      backdropEl.className = '_coral-Underlay';
      document.body.appendChild(backdropEl);
      backdropEl.addEventListener('click', handleBackdropClick);
    } // Show just under the provided zIndex
    // Since we always increment by 10, this will never collide


    backdropEl.style.zIndex = zIndex - 1; // Set flag for testing

    backdropEl._isOpen = true; // Start animation

    backdropEl.style.display = '';
    window.requestAnimationFrame(function () {
      // Add the class on the next animation frame so backdrop has time to exist
      // Otherwise, the animation for opacity will not work.
      backdropEl.classList.add('is-open');
      cancelBackdropHide();
    });
    hideEverythingBut(instance);
  }
  /**
   @base BaseOverlay
   @classdesc The base element for Overlay components
   */


  var BaseOverlay = function BaseOverlay(superClass) {
    return /*#__PURE__*/function (_superClass) {
      _inherits(_class, _superClass);

      var _super = _createSuper(_class);

      /** @ignore */
      function _class() {
        var _this;

        _classCallCheck(this, _class);

        _this = _super.call(this); // Templates

        _this._elements = {};
        template$4.call(_this._elements);
        return _this;
      }
      /**
       Whether to trap tabs and keep them within the overlay. See {@link OverlayTrapFocusEnum}.
        @type {String}
       @default OverlayTrapFocusEnum.OFF
       @htmlattribute trapfocus
       */


      _createClass(_class, [{
        key: "_closeChildOverlays",
        value: function _closeChildOverlays() {
          var components = this.querySelectorAll(COMPONENTS_WITH_OVERLAY); // Close all children overlays and components with overlays

          for (var i = 0; i < components.length; i++) {
            var component = components[i]; // Overlay component

            if (component.hasAttribute('open')) {
              component.removeAttribute('open');
            } // Component that uses an overlay
            else if (component._elements && component._elements.overlay && component._elements.overlay.hasAttribute('open')) {
                component._elements.overlay.removeAttribute('open');
              }
          }
        }
        /** @private */

      }, {
        key: "_debounce",
        value: function _debounce(f) {
          // Used to avoid triggering open/close event continuously
          window.clearTimeout(this._debounceId);
          this._debounceId = window.setTimeout(function () {
            f();
          }, 10);
        }
        /**
         Check if this overlay is the topmost.
          @protected
         */

      }, {
        key: "_isTopOverlay",
        value: function _isTopOverlay() {
          var top = OverlayManager.top();
          return top && top.instance === this;
        }
        /**
         Push the overlay to the top of the stack.
          @protected
         */

      }, {
        key: "_pushOverlay",
        value: function _pushOverlay() {
          OverlayManager.push(this);
        }
        /**
         Remove the overlay from the stack.
          @protected
         */

      }, {
        key: "_popOverlay",
        value: function _popOverlay() {
          OverlayManager.pop(this); // Automatically hide the backdrop if required

          hideOrRepositionBackdrop();
        }
        /**
         Show the backdrop.
          @protected
         */

      }, {
        key: "_showBackdrop",
        value: function _showBackdrop() {
          var overlay = OverlayManager.get(this); // Overlay is not tracked unless the component is in the DOM
          // Hence, we need to check

          if (overlay) {
            overlay.backdrop = true;
            doBackdropShow(overlay.zIndex, this);
          } // Mark on the instance that the backdrop has been requested for this overlay


          this._requestedBackdrop = true; // Mark that the backdrop was requested when not attached to the DOM
          // This allows us to know whether to push the overlay when the component is attached

          if (!this.parentNode) {
            this._showBackdropOnAttached = true;
          }

          if (this.trapFocus === trapFocus.ON) {
            createDocumentTabCaptureEls();
          }
        }
        /**
         Show the backdrop.
          @protected
         */

      }, {
        key: "_hideBackdrop",
        value: function _hideBackdrop() {
          var overlay = OverlayManager.get(this);

          if (overlay) {
            overlay.backdrop = false; // If that was the last overlay using the backdrop, hide it

            hideOrRepositionBackdrop();
          } // Mark on the instance that the backdrop is no longer needed


          this._requestedBackdrop = false;
        }
        /**
         Handles keypresses on the root of the overlay and marshalls focus accordingly.
          @protected
         */

      }, {
        key: "_handleRootKeypress",
        value: function _handleRootKeypress(event) {
          if (event.target === this && event.keyCode === TAB_KEY) {
            // Skip the top tabcapture and focus on the first focusable element
            this._focusOn('first'); // Stop the normal tab behavior


            event.preventDefault();
          }
        }
        /**
         Handles focus events on tab capture elements.
          @protected
         */

      }, {
        key: "_handleTabCaptureFocus",
        value: function _handleTabCaptureFocus(event) {
          // Avoid moving around if we're trying to focus on coral-tabcapture
          if (this._ignoreTabCapture) {
            this._ignoreTabCapture = false;
            return;
          } // Focus on the correct tabbable element


          var target = event.target;
          var which = target === this._elements.intermediateTabCapture ? 'first' : 'last';

          this._focusOn(which);
        }
        /**
         Handles the focus behavior. When "on" is specified it would try to find the first tababble descendent in the
         content and if there are no valid candidates it will focus the element itself.
          @protected
         */

      }, {
        key: "_handleFocus",
        value: function _handleFocus() {
          // ON handles the focusing per accessibility recommendations
          if (this.focusOnShow === focusOnShow.ON) {
            this._focusOn('first');
          } else if (this.focusOnShow instanceof HTMLElement) {
            this.focusOnShow.focus(preventScroll(this));
          } else if (typeof this.focusOnShow === 'string' && this.focusOnShow !== focusOnShow.OFF) {
            // we need to add :not([coral-tabcapture]) to avoid selecting the tab captures
            var selectedElement = this.querySelector("".concat(this.focusOnShow, ":not([coral-tabcapture])"));

            if (selectedElement) {
              selectedElement.focus(preventScroll(this));
            } // in case the selector does not match, it should fallback to the default behavior
            else {
                this._focusOn('first');
              }
          }
        }
        /**
         @protected
         */

      }, {
        key: "_handleReturnFocus",
        value: function _handleReturnFocus() {
          if (this.returnFocus === returnFocus.ON && this._elementToFocusWhenHidden) {
            if (document.activeElement && !this.contains(document.activeElement)) {
              // Don't return focus if the user focused outside of the overlay
              return;
            } // Return focus, ignoring tab capture if it is an overlay


            this._elementToFocusWhenHidden._ignoreTabCapture = true;

            this._elementToFocusWhenHidden.focus(preventScroll(this));

            this._elementToFocusWhenHidden._ignoreTabCapture = false; // Drop the reference to avoid memory leaks

            this._elementToFocusWhenHidden = null;
          }
        }
        /**
         Focus on the first or last element.
          @param {String} which
         one of "first" or "last"
         @protected
         */

      }, {
        key: "_focusOn",
        value: function _focusOn(which) {
          var focusableTarget = this._getFocusableElement(which); // if we found a focusing target we focus it


          if (focusableTarget) {
            focusableTarget.focus(preventScroll(this));
          } // otherwise the element itself should get focus
          else {
              this.focus(preventScroll(this));
            }
        }
      }, {
        key: "_getFocusableElements",
        value: function _getFocusableElements() {
          return Array.prototype.filter.call(this.querySelectorAll(commons.FOCUSABLE_ELEMENT_SELECTOR), function (item) {
            return item.offsetParent !== null && !item.hasAttribute('coral-tabcapture');
          });
        }
      }, {
        key: "_getFocusableElement",
        value: function _getFocusableElement(which) {
          var focusableTarget;

          if (which === 'first' || which === 'last') {
            var focusableElements = this._getFocusableElements();

            focusableTarget = focusableElements[which === 'first' ? 'shift' : 'pop']();
          }

          return focusableTarget;
        }
        /**
         Open the overlay and set the z-index accordingly.
          @returns {BaseOverlay} this, chainable
         */

      }, {
        key: "show",
        value: function show() {
          this.open = true;
          return this;
        }
        /**
         Close the overlay.
          @returns {BaseOverlay} this, chainable
         */

      }, {
        key: "hide",
        value: function hide() {
          this.open = false;
          return this;
        }
        /**
         Set the element that focus should be returned to when the overlay is hidden.
          @param {HTMLElement} element
         The element to return focus to. This must be a DOM element, not a jQuery object or selector.
          @returns {BaseOverlay} this, chainable
         */

      }, {
        key: "returnFocusTo",
        value: function returnFocusTo(element) {
          if (this.returnFocus === returnFocus.OFF) {
            // Switch on returning focus if it's off
            this.returnFocus = returnFocus.ON;
          } // If the element is not focusable,


          if (!element.matches(commons.FOCUSABLE_ELEMENT_SELECTOR)) {
            // add tabindex so that it is programmatically focusable.
            element.setAttribute('tabindex', -1); // On blur, restore element to its prior, not-focusable state

            var tempVent = new vent(element);
            tempVent.on('blur.afterFocus', function (event) {
              // Wait a frame before testing whether focus has moved to an open overlay or to some other element.
              window.requestAnimationFrame(function () {
                // If overlay remains open, don't remove tabindex event handler until after it has been closed
                var top = OverlayManager.top();

                if (top && top.instance.contains(document.activeElement)) {
                  return;
                }

                tempVent.off('blur.afterFocus');
                event.matchedTarget.removeAttribute('tabindex');
              });
            }, true);
          }

          this._returnFocusToElement = element;
          return this;
        }
      }, {
        key: "connectedCallback",

        /** @ignore */
        value: function connectedCallback() {
          _get(_getPrototypeOf(_class.prototype), "connectedCallback", this).call(this);

          if (!this.hasAttribute('trapfocus')) {
            this.trapFocus = this.trapFocus;
          }

          if (!this.hasAttribute('returnfocus')) {
            this.returnFocus = this.returnFocus;
          }

          if (!this.hasAttribute('focusonshow')) {
            this.focusOnShow = this.focusOnShow;
          }

          if (!this.hasAttribute('scrollonfocus')) {
            this.scrollOnFocus = this.scrollOnFocus;
          }

          if (this.open) {
            this._pushOverlay();

            if (this._showBackdropOnAttached) {
              // Show the backdrop again
              this._showBackdrop();
            }
          } else {
            // If overlay is closed, make sure that it is hidden with `display: none`,
            // but set `visibility: visible` to ensure that the overlay will be included in accessibility name or description
            // of an element that references it using `aria-labelledby` or `aria-describedby`.
            this.style.display = 'none';
            this.style.visibility = 'visible';
          }
        }
        /** @ignore */

      }, {
        key: "render",
        value: function render() {
          _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

          this.classList.add(CLASSNAME$h);
        }
        /** @ignore */

      }, {
        key: "disconnectedCallback",
        value: function disconnectedCallback() {
          _get(_getPrototypeOf(_class.prototype), "disconnectedCallback", this).call(this);

          if (this.open) {
            // Release zIndex as we're not in the DOM any longer
            // When we're re-added, we'll get a new zIndex
            this._popOverlay();

            if (this._requestedBackdrop) {
              // Mark that we'll need to show the backdrop when attached
              this._showBackdropOnAttached = true;
            }
          }
        }
        /**
         Called when the {@link BaseOverlay} is clicked.
          @function backdropClickedCallback
         @protected
         */

        /**
         Triggered before the {@link BaseOverlay} is opened with <code>show()</code> or <code>instance.open = true</code>.
          @typedef {CustomEvent} coral-overlay:beforeopen
          @property {function} preventDefault
         Call to stop the overlay from opening.
         */

        /**
         Triggered after the {@link BaseOverlay} is opened with <code>show()</code> or <code>instance.open = true</code>
          @typedef {CustomEvent} coral-overlay:open
         */

        /**
         Triggered before the {@link BaseOverlay} is closed with <code>hide()</code> or <code>instance.open = false</code>.
          @typedef {CustomEvent} coral-overlay:beforeclose
          @property {function} preventDefault
         Call to stop the overlay from closing.
         */

        /**
         Triggered after the {@link BaseOverlay} is closed with <code>hide()</code> or <code>instance.open = false</code>
          @typedef {CustomEvent} coral-overlay:close
         */

      }, {
        key: "trapFocus",
        get: function get() {
          return this._trapFocus || trapFocus.OFF;
        },
        set: function set(value) {
          value = transform.string(value).toLowerCase();
          this._trapFocus = validate.enumeration(trapFocus)(value) && value || trapFocus.OFF;

          if (this._trapFocus === trapFocus.ON) {
            // Give ourselves tabIndex if we are not focusable
            if (this.tabIndex < 0) {
              /** @ignore */
              this.tabIndex = 0;
            } // Insert elements


            this.insertBefore(this._elements.topTabCapture, this.firstElementChild);
            this.appendChild(this._elements.intermediateTabCapture);
            this.appendChild(this._elements.bottomTabCapture); // Add listeners

            this._handleTabCaptureFocus = this._handleTabCaptureFocus.bind(this);
            this._handleRootKeypress = this._handleRootKeypress.bind(this);

            this._vent.on('keydown', this._handleRootKeypress);

            this._vent.on('focus', '[coral-tabcapture]', this._handleTabCaptureFocus);
          } else if (this._trapFocus === trapFocus.OFF) {
            // Remove elements
            this._elements.topTabCapture && this._elements.topTabCapture.remove();
            this._elements.intermediateTabCapture && this._elements.intermediateTabCapture.remove();
            this._elements.bottomTabCapture && this._elements.bottomTabCapture.remove(); // Remove listeners

            this._vent.off('keydown', this._handleRootKeypress);

            this._vent.off('focus', '[coral-tabcapture]', this._handleTabCaptureFocus);
          }
        }
        /**
         Whether to return focus to the previously focused element when closed. See {@link OverlayReturnFocusEnum}.
          @type {String}
         @default OverlayReturnFocusEnum.OFF
         @htmlattribute returnfocus
         */

      }, {
        key: "returnFocus",
        get: function get() {
          return this._returnFocus || returnFocus.OFF;
        },
        set: function set(value) {
          value = transform.string(value).toLowerCase();
          this._returnFocus = validate.enumeration(returnFocus)(value) && value || returnFocus.OFF;
        }
        /**
         returns element that will receive focus when overlay is closed
         @returns {HTMLElement}element passed via returnFocusTo()
         */

      }, {
        key: "returnFocusToElement",
        get: function get() {
          return this._returnFocusToElement;
        }
        /**
         returns element that will receive focus when overlay is hidden
         @returns {HTMLElement} element cached
         */

      }, {
        key: "elementToFocusWhenHidden",
        get: function get() {
          return this._elementToFocusWhenHidden;
        }
        /**
         Whether the browser should scroll the document to bring the newly-focused element into view. See {@link OverlayScrollOnFocusEnum}.
          @type {String}
         @default OverlayScrollOnFocusEnum.ON
         @htmlattribute scrollonfocus
         */

      }, {
        key: "scrollOnFocus",
        get: function get() {
          return this._scrollOnFocus || scrollOnFocus.ON;
        },
        set: function set(value) {
          value = transform.string(value).toLowerCase();
          this._scrollOnFocus = validate.enumeration(scrollOnFocus)(value) && value || scrollOnFocus.ON;
        }
        /**
         Whether to focus the overlay, when opened or not. By default the overlay itself will get the focus. It also accepts
         an instance of HTMLElement or a selector like ':first-child' or 'button:last-of-type'. If the selector returns
         multiple elements, it will focus the first element inside the overlay that matches the selector.
         See {@link OverlayFocusOnShowEnum}.
          @type {HTMLElement|String}
         @default OverlayFocusOnShowEnum.ON
         @htmlattribute focusonshow
         */

      }, {
        key: "focusOnShow",
        get: function get() {
          return this._focusOnShow || focusOnShow.ON;
        },
        set: function set(value) {
          if (typeof value === 'string' || value instanceof HTMLElement) {
            this._focusOnShow = value;
          }
        }
        /**
         Whether this overlay is open or not.
          @type {Boolean}
         @default false
         @htmlattribute open
         @htmlattributereflected
         @emits {coral-overlay:open}
         @emits {coral-overlay:close}
         @emits {coral-overlay:beforeopen}
         @emits {coral-overlay:beforeclose}
         */

      }, {
        key: "open",
        get: function get() {
          return this._open || false;
        },
        set: function set(value) {
          var _this2 = this;

          var silenced = this._silenced;
          value = transform.booleanAttr(value); // Used for global animations

          this.trigger('coral-overlay:_animate');
          var beforeEvent = this.trigger(value ? 'coral-overlay:beforeopen' : 'coral-overlay:beforeclose');

          if (!beforeEvent.defaultPrevented) {
            var open = this._open = value;

            this._reflectAttribute('open', open); // Remove aria-hidden attribute before we show.
            // Otherwise, screen readers will not announce
            // Doesn't matter when we set aria-hidden true (nothing being announced)


            if (open) {
              this.removeAttribute('aria-hidden');
            } else {
              this.setAttribute('aria-hidden', !open);
            } // Don't do anything if we're not in the DOM yet
            // This prevents errors related to allocating a zIndex we don't need


            if (this.parentNode) {
              // Do this check afterwards as we may have been appended inside of _show()
              if (open) {
                // Set z-index
                this._pushOverlay();

                if (this.returnFocus === returnFocus.ON) {
                  this._elementToFocusWhenHidden = // cached element
                  this._elementToFocusWhenHidden || // element passed via returnFocusTo()
                  this._returnFocusToElement || ( // element that had focus before opening the overlay
                  document.activeElement === document.body ? null : document.activeElement);
                }
              } else {
                // Release zIndex
                this._popOverlay();
              }
            } // Don't force reflow


            window.requestAnimationFrame(function () {
              // Keep it silenced
              _this2._silenced = silenced;

              if (open) {
                if (_this2.trapFocus === trapFocus.ON) {
                  // Make sure tab capture elements are positioned correctly
                  if ( // Tab capture elements are no longer at the bottom
                  _this2._elements.topTabCapture !== _this2.firstElementChild || _this2._elements.bottomTabCapture !== _this2.lastElementChild || // Tab capture elements have been separated
                  _this2._elements.bottomTabCapture.previousElementSibling !== _this2._elements.intermediateTabCapture) {
                    _this2.insertBefore(_this2._elements.intermediateTabCapture, _this2.firstElementChild);

                    _this2.appendChild(_this2._elements.intermediateTabCapture);

                    _this2.appendChild(_this2._elements.bottomTabCapture);
                  }
                } // visibility should revert to whatever is specified in CSS, so that transition renders.


                _this2.style.visibility = ''; // The default style should be display: none for overlays
                // Show ourselves first for centering calculations etc

                _this2.style.display = ''; // Do it in the next frame to make the animation happen

                window.requestAnimationFrame(function () {
                  _this2.classList.add('is-open');
                });

                var openComplete = function openComplete() {
                  if (_this2.open) {
                    _this2._debounce(function () {
                      // handles the focus behavior based on accessibility recommendations
                      _this2._handleFocus();

                      _this2.trigger('coral-overlay:open');

                      _this2._silenced = false;
                    });
                  }
                };

                if (_this2._overlayAnimationTime) {
                  // Wait for animation to complete
                  commons.transitionEnd(_this2, openComplete);
                } else {
                  // Execute immediately
                  openComplete();
                }
              } else {
                // Fade out
                _this2.classList.remove('is-open');

                var closeComplete = function closeComplete() {
                  if (!_this2.open) {
                    // When the CSS transition has finished, set visibility to browser default, `visibility: visible`,
                    // to ensure that the overlay will be included in accessibility name or description
                    // of an element that references it using `aria-labelledby` or `aria-describedby`.
                    _this2.style.visibility = 'visible'; // makes sure the focus is returned per accessibility recommendations

                    _this2._handleReturnFocus(); // Hide self


                    _this2.style.display = 'none';

                    _this2._debounce(function () {
                      // Inform child overlays that we're closing
                      _this2._closeChildOverlays();

                      _this2.trigger('coral-overlay:close');

                      _this2._silenced = false;
                    });
                  }
                };

                if (_this2._overlayAnimationTime) {
                  // Wait for animation to complete
                  commons.transitionEnd(_this2, closeComplete);
                } else {
                  // Execute immediately
                  closeComplete();
                }
              }
            });
          }
        }
      }], [{
        key: "_OverlayManager",
        get: function get() {
          return OverlayManager;
        }
        /**
         Returns {@link BaseOverlay} trap focus options.
          @return {OverlayTrapFocusEnum}
         */

      }, {
        key: "trapFocus",
        get: function get() {
          return trapFocus;
        }
        /**
         Returns {@link BaseOverlay} return focus options.
          @return {OverlayReturnFocusEnum}
         */

      }, {
        key: "returnFocus",
        get: function get() {
          return returnFocus;
        }
        /**
         Returns {@link BaseOverlay} scroll focus options.
          @return {OverlayScrollOnFocusEnum}
         */

      }, {
        key: "scrollOnFocus",
        get: function get() {
          return scrollOnFocus;
        }
        /**
         Returns {@link BaseOverlay} focus on show options.
          @return {OverlayFocusOnShowEnum}
         */

      }, {
        key: "focusOnShow",
        get: function get() {
          return focusOnShow;
        }
        /**
         Returns {@link BaseOverlay} fadetime in milliseconds.
          @return {Number}
         */

      }, {
        key: "FADETIME",
        get: function get() {
          return FADETIME;
        }
      }, {
        key: "_attributePropertyMap",
        get: function get() {
          return commons.extend(_get(_getPrototypeOf(_class), "_attributePropertyMap", this), {
            trapfocus: 'trapFocus',
            returnfocus: 'returnFocus',
            focusonshow: 'focusOnShow'
          });
        }
        /** @ignore */

      }, {
        key: "observedAttributes",
        get: function get() {
          return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['trapfocus', 'returnfocus', 'focusonshow', 'open']);
        }
      }]);

      return _class;
    }(superClass);
  };

  /**!
   * @fileOverview Kickass library to create and place poppers near their reference elements.
   * @version 1.16.1
   * @license
   * Copyright (c) 2016 Federico Zivolo and contributors
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   */
  var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && typeof navigator !== 'undefined';

  var timeoutDuration = function () {
    var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];

    for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
      if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
        return 1;
      }
    }

    return 0;
  }();

  function microtaskDebounce(fn) {
    var called = false;
    return function () {
      if (called) {
        return;
      }

      called = true;
      window.Promise.resolve().then(function () {
        called = false;
        fn();
      });
    };
  }

  function taskDebounce(fn) {
    var scheduled = false;
    return function () {
      if (!scheduled) {
        scheduled = true;
        setTimeout(function () {
          scheduled = false;
          fn();
        }, timeoutDuration);
      }
    };
  }

  var supportsMicroTasks = isBrowser && window.Promise;
  /**
  * Create a debounced version of a method, that's asynchronously deferred
  * but called in the minimum time possible.
  *
  * @method
  * @memberof Popper.Utils
  * @argument {Function} fn
  * @returns {Function}
  */

  var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;
  /**
   * Check if the given variable is a function
   * @method
   * @memberof Popper.Utils
   * @argument {Any} functionToCheck - variable to check
   * @returns {Boolean} answer to: is a function?
   */

  function isFunction$1(functionToCheck) {
    var getType = {};
    return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
  }
  /**
   * Get CSS computed property of the given element
   * @method
   * @memberof Popper.Utils
   * @argument {Eement} element
   * @argument {String} property
   */


  function getStyleComputedProperty(element, property) {
    if (element.nodeType !== 1) {
      return [];
    } // NOTE: 1 DOM access here


    var window = element.ownerDocument.defaultView;
    var css = window.getComputedStyle(element, null);
    return property ? css[property] : css;
  }
  /**
   * Returns the parentNode or the host of the element
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @returns {Element} parent
   */


  function getParentNode(element) {
    if (element.nodeName === 'HTML') {
      return element;
    }

    return element.parentNode || element.host;
  }
  /**
   * Returns the scrolling parent of the given element
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @returns {Element} scroll parent
   */


  function getScrollParent$1(element) {
    // Return body, `getScroll` will take care to get the correct `scrollTop` from it
    if (!element) {
      return document.body;
    }

    switch (element.nodeName) {
      case 'HTML':
      case 'BODY':
        return element.ownerDocument.body;

      case '#document':
        return element.body;
    } // Firefox want us to check `-x` and `-y` variations as well


    var _getStyleComputedProp = getStyleComputedProperty(element),
        overflow = _getStyleComputedProp.overflow,
        overflowX = _getStyleComputedProp.overflowX,
        overflowY = _getStyleComputedProp.overflowY;

    if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
      return element;
    }

    return getScrollParent$1(getParentNode(element));
  }
  /**
   * Returns the reference node of the reference object, or the reference object itself.
   * @method
   * @memberof Popper.Utils
   * @param {Element|Object} reference - the reference element (the popper will be relative to this)
   * @returns {Element} parent
   */


  function getReferenceNode(reference) {
    return reference && reference.referenceNode ? reference.referenceNode : reference;
  }

  var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
  var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);
  /**
   * Determines if the browser is Internet Explorer
   * @method
   * @memberof Popper.Utils
   * @param {Number} version to check
   * @returns {Boolean} isIE
   */

  function isIE(version) {
    if (version === 11) {
      return isIE11;
    }

    if (version === 10) {
      return isIE10;
    }

    return isIE11 || isIE10;
  }
  /**
   * Returns the offset parent of the given element
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @returns {Element} offset parent
   */


  function getOffsetParent(element) {
    if (!element) {
      return document.documentElement;
    }

    var noOffsetParent = isIE(10) ? document.body : null; // NOTE: 1 DOM access here

    var offsetParent = element.offsetParent || null; // Skip hidden elements which don't have an offsetParent

    while (offsetParent === noOffsetParent && element.nextElementSibling) {
      offsetParent = (element = element.nextElementSibling).offsetParent;
    }

    var nodeName = offsetParent && offsetParent.nodeName;

    if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
      return element ? element.ownerDocument.documentElement : document.documentElement;
    } // .offsetParent will return the closest TH, TD or TABLE in case
    // no offsetParent is present, I hate this job...


    if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
      return getOffsetParent(offsetParent);
    }

    return offsetParent;
  }

  function isOffsetContainer(element) {
    var nodeName = element.nodeName;

    if (nodeName === 'BODY') {
      return false;
    }

    return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
  }
  /**
   * Finds the root node (document, shadowDOM root) of the given element
   * @method
   * @memberof Popper.Utils
   * @argument {Element} node
   * @returns {Element} root node
   */


  function getRoot(node) {
    if (node.parentNode !== null) {
      return getRoot(node.parentNode);
    }

    return node;
  }
  /**
   * Finds the offset parent common to the two provided nodes
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element1
   * @argument {Element} element2
   * @returns {Element} common offset parent
   */


  function findCommonOffsetParent(element1, element2) {
    // This check is needed to avoid errors in case one of the elements isn't defined for any reason
    if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
      return document.documentElement;
    } // Here we make sure to give as "start" the element that comes first in the DOM


    var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
    var start = order ? element1 : element2;
    var end = order ? element2 : element1; // Get common ancestor container

    var range = document.createRange();
    range.setStart(start, 0);
    range.setEnd(end, 0);
    var commonAncestorContainer = range.commonAncestorContainer; // Both nodes are inside #document

    if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
      if (isOffsetContainer(commonAncestorContainer)) {
        return commonAncestorContainer;
      }

      return getOffsetParent(commonAncestorContainer);
    } // one of the nodes is inside shadowDOM, find which one


    var element1root = getRoot(element1);

    if (element1root.host) {
      return findCommonOffsetParent(element1root.host, element2);
    } else {
      return findCommonOffsetParent(element1, getRoot(element2).host);
    }
  }
  /**
   * Gets the scroll value of the given element in the given side (top and left)
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @argument {String} side `top` or `left`
   * @returns {number} amount of scrolled pixels
   */


  function getScroll(element) {
    var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';
    var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
    var nodeName = element.nodeName;

    if (nodeName === 'BODY' || nodeName === 'HTML') {
      var html = element.ownerDocument.documentElement;
      var scrollingElement = element.ownerDocument.scrollingElement || html;
      return scrollingElement[upperSide];
    }

    return element[upperSide];
  }
  /*
   * Sum or subtract the element scroll values (left and top) from a given rect object
   * @method
   * @memberof Popper.Utils
   * @param {Object} rect - Rect object you want to change
   * @param {HTMLElement} element - The element from the function reads the scroll values
   * @param {Boolean} subtract - set to true if you want to subtract the scroll values
   * @return {Object} rect - The modifier rect object
   */


  function includeScroll(rect, element) {
    var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var scrollTop = getScroll(element, 'top');
    var scrollLeft = getScroll(element, 'left');
    var modifier = subtract ? -1 : 1;
    rect.top += scrollTop * modifier;
    rect.bottom += scrollTop * modifier;
    rect.left += scrollLeft * modifier;
    rect.right += scrollLeft * modifier;
    return rect;
  }
  /*
   * Helper to detect borders of a given element
   * @method
   * @memberof Popper.Utils
   * @param {CSSStyleDeclaration} styles
   * Result of `getStyleComputedProperty` on the given element
   * @param {String} axis - `x` or `y`
   * @return {number} borders - The borders size of the given axis
   */


  function getBordersSize(styles, axis) {
    var sideA = axis === 'x' ? 'Left' : 'Top';
    var sideB = sideA === 'Left' ? 'Right' : 'Bottom';
    return parseFloat(styles['border' + sideA + 'Width']) + parseFloat(styles['border' + sideB + 'Width']);
  }

  function getSize(axis, body, html, computedStyle) {
    return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? parseInt(html['offset' + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')]) : 0);
  }

  function getWindowSizes(document) {
    var body = document.body;
    var html = document.documentElement;
    var computedStyle = isIE(10) && getComputedStyle(html);
    return {
      height: getSize('Height', body, html, computedStyle),
      width: getSize('Width', body, html, computedStyle)
    };
  }

  var classCallCheck = function classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  var createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  var defineProperty$2 = function defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  };

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  /**
   * Given element offsets, generate an output similar to getBoundingClientRect
   * @method
   * @memberof Popper.Utils
   * @argument {Object} offsets
   * @returns {Object} ClientRect like output
   */


  function getClientRect(offsets) {
    return _extends({}, offsets, {
      right: offsets.left + offsets.width,
      bottom: offsets.top + offsets.height
    });
  }
  /**
   * Get bounding client rect of given element
   * @method
   * @memberof Popper.Utils
   * @param {HTMLElement} element
   * @return {Object} client rect
   */


  function getBoundingClientRect(element) {
    var rect = {}; // IE10 10 FIX: Please, don't ask, the element isn't
    // considered in DOM in some circumstances...
    // This isn't reproducible in IE10 compatibility mode of IE11

    try {
      if (isIE(10)) {
        rect = element.getBoundingClientRect();
        var scrollTop = getScroll(element, 'top');
        var scrollLeft = getScroll(element, 'left');
        rect.top += scrollTop;
        rect.left += scrollLeft;
        rect.bottom += scrollTop;
        rect.right += scrollLeft;
      } else {
        rect = element.getBoundingClientRect();
      }
    } catch (e) {}

    var result = {
      left: rect.left,
      top: rect.top,
      width: rect.right - rect.left,
      height: rect.bottom - rect.top
    }; // subtract scrollbar size from sizes

    var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};
    var width = sizes.width || element.clientWidth || result.width;
    var height = sizes.height || element.clientHeight || result.height;
    var horizScrollbar = element.offsetWidth - width;
    var vertScrollbar = element.offsetHeight - height; // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
    // we make this check conditional for performance reasons

    if (horizScrollbar || vertScrollbar) {
      var styles = getStyleComputedProperty(element);
      horizScrollbar -= getBordersSize(styles, 'x');
      vertScrollbar -= getBordersSize(styles, 'y');
      result.width -= horizScrollbar;
      result.height -= vertScrollbar;
    }

    return getClientRect(result);
  }

  function getOffsetRectRelativeToArbitraryNode(children, parent) {
    var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var isIE10 = isIE(10);
    var isHTML = parent.nodeName === 'HTML';
    var childrenRect = getBoundingClientRect(children);
    var parentRect = getBoundingClientRect(parent);
    var scrollParent = getScrollParent$1(children);
    var styles = getStyleComputedProperty(parent);
    var borderTopWidth = parseFloat(styles.borderTopWidth);
    var borderLeftWidth = parseFloat(styles.borderLeftWidth); // In cases where the parent is fixed, we must ignore negative scroll in offset calc

    if (fixedPosition && isHTML) {
      parentRect.top = Math.max(parentRect.top, 0);
      parentRect.left = Math.max(parentRect.left, 0);
    }

    var offsets = getClientRect({
      top: childrenRect.top - parentRect.top - borderTopWidth,
      left: childrenRect.left - parentRect.left - borderLeftWidth,
      width: childrenRect.width,
      height: childrenRect.height
    });
    offsets.marginTop = 0;
    offsets.marginLeft = 0; // Subtract margins of documentElement in case it's being used as parent
    // we do this only on HTML because it's the only element that behaves
    // differently when margins are applied to it. The margins are included in
    // the box of the documentElement, in the other cases not.

    if (!isIE10 && isHTML) {
      var marginTop = parseFloat(styles.marginTop);
      var marginLeft = parseFloat(styles.marginLeft);
      offsets.top -= borderTopWidth - marginTop;
      offsets.bottom -= borderTopWidth - marginTop;
      offsets.left -= borderLeftWidth - marginLeft;
      offsets.right -= borderLeftWidth - marginLeft; // Attach marginTop and marginLeft because in some circumstances we may need them

      offsets.marginTop = marginTop;
      offsets.marginLeft = marginLeft;
    }

    if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
      offsets = includeScroll(offsets, parent);
    }

    return offsets;
  }

  function getViewportOffsetRectRelativeToArtbitraryNode(element) {
    var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var html = element.ownerDocument.documentElement;
    var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
    var width = Math.max(html.clientWidth, window.innerWidth || 0);
    var height = Math.max(html.clientHeight, window.innerHeight || 0);
    var scrollTop = !excludeScroll ? getScroll(html) : 0;
    var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;
    var offset = {
      top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
      left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
      width: width,
      height: height
    };
    return getClientRect(offset);
  }
  /**
   * Check if the given element is fixed or is inside a fixed parent
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @argument {Element} customContainer
   * @returns {Boolean} answer to "isFixed?"
   */


  function isFixed(element) {
    var nodeName = element.nodeName;

    if (nodeName === 'BODY' || nodeName === 'HTML') {
      return false;
    }

    if (getStyleComputedProperty(element, 'position') === 'fixed') {
      return true;
    }

    var parentNode = getParentNode(element);

    if (!parentNode) {
      return false;
    }

    return isFixed(parentNode);
  }
  /**
   * Finds the first parent of an element that has a transformed property defined
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @returns {Element} first transformed parent or documentElement
   */


  function getFixedPositionOffsetParent(element) {
    // This check is needed to avoid errors in case one of the elements isn't defined for any reason
    if (!element || !element.parentElement || isIE()) {
      return document.documentElement;
    }

    var el = element.parentElement;

    while (el && getStyleComputedProperty(el, 'transform') === 'none') {
      el = el.parentElement;
    }

    return el || document.documentElement;
  }
  /**
   * Computed the boundaries limits and return them
   * @method
   * @memberof Popper.Utils
   * @param {HTMLElement} popper
   * @param {HTMLElement} reference
   * @param {number} padding
   * @param {HTMLElement} boundariesElement - Element used to define the boundaries
   * @param {Boolean} fixedPosition - Is in fixed position mode
   * @returns {Object} Coordinates of the boundaries
   */


  function getBoundaries(popper, reference, padding, boundariesElement) {
    var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false; // NOTE: 1 DOM access here

    var boundaries = {
      top: 0,
      left: 0
    };
    var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference)); // Handle viewport case

    if (boundariesElement === 'viewport') {
      boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
    } else {
      // Handle other cases based on DOM element used as boundaries
      var boundariesNode = void 0;

      if (boundariesElement === 'scrollParent') {
        boundariesNode = getScrollParent$1(getParentNode(reference));

        if (boundariesNode.nodeName === 'BODY') {
          boundariesNode = popper.ownerDocument.documentElement;
        }
      } else if (boundariesElement === 'window') {
        boundariesNode = popper.ownerDocument.documentElement;
      } else {
        boundariesNode = boundariesElement;
      }

      var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition); // In case of HTML, we need a different computation

      if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
        var _getWindowSizes = getWindowSizes(popper.ownerDocument),
            height = _getWindowSizes.height,
            width = _getWindowSizes.width;

        boundaries.top += offsets.top - offsets.marginTop;
        boundaries.bottom = height + offsets.top;
        boundaries.left += offsets.left - offsets.marginLeft;
        boundaries.right = width + offsets.left;
      } else {
        // for all the other DOM elements, this one is good
        boundaries = offsets;
      }
    } // Add paddings


    padding = padding || 0;
    var isPaddingNumber = typeof padding === 'number';
    boundaries.left += isPaddingNumber ? padding : padding.left || 0;
    boundaries.top += isPaddingNumber ? padding : padding.top || 0;
    boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
    boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;
    return boundaries;
  }

  function getArea(_ref) {
    var width = _ref.width,
        height = _ref.height;
    return width * height;
  }
  /**
   * Utility used to transform the `auto` placement to the placement with more
   * available space.
   * @method
   * @memberof Popper.Utils
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */


  function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
    var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

    if (placement.indexOf('auto') === -1) {
      return placement;
    }

    var boundaries = getBoundaries(popper, reference, padding, boundariesElement);
    var rects = {
      top: {
        width: boundaries.width,
        height: refRect.top - boundaries.top
      },
      right: {
        width: boundaries.right - refRect.right,
        height: boundaries.height
      },
      bottom: {
        width: boundaries.width,
        height: boundaries.bottom - refRect.bottom
      },
      left: {
        width: refRect.left - boundaries.left,
        height: boundaries.height
      }
    };
    var sortedAreas = Object.keys(rects).map(function (key) {
      return _extends({
        key: key
      }, rects[key], {
        area: getArea(rects[key])
      });
    }).sort(function (a, b) {
      return b.area - a.area;
    });
    var filteredAreas = sortedAreas.filter(function (_ref2) {
      var width = _ref2.width,
          height = _ref2.height;
      return width >= popper.clientWidth && height >= popper.clientHeight;
    });
    var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;
    var variation = placement.split('-')[1];
    return computedPlacement + (variation ? '-' + variation : '');
  }
  /**
   * Get offsets to the reference element
   * @method
   * @memberof Popper.Utils
   * @param {Object} state
   * @param {Element} popper - the popper element
   * @param {Element} reference - the reference element (the popper will be relative to this)
   * @param {Element} fixedPosition - is in fixed position mode
   * @returns {Object} An object containing the offsets which will be applied to the popper
   */


  function getReferenceOffsets(state, popper, reference) {
    var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));
    return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
  }
  /**
   * Get the outer sizes of the given element (offset size + margins)
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @returns {Object} object containing width and height properties
   */


  function getOuterSizes(element) {
    var window = element.ownerDocument.defaultView;
    var styles = window.getComputedStyle(element);
    var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);
    var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);
    var result = {
      width: element.offsetWidth + y,
      height: element.offsetHeight + x
    };
    return result;
  }
  /**
   * Get the opposite placement of the given one
   * @method
   * @memberof Popper.Utils
   * @argument {String} placement
   * @returns {String} flipped placement
   */


  function getOppositePlacement(placement) {
    var hash = {
      left: 'right',
      right: 'left',
      bottom: 'top',
      top: 'bottom'
    };
    return placement.replace(/left|right|bottom|top/g, function (matched) {
      return hash[matched];
    });
  }
  /**
   * Get offsets to the popper
   * @method
   * @memberof Popper.Utils
   * @param {Object} position - CSS position the Popper will get applied
   * @param {HTMLElement} popper - the popper element
   * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
   * @param {String} placement - one of the valid placement options
   * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
   */


  function getPopperOffsets(popper, referenceOffsets, placement) {
    placement = placement.split('-')[0]; // Get popper node sizes

    var popperRect = getOuterSizes(popper); // Add position, width and height to our offsets object

    var popperOffsets = {
      width: popperRect.width,
      height: popperRect.height
    }; // depending by the popper placement we have to compute its offsets slightly differently

    var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
    var mainSide = isHoriz ? 'top' : 'left';
    var secondarySide = isHoriz ? 'left' : 'top';
    var measurement = isHoriz ? 'height' : 'width';
    var secondaryMeasurement = !isHoriz ? 'height' : 'width';
    popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;

    if (placement === secondarySide) {
      popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
    } else {
      popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
    }

    return popperOffsets;
  }
  /**
   * Mimics the `find` method of Array
   * @method
   * @memberof Popper.Utils
   * @argument {Array} arr
   * @argument prop
   * @argument value
   * @returns index or -1
   */


  function find(arr, check) {
    // use native find if supported
    if (Array.prototype.find) {
      return arr.find(check);
    } // use `filter` to obtain the same behavior of `find`


    return arr.filter(check)[0];
  }
  /**
   * Return the index of the matching object
   * @method
   * @memberof Popper.Utils
   * @argument {Array} arr
   * @argument prop
   * @argument value
   * @returns index or -1
   */


  function findIndex(arr, prop, value) {
    // use native findIndex if supported
    if (Array.prototype.findIndex) {
      return arr.findIndex(function (cur) {
        return cur[prop] === value;
      });
    } // use `find` + `indexOf` if `findIndex` isn't supported


    var match = find(arr, function (obj) {
      return obj[prop] === value;
    });
    return arr.indexOf(match);
  }
  /**
   * Loop trough the list of modifiers and run them in order,
   * each of them will then edit the data object.
   * @method
   * @memberof Popper.Utils
   * @param {dataObject} data
   * @param {Array} modifiers
   * @param {String} ends - Optional modifier name used as stopper
   * @returns {dataObject}
   */


  function runModifiers(modifiers, data, ends) {
    var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));
    modifiersToRun.forEach(function (modifier) {
      if (modifier['function']) {
        // eslint-disable-line dot-notation
        console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
      }

      var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation

      if (modifier.enabled && isFunction$1(fn)) {
        // Add properties to offsets to make them a complete clientRect object
        // we do this before each modifier to make sure the previous one doesn't
        // mess with these values
        data.offsets.popper = getClientRect(data.offsets.popper);
        data.offsets.reference = getClientRect(data.offsets.reference);
        data = fn(data, modifier);
      }
    });
    return data;
  }
  /**
   * Updates the position of the popper, computing the new offsets and applying
   * the new style.<br />
   * Prefer `scheduleUpdate` over `update` because of performance reasons.
   * @method
   * @memberof Popper
   */


  function update() {
    // if popper is destroyed, don't perform any further update
    if (this.state.isDestroyed) {
      return;
    }

    var data = {
      instance: this,
      styles: {},
      arrowStyles: {},
      attributes: {},
      flipped: false,
      offsets: {}
    }; // compute reference element offsets

    data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed); // compute auto placement, store placement inside the data object,
    // modifiers will be able to edit `placement` if needed
    // and refer to originalPlacement to know the original value

    data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding); // store the computed placement inside `originalPlacement`

    data.originalPlacement = data.placement;
    data.positionFixed = this.options.positionFixed; // compute the popper offsets

    data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);
    data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute'; // run the modifiers

    data = runModifiers(this.modifiers, data); // the first `update` will call `onCreate` callback
    // the other ones will call `onUpdate` callback

    if (!this.state.isCreated) {
      this.state.isCreated = true;
      this.options.onCreate(data);
    } else {
      this.options.onUpdate(data);
    }
  }
  /**
   * Helper used to know if the given modifier is enabled.
   * @method
   * @memberof Popper.Utils
   * @returns {Boolean}
   */


  function isModifierEnabled(modifiers, modifierName) {
    return modifiers.some(function (_ref) {
      var name = _ref.name,
          enabled = _ref.enabled;
      return enabled && name === modifierName;
    });
  }
  /**
   * Get the prefixed supported property name
   * @method
   * @memberof Popper.Utils
   * @argument {String} property (camelCase)
   * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
   */


  function getSupportedPropertyName(property) {
    var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
    var upperProp = property.charAt(0).toUpperCase() + property.slice(1);

    for (var i = 0; i < prefixes.length; i++) {
      var prefix = prefixes[i];
      var toCheck = prefix ? '' + prefix + upperProp : property;

      if (typeof document.body.style[toCheck] !== 'undefined') {
        return toCheck;
      }
    }

    return null;
  }
  /**
   * Destroys the popper.
   * @method
   * @memberof Popper
   */


  function destroy() {
    this.state.isDestroyed = true; // touch DOM only if `applyStyle` modifier is enabled

    if (isModifierEnabled(this.modifiers, 'applyStyle')) {
      this.popper.removeAttribute('x-placement');
      this.popper.style.position = '';
      this.popper.style.top = '';
      this.popper.style.left = '';
      this.popper.style.right = '';
      this.popper.style.bottom = '';
      this.popper.style.willChange = '';
      this.popper.style[getSupportedPropertyName('transform')] = '';
    }

    this.disableEventListeners(); // remove the popper if user explicitly asked for the deletion on destroy
    // do not use `remove` because IE11 doesn't support it

    if (this.options.removeOnDestroy) {
      this.popper.parentNode.removeChild(this.popper);
    }

    return this;
  }
  /**
   * Get the window associated with the element
   * @argument {Element} element
   * @returns {Window}
   */


  function getWindow(element) {
    var ownerDocument = element.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView : window;
  }

  function attachToScrollParents(scrollParent, event, callback, scrollParents) {
    var isBody = scrollParent.nodeName === 'BODY';
    var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
    target.addEventListener(event, callback, {
      passive: true
    });

    if (!isBody) {
      attachToScrollParents(getScrollParent$1(target.parentNode), event, callback, scrollParents);
    }

    scrollParents.push(target);
  }
  /**
   * Setup needed event listeners used to update the popper position
   * @method
   * @memberof Popper.Utils
   * @private
   */


  function setupEventListeners(reference, options, state, updateBound) {
    // Resize event listener on window
    state.updateBound = updateBound;
    getWindow(reference).addEventListener('resize', state.updateBound, {
      passive: true
    }); // Scroll event listener on scroll parents

    var scrollElement = getScrollParent$1(reference);
    attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
    state.scrollElement = scrollElement;
    state.eventsEnabled = true;
    return state;
  }
  /**
   * It will add resize/scroll events and start recalculating
   * position of the popper element when they are triggered.
   * @method
   * @memberof Popper
   */


  function enableEventListeners() {
    if (!this.state.eventsEnabled) {
      this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
    }
  }
  /**
   * Remove event listeners used to update the popper position
   * @method
   * @memberof Popper.Utils
   * @private
   */


  function removeEventListeners(reference, state) {
    // Remove resize event listener on window
    getWindow(reference).removeEventListener('resize', state.updateBound); // Remove scroll event listener on scroll parents

    state.scrollParents.forEach(function (target) {
      target.removeEventListener('scroll', state.updateBound);
    }); // Reset state

    state.updateBound = null;
    state.scrollParents = [];
    state.scrollElement = null;
    state.eventsEnabled = false;
    return state;
  }
  /**
   * It will remove resize/scroll events and won't recalculate popper position
   * when they are triggered. It also won't trigger `onUpdate` callback anymore,
   * unless you call `update` method manually.
   * @method
   * @memberof Popper
   */


  function disableEventListeners() {
    if (this.state.eventsEnabled) {
      cancelAnimationFrame(this.scheduleUpdate);
      this.state = removeEventListeners(this.reference, this.state);
    }
  }
  /**
   * Tells if a given input is a number
   * @method
   * @memberof Popper.Utils
   * @param {*} input to check
   * @return {Boolean}
   */


  function isNumeric(n) {
    return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
  }
  /**
   * Set the style to the given popper
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element - Element to apply the style to
   * @argument {Object} styles
   * Object with a list of properties and values which will be applied to the element
   */


  function setStyles(element, styles) {
    Object.keys(styles).forEach(function (prop) {
      var unit = ''; // add unit if the value is numeric and is one of the following

      if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
        unit = 'px';
      }

      element.style[prop] = styles[prop] + unit;
    });
  }
  /**
   * Set the attributes to the given popper
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element - Element to apply the attributes to
   * @argument {Object} styles
   * Object with a list of properties and values which will be applied to the element
   */


  function setAttributes(element, attributes) {
    Object.keys(attributes).forEach(function (prop) {
      var value = attributes[prop];

      if (value !== false) {
        element.setAttribute(prop, attributes[prop]);
      } else {
        element.removeAttribute(prop);
      }
    });
  }
  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} data.styles - List of style properties - values to apply to popper element
   * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The same data object
   */


  function applyStyle(data) {
    // any property present in `data.styles` will be applied to the popper,
    // in this way we can make the 3rd party modifiers add custom styles to it
    // Be aware, modifiers could override the properties defined in the previous
    // lines of this modifier!
    setStyles(data.instance.popper, data.styles); // any property present in `data.attributes` will be applied to the popper,
    // they will be set as HTML attributes of the element

    setAttributes(data.instance.popper, data.attributes); // if arrowElement is defined and arrowStyles has some properties

    if (data.arrowElement && Object.keys(data.arrowStyles).length) {
      setStyles(data.arrowElement, data.arrowStyles);
    }

    return data;
  }
  /**
   * Set the x-placement attribute before everything else because it could be used
   * to add margins to the popper margins needs to be calculated to get the
   * correct popper offsets.
   * @method
   * @memberof Popper.modifiers
   * @param {HTMLElement} reference - The reference element used to position the popper
   * @param {HTMLElement} popper - The HTML element used as popper
   * @param {Object} options - Popper.js options
   */


  function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
    // compute reference element offsets
    var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed); // compute auto placement, store placement inside the data object,
    // modifiers will be able to edit `placement` if needed
    // and refer to originalPlacement to know the original value

    var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);
    popper.setAttribute('x-placement', placement); // Apply `position` to popper before anything else because
    // without the position applied we can't guarantee correct computations

    setStyles(popper, {
      position: options.positionFixed ? 'fixed' : 'absolute'
    });
    return options;
  }
  /**
   * @function
   * @memberof Popper.Utils
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Boolean} shouldRound - If the offsets should be rounded at all
   * @returns {Object} The popper's position offsets rounded
   *
   * The tale of pixel-perfect positioning. It's still not 100% perfect, but as
   * good as it can be within reason.
   * Discussion here: https://github.com/FezVrasta/popper.js/pull/715
   *
   * Low DPI screens cause a popper to be blurry if not using full pixels (Safari
   * as well on High DPI screens).
   *
   * Firefox prefers no rounding for positioning and does not have blurriness on
   * high DPI screens.
   *
   * Only horizontal placement and left/right values need to be considered.
   */


  function getRoundedOffsets(data, shouldRound) {
    var _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;
    var round = Math.round,
        floor = Math.floor;

    var noRound = function noRound(v) {
      return v;
    };

    var referenceWidth = round(reference.width);
    var popperWidth = round(popper.width);
    var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;
    var isVariation = data.placement.indexOf('-') !== -1;
    var sameWidthParity = referenceWidth % 2 === popperWidth % 2;
    var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;
    var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;
    var verticalToInteger = !shouldRound ? noRound : round;
    return {
      left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),
      top: verticalToInteger(popper.top),
      bottom: verticalToInteger(popper.bottom),
      right: horizontalToInteger(popper.right)
    };
  }

  var isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);
  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */

  function computeStyle(data, options) {
    var x = options.x,
        y = options.y;
    var popper = data.offsets.popper; // Remove this legacy support in Popper.js v2

    var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
      return modifier.name === 'applyStyle';
    }).gpuAcceleration;

    if (legacyGpuAccelerationOption !== undefined) {
      console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
    }

    var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;
    var offsetParent = getOffsetParent(data.instance.popper);
    var offsetParentRect = getBoundingClientRect(offsetParent); // Styles

    var styles = {
      position: popper.position
    };
    var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);
    var sideA = x === 'bottom' ? 'top' : 'bottom';
    var sideB = y === 'right' ? 'left' : 'right'; // if gpuAcceleration is set to `true` and transform is supported,
    //  we use `translate3d` to apply the position to the popper we
    // automatically use the supported prefixed version if needed

    var prefixedProperty = getSupportedPropertyName('transform'); // now, let's make a step back and look at this code closely (wtf?)
    // If the content of the popper grows once it's been positioned, it
    // may happen that the popper gets misplaced because of the new content
    // overflowing its reference element
    // To avoid this problem, we provide two options (x and y), which allow
    // the consumer to define the offset origin.
    // If we position a popper on top of a reference element, we can set
    // `x` to `top` to make the popper grow towards its top instead of
    // its bottom.

    var left = void 0,
        top = void 0;

    if (sideA === 'bottom') {
      // when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)
      // and not the bottom of the html element
      if (offsetParent.nodeName === 'HTML') {
        top = -offsetParent.clientHeight + offsets.bottom;
      } else {
        top = -offsetParentRect.height + offsets.bottom;
      }
    } else {
      top = offsets.top;
    }

    if (sideB === 'right') {
      if (offsetParent.nodeName === 'HTML') {
        left = -offsetParent.clientWidth + offsets.right;
      } else {
        left = -offsetParentRect.width + offsets.right;
      }
    } else {
      left = offsets.left;
    }

    if (gpuAcceleration && prefixedProperty) {
      styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
      styles[sideA] = 0;
      styles[sideB] = 0;
      styles.willChange = 'transform';
    } else {
      // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
      var invertTop = sideA === 'bottom' ? -1 : 1;
      var invertLeft = sideB === 'right' ? -1 : 1;
      styles[sideA] = top * invertTop;
      styles[sideB] = left * invertLeft;
      styles.willChange = sideA + ', ' + sideB;
    } // Attributes


    var attributes = {
      'x-placement': data.placement
    }; // Update `data` attributes, styles and arrowStyles

    data.attributes = _extends({}, attributes, data.attributes);
    data.styles = _extends({}, styles, data.styles);
    data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);
    return data;
  }
  /**
   * Helper used to know if the given modifier depends from another one.<br />
   * It checks if the needed modifier is listed and enabled.
   * @method
   * @memberof Popper.Utils
   * @param {Array} modifiers - list of modifiers
   * @param {String} requestingName - name of requesting modifier
   * @param {String} requestedName - name of requested modifier
   * @returns {Boolean}
   */


  function isModifierRequired(modifiers, requestingName, requestedName) {
    var requesting = find(modifiers, function (_ref) {
      var name = _ref.name;
      return name === requestingName;
    });
    var isRequired = !!requesting && modifiers.some(function (modifier) {
      return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
    });

    if (!isRequired) {
      var _requesting = '`' + requestingName + '`';

      var requested = '`' + requestedName + '`';
      console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
    }

    return isRequired;
  }
  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */


  function arrow(data, options) {
    var _data$offsets$arrow; // arrow depends on keepTogether in order to work


    if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
      return data;
    }

    var arrowElement = options.element; // if arrowElement is a string, suppose it's a CSS selector

    if (typeof arrowElement === 'string') {
      arrowElement = data.instance.popper.querySelector(arrowElement); // if arrowElement is not found, don't run the modifier

      if (!arrowElement) {
        return data;
      }
    } else {
      // if the arrowElement isn't a query selector we must check that the
      // provided DOM node is child of its popper node
      if (!data.instance.popper.contains(arrowElement)) {
        console.warn('WARNING: `arrow.element` must be child of its popper element!');
        return data;
      }
    }

    var placement = data.placement.split('-')[0];
    var _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;
    var isVertical = ['left', 'right'].indexOf(placement) !== -1;
    var len = isVertical ? 'height' : 'width';
    var sideCapitalized = isVertical ? 'Top' : 'Left';
    var side = sideCapitalized.toLowerCase();
    var altSide = isVertical ? 'left' : 'top';
    var opSide = isVertical ? 'bottom' : 'right';
    var arrowElementSize = getOuterSizes(arrowElement)[len]; //
    // extends keepTogether behavior making sure the popper and its
    // reference have enough pixels in conjunction
    //
    // top/left side

    if (reference[opSide] - arrowElementSize < popper[side]) {
      data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
    } // bottom/right side


    if (reference[side] + arrowElementSize > popper[opSide]) {
      data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
    }

    data.offsets.popper = getClientRect(data.offsets.popper); // compute center of the popper

    var center = reference[side] + reference[len] / 2 - arrowElementSize / 2; // Compute the sideValue using the updated popper offsets
    // take popper margin in account because we don't have this info available

    var css = getStyleComputedProperty(data.instance.popper);
    var popperMarginSide = parseFloat(css['margin' + sideCapitalized]);
    var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width']);
    var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide; // prevent arrowElement from being placed not contiguously to its popper

    sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);
    data.arrowElement = arrowElement;
    data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty$2(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty$2(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);
    return data;
  }
  /**
   * Get the opposite placement variation of the given one
   * @method
   * @memberof Popper.Utils
   * @argument {String} placement variation
   * @returns {String} flipped placement variation
   */


  function getOppositeVariation(variation) {
    if (variation === 'end') {
      return 'start';
    } else if (variation === 'start') {
      return 'end';
    }

    return variation;
  }
  /**
   * List of accepted placements to use as values of the `placement` option.<br />
   * Valid placements are:
   * - `auto`
   * - `top`
   * - `right`
   * - `bottom`
   * - `left`
   *
   * Each placement can have a variation from this list:
   * - `-start`
   * - `-end`
   *
   * Variations are interpreted easily if you think of them as the left to right
   * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
   * is right.<br />
   * Vertically (`left` and `right`), `start` is top and `end` is bottom.
   *
   * Some valid examples are:
   * - `top-end` (on top of reference, right aligned)
   * - `right-start` (on right of reference, top aligned)
   * - `bottom` (on bottom, centered)
   * - `auto-end` (on the side with more space available, alignment depends by placement)
   *
   * @static
   * @type {Array}
   * @enum {String}
   * @readonly
   * @method placements
   * @memberof Popper
   */


  var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start']; // Get rid of `auto` `auto-start` and `auto-end`

  var validPlacements = placements.slice(3);
  /**
   * Given an initial placement, returns all the subsequent placements
   * clockwise (or counter-clockwise).
   *
   * @method
   * @memberof Popper.Utils
   * @argument {String} placement - A valid placement (it accepts variations)
   * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
   * @returns {Array} placements including their variations
   */

  function clockwise(placement) {
    var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var index = validPlacements.indexOf(placement);
    var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
    return counter ? arr.reverse() : arr;
  }

  var BEHAVIORS = {
    FLIP: 'flip',
    CLOCKWISE: 'clockwise',
    COUNTERCLOCKWISE: 'counterclockwise'
  };
  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */

  function flip(data, options) {
    // if `inner` modifier is enabled, we can't use the `flip` modifier
    if (isModifierEnabled(data.instance.modifiers, 'inner')) {
      return data;
    }

    if (data.flipped && data.placement === data.originalPlacement) {
      // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
      return data;
    }

    var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);
    var placement = data.placement.split('-')[0];
    var placementOpposite = getOppositePlacement(placement);
    var variation = data.placement.split('-')[1] || '';
    var flipOrder = [];

    switch (options.behavior) {
      case BEHAVIORS.FLIP:
        flipOrder = [placement, placementOpposite];
        break;

      case BEHAVIORS.CLOCKWISE:
        flipOrder = clockwise(placement);
        break;

      case BEHAVIORS.COUNTERCLOCKWISE:
        flipOrder = clockwise(placement, true);
        break;

      default:
        flipOrder = options.behavior;
    }

    flipOrder.forEach(function (step, index) {
      if (placement !== step || flipOrder.length === index + 1) {
        return data;
      }

      placement = data.placement.split('-')[0];
      placementOpposite = getOppositePlacement(placement);
      var popperOffsets = data.offsets.popper;
      var refOffsets = data.offsets.reference; // using floor because the reference offsets may contain decimals we are not going to consider here

      var floor = Math.floor;
      var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);
      var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
      var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
      var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
      var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);
      var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom; // flip the variation if required

      var isVertical = ['top', 'bottom'].indexOf(placement) !== -1; // flips variation if reference element overflows boundaries

      var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom); // flips variation if popper content overflows boundaries

      var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === 'start' && overflowsRight || isVertical && variation === 'end' && overflowsLeft || !isVertical && variation === 'start' && overflowsBottom || !isVertical && variation === 'end' && overflowsTop);
      var flippedVariation = flippedVariationByRef || flippedVariationByContent;

      if (overlapsRef || overflowsBoundaries || flippedVariation) {
        // this boolean to detect any flip loop
        data.flipped = true;

        if (overlapsRef || overflowsBoundaries) {
          placement = flipOrder[index + 1];
        }

        if (flippedVariation) {
          variation = getOppositeVariation(variation);
        }

        data.placement = placement + (variation ? '-' + variation : ''); // this object contains `position`, we want to preserve it along with
        // any additional property we may add in the future

        data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));
        data = runModifiers(data.instance.modifiers, data, 'flip');
      }
    });
    return data;
  }
  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */


  function keepTogether(data) {
    var _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;
    var placement = data.placement.split('-')[0];
    var floor = Math.floor;
    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
    var side = isVertical ? 'right' : 'bottom';
    var opSide = isVertical ? 'left' : 'top';
    var measurement = isVertical ? 'width' : 'height';

    if (popper[side] < floor(reference[opSide])) {
      data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
    }

    if (popper[opSide] > floor(reference[side])) {
      data.offsets.popper[opSide] = floor(reference[side]);
    }

    return data;
  }
  /**
   * Converts a string containing value + unit into a px value number
   * @function
   * @memberof {modifiers~offset}
   * @private
   * @argument {String} str - Value + unit string
   * @argument {String} measurement - `height` or `width`
   * @argument {Object} popperOffsets
   * @argument {Object} referenceOffsets
   * @returns {Number|String}
   * Value in pixels, or original string if no values were extracted
   */


  function toValue(str, measurement, popperOffsets, referenceOffsets) {
    // separate value from unit
    var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
    var value = +split[1];
    var unit = split[2]; // If it's not a number it's an operator, I guess

    if (!value) {
      return str;
    }

    if (unit.indexOf('%') === 0) {
      var element = void 0;

      switch (unit) {
        case '%p':
          element = popperOffsets;
          break;

        case '%':
        case '%r':
        default:
          element = referenceOffsets;
      }

      var rect = getClientRect(element);
      return rect[measurement] / 100 * value;
    } else if (unit === 'vh' || unit === 'vw') {
      // if is a vh or vw, we calculate the size based on the viewport
      var size = void 0;

      if (unit === 'vh') {
        size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
      } else {
        size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
      }

      return size / 100 * value;
    } else {
      // if is an explicit pixel unit, we get rid of the unit and keep the value
      // if is an implicit unit, it's px, and we return just the value
      return value;
    }
  }
  /**
   * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
   * @function
   * @memberof {modifiers~offset}
   * @private
   * @argument {String} offset
   * @argument {Object} popperOffsets
   * @argument {Object} referenceOffsets
   * @argument {String} basePlacement
   * @returns {Array} a two cells array with x and y offsets in numbers
   */


  function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
    var offsets = [0, 0]; // Use height if placement is left or right and index is 0 otherwise use width
    // in this way the first offset will use an axis and the second one
    // will use the other one

    var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1; // Split the offset string to obtain a list of values and operands
    // The regex addresses values with the plus or minus sign in front (+10, -20, etc)

    var fragments = offset.split(/(\+|\-)/).map(function (frag) {
      return frag.trim();
    }); // Detect if the offset string contains a pair of values or a single one
    // they could be separated by comma or space

    var divider = fragments.indexOf(find(fragments, function (frag) {
      return frag.search(/,|\s/) !== -1;
    }));

    if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
      console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
    } // If divider is found, we divide the list of values and operands to divide
    // them by ofset X and Y.


    var splitRegex = /\s*,\s*|\s+/;
    var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments]; // Convert the values with units to absolute pixels to allow our computations

    ops = ops.map(function (op, index) {
      // Most of the units rely on the orientation of the popper
      var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
      var mergeWithPrevious = false;
      return op // This aggregates any `+` or `-` sign that aren't considered operators
      // e.g.: 10 + +5 => [10, +, +5]
      .reduce(function (a, b) {
        if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
          a[a.length - 1] = b;
          mergeWithPrevious = true;
          return a;
        } else if (mergeWithPrevious) {
          a[a.length - 1] += b;
          mergeWithPrevious = false;
          return a;
        } else {
          return a.concat(b);
        }
      }, []) // Here we convert the string values into number values (in px)
      .map(function (str) {
        return toValue(str, measurement, popperOffsets, referenceOffsets);
      });
    }); // Loop trough the offsets arrays and execute the operations

    ops.forEach(function (op, index) {
      op.forEach(function (frag, index2) {
        if (isNumeric(frag)) {
          offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
        }
      });
    });
    return offsets;
  }
  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @argument {Number|String} options.offset=0
   * The offset value as described in the modifier description
   * @returns {Object} The data object, properly modified
   */


  function offset(data, _ref) {
    var offset = _ref.offset;
    var placement = data.placement,
        _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;
    var basePlacement = placement.split('-')[0];
    var offsets = void 0;

    if (isNumeric(+offset)) {
      offsets = [+offset, 0];
    } else {
      offsets = parseOffset(offset, popper, reference, basePlacement);
    }

    if (basePlacement === 'left') {
      popper.top += offsets[0];
      popper.left -= offsets[1];
    } else if (basePlacement === 'right') {
      popper.top += offsets[0];
      popper.left += offsets[1];
    } else if (basePlacement === 'top') {
      popper.left += offsets[0];
      popper.top -= offsets[1];
    } else if (basePlacement === 'bottom') {
      popper.left += offsets[0];
      popper.top += offsets[1];
    }

    data.popper = popper;
    return data;
  }
  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */


  function preventOverflow(data, options) {
    var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper); // If offsetParent is the reference element, we really want to
    // go one step up and use the next offsetParent as reference to
    // avoid to make this modifier completely useless and look like broken

    if (data.instance.reference === boundariesElement) {
      boundariesElement = getOffsetParent(boundariesElement);
    } // NOTE: DOM access here
    // resets the popper's position so that the document size can be calculated excluding
    // the size of the popper element itself


    var transformProp = getSupportedPropertyName('transform');
    var popperStyles = data.instance.popper.style; // assignment to help minification

    var top = popperStyles.top,
        left = popperStyles.left,
        transform = popperStyles[transformProp];
    popperStyles.top = '';
    popperStyles.left = '';
    popperStyles[transformProp] = '';
    var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed); // NOTE: DOM access here
    // restores the original style properties after the offsets have been computed

    popperStyles.top = top;
    popperStyles.left = left;
    popperStyles[transformProp] = transform;
    options.boundaries = boundaries;
    var order = options.priority;
    var popper = data.offsets.popper;
    var check = {
      primary: function primary(placement) {
        var value = popper[placement];

        if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
          value = Math.max(popper[placement], boundaries[placement]);
        }

        return defineProperty$2({}, placement, value);
      },
      secondary: function secondary(placement) {
        var mainSide = placement === 'right' ? 'left' : 'top';
        var value = popper[mainSide];

        if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
          value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
        }

        return defineProperty$2({}, mainSide, value);
      }
    };
    order.forEach(function (placement) {
      var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
      popper = _extends({}, popper, check[side](placement));
    });
    data.offsets.popper = popper;
    return data;
  }
  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */


  function shift(data) {
    var placement = data.placement;
    var basePlacement = placement.split('-')[0];
    var shiftvariation = placement.split('-')[1]; // if shift shiftvariation is specified, run the modifier

    if (shiftvariation) {
      var _data$offsets = data.offsets,
          reference = _data$offsets.reference,
          popper = _data$offsets.popper;
      var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
      var side = isVertical ? 'left' : 'top';
      var measurement = isVertical ? 'width' : 'height';
      var shiftOffsets = {
        start: defineProperty$2({}, side, reference[side]),
        end: defineProperty$2({}, side, reference[side] + reference[measurement] - popper[measurement])
      };
      data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
    }

    return data;
  }
  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */


  function hide(data) {
    if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
      return data;
    }

    var refRect = data.offsets.reference;
    var bound = find(data.instance.modifiers, function (modifier) {
      return modifier.name === 'preventOverflow';
    }).boundaries;

    if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
      // Avoid unnecessary DOM access if visibility hasn't changed
      if (data.hide === true) {
        return data;
      }

      data.hide = true;
      data.attributes['x-out-of-boundaries'] = '';
    } else {
      // Avoid unnecessary DOM access if visibility hasn't changed
      if (data.hide === false) {
        return data;
      }

      data.hide = false;
      data.attributes['x-out-of-boundaries'] = false;
    }

    return data;
  }
  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */


  function inner(data) {
    var placement = data.placement;
    var basePlacement = placement.split('-')[0];
    var _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;
    var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;
    var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;
    popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);
    data.placement = getOppositePlacement(placement);
    data.offsets.popper = getClientRect(popper);
    return data;
  }
  /**
   * Modifier function, each modifier can have a function of this type assigned
   * to its `fn` property.<br />
   * These functions will be called on each update, this means that you must
   * make sure they are performant enough to avoid performance bottlenecks.
   *
   * @function ModifierFn
   * @argument {dataObject} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {dataObject} The data object, properly modified
   */

  /**
   * Modifiers are plugins used to alter the behavior of your poppers.<br />
   * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
   * needed by the library.
   *
   * Usually you don't want to override the `order`, `fn` and `onLoad` props.
   * All the other properties are configurations that could be tweaked.
   * @namespace modifiers
   */


  var modifiers = {
    /**
     * Modifier used to shift the popper on the start or end of its reference
     * element.<br />
     * It will read the variation of the `placement` property.<br />
     * It can be one either `-end` or `-start`.
     * @memberof modifiers
     * @inner
     */
    shift: {
      /** @prop {number} order=100 - Index used to define the order of execution */
      order: 100,

      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,

      /** @prop {ModifierFn} */
      fn: shift
    },

    /**
     * The `offset` modifier can shift your popper on both its axis.
     *
     * It accepts the following units:
     * - `px` or unit-less, interpreted as pixels
     * - `%` or `%r`, percentage relative to the length of the reference element
     * - `%p`, percentage relative to the length of the popper element
     * - `vw`, CSS viewport width unit
     * - `vh`, CSS viewport height unit
     *
     * For length is intended the main axis relative to the placement of the popper.<br />
     * This means that if the placement is `top` or `bottom`, the length will be the
     * `width`. In case of `left` or `right`, it will be the `height`.
     *
     * You can provide a single value (as `Number` or `String`), or a pair of values
     * as `String` divided by a comma or one (or more) white spaces.<br />
     * The latter is a deprecated method because it leads to confusion and will be
     * removed in v2.<br />
     * Additionally, it accepts additions and subtractions between different units.
     * Note that multiplications and divisions aren't supported.
     *
     * Valid examples are:
     * ```
     * 10
     * '10%'
     * '10, 10'
     * '10%, 10'
     * '10 + 10%'
     * '10 - 5vh + 3%'
     * '-10px + 5vh, 5px - 6%'
     * ```
     * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
     * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
     * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).
     *
     * @memberof modifiers
     * @inner
     */
    offset: {
      /** @prop {number} order=200 - Index used to define the order of execution */
      order: 200,

      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,

      /** @prop {ModifierFn} */
      fn: offset,

      /** @prop {Number|String} offset=0
       * The offset value as described in the modifier description
       */
      offset: 0
    },

    /**
     * Modifier used to prevent the popper from being positioned outside the boundary.
     *
     * A scenario exists where the reference itself is not within the boundaries.<br />
     * We can say it has "escaped the boundaries" — or just "escaped".<br />
     * In this case we need to decide whether the popper should either:
     *
     * - detach from the reference and remain "trapped" in the boundaries, or
     * - if it should ignore the boundary and "escape with its reference"
     *
     * When `escapeWithReference` is set to`true` and reference is completely
     * outside its boundaries, the popper will overflow (or completely leave)
     * the boundaries in order to remain attached to the edge of the reference.
     *
     * @memberof modifiers
     * @inner
     */
    preventOverflow: {
      /** @prop {number} order=300 - Index used to define the order of execution */
      order: 300,

      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,

      /** @prop {ModifierFn} */
      fn: preventOverflow,

      /**
       * @prop {Array} [priority=['left','right','top','bottom']]
       * Popper will try to prevent overflow following these priorities by default,
       * then, it could overflow on the left and on top of the `boundariesElement`
       */
      priority: ['left', 'right', 'top', 'bottom'],

      /**
       * @prop {number} padding=5
       * Amount of pixel used to define a minimum distance between the boundaries
       * and the popper. This makes sure the popper always has a little padding
       * between the edges of its container
       */
      padding: 5,

      /**
       * @prop {String|HTMLElement} boundariesElement='scrollParent'
       * Boundaries used by the modifier. Can be `scrollParent`, `window`,
       * `viewport` or any DOM element.
       */
      boundariesElement: 'scrollParent'
    },

    /**
     * Modifier used to make sure the reference and its popper stay near each other
     * without leaving any gap between the two. Especially useful when the arrow is
     * enabled and you want to ensure that it points to its reference element.
     * It cares only about the first axis. You can still have poppers with margin
     * between the popper and its reference element.
     * @memberof modifiers
     * @inner
     */
    keepTogether: {
      /** @prop {number} order=400 - Index used to define the order of execution */
      order: 400,

      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,

      /** @prop {ModifierFn} */
      fn: keepTogether
    },

    /**
     * This modifier is used to move the `arrowElement` of the popper to make
     * sure it is positioned between the reference element and its popper element.
     * It will read the outer size of the `arrowElement` node to detect how many
     * pixels of conjunction are needed.
     *
     * It has no effect if no `arrowElement` is provided.
     * @memberof modifiers
     * @inner
     */
    arrow: {
      /** @prop {number} order=500 - Index used to define the order of execution */
      order: 500,

      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,

      /** @prop {ModifierFn} */
      fn: arrow,

      /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
      element: '[x-arrow]'
    },

    /**
     * Modifier used to flip the popper's placement when it starts to overlap its
     * reference element.
     *
     * Requires the `preventOverflow` modifier before it in order to work.
     *
     * **NOTE:** this modifier will interrupt the current update cycle and will
     * restart it if it detects the need to flip the placement.
     * @memberof modifiers
     * @inner
     */
    flip: {
      /** @prop {number} order=600 - Index used to define the order of execution */
      order: 600,

      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,

      /** @prop {ModifierFn} */
      fn: flip,

      /**
       * @prop {String|Array} behavior='flip'
       * The behavior used to change the popper's placement. It can be one of
       * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
       * placements (with optional variations)
       */
      behavior: 'flip',

      /**
       * @prop {number} padding=5
       * The popper will flip if it hits the edges of the `boundariesElement`
       */
      padding: 5,

      /**
       * @prop {String|HTMLElement} boundariesElement='viewport'
       * The element which will define the boundaries of the popper position.
       * The popper will never be placed outside of the defined boundaries
       * (except if `keepTogether` is enabled)
       */
      boundariesElement: 'viewport',

      /**
       * @prop {Boolean} flipVariations=false
       * The popper will switch placement variation between `-start` and `-end` when
       * the reference element overlaps its boundaries.
       *
       * The original placement should have a set variation.
       */
      flipVariations: false,

      /**
       * @prop {Boolean} flipVariationsByContent=false
       * The popper will switch placement variation between `-start` and `-end` when
       * the popper element overlaps its reference boundaries.
       *
       * The original placement should have a set variation.
       */
      flipVariationsByContent: false
    },

    /**
     * Modifier used to make the popper flow toward the inner of the reference element.
     * By default, when this modifier is disabled, the popper will be placed outside
     * the reference element.
     * @memberof modifiers
     * @inner
     */
    inner: {
      /** @prop {number} order=700 - Index used to define the order of execution */
      order: 700,

      /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
      enabled: false,

      /** @prop {ModifierFn} */
      fn: inner
    },

    /**
     * Modifier used to hide the popper when its reference element is outside of the
     * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
     * be used to hide with a CSS selector the popper when its reference is
     * out of boundaries.
     *
     * Requires the `preventOverflow` modifier before it in order to work.
     * @memberof modifiers
     * @inner
     */
    hide: {
      /** @prop {number} order=800 - Index used to define the order of execution */
      order: 800,

      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,

      /** @prop {ModifierFn} */
      fn: hide
    },

    /**
     * Computes the style that will be applied to the popper element to gets
     * properly positioned.
     *
     * Note that this modifier will not touch the DOM, it just prepares the styles
     * so that `applyStyle` modifier can apply it. This separation is useful
     * in case you need to replace `applyStyle` with a custom implementation.
     *
     * This modifier has `850` as `order` value to maintain backward compatibility
     * with previous versions of Popper.js. Expect the modifiers ordering method
     * to change in future major versions of the library.
     *
     * @memberof modifiers
     * @inner
     */
    computeStyle: {
      /** @prop {number} order=850 - Index used to define the order of execution */
      order: 850,

      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,

      /** @prop {ModifierFn} */
      fn: computeStyle,

      /**
       * @prop {Boolean} gpuAcceleration=true
       * If true, it uses the CSS 3D transformation to position the popper.
       * Otherwise, it will use the `top` and `left` properties
       */
      gpuAcceleration: true,

      /**
       * @prop {string} [x='bottom']
       * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
       * Change this if your popper should grow in a direction different from `bottom`
       */
      x: 'bottom',

      /**
       * @prop {string} [x='left']
       * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
       * Change this if your popper should grow in a direction different from `right`
       */
      y: 'right'
    },

    /**
     * Applies the computed styles to the popper element.
     *
     * All the DOM manipulations are limited to this modifier. This is useful in case
     * you want to integrate Popper.js inside a framework or view library and you
     * want to delegate all the DOM manipulations to it.
     *
     * Note that if you disable this modifier, you must make sure the popper element
     * has its position set to `absolute` before Popper.js can do its work!
     *
     * Just disable this modifier and define your own to achieve the desired effect.
     *
     * @memberof modifiers
     * @inner
     */
    applyStyle: {
      /** @prop {number} order=900 - Index used to define the order of execution */
      order: 900,

      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,

      /** @prop {ModifierFn} */
      fn: applyStyle,

      /** @prop {Function} */
      onLoad: applyStyleOnLoad,

      /**
       * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
       * @prop {Boolean} gpuAcceleration=true
       * If true, it uses the CSS 3D transformation to position the popper.
       * Otherwise, it will use the `top` and `left` properties
       */
      gpuAcceleration: undefined
    }
  };
  /**
   * The `dataObject` is an object containing all the information used by Popper.js.
   * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
   * @name dataObject
   * @property {Object} data.instance The Popper.js instance
   * @property {String} data.placement Placement applied to popper
   * @property {String} data.originalPlacement Placement originally defined on init
   * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
   * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper
   * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
   * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)
   * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)
   * @property {Object} data.boundaries Offsets of the popper boundaries
   * @property {Object} data.offsets The measurements of popper, reference and arrow elements
   * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
   * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
   * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
   */

  /**
   * Default options provided to Popper.js constructor.<br />
   * These can be overridden using the `options` argument of Popper.js.<br />
   * To override an option, simply pass an object with the same
   * structure of the `options` object, as the 3rd argument. For example:
   * ```
   * new Popper(ref, pop, {
   *   modifiers: {
   *     preventOverflow: { enabled: false }
   *   }
   * })
   * ```
   * @type {Object}
   * @static
   * @memberof Popper
   */

  var Defaults = {
    /**
     * Popper's placement.
     * @prop {Popper.placements} placement='bottom'
     */
    placement: 'bottom',

    /**
     * Set this to true if you want popper to position it self in 'fixed' mode
     * @prop {Boolean} positionFixed=false
     */
    positionFixed: false,

    /**
     * Whether events (resize, scroll) are initially enabled.
     * @prop {Boolean} eventsEnabled=true
     */
    eventsEnabled: true,

    /**
     * Set to true if you want to automatically remove the popper when
     * you call the `destroy` method.
     * @prop {Boolean} removeOnDestroy=false
     */
    removeOnDestroy: false,

    /**
     * Callback called when the popper is created.<br />
     * By default, it is set to no-op.<br />
     * Access Popper.js instance with `data.instance`.
     * @prop {onCreate}
     */
    onCreate: function onCreate() {},

    /**
     * Callback called when the popper is updated. This callback is not called
     * on the initialization/creation of the popper, but only on subsequent
     * updates.<br />
     * By default, it is set to no-op.<br />
     * Access Popper.js instance with `data.instance`.
     * @prop {onUpdate}
     */
    onUpdate: function onUpdate() {},

    /**
     * List of modifiers used to modify the offsets before they are applied to the popper.
     * They provide most of the functionalities of Popper.js.
     * @prop {modifiers}
     */
    modifiers: modifiers
  };
  /**
   * @callback onCreate
   * @param {dataObject} data
   */

  /**
   * @callback onUpdate
   * @param {dataObject} data
   */
  // Utils
  // Methods

  var Popper = function () {
    /**
     * Creates a new Popper.js instance.
     * @class Popper
     * @param {Element|referenceObject} reference - The reference element used to position the popper
     * @param {Element} popper - The HTML / XML element used as the popper
     * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
     * @return {Object} instance - The generated Popper.js instance
     */
    function Popper(reference, popper) {
      var _this = this;

      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      classCallCheck(this, Popper);

      this.scheduleUpdate = function () {
        return requestAnimationFrame(_this.update);
      }; // make update() debounced, so that it only runs at most once-per-tick


      this.update = debounce(this.update.bind(this)); // with {} we create a new object with the options inside it

      this.options = _extends({}, Popper.Defaults, options); // init state

      this.state = {
        isDestroyed: false,
        isCreated: false,
        scrollParents: []
      }; // get reference and popper elements (allow jQuery wrappers)

      this.reference = reference && reference.jquery ? reference[0] : reference;
      this.popper = popper && popper.jquery ? popper[0] : popper; // Deep merge modifiers options

      this.options.modifiers = {};
      Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
        _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
      }); // Refactoring modifiers' list (Object => Array)

      this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
        return _extends({
          name: name
        }, _this.options.modifiers[name]);
      }) // sort the modifiers by order
      .sort(function (a, b) {
        return a.order - b.order;
      }); // modifiers have the ability to execute arbitrary code when Popper.js get inited
      // such code is executed in the same order of its modifier
      // they could add new properties to their options configuration
      // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!

      this.modifiers.forEach(function (modifierOptions) {
        if (modifierOptions.enabled && isFunction$1(modifierOptions.onLoad)) {
          modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
        }
      }); // fire the first update to position the popper in the right place

      this.update();
      var eventsEnabled = this.options.eventsEnabled;

      if (eventsEnabled) {
        // setup event listeners, they will take care of update the position in specific situations
        this.enableEventListeners();
      }

      this.state.eventsEnabled = eventsEnabled;
    } // We can't use class properties because they don't get listed in the
    // class prototype and break stuff like Sinon stubs


    createClass(Popper, [{
      key: 'update',
      value: function update$$1() {
        return update.call(this);
      }
    }, {
      key: 'destroy',
      value: function destroy$$1() {
        return destroy.call(this);
      }
    }, {
      key: 'enableEventListeners',
      value: function enableEventListeners$$1() {
        return enableEventListeners.call(this);
      }
    }, {
      key: 'disableEventListeners',
      value: function disableEventListeners$$1() {
        return disableEventListeners.call(this);
      }
      /**
       * Schedules an update. It will run on the next UI update available.
       * @method scheduleUpdate
       * @memberof Popper
       */

      /**
       * Collection of utilities useful when writing custom modifiers.
       * Starting from version 1.7, this method is available only if you
       * include `popper-utils.js` before `popper.js`.
       *
       * **DEPRECATION**: This way to access PopperUtils is deprecated
       * and will be removed in v2! Use the PopperUtils module directly instead.
       * Due to the high instability of the methods contained in Utils, we can't
       * guarantee them to follow semver. Use them at your own risk!
       * @static
       * @private
       * @type {Object}
       * @deprecated since version 1.8
       * @member Utils
       * @memberof Popper
       */

    }]);
    return Popper;
  }();
  /**
   * The `referenceObject` is an object that provides an interface compatible with Popper.js
   * and lets you use it as replacement of a real DOM node.<br />
   * You can use this method to position a popper relatively to a set of coordinates
   * in case you don't have a DOM node to use as reference.
   *
   * ```
   * new Popper(referenceObject, popperNode);
   * ```
   *
   * NB: This feature isn't supported in Internet Explorer 10.
   * @name referenceObject
   * @property {Function} data.getBoundingClientRect
   * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
   * @property {number} data.clientWidth
   * An ES6 getter that will return the width of the virtual reference element.
   * @property {number} data.clientHeight
   * An ES6 getter that will return the height of the virtual reference element.
   */


  Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
  Popper.placements = placements;
  Popper.Defaults = Defaults;

  var DEPRECATED_ALIGN = 'Coral.Overlay: alignAt and alignMy have been deprecated. Please use the offset, inner and placement properties instead.';
  var DEPRECATED_FLIP_FIT = 'Coral.Overlay.collision.FLIP_FIT has been deprecated. Please use Coral.Overlay.collision.FLIP instead.';
  /**
   Enumeration for {@link Overlay} alignment pairs.
   @deprecated

   @typedef {Object} OverlayAlignEnum

   @property {String} LEFT_TOP
   Use the top of the left side as an anchor point.
   @property {String} LEFT_CENTER
   Use the center of the left side as an anchor point.
   @property {String} LEFT_BOTTOM
   Use the bottom of the left side as an anchor point.
   @property {String} CENTER_TOP
   Use the center of the top side as an anchor point.
   @property {String} CENTER_CENTER
   Use the center as an anchor point.
   @property {String} CENTER_BOTTOM
   Use the center of the bottom side as an anchor point.
   @property {String} RIGHT_TOP
   Use the top of the right side as an anchor point.
   @property {String} RIGHT_CENTER
   Use the center of the right side as an anchor point.
   @property {String} RIGHT_BOTTOM
   Use the bottom of the right side as an anchor point.
   */

  var align = {
    LEFT_TOP: 'left top',
    LEFT_CENTER: 'left center',
    LEFT_BOTTOM: 'left bottom',
    CENTER_TOP: 'center top',
    CENTER_CENTER: 'center center',
    CENTER_BOTTOM: 'center bottom',
    RIGHT_TOP: 'right top',
    RIGHT_CENTER: 'right center',
    RIGHT_BOTTOM: 'right bottom'
  };
  /**
   Enumeration for {@link Overlay} collision detection strategies.

   @typedef {Object} OverlayCollisionEnum

   @property {String} FLIP
   Flips the element to the opposite side of the target and the collision detection is run again to see if it will fit. Whichever side allows more of the element to be visible will be used.
   @property {String} FIT
   Shift the element away from the edge of the window.
   @property {String} FLIP_FIT
   Deprecated. First applies the flip logic, placing the element on whichever side allows more of the element to be visible. Then the fit logic is applied to ensure as much of the element is visible as possible.
   @property {String} NONE
   Does not apply any collision detection.
   */

  var collision = {
    FLIP: 'flip',
    FIT: 'fit',
    FLIP_FIT: 'flipfit',
    NONE: 'none'
  };
  /**
   Enumeration for {@link Overlay} anchored overlay targets.

   @typedef {Object} OverlayTargetEnum

   @property {String} PREVIOUS
   Use the previous sibling element in the DOM.
   @property {String} NEXT
   Use the next sibling element in the DOM.
   */

  var target = {
    PREVIOUS: '_prev',
    NEXT: '_next'
  };
  /**
   Enumeration for {@link Overlay} placement values.

   @typedef {Object} OverlayPlacementEnum

   @property {String} LEFT
   An overlay anchored to the left of the target.
   @property {String} RIGHT
   An overlay anchored to the right of the target.
   @property {String} BOTTOM
   An overlay anchored at the bottom the target.
   @property {String} TOP
   An overlay anchored at the top target.
   */

  var placement = {
    LEFT: 'left',
    RIGHT: 'right',
    BOTTOM: 'bottom',
    TOP: 'top'
  };
  /**
   Enumeration for {@link Overlay} interaction values.

   @typedef {Object} OverlayInteractionEnum

   @property {String} ON
   Keyboard interaction is enabled.
   @property {String} OFF
   Keyboard interaction is disabled.
   */

  var interaction$1 = {
    ON: 'on',
    OFF: 'off'
  };
  var CLASSNAME$i = '_coral-Overlay';
  /**
   @class Coral.Overlay
   @classdesc A generic Overlay component.
   @htmltag coral-overlay
   @extends {HTMLElement}
   @extends {BaseComponent}
   @extends {BaseOverlay}
   */

  var ExtensibleOverlay = /*#__PURE__*/function (_BaseOverlay) {
    _inherits(ExtensibleOverlay, _BaseOverlay);

    var _super = _createSuper(ExtensibleOverlay);

    /** @ignore */
    function ExtensibleOverlay() {
      var _this;

      _classCallCheck(this, ExtensibleOverlay);

      _this = _super.call(this); // Override from BaseOverlay

      _this._overlayAnimationTime = 0; // Popper default

      _this._withinOffset = 5; // Events

      _this._delegateEvents({
        'global:key:escape': '_handleEscape',
        'click [coral-close]': '_handleCloseClick'
      });

      return _this;
    }
    /**
     The element the overlay should position relative to. It accepts values from {@link OverlayTargetEnum}, as
     well as a DOM element or a CSS selector. If a CSS selector is provided, the first matching element will be used.
      @type {?HTMLElement|String}
     @default null
     */


    _createClass(ExtensibleOverlay, [{
      key: "_toggleSmartBehavior",
      value: function _toggleSmartBehavior(toggle) {
        var _this2 = this;

        if (toggle) {
          if (this.smart) {
            this._validateParentOverflow();
          }

          this._togglePopperEventListener(true); // We need an additional frame to help popper read the correct offsets


          window.requestAnimationFrame(function () {
            _this2.reposition();
          });
        } else {
          this._togglePopperEventListener(false);
        }
      }
    }, {
      key: "_togglePopperEventListener",
      value: function _togglePopperEventListener(toggle) {
        if (this._popper) {
          this._popper[toggle ? 'enableEventListeners' : 'disableEventListeners']();
        }
      }
      /** @ignore */

    }, {
      key: "_validateParentOverflow",
      value: function _validateParentOverflow() {
        var reposition = false; // Check parents if they potentially truncate the overlay

        var parent = this.parentElement;

        while (!reposition && parent) {
          if (parent !== document.body) {
            var computedStyle = window.getComputedStyle(parent);

            if (computedStyle.overflow === 'auto' || computedStyle.overflow === 'hidden' || parent.clientHeight === 0 || parent.clientWidth === 0) {
              reposition = true;
            }

            parent = parent.parentElement;
          } else {
            parent = null;
          }
        } // If it's the case then we move the overlay to make sure it's not truncated


        if (reposition) {
          this._ignoreConnectedCallback = true;
          this._repositioned = true;
          document.body.appendChild(this);
          this._ignoreConnectedCallback = false;
        }
      }
      /** @ignore */

    }, {
      key: "_onUpdate",
      value: function _onUpdate(data) {
        var _this3 = this;

        // Trigger once positioned the first time
        if (!this._oldPosition) {
          this._oldPosition = data.styles.transform; // Do it in the next frame to avoid triggering the event too early

          window.requestAnimationFrame(function () {
            _this3.trigger('coral-overlay:positioned', data);
          });
        } // Trigger again only if position changed
        else {
            this._oldPosition = this._oldPosition || data.styles.transform;

            if (this._oldPosition !== data.styles.transform) {
              this.trigger('coral-overlay:positioned', data);
            }

            this._oldPosition = data.styles.transform;
          }
      }
      /**
       @todo maybe this should be base or something
       @ignore
       */

    }, {
      key: "_handleCloseClick",
      value: function _handleCloseClick(event) {
        var dismissTarget = event.matchedTarget;
        var dismissValue = dismissTarget.getAttribute('coral-close');

        if (!dismissValue || this.matches(dismissValue)) {
          this.hide();
          event.stopPropagation();

          this._trackEvent('close', this.tagName.toLowerCase(), event);
        }
      }
      /**
       Hides the overlay if it's on the top. When <code>interaction</code> is OFF it is ignored.
        @ignore
       */

    }, {
      key: "_handleEscape",
      value: function _handleEscape(event) {
        if (this.interaction === interaction$1.ON && this.open && this._isTopOverlay()) {
          event.stopPropagation();
          this.hide();
        }
      }
    }, {
      key: "_getTarget",
      value: function _getTarget(targetValue) {
        return this.constructor._getTarget(this, targetValue);
      }
    }, {
      key: "_initPopper",
      value: function _initPopper(forceReposition, targetElement) {
        targetElement = targetElement || this._getTarget();

        if (targetElement) {
          this._popper = this._popper || new Popper(targetElement, this, {
            onUpdate: this._onUpdate.bind(this)
          }); // Make sure popper options modifiers are up to date

          this.reposition(forceReposition);
        }
      }
      /**
       Re-position the overlay if it's currently open.
        @function
       @param {Boolean} forceReposition
       Whether to force repositioning even if closed.
       */

    }, {
      key: "reposition",
      value: function reposition(forceReposition) {
        var _this4 = this;

        if (this._popper) {
          var targetElement = this._getTarget(); // Update target only if valid


          if (targetElement) {
            this._popper.reference = targetElement;
          }

          this._popper.options.placement = this.placement;

          this._popper.modifiers.forEach(function (modifier) {
            if (modifier.name === 'offset') {
              modifier.offset = "".concat(_this4.breadthOffset, ", ").concat(_this4.lengthOffset);
            } else if (modifier.name === 'flip') {
              modifier.enabled = _this4.collision !== collision.FIT && _this4.collision !== collision.NONE;
            } else if (modifier.name === 'inner') {
              modifier.enabled = _this4.inner;
            } else if (modifier.name === 'preventOverflow') {
              modifier.enabled = _this4.collision !== collision.NONE;
              var within = _this4.within;
              var boundary; // Check for allowed PopperJS strings

              if (within instanceof HTMLElement || ['scrollParent', 'window', 'viewport'].indexOf(within) !== -1) {
                boundary = within;
              } else if (typeof within === 'string') {
                boundary = document.querySelector(within); // Fallback to default if element is not found in the document

                if (!(boundary instanceof HTMLElement)) {
                  boundary = 'scrollParent';
                }
              }

              modifier.boundariesElement = boundary;
              modifier.padding = _this4.withinOffset;
            }
          });

          if (this.open || forceReposition) {
            this._popper.update();
          }
        }
      }
      /**
       Get the element the overlay is anchored to.
        @param {HTMLElement} [el]
       The reference element.
       @param {HTMLElement|String} [target]
       A specific target value to use.
       If not provided, the current target of the element will be used.
       @returns {HTMLElement|null}
       */

    }, {
      key: "connectedCallback",

      /** @ignore */
      value: function connectedCallback() {
        var _this5 = this;

        _get(_getPrototypeOf(ExtensibleOverlay.prototype), "connectedCallback", this).call(this); // In case it was not added to the DOM, make sure popper is initialized by setting target


        this.target = this.target; // We need an additional frame to help popper read the correct offsets

        window.requestAnimationFrame(function () {
          // Force repositioning
          _this5.reposition(true);

          if (!_this5.open) {
            _this5._togglePopperEventListener(false);
          }
        });
      }
      /** @ignore */

    }, {
      key: "render",
      value: function render() {
        this.classList.add(CLASSNAME$i); // Hidden by default

        this.style.display = 'none';
      }
      /**
       Triggered after the {@link Overlay} is positioned.
        @typedef {CustomEvent} coral-overlay:positioned
       */

    }, {
      key: "target",
      get: function get() {
        return this._target || null;
      },
      set: function set(value) {
        // We don't want to validate that the value must change here
        // If a selector is provided, we'll take the first element matching that selector
        // If the DOM is modified and the user wants a new target with the same selector,
        // They should be able to set target = 'selector' again and get a different element
        if (value === null || typeof value === 'string' || value instanceof Node) {
          this._target = value;

          var targetElement = this._getTarget();

          if (targetElement) {
            // To make it return focus to the right item, change the target
            if (this._returnFocus === this.constructor.returnFocus.ON) {
              this.returnFocusTo(targetElement);
            } // update popper if popper already initialised or it is not explicitly avoid.


            if (this._popper || !this._avoidPopperInit) {
              this._initPopper(false, targetElement);
            }
          }
        }
      }
      /**
       The point on the overlay we should anchor from when positioning. See {@link OverlayAlignEnum}.
        @type {String}
       @default OverlayAlignEnum.CENTER_CENTER
       @htmlattribute alignmy
        @deprecated
       */

    }, {
      key: "alignMy",
      get: function get() {
        return this._alignMy || align.CENTER_CENTER;
      },
      set: function set(value) {
        commons._log('warn', DEPRECATED_ALIGN);

        value = transform.string(value).toLowerCase();
        this._alignMy = validate.enumeration(align)(value) && value || align.CENTER_CENTER;
      }
      /**
       The point on the target we should anchor to when positioning. See {@link OverlayAlignEnum}.
        @type {String}
       @default Coral.Overlay.align.CENTER_CENTER
       @htmlattribute alignat
        @deprecated
       */

    }, {
      key: "alignAt",
      get: function get() {
        return this._alignAt || align.CENTER_CENTER;
      },
      set: function set(value) {
        commons._log('warn', DEPRECATED_ALIGN);

        value = transform.string(value).toLowerCase();
        this._alignAt = validate.enumeration(align)(value) && value || align.CENTER_CENTER;
      }
      /**
       The distance the overlay should be from its target.
        @type {Number}
       @default 0
       @htmlattribute offset
       */

    }, {
      key: "offset",
      get: function get() {
        return transform.number(this.lengthOffset);
      },
      set: function set(value) {
        value = transform.number(value);

        if (typeof value === 'number') {
          this.lengthOffset = "".concat(value, "px");
          this.breadthOffset = '0px';
          this.reposition();
        }
      }
      /**
       Whether the overlay flows toward the inner of the target element. By default, it's placed outside the target element.
        @type {Boolean}
       @default false
       @htmlattribute inner
       */

    }, {
      key: "inner",
      get: function get() {
        return this._inner || false;
      },
      set: function set(value) {
        this._inner = transform.booleanAttr(value);
        this.reposition();
      }
      /**
       The distance the overlay should be from its target along the length axis.
        @type {String}
       @default '0px'
       @htmlattribute lengthoffset
       */

    }, {
      key: "lengthOffset",
      get: function get() {
        return this._lengthOffset || '0px';
      },
      set: function set(value) {
        this._lengthOffset = transform.string(value) || '0px';
        this.reposition();
      }
      /**
       The distance the overlay should be from its target along the breadth axis.
        @type {String}
       @default '0px'
       @htmlattribute breadthoffset
       */

    }, {
      key: "breadthOffset",
      get: function get() {
        return this._breadthOffset || '0px';
      },
      set: function set(value) {
        this._breadthOffset = transform.string(value) || '0px';
        this.reposition();
      }
      /**
       The placement of the overlay. See {@link OverlayPlacementEnum}.
        @type {String}
       @default OverlayPlacementEnum.RIGHT
       @htmlattribute placement
       */

    }, {
      key: "placement",
      get: function get() {
        return this._placement || placement.RIGHT;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        this._placement = validate.enumeration(placement)(value) && value || placement.RIGHT;
        this.reposition();
      }
      /**
       The bounding element for the overlay. The overlay will be sized and positioned such that it is contained within
       this element. It accepts both a DOM Element or a CSS selector. If a CSS selector is provided, the first matching
       element will be used.
        @type {HTMLElement|String}
       @default 'scrollParent'
       */

    }, {
      key: "within",
      get: function get() {
        return this._within || 'scrollParent';
      },
      set: function set(value) {
        if (value instanceof HTMLElement || typeof value === 'string') {
          this._within = value;
          this.reposition();
        }
      }
      /**
       Amount of pixel used to define a minimum distance between the boundaries and the overlay.
       This makes sure the overlay always has a little padding between the edges of its container.
        @type {Number}
       @default 5
       @htmlattribute withinOffset
       */

    }, {
      key: "withinOffset",
      get: function get() {
        return this._withinOffset;
      },
      set: function set(value) {
        value = transform.number(value);

        if (typeof value === 'number') {
          this._withinOffset = value;
          this.reposition();
        }
      }
      /**
       The collision handling strategy when positioning the overlay relative to a target. See {@link OverlayCollisionEnum}.
        @type {String}
       @default OverlayCollisionEnum.FLIP
       @htmlattribute collision
       */

    }, {
      key: "collision",
      get: function get() {
        return this._collision || collision.FLIP;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        this._collision = validate.enumeration(collision)(value) && value || collision.FLIP;

        if (this._collision === collision.FLIP_FIT) {
          commons._log('warn', DEPRECATED_FLIP_FIT);
        }

        this.reposition();
      }
      /**
       Whether keyboard interaction is enabled. See {@link OverlayInteractionEnum}.
        @type {String}
       @default OverlayInteractionEnum.ON
       */

    }, {
      key: "interaction",
      get: function get() {
        return this._interaction || interaction$1.ON;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        this._interaction = validate.enumeration(interaction$1)(value) && value || interaction$1.ON;
      }
      /**
       Whether the overlay is allowed to change its DOM position for better positioning based on its context.
        @type {Boolean}
       @default false
       */

    }, {
      key: "smart",
      get: function get() {
        return this._smart || false;
      },
      set: function set(value) {
        this._smart = transform.booleanAttr(value);

        this._toggleSmartBehavior(this.open);
      }
      /**
       Inherited from {@link BaseOverlay#open}.
       */

    }, {
      key: "open",
      get: function get() {
        return _get(_getPrototypeOf(ExtensibleOverlay.prototype), "open", this);
      },
      set: function set(value) {
        // initialise popper if undefined, used when popper initialisation avoided while setting target.
        if (!this._popper) {
          this._initPopper(true);
        }

        _set(_getPrototypeOf(ExtensibleOverlay.prototype), "open", value, this, true);

        this._toggleSmartBehavior(this.open);
      }
    }], [{
      key: "_getTarget",
      value: function _getTarget(el, targetValue) {
        // Use passed target
        targetValue = targetValue || el.target;

        if (targetValue instanceof Node) {
          // Just return the provided Node
          return targetValue;
        } // Dynamically get the target node based on target


        var newTarget = null;

        if (typeof targetValue === 'string') {
          if (targetValue === target.PREVIOUS) {
            newTarget = el.previousElementSibling;
          } else if (targetValue === target.NEXT) {
            newTarget = el.nextElementSibling;
          } else {
            newTarget = document.querySelector(targetValue);
          }
        }

        return newTarget;
      }
      /**
       @deprecated
        Returns {@link Overlay} align options.
        @return {OverlayAlignEnum}
       */

    }, {
      key: "align",
      get: function get() {
        return align;
      }
      /**
       Returns {@link Overlay} collision options.
        @return {OverlayCollisionEnum}
       */

    }, {
      key: "collision",
      get: function get() {
        return collision;
      }
      /**
       Returns {@link Overlay} target options.
        @return {OverlayTargetEnum}
       */

    }, {
      key: "target",
      get: function get() {
        return target;
      }
      /**
       Returns {@link Overlay} placement options.
        @return {OverlayPlacementEnum}
       */

    }, {
      key: "placement",
      get: function get() {
        return placement;
      }
      /**
       Returns {@link Overlay} interaction options.
        @return {OverlayInteractionEnum}
       */

    }, {
      key: "interaction",
      get: function get() {
        return interaction$1;
      }
    }, {
      key: "_attributePropertyMap",
      get: function get() {
        return commons.extend(_get(_getPrototypeOf(ExtensibleOverlay), "_attributePropertyMap", this), {
          alignmy: 'alignMy',
          alignat: 'alignAt',
          lengthoffset: 'lengthOffset',
          breadthoffset: 'breadthOffset',
          withinoffset: 'withinOffset'
        });
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(ExtensibleOverlay), "observedAttributes", this).concat(['alignmy', 'alignat', 'offset', 'lengthoffset', 'breadthoffset', 'placement', 'within', 'withinoffset', 'collision', 'interaction', 'target', 'inner', 'smart']);
      }
    }]);

    return ExtensibleOverlay;
  }(BaseOverlay(BaseComponent(HTMLElement)));

  var Overlay = Decorator(ExtensibleOverlay);

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons._define('coral-overlay', Overlay);

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var translations$5 = {
    "en-US": {
      "Close": "Close"
    },
    "de-DE": {
      "Close": "Schließen"
    },
    "fr-FR": {
      "Close": "Fermer"
    },
    "it-IT": {
      "Close": "Chiudi"
    },
    "ja-JP": {
      "Close": "閉じる"
    },
    "es-ES": {
      "Close": "Cerrar"
    },
    "ko-KR": {
      "Close": "닫기"
    },
    "zh-CN": {
      "Close": "关闭"
    },
    "zh-TW": {
      "Close": "關閉"
    },
    "pt-BR": {
      "Close": "Fechar"
    },
    "nl-NL": {
      "Close": "Sluiten"
    },
    "da-DK": {
      "Close": "Luk"
    },
    "fi-FI": {
      "Close": "Sulje"
    },
    "nb-NO": {
      "Close": "Lukk"
    },
    "sv-SE": {
      "Close": "Stäng"
    },
    "cs-CZ": {
      "Close": "Zavřít"
    },
    "pl-PL": {
      "Close": "Zamknij"
    },
    "ru-RU": {
      "Close": "Закрыть"
    },
    "tr-TR": {
      "Close": "Kapat"
    }
  };

  var DROP_ZONE_ATTRIBUTE = 'coral-dragaction-dropzone';
  var HANDLE_ATTRIBUTE = 'coral-dragaction-handle';
  var AXIS_ATTRIBUTE = 'coral-dragaction-axis';
  var SCROLL_ATTRIBUTE = 'coral-dragaction-scroll';
  var CONTAINMENT_ATTRIBUTE = 'coral-dragaction-containment'; // Classes

  var OPEN_HAND_CLASS = 'u-coral-openHand';
  var CLOSE_HAND_CLASS = 'u-coral-closedHand';
  var IS_DRAGGING_CLASS = 'is-dragging'; // Scroll offset default values

  var DEFAULT_SCROLL_OFFSET = 20;
  var DEFAULT_SCROLL_BY = 10;
  /**
   Enumeration for {@link DragAction} axis restrictions.

   @typedef {Object} DragActionAxisEnum

   @property {String} FREE
   Allows vertically and horizontally dragging.
   @property {String} VERTICAL
   Allows vertically dragging only.
   @property {String} HORIZONTAL
   Allows horizontally dragging only.
   */

  var axis = {
    FREE: 'free',
    VERTICAL: 'vertical',
    HORIZONTAL: 'horizontal'
  };
  /**
   @ignore
   @param {HTMLElement} element
   @returns {HTMLElement}
   First parent element with overflow [hidden|scroll|auto]
   */

  function getViewContainer(element) {
    while (element) {
      var p = element.parentNode;

      if (!p) {
        return p;
      }

      if (p.matches('body')) {
        return p;
      }

      var computedStyle = window.getComputedStyle(p);
      var overflow = computedStyle.overflow; // IE11 can return a value for overflow even if it was not set compared to other browsers so we check for X and Y.

      var overflowX = computedStyle.overflowX;
      var overflowY = computedStyle.overflowY;

      if ((overflow === 'hidden' || overflow === 'auto' || overflow === 'scroll') && // @polyfill IE11
      overflow === overflowX && overflow === overflowY) {
        return p;
      }

      element = p;
    }
  }
  /**
   @ignore
   @param {String|HTMLElement|NodeList} el
   @returns {Array.<HTMLElement>}
   X and y position whether event was generated by a click or a touch
   */


  function transformToArray(el) {
    if (typeof el === 'string') {
      return Array.prototype.slice.call(document.querySelectorAll(el));
    } else if (el instanceof HTMLElement) {
      return [el];
    } else if (Object.prototype.toString.call(el) === '[object NodeList]') {
      return Array.prototype.slice.call(el);
    }
  }
  /**
   @ignore
   @param {Object} event
   @returns {Object}
   X and y position whether event was generated by a click or a touch
   */


  function getPagePosition(event) {
    var touch = {};

    if (event.changedTouches && event.changedTouches.length > 0) {
      touch = event.changedTouches[0];
    } else if (event.touches && event.touches.length > 0) {
      touch = event.touches[0];
    }

    return {
      x: touch.pageX || event.pageX,
      y: touch.pageY || event.pageY
    };
  }
  /**
   @ignore
   @param {HTMLElement} scrollingElement
   element that scrolls the document
   @param {HTMLElement} a
   @param {HTMLElement} b
   @returns {Boolean}
   Whether a is within b bounds
   */


  function within(scrollingElement, a, b) {
    var aBoundingClientRect = a.getBoundingClientRect();
    var bBoundingClientRect = b.getBoundingClientRect();
    var documentScrollTop = scrollingElement.scrollTop;
    var documentScrollLeft = scrollingElement.scrollLeft;
    var al = aBoundingClientRect.left + documentScrollLeft;
    var ar = al + aBoundingClientRect.width;
    var bl = bBoundingClientRect.left + documentScrollLeft;
    var br = bl + bBoundingClientRect.width;
    var at = aBoundingClientRect.top + documentScrollTop;
    var ab = at + aBoundingClientRect.height;
    var bt = bBoundingClientRect.top + documentScrollTop;
    var bb = bt + bBoundingClientRect.height;
    return !(bl > ar || br < al || bt > ab || bb < at);
  }
  /**
   @ignore
   @param {DragAction} dragAction
   Coral.DragAction instance
   @returns {HTMLElement}
   The dropzone that is being hovered by the dragged element or null if none
   */


  function isOverDropZone(dragAction) {
    var el = null;

    if (dragAction._dropZones && dragAction._dropZones.length) {
      dragAction._dropZones.some(function (dropZone) {
        if (within(dragAction._scrollingElement, dragAction._dragElement, dropZone)) {
          el = dropZone;
          return true;
        }

        return false;
      });
    }

    return el;
  }
  /**
   @class Coral.DragAction
   @classdesc This a decorator which adds draggable functionality to elements.
   To define draggable actions on specific elements, handles can be used.
   A handle is given a special attribute :
   - <code>coral-dragaction</code> attribute adds draggable functionality to the corresponding element.
   - <code>coral-dragaction-handle</code> attribute allows dragging only by dragging the specified handle.
   - <code>coral-dragaction-dropzone</code> attribute is used to indicate possible dropzones making it possible
   to build drag-and-drop enabled interfaces in conjunction with <code>DragAction</code> events.
   - <code>coral-dragaction-axis</code> and setting it to either <code>horizontal</code> or <code>vertical</code>,
   it is possible to restrict the drag'n'drop to a single axis.
   - <code>coral-dragaction-scroll</code> attribute will scroll the container when the draggable is moved beyond the viewport.
   - <code>coral-dragaction-containment</code>, the draggable element will be constrained to its container.
   @param {String|HTMLElement} dragElement
   The draggable element.
   */


  var DragAction = /*#__PURE__*/function () {
    /**
     Takes the {HTMLElement} to be dragged as argument.
      @param {HTMLElement} dragElement
     */
    function DragAction(dragElement) {
      _classCallCheck(this, DragAction);

      if (!dragElement) {
        throw new Error('Coral.DragAction: dragElement is missing');
      }

      var el = null;

      if (dragElement instanceof HTMLElement) {
        el = dragElement;
      } else if (typeof dragElement === 'string') {
        el = document.querySelector(dragElement);

        if (!el) {
          throw new Error('Coral.DragAction: dragElement is null');
        }
      }

      this._id = commons.getUID();
      this._dragElementValue = dragElement;
      this._dragElement = el; // Destroy instance if existing

      if (this._dragElement.dragAction) {
        this._dragElement.dragAction.destroy();
      }

      var computedStyle = window.getComputedStyle(this._dragElement); // Store initial position

      this._initialPosition = {
        position: computedStyle.position,
        left: computedStyle.left,
        top: computedStyle.top
      }; // Prepare Vent

      this._dragEvents = new vent(this._dragElement); // Handle options. Binds events to dragElement if no handles defined or found

      this.handle = this._dragElement.getAttribute(HANDLE_ATTRIBUTE); // DropZone options

      this.dropZone = this._dragElement.getAttribute(DROP_ZONE_ATTRIBUTE); // Axis horizontal|vertical

      this.axis = this._dragElement.getAttribute(AXIS_ATTRIBUTE); // Scroll options

      this.scroll = this._dragElement.matches("[".concat(SCROLL_ATTRIBUTE, "]")); // Restriction to container

      this.containment = this._dragElement.matches("[".concat(CONTAINMENT_ATTRIBUTE, "]"));
      this._drag = this._drag.bind(this);
      this._dragEnd = this._dragEnd.bind(this);
      events.on("touchmove.DragAction".concat(this._id), this._drag);
      events.on("mousemove.DragAction".concat(this._id), this._drag);
      events.on("touchend.DragAction".concat(this._id), this._dragEnd);
      events.on("mouseup.DragAction".concat(this._id), this._dragEnd); // Store reference on dragElement

      this._dragElement.dragAction = this;
    }
    /**
     The draggable element.
      @name dragElement
     @readonly
     @type {String|HTMLElement}
     @htmlattribute coral-dragaction
     */


    _createClass(DragAction, [{
      key: "_dragStart",

      /** @private */
      value: function _dragStart(event) {
        // Container
        this._container = getViewContainer(this._dragElement) || document.body; // Prevent dragging ghost image

        if (event.target.tagName === 'IMG') {
          event.preventDefault();
        } // Prevent touchscreen windows to scroll while dragging


        events.on('touchmove.DragAction', function (e) {
          e.preventDefault();
        });
        document.body._overflow = window.getComputedStyle(document.body).overflow;
        document.body.style.overflow = 'hidden';

        if (!this._container.matches('body')) {
          this._container._overflow = window.getComputedStyle(this._container).overflow;
          this._container.style.overflow = this.scroll ? 'scroll' : 'hidden';
        }

        var pagePosition = getPagePosition(event);

        var dragElementBoundingClientRect = this._dragElement.getBoundingClientRect();

        this._dragPosition = getPagePosition(event);
        this._dragPosition.y -= dragElementBoundingClientRect.top + this._scrollingElement.scrollTop;
        this._dragPosition.x -= dragElementBoundingClientRect.left + this._scrollingElement.scrollLeft; // Handle classes

        document.body.classList.add(CLOSE_HAND_CLASS);

        if (this._handles && this._handles.length) {
          this._handles.forEach(function (handle) {
            handle.classList.remove(OPEN_HAND_CLASS);
          });
        } else {
          this._dragElement.classList.remove(OPEN_HAND_CLASS);
        }

        this._dragElement.classList.add(IS_DRAGGING_CLASS); // Apply relative position by default


        if (window.getComputedStyle(this._dragElement).position === 'static') {
          this._dragElement.style.position = 'relative';
        }

        this._dragEvents.dispatch('coral-dragaction:dragstart', {
          detail: {
            dragElement: this._dragElement,
            pageX: pagePosition.x,
            pageY: pagePosition.y
          }
        });
      }
      /** @private */

    }, {
      key: "_drag",
      value: function _drag(event) {
        if (this._dragElement.classList.contains(IS_DRAGGING_CLASS)) {
          var pagePosition = getPagePosition(event);
          var documentScrollTop = this._scrollingElement.scrollTop;
          var documentScrollLeft = this._scrollingElement.scrollLeft;

          var dragElementBoundingClientRect = this._dragElement.getBoundingClientRect();

          var dragElementHeight = dragElementBoundingClientRect.height;
          var dragElementWidth = dragElementBoundingClientRect.width;
          var dragElementPosition = {
            top: dragElementBoundingClientRect.top + documentScrollTop,
            left: dragElementBoundingClientRect.left + documentScrollLeft
          };
          var dragElementComputedStyle = window.getComputedStyle(this._dragElement);
          var dragElementCSSPosition = {
            top: parseFloat(dragElementComputedStyle.top) || 0,
            left: parseFloat(dragElementComputedStyle.left) || 0
          };

          var containerBoundingClientRect = this._container.getBoundingClientRect();

          var containerWidth = containerBoundingClientRect.width;
          var containerHeight = containerBoundingClientRect.height;
          var containerPosition = {
            top: containerBoundingClientRect.top + documentScrollTop,
            left: containerBoundingClientRect.left + documentScrollLeft
          };

          this._dragEvents.dispatch('coral-dragaction:drag', {
            detail: {
              dragElement: this._dragElement,
              pageX: pagePosition.x,
              pageY: pagePosition.y
            }
          }); // Remove selection


          if (document.selection) {
            document.selection.empty();
          } else if (window.getSelection) {
            // @polyfill ie
            if (window.getSelection().removeAllRanges) {
              window.getSelection().removeAllRanges();
            }
          } // Need to scroll ?


          if (this.scroll) {
            // Scroll element is the document
            if (this._container === document.body) {
              // Scroll to the top
              if (dragElementBoundingClientRect.top < DEFAULT_SCROLL_OFFSET) {
                this._scrollingElement.scrollTop = documentScrollTop - DEFAULT_SCROLL_BY;
              } // Scroll to the bottom but don't go further than the maximum scroll position of the document
              else if (dragElementBoundingClientRect.top + dragElementBoundingClientRect.height > window.innerHeight - DEFAULT_SCROLL_OFFSET && dragElementPosition.top + dragElementBoundingClientRect.height + DEFAULT_SCROLL_OFFSET < this._scrollingElement.scrollHeight) {
                  this._scrollingElement.scrollTop = documentScrollTop + DEFAULT_SCROLL_BY;
                } // Scroll to the left


              if (dragElementBoundingClientRect.left < DEFAULT_SCROLL_OFFSET) {
                this._scrollingElement.scrollLeft = documentScrollLeft - DEFAULT_SCROLL_BY;
              } // Scroll to the right but don't go further than the maximum scroll position of the document
              else if (dragElementBoundingClientRect.left + dragElementBoundingClientRect.width > window.innerWidth - DEFAULT_SCROLL_OFFSET && dragElementPosition.left + dragElementBoundingClientRect.width + DEFAULT_SCROLL_OFFSET < this._scrollingElement.scrollWidth) {
                  this._scrollingElement.scrollLeft = documentScrollLeft + DEFAULT_SCROLL_BY;
                }
            } // Scroll element is an element other than the document
            else {
                // Scroll to the top
                if (dragElementBoundingClientRect.top - containerBoundingClientRect.top < DEFAULT_SCROLL_OFFSET) {
                  this._container.scrollTop = this._container.scrollTop - DEFAULT_SCROLL_BY;
                } // Scroll to the bottom but don't go further than the maximum scroll position of the container
                else if (dragElementBoundingClientRect.top - containerBoundingClientRect.top + dragElementBoundingClientRect.height > containerBoundingClientRect.height - DEFAULT_SCROLL_OFFSET && dragElementBoundingClientRect.top - containerBoundingClientRect.top + dragElementBoundingClientRect.height < containerBoundingClientRect.height) {
                    this._container.scrollTop = this._container.scrollTop + DEFAULT_SCROLL_BY;
                  } // Scroll to the left


                if (dragElementBoundingClientRect.left - containerBoundingClientRect.left < DEFAULT_SCROLL_OFFSET) {
                  this._container.scrollLeft = this._container.scrollLeft - DEFAULT_SCROLL_BY;
                } // Scroll to the bottom but don't go further than the maximum scroll position of the container
                else if (dragElementBoundingClientRect.left - containerBoundingClientRect.left + dragElementBoundingClientRect.width > containerBoundingClientRect.width - DEFAULT_SCROLL_OFFSET && dragElementBoundingClientRect.left - containerBoundingClientRect.left + dragElementBoundingClientRect.width < containerBoundingClientRect.width) {
                    this._container.scrollLeft = this._container.scrollLeft + DEFAULT_SCROLL_BY;
                  }
              }
          } // Set drag element's new position


          var newPosition = {};

          if (this.axis !== 'horizontal') {
            var top = pagePosition.y - this._dragPosition.y; // Applying container containment for y movements

            if (this.containment) {
              if (top >= containerPosition.top && top + dragElementHeight <= containerPosition.top + containerHeight) {
                newPosition.top = top;
              } // put the drag element to the container's top
              else if (pagePosition.y <= containerPosition.top) {
                  newPosition.top = containerPosition.top;
                } // put the drag element to the container's bottom
                else if (pagePosition.y >= containerPosition.top + containerHeight) {
                    newPosition.top = containerPosition.top + containerHeight - dragElementHeight;
                  }
            } else {
              newPosition.top = top;
            }
          }

          if (this.axis !== 'vertical') {
            var left = pagePosition.x - this._dragPosition.x; // Applying container containment for x movements

            if (this.containment) {
              if (left >= containerPosition.left && left + dragElementWidth <= containerPosition.left + containerWidth) {
                newPosition.left = left;
              } // put the drag element to the container's left
              else if (pagePosition.x <= containerPosition.left) {
                  newPosition.left = containerPosition.left;
                } // put the drag element to the container's right
                else if (pagePosition.x >= containerPosition.left + containerWidth) {
                    newPosition.left = containerPosition.left + containerWidth - dragElementWidth;
                  }
            } else {
              newPosition.left = left;
            }
          } // Set the new position


          this._dragElement.style.top = "".concat(newPosition.top - dragElementPosition.top + dragElementCSSPosition.top, "px");
          this._dragElement.style.left = "".concat(newPosition.left - dragElementPosition.left + dragElementCSSPosition.left, "px"); // Trigger dropzone related events

          var dropZone = isOverDropZone(this);

          if (dropZone) {
            this._dropElement = dropZone;

            if (!this._dropZoneEntered) {
              this._dropZoneEntered = true;

              this._dragEvents.dispatch('coral-dragaction:dragenter', {
                detail: {
                  dragElement: this._dragElement,
                  pageX: pagePosition.x,
                  pageY: pagePosition.y,
                  dropElement: this._dropElement
                }
              });
            }

            this._dragEvents.dispatch('coral-dragaction:dragover', {
              detail: {
                dragElement: this._dragElement,
                pageX: pagePosition.x,
                pageY: pagePosition.y,
                dropElement: this._dropElement
              }
            });
          } else if (this._dropZoneEntered) {
            this._dragEvents.dispatch('coral-dragaction:dragleave', {
              detail: {
                dragElement: this._dragElement,
                pageX: pagePosition.x,
                pageY: pagePosition.y,
                dropElement: this._dropElement
              }
            });

            this._dropZoneEntered = false;
          }
        }
      }
      /** @private */

    }, {
      key: "_dragEnd",
      value: function _dragEnd(event) {
        if (this._dragElement.classList.contains(IS_DRAGGING_CLASS)) {
          var pagePosition = getPagePosition(event); // Restore overflow

          document.body.style.overflow = document.body._overflow;
          document.body._overflow = undefined;

          if (!this._container.matches('body')) {
            this._container.style.overflow = this._container._overflow;
            this._container._overflow = undefined;
          }

          document.body.classList.remove(CLOSE_HAND_CLASS);

          this._dragElement.classList.remove(IS_DRAGGING_CLASS);

          if (this._handles && this._handles.length) {
            this._handles.forEach(function (handle) {
              handle.classList.add(OPEN_HAND_CLASS);
            });
          } else {
            this._dragElement.classList.add(OPEN_HAND_CLASS);
          }

          if (this._dropZoneEntered) {
            var dropZone = isOverDropZone(this);

            if (dropZone) {
              this._dropElement = dropZone;

              this._dragEvents.dispatch('coral-dragaction:drop', {
                detail: {
                  dragElement: this._dragElement,
                  pageX: pagePosition.x,
                  pageY: pagePosition.y,
                  dropElement: this._dropElement
                }
              });
            }
          }

          this._dragEvents.dispatch('coral-dragaction:dragend', {
            detail: {
              dragElement: this._dragElement,
              pageX: pagePosition.x,
              pageY: pagePosition.y
            }
          });
        }
      }
      /**
       Remove draggable actions
        @function destroy
       @param {Boolean} restorePosition
       Whether to restore the draggable element to its initial position
       */

    }, {
      key: "destroy",
      value: function destroy(restorePosition) {
        // Unbind events and remove classes
        document.body.classList.remove(CLOSE_HAND_CLASS);

        this._dragElement.classList.remove(IS_DRAGGING_CLASS);

        if (this._handles && this._handles.length) {
          this._handles.forEach(function (handle) {
            handle._dragEvents.off('.DragAction');

            handle.classList.remove(OPEN_HAND_CLASS);
          });
        } else {
          this._dragEvents.off('.DragAction');

          this._dragElement.classList.remove(OPEN_HAND_CLASS);
        }

        events.off(".DragAction".concat(this._id)); // Restore overflow

        if (document.body._overflow) {
          document.body.style.overflow = document.body._overflow;
          document.body._overflow = undefined;
        } // Container might not have been initialized


        if (this._container) {
          if (!this._container.matches('body') && this._container._overflow) {
            this._container.style.overflow = this._container._overflow;
            this._container._overflow = undefined;
          }
        } // Set to initial position


        if (restorePosition) {
          this._dragElement.style.position = this._initialPosition.position;
          this._dragElement.style.top = this._initialPosition.top;
          this._dragElement.style.left = this._initialPosition.left;
        } // Remove reference


        this._dragElement.dragAction = undefined;
      }
      /**
       Returns {@link DragAction} axis restrictions.
        @return {DragActionAxisEnum}
       */

    }, {
      key: "dragElement",
      get: function get() {
        return this._dragElementValue;
      }
      /**
       The handle allowing to drag the element.
        @name handle
       @type {String|HTMLElement}
       @htmlattribute coral-dragaction-handle
       */

    }, {
      key: "handle",
      get: function get() {
        return this._handle;
      },
      set: function set(value) {
        var _this = this;

        // Set new value
        this._handle = value; // Unbind events

        this._dragEvents.off('.DragAction'); // Remove classes


        document.body.classList.remove(CLOSE_HAND_CLASS);

        this._dragElement.classList.remove(IS_DRAGGING_CLASS);

        if (this._handles && this._handles.length) {
          this._handles.forEach(function (handle) {
            handle._dragEvents.off('.DragAction');

            handle.classList.remove(OPEN_HAND_CLASS);
          });
        } else {
          this._dragElement.classList.remove(OPEN_HAND_CLASS);
        }

        if (typeof value === 'string' || value instanceof HTMLElement || Object.prototype.toString.call(value) === '[object NodeList]') {
          this._handles = transformToArray(value); // Bind events

          if (this._handles && this._handles.length) {
            this._handles.forEach(function (handle) {
              handle._dragEvents = handle._dragEvents || new vent(handle);

              handle._dragEvents.on('mousedown.DragAction', _this._dragStart.bind(_this));

              handle._dragEvents.on('touchstart.DragAction', _this._dragStart.bind(_this));

              handle.classList.add(OPEN_HAND_CLASS);
            });
          } else {
            this._dragEvents.on('touchstart.DragAction', this._dragStart.bind(this));

            this._dragEvents.on('mousedown.DragAction', this._dragStart.bind(this));

            this._dragElement.classList.add(OPEN_HAND_CLASS);
          }
        } else {
          // Defaults to the dragElement
          this._handles = [];

          this._dragEvents.on('touchstart.DragAction', this._dragStart.bind(this));

          this._dragEvents.on('mousedown.DragAction', this._dragStart.bind(this));

          this._dragElement.classList.add(OPEN_HAND_CLASS);
        }
      }
      /**
       The dropZone to drop the dragged element.
        @name dropZone
       @type {String|HTMLElement}
       @htmlattribute coral-dragaction-dropzone
       */

    }, {
      key: "dropZone",
      get: function get() {
        return this._dropZone;
      },
      set: function set(value) {
        // Set new value
        this._dropZone = value;
        this._dropZoneEntered = false;

        if (typeof value === 'string' || value instanceof HTMLElement || Object.prototype.toString.call(value) === '[object NodeList]') {
          this._dropZones = transformToArray(value);
        } else {
          this._dropZones = [];
        }
      }
      /**
       The axis to constrain drag movement. See {@link DragActionAxisEnum}.
        @name axis
       @type {String}
       @default DragActionAxisEnum.FREE
       @htmlattribute coral-dragaction-axis
       */

    }, {
      key: "axis",
      get: function get() {
        return this._axis;
      },
      set: function set(value) {
        value = transform.string(value);
        this._axis = validate.enumeration(axis)(value) && value || axis.FREE;
      }
      /**
       Whether to scroll the container when the draggable element is moved beyond the viewport.
        @name scroll
       @default false
       @type {Boolean}
       @htmlattribute coral-dragaction-scroll
       */

    }, {
      key: "scroll",
      get: function get() {
        return this._scroll;
      },
      set: function set(value) {
        this._scroll = transform.boolean(value);
      }
      /**
       Whether to constrain the draggable element to its container viewport.
        @name containment
       @default false
       @type {Boolean}
       @htmlattribute coral-dragaction-containment
       */

    }, {
      key: "containment",
      get: function get() {
        return this._containment;
      },
      set: function set(value) {
        this._containment = transform.boolean(value);
      }
    }, {
      key: "_scrollingElement",

      /** @private */
      get: function get() {
        // @polyfill ie11
        // Element that scrolls the document.
        return document.scrollingElement || document.documentElement;
      }
      /**
       Triggered when the {@link DragAction#dragElement} starts to be dragged.
        @typedef {CustomEvent} coral-dragaction:dragstart
        @property {HTMLElement} dragElement
       The dragged element
       @property {Number} pageX
       The mouse position relative to the left edge of the document.
       @property {Number} pageY
       The mouse position relative to the top edge of the document.
       */

      /**
       Triggered when the {@link DragAction#dragElement} is being dragged.
        @typedef {CustomEvent} coral-dragaction:drag
        @property {HTMLElement} dragElement
       The dragged element
       @property {Number} pageX
       The mouse position relative to the left edge of the document.
       @property {Number} pageY
       The mouse position relative to the top edge of the document.
       */

      /**
       Triggered when the {@link DragAction#dragElement} stops to be dragged.
        @typedef {CustomEvent} coral-dragaction:dragend
        @property {HTMLElement} dragElement
       The dragged element
       @property {Number} pageX
       The mouse position relative to the left edge of the document.
       @property {Number} pageY
       The mouse position relative to the top edge of the document.
       */

      /**
       Triggered when the {@link DragAction#dragElement} enters a drop element.
        @typedef {CustomEvent} coral-dragaction:dragenter
        @property {HTMLElement} dragElement
       The dragged element
       @property {HTMLElement} dropElement
       The drop element
       @property {Number} pageX
       The mouse position relative to the left edge of the document.
       @property {Number} pageY
       The mouse position relative to the top edge of the document.
       */

      /**
       Triggered when the {@link DragAction#dragElement} is over a drop element.
        @typedef {CustomEvent} coral-dragaction:dragover
        @property {HTMLElement} dragElement
       The dragged element
       @property {HTMLElement} dropElement
       The drop element
       @property {Number} pageX
       The mouse position relative to the left edge of the document.
       @property {Number} pageY
       The mouse position relative to the top edge of the document.
       */

      /**
       Triggered when the {@link DragAction#dragElement} leaves a drop element.
        @typedef {CustomEvent} coral-dragaction:dragleave
        @property {HTMLElement} dragElement
       The dragged element
       @property {HTMLElement} dropElement
       The drop element
       @property {Number} pageX
       The mouse position relative to the left edge of the document.
       @property {Number} pageY
       The mouse position relative to the top edge of the document.
       */

      /**
       Triggered when the {@link DragAction#dragElement} is dropped on a drop element.
        @typedef {CustomEvent} coral-dragaction:drop
        @property {HTMLElement} dragElement
       The dragged element
       @property {HTMLElement} dropElement
       The drop element
       @property {Number} pageX
       The mouse position relative to the left edge of the document.
       @property {Number} pageY
       The mouse position relative to the top edge of the document.
       */

    }], [{
      key: "axis",
      get: function get() {
        return axis;
      }
    }]);

    return DragAction;
  }();

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  document.addEventListener('DOMContentLoaded', function () {
    var elements = document.body.querySelectorAll('[coral-dragaction]');

    for (var i = 0; i < elements.length; i++) {
      new DragAction(elements[i]);
    }
  });

  var template$5 = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["headerWrapper"] = document.createElement("div");
    el0.className += " _coral-Dialog-header";
    el0.setAttribute("handle", "headerWrapper");
    var el1 = document.createTextNode("\n  ");
    el0.appendChild(el1);
    var el2 = this["dragZone"] = document.createElement("div");
    el2.className += " _coral-Dialog-dragZone";
    el2.setAttribute("handle", "dragZone");
    el0.appendChild(el2);
    var el3 = document.createTextNode("\n");
    el0.appendChild(el3);
    frag.appendChild(el0);
    var el4 = document.createTextNode("\n");
    frag.appendChild(el4);
    var el5 = this["wrapper"] = document.createElement("div");
    el5.setAttribute("handle", "wrapper");
    var el6 = document.createTextNode("\n  ");
    el5.appendChild(el6);
    var el7 = this["closeButton"] = document.createElement("button", "coral-button");
    el7.setAttribute("tracking", "off");
    el7.setAttribute("handle", "closeButton");
    el7.className += " _coral-Dialog-closeButton";
    el7.setAttribute("type", "button");
    el7.setAttribute("is", "coral-button");
    el7.setAttribute("variant", "quietaction");
    el7.setAttribute("title", data_0["i18n"]["get"]('Close'));
    el7.setAttribute("tabindex", "-1");
    el7.setAttribute("coral-close", "");
    el7.setAttribute("coral-tabcapture", "");
    var el8 = document.createTextNode("\n    ");
    el7.appendChild(el8);
    var el9 = document.createElement("coral-icon");
    el9.setAttribute("icon", "spectrum-css-icon-CrossLarge");
    el9.className += " _coral-UIIcon-CrossLarge";
    el7.appendChild(el9);
    var el10 = document.createTextNode("\n  ");
    el7.appendChild(el10);
    el5.appendChild(el7);
    var el11 = document.createTextNode("\n");
    el5.appendChild(el11);
    frag.appendChild(el5);
    var el12 = document.createTextNode("\n");
    frag.appendChild(el12);
    return frag;
  };

  /**
   Enumeration for {@link Dialog} closable options.

   @typedef {Object} DialogClosableEnum

   @property {String} ON
   Show a close button on the dialog and close the dialog when clicked.
   @property {String} OFF
   Do not show a close button. Elements with the <code>coral-close</code> attribute will still close the dialog.
   */

  var closable = {
    ON: 'on',
    OFF: 'off'
  };
  /**
   Enumeration for {@link Dialog} keyboard interaction options.

   @typedef {Object} DialogInteractionEnum

   @property {String} ON
   Keyboard interaction is enabled.
   @property {String} OFF
   Keyboard interaction is disabled.
   */

  var interaction$2 = {
    ON: 'on',
    OFF: 'off'
  };
  /**
   Enumeration for {@link Dialog} variants.

   @typedef {Object} DialogVariantEnum

   @property {String} DEFAULT
   A default dialog without header icon.
   @property {String} ERROR
   A dialog with an error header and icon, indicating that an error has occurred.
   @property {String} WARNING
   A dialog with a warning header and icon, notifying the user of something important.
   @property {String} SUCCESS
   A dialog with a success header and icon, indicates to the user that an operation was successful.
   @property {String} HELP
   A dialog with a question header and icon, provides the user with help.
   @property {String} INFO
   A dialog with an info header and icon, informs the user of non-critical information.
   */

  var variant$4 = {
    DEFAULT: 'default',
    ERROR: 'error',
    WARNING: 'warning',
    SUCCESS: 'success',
    HELP: 'help',
    INFO: 'info'
  };
  /**
   Enumeration for {@link Dialog} backdrops.

   @typedef {Object} DialogBackdropEnum

   @property {String} NONE
   No backdrop.
   @property {String} MODAL
   A backdrop that hides the dialog when clicked.
   @property {String} STATIC
   A backdrop that does not hide the dialog when clicked.
   */

  var backdrop = {
    NONE: 'none',
    MODAL: 'modal',
    STATIC: 'static'
  }; // Used to map icon with variant

  var capitalize$1 = function capitalize(s) {
    return s.charAt(0).toUpperCase() + s.slice(1);
  }; // The dialog's base classname


  var CLASSNAME$j = '_coral-Dialog'; // Modifier classnames

  var FULLSCREEN_CLASSNAME = "".concat(CLASSNAME$j, "--fullscreenTakeover"); // A string of all possible variant classnames

  var ALL_VARIANT_CLASSES$3 = [];

  for (var variantValue$2 in variant$4) {
    ALL_VARIANT_CLASSES$3.push("".concat(CLASSNAME$j, "--").concat(variant$4[variantValue$2]));
  }
  /**
   @class Coral.Dialog
   @classdesc A Dialog component that supports various use cases with custom content. The Dialog can be given a size by
   using the special attribute <code>[coral-dialog-size]</code> as selector.
   @htmltag coral-dialog
   @extends {HTMLElement}
   @extends {BaseComponent}
   @extends {BaseOverlay}
   */


  var Dialog = Decorator( /*#__PURE__*/function (_BaseOverlay) {
    _inherits(_class, _BaseOverlay);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this); // Prepare templates

      _this._elements = commons.extend(_this._elements, {
        // Fetch or create the content zone elements
        header: _this.querySelector('coral-dialog-header') || document.createElement('coral-dialog-header'),
        content: _this.querySelector('coral-dialog-content') || document.createElement('coral-dialog-content'),
        footer: _this.querySelector('coral-dialog-footer') || document.createElement('coral-dialog-footer')
      });
      template$5.call(_this._elements, {
        i18n: i18n
      }); // Events

      _this._delegateEvents({
        'coral-overlay:open': '_handleOpen',
        'click [coral-close]': '_handleCloseClick',
        // Since we cover the backdrop with ourself for positioning purposes, this is implemented as a click listener
        // instead of using backdropClickedCallback
        'click': '_handleClick',
        // Handle resize events
        'global:resize': 'center',
        'global:key:escape': '_handleEscape'
      }); // Override defaults from Overlay


      _this._trapFocus = _this.constructor.trapFocus.ON;
      _this._returnFocus = _this.constructor.returnFocus.ON;
      _this._overlayAnimationTime = _this.constructor.FADETIME; // Listen for mutations

      _this._headerObserver = new MutationObserver(_this._hideHeaderIfEmpty.bind(_assertThisInitialized(_this))); // Watch for changes to the header element's children

      _this._observeHeader();

      return _this;
    }
    /**
     Whether keyboard interaction is enabled. See {@link DialogInteractionEnum}.
      @type {DialogInteractionEnum}
     @default DialogInteractionEnum.ON
     */


    _createClass(_class, [{
      key: "_observeHeader",

      /** @ignore */
      value: function _observeHeader() {
        if (this._headerObserver) {
          this._headerObserver.disconnect();

          if (this._elements.header) {
            this._headerObserver.observe(this._elements.header, {
              // Catch changes to childList
              childList: true,
              // Catch changes to textContent
              characterData: true,
              // Monitor any child node
              subtree: true
            });
          }
        }
      }
      /**
       Hide the header wrapper if the header content zone is empty.
       @ignore
       */

    }, {
      key: "_hideHeaderIfEmpty",
      value: function _hideHeaderIfEmpty() {
        var header = this._elements.header;

        if (header) {
          var headerWrapper = this._elements.headerWrapper; // If it's empty and has no non-textnode children, hide the header

          var hiddenValue = header.children.length === 0 && header.textContent.replace(/\s*/g, '') === ''; // Only bother if the hidden status has changed

          if (hiddenValue !== headerWrapper.hidden) {
            headerWrapper.hidden = hiddenValue;
          }

          this.variant = this.variant;
        }
      }
    }, {
      key: "_handleOpen",
      value: function _handleOpen(event) {
        this._trackEvent('display', 'coral-dialog', event);
      }
      /** @ignore */

    }, {
      key: "_handleEscape",
      value: function _handleEscape(event) {
        // When escape is pressed, hide ourselves
        if (this.interaction === interaction$2.ON && this.open && this._isTopOverlay()) {
          event.stopPropagation();
          this.open = false;
        }
      }
      /**
       @ignore
       @todo maybe this should be base or something
       */

    }, {
      key: "_handleCloseClick",
      value: function _handleCloseClick(event) {
        var dismissTarget = event.matchedTarget;
        var dismissValue = dismissTarget.getAttribute('coral-close');

        if (!dismissValue || this.matches(dismissValue)) {
          this.open = false;
          event.stopPropagation();

          this._trackEvent('close', 'coral-dialog', event);
        }
      }
    }, {
      key: "_handleClick",
      value: function _handleClick(event) {
        // When we're modal, we close when our outer area (over the backdrop) is clicked
        if (event.target === this && this.backdrop === backdrop.MODAL && this._isTopOverlay()) {
          this.open = false;

          this._trackEvent('close', 'coral-dialog', event);
        }
      }
      /** @ignore */

    }, {
      key: "_moveToDocumentBody",
      value: function _moveToDocumentBody() {
        // Not in the DOM
        if (!document.body.contains(this)) {
          document.body.appendChild(this);
        } // In the DOM but not a direct child of body
        else if (this.parentNode !== document.body) {
            this._ignoreConnectedCallback = true;
            this._repositioned = true;
            document.body.appendChild(this);
            this._ignoreConnectedCallback = false;
          }
      }
    }, {
      key: "_insertTypeIcon",
      value: function _insertTypeIcon() {
        if (this._elements.icon) {
          this._elements.icon.remove();
        }

        var variantValue = this.variant; // Warning icon is same as ERROR icon

        if (variantValue === variant$4.WARNING || variantValue === variant$4.ERROR) {
          variantValue = 'alert';
        } // Inject the SVG icon


        if (variantValue !== variant$4.DEFAULT) {
          var iconName = capitalize$1(variantValue);

          this._elements.headerWrapper.insertAdjacentHTML('beforeend', Icon._renderSVG("spectrum-css-icon-".concat(iconName, "Medium"), ['_coral-Dialog-typeIcon', "_coral-UIIcon-".concat(iconName, "Medium")]));

          this._elements.icon = this._elements.headerWrapper.querySelector('._coral-Dialog-typeIcon');
        }
      }
      /** @ignore */

    }, {
      key: "backdropClickedCallback",
      value: function backdropClickedCallback() {
        // When we're modal, we close when the backdrop is clicked
        if (this.backdrop === backdrop.MODAL && this._isTopOverlay()) {
          this.open = false;
        }
      }
      /**
       Centers the dialog in the middle of the screen.
        @returns {Dialog} this, chainable.
       */

    }, {
      key: "center",
      value: function center() {
        // We're already centered in fullscreen mode
        if (this.fullscreen) {
          return;
        } // If moved we reset the position


        this.style.top = '';
        this.style.left = '';
        return this;
      }
    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        var _this2 = this;

        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add("".concat(CLASSNAME$j, "-wrapper"));
        this.setAttribute("aria-modal", "dialog"); // Default reflected attributes

        if (!this._variant) {
          this.variant = variant$4.DEFAULT;
        }

        if (!this._backdrop) {
          this.backdrop = backdrop.MODAL;
        }

        if (!this._closable) {
          this.closable = closable.OFF;
        }

        if (!this._interaction) {
          this.interaction = interaction$2.ON;
        } // Fetch the content zones


        var header = this._elements.header;
        var content = this._elements.content;
        var footer = this._elements.footer; // Verify if a content zone is provided

        var contentZoneProvided = this.contains(content) && content || this.contains(footer) && footer || this.contains(header) && header; // Verify if the internal wrapper exists

        var wrapper = this.querySelector(".".concat(CLASSNAME$j)); // Case where the dialog was rendered already - cloneNode support

        if (wrapper) {
          // Remove tab captures
          Array.prototype.filter.call(this.children, function (child) {
            return child.hasAttribute('coral-tabcapture');
          }).forEach(function (tabCapture) {
            _this2.removeChild(tabCapture);
          }); // Assign internal elements

          this._elements.headerWrapper = this.querySelector('._coral-Dialog-header');
          this._elements.closeButton = this.querySelector('._coral-Dialog-closeButton');
          this._elements.wrapper = wrapper;
        } // Case where the dialog needs to be rendered
        else {
            // Create default wrapper
            wrapper = this._elements.wrapper; // Create default header wrapper

            var headerWrapper = this._elements.headerWrapper; // Case where the dialog needs to be rendered and content zones are provided

            if (contentZoneProvided) {
              // Check if user wrapper is provided
              if (contentZoneProvided.parentNode === this) {
                // Content zone target defaults to default wrapper if no user wrapper element is provided
                this._elements.wrapper = wrapper;
              } else {
                // Content zone target defaults to user wrapper element if provided
                this._elements.wrapper = contentZoneProvided.parentNode;
              } // Move everything in the wrapper


              while (this.firstChild) {
                wrapper.appendChild(this.firstChild);
              } // Add the dialog header before the content


              if (this._elements.wrapper.contains(content)) {
                this._elements.wrapper.insertBefore(headerWrapper, content);
              } else {
                // try adding in next frame
                // so that content is a child of dialog wrapper
                commons.nextFrame(function () {
                  _this2._elements.wrapper.insertBefore(headerWrapper, content);
                });
              }
            } // Case where the dialog needs to be rendered and content zones need to be created
            else {
                // Default content zone target is wrapper
                this._elements.wrapper = wrapper; // Move everything in the "content" content zone

                while (this.firstChild) {
                  content.appendChild(this.firstChild);
                } // Add the content zones in the wrapper


                wrapper.appendChild(headerWrapper);
                wrapper.appendChild(content);
                wrapper.appendChild(footer);
              } // Add the wrapper to the dialog


            this.appendChild(wrapper);
          } // Only the wrapper gets the dialog class


        this._elements.wrapper.classList.add(CLASSNAME$j); // Mark the dialog with a public attribute for sizing


        this._elements.wrapper.setAttribute('coral-dialog-size', ''); // Close button should stay under the dialog


        this._elements.wrapper.appendChild(this._elements.closeButton); // Copy styles over to new wrapper


        if (this._elements.wrapper.parentNode !== this) {
          var contentWrapper = this.querySelector('[handle="wrapper"]');
          Array.prototype.forEach.call(contentWrapper.classList, function (style) {
            return _this2._elements.wrapper.classList.add(style);
          });
          contentWrapper.removeAttribute('class');
        } // Assign content zones


        this.header = header;
        this.footer = footer;
        this.content = content;
      }
    }, {
      key: "interaction",
      get: function get() {
        return this._interaction || interaction$2.ON;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        this._interaction = validate.enumeration(interaction$2)(value) && value || interaction$2.ON;
      }
      /**
       The dialog header element.
        @type {DialogHeader}
       @contentzone
       */

    }, {
      key: "header",
      get: function get() {
        return this._getContentZone(this._elements.header);
      },
      set: function set(value) {
        this._setContentZone('header', value, {
          handle: 'header',
          tagName: 'coral-dialog-header',
          insert: function insert(header) {
            header.classList.add("".concat(CLASSNAME$j, "-title")); // Providing the ARIA attributes to coral dialog header

            header.setAttribute('role', 'heading');
            header.setAttribute('aria-level', '2'); // Position the header between the drag zone and the type icon

            this._elements.headerWrapper.insertBefore(header, this._elements.dragZone.nextElementSibling);
          },
          set: function set() {
            // Stop observing the old header and observe the new one
            this._observeHeader(); // Check if header needs to be hidden


            this._hideHeaderIfEmpty();
          }
        });
      }
      /**
       The dialog content element.
        @type {DialogContent}
       @contentzone
       */

    }, {
      key: "content",
      get: function get() {
        return this._getContentZone(this._elements.content);
      },
      set: function set(value) {
        this._setContentZone('content', value, {
          handle: 'content',
          tagName: 'coral-dialog-content',
          insert: function insert(content) {
            content.classList.add("".concat(CLASSNAME$j, "-content"));
            var footer = this.footer; // The content should always be before footer

            this._elements.wrapper.insertBefore(content, this.contains(footer) && footer || null);
          }
        });
      }
      /**
       The dialog footer element.
        @type {DialogFooter}
       @contentzone
       */

    }, {
      key: "footer",
      get: function get() {
        return this._getContentZone(this._elements.footer);
      },
      set: function set(value) {
        this._setContentZone('footer', value, {
          handle: 'footer',
          tagName: 'coral-dialog-footer',
          insert: function insert(footer) {
            footer.classList.add("".concat(CLASSNAME$j, "-footer")); // The footer should always be after content

            this._elements.wrapper.appendChild(footer);
          }
        });
      }
      /**
       The backdrop configuration for this dialog. See {@link DialogBackdropEnum}.
        @type {String}
       @default DialogBackdropEnum.MODAL
       @htmlattribute backdrop
       */

    }, {
      key: "backdrop",
      get: function get() {
        return this._backdrop || backdrop.MODAL;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        this._backdrop = validate.enumeration(backdrop)(value) && value || backdrop.MODAL;
        var showBackdrop = this._backdrop !== backdrop.NONE;

        this._elements.wrapper.classList.toggle("".concat(CLASSNAME$j, "--noBackdrop"), !showBackdrop); // We're visible now, so hide or show the modal accordingly


        if (this.open && showBackdrop) {
          this._showBackdrop();
        }
      }
      /**
       The dialog's variant. See {@link DialogVariantEnum}.
        @type {String}
       @default DialogVariantEnum.DEFAULT
       @htmlattribute variant
       @htmlattributereflected
       */

    }, {
      key: "variant",
      get: function get() {
        return this._variant || variant$4.DEFAULT;
      },
      set: function set(value) {
        var _this$_elements$wrapp;

        value = transform.string(value).toLowerCase();
        this._variant = validate.enumeration(variant$4)(value) && value || variant$4.DEFAULT;

        this._reflectAttribute('variant', this._variant); // Insert SVG icon


        this._insertTypeIcon(); // Remove all variant classes


        (_this$_elements$wrapp = this._elements.wrapper.classList).remove.apply(_this$_elements$wrapp, ALL_VARIANT_CLASSES$3);

        if (this._variant === variant$4.DEFAULT) {
          // ARIA
          this.setAttribute('role', 'dialog');
        } else {
          // Set new variant class
          this._elements.wrapper.classList.add("".concat(CLASSNAME$j, "--").concat(this._variant)); // ARIA


          this.setAttribute('role', 'alertdialog');
        }

        var hasHeader = this.header && this.header.textContent !== ''; // If the dialog has a header and is not otherwise labelled,

        if (hasHeader && !(this.hasAttribute('aria-labelledby') || this.hasAttribute('aria-label'))) {
          this.header.id = this.header.id || commons.getUID(); // label the dialog with a reference to the header

          this.setAttribute('aria-labelledby', this.header.id);
        } // If the dialog has no content, or the content is empty, do nothing further.


        if (!this.content || this.content.textContent === '') {
          return;
        } // If the dialog has a content,


        this.content.id = this.content.id || commons.getUID(); // In an alertdialog with a content region, if the alertdialog is not otherwise described.

        if (this._variant !== variant$4.DEFAULT) {
          // with no header,
          if (!hasHeader) {
            // label the alertdialog with a reference to the content
            this.setAttribute('aria-labelledby', this.content.id);
          } // otherwise, if the alertdialog is not otherwise described,
          else if (!this.hasAttribute('aria-describedby')) {
              // ensure that the alertdialog is described by the content.
              this.setAttribute('aria-describedby', this.content.id);
            }
        } else if (this.getAttribute('aria-labelledby') === this.content.id) {
          this.removeAttribute('aria-labelledby');
        }
      }
      /**
       Whether the dialog should be displayed full screen (without borders or margin).
        @type {Boolean}
       @default false
       @htmlattribute fullscreen
       @htmlattributereflected
       */

    }, {
      key: "fullscreen",
      get: function get() {
        return this._fullscreen || false;
      },
      set: function set(value) {
        this._fullscreen = transform.booleanAttr(value);

        this._reflectAttribute('fullscreen', this._fullscreen);

        if (this._fullscreen) {
          // Full screen and movable are not compatible
          this.movable = false;

          this._elements.wrapper.classList.add(FULLSCREEN_CLASSNAME);
        } else {
          this._elements.wrapper.classList.remove(FULLSCREEN_CLASSNAME);
        }
      }
      /**
       Inherited from {@link BaseOverlay#open}.
       */

    }, {
      key: "open",
      get: function get() {
        return _get(_getPrototypeOf(_class.prototype), "open", this);
      },
      set: function set(value) {
        var _this3 = this;

        _set(_getPrototypeOf(_class.prototype), "open", value, this, true); // Ensure we're in the DOM


        if (this.open) {
          // If not child of document.body, we have to move it there
          this._moveToDocumentBody(); // Show the backdrop, if necessary


          if (this.backdrop !== backdrop.NONE) {
            this._showBackdrop();
          }
        } // Support animation


        requestAnimationFrame(function () {
          // Support wrapped dialog
          _this3._elements.wrapper.classList.toggle('is-open', _this3.open); // Handles what to focus based on focusOnShow


          if (_this3.open) {
            commons.transitionEnd(_this3._elements.wrapper, function () {
              _this3._handleFocus();

              _this3._elements.closeButton.tabIndex = 0;

              _this3._elements.closeButton.removeAttribute('coral-tabcapture');
            });
          } else {
            _this3._elements.closeButton.tabIndex = -1;

            _this3._elements.closeButton.setAttribute('coral-tabcapture', '');
          }
        });
      }
      /**
       The dialog's icon.
        @type {String}
       @default ""
       @htmlattribute icon
       */

    }, {
      key: "icon",
      get: function get() {
        return this._elements.icon;
      },
      set: function set(value) {
        this._elements.icon = value;
      }
      /**
       Whether the dialog should have a close button. See {@link DialogClosableEnum}.
        @type {String}
       @default DialogClosableEnum.OFF
       @htmlattribute closable
       @htmlattributereflected
       */

    }, {
      key: "closable",
      get: function get() {
        return this._closable || closable.OFF;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        this._closable = validate.enumeration(closable)(value) && value || closable.OFF;

        this._reflectAttribute('closable', this._closable);

        this._elements.wrapper.classList.toggle("".concat(CLASSNAME$j, "--dismissible"), this._closable === closable.ON);
      }
      /**
       Whether the dialog can moved around by dragging the title.
        @type {Boolean}
       @default false
       @htmlattribute movable
       @htmlattributereflected
       */

    }, {
      key: "movable",
      get: function get() {
        return this._movable || false;
      },
      set: function set(value) {
        this._movable = transform.booleanAttr(value);

        this._reflectAttribute('movable', this._movable); // Movable and fullscreen are not compatible


        if (this._movable) {
          this.fullscreen = false;
        }

        if (this._movable) {
          var dragAction = new DragAction(this);
          dragAction.handle = this._elements.headerWrapper;
        } else {
          // Disables any dragging interaction
          if (this.dragAction) {
            this.dragAction.destroy();
          } // Recenter the dialog once it's not movable anymore


          this.center();
        }
      }
      /**
       Inherited from {@link BaseComponent#trackingElement}.
       */

    }, {
      key: "trackingElement",
      get: function get() {
        return typeof this._trackingElement === 'undefined' ? this.header && this.header.textContent && this.header.textContent.replace(/\s{2,}/g, ' ').trim() || '' : this._trackingElement;
      },
      set: function set(value) {
        _set(_getPrototypeOf(_class.prototype), "trackingElement", value, this, true);
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-dialog-header': 'header',
          'coral-dialog-content': 'content',
          'coral-dialog-footer': 'footer'
        };
      }
      /**
       Returns {@link Dialog} variants.
        @return {DialogVariantEnum}
       */

    }], [{
      key: "variant",
      get: function get() {
        return variant$4;
      }
      /**
       Returns {@link Dialog} backdrops.
        @return {DialogBackdropEnum}
       */

    }, {
      key: "backdrop",
      get: function get() {
        return backdrop;
      }
      /**
       Returns {@link Dialog} close options.
        @return {DialogClosableEnum}
       */

    }, {
      key: "closable",
      get: function get() {
        return closable;
      }
      /**
       Returns {@link Dialog} interaction options.
        @return {DialogInteractionEnum}
       */

    }, {
      key: "interaction",
      get: function get() {
        return interaction$2;
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['interaction', 'backdrop', 'variant', 'fullscreen', 'icon', 'closable', 'movable']);
      }
    }]);

    return _class;
  }(BaseOverlay(BaseComponent(HTMLElement))));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Dialog.Header
   @classdesc The Dialog header content
   @htmltag coral-dialog-header
   @return {HTMLElement}
   */
  var DialogHeader = (function () {
    return document.createElement('coral-dialog-header');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Dialog.Content
   @classdesc The Dialog default content
   @htmltag coral-dialog-content
   @return {HTMLElement}
   */
  var DialogContent = (function () {
    return document.createElement('coral-dialog-content');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Dialog.Footer
   @classdesc The Dialog footer content
   @htmltag coral-dialog-footer
   @return {HTMLElement}
   */
  var DialogFooter = (function () {
    return document.createElement('coral-dialog-footer');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons.extend(strings, {
    'coral-component-dialog': translations$5
  }); // Expose component on the Coral namespace

  commons._define('coral-dialog', Dialog);

  Dialog.Header = DialogHeader;
  Dialog.Content = DialogContent;
  Dialog.Footer = DialogFooter;

  var template$6 = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["headerWrapper"] = document.createElement("div");
    el0.className += " _coral-Dialog-header";
    el0.setAttribute("handle", "headerWrapper");
    el0.setAttribute("role", "presentation");
    frag.appendChild(el0);
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    var el2 = this["closeButton"] = document.createElement("button", "coral-button");
    el2.setAttribute("tracking", "off");
    el2.setAttribute("handle", "closeButton");
    el2.className += " _coral-Dialog-closeButton _coral-ClearButton";
    el2.setAttribute("type", "button");
    el2.setAttribute("is", "coral-button");
    el2.setAttribute("variant", "_custom");
    el2.setAttribute("icon", "close");
    el2.setAttribute("title", data_0["i18n"]["get"]('Close'));
    el2.setAttribute("tabindex", "-1");
    el2.setAttribute("coral-close", "");
    frag.appendChild(el2);
    var el3 = document.createTextNode("\n");
    frag.appendChild(el3);
    var el4 = this["tip"] = document.createElement("div");
    el4.className += " _coral-Popover-tip";
    el4.setAttribute("handle", "tip");
    frag.appendChild(el4);
    var el5 = document.createTextNode("\n");
    frag.appendChild(el5);
    return frag;
  };

  var CLASSNAME$k = '_coral-Popover';
  var OFFSET = 5; // Used to map icon with variant

  var capitalize$2 = function capitalize(s) {
    return s.charAt(0).toUpperCase() + s.slice(1);
  }; // If it's empty and has no non-textnode children


  var _isEmpty = function _isEmpty(el) {
    return !el || el.children.length === 0 && el.textContent.replace(/\s*/g, '') === '';
  };
  /**
   Enumeration for {@link Popover} closable state.

   @typedef {Object} PopoverClosableEnum

   @property {String} ON
   Show a close button on the popover and close the popover when clicked.
   @property {String} OFF
   Do not show a close button. Elements with the <code>coral-close</code> attributes will still close the
   popover.
   */


  var closable$1 = {
    ON: 'on',
    OFF: 'off'
  };
  /**
   Enumeration for {@link Popover} variants.

   @typedef {Object} PopoverVariantEnum

   @property {String} DEFAULT
   A default popover without header icon.
   @property {String} ERROR
   A popover with an error header and icon, indicating that an error has occurred.
   @property {String} WARNING
   A popover with a warning header and icon, notifying the user of something important.
   @property {String} SUCCESS
   A popover with a success header and icon, indicates to the user that an operation was successful.
   @property {String} HELP
   A popover with a question header and icon, provides the user with help.
   @property {String} INFO
   A popover with an info header and icon, informs the user of non-critical information.
   */

  var variant$5 = {
    DEFAULT: 'default',
    ERROR: 'error',
    WARNING: 'warning',
    SUCCESS: 'success',
    HELP: 'help',
    INFO: 'info',
    _COACHMARK: '_coachmark'
  }; // A string of all possible variant classnames

  var ALL_VARIANT_CLASSES$4 = [];

  for (var variantValue$3 in variant$5) {
    if (variantValue$3 !== 'COACHMARK') {
      ALL_VARIANT_CLASSES$4.push("_coral-Dialog--".concat(variant$5[variantValue$3]));
    }
  } // A string of all possible placement classnames


  var placement$1 = Overlay.placement;
  var ALL_PLACEMENT_CLASSES = [];

  for (var placementKey in placement$1) {
    ALL_PLACEMENT_CLASSES.push("".concat(CLASSNAME$k, "--").concat(placement$1[placementKey]));
  }
  /**
   @class Coral.Popover
   @classdesc A Popover component for small overlay content.
   @htmltag coral-popover
   @extends {Overlay}
   */


  var Popover = Decorator( /*#__PURE__*/function (_ExtensibleOverlay) {
    _inherits(_class, _ExtensibleOverlay);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this); // Prepare templates

      _this._elements = commons.extend(_this._elements, {
        // Fetch or create the content zone elements
        header: _this.querySelector('coral-popover-header') || document.createElement('coral-popover-header'),
        content: _this.querySelector('coral-popover-content') || document.createElement('coral-popover-content'),
        footer: _this.querySelector('coral-popover-footer') || document.createElement('coral-popover-footer')
      });
      template$6.call(_this._elements, {
        i18n: i18n
      }); // Events

      _this._delegateEvents({
        'global:capture:click': '_handleClick',
        'coral-overlay:positioned': '_onPositioned',
        'coral-overlay:_animate': '_onAnimate'
      }); // Override defaults from Overlay


      _this._focusOnShow = _this.constructor.focusOnShow.ON;
      _this._trapFocus = _this.constructor.trapFocus.ON;
      _this._returnFocus = _this.constructor.returnFocus.ON;
      _this._overlayAnimationTime = _this.constructor.FADETIME;
      _this._lengthOffset = OFFSET; // Listen for mutations

      ['header', 'footer'].forEach(function (name) {
        _this["_".concat(name, "Observer")] = new MutationObserver(function () {
          _this._hideContentZoneIfEmpty(name);

          _this._toggleFlyout();
        }); // Watch for changes

        _this._observeContentZone(name);
      });
      return _this;
    }
    /**
     The popover's content element.
      @contentzone
     @name content
     @type {PopoverContent}
     */


    _createClass(_class, [{
      key: "_setAriaExpandedOnTarget",
      value: function _setAriaExpandedOnTarget() {
        var _this2 = this;

        var target = this._getTarget();

        if (target) {
          var hasPopupAttribute = target.hasAttribute('aria-haspopup');

          if (hasPopupAttribute || target.querySelector('[aria-haspopup]') !== null) {
            var targetElements = hasPopupAttribute ? [target] : target.querySelectorAll('[aria-haspopup]');
            targetElements.forEach(function (targetElement) {
              return targetElement.setAttribute('aria-expanded', _this2.open);
            });
          }
        }
      }
    }, {
      key: "_onPositioned",
      value: function _onPositioned(event) {
        if (this.open) {
          var _this$classList;

          // Set arrow placement
          (_this$classList = this.classList).remove.apply(_this$classList, ALL_PLACEMENT_CLASSES);

          this.classList.add("".concat(CLASSNAME$k, "--").concat(event.detail.placement));
        }
      }
    }, {
      key: "_onAnimate",
      value: function _onAnimate() {
        // popper attribute
        var popperPlacement = this.getAttribute('x-placement'); // popper takes care of setting left, top to 0 on positioning

        if (popperPlacement === 'left') {
          this.style.left = '8px';
        } else if (popperPlacement === 'top') {
          this.style.top = '8px';
        } else if (popperPlacement === 'right') {
          this.style.left = '-8px';
        } else if (popperPlacement === 'bottom') {
          this.style.top = '-8px';
        }
      }
    }, {
      key: "_insertTypeIcon",
      value: function _insertTypeIcon() {
        if (this._elements.icon) {
          this._elements.icon.remove();
        }

        var variantValue = this.variant; // Warning icon is same as ERROR icon

        if (variantValue === variant$5.WARNING || variantValue === variant$5.ERROR) {
          variantValue = 'alert';
        } // Inject the SVG icon


        if (variantValue !== variant$5.DEFAULT && variantValue !== variant$5._COACHMARK) {
          var iconName = capitalize$2(variantValue);

          this._elements.headerWrapper.insertAdjacentHTML('beforeend', Icon._renderSVG("spectrum-css-icon-".concat(iconName, "Medium"), ['_coral-Dialog-typeIcon', "_coral-UIIcon-".concat(iconName, "Medium")]));

          this._elements.icon = this.querySelector('._coral-Dialog-typeIcon');
        }
      }
    }, {
      key: "_observeContentZone",
      value: function _observeContentZone(name) {
        var observer = this["_".concat(name, "Observer")];

        if (observer) {
          observer.disconnect();
          observer.observe(this._elements[name], {
            // Catch changes to childList
            childList: true,
            // Catch changes to textContent
            characterData: true,
            // Monitor any child node
            subtree: true
          });
        }
      }
    }, {
      key: "_hideContentZoneIfEmpty",
      value: function _hideContentZoneIfEmpty(name) {
        var contentZone = this._elements[name];
        var target = name === 'header' ? this._elements.headerWrapper : contentZone; // If it's empty and has no non-textnode children, hide the header

        var hiddenValue = _isEmpty(contentZone); // Only bother if the hidden status has changed


        if (hiddenValue !== target.hidden) {
          target.hidden = hiddenValue; // Reposition as the height has changed

          this.reposition();
        }
      }
    }, {
      key: "_toggleCoachMark",
      value: function _toggleCoachMark(isCoachMark) {
        var _this3 = this;

        this.classList.toggle('_coral-CoachMarkPopover', isCoachMark);

        this._elements.headerWrapper.classList.toggle('_coral-Dialog-header', !isCoachMark);

        this._elements.headerWrapper.classList.toggle('_coral-CoachMarkPopover-header', isCoachMark);

        ['header', 'content', 'footer'].forEach(function (contentZone, i) {
          var el = _this3[contentZone];
          var type = i === 0 ? 'title' : contentZone;

          if (el) {
            el.classList.toggle("_coral-Dialog-".concat(type), !isCoachMark);
            el.classList.toggle("_coral-CoachMarkPopover-".concat(type), isCoachMark);
          }
        });
      }
    }, {
      key: "_toggleFlyout",
      value: function _toggleFlyout() {
        // Flyout mode is when there's only content in default variant
        var isFlyout = this._variant === variant$5._COACHMARK || this._variant === variant$5.DEFAULT && _isEmpty(this.header) && _isEmpty(this.footer);

        this.classList.toggle("".concat(CLASSNAME$k, "--dialog"), !isFlyout);
        this._elements.tip.hidden = isFlyout;
      }
      /** @private */

    }, {
      key: "_handleClick",
      value: function _handleClick(event) {
        if (this.interaction === this.constructor.interaction.OFF) {
          // Since we use delegation, just ignore clicks if interaction is off
          return;
        }

        var eventTarget = event.target;

        var targetEl = this._getTarget();

        var eventIsWithinTarget = targetEl ? targetEl.contains(eventTarget) : false;

        if (eventIsWithinTarget) {
          // When target is clicked
          if (!this.open && !targetEl.disabled) {
            // Open if we're not already open and target element is not disabled
            this.show();

            this._trackEvent('display', 'coral-popover', event);
          } else {
            this.hide();

            this._trackEvent('close', 'coral-popover', event);
          }
        } else if (this.open && !this.contains(eventTarget)) {
          var target = eventTarget.closest('._coral-Overlay'); // Also check if the click element is inside an overlay which target could be inside of this popover

          if (target && this.contains(target._getTarget())) {
            return;
          } // Close if we're open and the click was outside of the target and outside of the popover


          this.hide();

          this._trackEvent('close', 'coral-popover', event);
        }
      }
    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        var _this4 = this;

        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$k); // ARIA

        if (!this.hasAttribute('role')) {
          this.setAttribute('role', 'dialog');
        }

        if (!this.hasAttribute('aria-live')) {
          // This helped announcements in certain screen readers
          this.setAttribute('aria-live', 'assertive');
        } // Default reflected attributes


        if (!this._variant) {
          this.variant = variant$5.DEFAULT;
        }

        if (!this._closable) {
          this.closable = closable$1.OFF;
        } // // Fetch the content zones


        var header = this._elements.header;
        var content = this._elements.content;
        var footer = this._elements.footer; // Verify if a content zone is provided

        var contentZoneProvided = this.contains(content) && content || this.contains(footer) && footer || this.contains(header) && header; // Remove content zones so we can process children

        if (header.parentNode) {
          header.remove();
        }

        if (content.parentNode) {
          content.remove();
        }

        if (footer.parentNode) {
          footer.remove();
        } // Remove tab captures


        Array.prototype.filter.call(this.children, function (child) {
          return child.hasAttribute('coral-tabcapture');
        }).forEach(function (tabCapture) {
          _this4.removeChild(tabCapture);
        }); // Support cloneNode

        var template = this.querySelectorAll('._coral-Dialog-header, ._coral-Dialog-closeButton, ._coral-Popover-tip');

        for (var i = 0; i < template.length; i++) {
          template[i].remove();
        } // Move everything in the content


        if (!contentZoneProvided) {
          while (this.firstChild) {
            content.appendChild(this.firstChild);
          }
        } // Insert template


        var frag = document.createDocumentFragment();
        frag.appendChild(this._elements.headerWrapper);
        frag.appendChild(this._elements.closeButton);
        frag.appendChild(this._elements.tip);
        this.appendChild(frag); // Assign content zones

        this.header = header;
        this.content = content;
        this.footer = footer;
      }
    }, {
      key: "content",
      get: function get() {
        return this._getContentZone(this._elements.content);
      },
      set: function set(value) {
        this._setContentZone('content', value, {
          handle: 'content',
          tagName: 'coral-popover-content',
          insert: function insert(content) {
            content.classList.add('_coral-Dialog-content');
            var footer = this.footer; // The content should always be before footer

            this.insertBefore(content, this.contains(footer) && footer || null);
          }
        });
      }
      /**
       The popover's header element.
        @contentzone
       @name header
       @type {PopoverHeader}
       */

    }, {
      key: "header",
      get: function get() {
        return this._getContentZone(this._elements.header);
      },
      set: function set(value) {
        this._setContentZone('header', value, {
          handle: 'header',
          tagName: 'coral-popover-header',
          insert: function insert(header) {
            header.classList.add('_coral-Dialog-title');

            this._elements.headerWrapper.insertBefore(header, this._elements.headerWrapper.firstChild);
          },
          set: function set() {
            // Stop observing the old header and observe the new one
            this._observeContentZone('header'); // Check if header needs to be hidden


            this._hideContentZoneIfEmpty('header');
          }
        });
      }
      /**
       The popover's footer element.
        @type {PopoverFooter}
       @contentzone
       */

    }, {
      key: "footer",
      get: function get() {
        return this._getContentZone(this._elements.footer);
      },
      set: function set(value) {
        this._setContentZone('footer', value, {
          handle: 'footer',
          tagName: 'coral-popover-footer',
          insert: function insert(footer) {
            footer.classList.add('_coral-Dialog-footer'); // The footer should always be after content

            this.appendChild(footer);
          },
          set: function set() {
            // Stop observing the old header and observe the new one
            this._observeContentZone('footer'); // Check if header needs to be hidden


            this._hideContentZoneIfEmpty('footer');
          }
        });
      }
      /**
       The popover's variant. See {@link PopoverVariantEnum}.
        @type {String}
       @default PopoverVariantEnum.DEFAULT
       @htmlattribute variant
       @htmlattributereflected
       */

    }, {
      key: "variant",
      get: function get() {
        return this._variant || variant$5.DEFAULT;
      },
      set: function set(value) {
        var _this$classList2;

        value = transform.string(value).toLowerCase();
        this._variant = validate.enumeration(variant$5)(value) && value || variant$5.DEFAULT;

        this._reflectAttribute('variant', this._variant); // Insert SVG icon


        this._insertTypeIcon(); // Remove all variant classes


        (_this$classList2 = this.classList).remove.apply(_this$classList2, ALL_VARIANT_CLASSES$4); // Toggle dialog mode


        this._toggleFlyout();

        if (this._variant === variant$5._COACHMARK) {
          // ARIA
          this.setAttribute('role', 'dialog');

          this._toggleCoachMark(true);
        } else {
          this._toggleCoachMark(false);

          if (this._variant === variant$5.DEFAULT) {
            // ARIA
            if (!this.hasAttribute('role')) {
              this.setAttribute('role', 'dialog');
            }
          } else {
            // Set new variant class
            this.classList.add("_coral-Dialog--".concat(this._variant)); // ARIA

            this.setAttribute('role', 'alertdialog');
          }
        }
      }
      /**
       Whether the popover should have a close button. See {@link PopoverClosableEnum}.
        @type {String}
       @default PopoverClosableEnum.OFF
       @htmlattribute closable
       @htmlattributereflected
       */

    }, {
      key: "closable",
      get: function get() {
        return this._closable || closable$1.OFF;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        this._closable = validate.enumeration(closable$1)(value) && value || closable$1.OFF;

        this._reflectAttribute('closable', this._closable);

        this._elements.closeButton.style.display = this._closable === closable$1.ON ? 'block' : 'none';
      }
      /**
       Inherited from {@link Overlay#target}.
       */

    }, {
      key: "target",
      get: function get() {
        return _get(_getPrototypeOf(_class.prototype), "target", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(_class.prototype), "target", value, this, true); // Coach Mark specific


        var target = this._getTarget();

        if (target && target.tagName === 'CORAL-COACHMARK') {
          this.setAttribute('variant', variant$5._COACHMARK);
        }

        this._setAriaExpandedOnTarget();
      }
      /**
       Inherited from {@link Overlay#open}.
       */

    }, {
      key: "open",
      get: function get() {
        return _get(_getPrototypeOf(_class.prototype), "open", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(_class.prototype), "open", value, this, true);

        var target = this._getTarget();

        if (target) {
          var is = target.getAttribute('is');

          if (is === 'coral-button' || is === 'coral-anchorbutton') {
            target.classList.toggle('is-selected', this.open);
          }

          this._setAriaExpandedOnTarget();
        }
      }
      /**
       @ignore
        Not supported anymore.
       */

    }, {
      key: "icon",
      get: function get() {
        return this._icon || '';
      },
      set: function set(value) {
        this._icon = transform.string(value);
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-popover-header': 'header',
          'coral-popover-content': 'content',
          'coral-popover-footer': 'footer'
        };
      }
      /**
       Returns {@link Popover} variants.
        @return {PopoverVariantEnum}
       */

    }], [{
      key: "variant",
      get: function get() {
        return variant$5;
      }
      /**
       Returns {@link Popover} close options.
        @return {PopoverClosableEnum}
       */

    }, {
      key: "closable",
      get: function get() {
        return closable$1;
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['closable', 'variant']);
      }
    }]);

    return _class;
  }(ExtensibleOverlay));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Popover.Header
   @classdesc The Popover header content
   @htmltag coral-popover-header
   @return {HTMLElement}
   */
  var PopoverHeader = (function () {
    return document.createElement('coral-popover-header');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Popover.Content
   @classdesc The Popover default content
   @htmltag coral-popover-content
   @return {HTMLElement}
   */
  var PopoverContent = (function () {
    return document.createElement('coral-popover-content');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Popover.Footer
   @classdesc The Popover footer content
   @htmltag coral-popover-footer
   @return {HTMLElement}
   */
  var PopoverFooter = (function () {
    return document.createElement('coral-popover-footer');
  });

  var CLASSNAMES = ['coral-Rule', 'coral-Rule--subsection2'];
  /**
   @class Coral.Popover.Separator
   @classdesc The Popover separator
   @htmltag coral-popover-separator
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var PopoverSeparator = Decorator( /*#__PURE__*/function (_BaseComponent) {
    _inherits(_class, _BaseComponent);

    var _super = _createSuper(_class);

    function _class() {
      _classCallCheck(this, _class);

      return _super.apply(this, arguments);
    }

    _createClass(_class, [{
      key: "connectedCallback",

      /** @ignore */
      value: function connectedCallback() {
        var _this$classList;

        _get(_getPrototypeOf(_class.prototype), "connectedCallback", this).call(this);

        (_this$classList = this.classList).add.apply(_this$classList, CLASSNAMES);
      }
    }]);

    return _class;
  }(BaseComponent(HTMLElement)));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons.extend(strings, {
    'coral-component-popover': translations$4
  }); // Expose component on the Coral namespace

  commons._define('coral-popover-separator', PopoverSeparator);

  commons._define('coral-popover', Popover);

  Popover.Header = PopoverHeader;
  Popover.Content = PopoverContent;
  Popover.Footer = PopoverFooter;
  Popover.Separator = PopoverSeparator;

  var template$7 = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var data = data_0 = typeof data_0 === "undefined" ? {} : data_0;
    data = data_0;
    var buttonId = data.commons.getUID();
    var listId = data.commons.getUID();
    data_0 = data;
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    var el2 = this["button"] = document.createElement("button", "coral-button");
    el2.setAttribute("tracking", "off");
    el2.setAttribute("variant", "_custom");
    el2.setAttribute("iconposition", "right");
    el2.setAttribute("handle", "button");
    el2.setAttribute("type", "button");
    el2.setAttribute("is", "coral-button");
    el2.setAttribute("aria-haspopup", "listbox");
    el2.id = buttonId;
    el2.setAttribute("aria-controls", listId);
    el2.setAttribute("aria-expanded", "false");
    el2.className += " _coral-FieldButton _coral-Dropdown-trigger";
    var el3 = document.createTextNode("\n  ");
    el2.appendChild(el3);
    var el4 = this["label"] = document.createElement("coral-button-label");
    el4.className += " _coral-Dropdown-label";
    el4.setAttribute("handle", "label");
    el4.id = data_0["commons"]["getUID"]();
    el4.textContent = "​";
    el2.appendChild(el4);
    var el5 = document.createTextNode("\n  ");
    el2.appendChild(el5);
    var el6 = this["invalidIcon"] = document.createElement("coral-icon");
    el6.setAttribute("icon", "alert");
    el6.setAttribute("hidden", "");
    el6.setAttribute("handle", "invalidIcon");
    el6.className += " _coral-Dropdown-invalidIcon";
    el6.setAttribute("alt", data_0["i18n"]["get"]('invalid'));
    el6.id = data_0["commons"]["getUID"]();
    el2.appendChild(el6);
    var el7 = document.createTextNode("\n");
    el2.appendChild(el7);
    frag.appendChild(el2);
    var el8 = document.createTextNode("\n");
    frag.appendChild(el8);
    data = data_0; // Don't wait for button MO to pick up the label

    this.button._elements.label = this.label; // Render invalid icon

    this.button.insertAdjacentHTML('beforeend', data.Icon._renderSVG('spectrum-css-icon-ChevronDownMedium', ['_coral-Dropdown-icon', '_coral-UIIcon-ChevronDownMedium']));
    data_0 = data;
    var el10 = document.createTextNode("\n");
    frag.appendChild(el10);
    var el11 = this["overlay"] = document.createElement("coral-popover");
    el11.setAttribute("withinoffset", "0");
    el11.setAttribute("tracking", "off");
    el11.className += " _coral-Select-overlay";
    el11.setAttribute("smart", "");
    el11.id = data_0["commons"]["getUID"]();
    el11.setAttribute("handle", "overlay");
    el11.setAttribute("placement", "bottom");
    el11.setAttribute("focusonshow", "coral-selectlist");
    el11.setAttribute("role", "presentation");
    var el12 = document.createTextNode("\n  ");
    el11.appendChild(el12);
    data = data_0; // Constrains the size of the list to 6 items.
    // @todo move this to theme

    var maxHeight = 'max-height:' + 32 * 6 + 'px';
    data_0 = data;
    var el14 = document.createTextNode("\n  ");
    el11.appendChild(el14);
    var el15 = this["list"] = document.createElement("coral-selectlist");
    el15.setAttribute("tracking", "off");
    el15.setAttribute("style", maxHeight);
    el15.setAttribute("handle", "list");
    el15.setAttribute("role", "listbox");
    el15.id = listId;
    el11.appendChild(el15);
    var el16 = document.createTextNode("\n");
    el11.appendChild(el16);
    frag.appendChild(el11);
    var el17 = document.createTextNode("\n");
    frag.appendChild(el17);
    var el18 = this["input"] = document.createElement("input");
    el18.setAttribute("handle", "input");
    el18.setAttribute("type", "hidden");
    frag.appendChild(el18);
    var el19 = document.createTextNode("\n");
    frag.appendChild(el19);
    var el20 = this["nativeSelect"] = document.createElement("select");
    el20.setAttribute("handle", "nativeSelect");
    el20.className += " _coral-Dropdown-select";
    el20.setAttribute("tabindex", "-1");
    frag.appendChild(el20);
    var el21 = document.createTextNode("\n");
    frag.appendChild(el21);
    var el22 = this["taglist"] = document.createElement("coral-taglist");
    el22.setAttribute("tracking", "off");
    el22.setAttribute("handle", "taglist");
    el22.className += " _coral-Dropdown-tagList";
    frag.appendChild(el22);
    var el23 = document.createTextNode("\n");
    frag.appendChild(el23);
    return frag;
  };

  /**
   Enumeration for {@link Select} variants.

   @typedef {Object} SelectVariantEnum

   @property {String} DEFAULT
   A default, gray Select.
   @property {String} QUIET
   A Select with no border or background.
   */

  var variant$6 = {
    DEFAULT: 'default',
    QUIET: 'quiet'
  };
  var CLASSNAME$l = '_coral-Dropdown'; // used in 'auto' mode to determine if the client is on mobile.

  var IS_MOBILE_DEVICE = navigator.userAgent.match(/iPhone|iPad|iPod|Android/i) !== null;
  /**
   Extracts the value from the item in case no explicit value was provided.

   @param {HTMLElement} item
   the item whose value will be extracted.

   @returns {String} the value that will be submitted for this item.

   @private
   */

  var itemValueFromDOM$1 = function itemValueFromDOM(item) {
    var attr = item.getAttribute('value'); // checking explicitely for null allows to differenciate between non set values and empty strings

    return attr !== null ? attr : item.textContent.replace(/\s{2,}/g, ' ').trim();
  };
  /**
   Calculates the difference between two given arrays. It returns the items that are in a that are not in b.

   @param {Array.<String>} a
   @param {Array.<String>} b

   @returns {Array.<String>}
   the difference between the arrays.
   */


  var arrayDiff = function arrayDiff(a, b) {
    return a.filter(function (item) {
      return !b.some(function (item2) {
        return item === item2;
      });
    });
  };
  /**
   @class Coral.Select
   @classdesc A Select component is a form field that allows users to select from a list of options. If this component is
   shown on a mobile device, it will show a native select list, instead of the select list styled via Coral Spectrum.
   @htmltag coral-select
   @extends {HTMLElement}
   @extends {BaseComponent}
   @extends {BaseFormField}
   */


  var Select = Decorator( /*#__PURE__*/function (_BaseFormField) {
    _inherits(_class, _BaseFormField);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this); // Templates

      _this._elements = {};
      template$7.call(_this._elements, {
        commons: commons,
        Icon: Icon,
        i18n: i18n
      });
      var events = {
        'global:click': '_onGlobalClick',
        'global:touchstart': '_onGlobalClick',
        'coral-collection:add coral-taglist': '_onInternalEvent',
        'coral-collection:remove coral-taglist': '_onInternalEvent',
        // item events
        'coral-select-item:_valuechanged coral-select-item': '_onItemValueChange',
        'coral-select-item:_contentchanged coral-select-item': '_onItemContentChange',
        'coral-select-item:_disabledchanged coral-select-item': '_onItemDisabledChange',
        'coral-select-item:_selectedchanged coral-select-item': '_onItemSelectedChange',
        'change coral-taglist': '_onTagListChange',
        'change select': '_onNativeSelectChange',
        'click select': '_onNativeSelectClick',
        'click > ._coral-Dropdown-trigger': '_onButtonClick',
        'key:space > ._coral-Dropdown-trigger': '_onSpaceKey',
        'key:enter > ._coral-Dropdown-trigger': '_onSpaceKey',
        'key:return > ._coral-Dropdown-trigger': '_onSpaceKey',
        'key:down > ._coral-Dropdown-trigger': '_onSpaceKey'
      }; // Overlay

      var overlayId = _this._elements.overlay.id;
      events["global:capture:coral-collection:add #".concat(overlayId, " coral-selectlist")] = '_onSelectListItemAdd';
      events["global:capture:coral-collection:remove #".concat(overlayId, " coral-selectlist")] = '_onInternalEvent';
      events["global:capture:coral-selectlist:beforechange #".concat(overlayId)] = '_onSelectListBeforeChange';
      events["global:capture:coral-selectlist:change #".concat(overlayId)] = '_onSelectListChange';
      events["global:capture:coral-selectlist:scrollbottom #".concat(overlayId)] = '_onSelectListScrollBottom';
      events["global:capture:coral-overlay:close #".concat(overlayId)] = '_onOverlayToggle';
      events["global:capture:coral-overlay:open #".concat(overlayId)] = '_onOverlayToggle';
      events["global:capture:coral-overlay:positioned #".concat(overlayId)] = '_onOverlayPositioned';
      events["global:capture:coral-overlay:beforeopen #".concat(overlayId)] = '_onBeforeOpen';
      events["global:capture:coral-overlay:beforeclose #".concat(overlayId)] = '_onInternalEvent'; // Keyboard interaction

      events["global:keypress #".concat(overlayId)] = '_onOverlayKeyPress'; // TODO for some reason this disables tabbing into the select
      // events[`global:key:tab #${overlayId} coral-selectlist-item`] = '_onTabKey';
      // events[`global:key:tab+shift #${overlayId} coral-selectlist-item`] = '_onTabKey';
      // Attach events

      _this._delegateEvents(commons.extend(_this._events, events)); // Pre-define labellable element


      _this._labellableElement = _this._elements.button; // default value of inner flag to process events

      _this._bulkSelectionChange = false; // we only have AUTO mode.

      _this._useNativeInput = IS_MOBILE_DEVICE;

      _this._elements.taglist.reset = function () {// since reseting a form will call the reset on every component, we need to kill the behavior of the taglist
        // otherwise the state will not be accurate
      };

      _this._initialValues = []; // Init the collection mutation observer

      _this.items._startHandlingItems();

      return _this;
    }
    /**
     Returns the inner overlay to allow customization.
      @type {Popover}
     @readonly
     */


    _createClass(_class, [{
      key: "_setName",

      /** @ignore */
      value: function _setName(value) {
        if (this.multiple) {
          this._elements.input.name = '';

          this._elements.taglist.setAttribute('name', value);
        } else {
          this._elements.taglist.setAttribute('name', '');

          this._elements.input.name = value;
        }
      }
      /**
       @param {Boolean} [checkAvailableSpace=false]
       If <code>true</code>, the event is triggered based on the available space.
        @private
       */

    }, {
      key: "_showOptions",
      value: function _showOptions(checkAvailableSpace) {
        var _this2 = this;

        if (checkAvailableSpace) {
          // threshold in pixels
          var ITEM_SIZE_THRESHOLD = 30;
          var scrollHeight = this._elements.list.scrollHeight;
          var viewportHeight = this._elements.list.clientHeight;
          var scrollTop = this._elements.list.scrollTop; // we should not do this, but it increases performance since we do not need to find the item

          var loadIndicator = this._elements.list._elements.loadIndicator; // we remove the size of the load indicator

          if (loadIndicator && loadIndicator.parentNode) {
            var outerHeight = function outerHeight(el) {
              var height = el.offsetHeight;
              var style = getComputedStyle(el);
              height += parseInt(style.marginTop, 10) + parseInt(style.marginBottom, 10);
              return height;
            };

            scrollHeight -= outerHeight(loadIndicator);
          } // if we are not close to the bottom scroll, we cancel triggering the event


          if (scrollTop + viewportHeight < scrollHeight - ITEM_SIZE_THRESHOLD) {
            return;
          }
        } // we do not show the list with native


        if (!this._useNativeInput) {
          if (!this._elements.overlay.open) {
            // Show the overlay
            this._elements.overlay.open = true;
          } // Force overlay repositioning (remote loading)


          requestAnimationFrame(function () {
            _this2._elements.overlay._onAnimate();

            _this2._elements.overlay.reposition();
          });
        } // Trigger an event
        // @todo: maybe we should only trigger this event when the button is toggled and we have space for more items


        var event = this.trigger('coral-select:showitems', {
          // amount of items in the select
          start: this.items.length
        }); // while using native there is no need to show the loading

        if (!this._useNativeInput) {
          // if the default is prevented, we should the loading indicator
          this._elements.list.loading = event.defaultPrevented;
        } // communicate expanded state to assistive technology


        this._elements.button.setAttribute('aria-expanded', true);
      }
      /** @private */

    }, {
      key: "_hideOptions",
      value: function _hideOptions() {
        // Don't close the overlay if selection = multiple
        if (!this.multiple) {
          this._elements.overlay.open = false;
          this.trigger('coral-select:hideitems');
        } // communicate collapsed state to assistive technology


        this._elements.button.setAttribute('aria-expanded', false);
      }
      /** @ignore */

    }, {
      key: "_onGlobalClick",
      value: function _onGlobalClick(event) {
        if (!this._elements.overlay.open) {
          return;
        }

        var eventTargetWithinOverlayTarget = this._elements.button.contains(event.target);

        var eventTargetWithinItself = this._elements.overlay.contains(event.target);

        if (!eventTargetWithinOverlayTarget && !eventTargetWithinItself) {
          this._hideOptions();
        }
      }
      /** @private */

    }, {
      key: "_onSelectListItemAdd",
      value: function _onSelectListItemAdd(event) {
        // stops propagation cause the event is internal to the component
        event.stopImmediatePropagation(); // When items have been added, we are no longer loading

        this.loading = false; // Reset height

        this._elements.list.style.height = ''; // Measure actual height

        var style = window.getComputedStyle(this._elements.list);
        var height = parseInt(style.height, 10);
        var maxHeight = parseInt(style.maxHeight, 10);

        if (height < maxHeight) {
          // Make it scrollable
          this._elements.list.style.height = "".concat(height - 1, "px");
        }
      }
    }, {
      key: "_onBeforeOpen",
      value: function _onBeforeOpen(event) {
        event.stopImmediatePropagation(); // Prevent opening the overlay if select is readonly

        if (this.readOnly) {
          event.preventDefault();
        } // focus first selected or tabbable item when the list expands


        this._elements.list._resetTabTarget(true);
      }
      /** @private */

    }, {
      key: "_onInternalEvent",
      value: function _onInternalEvent(event) {
        // stops propagation cause the event is internal to the component
        event.stopImmediatePropagation();
      }
      /** @ignore */

    }, {
      key: "_onItemAdded",
      value: function _onItemAdded(item) {
        var selectListItemParent = this._elements.list;
        var selectListItem = item._selectListItem || new SelectList.Item(); // @todo: Make sure it is added at the right index.

        selectListItemParent.appendChild(selectListItem);
        selectListItem.set({
          value: item.value,
          content: {
            innerHTML: item.innerHTML
          },
          disabled: item.disabled,
          selected: item.selected,
          trackingElement: item.trackingElement
        }, true);
        var nativeOption = item._nativeOption || new Option(); // @todo: make sure it is added at the right index.

        this._elements.nativeSelect.appendChild(nativeOption); // Need to store the initially selected values in the native select so that it can be reset


        if (this._initialValues.indexOf(item.value) !== -1) {
          nativeOption.setAttribute('selected', 'selected');
        }

        nativeOption.selected = item.selected;
        nativeOption.value = item.value;
        nativeOption.disabled = item.disabled;
        nativeOption.innerHTML = item.innerHTML;

        if (this.multiple) {
          // in case it was selected before it was added
          if (item.selected) {
            this._addTagToTagList(item);
          }
        } // Make sure the input value is set to the selected item
        else if (item.selected) {
            this._elements.input.value = item.value;
          }

        item._selectListItem = selectListItem;
        item._nativeOption = nativeOption;
        selectListItem._selectItem = item;
        nativeOption._selectItem = item;
      }
      /** @private */

    }, {
      key: "_onItemRemoved",
      value: function _onItemRemoved(item) {
        if (item._selectListItem) {
          item._selectListItem.remove();

          item._selectListItem._selectItem = undefined;
          item._selectListItem = undefined;
        }

        if (item._nativeOption) {
          this._elements.nativeSelect.removeChild(item._nativeOption);

          item._nativeOption._selectItem = undefined;
          item._nativeOption = undefined;
        }

        this._removeTagFromTagList(item, true);
      }
      /** @private */

    }, {
      key: "_onItemSelected",
      value: function _onItemSelected(item) {
        // in case the component is not in the DOM or the internals have not been created we force it
        if (!item._selectListItem || !item._selectListItem.parentNode) {
          this._onItemAdded(item);
        }

        item._selectListItem.selected = true;
        item._nativeOption.selected = true;

        if (this.multiple) {
          this._addTagToTagList(item); // @todo: what happens when ALL items have been selected
          //  1. a message is disabled (i18n?)
          //  2. we don't try to open the selectlist (native behavior).

        } else {
          this._elements.input.value = item.value;
        }
      }
      /** @private */

    }, {
      key: "_onItemDeselected",
      value: function _onItemDeselected(item) {
        // in case the component is not in the DOM or the internals have not been created we force it
        if (!item._selectListItem || !item._selectListItem.parentNode) {
          this._onItemAdded(item);
        }

        item._selectListItem.selected = false;
        item._nativeOption.selected = false;

        if (this.multiple) {
          // we use the internal reference to remove the related tag from the taglist
          this._removeTagFromTagList(item);
        }
      }
      /**
       Detects when something is about to change inside the select.
        @private
       */

    }, {
      key: "_onSelectListBeforeChange",
      value: function _onSelectListBeforeChange(event) {
        // stops propagation cause the event is internal to the component
        event.stopImmediatePropagation(); // We prevent the selection to change if we're in single selection and the clicked item is already selected

        if (!this.multiple && event.detail.item.selected) {
          event.preventDefault();
          this._elements.overlay.open = false;
        }
      }
      /**
       Detects when something inside the select list changes.
        @private
       */

    }, {
      key: "_onSelectListChange",
      value: function _onSelectListChange(event) {
        // stops propagation cause the event is internal to the component
        event.stopImmediatePropagation(); // avoids triggering unnecessary changes in the selectist because selecting items programatically will trigger
        // a change event

        if (this._bulkSelectionChange) {
          return;
        }

        var oldSelection = event.detail.oldSelection || [];
        oldSelection = !Array.isArray(oldSelection) ? [oldSelection] : oldSelection;
        var selection = event.detail.selection || [];
        selection = !Array.isArray(selection) ? [selection] : selection; // if the arrays are the same, there is no point in calculating the selection changes

        if (event.detail.oldSelection !== event.detail.selection) {
          this._bulkSelectionChange = true; // we deselect first the ones that have to go

          var removedSelection = arrayDiff(oldSelection, selection);
          removedSelection.forEach(function (listItem) {
            // selectlist will report on removed items
            if (listItem._selectItem) {
              listItem._selectItem.removeAttribute('selected');
            }
          }); // we only sync the items that changed

          var newSelection = arrayDiff(selection, oldSelection);
          newSelection.forEach(function (listItem) {
            if (listItem._selectItem) {
              listItem._selectItem.setAttribute('selected', '');
            }
          });
          this._bulkSelectionChange = false; // hides the list since something was selected. if the overlay was open, it means there was user interaction so
          // the necessary events need to be triggered

          if (this._elements.overlay.open) {
            // closes and triggers the hideitems event
            this._hideOptions(); // if there is a change in the added or removed selection, we trigger a change event


            if (newSelection.length || removedSelection.length) {
              this.trigger('change');
            }
          }
        } // in case they are the same, we just need to trigger the hideitems event when appropiate, and that is when the
        // overlay was previously open
        else if (this._elements.overlay.open) {
            // closes and triggers the hideitems event
            this._hideOptions();
          }

        if (!this.multiple) {
          this._trackEvent('change', 'coral-select-item', event, this.selectedItem);
        }
      }
      /** @private */

    }, {
      key: "_onTagListChange",
      value: function _onTagListChange(event) {
        // cancels the change event from the taglist
        event.stopImmediatePropagation(); // avoids triggering unnecessary changes in the selectist because selecting items programatically will trigger
        // a change event

        if (this._bulkSelectionChange) {
          return;
        }

        this._bulkSelectionChange = true;
        var values = event.target.values; // we use the selected items, because they are the only possible items that may change

        var itemValue;

        this.items._getAllSelected().forEach(function (item) {
          // we use DOM API instead of properties in case the item is not yet initialized
          itemValue = itemValueFromDOM$1(item); // if the item is inside the values array, then it has to be selected

          item[values.indexOf(itemValue) !== -1 ? 'setAttribute' : 'removeAttribute']('selected', '');
        });

        this._bulkSelectionChange = false; // if the taglist is empty, we should return the focus to the button

        if (!values.length) {
          this._elements.button.focus();
        } // reparents the change event with the select as the target


        this.trigger('change');
      }
      /** @private */

    }, {
      key: "_addTagToTagList",
      value: function _addTagToTagList(item) {
        // we prepare the tag
        item._tag = item._tag || new Tag();

        item._tag.set({
          value: item.value,
          label: {
            innerHTML: item.innerHTML
          }
        }, true); // we add the new tag at the end


        this._elements.taglist.items.add(item._tag);
      }
      /** @private */

    }, {
      key: "_removeTagFromTagList",
      value: function _removeTagFromTagList(item, destroy) {
        if (item._tag) {
          item._tag.remove(); // we only remove the reference if destroy is passed, this allow us to recycle the tags when possible


          item._tag = destroy ? undefined : item._tag;
        }
      }
      /** @private */

    }, {
      key: "_onSelectListScrollBottom",
      value: function _onSelectListScrollBottom(event) {
        // stops propagation cause the event is internal to the component
        event.stopImmediatePropagation();

        if (this._elements.overlay.open) {
          // Checking if the overlay is open guards against debounced scroll events being handled after an overlay has
          // already been closed (e.g. clicking the last element in a selectlist always reopened the overlay emediately
          // after closing)
          // triggers the corresponding event
          // since we got the the event from select list we need to trigger the event
          this._showOptions();
        }
      }
      /** @private */

    }, {
      key: "_onButtonClick",
      value: function _onButtonClick(event) {
        event.preventDefault();

        if (this.disabled || this.readOnly) {
          return;
        } // if native is required, we do not need to do anything


        if (!this._useNativeInput) {
          // @todo: this was removed cause otherwise the coral-select:showitems event is never triggered.
          // if this is a multiselect and all items are selected, there should be nothing in the list to focus so do
          // nothing.
          // if (this.multiple && this.selectedItems.length === this.items.length) {
          //   return;
          // }
          // Toggle openness
          if (this._elements.overlay.classList.contains('is-open')) {
            this._hideOptions();
          } else {
            // event should be triggered based on the contents
            this._showOptions(true);
          }
        }
      }
      /** @private */

    }, {
      key: "_onNativeSelectClick",
      value: function _onNativeSelectClick() {
        this._showOptions(false);
      }
    }, {
      key: "_onOverlayKeyPress",
      value: function _onOverlayKeyPress(event) {
        // Focus on item which text starts with pressed keys
        this._elements.list._onKeyPress(event);
      }
      /** @private */

    }, {
      key: "_onSpaceKey",
      value: function _onSpaceKey(event) {
        if (this.disabled || this.readOnly) {
          return;
        }

        event.preventDefault();

        if (this._useNativeInput) {
          // we try to open the native select
          this._elements.nativeSelect.dispatchEvent(new MouseEvent('mousedown'));
        } else if (!this._elements.overlay.open || event.keyCode === Keys.keyToCode('space')) {
          this._elements.button.click();
        }
      }
      /**
       Prevents tab key default handling on selectList Items.
        @private
       */
      // _onTabKey(event) {
      // event.preventDefault();
      // }

      /** @private */

    }, {
      key: "_onOverlayToggle",
      value: function _onOverlayToggle(event) {
        // stops propagation cause the event is internal to the component
        event.stopImmediatePropagation(); // Trigger private event instead

        var type = event.type.split(':').pop();
        this.trigger("coral-select:_overlay".concat(type));

        this._elements.button.classList.toggle('is-selected', event.target.open); // communicate expanded state to assistive technology


        this._elements.button.setAttribute('aria-expanded', event.target.open);

        if (!event.target.open) {
          this.classList.remove('is-openAbove', 'is-openBelow');
        }
      }
      /** @private */

    }, {
      key: "_onOverlayPositioned",
      value: function _onOverlayPositioned(event) {
        // stops propagation cause the event is internal to the component
        event.stopImmediatePropagation();

        if (this._elements.overlay.open) {
          this._elements.overlay.style.width = "".concat(this.offsetWidth, "px");
        }
      } // @todo: while the select is multiple, if everything is deselected no change event will be triggered.

    }, {
      key: "_onNativeSelectChange",
      value: function _onNativeSelectChange(event) {
        // stops propagation cause the event is internal to the component
        event.stopImmediatePropagation(); // avoids triggering unnecessary changes in the selectist because selecting items programatically will trigger
        // a change event

        if (this._bulkSelectionChange) {
          return;
        }

        this._bulkSelectionChange = true; // extracts the native options for the selected items. We use the selected options, instead of the complete
        // options to make the diff since it will normally be a smaller set

        var oldSelectedOptions = this.selectedItems.map(function (element) {
          return element._nativeOption;
        }); // we convert the HTMLCollection to an array

        var selectedOptions = Array.prototype.slice.call(event.target.querySelectorAll(':checked'));
        var diff = arrayDiff(oldSelectedOptions, selectedOptions);
        diff.forEach(function (item) {
          item._selectItem.selected = false;
        }); // we only sync the items that changed

        var newSelection = arrayDiff(selectedOptions, oldSelectedOptions);
        newSelection.forEach(function (item) {
          item._selectItem.selected = true;
        });
        this._bulkSelectionChange = false; // since multiple keeps the select open, we cannot return the focus to the button otherwise the user cannot
        // continue selecting values

        if (!this.multiple) {
          // returns the focus to the button, otherwise the select will keep it
          this._elements.button.focus(); // since selecting an item closes the native select, we need to trigger an event


          this.trigger('coral-select:hideitems');
        } // if the native change event was triggered, then it means there is some new value


        this.trigger('change');
      }
      /**
       This handles content change of coral-select-item and updates its associatives.
        @private
       */

    }, {
      key: "_onItemContentChange",
      value: function _onItemContentChange(event) {
        // stops propagation cause the event is internal to the component
        event.stopImmediatePropagation();
        var item = event.target;

        if (item._selectListItem) {
          var content = new SelectList.Item.Content();
          content.innerHTML = item.innerHTML;
          item._selectListItem.content = content;
        }

        if (item._nativeOption) {
          item._nativeOption.innerHTML = item.innerHTML;
        }

        if (item._tag && item._tag.label) {
          item._tag.label.innerHTML = item.innerHTML;
        } // since the content changed, we need to sync the placeholder in case it was the selected item


        this._syncSelectedItemPlaceholder();
      }
      /** @private */

    }, {
      key: "_syncSelectedItemPlaceholder",
      value: function _syncSelectedItemPlaceholder() {
        this.placeholder = this.getAttribute('placeholder'); // case 3: !p + !m +  se = se
        // case 5:  p + !m +  se = se

        if (this.selectedItem && !this.multiple) {
          this._elements.label.classList.remove('is-placeholder');

          this._elements.label.innerHTML = this.selectedItem.innerHTML;
        }
      }
      /**
       This handles value change of coral-select-item and updates its associatives.
        @private
       */

    }, {
      key: "_onItemValueChange",
      value: function _onItemValueChange(event) {
        // stops propagation cause the event is internal to the component
        event.stopImmediatePropagation();
        var item = event.target;

        if (item._selectListItem) {
          item._selectListItem.value = item.value;
        }

        if (item._nativeOption) {
          item._nativeOption.value = item.value;
        }

        if (item._tag) {
          item._tag.value = item.value;
        }
      }
      /**
       This handles disabled change of coral-select-item and updates its associatives.
        @private
       */

    }, {
      key: "_onItemDisabledChange",
      value: function _onItemDisabledChange(event) {
        // stops propagation cause the event is internal to the component
        event.stopImmediatePropagation();
        var item = event.target;

        if (item._selectListItem) {
          item._selectListItem.disabled = item.disabled;
        }

        if (item._nativeOption) {
          item._nativeOption.disabled = item.disabled;
        }
      }
      /**
       In case an item from the initial selection is removed, we need to remove it from the initial values.
        @private
       */

    }, {
      key: "_validateInitialState",
      value: function _validateInitialState(nodes) {
        var item;
        var index; // we iterate over all the nodes, checking if they matched the initial value

        for (var i = 0, nodeCount = nodes.length; i < nodeCount; i++) {
          // since we are not sure if the item has been upgraded, we try first the attribute, otherwise we extract the
          // value from the textContent
          item = nodes[i];
          index = this._initialValues.indexOf(item.value);

          if (index !== -1) {
            this._initialValues.splice(index, 1);
          }
        }
      }
      /** @private */
      // eslint-disable-next-line no-unused-vars

    }, {
      key: "_onCollectionChange",
      value: function _onCollectionChange(addedNodes, removedNodes) {
        // we make sure that items that were part of the initial selection are removed from the internal representation
        this._validateInitialState(removedNodes); // makes sure that the selection state matches the multiple variable


        this._setStateFromDOM();
      }
      /**
       Updates the label to reflect the current state. The label needs to be updated when the placeholder changes and
       when the selection changes.
        @private
       */

    }, {
      key: "_updateLabel",
      value: function _updateLabel() {
        this._syncSelectedItemPlaceholder();
      }
      /**
       Handles the selection state.
        @ignore
       */

    }, {
      key: "_setStateFromDOM",
      value: function _setStateFromDOM() {
        // if it is not multiple, we need to be sure only one item is selected
        if (!this.hasAttribute('multiple')) {
          // makes sure that only one is selected
          this.items._deselectAllExceptLast(); // we execute _getFirstSelected instead of _getSelected because it is faster


          var selectedItem = this.items._getFirstSelected(); // case 1. there is a selected item, so no further change is required
          // case 2. no selected item and no placeholder. an item will be automatically selected
          // case 3. no selected item and a placehoder. we just make sure the value is really empty


          if (!selectedItem) {
            // we clean the value because there is no selected item
            this._elements.input.value = ''; // when there is no placeholder, we need to force a selection to behave like the native select

            if (transform.string(this.getAttribute('placeholder')) === '') {
              // gets the first candidate for selection
              var selectable = this.items._getFirstSelectable();

              if (selectable) {
                // selects using the attribute in case the item is not yet initialized
                selectable.setAttribute('selected', ''); // we set the value explicitely, so we do not need to wait for the MO

                this._elements.input.value = itemValueFromDOM$1(selectable);
              }
            }
          } else {
            // we set the value explicitely, so we do not need to wait for the MO
            this._elements.input.value = itemValueFromDOM$1(selectedItem);
          }
        } // handles the initial item in the select


        this._updateLabel();
      }
      /**
       Handles selecting multiple items. Selection could result a single or multiple selected items.
        @private
       */

    }, {
      key: "_onItemSelectedChange",
      value: function _onItemSelectedChange(event) {
        // we stop propagation since it is a private event
        event.stopImmediatePropagation(); // the item that was selected

        var item = event.target; // setting this to true will ignore any changes from the selectlist al

        this._bulkSelectionChange = true; // when the item is selected, we need to enforce the selection mode

        if (item.selected) {
          this._onItemSelected(item);

          if (this.multiple) {
            this._trackEvent('select', 'coral-select-item', event, item);
          } // enforces the selection mode


          if (!this.hasAttribute('multiple')) {
            this.items._deselectAllExcept(item);
          }
        } else {
          this._onItemDeselected(item);

          if (this.multiple) {
            this._trackEvent('deselect', 'coral-select-item', event, item);
          }
        }

        this._bulkSelectionChange = false; // since there is a change in selection, we need to update the placeholder

        this._updateLabel();
      }
      /**
       Inherited from {@link BaseFormField#clear}.
       */

    }, {
      key: "clear",
      value: function clear() {
        this.value = '';
      }
      /**
       Focuses the component.
        @ignore
       */

    }, {
      key: "focus",
      value: function focus() {
        if (!this.contains(document.activeElement)) {
          this._elements.button.focus();
        }
      }
      /**
       Inherited from {@link BaseFormField#reset}.
       */

    }, {
      key: "reset",
      value: function reset() {
        // reset the values to the initial values
        this.values = this._initialValues;
      }
      /**
       Returns {@link Select} variants.
        @return {SelectVariantEnum}
       */

    }, {
      key: "connectedCallback",

      /** @ignore */
      value: function connectedCallback() {
        _get(_getPrototypeOf(_class.prototype), "connectedCallback", this).call(this);

        var overlay = this._elements.overlay; // Cannot be open by default when rendered

        overlay.removeAttribute('open'); // Restore in DOM

        if (overlay._parent) {
          overlay._parent.appendChild(overlay);
        }
      }
      /** @ignore */

    }, {
      key: "render",
      value: function render() {
        var _this3 = this;

        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$l); // Default reflected attributes

        if (!this._variant) {
          this.variant = variant$6.DEFAULT;
        }

        this.classList.toggle("".concat(CLASSNAME$l, "--native"), this._useNativeInput);

        if (!this._useNativeInput && this.contains(this._elements.nativeSelect)) {
          this.removeChild(this._elements.nativeSelect);
        } // handles the initial selection


        this._setStateFromDOM(); // we need to keep a state of the initial items to be able to reset the component. values is not reliable during
        // initialization since items are not yet initialized


        this.selectedItems.forEach(function (item) {
          // we use DOM API instead of properties in case the item is not yet initialized
          _this3._initialValues.push(itemValueFromDOM$1(item));
        }); // Cleanup template elements (supporting cloneNode)

        var templateElements = this.querySelectorAll('[handle]');

        for (var i = 0; i < templateElements.length; ++i) {
          var currentElement = templateElements[i];

          if (currentElement.parentNode === this) {
            this.removeChild(currentElement);
          }
        } // Render the main template


        var frag = document.createDocumentFragment();
        frag.appendChild(this._elements.button);
        frag.appendChild(this._elements.input);
        frag.appendChild(this._elements.nativeSelect);
        frag.appendChild(this._elements.taglist);
        frag.appendChild(this._elements.overlay); // Assign the button as the target for the overlay

        this._elements.overlay.target = this._elements.button; // handles the focus allocation every time the overlay closes

        this._elements.overlay.returnFocusTo(this._elements.button);

        this.appendChild(frag);
      }
      /** @ignore */

    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        _get(_getPrototypeOf(_class.prototype), "disconnectedCallback", this).call(this);

        var overlay = this._elements.overlay; // In case it was moved out don't forget to remove it

        if (!this.contains(overlay)) {
          overlay._parent = overlay._repositioned ? document.body : this;
          overlay.remove();
        }
      }
      /**
       Triggered when the {@link Select} could accept external data to be loaded by the user. If <code>preventDefault()</code> is
       called, then a loading indicator will be shown. {@link Select#loading} should be set to false to indicate
       that the data has been successfully loaded.
        @typedef {CustomEvent} coral-select:showitems
        @property {Number} detail.start
       The count of existing items, which is the index where new items should start.
       */

      /**
       Triggered when the {@link Select} hides the UI used to select items. This is typically used to cancel a load request
       because the items will not be shown anymore.
        @typedef {CustomEvent} coral-select:hideitems
       */

    }, {
      key: "overlay",
      get: function get() {
        return this._elements.overlay;
      }
      /**
       The item collection.
        @type {SelectableCollection}
       @readonly
       */

    }, {
      key: "items",
      get: function get() {
        // we do lazy initialization of the collection
        if (!this._items) {
          this._items = new SelectableCollection({
            host: this,
            itemTagName: 'coral-select-item',
            onItemAdded: this._onItemAdded,
            onItemRemoved: this._onItemRemoved,
            onCollectionChange: this._onCollectionChange
          });
        }

        return this._items;
      }
      /**
       Indicates whether the select accepts multiple selected values.
        @type {Boolean}
       @default false
       @htmlattribute multiple
       @htmlattributereflected
       */

    }, {
      key: "multiple",
      get: function get() {
        return this._multiple || false;
      },
      set: function set(value) {
        var _this4 = this;

        this._multiple = transform.booleanAttr(value);

        this._reflectAttribute('multiple', this._multiple); // taglist should not be in DOM if multiple === false


        if (!this._multiple) {
          this.removeChild(this._elements.taglist);
        } else {
          this.appendChild(this._elements.taglist);
        } // we need to remove and re-add the native select to loose the selection


        if (this._nativeInput) {
          this.removeChild(this._elements.nativeSelect);
        }

        this._elements.nativeSelect.multiple = this._multiple;
        this._elements.nativeSelect.selectedIndex = -1;

        if (this._nativeInput) {
          if (this._multiple) {
            // We might not be rendered yet
            if (this._elements.nativeSelect.parentNode) {
              this.insertBefore(this._elements.nativeSelect, this._elements.taglist);
            }
          } else {
            this.appendChild(this._elements.nativeSelect);
          }
        }

        this._elements.list.multiple = this._multiple; // sets the correct name for value submission

        this._setName(this.getAttribute('name') || ''); // we need to make sure the selection is valid


        this._setStateFromDOM(); // everytime multiple changes, the state of the selectlist and taglist need to be updated


        this.items.getAll().forEach(function (item) {
          if (_this4._multiple && item.hasAttribute('selected')) {
            _this4._addTagToTagList(item);
          } else {
            // taglist is never used for multiple = false
            _this4._removeTagFromTagList(item); // when multiple = false and the item is selected, the value needs to be updated in the input


            if (item.hasAttribute('selected')) {
              _this4._elements.input.value = itemValueFromDOM$1(item);
            }
          }
        });
      }
      /**
       Contains a hint to the user of what can be selected in the component. If no placeholder is provided, the first
       option will be displayed in the component.
        @type {String}
       @default ""
       @htmlattribute placeholder
       @htmlattributereflected
       */
      // p = placeholder, m = multiple, se = selected
      // case 1:  p +  m +  se = p
      // case 2:  p +  m + !se = p
      // case 3: !p + !m +  se = se
      // case 4: !p + !m + !se = firstSelectable (native behavior)
      // case 5:  p + !m +  se = se
      // case 6:  p + !m + !se = p
      // case 7: !p +  m +  se = 'Select'
      // case 8: !p +  m + !se = 'Select'

    }, {
      key: "placeholder",
      get: function get() {
        return this._placeholder || '';
      },
      set: function set(value) {
        this._placeholder = transform.string(value);

        this._reflectAttribute('placeholder', this._placeholder); // case 1:  p +  m +  se = p
        // case 2:  p +  m + !se = p
        // case 6:  p + !m + !se = p


        if (this._placeholder && (this.hasAttribute('multiple') || !this.selectedItem)) {
          this._elements.label.classList.add('is-placeholder');

          this._elements.label.textContent = this._placeholder;
        } // case 7: !p +  m +  se = 'Select'
        // case 8: !p +  m + !se = 'Select'
        else if (this.hasAttribute('multiple')) {
            this._elements.label.classList.add('is-placeholder');

            this._elements.label.textContent = i18n.get('Select');
          } // case 4: !p + !m + !se = firstSelectable (native behavior)
          else if (!this.selectedItem) {
              // we clean the value because there is no selected item
              this._elements.input.value = ''; // gets the first candidate for selection

              var placeholderItem = this.items._getFirstSelectable();

              this._elements.label.classList.remove('is-placeholder');

              if (placeholderItem) {
                // selects using the attribute in case the item is not yet initialized
                placeholderItem.setAttribute('selected', '');
                this._elements.label.innerHTML = placeholderItem.innerHTML;
              } else {
                // label must be cleared when there is no placeholder and no item to select
                this._elements.label.textContent = '';
              }
            }
      }
      /**
       Name used to submit the data in a form.
       @type {String}
       @default ""
       @htmlattribute name
       @htmlattributereflected
       */

    }, {
      key: "name",
      get: function get() {
        return this.multiple ? this._elements.taglist.name : this._elements.input.name;
      },
      set: function set(value) {
        this._setName(value);

        this._reflectAttribute('name', this.name);
      }
      /**
       This field's current value.
       @type {String}
       @default ""
       @htmlattribute value
       */

    }, {
      key: "value",
      get: function get() {
        // we leverage the internal elements to know the value, this way we are always sure that the server submission
        // will be correct
        return this.multiple ? this._elements.taglist.value : this._elements.input.value;
      },
      set: function set(value) {
        // we rely on the the values property to handle this correctly
        this.values = [value];
      }
      /**
       The current selected values, as submitted during form submission. When {@link Coral.Select#multiple} is
       <code>false</code>, this will be an array of length 1.
        @type {Array.<String>}
       */

    }, {
      key: "values",
      get: function get() {
        if (this.multiple) {
          return this._elements.taglist.values;
        } // if there is a selection, we return whatever value it has assigned


        return this.selectedItem ? [this._elements.input.value] : [];
      },
      set: function set(values) {
        if (Array.isArray(values)) {
          // when multiple = false, we explicitely ignore the other values and just set the first one
          if (!this.multiple && values.length > 1) {
            values = [values[0]];
          } // gets all the items


          var items = this.items.getAll();
          var itemValue; // if multiple, we need to explicitely set the selection state of every item

          if (this.multiple) {
            items.forEach(function (item) {
              // we use DOM API instead of properties in case the item is not yet initialized
              itemValue = itemValueFromDOM$1(item); // if the value is located inside the values array, then we set the item as selected

              item[values.indexOf(itemValue) !== -1 ? 'setAttribute' : 'removeAttribute']('selected', '');
            });
          } // if single selection, we find the first item that matches the value and deselect everything else. in case,
          // no item matches the value, we may need to find a selection candidate
          else {
              var targetItem; // since multiple = false, there is only 1 value value

              var value = values[0] || '';
              items.forEach(function (item) {
                // small optimization to avoid calculating the value from every item
                if (!targetItem) {
                  itemValue = itemValueFromDOM$1(item);

                  if (itemValue === value) {
                    // selecting the item will cause the taglist or input to be updated
                    item.setAttribute('selected', ''); // we store the first ocurrence, afterwards we deselect all items

                    targetItem = item; // since we found our target item, we continue to avoid removing the selected attribute

                    return;
                  }
                } // every-non targetItem must be deselected


                item.removeAttribute('selected');
              }); // if no targetItem was found, _setStateFromDOM will make sure that the state is valid

              if (!targetItem) {
                this._setStateFromDOM();
              }
            }
        }
      }
      /**
       Whether this field is disabled or not.
       @type {Boolean}
       @default false
       @htmlattribute disabled
       @htmlattributereflected
       */

    }, {
      key: "disabled",
      get: function get() {
        return this._disabled || false;
      },
      set: function set(value) {
        this._disabled = transform.booleanAttr(value);

        this._reflectAttribute('disabled', this._disabled);

        this[this._disabled ? 'setAttribute' : 'removeAttribute']('aria-disabled', this._disabled);
        this.classList.toggle('is-disabled', this._disabled);
        this._elements.button.disabled = this._disabled;
        this._elements.input.disabled = this._disabled;
        this._elements.taglist.disabled = this._disabled;
      }
      /**
       Inherited from {@link BaseFormField#invalid}.
       */

    }, {
      key: "invalid",
      get: function get() {
        return _get(_getPrototypeOf(_class.prototype), "invalid", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(_class.prototype), "invalid", value, this, true);

        this.classList.toggle('is-invalid', this.invalid);

        this._elements.button.classList.toggle('is-invalid', this.invalid);

        this._elements.invalidIcon.hidden = !this.invalid;
      }
      /**
       Whether this field is required or not.
       @type {Boolean}
       @default false
       @htmlattribute required
       @htmlattributereflected
       */

    }, {
      key: "required",
      get: function get() {
        return this._required || false;
      },
      set: function set(value) {
        this._required = transform.booleanAttr(value);

        this._reflectAttribute('required', this._required);

        this._elements.input.required = this._required;
        this._elements.taglist.required = this._required;
      }
      /**
       Whether this field is readOnly or not. Indicating that the user cannot modify the value of the control.
       @type {Boolean}
       @default false
       @htmlattribute readonly
       @htmlattributereflected
       */

    }, {
      key: "readOnly",
      get: function get() {
        return this._readOnly || false;
      },
      set: function set(value) {
        this._readOnly = transform.booleanAttr(value);

        this._reflectAttribute('readonly', this._readOnly);

        this._elements.input.readOnly = this._readOnly;
        this._elements.taglist.readOnly = this._readOnly;
        this._elements.taglist.disabled = this._readOnly;
      }
      /**
       Inherited from {@link BaseFormField#labelled}.
       */

    }, {
      key: "labelled",
      get: function get() {
        return _get(_getPrototypeOf(_class.prototype), "labelled", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(_class.prototype), "labelled", value, this, true);

        if (this.labelled) {
          if (!this.labelledBy) {
            this._elements.button.setAttribute('aria-labelledby', "".concat(this._elements.button.id, " ").concat(this._elements.label.id, " ").concat(this.invalid ? this._elements.invalidIcon.id : ''));
          }

          this._elements.nativeSelect.setAttribute('aria-label', value);
        } else {
          this._elements.button.removeAttribute('aria-label');

          this._elements.nativeSelect.removeAttribute('aria-label');

          if (!this.labelledBy) {
            this._elements.button.removeAttribute('aria-labelledby');
          }
        }

        this._elements.taglist.labelled = value;
      }
      /**
       Inherited from {@link BaseFormField#labelledBy}.
       */

    }, {
      key: "labelledBy",
      get: function get() {
        return this._labelledBy;
      },
      set: function set(value) {
        _set(_getPrototypeOf(_class.prototype), "labelledBy", value, this, true);

        this._labelledBy = _get(_getPrototypeOf(_class.prototype), "labelledBy", this);

        if (this._labelledBy) {
          this._elements.button.setAttribute('aria-labelledby', "".concat(this._labelledBy, " ").concat(this._elements.label.id, " ").concat(this.invalid ? this._elements.invalidIcon.id : ''));

          this._elements.nativeSelect.setAttribute('aria-labelledby', this._labelledBy);
        } else {
          this._elements.nativeSelect.removeAttribute('aria-labelledby'); // if the select is also labelled, make sure that aria-labelledby gets restored


          if (this.labelled) {
            this.labelled = this.labelled;
          }
        }

        this._elements.taglist.labelledBy = this._labelledBy;
      }
      /**
       Returns the first selected item in the Select. The value <code>null</code> is returned if no element is
       selected.
        @type {?HTMLElement}
       @readonly
       */

    }, {
      key: "selectedItem",
      get: function get() {
        return this.hasAttribute('multiple') ? this.items._getFirstSelected() : this.items._getLastSelected();
      }
      /**
       Returns an Array containing the set selected items.
        @type {Array.<HTMLElement>}
       @readonly
       */

    }, {
      key: "selectedItems",
      get: function get() {
        if (this.hasAttribute('multiple')) {
          return this.items._getAllSelected();
        }

        var item = this.selectedItem;
        return item ? [item] : [];
      }
      /**
       Indicates that the Select is currently loading remote data. This will set the wait indicator inside the list.
        @type {Boolean}
       @default false
       @htmlattribute loading
       */

    }, {
      key: "loading",
      get: function get() {
        return this._elements.list.loading;
      },
      set: function set(value) {
        this._elements.list.loading = value;
      }
      /**
       The Select's variant. See {@link SelectVariantEnum}.
        @type {SelectVariantEnum}
       @default SelectVariantEnum.DEFAULT
       @htmlattribute variant
       @htmlattributereflected
       */

    }, {
      key: "variant",
      get: function get() {
        return this._variant || variant$6.DEFAULT;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        this._variant = validate.enumeration(variant$6)(value) && value || variant$6.DEFAULT;

        this._reflectAttribute('variant', this._variant);

        this._elements.button.classList.toggle('_coral-FieldButton--quiet', this._variant === variant$6.QUIET);
      }
    }], [{
      key: "variant",
      get: function get() {
        return variant$6;
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['variant', 'multiple', 'placeholder', 'loading']);
      }
    }]);

    return _class;
  }(BaseFormField(BaseComponent(HTMLElement))));

  /**
   @class Coral.Select.Item
   @classdesc A Select item component
   @htmltag coral-select-item
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var SelectItem = Decorator( /*#__PURE__*/function (_BaseComponent) {
    _inherits(_class, _BaseComponent);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this);
      _this._observer = new MutationObserver(_this._handleMutation.bind(_assertThisInitialized(_this)));

      _this._observer.observe(_assertThisInitialized(_this), {
        characterData: true,
        childList: true,
        subtree: true
      });

      return _this;
    } // @compat


    _createClass(_class, [{
      key: "_handleMutation",

      /** @private */
      value: function _handleMutation() {
        this.trigger('coral-select-item:_contentchanged', {
          content: this.textContent
        });
      }
      /** @ignore */

    }, {
      key: "content",
      get: function get() {
        return this;
      },
      set: function set(value) {
        // Support configs
        if (_typeof(value) === 'object') {
          for (var prop in value) {
            /** @ignore */
            this[prop] = value[prop];
          }
        }
      }
      /**
       Whether this item is disabled. When set to <code>true</code>, this will prevent every user interaction with the
       item. If disabled is set to <code>true</code> for a selected item it will be deselected.
        @type {Boolean}
       @default false
       @htmlattribute disabled
       @htmlattributereflected
       */

    }, {
      key: "disabled",
      get: function get() {
        return this._disabled || false;
      },
      set: function set(value) {
        this._disabled = transform.booleanAttr(value);

        this._reflectAttribute('disabled', this._disabled);

        this.trigger('coral-select-item:_disabledchanged');
      }
      /**
       Whether the item is selected. Selected cannot be set to <code>true</code> if the item is disabled.
        @type {Boolean}
       @default false
       @htmlattribute selected
       @htmlattributereflected
       */

    }, {
      key: "selected",
      get: function get() {
        return this._selected || false;
      },
      set: function set(value) {
        var _selected = transform.booleanAttr(value);

        if (this._selected === _selected) {
          return;
        }

        this._selected = _selected;

        this._reflectAttribute('selected', this._selected);

        this.trigger('coral-select-item:_selectedchanged');
      }
      /**
       Value of the item. If not explicitly set, the value of <code>Node.textContent</code> is returned.
        @type {String}
       @default ""
       @htmlattribute value
       @htmlattributereflected
       */

    }, {
      key: "value",
      get: function get() {
        var val = this._value;

        if (typeof this._value === 'undefined') {
          if (this.getAttribute('value') === null) {
            // keep spaces to only 1 max and trim to mimic native select option behavior
            val = this.textContent.replace(/\s{2,}/g, ' ').trim();
          } else {
            val = this.getAttribute('value');
          }
        }

        return val;
      },
      set: function set(value) {
        var _value = transform.string(value);

        if (this._value === _value) {
          return;
        }

        this._value = _value;

        this._reflectAttribute('value', this._value);

        this.trigger('coral-select-item:_valuechanged');
      }
      /**
       Inherited from {@link BaseComponent#trackingElement}.
       */

    }, {
      key: "trackingElement",
      get: function get() {
        return typeof this._trackingElement === 'undefined' ? // keep spaces to only 1 max and trim. this mimics native html behaviors
        this.value || this.textContent.replace(/\s{2,}/g, ' ').trim() : this._trackingElement;
      },
      set: function set(value) {
        _set(_getPrototypeOf(_class.prototype), "trackingElement", value, this, true);
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['selected', 'disabled', 'value']);
      }
    }]);

    return _class;
  }(BaseComponent(HTMLElement)));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons.extend(strings, {
    'coral-component-select': translations$1
  }); // Expose component on the Coral namespace

  commons._define('coral-select-item', SelectItem);

  commons._define('coral-select', Select);

  Select.Item = SelectItem;

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var translations$6 = {
    "en-US": {
      "Select": "Select"
    },
    "fr-FR": {
      "Select": "Sélectionner"
    },
    "de-DE": {
      "Select": "Auswählen"
    },
    "it-IT": {
      "Select": "Seleziona"
    },
    "es-ES": {
      "Select": "Seleccionar"
    },
    "pt-BR": {
      "Select": "Selecionar"
    },
    "ja-JP": {
      "Select": "選択"
    },
    "ko-KR": {
      "Select": "선택"
    },
    "zh-CN": {
      "Select": "选择"
    },
    "zh-TW": {
      "Select": "選取"
    },
    "nl-NL": {
      "Select": "Selecteren"
    },
    "da-DK": {
      "Select": "Vælg"
    },
    "fi-FI": {
      "Select": "Valitse"
    },
    "nb-NO": {
      "Select": "Velg"
    },
    "sv-SE": {
      "Select": "Välj"
    },
    "cs-CZ": {
      "Select": "Vybrat"
    },
    "pl-PL": {
      "Select": "Wybierz"
    },
    "ru-RU": {
      "Select": "Выберите"
    },
    "tr-TR": {
      "Select": "Seç"
    }
  };

  var template$8 = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["input"] = document.createElement("input");
    el0.setAttribute("type", "radio");
    el0.setAttribute("handle", "input");
    el0.className += " _coral-Radio-input";
    el0.id = data_0["commons"]["getUID"]();
    frag.appendChild(el0);
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    var el2 = this["checkmark"] = document.createElement("span");
    el2.className += " _coral-Radio-button";
    el2.setAttribute("handle", "checkmark");
    frag.appendChild(el2);
    var el3 = document.createTextNode("\n");
    frag.appendChild(el3);
    var el4 = this["labelWrapper"] = document.createElement("label");
    el4.className += " _coral-Radio-label";
    el4.setAttribute("handle", "labelWrapper");
    el4.setAttribute("for", this["input"]["id"]);
    var el5 = document.createTextNode("\n  ");
    el4.appendChild(el5);
    var el6 = this["screenReaderOnly"] = document.createElement("span");
    el6.className += " u-coral-screenReaderOnly";
    el6.setAttribute("handle", "screenReaderOnly");
    el6.textContent = data_0["i18n"]["get"]('Select');
    el4.appendChild(el6);
    var el7 = document.createTextNode("\n");
    el4.appendChild(el7);
    frag.appendChild(el4);
    var el8 = document.createTextNode("\n");
    frag.appendChild(el8);
    return frag;
  };

  var CLASSNAME$m = '_coral-Radio';
  /**
   @class Coral.Radio
   @classdesc A Radio component to be used as a form field.
   @htmltag coral-radio
   @extends {HTMLElement}
   @extends {BaseComponent}
   @extends {BaseFormField}
   */

  var Radio = Decorator( /*#__PURE__*/function (_BaseFormField) {
    _inherits(_class, _BaseFormField);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this);

      _this._delegateEvents(commons.extend(_this._events, {
        click: '_onClick',
        mousedown: '_onMouseDown'
      })); // Prepare templates


      _this._elements = {
        // Try to find the label content zone
        label: _this.querySelector('coral-radio-label') || document.createElement('coral-radio-label')
      };
      template$8.call(_this._elements, {
        commons: commons,
        i18n: i18n
      }); // Pre-define labellable element

      _this._labellableElement = _this._elements.input; // Check if the label is empty whenever we get a mutation

      _this._observer = new MutationObserver(_this._hideLabelIfEmpty.bind(_assertThisInitialized(_this))); // Watch for changes to the label element's children

      _this._observer.observe(_this._elements.labelWrapper, {
        // Catch changes to childList
        childList: true,
        // Catch changes to textContent
        characterData: true,
        // Monitor any child node
        subtree: true
      });

      return _this;
    }
    /**
     Checked state for the radio, <code>true</code> is checked and <code>false</code> is unchecked.
      @type {Boolean}
     @default false
     @htmlattribute checked
     @htmlattributereflected
     @emits {change}
     */


    _createClass(_class, [{
      key: "_syncRelatedRadios",

      /**
       Takes care of keeping the checked property up to date, by unchecking every radio that has the same name. This is
       only done if the radio is already in the DOM, it has a name and it is checked, otherwise this is not needed.
        @ignore
       */
      value: function _syncRelatedRadios() {
        // if the radio has a name defined and it is checked, we need to ensure that other radios that share the name
        // are not checked.
        if (this.parentNode !== null && this.name && this.checked) {
          // queries the document for all the coral-radios with the same name
          var items = document.querySelectorAll("".concat(this.tagName, "[name=").concat(JSON.stringify(this.name), "]"));
          var itemCount = items.length;

          for (var i = 0; i < itemCount; i++) {
            if (items[i] !== this) {
              // we uncheck all other radios with the same name
              items[i].removeAttribute('checked');
            }
          }
        }
      }
      /**
       Hide the label if it's empty.
        @ignore
       */

    }, {
      key: "_hideLabelIfEmpty",
      value: function _hideLabelIfEmpty() {
        var label = this._elements.label; // If it's empty and has no non-textnode children, hide the label

        var hiddenValue = !(label.children.length === 0 && label.textContent.replace(/\s*/g, '') === ''); // Toggle the screen reader text

        this._elements.labelWrapper.style.margin = !hiddenValue ? '0' : '';
        this._elements.screenReaderOnly.hidden = hiddenValue || this.labelled;
      }
      /**
       @private
       */

    }, {
      key: "_onClick",
      value: function _onClick(event) {
        // Handle the click() just like the native radio
        if (!this.checked) {
          if (event.target === this) {
            this.checked = true;
            this.trigger('change');
          }

          this._trackEvent('checked', 'coral-radio', event);
        }
      }
      /**
       Forces radio to receive focus on mousedown
       @ignore
       */

    }, {
      key: "_onMouseDown",
      value: function _onMouseDown() {
        var target = this._elements.input;
        requestAnimationFrame(function () {
          if (target !== document.activeElement) {
            target.focus();
          }
        });
      }
      /**
       Inherited from {@link BaseFormField#clear}.
       */

    }, {
      key: "clear",
      value: function clear() {
        this.checked = false;
      }
      /**
       Inherited from {@link BaseFormField#reset}.
       */

    }, {
      key: "reset",
      value: function reset() {
        this.checked = this._initialCheckedState;
      }
    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$m); // Create a fragment

        var frag = document.createDocumentFragment();
        var templateHandleNames = ['input', 'checkmark', 'labelWrapper']; // Render the main template

        frag.appendChild(this._elements.input);
        frag.appendChild(this._elements.checkmark);
        frag.appendChild(this._elements.labelWrapper);
        var label = this._elements.label; // Remove it so we can process children

        if (label && label.parentNode) {
          label.parentNode.removeChild(label);
        }

        while (this.firstChild) {
          var child = this.firstChild;

          if (child.nodeType === Node.TEXT_NODE || child.nodeType === Node.ELEMENT_NODE && templateHandleNames.indexOf(child.getAttribute('handle')) === -1) {
            // Add non-template elements to the label
            label.appendChild(child);
          } else {
            // Remove anything else (e.g labelWrapper)
            this.removeChild(child);
          }
        } // Add the frag to the component


        this.appendChild(frag); // Assign the content zones, moving them into place in the process

        this.label = label; // Cache the initial checked state of the radio button (in order to implement reset)

        this._initialCheckedState = this.checked; // handles the case where the attached component was checked

        this._syncRelatedRadios(); // Check if we need to hide the label
        // We must do this because IE does not catch mutations when nodes are not in the DOM


        this._hideLabelIfEmpty();
      }
    }, {
      key: "checked",
      get: function get() {
        return this._checked || false;
      },
      set: function set(value) {
        this._checked = transform.booleanAttr(value);

        this._reflectAttribute('checked', this._checked);

        this._elements.input.checked = this._checked; // handles related radios

        this._syncRelatedRadios();
      }
      /**
       The radios's label element.
        @type {RadioLabel}
       @contentzone
       */

    }, {
      key: "label",
      get: function get() {
        return this._getContentZone(this._elements.label);
      },
      set: function set(value) {
        this._setContentZone('label', value, {
          handle: 'label',
          tagName: 'coral-radio-label',
          insert: function insert(label) {
            this._elements.labelWrapper.appendChild(label);
          }
        });
      }
      /**
       Name used to submit the data in a form.
       @type {String}
       @default ""
       @htmlattribute name
       @htmlattributereflected
       */

    }, {
      key: "name",
      get: function get() {
        return this._elements.input.name;
      },
      set: function set(value) {
        this._reflectAttribute('name', value);

        this._elements.input.name = value;
      }
      /**
       The value this radio should submit when checked. Changing this value will not trigger an event.
        @type {String}
       @default "on"
       @htmlattribute value
       */

    }, {
      key: "value",
      get: function get() {
        return this._elements.input.value || 'on';
      },
      set: function set(value) {
        this._elements.input.value = value;
      }
      /**
       Whether this field is disabled or not.
       @type {Boolean}
       @default false
       @htmlattribute disabled
       @htmlattributereflected
       */

    }, {
      key: "disabled",
      get: function get() {
        return this._disabled || false;
      },
      set: function set(value) {
        this._disabled = transform.booleanAttr(value);

        this._reflectAttribute('disabled', this._disabled);

        this[this._disabled ? 'setAttribute' : 'removeAttribute']('aria-disabled', this._disabled);
        this.classList.toggle('is-disabled', this._disabled);
        this._elements.input.disabled = this._disabled;
      }
      /**
       Whether this field is required or not.
       @type {Boolean}
       @default false
       @htmlattribute required
       @htmlattributereflected
       */

    }, {
      key: "required",
      get: function get() {
        return this._required || false;
      },
      set: function set(value) {
        this._required = transform.booleanAttr(value);

        this._reflectAttribute('required', this._required);

        this._elements.input.required = this._required;
      }
      /**
       Whether this field is readOnly or not. Indicating that the user cannot modify the value of the control.
       @type {Boolean}
       @default false
       @htmlattribute readonly
       @htmlattributereflected
       */

    }, {
      key: "readOnly",
      get: function get() {
        return this._readOnly || false;
      },
      set: function set(value) {
        this._readOnly = transform.booleanAttr(value);

        this._reflectAttribute('readonly', this._readOnly);

        this.classList.toggle('is-readOnly', this._readOnly);
        this._elements.input.tabIndex = this._readOnly ? -1 : 0;
      }
      /**
       Inherited from {@link BaseFormField#labelled}.
       */

    }, {
      key: "labelled",
      get: function get() {
        return _get(_getPrototypeOf(_class.prototype), "labelled", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(_class.prototype), "labelled", value, this, true);

        this._hideLabelIfEmpty();
      }
      /**
       Inherited from {@link BaseComponent#trackingElement}.
       */

    }, {
      key: "trackingElement",
      get: function get() {
        // it uses the name as the first fallback since it is not localized, otherwise it uses the label
        return typeof this._trackingElement === 'undefined' ? // keep spaces to only 1 max and trim. this mimics native html behaviors
        (this.name ? "".concat(this.name, "=").concat(this.value) : '') || (this.label || this).textContent.replace(/\s{2,}/g, ' ').trim() : this._trackingElement;
      },
      set: function set(value) {
        _set(_getPrototypeOf(_class.prototype), "trackingElement", value, this, true);
      }
      /*
       Indicates to the formField that the 'checked' property needs to be set in this component.
        @protected
       */

    }, {
      key: "_componentTargetProperty",
      get: function get() {
        return 'checked';
      }
      /*
       Indicates to the formField that the 'checked' property has to be extracted from the event.
        @protected
       */

    }, {
      key: "_eventTargetProperty",
      get: function get() {
        return 'checked';
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-radio-label': 'label'
        };
      }
      /** @ignore */

    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['checked']);
      }
    }]);

    return _class;
  }(BaseFormField(BaseComponent(HTMLElement))));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Radio.Label
   @classdesc The Radio label
   @htmltag coral-radio-label
   @return {HTMLElement}
   */
  var RadioLabel = (function () {
    return document.createElement('coral-radio-label');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons.extend(strings, {
    'coral-component-radio': translations$6
  }); // Expose component on the Coral namespace

  commons._define('coral-radio', Radio);

  Radio.Label = RadioLabel;

  var CLASSNAME$n = 'coral-RadioGroup';
  /**
   Enumeration for {@link BaseFieldGroup} orientations.

   @typedef {Object} BaseFieldGroupOrientationEnum

   @property {String} HORIZONTAL
   Horizontal default orientation.
   @property {String} VERTICAL
   Vertical orientation.
   */

  var orientation = {
    HORIZONTAL: 'horizontal',
    VERTICAL: 'vertical'
  };
  /**
   @base BaseFieldGroup
   @classdesc The base element for FieldGroup components
   */

  var BaseFieldGroup = function BaseFieldGroup(superClass) {
    return /*#__PURE__*/function (_superClass) {
      _inherits(_class, _superClass);

      var _super = _createSuper(_class);

      function _class() {
        _classCallCheck(this, _class);

        return _super.apply(this, arguments);
      }

      _createClass(_class, [{
        key: "render",

        /** @ignore */
        value: function render() {
          _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

          this.classList.add(CLASSNAME$n); // a11y

          this.setAttribute('role', 'group'); // Default reflected attributes

          if (!this._orientation) {
            this.orientation = orientation.HORIZONTAL;
          }
        }
      }, {
        key: "items",

        /**
         The Collection Interface that allows interacting with the items that the component contains.
          @type {SelectableCollection}
         @readonly
         */
        get: function get() {
          // Construct the collection on first request:
          if (!this._items) {
            this._items = new SelectableCollection({
              itemTagName: this._itemTagName,
              host: this
            });
          }

          return this._items;
        }
        /**
         Orientation of the field group. See {@link BaseFieldGroupOrientationEnum}.
          @type {String}
         @default BaseFieldGroupOrientationEnum.HORIZONTAL
         @htmlattribute orientation
         @htmlattributereflected
         */

      }, {
        key: "orientation",
        get: function get() {
          return this._orientation || orientation.HORIZONTAL;
        },
        set: function set(value) {
          value = transform.string(value).toLowerCase();
          value = validate.enumeration(this.constructor.orientation)(value) && value || orientation.HORIZONTAL;

          this._reflectAttribute('orientation', value);

          if (validate.valueMustChange(this._orientation, value)) {
            this._orientation = value;
            this.classList.toggle("".concat(CLASSNAME$n, "--vertical"), value === orientation.VERTICAL);
          }
        }
        /**
         Returns the first selected field group item in the Field Group. The value <code>null</code> is returned if no item is
         selected.
          @type {HTMLElement}
         @readonly
         */

      }, {
        key: "selectedItem",
        get: function get() {
          return this.items._getFirstSelected('checked');
        }
        /** @private */

      }, {
        key: "_itemTagName",
        get: function get() {
          // Used for Collection
          return 'coral-fieldgroup-item';
        }
        /**
         Returns {@link BaseFieldGroup} orientation options.
          @return {BaseFieldGroupEnum}
         */

      }], [{
        key: "orientation",
        get: function get() {
          return orientation;
        }
        /** @ignore */

      }, {
        key: "observedAttributes",
        get: function get() {
          return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['orientation']);
        }
      }]);

      return _class;
    }(superClass);
  };

  /**
   Enumeration for {@link RadioGroup} orientations.

   @typedef {Object} RadioGroupOrientationEnum

   @property {String} HORIZONTAL
   Horizontal default orientation.
   @property {String} VERTICAL
   Vertical orientation.
   @property {String} LABELS_BELOW
   Renders labels below items.
   */

  var orientation$1 = {
    HORIZONTAL: 'horizontal',
    VERTICAL: 'vertical',
    LABELS_BELOW: 'labelsbelow'
  };
  /**
   @class Coral.RadioGroup
   @classdesc A RadioGroup component to group radio fields
   @htmltag coral-radiogroup
   @extends {HTMLElement}
   @extends {BaseComponent}
   @extends {BaseFieldGroup}
   */

  var RadioGroup = Decorator( /*#__PURE__*/function (_BaseFieldGroup) {
    _inherits(_class, _BaseFieldGroup);

    var _super = _createSuper(_class);

    function _class() {
      _classCallCheck(this, _class);

      return _super.apply(this, arguments);
    }

    _createClass(_class, [{
      key: "orientation",

      /**
       Orientation of the radio group. See {@link RadioGroupOrientationEnum}.
        @type {String}
       @default RadioGroupOrientationEnum.HORIZONTAL
       @htmlattribute orientation
       @htmlattributereflected
       */
      get: function get() {
        return _get(_getPrototypeOf(_class.prototype), "orientation", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(_class.prototype), "orientation", value, this, true);

        this.classList.toggle("coral-RadioGroup--labelsBelow", this._orientation === orientation$1.LABELS_BELOW);
      }
      /** @private */

    }, {
      key: "_itemTagName",
      get: function get() {
        // Used for Collection
        return 'coral-radio';
      }
      /**
       Returns {@link RadioGroup} orientation options.
        @return {RadioGroupEnum}
       */

    }], [{
      key: "orientation",
      get: function get() {
        return orientation$1;
      }
    }]);

    return _class;
  }(BaseFieldGroup(BaseComponent(HTMLElement))));

  /**
   * Copyright 2020 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons._define('coral-radiogroup', RadioGroup);

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var translations$7 = {
    "en-US": {
      "Decrement": "Decrement",
      "Increment": "Increment"
    },
    "fr-FR": {
      "Decrement": "Décrémenter",
      "Increment": "Incrémenter"
    },
    "de-DE": {
      "Decrement": "Reduzieren",
      "Increment": "Erhöhen"
    },
    "it-IT": {
      "Decrement": "Decrementare",
      "Increment": "Incrementare"
    },
    "es-ES": {
      "Decrement": "Reducir",
      "Increment": "Aumentar"
    },
    "pt-BR": {
      "Decrement": "Decrementar",
      "Increment": "Incrementar"
    },
    "ja-JP": {
      "Decrement": "減らす",
      "Increment": "増やす"
    },
    "ko-KR": {
      "Decrement": "감소",
      "Increment": "증가"
    },
    "zh-CN": {
      "Decrement": "减量",
      "Increment": "增量"
    },
    "zh-TW": {
      "Decrement": "減量",
      "Increment": "增量"
    },
    "nl-NL": {
      "Decrement": "Verlagen",
      "Increment": "Verhogen"
    },
    "da-DK": {
      "Decrement": "Reduktion",
      "Increment": "Dataændring"
    },
    "fi-FI": {
      "Decrement": "Vähennys",
      "Increment": "Lisäys"
    },
    "nb-NO": {
      "Decrement": "Reduser",
      "Increment": "Øk"
    },
    "sv-SE": {
      "Decrement": "Minskning",
      "Increment": "Ökning"
    },
    "cs-CZ": {
      "Decrement": "Odpočet",
      "Increment": "Přírůstek"
    },
    "pl-PL": {
      "Decrement": "Zmniejsz",
      "Increment": "Zwiększ"
    },
    "ru-RU": {
      "Decrement": "Снижение",
      "Increment": "Прирост"
    },
    "tr-TR": {
      "Decrement": "Azaltma",
      "Increment": "Artırma"
    }
  };

  var template$9 = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var data = data_0 = typeof data_0 === "undefined" ? {} : data_0;
    data = data_0;
    data.uid = data.commons.getUID();
    data_0 = data;
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    var el2 = this["input"] = document.createElement("input", "coral-textfield");
    el2.setAttribute("is", "coral-textfield");
    el2.setAttribute("handle", "input");
    el2.setAttribute("type", "number");
    el2.className += " _coral-Stepper-input";
    el2.id = data_0["uid"];
    el2.setAttribute("step", "1");
    frag.appendChild(el2);
    var el3 = document.createTextNode("\n");
    frag.appendChild(el3);
    var el4 = this["presentation"] = document.createElement("span");
    el4.className += " _coral-Stepper-buttons";
    el4.setAttribute("role", "presentation");
    el4.setAttribute("handle", "presentation");
    var el5 = document.createTextNode("\n  ");
    el4.appendChild(el5);
    var el6 = this["stepUp"] = document.createElement("button", "coral-button");
    el6.setAttribute("variant", "action");
    el6.className += " _coral-Stepper-stepUp";
    el6.setAttribute("type", "button");
    el6.setAttribute("is", "coral-button");
    el6.setAttribute("handle", "stepUp");
    el6.setAttribute("title", data_0["i18n"]["get"]('Increment'));
    el6.setAttribute("aria-label", data_0["i18n"]["get"]('Increment'));
    el6.setAttribute("tabindex", "-1");
    el6.setAttribute("aria-controls", data_0["uid"]);
    var el7 = document.createTextNode("\n    ");
    el6.appendChild(el7);
    data = data_0;
    this.stepUp.innerHTML = data.Icon._renderSVG('spectrum-css-icon-ChevronUpSmall', ['_coral-Stepper-stepUpIcon', '_coral-UIIcon-ChevronUpSmall']);
    data_0 = data;
    var el9 = document.createTextNode("\n  ");
    el6.appendChild(el9);
    el4.appendChild(el6);
    var el10 = document.createTextNode("\n  ");
    el4.appendChild(el10);
    var el11 = this["stepDown"] = document.createElement("button", "coral-button");
    el11.setAttribute("variant", "action");
    el11.className += " _coral-Stepper-stepDown";
    el11.setAttribute("type", "button");
    el11.setAttribute("is", "coral-button");
    el11.setAttribute("handle", "stepDown");
    el11.setAttribute("title", data_0["i18n"]["get"]('Decrement'));
    el11.setAttribute("aria-label", data_0["i18n"]["get"]('Decrement'));
    el11.setAttribute("tabindex", "-1");
    el11.setAttribute("aria-controls", data_0["uid"]);
    var el12 = document.createTextNode("\n    ");
    el11.appendChild(el12);
    data = data_0;
    this.stepDown.innerHTML = data.Icon._renderSVG('spectrum-css-icon-ChevronDownSmall', ['_coral-Stepper-stepDownIcon', '_coral-UIIcon-ChevronDownSmall']);
    data_0 = data;
    var el14 = document.createTextNode("\n  ");
    el11.appendChild(el14);
    el4.appendChild(el11);
    var el15 = document.createTextNode("\n  ");
    el4.appendChild(el15);
    var el16 = this["liveregion"] = document.createElement("span");
    el16.setAttribute("role", "presentation");
    el16.setAttribute("handle", "liveregion");
    el16.setAttribute("aria-live", "assertive");
    el16.setAttribute("aria-atomic", "true");
    el16.setAttribute("aria-relevant", "additions text");
    el16.className += " u-coral-screenReaderOnly";
    el16.setAttribute("hidden", "");
    el4.appendChild(el16);
    var el17 = document.createTextNode("\n");
    el4.appendChild(el17);
    frag.appendChild(el4);
    var el18 = document.createTextNode("\n");
    frag.appendChild(el18);
    return frag;
  };

  var CLASSNAME$o = '_coral-Stepper';
  var clearLiveRegionTimeout;
  var LIVEREGION_TIMEOUT_DELAY = 3000;
  var MSPOINTER_TYPE_MOUSE = 0x00000004;
  var flagTouchStart = false;
  var flagStepButtonClick = false;

  var exponentialToDecimalString = function exponentialToDecimalString(value) {
    var notation = value.toString();

    if (notation.indexOf('e') !== -1) {
      var negative = notation.indexOf('-') === 0;
      var exponent = parseInt(notation.split('-')[negative ? 2 : 1], 10);
      return value.toFixed(exponent).toString();
    }

    return value.toString();
  };

  var handleDecimalOperation = function handleDecimalOperation(operator, value1, value2) {
    var result;

    var operation = function operation(operator, value1, value2) {
      if (operator === '+') {
        return value1 + value2;
      } else if (operator === '-') {
        return value1 - value2;
      } else if (operator === '%') {
        return value1 % value2;
      }
    }; // Check if we have decimals


    if (value1 % 1 !== 0 || value2 % 1 !== 0) {
      var value1Decimal = exponentialToDecimalString(value1).split('.');
      var value2Decimal = exponentialToDecimalString(value2).split('.');
      var value1DecimalLength = value1Decimal[1] && value1Decimal[1].length || 0;
      var value2DecimalLength = value2Decimal[1] && value2Decimal[1].length || 0;
      var multiplier = Math.pow(10, Math.max(value1DecimalLength, value2DecimalLength)); // Transform the decimals to integers based on the multiplier

      value1 = Math.round(value1 * multiplier);
      value2 = Math.round(value2 * multiplier); // Perform the operation on integers values to make sure we don't get a fancy decimal value

      result = operation(operator, value1, value2); // Transform the integer result back to decimal

      result /= multiplier;
    } else {
      result = operation(operator, value1, value2);
    }

    return result;
  };
  /**
   @class Coral.NumberInput
   @classdesc A NumberInput component is a numeric control form field. It follows the ARIA specification for spinbutton.
   This means the following keys are valid for interacting with it: <code>up</code>, <code>down</code>, <code>left</code>,
   <code>right</code>, <code>pageup</code>, <code>pagedown</code>, <code>home</code>, <code>end</code> and the Mouse Wheel.
   @htmltag coral-numberinput
   @extends {HTMLElement}
   @extends {BaseComponent}
   @extends {BaseFormField}
   */


  var NumberInput = Decorator( /*#__PURE__*/function (_BaseFormField) {
    _inherits(_class, _BaseFormField);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this);

      _this._delegateEvents(commons.extend(_this._events, {
        'key:up': '_onKeyUp',
        'key:pageup': '_onKeyUp',
        'key:down': '_onKeyDown',
        'key:pagedown': '_onKeyDown',
        'key:home': '_onKeyHome',
        'key:end': '_onKeyEnd',
        'touchstart [handle=stepUp], [handle=stepDown]': '_onTouchStart',
        'pointerdown [handle=stepUp], [handle=stepDown]': '_onTouchStart',
        'MSPointerDown [handle=stepUp], [handle=stepUp]': '_onTouchStart',
        'MSPointerDown [handle=stepDown], [handle=stepDown]': '_onTouchStart',
        'click [handle=stepUp]': '_onStepUpButtonClick',
        'click [handle=stepDown]': '_onStepDownButtonClick',
        'mousewheel [handle="input"]': '_onInputMouseWheel',
        'DOMMouseScroll [handle="input"]': '_onInputMouseWheel',
        'capture:focus': '_onFocus',
        'capture:blur': '_onBlur'
      })); // Prepare templates


      _this._elements = {};
      template$9.call(_this._elements, {
        i18n: i18n,
        commons: commons,
        Icon: Icon
      }); // Pre-define labellable element

      _this._labellableElement = _this._elements.input; // Default is null

      _this._min = _this._max = null;
      return _this;
    }
    /**
     This field's current value.
     @type {String}
     @default ""
     @htmlattribute value
     */


    _createClass(_class, [{
      key: "reset",
      // overrides the behavior from BaseFormField
      value: function reset() {
        // since there is an internal value, this one handles the reset
        this._elements.input.reset();
      } // overrides the behavior from BaseFormField

    }, {
      key: "clear",
      value: function clear() {
        // since there is an internal value, this one handles the clear
        this._elements.input.clear();
      }
      /**
       Increments the value by <code>step</code>. If the current value is <code>null</code> or <code>''</code>, it is
       considered as 0. The new value will always respect the <code>min</code> and <code>max</code> values if available.
       */

    }, {
      key: "stepUp",
      value: function stepUp() {
        // uses the Number representation since it simplifies the calculations
        var value = this.valueAsNumber;

        var step = this._getActualStep();

        if (isNaN(value)) {
          this.value = this.max !== null ? Math.min(step, this.max) : step;
        } else {
          var newValue = handleDecimalOperation('+', value, step);
          this.value = this.max !== null ? Math.min(newValue, this.max) : newValue;
        }
      }
      /**
       Decrements the value by <code>step</code>. If the current value is <code>null</code> or <code>''</code>, it is
       considered as 0. The new value will always respect the <code>min</code> and <code>max</code> values if available.
       */

    }, {
      key: "stepDown",
      value: function stepDown() {
        // uses the Number representation since it simplifies the calculations
        var value = this.valueAsNumber;

        var step = this._getActualStep();

        if (isNaN(value)) {
          this.value = this.min !== null ? Math.max(-step, this.min) : -step;
        } else {
          var newValue = handleDecimalOperation('-', value, step);
          this.value = this.min !== null ? Math.max(newValue, this.min) : newValue;
        }
      }
      /**
       If the value is 'any' there is no allowed step, that means we incremenet with the default (as if the step was not
       defined).
        @returns {Number} the valid step according to the specs.
        @ignore
       */

    }, {
      key: "_getActualStep",
      value: function _getActualStep() {
        return this.step === 'any' ? 1 : this.step;
      }
      /**
       Checks if the current NumberInput is valid or not. This is done by checking that the current value is between the
       provided <code>min</code> and <code>max</code> values. This check is only performed on user interaction.
        @ignore
       */

    }, {
      key: "_validateInputValue",
      value: function _validateInputValue() {
        this.invalid = this.value !== '' && (isNaN(Number(this.value)) || this.max !== null && this.value > this.max || this.min !== null && this.value < this.min || this.step !== 'any' && handleDecimalOperation('%', Number(this.value), this._getActualStep()) !== 0);
      }
      /**
       Sets the correct state of the buttons based on <code>disabled</code>, <code>min</code>, <code>max</code> and
       <code>readOnly</code> properties.
        @ignore
       */

    }, {
      key: "_setButtonState",
      value: function _setButtonState() {
        this._elements.stepUp.disabled = this.disabled || this.max !== null && this.value >= this.max || this.readOnly;
        this._elements.stepDown.disabled = this.disabled || this.min !== null && this.value <= this.min || this.readOnly;
      }
      /**
       Triggers a change event. This is only done if the provided values are different.
        @param {String} newValue
       The new value of the component.
       @param {String} oldValue
       The old value of the component.
        @private
       */

    }, {
      key: "_triggerChange",
      value: function _triggerChange(newValue, oldValue) {
        // if the underlaying value stayed the same, there no need to trigger an event
        if (newValue !== oldValue) {
          this.trigger('change');
        }
      }
      /**
       Flags a touchstart or pointer event so that we can determine if an event originates from a touch screen interaction
       or from a mouse interaction. An event originating from a mouse interaction should shift the focus to the input,
       while an event originating from a touch interaction should not change the focus. On a touch screen, if the user
       presses the increment or decrement button, focus should not shift to the input and open the software keyboard.
        @ignore
       */

    }, {
      key: "_onTouchStart",
      value: function _onTouchStart(event) {
        if (event.type === 'touchstart' || event.pointerType !== 'mouse' && event.pointerType !== MSPOINTER_TYPE_MOUSE) {
          flagTouchStart = true;
        }
      }
      /**
       Per WAI-ARIA spinbutton design pattern, http://www.w3.org/TR/wai-aria-practices/#spinbutton, shift focus to the
       input if it does not currently have focus. We make an exception for touch devices, because a better user
       experience is for the focus to remain on an increment or decrement button without shifting focus and opening the
       soft keyboard.
        @ignore
       */

    }, {
      key: "_setFocusToInput",
      value: function _setFocusToInput() {
        if (!flagTouchStart && document.activeElement !== this._elements.input) {
          this._elements.input.focus();
        }

        flagTouchStart = false;
      }
      /**
       Handles the click on the step up button. It causes the NumberInput to step up its value and returns the focus back
       to the input. This way the clicked button does not get focus.
        @emits {change}
       @ignore
       */

    }, {
      key: "_onStepUpButtonClick",
      value: function _onStepUpButtonClick(event) {
        event.preventDefault(); // stores the old value before stepup

        var oldValue = this.value;
        flagStepButtonClick = event.type === 'click';

        this._setFocusToInput();

        this.stepUp(); // we only do this on user interaction

        this._validateInputValue(); // checks if we need to trigger a change event


        this._triggerChange(this.value, oldValue);
      }
      /**
       Handles the click on the step down button. It causes the NumberInput to step down its value and returns the focus
       back to the input. This way the clicked button does not get focus.
        @emits {change}
       @ignore
       */

    }, {
      key: "_onStepDownButtonClick",
      value: function _onStepDownButtonClick(event) {
        event.preventDefault(); // stores the old value before stepdown

        var oldValue = this.value;
        flagStepButtonClick = event.type === 'click';

        this._setFocusToInput();

        this.stepDown(); // we only do this on user interaction

        this._validateInputValue(); // checks if we need to trigger a change event


        this._triggerChange(this.value, oldValue);
      }
      /**
       Handles the home key press. If a max has been set, the value will be modified to match it, otherwise the key is
       ignored.
        @ignore
       */

    }, {
      key: "_onKeyHome",
      value: function _onKeyHome(event) {
        event.preventDefault(); // stops interaction if the numberinput is disabled or readonly

        if (this.disabled || this.readOnly) {
          return;
        } // sets the max value only if it exists


        if (this.max !== null) {
          // stores the old value before setting the max
          var oldValue = this.value; // When appropriate flagStepButtonClick will trigger a live region update.

          flagStepButtonClick = true;
          this.value = this.max; // checks if we need to trigger a change event

          this._triggerChange(this.value, oldValue);
        }

        this._setFocusToInput();
      }
      /**
       Handles the end key press. If a min has been set, the value will be modified to match it, otherwise the key is
       ignored.
        @ignore
       */

    }, {
      key: "_onKeyEnd",
      value: function _onKeyEnd(event) {
        event.preventDefault(); // stops interaction if the numberinput is disabled or readonly

        if (this.disabled || this.readOnly) {
          return;
        } // sets the min value only if it exists


        if (this.min !== null) {
          // stores the old value before setting the min
          var oldValue = this.value; // When appropriate, flagStepButtonClick will trigger a live region update.

          flagStepButtonClick = true;
          this.value = this.min; // checks if we need to trigger a change event

          this._triggerChange(this.value, oldValue);
        }

        this._setFocusToInput();
      }
      /**
       Handles the up action by steping up the NumberInput. It prevents the default action.
        @ignore
       */

    }, {
      key: "_onKeyUp",
      value: function _onKeyUp(event) {
        event.preventDefault(); // stops interaction if the numberinput is disabled or readonly

        if (this.disabled || this.readOnly) {
          return;
        }

        this._onStepUpButtonClick(event);
      }
      /**
       Handles the down action by steping down the NumberInput. It prevents the default action.
        @ignore
       */

    }, {
      key: "_onKeyDown",
      value: function _onKeyDown(event) {
        event.preventDefault(); // stops interaction if the numberinput is disabled or readonly

        if (this.disabled || this.readOnly) {
          return;
        }

        this._onStepDownButtonClick(event);
      }
      /**
       Handles the Mousewheel to increment/decrement values.
        @ignore
       */

    }, {
      key: "_onInputMouseWheel",
      value: function _onInputMouseWheel(event) {
        // stops interaction if the numberinput is disabled or readonly or is not focused (this is the case where its hovered but not focused)
        if (this.disabled || this.readOnly || this._elements.input !== document.activeElement) {
          return;
        } // else we prevent the default event like user scrolling the page and handle the mouse wheel input


        event.preventDefault(); // stores the old value to calculate the change

        var oldValue = this.value;
        var delta = Math.max(-1, Math.min(1, event.wheelDelta || -event.detail || event.deltaY));

        if (delta < 0) {
          this.stepDown();
        } else {
          this.stepUp();
        } // checks if we need to trigger a change event


        this._triggerChange(this.value, oldValue);
      }
      /**
       Overrides the method from formField to be able to add validation after the user has changed the value.
        @private
       */

    }, {
      key: "_onInputChange",
      value: function _onInputChange(event) {
        // stops the current event
        event.stopPropagation(); // we only do this on user interaction

        this._validateInputValue(); // we force the sync of the value,invalid and disabled properties


        this.value = this.value;
        this.invalid = this.invalid;
        this.disabled = this.disabled; // we always trigger a change since it came from user interaction

        this.trigger('change');
      }
      /**
       Handles focus event.
        @ignore
       */

    }, {
      key: "_onFocus",
      value: function _onFocus() {
        this.classList.add('is-focused');

        this._elements.input.classList.add('is-focused');

        this._elements.liveregion.removeAttribute('role');

        this._elements.liveregion.removeAttribute('aria-hidden');
      }
      /**
       Handles blur event.
        @ignore
       */

    }, {
      key: "_onBlur",
      value: function _onBlur() {
        this.classList.remove('is-focused');

        this._elements.input.classList.remove('is-focused'); // clear liveregion


        this._elements.liveregion.setAttribute('role', 'presentation');

        this._elements.liveregion.setAttribute('aria-hidden', true);

        this._clearLiveRegion();
      }
      /** @ignore */

    }, {
      key: "_clearLiveRegion",
      value: function _clearLiveRegion() {
        var liveregion = this._elements.liveregion;

        if (liveregion.firstChild) {
          liveregion.removeChild(liveregion.firstChild);
        }
      }
      /** @ignore */

    }, {
      key: "_updateLiveRegion",
      value: function _updateLiveRegion(value) {
        var _this2 = this;

        var textNode;
        clearTimeout(clearLiveRegionTimeout);

        this._clearLiveRegion();

        if (value && value !== '') {
          textNode = document.createTextNode(value);
          window.requestAnimationFrame(function () {
            _this2._elements.liveregion.appendChild(textNode);

            clearLiveRegionTimeout = window.setTimeout(function () {
              _this2._clearLiveRegion();
            }, LIVEREGION_TIMEOUT_DELAY);
          });
        }
      }
      /** @ignore */

    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$o); // Default reflected attributes

        if (!this._step) {
          this.step = 1;
        } // a11y


        this.setAttribute('role', 'group');

        if (this._elements.input.type === 'text') {
          this._elements.input.setAttribute('role', 'spinbutton');
        }

        var frag = document.createDocumentFragment();
        var templateHandleNames = ['presentation', 'input']; // Render main template

        frag.appendChild(this._elements.input);
        frag.appendChild(this._elements.presentation);

        while (this.firstChild) {
          var child = this.firstChild;

          if (child.nodeType === Node.TEXT_NODE || child.nodeType === Node.ELEMENT_NODE && templateHandleNames.indexOf(child.getAttribute('handle')) === -1) {
            // Add non-template elements to the frag
            frag.appendChild(child);
          } else {
            // Remove anything else
            this.removeChild(child);
          }
        }

        this.appendChild(frag);
      }
    }, {
      key: "value",
      get: function get() {
        return this._elements.input.value;
      },
      set: function set(value) {
        value = isNaN(value) ? '' : String(value); // sets the value immediately so it is picked up in form submits

        this._elements.input.value = value; // in order to keep the reset value in sync, we need to handle the "value" attribute of the inner input

        var valueAttribute = this.getAttribute('value');

        this._elements.input[valueAttribute ? 'setAttribute' : 'removeAttribute']('value', valueAttribute); // @a11y: aria-valuetext is used so that VoiceOver does not announce a percentage


        if (this.value) {
          this._elements.input.setAttribute('aria-valuenow', this.value);

          this._elements.input.setAttribute('aria-valuetext', this.value);
        } else {
          this._elements.input.removeAttribute('aria-valuenow');

          this._elements.input.removeAttribute('aria-valuetext');
        } // If the event triggering a value change is a click on a +/- button,
        // announce the new value using the live region.


        if (flagStepButtonClick || !!window.chrome) {
          this._updateLiveRegion(this.value); // Otherwise, clear the live region.

        } else {
          this._updateLiveRegion();
        }

        flagStepButtonClick = false;
        this.invalid = this.hasAttribute('invalid');
        this.disabled = this.hasAttribute('disabled');
      }
      /**
       The value returned as a Number. Value is <code>NaN</code> if conversion to Number is not possible.
        @type {Number}
       @default NaN
       */

    }, {
      key: "valueAsNumber",
      get: function get() {
        var valueAsNumber = this._valueAsNumber;

        if (typeof valueAsNumber !== 'undefined' && valueAsNumber !== null) {
          return valueAsNumber;
        }

        valueAsNumber = transform.number(this.value);

        if (valueAsNumber !== null) {
          return valueAsNumber;
        }

        return NaN;
      },
      set: function set(value) {
        this._valueAsNumber = transform.number(value);
        this.value = this._valueAsNumber;
        this.invalid = this.hasAttribute('invalid');
        this.disabled = this.hasAttribute('disabled');
      }
      /**
       The minimum value for the NumberInput. If a value below the minimum is set, the NumberInput will be marked as
       invalid but the value will be preserved. Stepping down the NumberInput via {@link Coral.NumberInput#stepDown}
       or the decrement button respects the minimum value. It reflects the <code>min</code> attribute to the DOM.
        @type {?Number}
       @default null
       @htmlattribute min
       @htmlattributereflected
       */

    }, {
      key: "min",
      get: function get() {
        return this._min;
      },
      set: function set(value) {
        value = transform.number(value);
        this._min = isNaN(value) ? null : value;

        if (this._min === null) {
          this._reflectAttribute('min', false);

          this._elements.input.removeAttribute('aria-valuemin');

          this._elements.input.removeAttribute('min');
        } else {
          this._reflectAttribute('min', this._min); // sets the min in the input so that keyboard handles this component


          this._elements.input.setAttribute('aria-valuemin', this._min);

          this._elements.input.min = this._min;
        }

        this.invalid = this.hasAttribute('invalid');
        this.disabled = this.hasAttribute('disabled');
      }
      /**
       The maximum value for the NumberInput. If a value above the maximum is set, the NumberInput will be marked as
       invalid but the value will be preserved. Stepping up the NumberInput via {@link Coral.NumberInput#stepUp} or
       the increment button respects the maximum value. It reflects the <code>max</code> attribute to the DOM.
        @type {?Number}
       @default null
       @htmlattribute max
       @htmlattributereflected
       */

    }, {
      key: "max",
      get: function get() {
        return this._max;
      },
      set: function set(value) {
        value = transform.number(value);
        this._max = isNaN(value) ? null : value;

        if (this.max === null) {
          this._reflectAttribute('max', false);

          this._elements.input.removeAttribute('aria-valuemax');

          this._elements.input.removeAttribute('max');
        } else {
          this._reflectAttribute('max', this._max); // sets the max in the input so that keyboard handles this component


          this._elements.input.setAttribute('aria-valuemax', this._max);

          this._elements.input.max = this._max;
        }

        this.invalid = this.hasAttribute('invalid');
        this.disabled = this.hasAttribute('disabled');
      }
      /**
       The amount to increment by when stepping up or down. It can be the string <code>any</code> or any positive
       floating point number. If this is not set to <code>any<code>, the control accepts only values at multiples of
       the step value greater than the minimum.
        @type {Number|String}
       @default 1
       @htmlattribute step
       @htmlattributereflected
       */

    }, {
      key: "step",
      get: function get() {
        return this._step || 1;
      },
      set: function set(value) {
        if (value !== null && (value > 0 || value === 'any')) {
          this._step = value === 'any' ? value : transform.number(value);

          this._reflectAttribute('step', this._step);

          this._elements.input.step = this._step;
        }
      }
      /**
       Name used to submit the data in a form.
       @type {String}
       @default ""
       @htmlattribute name
       @htmlattributereflected
       */

    }, {
      key: "name",
      get: function get() {
        return this._elements.input.name;
      },
      set: function set(value) {
        this._reflectAttribute('name', value);

        this._elements.input.name = value;
      }
      /**
       Whether this field is disabled or not.
       @type {Boolean}
       @default false
       @htmlattribute disabled
       @htmlattributereflected
       */

    }, {
      key: "disabled",
      get: function get() {
        return this._disabled || false;
      },
      set: function set(value) {
        this._disabled = transform.booleanAttr(value);

        this._reflectAttribute('disabled', this._disabled);

        this[this._disabled ? 'setAttribute' : 'removeAttribute']('aria-disabled', this._disabled);
        this.classList.toggle('is-disabled', this._disabled);
        this._elements.input.disabled = this._disabled;

        this._setButtonState();
      }
      /**
       Whether this field is required or not.
       @type {Boolean}
       @default false
       @htmlattribute required
       @htmlattributereflected
       */

    }, {
      key: "required",
      get: function get() {
        return this._required || false;
      },
      set: function set(value) {
        this._required = transform.booleanAttr(value);

        this._reflectAttribute('required', this._required);

        this._elements.input.required = this._required;
      }
      /**
       Whether this field is readOnly or not. Indicating that the user cannot modify the value of the control.
       @type {Boolean}
       @default false
       @htmlattribute readonly
       @htmlattributereflected
       */

    }, {
      key: "readOnly",
      get: function get() {
        return this._readOnly || false;
      },
      set: function set(value) {
        this._readOnly = transform.booleanAttr(value);

        this._reflectAttribute('readonly', this._readOnly);

        this._elements.input.readOnly = this._readOnly;

        this._setButtonState();
      }
      /**
       Inherited from {@link BaseFormField#invalid}.
       */

    }, {
      key: "invalid",
      get: function get() {
        return _get(_getPrototypeOf(_class.prototype), "invalid", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(_class.prototype), "invalid", value, this, true);

        this._elements.input.invalid = this._invalid;
      }
      /**
       Inherited from {@link BaseFormField#labelledBy}.
       */

    }, {
      key: "labelledBy",
      get: function get() {
        return _get(_getPrototypeOf(_class.prototype), "labelledBy", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(_class.prototype), "labelledBy", value, this, true); // in case the user focuses the buttons, he will still get a notion of the usage of the component


        this[this.labelledBy ? 'setAttribute' : 'removeAttribute']('aria-labelledby', this.labelledBy);
      }
      /**
       Short hint that describes the expected value of the NumberInput. It is displayed when the NumberInput is empty.
        @type {String}
       @default ""
       @htmlattribute placeholder
       @htmlattributereflected
       */

    }, {
      key: "placeholder",
      get: function get() {
        return this._elements.input.placeholder || '';
      },
      set: function set(value) {
        value = transform.string(value);

        this._reflectAttribute('placeholder', value);

        this._elements.input.placeholder = value;
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['min', 'max', 'step', 'placeholder']);
      }
    }]);

    return _class;
  }(BaseFormField(BaseComponent(HTMLElement))));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons.extend(strings, {
    'coral-component-numberinput': translations$7
  }); // Expose component on the Coral namespace

  commons._define('coral-numberinput', NumberInput);

  var template$a = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["tip"] = document.createElement("span");
    el0.className += " _coral-Tooltip-tip";
    el0.setAttribute("handle", "tip");
    frag.appendChild(el0);
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    return frag;
  };

  var arrowMap = {
    left: 'left',
    right: 'right',
    top: 'top',
    bottom: 'bottom'
  };
  var CLASSNAME$p = '_coral-Tooltip';
  var OFFSET$1 = 5;
  /**
   Enumeration for {@link Tooltip} variants.

   @typedef {Object} TooltipVariantEnum

   @property {String} DEFAULT
   A default tooltip that provides additional information.
   @property {String} INFO
   A tooltip that informs the user of non-critical information.
   @property {String} SUCCESS
   A tooltip that indicates an operation was successful.
   @property {String} ERROR
   A tooltip that indicates an error has occurred.
   @property {String} WARNING
   Not supported. Falls back to DEFAULT.
   @property {String} INSPECT
   Not supported. Falls back to DEFAULT.
   */

  var variant$7 = {
    DEFAULT: 'default',
    INFO: 'info',
    SUCCESS: 'success',
    ERROR: 'error',
    WARNING: 'warning',
    INSPECT: 'inspect'
  }; // A string of all possible variant classnames

  var ALL_VARIANT_CLASSES$5 = [];

  for (var variantName in variant$7) {
    ALL_VARIANT_CLASSES$5.push("".concat(CLASSNAME$p, "--").concat(variant$7[variantName]));
  } // A string of all position placement classnames


  var ALL_PLACEMENT_CLASSES$1 = []; // A map of lowercase directions to their corresponding classname

  var placementClassMap = {};

  for (var key$1 in Overlay.placement) {
    var direction = Overlay.placement[key$1];
    var placementClass = "".concat(CLASSNAME$p, "--").concat(arrowMap[direction]); // Store in map

    placementClassMap[direction] = placementClass; // Store in list

    ALL_PLACEMENT_CLASSES$1.push(placementClass);
  }
  /**
   @class Coral.Tooltip
   @classdesc A Tooltip component that can be attached to any element and may be displayed immediately or on hovering the
   target element.
   @htmltag coral-tooltip
   @extends {Overlay}
   */


  var Tooltip = Decorator( /*#__PURE__*/function (_ExtensibleOverlay) {
    _inherits(_class, _ExtensibleOverlay);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this); // Override defaults

      _this._lengthOffset = OFFSET$1;
      _this._overlayAnimationTime = Overlay.FADETIME;
      _this._focusOnShow = Overlay.focusOnShow.OFF; // Fetch or create the content zone element

      _this._elements = commons.extend(_this._elements, {
        content: _this.querySelector('coral-tooltip-content') || document.createElement('coral-tooltip-content')
      }); // Generate template

      template$a.call(_this._elements); // Used for events

      _this._id = commons.getUID();

      _this._delegateEvents({
        'coral-overlay:positioned': '_onPositioned',
        'coral-overlay:_animate': '_onAnimate'
      });

      return _this;
    }
    /**
     The variant of tooltip. See {@link TooltipVariantEnum}.
      @type {String}
     @default TooltipVariantEnum.DEFAULT
     @htmlattribute variant
     @htmlattributereflected
     */


    _createClass(_class, [{
      key: "_onPositioned",

      /** @ignore */
      value: function _onPositioned(event) {
        var _this$classList;

        // Set arrow placement
        (_this$classList = this.classList).remove.apply(_this$classList, ALL_PLACEMENT_CLASSES$1);

        this.classList.add(placementClassMap[event.detail.placement]);
      }
    }, {
      key: "_onAnimate",
      value: function _onAnimate() {
        // popper attribute
        var popperPlacement = this.getAttribute('x-placement'); // popper takes care of setting left, top to 0 on positioning

        if (popperPlacement === 'left') {
          this.style.left = '8px';
        } else if (popperPlacement === 'top') {
          this.style.top = '8px';
        } else if (popperPlacement === 'right') {
          this.style.left = '-8px';
        } else if (popperPlacement === 'bottom') {
          this.style.top = '-8px';
        }
      }
      /** @ignore */

    }, {
      key: "_handleFocusOut",
      value: function _handleFocusOut() {
        var _this2 = this;

        // The item that should have focus will get it on the next frame
        window.requestAnimationFrame(function () {
          var targetIsFocused = document.activeElement === _this2._getTarget();

          if (!targetIsFocused) {
            _this2._cancelShow();

            _this2.open = false;
          }
        });
      }
      /** @ignore */

    }, {
      key: "_cancelShow",
      value: function _cancelShow() {
        window.clearTimeout(this._showTimeout);
      }
      /** @ignore */

    }, {
      key: "_cancelHide",
      value: function _cancelHide() {
        window.clearTimeout(this._hideTimeout);
      }
      /** @ignore */

    }, {
      key: "_startHide",
      value: function _startHide() {
        var _this3 = this;

        if (this.delay === 0) {
          // Hide immediately
          this._handleFocusOut();
        } else {
          this._hideTimeout = window.setTimeout(function () {
            _this3._handleFocusOut();
          }, this.delay);
        }
      }
      /** @ignore */

    }, {
      key: "_addTargetListeners",
      value: function _addTargetListeners(target) {
        var _this4 = this;

        // Make sure we don't add listeners twice to the same element for this particular tooltip
        if (target["_hasTooltipListeners".concat(this._id)]) {
          return;
        }

        target["_hasTooltipListeners".concat(this._id)] = true; // Remove listeners from the old target

        if (this._oldTarget) {
          var oldTarget = this._getTarget(this._oldTarget);

          if (oldTarget) {
            this._removeTargetListeners(oldTarget);
          }
        } // Store the current target value


        this._oldTarget = target; // Use Vent to bind events on the target

        this._targetEvents = new vent(target);

        var handleEventToShow = function handleEventToShow() {
          // Don't let the tooltip hide
          _this4._cancelHide();

          if (!_this4.open) {
            _this4._cancelShow();

            if (_this4.delay === 0) {
              // Show immediately
              _this4.show();
            } else {
              _this4._showTimeout = window.setTimeout(function () {
                _this4.show();
              }, _this4.delay);
            }
          }
        };

        this._targetEvents.on("mouseenter.Tooltip".concat(this._id), handleEventToShow);

        this._targetEvents.on("focusin.Tooltip".concat(this._id), handleEventToShow);

        this._targetEvents.on("mouseenter.Tooltip".concat(this._id), this._handleOpenTooltip.bind(this));

        this._targetEvents.on("focusin.Tooltip".concat(this._id), this._handleOpenTooltip.bind(this));

        this._targetEvents.on("mouseleave.Tooltip".concat(this._id), function () {
          if (_this4.interaction === _this4.constructor.interaction.ON) {
            _this4._startHide();
          }
        });

        this._targetEvents.on("focusout.Tooltip".concat(this._id), function () {
          if (_this4.interaction === _this4.constructor.interaction.ON) {
            _this4._handleFocusOut();
          }
        });
      }
    }, {
      key: "_handleOpenTooltip",
      value: function _handleOpenTooltip() {
        var _this5 = this;

        // Don't let the tooltip hide
        this._cancelHide();

        if (!this.open) {
          this._cancelShow();

          if (this.delay === 0) {
            // Show immediately
            this.show();
          } else {
            this._showTimeout = window.setTimeout(function () {
              _this5.show();
            }, this.delay);
          }
        }
      }
      /** @ignore */

    }, {
      key: "_removeTargetListeners",
      value: function _removeTargetListeners(target) {
        // Remove listeners for this tooltip and mark that the element doesn't have them
        // Use the ID so we can support multiple tooltips on the same element
        if (this._targetEvents) {
          this._targetEvents.off(".Tooltip".concat(this._id));
        }

        target["_hasTooltipListeners".concat(this._id)] = false;
      }
    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$p); // ARIA

        this.setAttribute('role', 'tooltip'); // Let the tooltip be focusable
        // We'll marshall focus around when its focused

        this.setAttribute('tabindex', '-1'); // Default reflected attributes

        if (!this._variant) {
          this.variant = variant$7.DEFAULT;
        } // Support cloneNode


        var tip = this.querySelector('._coral-Tooltip-tip');

        if (tip) {
          tip.remove();
        }

        var content = this._elements.content; // Move the content into the content zone if none specified

        if (!content.parentNode) {
          while (this.firstChild) {
            content.appendChild(this.firstChild);
          }
        } // Append template


        this.appendChild(this._elements.tip); // Assign the content zone so the insert function will be called

        this.content = content;
      }
    }, {
      key: "variant",
      get: function get() {
        return this._variant || variant$7.DEFAULT;
      },
      set: function set(value) {
        var _this$classList2;

        value = transform.string(value).toLowerCase();
        this._variant = validate.enumeration(variant$7)(value) && value || variant$7.DEFAULT;

        this._reflectAttribute('variant', this._variant);

        (_this$classList2 = this.classList).remove.apply(_this$classList2, ALL_VARIANT_CLASSES$5);

        this.classList.add("".concat(CLASSNAME$p, "--").concat(this._variant));
      }
      /**
       The amount of time in miliseconds to wait before showing the tooltip when the target is interacted with.
        @type {Number}
       @default 500
       @htmlattribute delay
       */

    }, {
      key: "delay",
      get: function get() {
        return typeof this._delay === 'number' ? this._delay : 500;
      },
      set: function set(value) {
        this._delay = transform.number(value);
      }
      /**
       The Tooltip content element.
        @type {TooltipContent}
       @contentzone
       */

    }, {
      key: "content",
      get: function get() {
        return this._getContentZone(this._elements.content);
      },
      set: function set(value) {
        this._setContentZone('content', value, {
          handle: 'content',
          tagName: 'coral-tooltip-content',
          insert: function insert(content) {
            content.classList.add("".concat(CLASSNAME$p, "-label"));
            this.appendChild(content);
          }
        });
      }
      /**
       Inherited from {@link Overlay#open}.
       */

    }, {
      key: "open",
      get: function get() {
        return _get(_getPrototypeOf(_class.prototype), "open", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(_class.prototype), "open", value, this, true);

        if (!this.open) {
          // Stop previous show operations from happening
          this._cancelShow();
        }
      }
      /**
       Inherited from {@link Overlay#target}.
       */

    }, {
      key: "target",
      get: function get() {
        return _get(_getPrototypeOf(_class.prototype), "target", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(_class.prototype), "target", value, this, true);

        var target = this._getTarget(value);

        if (target) {
          this._elements.tip.hidden = false;

          if (this.interaction === this.constructor.interaction.ON) {
            // Add listeners to the target
            this._addTargetListeners(target);
          }
        } else {
          this._elements.tip.hidden = true;
        }
      }
      /**
       Inherited from {@link Overlay#interaction}.
       */

    }, {
      key: "interaction",
      get: function get() {
        return _get(_getPrototypeOf(_class.prototype), "interaction", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(_class.prototype), "interaction", value, this, true);

        var target = this._getTarget();

        if (target) {
          if (value === this.constructor.interaction.ON) {
            this._addTargetListeners(target);
          } else {
            this._removeTargetListeners(target);
          }
        }
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-tooltip-content': 'content'
        };
      }
      /**
       Returns {@link Tooltip} variants.
        @return {TooltipVariantEnum}
       */

    }], [{
      key: "variant",
      get: function get() {
        return variant$7;
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['variant', 'delay']);
      }
    }]);

    return _class;
  }(ExtensibleOverlay));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Tooltip.Content
   @classdesc Tooltip's content component
   @htmltag coral-tooltip-content
   @return {HTMLElement}
   */
  var TooltipContent = (function () {
    return document.createElement('coral-tooltip-content');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons._define('coral-tooltip', Tooltip);

  Tooltip.Content = TooltipContent;

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var translations$8 = {
    "en-US": {
      "Select": "Select"
    },
    "fr-FR": {
      "Select": "Sélectionner"
    },
    "de-DE": {
      "Select": "Auswählen"
    },
    "it-IT": {
      "Select": "Seleziona"
    },
    "es-ES": {
      "Select": "Seleccionar"
    },
    "pt-BR": {
      "Select": "Selecionar"
    },
    "ja-JP": {
      "Select": "選択"
    },
    "ko-KR": {
      "Select": "선택"
    },
    "zh-CN": {
      "Select": "选择"
    },
    "zh-TW": {
      "Select": "選取"
    },
    "nl-NL": {
      "Select": "Selecteren"
    },
    "da-DK": {
      "Select": "Vælg"
    },
    "fi-FI": {
      "Select": "Valitse"
    },
    "nb-NO": {
      "Select": "Velg"
    },
    "sv-SE": {
      "Select": "Välj"
    },
    "cs-CZ": {
      "Select": "Vybrat"
    },
    "pl-PL": {
      "Select": "Wybierz"
    },
    "ru-RU": {
      "Select": "Выберите"
    },
    "tr-TR": {
      "Select": "Seç"
    }
  };

  var template$b = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var data = data_0 = typeof data_0 === "undefined" ? {} : data_0;
    var el0 = this["input"] = document.createElement("input");
    el0.setAttribute("type", "checkbox");
    el0.setAttribute("handle", "input");
    el0.className += " _coral-Checkbox-input";
    el0.id = data_0["commons"]["getUID"]();
    frag.appendChild(el0);
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    var el2 = this["checkbox"] = document.createElement("span");
    el2.className += " _coral-Checkbox-box";
    el2.setAttribute("handle", "checkbox");
    var el3 = document.createTextNode("\n  ");
    el2.appendChild(el3);
    data = data_0;
    this.checkbox.innerHTML = data.Icon._renderSVG('spectrum-css-icon-CheckmarkSmall', ['_coral-Checkbox-checkmark', '_coral-UIIcon-CheckmarkSmall']);
    this.checkbox.innerHTML += data.Icon._renderSVG('spectrum-css-icon-DashSmall', ['_coral-Checkbox-partialCheckmark', '_coral-UIIcon-DashSmall']);
    data_0 = data;
    var el5 = document.createTextNode("\n");
    el2.appendChild(el5);
    frag.appendChild(el2);
    var el6 = document.createTextNode("\n");
    frag.appendChild(el6);
    var el7 = this["labelWrapper"] = document.createElement("label");
    el7.className += " _coral-Checkbox-label";
    el7.setAttribute("handle", "labelWrapper");
    el7.setAttribute("for", this["input"]["id"]);
    var el8 = document.createTextNode("\n  ");
    el7.appendChild(el8);
    var el9 = this["screenReaderOnly"] = document.createElement("span");
    el9.className += " u-coral-screenReaderOnly";
    el9.setAttribute("handle", "screenReaderOnly");
    el9.textContent = data_0["i18n"]["get"]('Select');
    el7.appendChild(el9);
    var el10 = document.createTextNode("\n");
    el7.appendChild(el10);
    frag.appendChild(el7);
    var el11 = document.createTextNode("\n");
    frag.appendChild(el11);
    return frag;
  };

  var IS_IE_OR_EDGE = navigator.userAgent.indexOf('MSIE') !== -1 || navigator.appVersion.indexOf('Trident/') > 0 || window.navigator.userAgent.indexOf('Edge') !== -1;
  var CLASSNAME$q = '_coral-Checkbox';
  /**
   @class Coral.Checkbox
   @classdesc A Checkbox component to be used as a form field.
   @htmltag coral-checkbox
   @extends {HTMLElement}
   @extends {BaseComponent}
   @extends {BaseFormField}
   */

  var Checkbox = Decorator( /*#__PURE__*/function (_BaseFormField) {
    _inherits(_class, _BaseFormField);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this); // @polyfill ie

      _this._delegateEvents(commons.extend(_this._events, {
        click: '_onClick',
        mousedown: '_onMouseDown'
      })); // Prepare templates


      _this._elements = {
        // Try to find the label content zone or create one
        label: _this.querySelector('coral-checkbox-label') || document.createElement('coral-checkbox-label')
      };
      template$b.call(_this._elements, {
        commons: commons,
        i18n: i18n,
        Icon: Icon
      }); // Pre-define labellable element

      _this._labellableElement = _this._elements.input; // Check if the label is empty whenever we get a mutation

      _this._observer = new MutationObserver(_this._hideLabelIfEmpty.bind(_assertThisInitialized(_this))); // Watch for changes to the label element's children

      _this._observer.observe(_this._elements.labelWrapper, {
        // Catch changes to childList
        childList: true,
        // Catch changes to textContent
        characterData: true,
        // Monitor any child node
        subtree: true
      });

      return _this;
    }
    /**
     Checked state for the checkbox.
      @type {Boolean}
     @default false
     @htmlattribute checked
     @htmlattributereflected
     @emits {change}
     */


    _createClass(_class, [{
      key: "_onInputChange",

      /** @private */
      value: function _onInputChange(event) {
        var _this2 = this;

        // stops the current event
        event.stopPropagation();
        /** @ignore */

        this[this._componentTargetProperty] = event.target[this._eventTargetProperty]; // resets the indeterminate state after user interaction

        this.indeterminate = false; // Explicitly re-emit the change event after the property has been set

        if (this._triggerChangeEvent) {
          // @polyfill ie/edge
          if (IS_IE_OR_EDGE) {
            // We need 1 additional frame in case the indeterminate state is set manually on change event
            window.requestAnimationFrame(function () {
              _this2.trigger('change');
            });
          } else {
            this.trigger('change');
          }
        }
      }
      /**
       @private
       @polyfill ie/edge
       */

    }, {
      key: "_onClick",
      value: function _onClick(event) {
        // Force the check/uncheck and trigger the change event since IE won't.
        if (IS_IE_OR_EDGE && this.indeterminate) {
          // Other browsers like Chrome and Firefox will trigger the change event and set indeterminate = false. So we
          // verify if indeterminate was changed and if not, we manually check/uncheck and trigger the change event.
          this.checked = !this.checked;

          this._onInputChange(event);
        } // Handle the click() just like the native checkbox
        else if (event.target === this) {
            this.indeterminate = false;
            this.checked = !this.checked;
            this.trigger('change');
          }

        this._trackEvent(this.checked ? 'checked' : 'unchecked', 'coral-checkbox', event);
      }
      /**
       Forces checkbox to receive focus on mousedown
       @ignore
       */

    }, {
      key: "_onMouseDown",
      value: function _onMouseDown() {
        var target = this._elements.input;
        window.requestAnimationFrame(function () {
          if (target !== document.activeElement) {
            target.focus();
          }
        });
      }
      /**
       Hide the label if it's empty
       @ignore
       */

    }, {
      key: "_hideLabelIfEmpty",
      value: function _hideLabelIfEmpty() {
        var label = this._elements.label; // If it's empty and has no non-textnode children, hide the label

        var hiddenValue = !(label.children.length === 0 && label.textContent.replace(/\s*/g, '') === ''); // Toggle the screen reader text

        this._elements.labelWrapper.style.margin = !hiddenValue ? '0' : '';
        this._elements.screenReaderOnly.hidden = !!hiddenValue || !!this.labelledBy || !!this.labelled;
      }
      /**
       Inherited from {@link BaseFormField#clear}.
       */

    }, {
      key: "clear",
      value: function clear() {
        this.checked = false;
      }
      /**
       Inherited from {@link BaseFormField#reset}.
       */

    }, {
      key: "reset",
      value: function reset() {
        this.checked = this._initialCheckedState;
      }
    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$q); // Create a fragment

        var frag = document.createDocumentFragment();
        var templateHandleNames = ['input', 'checkbox', 'labelWrapper']; // Render the main template

        frag.appendChild(this._elements.input);
        frag.appendChild(this._elements.checkbox);
        frag.appendChild(this._elements.labelWrapper);
        var label = this._elements.label; // Remove it so we can process children

        if (label.parentNode) {
          label.parentNode.removeChild(label);
        }

        while (this.firstChild) {
          var child = this.firstChild;

          if (child.nodeType === Node.TEXT_NODE || child.nodeType === Node.ELEMENT_NODE && templateHandleNames.indexOf(child.getAttribute('handle')) === -1) {
            // Add non-template elements to the label
            label.appendChild(child);
          } else {
            // Remove anything else (e.g labelWrapper)
            this.removeChild(child);
          }
        } // Add the frag to the component


        this.appendChild(frag); // Assign the content zones, moving them into place in the process

        this.label = label; // Cache the initial checked state of the checkbox (in order to implement reset)

        this._initialCheckedState = this.checked; // Check if we need to hide the label
        // We must do this because IE does not catch mutations when nodes are not in the DOM

        this._hideLabelIfEmpty();
      }
    }, {
      key: "checked",
      get: function get() {
        return this._checked || false;
      },
      set: function set(value) {
        this._checked = transform.booleanAttr(value);

        this._reflectAttribute('checked', this._checked);

        this._elements.input.checked = this._checked;
      }
      /**
       Indicates that the checkbox is neither on nor off.
        @type {Boolean}
       @default false
       @htmlattribute indeterminate
       @htmlattributereflected
       */

    }, {
      key: "indeterminate",
      get: function get() {
        return this._indeterminate || false;
      },
      set: function set(value) {
        this._indeterminate = transform.booleanAttr(value);

        this._reflectAttribute('indeterminate', this._indeterminate);

        this.classList.toggle('is-indeterminate', this._indeterminate);
        this._elements.input.indeterminate = this._indeterminate;

        this._elements.input[this._indeterminate ? 'setAttribute' : 'removeAttribute']('aria-checked', 'mixed');
      }
      /**
       The checkbox's label element.
        @type {CheckboxLabel}
       @contentzone
       */

    }, {
      key: "label",
      get: function get() {
        return this._getContentZone(this._elements.label);
      },
      set: function set(value) {
        this._setContentZone('label', value, {
          handle: 'label',
          tagName: 'coral-checkbox-label',
          insert: function insert(label) {
            this._elements.labelWrapper.appendChild(label);
          }
        });
      }
      /**
       Name used to submit the data in a form.
       @type {String}
       @default ""
       @htmlattribute name
       @htmlattributereflected
       */

    }, {
      key: "name",
      get: function get() {
        return this._elements.input.name;
      },
      set: function set(value) {
        this._reflectAttribute('name', value);

        this._elements.input.name = value;
      }
      /**
       The value that will be submitted when the checkbox is checked. Changing this value will not trigger an event.
        @type {String}
       @default "on"
       @htmlattribute value
       */

    }, {
      key: "value",
      get: function get() {
        return this._elements.input.value || 'on';
      },
      set: function set(value) {
        this._elements.input.value = value;
      }
      /**
       Whether this field is disabled or not.
       @type {Boolean}
       @default false
       @htmlattribute disabled
       @htmlattributereflected
       */

    }, {
      key: "disabled",
      get: function get() {
        return this._disabled || false;
      },
      set: function set(value) {
        this._disabled = transform.booleanAttr(value);

        this._reflectAttribute('disabled', this._disabled);

        this[this._disabled ? 'setAttribute' : 'removeAttribute']('aria-disabled', this._disabled);
        this.classList.toggle('is-disabled', this._disabled);
        this._elements.input.disabled = this._disabled;
      }
      /**
       Whether this field is required or not.
       @type {Boolean}
       @default false
       @htmlattribute required
       @htmlattributereflected
       */

    }, {
      key: "required",
      get: function get() {
        return this._required || false;
      },
      set: function set(value) {
        this._required = transform.booleanAttr(value);

        this._reflectAttribute('required', this._required);

        this._elements.input.required = this._required;
      }
      /**
       Whether this field is readOnly or not. Indicating that the user cannot modify the value of the control.
       @type {Boolean}
       @default false
       @htmlattribute readonly
       @htmlattributereflected
       */

    }, {
      key: "readOnly",
      get: function get() {
        return this._readOnly || false;
      },
      set: function set(value) {
        this._readOnly = transform.booleanAttr(value);

        this._reflectAttribute('readonly', this._readOnly);

        this.classList.toggle('is-readOnly', this._readOnly);
        this._elements.input.tabIndex = this._readOnly ? -1 : 0;
      }
      /**
       Inherited from {@link BaseFormField#labelled}.
       */

    }, {
      key: "labelled",
      get: function get() {
        return _get(_getPrototypeOf(_class.prototype), "labelled", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(_class.prototype), "labelled", value, this, true);

        this._hideLabelIfEmpty();
      }
      /**
       Inherited from {@link BaseFormField#labelledBy}.
       */

    }, {
      key: "labelledBy",
      get: function get() {
        return _get(_getPrototypeOf(_class.prototype), "labelledBy", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(_class.prototype), "labelledBy", value, this, true);

        this._hideLabelIfEmpty();
      }
      /**
       Inherited from {@link BaseComponent#trackingElement}.
       */

    }, {
      key: "trackingElement",
      get: function get() {
        // it uses the name as the first fallback since it is not localized, otherwise it uses the label
        return typeof this._trackingElement === 'undefined' ? // keep spaces to only 1 max and trim. this mimics native html behaviors
        (this.name ? "".concat(this.name, "=").concat(this.value) : '') || (this.label || this).textContent.replace(/\s{2,}/g, ' ').trim() : this._trackingElement;
      },
      set: function set(value) {
        _set(_getPrototypeOf(_class.prototype), "trackingElement", value, this, true);
      }
      /*
       Indicates to the formField that the 'checked' property needs to be set in this component.
        @protected
       */

    }, {
      key: "_componentTargetProperty",
      get: function get() {
        return 'checked';
      }
      /*
       Indicates to the formField that the 'checked' property has to be extracted from the event.
        @protected
       */

    }, {
      key: "_eventTargetProperty",
      get: function get() {
        return 'checked';
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-checkbox-label': 'label'
        };
      }
      /** @ignore */

    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['indeterminate', 'checked']);
      }
    }]);

    return _class;
  }(BaseFormField(BaseComponent(HTMLElement))));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Checkbox.Label
   @classdesc The Checkbox label
   @htmltag coral-checkbox-label
   @return {HTMLElement}
   */
  var CheckboxLabel = (function () {
    return document.createElement('coral-checkbox-label');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons.extend(strings, {
    'coral-component-checkbox': translations$8
  }); // Expose component on the Coral namespace

  commons._define('coral-checkbox', Checkbox);

  Checkbox.Label = CheckboxLabel;

  /**
   @class Coral.CheckboxGroup
   @classdesc A CheckboxGroup component to group checkbox fields
   @htmltag coral-checkboxgroup
   @extends {HTMLElement}
   @extends {BaseComponent}
   @extends {BaseFieldGroup}
   */

  var CheckboxGroup = Decorator( /*#__PURE__*/function (_BaseFieldGroup) {
    _inherits(_class, _BaseFieldGroup);

    var _super = _createSuper(_class);

    function _class() {
      _classCallCheck(this, _class);

      return _super.apply(this, arguments);
    }

    _createClass(_class, [{
      key: "_itemTagName",

      /** @private */
      get: function get() {
        // Used for Collection
        return 'coral-checkbox';
      }
      /**
       Returns an Array containing the selected field group items.
        @type {Array.<HTMLElement>}
       @readonly
       */

    }, {
      key: "selectedItems",
      get: function get() {
        return this.items._getAllSelected('checked');
      }
    }]);

    return _class;
  }(BaseFieldGroup(BaseComponent(HTMLElement))));

  /**
   * Copyright 2020 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons._define('coral-checkboxgroup', CheckboxGroup);

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  // todo add tests
  // Used to store DateTimeFormat
  var dateTimeFormats = {}; // Default supported format

  var DEFAULT_FORMAT = 'YYYY-MM-DD';

  var transform2digit = function transform2digit(value) {
    var s = value.toString();
    return s.length === 1 ? "0".concat(s) : s;
  }; // Default locale


  var globalLocale = document.documentElement.lang || window.navigator.language || 'en-US'; // Uses Intl.DateTimeFormat to return a formatted date string

  var formatDate = function formatDate(date, locale, options) {
    var formattedDateString = '';

    try {
      var key = "".concat(JSON.stringify(locale)).concat(JSON.stringify(options));
      var dateTimeFormat = dateTimeFormats[key]; // Use existing DateTimeFormat or create new one

      if (!dateTimeFormat) {
        dateTimeFormats[key] = new window.Intl.DateTimeFormat(locale, options);
      } // Format to string


      formattedDateString = dateTimeFormats[key].format(date);
    } catch (e) {
      console.warn(e.message);
    }

    return formattedDateString;
  };
  /**
   The DateTime API is used as fallback to {@link momentJS}.

   @param {DateTime|Date|Array<Number>|String} value
   The initial date value. If none provided, the current day is used instead.
   */


  var DateTime = /*#__PURE__*/function () {
    /**
     @see https://momentjs.com/docs/#/parsing/now/
     */
    function DateTime(value) {
      _classCallCheck(this, DateTime);

      if (value instanceof this.constructor) {
        // Copy properties
        this._locale = value._locale;
        this._value = value._value;
        this._date = value._date;
      } else {
        this._locale = globalLocale;
        this._value = value; // Support Array

        if (Array.isArray(value)) {
          this._date = value.length ? new Date(value[0], value[1] || 0, value[2] || 1) : new Date();
        } else if (typeof value === 'string') {
          var isTime = value.indexOf(':') === 2; // For time, we only need to set hours and minutes using current date

          if (isTime) {
            var time = value.split(':');
            var hours = parseInt(time[0], 10);
            var minutes = parseInt(time[1], 10);

            if (hours >= 0 && hours <= 23 && minutes >= 0 && minutes <= 59) {
              this._date = new Date();

              this._date.setHours(time[0]);

              this._date.setMinutes(time[1]);
            } else {
              this._date = new Date('Invalid Date');
            }
          } else {
            // If string is invalid, the date will be invalid too
            // "replace" fixes the one day off issue
            this._date = new Date(this._value.replace(/-/g, '/').replace(/T.+/, ''));
          }
        } else if (this._value === null) {
          this._date = new Date('Invalid Date');
        } else {
          // Create a Date instance from the value or use current day if value is missing
          this._date = this._value ? new Date(this._value) : new Date();
        }
      }
    }
    /**
     @see https://momentjs.com/docs/#/i18n/instance-locale/
     */


    _createClass(DateTime, [{
      key: "locale",
      value: function locale(value) {
        if (value) {
          this._locale = value;
        }

        return this._locale;
      }
      /**
       @see https://momentjs.com/docs/#/displaying/as-javascript-date/
       */

    }, {
      key: "toDate",
      value: function toDate() {
        return this._date;
      }
      /**
       @see https://momentjs.com/docs/#/parsing/moment-clone/
       */

    }, {
      key: "clone",
      value: function clone() {
        var clone = new this.constructor(this._value);
        clone._date = this._date;
        return clone;
      }
      /**
       @see https://momentjs.com/docs/#/displaying/format/
       */

    }, {
      key: "format",
      value: function format(_format) {
        var formattedDateString = '';

        if (!_format) {
          _format = DEFAULT_FORMAT;
        }

        if (_format === DEFAULT_FORMAT) {
          formattedDateString += this._date.getFullYear();
          formattedDateString += '-';
          formattedDateString += transform2digit(this._date.getMonth() + 1);
          formattedDateString += '-';
          formattedDateString += transform2digit(this._date.getDate());
        } else if (_format === 'MMMM YYYY') {
          formattedDateString += formatDate(this._date, this._locale, {
            month: 'long'
          });
          formattedDateString += ' ';
          formattedDateString += this._date.getFullYear();
        } else if (_format === 'LL') {
          formattedDateString += formatDate(this._date, this._locale, {
            month: 'long',
            year: 'numeric',
            day: '2-digit'
          });
        } else if (_format === 'dd') {
          formattedDateString += formatDate(this._date, this._locale, {
            weekday: 'short'
          });
        } else if (_format === 'dddd') {
          formattedDateString += formatDate(this._date, this._locale, {
            weekday: 'long'
          });
        } else if (_format === 'HH:mm') {
          formattedDateString += transform2digit(this._date.getHours());
          formattedDateString += ':';
          formattedDateString += transform2digit(this._date.getMinutes());
        } else if (_format === 'HH') {
          formattedDateString += transform2digit(this._date.getHours());
        } else if (_format === 'mm') {
          formattedDateString += transform2digit(this._date.getMinutes());
        } else if (_format === 'YYYY-MM-DD[T]HH:mmZ') {
          formattedDateString += this._date.getFullYear();
          formattedDateString += '-';
          formattedDateString += transform2digit(this._date.getMonth() + 1);
          formattedDateString += '-';
          formattedDateString += transform2digit(this._date.getDate());
          formattedDateString += 'T';
          formattedDateString += transform2digit(this._date.getHours());
          formattedDateString += ':';
          formattedDateString += transform2digit(this._date.getMinutes());
          var timezone = -1 * (this._date.getTimezoneOffset() / 60);
          var abs = Math.abs(timezone);
          abs = abs < 10 ? "0".concat(abs) : abs.toString();
          formattedDateString += timezone < 0 ? "-".concat(abs, ":00") : "+".concat(abs, ":00");
        } else {
          _format = _typeof(_format) === 'object' ? _format : {};
          formattedDateString = formatDate(this._date, this._locale, _format);
        }

        return formattedDateString;
      }
      /**
       @see https://momentjs.com/docs/#/get-set/year/
       */

    }, {
      key: "year",
      value: function year() {
        return this._date.getFullYear();
      }
      /**
       @see https://momentjs.com/docs/#/get-set/month/
       */

    }, {
      key: "month",
      value: function month() {
        return this._date.getMonth();
      }
      /**
       @see https://momentjs.com/docs/#/get-set/week/
       */

    }, {
      key: "week",
      value: function week() {
        // Source : https://stackoverflow.com/questions/6117814/get-week-of-year-in-javascript-like-in-php
        var date = new Date(Date.UTC(this._date.getFullYear(), this._date.getMonth(), this._date.getDate()));
        var dayNum = date.getUTCDay() || 7;
        date.setUTCDate(date.getUTCDate() + 4 - dayNum);
        var yearStart = new Date(Date.UTC(date.getUTCFullYear(), 0, 1));
        return Math.ceil(((date - yearStart) / 86400000 + 1) / 7);
      }
      /**
       @see https://momentjs.com/docs/#/get-set/day/
       */

    }, {
      key: "day",
      value: function day(_day) {
        if (typeof _day === 'number') {
          this._date.setDate(this._date.getDate() - (this._date.getDay() || 7) + _day);

          return this;
        }

        return this._date.getDay();
      }
      /**
       @see https://momentjs.com/docs/#/get-set/hour/
       */

    }, {
      key: "hours",
      value: function hours(_hours) {
        if (typeof _hours === 'number') {
          this._date.setHours(_hours);

          return this;
        }

        return this._date.getHours();
      }
      /**
       @see https://momentjs.com/docs/#/get-set/minute/
       */

    }, {
      key: "minutes",
      value: function minutes(_minutes) {
        if (typeof _minutes === 'number') {
          this._date.setMinutes(_minutes);

          return this;
        }

        return this._date.getMinutes();
      }
      /**
       @see https://momentjs.com/docs/#/get-set/date/
       */

    }, {
      key: "date",
      value: function date() {
        return this._date.getDate();
      }
      /**
       @see https://momentjs.com/docs/#/manipulating/add/
       */

    }, {
      key: "add",
      value: function add(value, type) {
        var multiplier = 1;

        switch (type) {
          case 'year':
          case 'years':
            multiplier = 12;

          case 'month':
          case 'months':
            var dayOfMonth = this._date.getDate();

            this._date.setMonth(this._date.getMonth() + multiplier * value);

            if (this._date.getDate() != dayOfMonth) {
              this._date.setDate(0);
            }

            break;

          case 'week':
          case 'weeks':
            multiplier = 7;

          case 'day':
          case 'days':
            this._date.setDate(this._date.getDate() + multiplier * value);

            break;
        }

        return this;
      }
      /**
       @see https://momentjs.com/docs/#/manipulating/subtract/
       */

    }, {
      key: "subtract",
      value: function subtract(value, type) {
        var multiplier = 1;

        switch (type) {
          case 'year':
          case 'years':
            multiplier = 12;

          case 'month':
          case 'months':
            var dayOfMonth = this._date.getDate();

            this._date.setMonth(this._date.getMonth() - multiplier * value);

            if (this._date.getDate() != dayOfMonth) {
              this._date.setDate(0);
            }

            break;

          case 'week':
          case 'weeks':
            multiplier = 7;

          case 'day':
          case 'days':
            this._date.setDate(this._date.getDate() - multiplier * value);

            break;
        }

        return this;
      }
      /**
       @see https://momentjs.com/docs/#/displaying/days-in-month/
      */

    }, {
      key: "daysInMonth",
      value: function daysInMonth() {
        return new Date(this._date.getFullYear(), this._date.getMonth() + 1, 0).getDate();
      }
      /**
       @see https://momentjs.com/docs/#/displaying/difference/
       */

    }, {
      key: "diff",
      value: function diff(obj) {
        var diff = this._date.getTime() - obj._date.getTime();

        var timezoneDiff = this._date.getTimezoneOffset() - obj._date.getTimezoneOffset();

        if (timezoneDiff !== 0) {
          diff -= timezoneDiff * 60000;
        }

        return diff / 86400000;
      }
      /**
       @see https://momentjs.com/docs/#/manipulating/start-of/
       */

    }, {
      key: "startOf",
      value: function startOf(value) {
        if (value === 'day') {
          // Today
          this._date = new Date(this._date.getFullYear(), this._date.getMonth(), this._date.getDate());
        } else if (value === 'month') {
          this._date = new Date(this._date.getFullYear(), this._date.getMonth(), 1);
        } else if (value === 'year') {
          this._date = new Date(new Date().getFullYear(), 0, 1);
        }

        return this;
      }
      /**
       @see https://momentjs.com/docs/#/query/is-before/
       */

    }, {
      key: "isBefore",
      value: function isBefore(coralDate, unit) {
        if (coralDate && coralDate._date) {
          return unit ? coralDate[unit]() > this[unit]() : coralDate._date > this._date;
        }

        return false;
      }
      /**
       @see https://momentjs.com/docs/#/query/is-after/
       */

    }, {
      key: "isAfter",
      value: function isAfter(coralDate, unit) {
        if (coralDate && coralDate._date) {
          return unit ? coralDate[unit]() < this[unit]() : coralDate._date < this._date;
        }

        return false;
      }
      /**
       @see https://momentjs.com/docs/#/query/is-same/
       */

    }, {
      key: "isSame",
      value: function isSame(obj, type) {
        if (type === 'hour') {
          return obj && obj.clone()._date.getHours() === this.clone()._date.getHours();
        } else if (type === 'minute') {
          return obj && obj.clone()._date.getMinutes() === this.clone()._date.getMinutes();
        } else if (type === 'day') {
          return obj && obj.clone().startOf('day')._date.getTime() === this.clone().startOf('day')._date.getTime();
        }

        return obj && obj.clone()._date.getTime() === this.clone()._date.getTime();
      }
      /**
       @see https://momentjs.com/docs/#/parsing/is-valid/
       */

    }, {
      key: "isValid",
      value: function isValid() {
        return this._date.toString() !== 'Invalid Date';
      }
      /**
       @ignore
       Not supported so we return an empty object
       */

    }], [{
      key: "localeData",
      value: function localeData() {
        return {};
      }
      /**
       @see https://momentjs.com/docs/#/i18n/changing-locale/
       */

    }, {
      key: "locale",
      value: function locale(value) {
        if (value) {
          globalLocale = value;
        }

        return globalLocale;
      }
      /**
       @see https://momentjs.com/docs/#/query/is-a-moment/
       */

    }, {
      key: "isMoment",
      value: function isMoment(obj) {
        return obj instanceof this;
      }
      /**
       @return {momentJS|DateTime}
       */

    }, {
      key: "Moment",
      get: function get() {
        return window.moment || this;
      }
    }]);

    return DateTime;
  }();

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  if (typeof window.moment !== 'undefined') {
    window.moment.locale(document.documentElement.lang || window.navigator.language || 'en');
  }

  var PAGE_UP = 33;
  var PAGE_DOWN = 34;
  var LEFT_ARROW = 37;
  var UP_ARROW = 38;
  /**
   Enumeration for {@link Accordion} variants.

   @typedef {Object} AccordionVariantEnum

   @property {String} DEFAULT
   Default look and feel.
   @property {String} QUIET
   Not supported. Falls back to DEFAULT.
   @property {String} LARGE
   Not supported. Falls back to DEFAULT.
   */

  var variant$8 = {
    DEFAULT: 'default',
    QUIET: 'quiet',
    LARGE: 'large'
  }; // the accordions's base classname

  var CLASSNAME$r = '_coral-Accordion';
  /**
   @class Coral.Accordion
   @classdesc An Accordion component consisting of multiple collapsible items.
   @htmltag coral-accordion
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var Accordion = Decorator( /*#__PURE__*/function (_BaseComponent) {
    _inherits(_class, _BaseComponent);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this); // Attach events

      _this._delegateEvents({
        'click coral-accordion-item:not([disabled]) ._coral-Accordion-itemHeader': '_onItemClick',
        'key:space ._coral-Accordion-itemHeader': '_onToggleItemKey',
        'key:return ._coral-Accordion-itemHeader': '_onToggleItemKey',
        'key:pageup ._coral-Accordion-itemHeader': '_focusPreviousItem',
        'key:left ._coral-Accordion-itemHeader': '_focusPreviousItem',
        'key:up ._coral-Accordion-itemHeader': '_focusPreviousItem',
        'key:pagedown ._coral-Accordion-itemHeader': '_focusNextItem',
        'key:right ._coral-Accordion-itemHeader': '_focusNextItem',
        'key:down ._coral-Accordion-itemHeader': '_focusNextItem',
        'key:home ._coral-Accordion-itemHeader': '_onHomeKey',
        'key:end ._coral-Accordion-itemHeader': '_onEndKey',
        'keydown ._coral-Accordion-itemHeader': '_onItemContentKeyDown',
        // private
        'coral-accordion-item:_selectedchanged': '_onItemSelectedChanged'
      }); // Used for eventing


      _this._oldSelection = []; // Init the collection mutation observer

      _this.items._startHandlingItems(true);

      return _this;
    }
    /**
     The Accordion's variant. See {@link AccordionVariantEnum}.
      @type {String}
     @default AccordionVariantEnum.DEFAULT
     @htmlattribute variant
     @htmlattributereflected
     */


    _createClass(_class, [{
      key: "_onHomeKey",

      /** @private */
      value: function _onHomeKey(event) {
        event.preventDefault();
        event.stopPropagation();

        this._focusItem(this.items._getFirstSelectable());
      }
      /** @private */

    }, {
      key: "_onEndKey",
      value: function _onEndKey(event) {
        event.preventDefault();
        event.stopPropagation();

        this._focusItem(this.items._getLastSelectable());
      }
      /**
       References:
       http://www.w3.org/WAI/PF/aria-practices/#accordion &
        Handlers for when focus is on an element inside of the panel:
       http://test.cita.illinois.edu/aria/tabpanel/tabpanel2.php
        @private
       */

    }, {
      key: "_onItemContentKeyDown",
      value: function _onItemContentKeyDown(event) {
        // Required since sometimes the value is a number
        var key = parseFloat(event.keyCode);
        var item = event.matchedTarget.parentNode;

        switch (key) {
          case UP_ARROW:
          case LEFT_ARROW:
            // Set focus on the tab button for the currently displayed tab.
            if ((event.metaKey || event.ctrlKey) && Keys.filterInputs(event)) {
              event.preventDefault();
              event.stopPropagation();

              this._focusItem(item);
            }

            break;

          case PAGE_UP:
            // Show the previous tab and set focus on its corresponding tab button. Shows the last tab in the panel if
            // current tab is the first one.
            if (event.metaKey || event.ctrlKey) {
              event.preventDefault();
              event.stopPropagation();

              var prevItem = this.items._getPreviousSelectable(item);

              this._toggleItemSelection(prevItem);

              this._focusItem(prevItem);
            }

            break;

          case PAGE_DOWN:
            // Show the next tab and set focus on its corresponding tab button. Shows the first tab in the panel if current
            // tab is the last one.
            if (event.metaKey || event.ctrlKey) {
              event.preventDefault();
              event.stopPropagation();

              var nextItem = this.items._getNextSelectable(item);

              this._toggleItemSelection(nextItem);

              this._focusItem(nextItem);
            }

            break;
        }
      }
      /** @private */

    }, {
      key: "_focusPreviousItem",
      value: function _focusPreviousItem(event) {
        event.preventDefault();
        event.stopPropagation();

        this._focusItem(this.items._getPreviousSelectable(event.target.closest('coral-accordion-item')));
      }
      /** @private */

    }, {
      key: "_focusNextItem",
      value: function _focusNextItem(event) {
        event.preventDefault();
        event.stopPropagation();

        this._focusItem(this.items._getNextSelectable(event.target.closest('coral-accordion-item')));
      }
      /** @private */

    }, {
      key: "_onItemClick",
      value: function _onItemClick(event) {
        // Clickable elements included in an item header shouldn't automatically trigger the selection of that item
        if (event.target.hasAttribute('coral-interactive') || event.target.closest('[coral-interactive]')) {
          return;
        } // The click was performed on the header so we select the item (parentNode) the selection is toggled


        var item = event.target.closest('coral-accordion-item');

        if (item) {
          event.preventDefault();
          event.stopPropagation();

          this._toggleItemSelection(item);

          this._focusItem(item);
        }
      }
      /** @private */

    }, {
      key: "_onToggleItemKey",
      value: function _onToggleItemKey(event) {
        event.preventDefault();
        event.stopPropagation();
        var item = event.target.closest('coral-accordion-item');

        this._toggleItemSelection(item);

        this._focusItem(item);
      }
      /** @private */

    }, {
      key: "_onItemSelectedChanged",
      value: function _onItemSelectedChanged(event) {
        event.stopImmediatePropagation();

        this._validateSelection(event.target);
      }
      /** @private */

    }, {
      key: "_validateSelection",
      value: function _validateSelection(item) {
        var _this2 = this;

        var selectedItems = this.selectedItems;

        if (!this.multiple) {
          // Last selected item wins if multiple selection while not allowed
          item = item || selectedItems[selectedItems.length - 1];

          if (item && item.hasAttribute('selected') && selectedItems.length > 1) {
            selectedItems.forEach(function (selectedItem) {
              if (selectedItem !== item) {
                // Don't trigger change events
                _this2._preventTriggeringEvents = true;
                selectedItem.removeAttribute('selected');
              }
            }); // We can trigger change events again

            this._preventTriggeringEvents = false;
          }
        } // set items level appropriately


        if (item && item.getAttribute('level') !== this.level) {
          item.setAttribute('level', this.level);
        }

        this._resetTabTarget();

        this._triggerChangeEvent();
      }
      /** @private */

    }, {
      key: "_triggerChangeEvent",
      value: function _triggerChangeEvent() {
        var selectedItems = this.selectedItems;
        var oldSelection = this._oldSelection;

        if (!this._preventTriggeringEvents && this._arraysAreDifferent(selectedItems, oldSelection)) {
          // We differentiate whether multiple is on or off and return an array or HTMLElement respectively
          if (this.multiple) {
            this.trigger('coral-accordion:change', {
              oldSelection: oldSelection,
              selection: selectedItems
            });
          } else {
            // Return all items if we just switched from multiple=true to multiple=false and we had >1 selected items
            this.trigger('coral-accordion:change', {
              oldSelection: oldSelection.length > 1 ? oldSelection : oldSelection[0] || null,
              selection: selectedItems[0] || null
            });
          }

          this._oldSelection = selectedItems;
        }
      }
      /** @private */

    }, {
      key: "_arraysAreDifferent",
      value: function _arraysAreDifferent(selection, oldSelection) {
        var diff = [];

        if (oldSelection.length === selection.length) {
          diff = oldSelection.filter(function (item) {
            return selection.indexOf(item) === -1;
          });
        } // since we guarantee that they are arrays, we can start by comparing their size


        return oldSelection.length !== selection.length || diff.length !== 0;
      }
      /**
       Determine what item should get focus (if any) when the user tries to tab into the accordion. This should be the
       first selected panel, or the first selectable panel otherwise. When neither is available, to Accordion cannot be
       tabbed into.
        @private
       */

    }, {
      key: "_resetTabTarget",
      value: function _resetTabTarget() {
        var _this3 = this;

        if (!this._resetTabTargetScheduled) {
          this._resetTabTargetScheduled = true;
          window.requestAnimationFrame(function () {
            _this3._resetTabTargetScheduled = false; // since hidden items cannot have focus, we need to make sure the tabTarget is not hidden

            var selectedItems = _this3.items._getAllSelected();

            _this3._tabTarget = selectedItems.length ? selectedItems[0] : _this3.items._getFirstSelectable();
          });
        }
      }
      /** @private */

    }, {
      key: "_toggleItemSelection",
      value: function _toggleItemSelection(item) {
        if (item) {
          item[item.hasAttribute('selected') ? 'removeAttribute' : 'setAttribute']('selected', '');
        }
      }
      /** @private */

    }, {
      key: "_focusItem",
      value: function _focusItem(item) {
        if (item) {
          item._elements.button.focus();
        }

        this._tabTarget = item;
      }
      /**
       Returns {@link Accordion} variants.
        @return {AccordionVariantEnum}
       */

    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        var _this4 = this;

        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$r); // Default reflected attributes

        if (!this._variant) {
          this.variant = variant$8.DEFAULT;
        } // WAI-ARIA 1.1


        this.setAttribute('role', 'region'); // Don't trigger events once connected

        this._preventTriggeringEvents = true;

        this._validateSelection();

        this._preventTriggeringEvents = false;
        this._oldSelection = this.selectedItems; // Don't trigger animations on rendering

        window.requestAnimationFrame(function () {
          _this4.classList.add("".concat(CLASSNAME$r, "--animated"));
        });
      }
      /**
       Triggered when {@link Accordion} selected item has changed.
        @typedef {CustomEvent} coral-accordion:change
        @property {AccordionItem} detail.oldSelection
       The prior selected item(s).
       @property {AccordionItem} detail.selection
       The newly selected item(s).
       */

    }, {
      key: "variant",
      get: function get() {
        return this._variant || variant$8.DEFAULT;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        this._variant = validate.enumeration(variant$8)(value) && value || variant$8.DEFAULT;

        this._reflectAttribute('variant', this._variant);
      }
      /**
       The Collection Interface that allows interacting with the items that the component contains.
        @type {Collection}
       @readonly
       */

    }, {
      key: "items",
      get: function get() {
        // just init on demand
        if (!this._items) {
          this._items = new SelectableCollection({
            host: this,
            itemTagName: 'coral-accordion-item',
            // allows accordions to be nested
            itemSelector: ':scope > coral-accordion-item',
            onlyHandleChildren: true,
            onItemAdded: this._validateSelection,
            onItemRemoved: this._validateSelection
          });
        }

        return this._items;
      }
      /**
       Indicates whether the accordion accepts multiple selected items.
       @type {Boolean}
       @default false
       @htmlattribute multiple
       @htmlattributereflected
       */

    }, {
      key: "multiple",
      get: function get() {
        return this._multiple || false;
      },
      set: function set(value) {
        this._multiple = transform.booleanAttr(value);

        this._reflectAttribute('multiple', this._multiple);

        this._validateSelection();
      }
      /**
       Returns an Array containing the set selected items.
       @type {Array.<AccordionItem>}
       @readonly
       */

    }, {
      key: "selectedItems",
      get: function get() {
        return this.items._getAllSelected();
      }
      /**
       Returns the first selected item in the Accordion. The value <code>null</code> is returned if no element is
       selected.
       @type {AccordionItem}
       @readonly
       */

    }, {
      key: "selectedItem",
      get: function get() {
        return this.items._getFirstSelected();
      }
      /**
       The heading level for Accordion items within the Accordion
        @type {Number}
       @default 3
       @htmlattribute level
       @htmlattributereflected
       */

    }, {
      key: "level",
      get: function get() {
        return this._level || 3;
      },
      set: function set(value) {
        var _this5 = this;

        value = transform.number(value);

        if (validate.valueMustChange(value, this._level) && value > 0 && value < 7) {
          this._level = value;

          this._reflectAttribute('level', this._level);

          this.items.getAll().forEach(function (item) {
            return item.setAttribute('level', _this5._level);
          });
        }
      }
      /** @private **/

    }, {
      key: "_tabTarget",
      get: function get() {
        return this.__tabTarget || null;
      },
      set: function set(value) {
        this.__tabTarget = value; // Set all but the current set _tabTarget to not be a tab target:

        this.items.getAll().forEach(function (item) {
          item._isTabTarget = item === value;
        });
      }
    }], [{
      key: "variant",
      get: function get() {
        return variant$8;
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['variant', 'multiple', 'level']);
      }
    }]);

    return _class;
  }(BaseComponent(HTMLElement)));

  var template$c = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var data = data_0 = typeof data_0 === "undefined" ? {} : data_0;
    var el0 = this["heading"] = document.createElement("h3");
    el0.setAttribute("handle", "heading");
    el0.className += " _coral-Accordion-itemHeading";
    var el1 = document.createTextNode("\n  ");
    el0.appendChild(el1);
    var el2 = this["button"] = document.createElement("button");
    el2.setAttribute("handle", "button");
    el2.className += " _coral-Accordion-itemHeader";
    el2.setAttribute("type", "button");
    el0.appendChild(el2);
    var el3 = document.createTextNode("\n  ");
    el0.appendChild(el3);
    data = data_0;
    var iconId = 'spectrum-css-icon-ChevronRightMedium';
    var classes = ['_coral-Accordion-itemIndicator', '_coral-UIIcon-ChevronRightMedium'];
    this.button.insertAdjacentHTML('afterend', data.Icon._renderSVG(iconId, classes));
    data_0 = data;
    var el5 = document.createTextNode("\n");
    el0.appendChild(el5);
    frag.appendChild(el0);
    var el6 = document.createTextNode("\n");
    frag.appendChild(el6);
    return frag;
  };

  var CLASSNAME$s = '_coral-Accordion-item';
  /**
   @class Coral.Accordion.Item
   @classdesc A Accordion item component
   @htmltag coral-accordion-item
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var AccordionItem = Decorator( /*#__PURE__*/function (_BaseComponent) {
    _inherits(_class, _BaseComponent);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this); // Prepare templates

      _this._elements = {
        // Create or fetch the content zones
        label: _this.querySelector('coral-accordion-item-label') || document.createElement('coral-accordion-item-label'),
        content: _this.querySelector('coral-accordion-item-content') || document.createElement('coral-accordion-item-content')
      };
      template$c.call(_this._elements, {
        Icon: Icon
      });
      return _this;
    }
    /**
     The label of this accordion item.
      @type {AccordionItemLabel}
     @contentzone
     */


    _createClass(_class, [{
      key: "_setAria",
      value: function _setAria(button, content) {
        button.id = button.id || commons.getUID();
        content.id = content.id || commons.getUID();
        button.setAttribute('aria-controls', content.id);
        content.setAttribute('aria-labelledby', button.id);
      }
      /**
       Handles the focus of the item.
        @ignore
       */

    }, {
      key: "focus",
      value: function focus() {
        this._elements.label.focus();
      }
    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$s); // a11y

        this.setAttribute('role', 'presentation'); // Support cloneNode

        var template = this.querySelector('._coral-Accordion-itemHeading');

        if (template) {
          template.remove();
        } // Move content into the content zone if not specified


        if (!this._elements.content.parentNode) {
          while (this.firstChild) {
            this._elements.content.appendChild(this.firstChild);
          }
        }

        this.appendChild(this._elements.heading); // Assign the content zones, moving them into place in the process

        this.label = this._elements.label;
        this.content = this._elements.content; // Defaults

        this.selected = this.selected;
      }
    }, {
      key: "label",
      get: function get() {
        return this._getContentZone(this._elements.label);
      },
      set: function set(value) {
        this._setContentZone('label', value, {
          handle: 'label',
          tagName: 'coral-accordion-item-label',
          insert: function insert(label) {
            this._setAria(this._elements.button, this._elements.content);

            this._elements.button.appendChild(label);
          }
        });
      }
      /**
       The content of this accordion item.
        @type {AccordionItemContent}
       @contentzone
       */

    }, {
      key: "content",
      get: function get() {
        return this._getContentZone(this._elements.content);
      },
      set: function set(value) {
        this._setContentZone('content', value, {
          handle: 'content',
          tagName: 'coral-accordion-item-content',
          insert: function insert(content) {
            content.classList.add("".concat(CLASSNAME$s, "Content")); // WAI-ARIA 1.1

            content.setAttribute('role', 'region');

            this._setAria(this._elements.button, content);

            this.appendChild(content);
          }
        });
      }
      /**
       Whether the item is selected. If the item has an element with the `coral-interactive` attribute and is clicked,
       then the toggling of the accordion item will not occur.
        @type {Boolean}
       @default false
       @htmlattribute selected
       @htmlattributereflected
       */

    }, {
      key: "selected",
      get: function get() {
        return this._selected || false;
      },
      set: function set(value) {
        var _this2 = this;

        var _value = transform.booleanAttr(value);

        var _selected = this.hasAttribute('disabled') ? false : _value;

        if (this._selected === _selected) {
          return;
        }

        this._selected = _selected;

        this._reflectAttribute('selected', this._selected); // Read it before applying is-open which adds additional padding


        var scrollHeight = this._elements.content.scrollHeight;
        this.classList.toggle('is-open', this._selected);

        this._elements.button.setAttribute('aria-expanded', this._selected);

        if (!this._selected) {
          this._elements.content.style.height = "".concat(scrollHeight, "px"); // We read the offset height to force a reflow, this is needed to start the transition between absolute values
          // https://blog.alexmaccaw.com/css-transitions under Redrawing
          // eslint-disable-next-line no-unused-vars

          var offsetHeight = this._elements.content.offsetHeight;
        }

        this._elements.content.style.height = this._selected ? "".concat(scrollHeight, "px") : '0';

        if (this._selected) {
          commons.transitionEnd(this._elements.content, function () {
            _this2._elements.content.style.height = '';
          });
        }

        if (!this._selected) {
          this._elements.content.setAttribute('aria-hidden', 'true');

          this._elements.content.style.visibility = 'hidden';
        } else {
          this._elements.content.setAttribute('aria-hidden', 'false');

          this._elements.content.style.visibility = 'visible';
        }

        this.trigger('coral-accordion-item:_selectedchanged');
      }
      /**
       Whether this item is disabled.
       @type {Boolean}
       @default false
       @htmlattribute disabled
       @htmlattributereflected
       */

    }, {
      key: "disabled",
      get: function get() {
        return this._disabled || false;
      },
      set: function set(value) {
        this._disabled = transform.booleanAttr(value);

        this._reflectAttribute('disabled', this._disabled);

        this.classList.toggle('is-disabled', this._disabled);

        this._elements.button[this._disabled ? 'setAttribute' : 'removeAttribute']('disabled', '');

        this.selected = this.selected;
      }
      /**
       The heading level for the Accordion item
        @type {Number}
       @default 3
       @htmlattribute level
       @htmlattributereflected
       */

    }, {
      key: "level",
      get: function get() {
        return this._level || 3;
      },
      set: function set(value) {
        value = transform.number(value); // If the value has changed,

        if (!validate.valueMustChange(value, this._level)) {
          return;
        } // and the value is greater than 0


        if (value > 0) {
          // set the value and reflect the attribute.
          this._level = value;

          this._reflectAttribute('level', this._level); // If the new value is not equal to the default,


          if (value !== 3) {
            // override the aria-level on the h3 element.
            this._elements.heading.setAttribute('aria-level', this._level);

            return;
          }
        } // If the value is the default or invalid, remove the aria-level override from the h3 element.


        this._elements.heading.removeAttribute('aria-level');
      }
      /** @private **/

    }, {
      key: "_isTabTarget",
      get: function get() {
        return this.__isTabTarget || false;
      },
      set: function set(value) {
        this.__isTabTarget = value;

        if (this.disabled) {
          this._elements.button.removeAttribute('tabindex');
        } else {
          this._elements.button.setAttribute('tabindex', this.__isTabTarget ? '0' : '-1');
        }
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-accordion-item-label': 'label',
          'coral-accordion-item-content': 'content'
        };
      }
      /** @ignore */

    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['selected', 'disabled', 'level']);
      }
    }]);

    return _class;
  }(BaseComponent(HTMLElement)));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Accordion.Item.Label
   @classdesc Accordion item's label component
   @htmltag coral-accordion-item-label
   @return {HTMLElement}
   */
  var AccordionItemLabel = (function () {
    return document.createElement('coral-accordion-item-label');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Accordion.Item.Content
   @classdesc Accordion item's content component
   @htmltag coral-accordion-item-content
   @return {HTMLElement}
   */
  var AccordionItemContent = (function () {
    return document.createElement('coral-accordion-item-content');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons._define('coral-accordion-item', AccordionItem);

  commons._define('coral-accordion', Accordion);

  Accordion.Item = AccordionItem;
  Accordion.Item.Label = AccordionItemLabel;
  Accordion.Item.Content = AccordionItemContent;

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var translations$9 = {
    "en-US": {
      "More": "More"
    },
    "de-DE": {
      "More": "Mehr"
    },
    "fr-FR": {
      "More": "Plus"
    },
    "it-IT": {
      "More": "Altro"
    },
    "ja-JP": {
      "More": "その他"
    },
    "es-ES": {
      "More": "Más"
    },
    "ko-KR": {
      "More": "자세히"
    },
    "zh-CN": {
      "More": "更多"
    },
    "zh-TW": {
      "More": "更多"
    },
    "pt-BR": {
      "More": "Mais"
    },
    "nl-NL": {
      "More": "Meer"
    },
    "da-DK": {
      "More": "Mere"
    },
    "fi-FI": {
      "More": "Lisää"
    },
    "nb-NO": {
      "More": "Mer"
    },
    "sv-SE": {
      "More": "Mer"
    },
    "cs-CZ": {
      "More": "Více"
    },
    "pl-PL": {
      "More": "Więcej"
    },
    "ru-RU": {
      "More": "Дополнительно"
    },
    "tr-TR": {
      "More": "Daha Fazla"
    }
  };

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  /** @ignore */

  function getFirstSelectableWrappedItem(wrapperItem) {
    // util method to get first selectable item inside a wrapper item
    if (!wrapperItem) {
      return null;
    }

    if (wrapperItem.hasAttribute('coral-actionbar-more')) {
      // more buttons are no 'real' actionbar items => not wrapped
      return wrapperItem;
    }

    var child = null;

    for (var i = 0; i < wrapperItem.children.length; i++) {
      child = wrapperItem.children[i]; // maybe filter even more elements? (opacity, display='none', position='absolute' ...)

      if (child.offsetParent && (child.matches(commons.FOCUSABLE_ELEMENT_SELECTOR) || child.matches('a:not([href])'))) {
        return child;
      }
    } // search at 2nd level, some elements like coral-fileupload has selectable items inside them


    for (var _i = 0; _i < wrapperItem.children.length; _i++) {
      child = wrapperItem.children[_i];

      for (var j = 0; j < child.children.length; j++) {
        var subChild = child.children[j]; // maybe filter even more elements? (opacity, display='none', position='absolute' ...)

        if (subChild.offsetParent && (subChild.matches(commons.FOCUSABLE_ELEMENT_SELECTOR) || child.matches('a:not([href])'))) {
          return subChild;
        }
      }
    }

    return null;
  }

  var CLASSNAME$t = '_coral-ActionBar';
  /**
   @class Coral.ActionBar
   @classdesc An ActionBar component containing arbitrary items. An item can either be added to the left or the right side
   of the bar. All items that do not fit into the bar are hidden but still accessible.
   @htmltag coral-actionbar
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var ActionBar = Decorator( /*#__PURE__*/function (_BaseComponent) {
    _inherits(_class, _BaseComponent);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this); // Attach events

      _this._delegateEvents({
        'key:up': '_onFocusPreviousItem',
        'key:left': '_onFocusPreviousItem',
        'key:down': '_onFocusNextItem',
        'key:right': '_onFocusNextItem',
        'global:resize': '_onResizeWindow'
      }); // Prepare templates


      _this._elements = {
        // Fetch or create the content zone elements
        primary: _this.querySelector('coral-actionbar-primary') || document.createElement('coral-actionbar-primary'),
        secondary: _this.querySelector('coral-actionbar-secondary') || document.createElement('coral-actionbar-secondary')
      }; // Reference on all items

      _this._items = _this.getElementsByTagName('coral-actionbar-item'); // Debounce wait time in milliseconds

      _this._wait = 50; // bind this._onLayout so it can be removed again

      _this._onLayout = _this._onLayout.bind(_assertThisInitialized(_this));
      _this._debounceOnLayout = _this._debounceOnLayout.bind(_assertThisInitialized(_this)); // use the smart strategy instead of re-rendering every frame

      _this._recalculateLayoutOnMutation();

      return _this;
    }
    /**
     The primary (left) container of the ActionBar.
      @type {ActionBarPrimary}
     @contentzone
     */


    _createClass(_class, [{
      key: "_recalculateLayoutOnMutation",

      /** @ignore */
      value: function _recalculateLayoutOnMutation() {
        var _this2 = this;

        // recalculate layout on dom element size change + on dom mutation
        // http://www.backalleycoder.com/2013/03/18/cross-browser-event-based-element-resize-detection/
        // relayout any time the dom changes
        this._observer = new MutationObserver(function () {
          _this2._debounceOnLayout();
        }); // Watch for changes

        this._observer.observe(this, {
          attributes: true,
          childList: true,
          characterData: true,
          subtree: true
        });
      }
      /** @ignore */

    }, {
      key: "_onFocusPreviousItem",
      value: function _onFocusPreviousItem(event) {
        // stops the page from scrolling
        event.preventDefault();

        var previousItem = this._getPreviousSelectableWrappedItem(event.target);

        if (previousItem !== null) {
          previousItem.focus();
        }
      }
      /** @ignore */

    }, {
      key: "_onFocusNextItem",
      value: function _onFocusNextItem(event) {
        // stops the page from scrolling
        event.preventDefault();

        var nextWrappedItem = this._getNextSelectableWrappedItem(event.target);

        if (nextWrappedItem !== null) {
          nextWrappedItem.focus();
        }
      }
      /** @ignore */

    }, {
      key: "_onResizeWindow",
      value: function _onResizeWindow() {
        // just close all popovers for now when screen is resized
        // there might be more popovers, then the 'more' popovers
        var popovers = this.getElementsByTagName('coral-popover');

        for (var i = 0; i < popovers.length; i++) {
          popovers[i].removeAttribute('open');
        } // force a relayout (needed especially if framerate during resize drops e.g.: in FF)


        this._debounceOnLayout();
      }
      /** @ignore */

    }, {
      key: "_onLayout",
      value: function _onLayout() {
        if (!this.primary || !this.primary._elements || !this.primary._elements.overlay || !this.secondary || !this.secondary._elements || !this.secondary._elements.overlay) {
          // while containers are not cached or no items are rendered do nothing
          return;
        }

        if (this.primary._elements.overlay.open === true || this.secondary._elements.overlay.open === true) {
          // while popovers are open do not relayout
          return;
        }

        var ERROR_MARGIN = 78;
        var primaryMore = this.primary._elements.moreButton;
        var secondaryMore = this.secondary._elements.moreButton;
        var leftItems = this.primary.items.getAll();
        var rightItems = this.secondary.items.getAll().reverse();
        var itemLeft = null;
        var itemRight = null;

        var widthCache = this._newWidthCache();

        var leftMoreButtonWidth = leftItems.length > 0 ? widthCache.getOuterWidth(primaryMore) : 0;
        var rightMoreButtonWidth = rightItems.length > 0 ? widthCache.getOuterWidth(secondaryMore) : 0; // Make it possible to set left/right padding to the containers

        var borderWidthLeftContainer = this.primary.offsetWidth - this.primary.getBoundingClientRect().width;
        var borderWidthRightContainer = this.secondary.offsetWidth - this.secondary.getBoundingClientRect().width;
        var primaryLeftOffset = this.primary.offsetLeft;
        var secondaryRightOffset = this.offsetWidth - (this.secondary.offsetLeft + this.secondary.offsetWidth);
        var availableWidth = this.offsetWidth - primaryLeftOffset - secondaryRightOffset - leftMoreButtonWidth - rightMoreButtonWidth - borderWidthLeftContainer - borderWidthRightContainer - ERROR_MARGIN;
        var currentUsedWidth = 0;
        var leftVisibleItems = 0;
        var rightVisibleItems = 0;
        var moreButtonLeftVisible = false;
        var moreButtonRightVisible = false;
        var showItem = false;
        var itemWidth = 0;

        for (var i = 0; i < leftItems.length || i < rightItems.length; i++) {
          itemLeft = i < leftItems.length ? leftItems[i] : null;
          itemRight = i < rightItems.length ? rightItems[i] : null; // first calculate visibility of left item

          showItem = false;

          if (itemLeft !== null) {
            if (itemLeft.hidden || itemLeft.style.display === 'none') {
              // item is hidden on purpose (we don't use it for layouting but do also not move offscreen) needed as it
              // might already have been moved offscreen before
              this._moveToScreen(itemLeft);
            } else {
              // if item is not hidden on purpose (hiding by actionBar due to space problems does not count) => layout
              // element
              if (!moreButtonLeftVisible && (this.primary.threshold <= 0 || leftVisibleItems < this.primary.threshold)) {
                // if threshold is not reached so far
                itemWidth = widthCache.getOuterWidth(itemLeft);

                if (currentUsedWidth + itemWidth < availableWidth) {
                  // if there is still enough space to show another item
                  showItem = true;
                } else if (leftVisibleItems === leftItems.length - 1 && currentUsedWidth + itemWidth < availableWidth + leftMoreButtonWidth) {
                  // if this is the last item and so far there have been no items hidden => don't show more button
                  showItem = true;
                }
              }

              if (showItem) {
                leftVisibleItems += 1;
                currentUsedWidth += itemWidth;

                this._moveToScreen(itemLeft);
              } else {
                this._hideItem(itemLeft);

                moreButtonLeftVisible = true;
              }

              if (leftVisibleItems === leftItems.length) {
                // left more button not needed => more free space available
                availableWidth += leftMoreButtonWidth;
                moreButtonLeftVisible = false;
              }
            }
          } // then calculate visibility of right item


          showItem = false;

          if (itemRight !== null) {
            if (itemRight.hidden || itemRight.style.display === 'none') {
              // item is hidden on purpose (we don't use it for layouting but do also not move offscreen) needed as it
              // might already have been moved offscreen before
              this._moveToScreen(itemRight);
            } else {
              // if item is not hidden on purpose (hiding by actionBar due to space problems does not count) => layout
              // element
              if (!moreButtonRightVisible && (this.secondary.threshold <= 0 || rightVisibleItems < this.secondary.threshold)) {
                // if threshold is not reached so far
                itemWidth = widthCache.getOuterWidth(itemRight);

                if (currentUsedWidth + itemWidth < availableWidth) {
                  // if there is still enough space to show another item
                  showItem = true;
                } else if (rightVisibleItems === rightItems.length - 1 && currentUsedWidth + itemWidth < availableWidth + rightMoreButtonWidth) {
                  // if this is the last item and so far there have been no items hidden => don't show more button
                  showItem = true;
                }
              }

              if (showItem) {
                rightVisibleItems += 1;
                currentUsedWidth += itemWidth;

                this._moveToScreen(itemRight);
              } else {
                this._hideItem(itemRight);

                moreButtonRightVisible = true;
              }

              if (rightVisibleItems === rightItems.length) {
                // left more button not needed => more free space available
                availableWidth += rightMoreButtonWidth;
                moreButtonRightVisible = false;
              }
            }
          }
        } // Handle tabs


        var primarySelectable = this.primary.items._getAllSelectable();

        var secondarySelectable = this.secondary.items._getAllSelectable();

        for (var _i = 0; _i < this._items.length; _i++) {
          this._toggleItemTabbable(this._items[_i], false);
        } // LEFT: Show or hide more buttons


        if (moreButtonLeftVisible) {
          this._moveToScreen(primaryMore, true);

          if (primarySelectable.length === 0) {
            this._toggleItemTabbable(primaryMore, true);
          } else {
            this._toggleItemTabbable(primaryMore, false);

            this._toggleItemTabbable(primarySelectable[0], true);
          }
        } else {
          this._moveToScreen(primaryMore, false);

          this._toggleItemTabbable(primaryMore, false);

          this._toggleItemTabbable(primarySelectable[0], true);
        } // RIGHT: Show or hide more buttons


        if (moreButtonRightVisible) {
          this._moveToScreen(secondaryMore, true);

          if (secondarySelectable.length === 0) {
            this._toggleItemTabbable(secondaryMore, true);
          } else {
            this._toggleItemTabbable(secondaryMore, false);

            this._toggleItemTabbable(secondarySelectable[0], true);
          }
        } else {
          this._moveToScreen(secondaryMore, false);

          this._toggleItemTabbable(secondaryMore, false);

          var tabbableItem = this.secondary.items._getAllSelectable()[0];

          if (tabbableItem) {
            this._toggleItemTabbable(tabbableItem, true);
          }
        } // re-calculate layout on element resize


        if (!this._resizeListenerAttached) {
          commons.addResizeListener(this, this._debounceOnLayout);
          commons.addResizeListener(this.primary, this._debounceOnLayout);
          commons.addResizeListener(this.secondary, this._debounceOnLayout);
          this._resizeListenerAttached = true;
        }
      }
      /** @ignore */

    }, {
      key: "_getNextSelectableWrappedItem",
      value: function _getNextSelectableWrappedItem(currentItem) {
        if (currentItem.parentNode.tagName === 'CORAL-ACTIONBAR-ITEM') {
          // currentItem is wrapped
          currentItem = currentItem.parentNode;
        }

        var selectableItems = this._getAllSelectableItems(currentItem);

        var length = selectableItems.length;
        var index = selectableItems.indexOf(currentItem);

        if (index >= 0 && length > index + 1) {
          // if there is a next selectable element return it
          return getFirstSelectableWrappedItem(selectableItems[index + 1]);
        } else {
          for (var i = 0; i < length; i++) {
            if (selectableItems[i].contains(currentItem) && length > i + 1) {
              return getFirstSelectableWrappedItem(selectableItems[i + 1]);
            }
          }
        }

        return null;
      }
      /** @ignore */

    }, {
      key: "_getPreviousSelectableWrappedItem",
      value: function _getPreviousSelectableWrappedItem(currentItem) {
        if (currentItem.parentNode.tagName === 'CORAL-ACTIONBAR-ITEM') {
          // currentItem is wrapped
          currentItem = currentItem.parentNode;
        }

        var selectableItems = this._getAllSelectableItems(currentItem);

        var index = selectableItems.indexOf(currentItem);

        if (index > 0) {
          // if there is a previous selectable element return it
          return getFirstSelectableWrappedItem(selectableItems[index - 1]);
        } else {
          for (var i = 1; i < selectableItems.length; i++) {
            if (selectableItems[i].contains(currentItem)) {
              return getFirstSelectableWrappedItem(selectableItems[i - 1]);
            }
          }
        }

        return null;
      }
      /** @ignore */

    }, {
      key: "_getAllSelectableItems",
      value: function _getAllSelectableItems(currentItem) {
        var selectableItems = [];

        if (this.primary._elements.overlay.open === true || this.secondary._elements.overlay.open === true) {
          // if popover is open only items in popover can be selected
          var popoverItems = this.primary._elements.overlay.open === true ? this.primary._itemsInPopover : this.secondary._itemsInPopover;
          var item = null;

          for (var i = 0; i < popoverItems.length; i++) {
            item = popoverItems[i];

            if (!item.hasAttribute('disabled') && !item.hasAttribute('hidden') && item.style.display !== 'none' && getFirstSelectableWrappedItem(item)) {
              selectableItems.push(item);
            }
          }
        } else {
          // concat selectable items from left side of the bar and right side of the bar
          var leftSelectableItems = this.primary.items._getAllSelectable();

          var rightSelectableItems = this.secondary.items._getAllSelectable();

          if (currentItem) {
            if (this.primary.contains(currentItem)) {
              selectableItems = leftSelectableItems;
            } else if (this.secondary.contains(currentItem)) {
              selectableItems = rightSelectableItems;
            }
          } else {
            selectableItems = leftSelectableItems.concat(rightSelectableItems);
          }
        }

        return selectableItems;
      }
      /** @ignore */

    }, {
      key: "_newWidthCache",
      value: function _newWidthCache() {
        return {
          _items: [],
          _outerWidth: [],
          getOuterWidth: function getOuterWidth(item) {
            var index = this._items.indexOf(item);

            if (index < 0) {
              // if item was not cached in current frame => cache it
              this._items.push(item);

              var width = item.offsetWidth;

              this._outerWidth.push(width);

              index = this._outerWidth.length - 1;
            }

            return this._outerWidth[index];
          }
        };
      }
      /** @ignore */

    }, {
      key: "_forceWebkitRedraw",
      value: function _forceWebkitRedraw(el) {
        var isWebkit = ('WebkitAppearance' in document.documentElement.style);

        if (isWebkit && el.style.display !== 'none') {
          el.style.display = 'none'; // no need to store this anywhere, the reference would be enough

          this._cachedOffsetHeight = el.offsetHeight;
          el.style.display = '';
        }
      }
      /** @ignore */

    }, {
      key: "_hideItem",
      value: function _hideItem(item, hide) {
        if (hide === false) {
          this._moveToScreen(item);
        } else if (!item.hasAttribute('coral-actionbar-offscreen')) {
          // actually just move element offscreen to be able to measure the size while calculating the layout
          item.setAttribute('coral-actionbar-offscreen', '');
          item.style.visibility = 'hidden'; // if I do not force a browser redraw webkit has layouting problems

          this._forceWebkitRedraw(item);
        }
      }
      /** @ignore */

    }, {
      key: "_moveToScreen",
      value: function _moveToScreen(item, show) {
        if (show === false) {
          this._hideItem(item);
        } else if (item.hasAttribute('coral-actionbar-offscreen')) {
          // actually just move element onscreen again (see _hideItem)
          item.removeAttribute('coral-actionbar-offscreen');
          item.style.visibility = ''; // if I do not force a browser redraw webkit has layouting problems

          this._forceWebkitRedraw(item);
        }
      }
      /** @ignore */

    }, {
      key: "_toggleItemTabbable",
      value: function _toggleItemTabbable(item, tabbable) {
        this._ignoreLayout = true; // item might be wrapped (for now remove/add tabindex only on the first wrapped item)

        item = getFirstSelectableWrappedItem(item);

        if (item !== null) {
          item.setAttribute('tabindex', tabbable ? 0 : -1);
        }
      }
      /** @ignore */

    }, {
      key: "_debounceOnLayout",
      value: function _debounceOnLayout() {
        var _this3 = this;

        if (this._ignoreLayout) {
          this._ignoreLayout = false;
          return;
        } // Debounce


        if (this._timeout !== null) {
          window.clearTimeout(this._timeout);
        }

        this._timeout = window.setTimeout(function () {
          _this3._timeout = null;

          _this3._onLayout();
        }, this._wait);
      }
    }, {
      key: "_moveDirectItemChildren",
      value: function _moveDirectItemChildren() {
        var items = Array.prototype.filter.call(this.children, function (child) {
          return child.nodeName === 'CORAL-ACTIONBAR-ITEM';
        });
        var frag = document.createDocumentFragment(); // Move them to the frag

        items.forEach(function (item) {
          frag.appendChild(item);
        }); // Add the frag to primary content zone

        this._elements.primary.appendChild(frag);
      }
    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$t); // Move direct items into primary content zone

        this._moveDirectItemChildren(); // Cleanup resize helpers object (cloneNode support)


        var resizeHelpers = this.querySelectorAll('object');

        for (var i = 0; i < resizeHelpers.length; ++i) {
          var resizeElement = resizeHelpers[i];

          if (resizeElement.parentNode === this) {
            this.removeChild(resizeElement);
          }
        }

        var primary = this._elements.primary;
        var secondary = this._elements.secondary;

        if (!primary.hasAttribute('role')) {
          primary.setAttribute('role', 'toolbar');
        }

        if (!secondary.hasAttribute('role')) {
          secondary.setAttribute('role', 'toolbar');
        } // we need to know if the content zone was provided to stop the voracious behavior


        var primaryProvided = primary.parentNode === this; // as a way to transition to the new content zones, we need to provide support for the old container tag. we copy
        // everything from these containers into the corresponding content zones, including the configurations

        var containers = Array.prototype.slice.call(this.getElementsByTagName('coral-actionbar-container'));
        var legacyContainer;
        var targetContainer;

        for (var j = 0, containersCount = containers.length; j < containersCount; j++) {
          legacyContainer = containers[j]; // move first container content to new primary element

          if (j === 0) {
            targetContainer = primary; // overrides the previous configuration as we support older containers

            primaryProvided = true;
          } else if (j === 1) {
            targetContainer = secondary;
          } // it may happen that more than 2 containers were provided, in such case we simply ignore it


          if (targetContainer) {
            // we need to copy the existing configuration to the new content zone
            if (legacyContainer.hasAttribute('threshold')) {
              targetContainer.setAttribute('threshold', legacyContainer.getAttribute('threshold'));
            }

            if (legacyContainer.hasAttribute('morebuttontext')) {
              targetContainer.setAttribute('morebuttontext', legacyContainer.getAttribute('morebuttontext'));
            } // @todo: are we copying the more button?


            while (legacyContainer.firstChild) {
              targetContainer.appendChild(legacyContainer.firstChild);
            }
          }

          this.removeChild(legacyContainer);
        } // to prevent the content zone being voracious, we only move the children if primary was not explicitely provided


        if (!primaryProvided) {
          while (this.firstChild) {
            primary.appendChild(this.firstChild);
          }
        } // Call content zone inserts


        this.primary = this._elements.primary;
        this.secondary = this._elements.secondary; // force one layout

        this._onLayout();
      }
    }, {
      key: "primary",
      get: function get() {
        return this._getContentZone(this._elements.primary);
      },
      set: function set(value) {
        this._setContentZone('primary', value, {
          handle: 'primary',
          tagName: 'coral-actionbar-primary',
          insert: function insert(content) {
            // primary has to be before secondary if available
            this.insertBefore(content, this.secondary);
          }
        });
      }
      /**
       The secondary (right) container of the ActionBar.
        @type {ActionBarSecondary}
       @contentzone
       */

    }, {
      key: "secondary",
      get: function get() {
        return this._getContentZone(this._elements.secondary);
      },
      set: function set(value) {
        this._setContentZone('secondary', value, {
          handle: 'secondary',
          tagName: 'coral-actionbar-secondary',
          insert: function insert(content) {
            this.appendChild(content);
          }
        });
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-actionbar-primary': 'primary',
          'coral-actionbar-secondary': 'secondary'
        };
      }
    }]);

    return _class;
  }(BaseComponent(HTMLElement)));

  var CLASSNAME$u = '_coral-ActionBar-item';
  /**
   @class Coral.ActionBar.Item
   @classdesc An ActionBar item component
   @htmltag coral-actionbar-item
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var ActionBarItem = Decorator( /*#__PURE__*/function (_BaseComponent) {
    _inherits(_class, _BaseComponent);

    var _super = _createSuper(_class);

    function _class() {
      _classCallCheck(this, _class);

      return _super.apply(this, arguments);
    }

    _createClass(_class, [{
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$u);
      }
    }, {
      key: "content",
      // @compat
      get: function get() {
        return this;
      },
      set: function set(value) {
        // Support configs
        if (_typeof(value) === 'object') {
          for (var prop in value) {
            /** @ignore */
            this[prop] = value[prop];
          }
        }
      }
    }]);

    return _class;
  }(BaseComponent(HTMLElement)));

  /**
   @class Coral.ActionBar.Container.Collection
   @classdesc The ActionBar container collection
   @extends {SelectableCollection}
   */

  var ActionBarContainerCollection = /*#__PURE__*/function (_SelectableCollection) {
    _inherits(ActionBarContainerCollection, _SelectableCollection);

    var _super = _createSuper(ActionBarContainerCollection);

    function ActionBarContainerCollection() {
      _classCallCheck(this, ActionBarContainerCollection);

      return _super.apply(this, arguments);
    }

    _createClass(ActionBarContainerCollection, [{
      key: "add",
      value: function add(item, before) {
        // in the left actionBar container always insert elements before the 'more' button in right actionBar always append
        // at the end
        if (!before && this._host.tagName === 'CORAL-ACTIONBAR-PRIMARY') {
          var moreButton = this._host._elements.moreButton;
          before = this._host.contains(moreButton) ? moreButton : null;
        }

        return _get(_getPrototypeOf(ActionBarContainerCollection.prototype), "add", this).call(this, item, before);
      }
    }, {
      key: "clear",
      value: function clear() {
        var items = _get(_getPrototypeOf(ActionBarContainerCollection.prototype), "clear", this).call(this);

        this._host._itemsInPopover = [];
        return items;
      }
    }, {
      key: "_getAllSelectable",
      value: function _getAllSelectable() {
        var selectableItems = [];
        var child = null;

        for (var i = 0; i < this._host.children.length; i++) {
          child = this._host.children[i];

          if (!child.hasAttribute('disabled') && !child.hasAttribute('hidden') && !child.hasAttribute('coral-actionbar-offscreen') && child !== this._host._elements.overlay && getFirstSelectableWrappedItem(child)) {
            selectableItems.push(child);
          }
        }

        return selectableItems;
      }
    }, {
      key: "_getAllOffScreen",
      value: function _getAllOffScreen() {
        return Array.prototype.slice.call(this._host.querySelectorAll("".concat(this._itemTagName, "[coral-actionbar-offscreen]")));
      }
    }]);

    return ActionBarContainerCollection;
  }(SelectableCollection);

  var SPACE = 32;
  /**
   @class Coral.AnchorButton
   @classdesc A Link component rendering as a button allowing us to style an anchor element that both looks and behaves
   like a button rather than a link. It can receive keyboard focus regardless of whether or not it has an <code>href</code>
   attribute, can be activated using either the <code>SPACE</code> key or the <code>ENTER</code> key, and is identified to
   assistive technology as a button element.
   @htmltag coral-anchorbutton
   @htmlbasetag a
   @extends {HTMLAnchorElement}
   @extends {BaseComponent}
   @extends {BaseButton}
   */

  var AnchorButton = Decorator( /*#__PURE__*/function (_BaseButton) {
    _inherits(_class, _BaseButton);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this); // Events

      _this._delegateEvents(commons.extend(_this._events, {
        keydown: '_onKeyDown',
        keyup: '_onKeyUp'
      })); // cannot use the events hash because events on disabled items are not reported


      _this.addEventListener('click', _this._onDisabledClick.bind(_assertThisInitialized(_this)));

      return _this;
    }
    /**
     Disables the button from user interaction.
      @type {Boolean}
     @default false
     @htmlattribute disabled
     @htmlattributereflected
     */


    _createClass(_class, [{
      key: "_onKeyDown",

      /**
       Keyboard handling per the WAI-ARIA button widget design pattern:
       https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_button_role
        @ignore
       */
      value: function _onKeyDown(event) {
        if (event.keyCode === SPACE) {
          event.preventDefault();
          this.click();
          this.classList.add('is-selected');
        }
      }
      /** @ignore */

    }, {
      key: "_onKeyUp",
      value: function _onKeyUp(event) {
        if (event.keyCode === SPACE) {
          event.preventDefault();
          this.classList.remove('is-selected');
        }
      }
      /** @ignore */

    }, {
      key: "_onDisabledClick",
      value: function _onDisabledClick(event) {
        if (this.disabled) {
          event.preventDefault();
        }
      } // Override content zone name

    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this); // a11y


        this.setAttribute('role', 'button');

        if (!this.disabled) {
          // Force tabindex and aria-disabled attribute reflection
          this.setAttribute('tabindex', '0');
          this.removeAttribute('aria-disabled');
        }
      }
    }, {
      key: "disabled",
      get: function get() {
        return this._disabled || false;
      },
      set: function set(value) {
        this._disabled = transform.booleanAttr(value);

        this._reflectAttribute('disabled', this._disabled);

        this.classList.toggle('is-disabled', this._disabled);
        this.setAttribute('tabindex', this._disabled ? '-1' : '0');
        this[this._disabled ? 'setAttribute' : 'removeAttribute']('aria-disabled', this._disabled);
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-anchorbutton-label': 'label'
        };
      }
      /** @ignore */

    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['disabled']);
      }
    }]);

    return _class;
  }(BaseButton(BaseComponent(HTMLAnchorElement))));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.AnchorButton.Label
   @classdesc The AnchorButton label content
   @htmltag coral-anchorbutton-label
   @return {HTMLElement}
   */
  var AnchorButtonLabel = (function () {
    return document.createElement('coral-anchorbutton-label');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons._define('coral-anchorbutton', AnchorButton, {
    extends: 'a'
  });

  AnchorButton.Label = AnchorButtonLabel;

  var template$d = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["overlay"] = document.createElement("coral-popover");
    el0.id = data_0["commons"]["getUID"]();
    el0.setAttribute("handle", "overlay");
    el0.setAttribute("placement", "bottom");
    el0.setAttribute("breadthoffset", "-50%r + 50%p");
    el0.setAttribute("coral-actionbar-popover", "");
    el0.setAttribute("tabindex", "-1");
    el0.setAttribute("role", "presentation");
    frag.appendChild(el0);
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    return frag;
  };

  var template$e = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["moreButton"] = document.createElement("button", "coral-button");
    el0.setAttribute("is", "coral-button");
    el0.setAttribute("handle", "moreButton");
    el0.setAttribute("type", "button");
    el0.setAttribute("variant", "quietaction");
    el0.className += " _coral-ActionBar-button";
    el0.setAttribute("icon", "more");
    el0.setAttribute("coral-actionbar-more", "");
    el0.setAttribute("aria-expanded", "false");
    el0.setAttribute("aria-haspopup", "true");
    el0.setAttribute("aria-label", data_0["i18n"]["get"]('More'));
    var el1 = document.createTextNode("\n  ");
    el0.appendChild(el1);
    var el2 = this["moreButtonLabel"] = document.createElement("coral-button-label");
    el2.setAttribute("handle", "moreButtonLabel");
    el0.appendChild(el2);
    var el3 = document.createTextNode("\n");
    el0.appendChild(el3);
    frag.appendChild(el0);
    var el4 = document.createTextNode("\n");
    frag.appendChild(el4);
    return frag;
  };

  var template$f = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var data = data_0 = typeof data_0 === "undefined" ? {} : data_0;
    data = data_0;
    var copyAttributes = data.copyAttributes;
    data_0 = data;
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);

    if (data_0["items"]["isButtonList"]) {
      var el3 = document.createTextNode("\n  ");
      frag.appendChild(el3);
      var el4 = this["buttonList"] = document.createElement("coral-buttonlist");
      el4.className += " _coral-ActionBar-buttonList";
      el4.setAttribute("tabindex", "0");
      el4.setAttribute("role", "menu");
      el4.setAttribute("coral-actionbar-offscreen", "");
      el4.setAttribute("handle", "buttonList");
      var el5 = document.createTextNode("\n    ");
      el4.appendChild(el5);
      var iterated_1 = data_0["items"];

      for (var i1 = 0, ni1 = iterated_1.length; i1 < ni1; i1++) {
        var data_1 = data = iterated_1[i1];
        var el7 = document.createTextNode("\n      ");
        el4.appendChild(el7);
        var el8 = this["buttonListItem"] = document.createElement("button", "coral-buttonlist-item");
        el8.setAttribute("is", "coral-buttonlist-item");
        el8.setAttribute("role", "menuitem");
        el8.setAttribute("handle", "buttonListItem");
        var el9 = document.createTextNode("\n        ");
        el8.appendChild(el9);
        data = data_1;
        copyAttributes(data._button, this.buttonListItem);
        data_1 = data;
        var el11 = document.createTextNode("\n        ");
        el8.appendChild(el11);
        var el12 = document.createElement("coral-list-item-content");
        var el13 = document.createTextNode("\n          ");
        el12.appendChild(el13);
        var el14 = this["buttonListItemContent"] = document.createElement("coral-action-bar-item");
        el14.setAttribute("coral-actionbar-offscreen", "");
        el14.setAttribute("handle", "buttonListItemContent");
        el12.appendChild(el14);
        var el15 = document.createTextNode("\n        ");
        el12.appendChild(el15);
        el8.appendChild(el12);
        var el16 = document.createTextNode("\n        ");
        el8.appendChild(el16);
        data = data_1;
        this.buttonListItemContent.innerHTML = data._button.label.innerHTML;
        data_1 = data;
        var el18 = document.createTextNode("\n      ");
        el8.appendChild(el18);
        el4.appendChild(el8);
        var el19 = document.createTextNode("\n      ");
        el4.appendChild(el19);

        if (data_1["_popover"]) {
          var el21 = document.createTextNode("\n        ");
          el4.appendChild(el21);
          data = data_1;

          var popover = data._popover.cloneNode(true);

          data._popover.removeAttribute('id'); //set target to the new button


          if (popover.target) {
            popover.removeAttribute('target');
            popover.target = this.buttonListItem;
          }

          this.buttonList.items.add(popover);
          data_1 = data;
          var el23 = document.createTextNode("\n      ");
          el4.appendChild(el23);
        }

        var el24 = document.createTextNode("\n    ");
        el4.appendChild(el24);
      }

      var el25 = document.createTextNode("\n  ");
      el4.appendChild(el25);
      frag.appendChild(el4);
      var el26 = document.createTextNode("\n  ");
      frag.appendChild(el26);
      var el27 = document.createTextNode("\n");
      frag.appendChild(el27);
    } else {
      var el28 = document.createTextNode("\n    ");
      frag.appendChild(el28);

      if (data_0["items"]["isAnchorList"]) {
        var el30 = document.createTextNode("\n      ");
        frag.appendChild(el30);
        var el31 = this["anchorList"] = document.createElement("coral-anchorlist");
        el31.setAttribute("tabindex", "0");
        el31.setAttribute("role", "menu");
        el31.setAttribute("coral-actionbar-offscreen", "");
        el31.setAttribute("handle", "anchorList");
        var el32 = document.createTextNode("\n        ");
        el31.appendChild(el32);
        var iterated_1 = data_0["items"];

        for (var i1 = 0, ni1 = iterated_1.length; i1 < ni1; i1++) {
          var data_1 = data = iterated_1[i1];
          var el34 = document.createTextNode("\n          ");
          el31.appendChild(el34);
          var el35 = this["anchorListItem"] = document.createElement("a", "coral-anchorlist-item");
          el35.setAttribute("is", "coral-anchorlist-item");
          el35.setAttribute("role", "menuitem");
          el35.setAttribute("handle", "anchorListItem");
          var el36 = document.createTextNode("\n            ");
          el35.appendChild(el36);
          data = data_1;
          copyAttributes(data._button, this.anchorListItem);
          data_1 = data;
          var el38 = document.createTextNode("\n            ");
          el35.appendChild(el38);
          var el39 = document.createElement("coral-list-item-content");
          var el40 = document.createTextNode("\n              ");
          el39.appendChild(el40);
          var el41 = this["anchorListItemContent"] = document.createElement("coral-action-bar-item");
          el41.setAttribute("coral-actionbar-offscreen", "");
          el41.setAttribute("handle", "anchorListItemContent");
          el39.appendChild(el41);
          var el42 = document.createTextNode("\n            ");
          el39.appendChild(el42);
          el35.appendChild(el39);
          var el43 = document.createTextNode("\n            ");
          el35.appendChild(el43);
          data = data_1;
          this.anchorListItemContent.innerHTML = data._button.label.innerHTML;
          data_1 = data;
          var el45 = document.createTextNode("\n          ");
          el35.appendChild(el45);
          el31.appendChild(el35);
          var el46 = document.createTextNode("\n          ");
          el31.appendChild(el46);

          if (data_1["_popover"]) {
            var el48 = document.createTextNode("\n            ");
            el31.appendChild(el48);
            data = data_1;

            var popover = data._popover.cloneNode(true);

            data._popover.removeAttribute('id'); //set target to the new button


            if (popover.target) {
              popover.removeAttribute('target');
              popover.target = this.anchorListItem;
            }

            this.anchorList.items.add(popover);
            data_1 = data;
            var el50 = document.createTextNode("\n          ");
            el31.appendChild(el50);
          }

          var el51 = document.createTextNode("\n        ");
          el31.appendChild(el51);
        }

        var el52 = document.createTextNode("\n      ");
        el31.appendChild(el52);
        frag.appendChild(el31);
        var el53 = document.createTextNode("\n      ");
        frag.appendChild(el53);
        var el54 = document.createTextNode("\n    ");
        frag.appendChild(el54);
      } else {
        var el55 = document.createTextNode("\n        ");
        frag.appendChild(el55);
        var el56 = document.createElement("ul");
        el56.className += " _coral-ActionBar-list";
        var el57 = document.createTextNode("\n          ");
        el56.appendChild(el57);
        var iterated_1 = data_0["items"];

        for (var i1 = 0, ni1 = iterated_1.length; i1 < ni1; i1++) {
          var data_1 = data = iterated_1[i1];
          var el59 = document.createTextNode("\n            ");
          el56.appendChild(el59);
          var el60 = document.createElement("li");
          el60.className += " _coral-ActionBar-list-item";
          var el61 = document.createTextNode("\n              ");
          el60.appendChild(el61);
          el60.appendChild(data_1);
          var el63 = document.createTextNode("\n            ");
          el60.appendChild(el63);
          el56.appendChild(el60);
          var el64 = document.createTextNode("\n          ");
          el56.appendChild(el64);
        }

        var el65 = document.createTextNode("\n        ");
        el56.appendChild(el65);
        frag.appendChild(el56);
        var el66 = document.createTextNode("\n      ");
        frag.appendChild(el66);
      }

      var el67 = document.createTextNode("\n  ");
      frag.appendChild(el67);
    }

    var el68 = document.createTextNode("\n\n\n");
    frag.appendChild(el68);
    return frag;
  };

  var REG_EXP = /_coral([^\s]+)/g;

  var copyAttributes = function copyAttributes(from, to) {
    var excludedAttributes = ['is', 'id', 'variant', 'size'];

    for (var i = 0; i < from.attributes.length; i++) {
      var attr = from.attributes[i];

      if (excludedAttributes.indexOf(attr.nodeName) === -1) {
        if (attr.nodeName === 'class') {
          // Filter out private Coral classes
          to.setAttribute(attr.nodeName, "".concat(to.className, " ").concat(attr.nodeValue.replace(REG_EXP, '')));
        } else {
          to.setAttribute(attr.nodeName, attr.nodeValue);
        }
      }
    }
  };
  /**
   @base BaseActionBarContainer
   @classdesc The base element for action bar containers
   */


  var BaseActionBarContainer = function BaseActionBarContainer(superClass) {
    return /*#__PURE__*/function (_superClass) {
      _inherits(_class, _superClass);

      var _super = _createSuper(_class);

      /** @ignore */
      function _class() {
        var _this;

        _classCallCheck(this, _class);

        _this = _super.call(this); // Templates

        _this._elements = {};
        _this._itemsInPopover = [];
        template$e.call(_this._elements, {
          i18n: i18n
        });
        template$d.call(_this._elements, {
          commons: commons
        });
        template$f.call(_this._elements, {
          items: _this._itemsInPopover,
          copyAttributes: copyAttributes
        }); // Return focus to overlay by default

        _this._elements.overlay.focusOnShow = _this._elements.overlay;
        var overlayId = _this._elements.overlay.id;
        var events = {};
        events["global:capture:coral-overlay:beforeopen #".concat(overlayId)] = '_onOverlayBeforeOpen';
        events["global:capture:coral-overlay:beforeclose #".concat(overlayId)] = '_onOverlayBeforeClose'; // Keyboard interaction

        events["global:key:down #".concat(overlayId)] = '_onOverlayKeyDown';
        events["global:key:up #".concat(overlayId)] = '_onOverlayKeyUp'; // Events

        _this._delegateEvents(events); // Init the collection mutation observer


        _this.items._startHandlingItems(true);

        return _this;
      }
      /**
       Returns the inner overlay to allow customization.
        @type {Popover}
       @readonly
       */


      _createClass(_class, [{
        key: "_styleItem",

        /**
         Style item content
         */
        value: function _styleItem(item) {
          var button = item.querySelector('button[is="coral-button"]') || item.querySelector('a[is="coral-anchorbutton"]');

          if (button) {
            button.classList.add('_coral-ActionBar-button');
            var oldVariant = button.getAttribute('variant');

            if (oldVariant === Button.variant.ACTION || oldVariant === Button.variant.QUIET_ACTION) {
              return;
            }

            button.setAttribute('variant', oldVariant === Button.variant.QUIET ? Button.variant.QUIET_ACTION : Button.variant.ACTION);
          }
        }
        /**
         Called after popover.open is set to true, but before the transition of the popover is done. Show elements inside
         the actionbar, that are hidden due to space problems.
          @ignore
         */

      }, {
        key: "_onOverlayBeforeOpen",
        value: function _onOverlayBeforeOpen(event) {
          // there might be popovers in popover => ignore them
          if (event.target !== this._elements.overlay) {
            return;
          }

          this._itemsInPopover = this.items._getAllOffScreen();

          if (this._itemsInPopover.length < 1) {
            return;
          } // Set focus to first focusable descendant of the overlay by default


          this._elements.overlay.focusOnShow = 'on';

          this._itemsInPopover.forEach(function (item) {
            item.style.visibility = ''; // Store the button and popover on the item

            item._button = item.querySelector('button[is="coral-button"]') || item.querySelector('a[is="coral-anchorbutton"]');
            item._popover = item.querySelector('coral-popover');

            if (item._popover) {
              item._popoverId = item._popover.id;
            }
          }); // Whether a ButtonList or AnchorList should be rendered


          this._itemsInPopover.isButtonList = this._itemsInPopover.every(function (item) {
            return item._button && item._button.tagName === 'BUTTON';
          });
          this._itemsInPopover.isAnchorList = this._itemsInPopover.every(function (item) {
            return item._button && item._button.tagName === 'A';
          }); // show the current popover (hidden needed to disable fade time of popover)

          this._elements.overlay.hidden = false; // render popover content

          var popover = this._elements.overlay;
          popover.content.innerHTML = '';
          popover.content.appendChild(template$f.call(this._elements, {
            items: this._itemsInPopover,
            copyAttributes: copyAttributes
          }));
        }
        /**
         Called after popover.open is set to false, but before the transition of the popover is done.
         Make items visible again, that now do fit into the actionbar.
         @ignore
         */

      }, {
        key: "_onOverlayBeforeClose",
        value: function _onOverlayBeforeClose(event) {
          // there might be popovers in popover => ignore them
          if (event.target !== this._elements.overlay) {
            return;
          }

          var focusedItem = document.activeElement.parentNode; // we need to check if item has 'hasAttribute' because it is not present on the document

          var isFocusedItemInsideActionBar = this.parentNode.contains(focusedItem);
          var isFocusedItemOffscreen = focusedItem.hasAttribute && focusedItem.hasAttribute('coral-actionbar-offscreen');

          if (isFocusedItemInsideActionBar && isFocusedItemOffscreen) {
            // if currently an element is focused, that should not be visible (or is no actionbar-item) => select 'more'
            // button
            this._elements.moreButton.focus();
          } // hide the popover(needed to disable fade time of popover)


          this._elements.overlay.hidden = true;
          this._elements.overlay.focusOnShow = this._elements.overlay; // close any popovers, that might be inside the 'more' popover

          var childPopovers = this._elements.overlay.getElementsByTagName('coral-popover');

          for (var i = 0; i < childPopovers.length; i++) {
            childPopovers[i].open = false;
          } // return all elements from popover


          this._returnElementsFromPopover(); // clear cached items from popover


          this._itemsInPopover = []; // clear overlay

          this._elements.overlay.content.innerHTML = '';
        }
      }, {
        key: "_onOverlayKeyDown",
        value: function _onOverlayKeyDown(event) {
          event.preventDefault(); // Focus first item

          this._elements.anchorList && this._elements.anchorList._focusFirstItem(event);
          this._elements.buttonList && this._elements.buttonList._focusFirstItem(event);
        }
      }, {
        key: "_onOverlayKeyUp",
        value: function _onOverlayKeyUp(event) {
          event.preventDefault(); // Focus last item

          this._elements.anchorList && this._elements.anchorList._focusLastItem(event);
          this._elements.buttonList && this._elements.buttonList._focusLastItem(event);
        }
      }, {
        key: "connectedCallback",

        /** @ignore */
        value: function connectedCallback() {
          _get(_getPrototypeOf(_class.prototype), "connectedCallback", this).call(this);

          var overlay = this._elements.overlay; // Cannot be open by default when rendered

          overlay.removeAttribute('open'); // Restore in DOM

          if (overlay._parent) {
            overlay._parent.appendChild(overlay);
          }
        }
        /** @ignore */

      }, {
        key: "render",
        value: function render() {
          var _this2 = this;

          _get(_getPrototypeOf(_class.prototype), "render", this).call(this); // Cleanup resize helpers object (cloneNode support)


          var resizeHelpers = this.getElementsByTagName('object');

          for (var i = 0; i < resizeHelpers.length; ++i) {
            var resizeElement = resizeHelpers[i];

            if (resizeElement.parentNode === this) {
              this.removeChild(resizeElement);
            }
          } // Cleanup 'More' button


          var more = this.querySelector('[coral-actionbar-more]');

          if (more) {
            this.removeChild(more);
          } // Cleanup 'More' popover


          var popover = this.querySelector('[coral-actionbar-popover]');

          if (popover) {
            this.removeChild(popover);
          } // Copy more text


          this._elements.moreButton.label.textContent = this.moreButtonText; // Init 'More' popover

          this._elements.overlay.target = this._elements.moreButton; // Create empty frag

          var frag = document.createDocumentFragment(); // 'More' button might be moved later in dom when Container is attached to parent

          frag.appendChild(this._elements.moreButton);
          frag.appendChild(this._elements.overlay); // Render template

          this.appendChild(frag); // Style the items to match action items

          this.items.getAll().forEach(function (item) {
            return _this2._styleItem(item);
          });
        }
        /** @ignore */

      }, {
        key: "disconnectedCallback",
        value: function disconnectedCallback() {
          _get(_getPrototypeOf(_class.prototype), "disconnectedCallback", this).call(this);

          var overlay = this._elements.overlay; // In case it was moved out don't forget to remove it

          if (!this.contains(overlay)) {
            overlay._parent = overlay._repositioned ? document.body : this;
            overlay.remove();
          }
        }
      }, {
        key: "overlay",
        get: function get() {
          return this._elements.overlay;
        }
        /**
         The Collection Interface that allows interacting with the items that the component contains.
          @type {ActionBarContainerCollection}
         @readonly
         */

      }, {
        key: "items",
        get: function get() {
          // Construct the collection on first request:
          if (!this._items) {
            this._items = new ActionBarContainerCollection({
              host: this,
              itemTagName: 'coral-actionbar-item',
              onItemAdded: this._styleItem
            });
          }

          return this._items;
        }
        /**
         The amount of items that are maximally visible inside the container. Using a value <= 0 will disable this
         feature and show as many items as possible.
          @type {Number}
         @default -1
         @htmlattribute threshold
         @htmlattributereflected
         */

      }, {
        key: "threshold",
        get: function get() {
          return typeof this._threshold === 'number' ? this._threshold : -1;
        },
        set: function set(value) {
          this._threshold = transform.number(value);

          this._reflectAttribute('threshold', this._threshold);
        }
        /**
         If there are more ActionBarItems inside the ActionBar than currently can be shown, then a "more" Button with the
         following text will be rendered (and some ActionBarItems will be hidden inside of a Popover).
          @type {String}
         @default ""
         @htmlattribute morebuttontext
         */

      }, {
        key: "moreButtonText",
        get: function get() {
          return this._moreButtonText || '';
        },
        set: function set(value) {
          this._moreButtonText = transform.string(value);

          if (this._elements.moreButton) {
            // moreButton might not have been created so far
            this._elements.moreButtonLabel.innerHTML = this._moreButtonText;

            this._elements.moreButton[this._moreButtonText.trim() === '' ? 'setAttribute' : 'removeAttribute']('title', i18n.get('More'));
          }
        }
      }], [{
        key: "_attributePropertyMap",
        get: function get() {
          return commons.extend(_get(_getPrototypeOf(_class), "_attributePropertyMap", this), {
            morebuttontext: 'moreButtonText'
          });
        }
        /** @ignore */

      }, {
        key: "observedAttributes",
        get: function get() {
          return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['morebuttontext', 'threshold']);
        }
      }]);

      return _class;
    }(superClass);
  };

  var CLASSNAME$v = '_coral-ActionBar-primary';
  /**
   @class Coral.ActionBar.Primary
   @classdesc An ActionBar primary component
   @htmltag coral-actionbar-primary
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var ActionBarPrimary = Decorator( /*#__PURE__*/function (_ActionBarContainer) {
    _inherits(_class, _ActionBarContainer);

    var _super = _createSuper(_class);

    function _class() {
      _classCallCheck(this, _class);

      return _super.apply(this, arguments);
    }

    _createClass(_class, [{
      key: "_returnElementsFromPopover",

      /** @ignore */
      value: function _returnElementsFromPopover() {
        var item = null;
        var wrappedItem = null;

        for (var i = 0; i < this._itemsInPopover.length; i++) {
          item = this._itemsInPopover[i];
          item.style.visibility = 'hidden'; // remove tabindex again

          wrappedItem = getFirstSelectableWrappedItem(item);

          if (wrappedItem && wrappedItem.hasAttribute('tabindex')) {
            wrappedItem.setAttribute('tabindex', -1);
          }

          this.insertBefore(item, this._elements.moreButton); // Reset popover id, target

          if (item._button && item._popover) {
            item._popover.id = item._popoverId;

            if (item._popover.target) {
              item._popover.target = item._button;
            }
          }
        }
      }
      /** @ignore */

    }, {
      key: "_attachMoreButtonToContainer",
      value: function _attachMoreButtonToContainer() {
        // add the button to the left/primary contentzone
        this.appendChild(this._elements.moreButton);
      }
      /** @ignore */

    }, {
      key: "render",
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$v);

        this._attachMoreButtonToContainer();
      }
    }]);

    return _class;
  }(BaseActionBarContainer(BaseComponent(HTMLElement))));

  var CLASSNAME$w = '_coral-ActionBar-secondary';
  /**
   @class Coral.ActionBar.Secondary
   @classdesc An ActionBar secondary component
   @htmltag coral-actionbar-secondary
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var ActionBarSecondary = Decorator( /*#__PURE__*/function (_ActionBarContainer) {
    _inherits(_class, _ActionBarContainer);

    var _super = _createSuper(_class);

    function _class() {
      _classCallCheck(this, _class);

      return _super.apply(this, arguments);
    }

    _createClass(_class, [{
      key: "_returnElementsFromPopover",

      /** @ignore */
      value: function _returnElementsFromPopover() {
        var item = null;
        var wrappedItem = null;

        for (var i = this._itemsInPopover.length - 1; i >= 0; i--) {
          item = this._itemsInPopover[i];
          item.style.visibility = 'hidden'; // remove tabindex again

          wrappedItem = getFirstSelectableWrappedItem(item);

          if (wrappedItem && wrappedItem.hasAttribute('tabindex')) {
            wrappedItem.setAttribute('tabindex', -1);
          }

          this.insertBefore(item, this.firstChild.nextSibling); // Reset popover id, target

          if (item._button && item._popover) {
            item._popover.id = item._popoverId;

            if (item._popover.target) {
              item._popover.target = item._button;
            }
          }
        }
      }
      /** @ignore */

    }, {
      key: "_attachMoreButtonToContainer",
      value: function _attachMoreButtonToContainer() {
        this.insertBefore(this._elements.moreButton, this.firstChild);
      }
      /** @ignore */

    }, {
      key: "render",
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$w);

        this._attachMoreButtonToContainer();
      }
    }]);

    return _class;
  }(BaseActionBarContainer(BaseComponent(HTMLElement))));

  var CLASSNAME$x = '_coral-ActionBar-container';
  /**
   Enumeration for {@link ActionBarContainer} positions.

   @typedef {Object} ActionBarContainerPositionEnum

   @property {String} PRIMARY
   Primary (left) ActionBar container.
   @property {String} SECONDARY
   Secondary (right) ActionBar container.
   @property {String} INVALID
   Invalid ActionBar container.
   */

  var position = {
    PRIMARY: 'primary',
    SECONDARY: 'secondary',
    INVALID: 'invalid'
  };
  /**
   @class Coral.ActionBar.Container
   @classdesc An ActionBar container component
   @htmltag coral-actionbar-container
   @extends {HTMLElement}
   @extends {BaseComponent}

   @deprecated
   */

  var ActionBarContainer = Decorator( /*#__PURE__*/function (_BaseActionBarContain) {
    _inherits(_class, _BaseActionBarContain);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this);

      commons._log('warn', "Coral.ActionBar.Container: coral-actionbar-container has been deprecated.\n    Please use coral-actionbar-primary and coral-actionbar-secondary instead");

      return _this;
    }
    /**
     The container position inside the actionbar.
      @private
     @type {String}
     @readonly
     @default ActionBarContainerPositionEnum.INVALID
     */


    _createClass(_class, [{
      key: "_attachMoreButtonToContainer",

      /** @ignore */
      value: function _attachMoreButtonToContainer() {
        if (this.parentNode && this.parentNode.secondary === this) {
          this.insertBefore(this._elements.moreButton, this.firstChild);
        } else {
          // add the button to the left/primary contentzone
          this.appendChild(this._elements.moreButton);
        }
      }
      /**
       Returns {@link ActionBarContainer} positions.
        @return {ActionBarContainerPositionEnum}
       */

    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$x); // Cleanup resize helpers object (cloneNode support)

        var resizeHelpers = this.getElementsByTagName('object');

        for (var i = 0; i < resizeHelpers.length; ++i) {
          var resizeElement = resizeHelpers[i];

          if (resizeElement.parentNode === this) {
            this.removeChild(resizeElement);
          }
        } // Cleanup 'More' button


        this._elements.moreButton = this.querySelector('[coral-actionbar-more]');

        if (this._elements.moreButton) {
          this.removeChild(this._elements.moreButton);
        } // Cleanup 'More' popover


        this._elements.overlay = this.querySelector('[coral-actionbar-popover]');

        if (this._elements.overlay) {
          this.removeChild(this._elements.overlay);
        } // Init 'More' button


        this._elements.moreButton.label.textContent = this.moreButtonText; // 'More' button might be moved later in dom when Container is attached to parent

        this.appendChild(this._elements.moreButton); // Init 'More' popover

        this._elements.overlay.target = this._elements.moreButton; // Insert popover always as firstChild to ensure element order (cloneNode support)

        this.insertBefore(this._elements.overlay, this.firstChild);

        this._attachMoreButtonToContainer();
      }
    }, {
      key: "_position",
      get: function get() {
        if (this.parentNode) {
          var containers = this.parentNode.getElementsByTagName('coral-actionbar-container');

          if (containers.length > 0 && containers[0] === this) {
            return position.PRIMARY;
          } else if (containers.length > 1 && containers[1] === this) {
            return position.SECONDARY;
          }
        }

        return position.INVALID;
      }
    }], [{
      key: "position",
      get: function get() {
        return position;
      }
    }]);

    return _class;
  }(BaseActionBarContainer(BaseComponent(HTMLElement))));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons.extend(strings, {
    'coral-component-actionbar': translations$9
  }); // Expose component on the Coral namespace

  commons._define('coral-actionbar-item', ActionBarItem);

  commons._define('coral-actionbar-primary', ActionBarPrimary);

  commons._define('coral-actionbar-secondary', ActionBarSecondary);

  commons._define('coral-actionbar-container', ActionBarContainer);

  commons._define('coral-actionbar', ActionBar);

  ActionBar.Item = ActionBarItem;
  ActionBar.Primary = ActionBarPrimary;
  ActionBar.Secondary = ActionBarSecondary;
  ActionBar.Container = ActionBarContainer;

  /**
   Enumeration for {@link Alert} variants.

   @typedef {Object} AlertVariantEnum

   @property {String} ERROR
   An alert with a warning icon to indicate that an error has occurred.
   @property {String} WARNING
   An alert with a warning icon to warn the user of something important.
   @property {String} SUCCESS
   An alert with a question mark icon to notify the user of a successful operation.
   @property {String} HELP
   A neutral alert with a question icon to help the user with non-critical information.
   @property {String} INFO
   An alert with an info icon to inform the user of non-critical information.
   */

  var variant$9 = {
    ERROR: 'error',
    WARNING: 'warning',
    SUCCESS: 'success',
    HELP: 'help',
    INFO: 'info'
  };
  /**
   Enumeration for {@link Alert} sizes.

   @typedef {Object} AlertSizeEnum

   @property {String} SMALL
   A small alert, usually employed for single line alerts without headers.
   @property {String} LARGE
   Not supported. Falls back to SMALL.
   */

  var size$4 = {
    SMALL: 'S',
    LARGE: 'L'
  };
  var CLASSNAME$y = '_coral-Alert'; // An array of all possible variant classnames

  var ALL_VARIANT_CLASSES$6 = [];

  for (var variantValue$4 in variant$9) {
    ALL_VARIANT_CLASSES$6.push("".concat(CLASSNAME$y, "--").concat(variant$9[variantValue$4]));
  } // Used to map icon with variant


  var capitalize$3 = function capitalize(s) {
    return s.charAt(0).toUpperCase() + s.slice(1);
  };
  /**
   @class Coral.Alert
   @classdesc An Alert component used as static indicators of an operation's result, or as messages to highlight
   information to the user. It does not include a close button by default, but you can add it manually by adding the
   <code>coral-close</code> attribute on an element contained by the Alert.
   @htmltag coral-alert
   @extends {HTMLElement}
   @extends {BaseComponent}
   */


  var Alert = Decorator( /*#__PURE__*/function (_BaseComponent) {
    _inherits(_class, _BaseComponent);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this); // Prepare templates

      _this._elements = {
        // Fetch or create the content zone elements
        header: _this.querySelector('coral-alert-header') || document.createElement('coral-alert-header'),
        content: _this.querySelector('coral-alert-content') || document.createElement('coral-alert-content'),
        footer: _this.querySelector('coral-alert-footer') || document.createElement('coral-alert-footer')
      }; // Events

      _this._delegateEvents({
        'click [coral-close]': '_onCloseClick'
      });

      return _this;
    }
    /**
     The alert variant style to use. See {@link AlertVariantEnum}.
      @type {String}
     @default AlertVariantEnum.INFO
     @htmlattribute variant
     @htmlattributereflected
     */


    _createClass(_class, [{
      key: "_onCloseClick",

      /**
       @ignore
       @todo maybe this should be base or something
       */
      value: function _onCloseClick(event) {
        var dismissTarget = event.matchedTarget;
        var dismissValue = dismissTarget.getAttribute('coral-close');

        if (!dismissValue || this.matches(dismissValue)) {
          this.hidden = true;
          event.stopPropagation();
        }

        this._trackEvent('close', 'coral-alert', event);
      }
    }, {
      key: "_insertTemplate",
      value: function _insertTemplate() {
        if (this._elements.icon) {
          this._elements.icon.remove();
        }

        var variantValue = this.variant; // Warning icon is same as ERROR icon

        if (variantValue === variant$9.WARNING || variantValue === variant$9.ERROR) {
          variantValue = 'alert';
        } // Inject the SVG icon


        var iconName = capitalize$3(variantValue);
        this.insertAdjacentHTML('afterbegin', Icon._renderSVG("spectrum-css-icon-".concat(iconName, "Medium"), ['_coral-Alert-icon', "_coral-UIIcon-".concat(iconName, "Medium")]));
        this._elements.icon = this.querySelector('._coral-Alert-icon');
      }
    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$y); // a11y

        this.setAttribute('role', 'alert'); // Default reflected attributes

        if (!this._variant) {
          this.variant = variant$9.INFO;
        }

        if (!this._size) {
          this.size = size$4.SMALL;
        }

        for (var contentZone in this._contentZones) {
          var element = this._elements[this._contentZones[contentZone]]; // Remove it so we can process children

          if (element.parentNode) {
            element.parentNode.removeChild(element);
          }
        }

        while (this.firstChild) {
          var child = this.firstChild;

          if (child.nodeType === Node.TEXT_NODE || child.nodeType === Node.ELEMENT_NODE && !child.classList.contains('_coral-Alert-icon')) {
            // Add non-template elements to the content
            this._elements.content.appendChild(child);
          } else {
            // Remove anything else element
            this.removeChild(child);
          }
        }

        this._insertTemplate(); // Assign the content zones so the insert functions will be called


        for (var _contentZone in this._contentZones) {
          var contentZoneName = this._contentZones[_contentZone];
          /** @ignore */

          this[contentZoneName] = this._elements[contentZoneName];
        }
      }
    }, {
      key: "variant",
      get: function get() {
        return this._variant || variant$9.INFO;
      },
      set: function set(value) {
        var _this$classList;

        value = transform.string(value).toLowerCase();
        this._variant = validate.enumeration(variant$9)(value) && value || variant$9.INFO;

        this._reflectAttribute('variant', this._variant);

        this._insertTemplate(); // Remove all variant classes


        (_this$classList = this.classList).remove.apply(_this$classList, ALL_VARIANT_CLASSES$6); // Set new variant class
        // Don't use this._className; use the constant
        // This lets popover get our styles for free


        this.classList.add("".concat(CLASSNAME$y, "--").concat(this._variant));
      }
      /**
       The size of the alert. It accepts both lower and upper case sizes. See {@link AlertVariantEnum}.
        @type {String}
       @default AlertSizeEnum.SMALL
       @htmlattribute size
       @htmlattributereflected
       */

    }, {
      key: "size",
      get: function get() {
        return this._size || size$4.SMALL;
      },
      set: function set(value) {
        value = transform.string(value).toUpperCase();
        this._size = validate.enumeration(size$4)(value) && value || size$4.SMALL;

        this._reflectAttribute('size', this._size);
      }
      /**
       The alert header element.
        @type {AlertHeader}
       @contentzone
       */

    }, {
      key: "header",
      get: function get() {
        return this._getContentZone(this._elements.header);
      },
      set: function set(value) {
        this._setContentZone('header', value, {
          handle: 'header',
          tagName: 'coral-alert-header',
          insert: function insert(header) {
            header.classList.add("".concat(CLASSNAME$y, "-header"));
            this.insertBefore(header, this.firstChild);
          }
        });
      }
      /**
       The alert content element.
        @type {AlertContent}
       @contentzone
       */

    }, {
      key: "content",
      get: function get() {
        return this._getContentZone(this._elements.content);
      },
      set: function set(value) {
        this._setContentZone('content', value, {
          handle: 'content',
          tagName: 'coral-alert-content',
          insert: function insert(content) {
            content.classList.add("".concat(CLASSNAME$y, "-content")); // After the header

            this.insertBefore(content, this.header.nextElementSibling);
          }
        });
      }
      /**
       The alert footer element.
        @type {AlertFooter}
       @contentzone
       */

    }, {
      key: "footer",
      get: function get() {
        return this._getContentZone(this._elements.footer);
      },
      set: function set(value) {
        this._setContentZone('footer', value, {
          handle: 'footer',
          tagName: 'coral-alert-footer',
          insert: function insert(footer) {
            footer.classList.add("".concat(CLASSNAME$y, "-footer")); // After the content

            this.insertBefore(footer, this.content.nextElementSibling);
          }
        });
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-alert-header': 'header',
          'coral-alert-content': 'content',
          'coral-alert-footer': 'footer'
        };
      }
      /**
       Returns {@link Alert} variants.
        @return {AlertVariantEnum}
       */

    }], [{
      key: "variant",
      get: function get() {
        return variant$9;
      }
      /**
       Returns {@link Alert} sizes.
        @return {AlertSizeEnum}
       */

    }, {
      key: "size",
      get: function get() {
        return size$4;
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['variant', 'size']);
      }
    }]);

    return _class;
  }(BaseComponent(HTMLElement)));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Alert.Header
   @classdesc The Alert header content
   @htmltag coral-alert-header
   @return {HTMLElement}
   */
  var AlertHeader = (function () {
    return document.createElement('coral-alert-header');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Alert.Content
   @classdesc The Alert default content
   @htmltag coral-alert-content
   @return {HTMLElement}
   */
  var AlertContent = (function () {
    return document.createElement('coral-alert-content');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Alert.Footer
   @classdesc The Alert footer content
   @htmltag coral-alert-footer
   @return {HTMLElement}
   */
  var AlertFooter = (function () {
    return document.createElement('coral-alert-footer');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons._define('coral-alert', Alert);

  Alert.Header = AlertHeader;
  Alert.Content = AlertContent;
  Alert.Footer = AlertFooter;

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var translations$a = {
    "en-US": {
      "No matching results&period;": "No matching results.",
      "Show suggestion": "Show suggestion",
      "Show {0} suggestions": "Show {0} suggestions",
      "Show suggestions": "Show suggestions"
    },
    "de-DE": {
      "No matching results&period;": "Keine passenden Ergebnisse.",
      "Show suggestion": "Vorschlag anzeigen",
      "Show {0} suggestions": "{0} Vorschläge anzeigen",
      "Show suggestions": "Vorschläge anzeigen"
    },
    "es-ES": {
      "No matching results&period;": "No hay resultados coincidentes.",
      "Show suggestion": "Mostrar sugerencia",
      "Show {0} suggestions": "Mostrar {0} sugerencias",
      "Show suggestions": "Mostrar sugerencias"
    },
    "ko-KR": {
      "No matching results&period;": "일치하는 결과가 없습니다.",
      "Show suggestion": "제안 사항 표시",
      "Show {0} suggestions": "{0}제안 사항 표시",
      "Show suggestions": "제안 사항 표시"
    },
    "fr-FR": {
      "No matching results&period;": "Aucun résultat correspondant.",
      "Show suggestion": "Afficher la suggestion",
      "Show {0} suggestions": "Afficher {0} suggestions",
      "Show suggestions": "Afficher les suggestions"
    },
    "ja-JP": {
      "No matching results&period;": "一致する結果がありません。",
      "Show suggestion": "入力候補を表示",
      "Show {0} suggestions": "{0}入力候補を表示",
      "Show suggestions": "入力候補を表示"
    },
    "zh-CN": {
      "No matching results&period;": "无匹配的结果。",
      "Show suggestion": "显示建议",
      "Show {0} suggestions": "显示 {0} 个建议",
      "Show suggestions": "显示建议"
    },
    "zh-TW": {
      "No matching results&period;": "沒有相符的結果。",
      "Show suggestion": "顯示建議",
      "Show {0} suggestions": "顯示 {0} 個建議",
      "Show suggestions": "顯示建議"
    },
    "pt-BR": {
      "No matching results&period;": "Nenhum resultado correspondente.",
      "Show suggestion": "Mostrar sugestão",
      "Show {0} suggestions": "Mostrar {0} sugestões",
      "Show suggestions": "Mostrar sugestões"
    },
    "it-IT": {
      "No matching results&period;": "Nessun risultato corrispondente.",
      "Show suggestion": "Mostra suggerimento",
      "Show {0} suggestions": "Mostra {0} suggerimenti",
      "Show suggestions": "Mostra suggerimenti"
    },
    "nl-NL": {
      "No matching results&period;": "Geen overeenkomende resultaten.",
      "Show suggestion": "Voorstel tonen",
      "Show {0} suggestions": "{0} voorstellen tonen",
      "Show suggestions": "Voorstellen tonen"
    },
    "da-DK": {
      "No matching results&period;": "Ingen matchende resultater.",
      "Show suggestion": "Vis forslag",
      "Show {0} suggestions": "Vis  {0} forslag",
      "Show suggestions": "Vis forslag"
    },
    "fi-FI": {
      "No matching results&period;": "Vastaavia tuloksia ei ole.",
      "Show suggestion": "Näytä ehdotus",
      "Show {0} suggestions": "Näytä {0} ehdotusta",
      "Show suggestions": "Näytä ehdotukset"
    },
    "nb-NO": {
      "No matching results&period;": "Ingen tilsvarende resultater.",
      "Show suggestion": "Vis forslag",
      "Show {0} suggestions": "Vis {0} forslag",
      "Show suggestions": "Vis forslag"
    },
    "sv-SE": {
      "No matching results&period;": "Inga matchande resultat.",
      "Show suggestion": "Visa förslag",
      "Show {0} suggestions": "Visa {0} förslag",
      "Show suggestions": "Visa förslag"
    },
    "cs-CZ": {
      "No matching results&period;": "Neodpovídají žádné výsledky.",
      "Show suggestion": "Zobrazit doporučení",
      "Show {0} suggestions": "Zobrazit následující počet návrhů: {0}",
      "Show suggestions": "Zobrazit doporučení"
    },
    "pl-PL": {
      "No matching results&period;": "Brak pasujących wyników.",
      "Show suggestion": "Pokaż sugestię",
      "Show {0} suggestions": "Wyświetl {0} sugestii",
      "Show suggestions": "Pokaż sugestie"
    },
    "ru-RU": {
      "No matching results&period;": "Нет соответствующих результатов.",
      "Show suggestion": "Показать предложение",
      "Show {0} suggestions": "Показать предложения ({0})",
      "Show suggestions": "Показать предложения"
    },
    "tr-TR": {
      "No matching results&period;": "Eşleşen sonuç yok.",
      "Show suggestion": "Öneriyi göster",
      "Show {0} suggestions": "{0} önerilerini göster",
      "Show suggestions": "Önerileri göster"
    }
  };

  /**
   @class Coral.Autocomplete.Item
   @classdesc The Autocomplete Item
   @htmltag coral-autocomplete-item
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var AutocompleteItem = Decorator( /*#__PURE__*/function (_BaseComponent) {
    _inherits(_class, _BaseComponent);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this);
      _this._observer = new MutationObserver(_this._handleMutation.bind(_assertThisInitialized(_this)));

      _this._observer.observe(_assertThisInitialized(_this), {
        characterData: true,
        childList: true,
        subtree: true
      });

      return _this;
    }
    /**
     Value of the item. <code>textContent</code> is used if not provided.
      @type {String}
     @default ""
     @htmlattribute value
     @htmlattributereflected
     */


    _createClass(_class, [{
      key: "_handleMutation",

      /** @private */
      value: function _handleMutation() {
        this.trigger('coral-autocomplete-item:_contentchanged', {
          content: this.textContent
        });
      }
      /** @ignore */

    }, {
      key: "value",
      get: function get() {
        // keep spaces to only 1 max and trim to mimic native select option behavior
        return typeof this._value === 'undefined' ? this.getAttribute('value') || this.textContent.replace(/\s{2,}/g, ' ').trim() : this._value;
      },
      set: function set(value) {
        var _value = transform.string(value);

        if (this._value === _value) {
          return;
        }

        this._value = _value;

        this._reflectAttribute('value', this._value);

        this.trigger('coral-autocomplete-item:_valuechanged');
      } // @compat

    }, {
      key: "content",
      get: function get() {
        return this;
      },
      set: function set(value) {
        // Support configs
        if (_typeof(value) === 'object') {
          for (var prop in value) {
            /** @ignore */
            this[prop] = value[prop];
          }
        }
      }
      /**
       Whether this item is selected.
        @type {Boolean}
       @default false
       @htmlattribute selected
       @htmlattributereflected
       */

    }, {
      key: "selected",
      get: function get() {
        return this._selected || false;
      },
      set: function set(value) {
        var _selected = transform.booleanAttr(value);

        if (this._selected === _selected) {
          return;
        }

        this._selected = _selected;

        this._reflectAttribute('selected', this._selected);

        this.trigger('coral-autocomplete-item:_selectedchanged');
      }
      /**
       Whether this item is disabled.
        @type {Boolean}
       @default false
       @htmlattribute disabled
       @htmlattributereflected
       */

    }, {
      key: "disabled",
      get: function get() {
        return this._disabled || false;
      },
      set: function set(value) {
        this._disabled = transform.booleanAttr(value);

        this._reflectAttribute('disabled', this._disabled);
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['selected', 'disabled', 'value']);
      }
    }]);

    return _class;
  }(BaseComponent(HTMLElement)));

  var template$g = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var data = data_0 = typeof data_0 === "undefined" ? {} : data_0;
    var el0 = this["overlay"] = document.createElement("coral-popover");
    el0.setAttribute("withinoffset", "0");
    el0.setAttribute("smart", "");
    el0.id = data_0["commons"]["getUID"]();
    el0.className += " _coral-Autocomplete-overlay";
    el0.setAttribute("focusonshow", "off");
    el0.setAttribute("returnfocus", "off");
    el0.setAttribute("placement", "bottom");
    el0.setAttribute("handle", "overlay");
    el0.setAttribute("role", "presentation");
    el0.setAttribute("breadthoffset", "50%r - 50%p");
    var el1 = document.createTextNode("\n  ");
    el0.appendChild(el1);
    data = data_0; // Constrains the size of the list to 6 items.
    // @todo move this to theme

    var maxHeight = 'max-height:' + 32 * 6 + 'px';
    data_0 = data;
    var el3 = document.createTextNode("\n  ");
    el0.appendChild(el3);
    var el4 = this["selectList"] = document.createElement("coral-buttonlist");
    el4.setAttribute("style", maxHeight);
    el4.id = data_0["commons"]["getUID"]();
    el4.className += " _coral-Autocomplete-selectList";
    el4.setAttribute("handle", "selectList");
    el4.setAttribute("role", "listbox");
    el4.setAttribute("interaction", "off");
    el0.appendChild(el4);
    var el5 = document.createTextNode("\n");
    el0.appendChild(el5);
    frag.appendChild(el0);
    var el6 = document.createTextNode("\n");
    frag.appendChild(el6);
    var el7 = this["field"] = document.createElement("input");
    el7.setAttribute("type", "hidden");
    el7.setAttribute("handle", "field");
    frag.appendChild(el7);
    var el8 = document.createTextNode("\n");
    frag.appendChild(el8);
    var el9 = this["inputGroup"] = document.createElement("div");
    el9.className += " _coral-InputGroup _coral-Autocomplete-inputGroup";
    el9.setAttribute("handle", "inputGroup");
    el9.setAttribute("role", "presentation");
    var el10 = document.createTextNode("\n  ");
    el9.appendChild(el10);
    var el11 = this["input"] = document.createElement("input", "coral-textfield");
    el11.className += " _coral-InputGroup-field _coral-Autocomplete-input";
    el11.setAttribute("type", "text");
    el11.setAttribute("autocomplete", "off");
    el11.setAttribute("handle", "input");
    el11.setAttribute("role", "combobox");
    el11.setAttribute("is", "coral-textfield");
    el9.appendChild(el11);
    var el12 = document.createTextNode("\n  ");
    el9.appendChild(el12);
    var el13 = this["trigger"] = document.createElement("button", "coral-button");
    el13.setAttribute("type", "button");
    el13.className += " _coral-FieldButton _coral-InputGroup-button _coral-Autocomplete-trigger";
    el13.setAttribute("is", "coral-button");
    el13.setAttribute("variant", "_custom");
    el13.setAttribute("handle", "trigger");
    el13.setAttribute("aria-label", data_0["i18n"]["get"]('Show suggestions'));
    el13.setAttribute("title", data_0["i18n"]["get"]('Show suggestions'));
    var el14 = document.createTextNode("\n    ");
    el13.appendChild(el14);
    var el15 = this["label"] = document.createElement("coral-button-label");
    el15.setAttribute("handle", "label");
    el13.appendChild(el15);
    var el16 = document.createTextNode("\n    ");
    el13.appendChild(el16);
    data = data_0; // Don't wait for button MO to pick up the label

    this.trigger._elements.label = this.label; // Render invalid icon

    this.trigger.insertAdjacentHTML('beforeend', data.Icon._renderSVG('spectrum-css-icon-ChevronDownMedium', ['_coral-InputGroup-icon', '_coral-UIIcon-ChevronDownMedium']));
    data_0 = data;
    var el18 = document.createTextNode("\n  ");
    el13.appendChild(el18);
    el9.appendChild(el13);
    var el19 = document.createTextNode("\n");
    el9.appendChild(el19);
    frag.appendChild(el9);
    var el20 = document.createTextNode("\n");
    frag.appendChild(el20);
    var el21 = this["tagList"] = document.createElement("coral-taglist");
    el21.className += " _coral-Autocomplete-tagList";
    el21.setAttribute("handle", "tagList");
    frag.appendChild(el21);
    var el22 = document.createTextNode("\n");
    frag.appendChild(el22);
    return frag;
  };

  var template$h = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["loadIndicator"] = document.createElement("div");
    el0.className += " _coral-SelectList-loading";
    el0.setAttribute("handle", "loadIndicator");
    var el1 = document.createTextNode("\n  ");
    el0.appendChild(el1);
    var el2 = document.createElement("coral-wait");
    el2.setAttribute("centered", "");
    el0.appendChild(el2);
    var el3 = document.createTextNode("\n");
    el0.appendChild(el3);
    frag.appendChild(el0);
    var el4 = document.createTextNode("\n");
    frag.appendChild(el4);
    return frag;
  };

  var CLASSNAME$z = '_coral-Autocomplete';
  /**
   The distance, in pixels, from the bottom of the List at which we assume the user has scrolled
   to the bottom of the list.
   @type {Number}
   @ignore
   */

  var SCROLL_BOTTOM_THRESHOLD$1 = 50;
  /**
   The number of milliseconds for which scroll events should be debounced.
   @type {Number}
   @ignore
   */

  var SCROLL_DEBOUNCE$1 = 100;
  /**
   Enumeration for {@link Autocomplete} variants.

   @typedef {Object} AutocompleteVariantEnum

   @property {String} DEFAULT
   A default, gray Autocomplete.
   @property {String} QUIET
   An Autocomplete with no border or background.
   */

  var variant$a = {
    DEFAULT: 'default',
    QUIET: 'quiet'
  };
  /**
   Enumeration for {@link Autocomplete} match options.

   @typedef {Object} AutocompleteMatchEnum

   @property {String} STARTSWITH
   Include only matches that start with the user provided value.
   @property {String} CONTAINS
   Include only matches that contain the user provided value.
   */

  var match$1 = {
    STARTSWITH: 'startswith',
    CONTAINS: 'contains'
  };
  /**
   @class Coral.Autocomplete
   @classdesc An Autocomplete component that allows users to search and select from a list of options.
   @htmltag coral-autocomplete
   @extends {HTMLElement}
   @extends {BaseComponent}
   @extends {BaseFormField}
   */

  var Autocomplete = Decorator( /*#__PURE__*/function (_BaseFormField) {
    _inherits(_class, _BaseFormField);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this); // Template

      _this._elements = {};
      template$g.call(_this._elements, {
        Icon: Icon,
        commons: commons,
        i18n: i18n
      });

      _this._elements.tagList.reset = function () {// Kill inner tagList reset so it doesn't interfer with the autocomplete reset
      }; // Pre-define labellable element


      _this._labellableElement = _this._elements.input;
      var overlayId = _this._elements.overlay.id;
      var events = {
        // ARIA Autocomplete role keyboard interaction
        // http://www.w3.org/TR/wai-aria-practices/#autocomplete
        'key:up [handle="input"]': '_handleInputUpKeypress',
        'key:alt+up [handle="input"]': '_handleInputUpKeypress',
        'key:down [handle="input"]': '_handleInputDownKeypress',
        'key:alt+down [handle="input"]': '_handleInputDownKeypress',
        'key:tab [handle="input"]': '_handleInputTabKeypress',
        'key:shift+tab [handle="input"]': '_handleListFocusShift',
        'capture:change [handle="input"]': '_handleInput',
        'input [handle="input"]': '_handleInputEvent',
        // Manually listen to keydown event due to CUI-3973
        'keydown': '_handleInputKeypressEnter',
        // Interaction
        'click [handle="trigger"]': '_handleTriggerClick',
        'mousedown [handle="trigger"]': '_handleTriggerMousedown',
        // Focus
        'capture:blur': '_handleFocusOut',
        'global:click': '_onGlobalClick',
        'global:touchstart': '_onGlobalClick',
        // Taglist
        'coral-collection:add [handle="tagList"]': '_handleTagAdded',
        'coral-collection:remove [handle="tagList"]': '_handleTagRemoved',
        'change [handle="tagList"]': '_preventTagListChangeEvent',
        // Items
        'coral-autocomplete-item:_valuechanged': '_handleItemValueChange',
        'coral-autocomplete-item:_selectedchanged': '_handleItemSelectedChange',
        'coral-autocomplete-item:_contentchanged': '_handleItemContentChange'
      }; // Interaction

      events["global:key:shift+tab #".concat(overlayId, " [is=\"coral-buttonlist-item\"]")] = '_handleListFocusShift';
      events["global:key:esc"] = '_handleListFocusShift'; // Overlay

      events["global:capture:coral-overlay:positioned #".concat(overlayId)] = '_onOverlayPositioned';
      events["global:capture:coral-overlay:open #".concat(overlayId)] = '_onOverlayOpenOrClose';
      events["global:capture:coral-overlay:close #".concat(overlayId)] = '_onOverlayOpenOrClose'; // SelectList

      events["global:key:enter #".concat(overlayId, " button[is=\"coral-buttonlist-item\"]")] = '_handleSelect';
      events["global:capture:mousedown #".concat(overlayId, " button[is=\"coral-buttonlist-item\"]")] = '_handleSelect';
      events["global:capture:scroll #".concat(overlayId, " [handle=\"selectList\"]")] = '_onScroll';
      events["global:capture:mousewheel #".concat(overlayId, " [handle=\"selectList\"]")] = '_onMouseWheel';
      events["global:capture:mousedown #".concat(overlayId, " [handle=\"selectList\"]")] = '_onMouseDown'; // Events

      _this._delegateEvents(events); // A map of values to tags


      _this._tagMap = {}; // A list of selected values

      _this._values = []; // A list of options objects

      _this._options = []; // A map of option values to their content

      _this._optionsMap = {}; // Used for reset

      _this._initialSelectedValues = []; // Bind the debounced scroll method

      _this._handleScrollBottom = _this._handleScrollBottom.bind(_assertThisInitialized(_this)); // Listen for mutations

      _this._observer = new MutationObserver(_this._handleMutation.bind(_assertThisInitialized(_this)));

      _this._startObserving();

      return _this;
    }
    /**
     Returns the inner overlay to allow customization.
      @type {Popover}
     @readonly
     */


    _createClass(_class, [{
      key: "_getName",

      /** @private */
      value: function _getName() {
        if (this.multiple) {
          return this._elements.tagList.name;
        }

        return this._elements.field.name;
      }
      /**
       Set the name accordingly for multiple/single mode so the form submits contain only the right fields.
        @private
       */

    }, {
      key: "_setName",
      value: function _setName(value) {
        if (this.multiple) {
          this._elements.tagList.name = value;
          this._elements.field.name = '';
        } else {
          this._elements.field.name = value;
          this._elements.tagList.name = '';
        }
      }
      /** @private */

    }, {
      key: "_startObserving",
      value: function _startObserving() {
        this._observer.observe(this, {
          // Only watch the childList
          // Items will tell us if selected/value/content changes
          childList: true
        });
      }
      /**
       Stop watching for mutations. This should be done before manually updating observed properties.
        @protected
       */

    }, {
      key: "_stopObserving",
      value: function _stopObserving() {
        this._observer.disconnect();
      } // Override to do nothing

    }, {
      key: "_onInputChange",
      value: function _onInputChange(event) {
        // stops the current event
        event.stopPropagation();

        if (!this.multiple) {
          var inputText = this._elements.input.value.toLowerCase();

          if (this.forceSelection || inputText === '') {
            // We need a way to deselect item in single selection mode
            // 1) by using an empty string if this.forceSelection === false
            // 2) by using an invalid string if this.forceSelection === true
            var items = this.items.getAll();

            for (var i = 0; i < items.length; i++) {
              if (items[i].value.toLowerCase() !== inputText) {
                items[i].selected = false;
              }
            }
          }
        }
      }
      /**
       Handle mutations to children and childList. This is used to keep the options in sync with DOM changes.
        @private
       */

    }, {
      key: "_handleMutation",
      value: function _handleMutation(mutations) {
        for (var i = 0; i < mutations.length; i++) {
          var mutation = mutations[i];
          var target = mutation.target;

          if (mutation.type === 'childList' && target === this) {
            this._setStateFromDOM();

            return;
          }
        }
      }
      /**
       Update the option set and selected options from the DOM.
        @private
       */

    }, {
      key: "_setStateFromDOM",
      value: function _setStateFromDOM() {
        this._createOptionsFromDOM();

        this._setSelectedFromDOM();
      }
      /**
       Create the set of options from nodes in the DOM.
        @private
       */

    }, {
      key: "_createOptionsFromDOM",
      value: function _createOptionsFromDOM() {
        var _this2 = this;

        // Reset options array and value to content map
        this._options.length = 0;
        this._optionsMap = {};
        this.items.getAll().forEach(function (item) {
          // Don't use properties as children may not be initialized yet
          var itemObj = {
            value: item.getAttribute('value'),
            icon: item.getAttribute('icon'),
            disabled: item.hasAttribute('disabled'),
            content: item.innerHTML.replace(/\s{2,}/g, ' ').trim(),
            text: item.innerText
          };

          _this2._options.push(itemObj);

          _this2._optionsMap[itemObj.value] = itemObj;
        }); // @todo update value in hidden field if changed value = old value?
      }
      /** @private */

    }, {
      key: "_setInputValues",
      value: function _setInputValues(value, content) {
        this._elements.field.value = value; // Set text into input if in "multiple selection mode" or in "single selection mode and content is not empty"
        // otherwise keep the current text for us (should be marked red)

        if (this.multiple || content !== '') {
          this._elements.input.value = content.trim();
        }
      }
      /** @private */

    }, {
      key: "_reflectCurrentValue",
      value: function _reflectCurrentValue() {
        // Use empty string if no values
        var value = this._values.length > 0 ? this._values[0] : ''; // Reflect the value in the field for form submit

        this._elements.field.value = value;
        var content = '';

        if (value !== '') {
          // Find the object with the corresponding content
          var itemObj = this._optionsMap[value];

          if (itemObj) {
            // Reflect the content in the input

            /*
              prefence would be first given to innerText instead of innerHtml
              as special characters like '&' transformed as ;amp in case of innerHtml.
            */
            content = itemObj.text && itemObj.text !== '' ? itemObj.text : itemObj.content;
          } else {
            // Just use the provided value
            content = value;
          }
        }

        this._setInputValues(value, content);
      }
      /**
       Update the option set and selected options from the DOM
       @ignore
       */

    }, {
      key: "_setSelectedFromDOM",
      value: function _setSelectedFromDOM() {
        var selectedItems = this.selectedItems;

        if (selectedItems.length) {
          // Use this.hasAttribute('multiple') instead of this.multiple here, as this method is called from _render and element might not be ready
          if (this.hasAttribute('multiple')) {
            // Remove current tags
            this._resetValues(); // Add new ones


            for (var i = 0; i < selectedItems.length; i++) {
              var value = selectedItems[i].getAttribute('value');
              var content = selectedItems[i].innerHTML;

              this._addValue(value, content, true);
            }
          } else {
            // Select last
            var last = selectedItems[selectedItems.length - 1]; // Deselect others

            this._deselectExcept(last, selectedItems); // Set value from the attribute
            // We don't want to use the property as the sub-component may not have been upgraded yet


            this.value = last.getAttribute('value');
          }
        } else if (!this.hasAttribute('value')) {
          if (this.hasAttribute('multiple')) {
            this._resetValues();
          } else {
            this.value = '';
          }
        }
      }
      /**
       De-select every item except the provided item.
        @param {HTMLElement} exceptItem
       The item not to select
       @param {Array.<HTMLElement>} [items]
       The set of items to consider when deselecting. If not provided, the current set of selected items is used.
        @private
       */

    }, {
      key: "_deselectExcept",
      value: function _deselectExcept(exceptItem, items) {
        var selectedItems = items || this.selectedItems; // Deselect others

        this._stopObserving();

        for (var i = 0; i < selectedItems.length; i++) {
          if (selectedItems[i] !== exceptItem) {
            selectedItems[i].removeAttribute('selected');
          }
        }

        this._startObserving();
      }
      /**
       Add a tag to the taglist.
        @private
       */

    }, {
      key: "_addValue",
      value: function _addValue(value, content, asHTML) {
        if (!content) {
          // Find the content
          var itemObj = this._optionsMap[value];

          if (itemObj) {
            content = itemObj.content;
          } else {
            // Just use the value
            content = value;
          }
        } // Add to selected values


        var index = this._values.indexOf(value);

        if (index === -1) {
          this._values.push(value);
        }

        var labelContent = {};

        if (asHTML) {
          labelContent.innerHTML = content;
        } else {
          labelContent.textContent = content;
        } // Create a new tag


        var tag = new Tag().set({
          label: labelContent,
          value: value
        }); // Add to map

        this._tagMap[value] = tag; // Add to taglist

        this._elements.tagList.items.add(tag); // make sure to remove text from input box (to easily choose next item)


        this._setInputValues('', '');
      }
      /**
       Remove a tag from the taglist.
        @private
       */

    }, {
      key: "_removeValue",
      value: function _removeValue(value) {
        // Remove from selected values
        var index = this._values.indexOf(value);

        if (index === -1) {
          // Get out if we don't have the value
          return;
        }

        this._values.splice(index, 1); // Select autocomplete item


        var item = this.querySelector("coral-autocomplete-item[value=".concat(JSON.stringify(value), "]"));

        if (item) {
          if (item.hasAttribute('selected')) {
            this._stopObserving();

            item.removeAttribute('selected');

            this._startObserving();
          }
        } // Look up the tag by value


        var tag = this._tagMap[value];

        if (tag) {
          // Remove from map
          this._tagMap[value] = null; // Remove from taglist

          this._elements.tagList.items.remove(tag);
        }

        if (index !== -1) {
          // Emit the change event when a value is removed but only after a user interaction
          this.trigger('change');
        }
      }
      /**
       Remove all tags from the taglist.
        @private
       */

    }, {
      key: "_clearValues",
      value: function _clearValues() {
        this._resetValues(); // Deselect items


        this._stopObserving();

        var items = this.querySelectorAll('coral-autocomplete-item[selected]');

        for (var i = 0; i < items.length; i++) {
          items[i].removeAttribute('selected');
        }

        this._startObserving();
      }
      /**
       Reset values without affecting the DOM.
        @private
       */

    }, {
      key: "_resetValues",
      value: function _resetValues() {
        // Reset values
        this._values = []; // Drop references to tags

        this._tagMap = {}; // Clear taglist

        this._elements.tagList.items.clear();
      }
      /** @private */

    }, {
      key: "_focusNextItem",
      value: function _focusNextItem() {
        var _this3 = this;

        // Display focus on next item in the selectList
        var selectList = this._elements.selectList;
        var currentItem = selectList.querySelector('.is-focused');
        var input = this._elements.input;

        var items = selectList._getSelectableItems();

        var index;
        var item;

        if (currentItem) {
          index = items.indexOf(currentItem);

          if (index < items.length - 1) {
            item = items[index + 1];
          }
        } else if (items && items.length > 0) {
          item = items[0];
        }

        window.requestAnimationFrame(function () {
          if (item) {
            if (currentItem) {
              currentItem.classList.remove('is-focused');
            }

            _this3._scrollItemIntoView(item);

            item.classList.add('is-focused');
            input.setAttribute('aria-activedescendant', item.id);
          }

          if (!selectList.querySelector('.is-focused')) {
            input.removeAttribute('aria-activedescendant');
          }
        });
      }
      /** @private */

    }, {
      key: "_focusPreviousItem",
      value: function _focusPreviousItem() {
        var _this4 = this;

        // Display focus on previous item in the selectList
        var selectList = this._elements.selectList;
        var currentItem = selectList.querySelector('.is-focused');
        var input = this._elements.input;

        var items = selectList._getSelectableItems();

        var index;
        var item;

        if (currentItem) {
          index = items.indexOf(currentItem);

          if (index > 0) {
            item = items[index - 1];
          }

          currentItem.classList.remove('is-focused');
        } else if (items && items.length > 0) {
          item = items[items.length - 1];
        }

        window.requestAnimationFrame(function () {
          if (item) {
            _this4._scrollItemIntoView(item);

            item.classList.add('is-focused');
            input.setAttribute('aria-activedescendant', item.id);
          }

          if (!selectList.querySelector('.is-focused')) {
            input.removeAttribute('aria-activedescendant');
          }
        });
      }
      /** @private */

    }, {
      key: "_showSuggestions",
      value: function _showSuggestions() {
        // Get value from the input
        var inputValue = this._elements.input.value.toLowerCase().trim(); // Since we're showing fresh suggestions, clear the existing suggestions


        this.clearSuggestions(); // Trigger an event

        var event = this.trigger('coral-autocomplete:showsuggestions', {
          // Pass user input
          value: inputValue,
          // Started at zero here, always
          start: 0
        }); // Flag to indicate that the private method is called before public showSuggestions method

        this._showSuggestionsCalled = true;

        if (event.defaultPrevented) {
          // Set loading mode
          this.loading = true; // Show the menu

          this.showSuggestions();
        } else {
          // Show suggestions that match in the DOM
          this.addSuggestions(this._getMatches(inputValue, this._optionContainsValue));
          this.showSuggestions();
        }
      }
    }, {
      key: "_onOverlayPositioned",
      value: function _onOverlayPositioned(event) {
        // stops propagation cause the event is internal to the component
        event.stopImmediatePropagation();

        if (this._elements.overlay.open) {
          this._elements.overlay.style.width = "".concat(this.offsetWidth, "px");
        }
      }
    }, {
      key: "_onGlobalClick",
      value: function _onGlobalClick(event) {
        if (!this._elements.overlay.open) {
          return;
        }

        var eventTargetWithinOverlayTarget = this._elements.inputGroup.contains(event.target);

        var eventTargetWithinItself = this._elements.overlay.contains(event.target);

        if (!eventTargetWithinOverlayTarget && !eventTargetWithinItself) {
          this.hideSuggestions();
        }
      }
      /** @private */

    }, {
      key: "_onScroll",
      value: function _onScroll() {
        this._isOverlayScrolling = true;
        window.clearTimeout(this._scrollTimeout);
        this._scrollTimeout = window.setTimeout(this._handleScrollBottom, SCROLL_DEBOUNCE$1);
      }
      /** @private */

    }, {
      key: "_onMouseWheel",
      value: function _onMouseWheel(event) {
        var selectList = this._elements.selectList; // If scrolling with mouse wheel and if it has hit the top or bottom boundary
        // `SCROLL_BOTTOM_THRESHOLD` is ignored when hitting scroll bottom to allow debounced loading

        if (event.deltaY < 0 && selectList.scrollTop === 0 || event.deltaY > 0 && selectList.scrollTop >= selectList.scrollHeight - selectList.clientHeight) {
          event.preventDefault();
        }
      }
    }, {
      key: "_onMouseDown",
      value: function _onMouseDown(event) {
        this._isOverlayScrollBarClicked = event.matchedTarget.clientWidth <= event.offsetX;
      }
      /** @private */

    }, {
      key: "_handleScrollBottom",
      value: function _handleScrollBottom() {
        var selectList = this._elements.selectList;

        if (selectList.scrollTop >= selectList.scrollHeight - selectList.clientHeight - SCROLL_BOTTOM_THRESHOLD$1) {
          var inputValue = this._elements.input.value; // Do not clear the suggestions here, instead we'll expect them to append
          // Trigger an event

          var event = this.trigger('coral-autocomplete:showsuggestions', {
            // Pass user input
            value: inputValue,
            start: selectList.items.length
          });

          if (event.defaultPrevented) {
            // Set loading mode
            this.loading = true;
          }
        }
      }
      /** @private */

    }, {
      key: "_handleFocusOut",
      value: function _handleFocusOut(event) {
        var _this5 = this;

        var selectList = this._elements.selectList;
        var target = event.target;
        var inputBlur = target === this._elements.input;

        if (this._blurTimeout) {
          clearTimeout(this._blurTimeout);
        } // This is to hack around the fact that you cannot determine which element gets focus in a blur event
        // Firefox doesn't support focusout/focusin, so we're left doing awful things


        this._blurTimeout = window.setTimeout(function () {
          var relatedTarget = document.activeElement;
          var focusOutside = !_this5.contains(relatedTarget) && !_this5._elements.overlay.contains(relatedTarget); // If focus has moved out of the autocomplete, it's an input event

          if (inputBlur && focusOutside && !_this5.multiple) {
            _this5._handleInput(event);
          } // Nothing was focused
          else if (!relatedTarget || (inputBlur || relatedTarget !== document.body) && // Focus is now outside of the autocomplete component
            focusOutside || // Focus has shifted from the selectList to another element inside of the autocomplete component
            selectList.contains(target) && !selectList.contains(relatedTarget)) {
              _this5.hideSuggestions();
            }
        }, 0);
      }
      /** @private */

    }, {
      key: "_handleListFocusShift",
      value: function _handleListFocusShift(event) {
        if (this._elements.overlay.open) {
          // Stop focus shift
          event.preventDefault();
          event.stopImmediatePropagation();

          this._hideSuggestionsAndFocus();
        }
      }
      /** @private */

    }, {
      key: "_hideSuggestionsAndFocus",
      value: function _hideSuggestionsAndFocus() {
        // Hide the menu and focus on the input
        this.hideSuggestions();

        this._elements.input.focus();
      }
      /** @private */

    }, {
      key: "_handleTriggerClick",
      value: function _handleTriggerClick() {
        if (this._elements.overlay.classList.contains('is-open')) {
          this._hideSuggestionsAndFocus();
        } else {
          // Focus on the input so down arrow works as expected
          // Per @mijordan
          this._showSuggestions();

          this._elements.input.focus();
        }
      }
      /** @private */

    }, {
      key: "_handleTriggerMousedown",
      value: function _handleTriggerMousedown() {
        this._elements.trigger.focus();
      }
      /** @private */

    }, {
      key: "_handleListItemFocus",
      value: function _handleListItemFocus(event) {
        var item = event.matchedTarget;
        var selectList = this._elements.selectList;
        var currentItem = selectList.querySelector('.is-focused');
        var input = this._elements.input;

        if (currentItem) {
          currentItem.classList.remove('is-focused');
          input.removeAttribute('aria-activedescendant');
        }

        if (!item.disabled) {
          this._scrollItemIntoView(item);

          item.classList.add('is-focused');
          input.setAttribute('aria-activedescendant', item.id);
        }
      }
      /** @private */

    }, {
      key: "_scrollItemIntoView",
      value: function _scrollItemIntoView(item) {
        var itemRect = item.getBoundingClientRect();

        var selectListRect = this._elements.selectList.getBoundingClientRect();

        if (itemRect.top < selectListRect.top) {
          item.scrollIntoView();
        } else if (itemRect.bottom > selectListRect.bottom) {
          item.scrollIntoView(false);
        }
      }
      /** @private */

    }, {
      key: "_getMatches",
      value: function _getMatches(value, optionMatchesValue) {
        optionMatchesValue = optionMatchesValue || this._matchFunction;
        var matches = [];

        for (var i = 0; i < this._options.length; i++) {
          if (optionMatchesValue(this._options[i], value)) {
            matches.push(this._options[i]);
          }
        }

        if (!matches.length) {
          // If there are no matches in _options,
          // Check for matches in list, which could have been added after mounting the element
          var buttons = this._elements.selectList.items.getAll();

          for (var _i = 0; _i < buttons.length; _i++) {
            var option = {
              value: buttons[_i].value,
              content: buttons[_i].textContent.trim()
            };

            if (optionMatchesValue(option, value)) {
              matches.push(option);
            }
          }
        }

        return matches;
      }
      /** @private */

    }, {
      key: "_handleInputKeypressEnter",
      value: function _handleInputKeypressEnter(event) {
        // Sigh, CUI-3973 Hitting enter quickly after typing causes form to submit
        if (event.which === 13) {
          this._handleInput(event);
        }
      }
      /** @private */

    }, {
      key: "_handleInputEvent",
      value: function _handleInputEvent() {
        // Any input makes this valid again
        this.invalid = false;

        if (this.delay) {
          // Wait until the use has stopped typing for delay milliseconds before getting suggestions
          window.clearTimeout(this._timeout);
          this._timeout = window.setTimeout(this._showSuggestions.bind(this), this.delay);
        } else {
          // Immediately get suggestions
          this._showSuggestions();
        }
      }
      /** @private */

    }, {
      key: "_handleInput",
      value: function _handleInput(event) {
        // Don't set value and hide suggestions while scrolling overlay
        if (this._isOverlayScrolling || this._isOverlayScrollBarClicked) {
          this._isOverlayScrolling = false;
          this._isOverlayScrollBarClicked = false;
          return;
        } // Stop the event


        event.preventDefault();
        var focusedItemValue; // If a selectList item has focus, set the input value to the value of the selected item.

        if (this._elements.overlay.open && this._elements.input.getAttribute('aria-activedescendant')) {
          var focusedItem = this._elements.selectList.querySelector('.is-focused');

          if (focusedItem) {
            // Use the text content value of the item for comparison
            focusedItemValue = focusedItem.textContent.trim();
          }
        }

        var value = focusedItemValue || this._elements.input.value;
        var isChange = false; // Get all exact matches

        var exactMatches = this._getMatches(value, this._optionEqualsValue);

        if (exactMatches.length) {
          // Find perfect case sensitive match else defaults to first one
          var exactMatch = exactMatches.filter(function (option) {
            return option.content === value;
          })[0] || exactMatches[0];
          isChange = this.value !== exactMatch.value; // Select the matched item

          this._selectItem(exactMatch.value, exactMatch.content, false);

          if (this.multiple) {
            if (value.trim()) {
              // Add tag for non-empty values
              this._addValue(exactMatch.value, exactMatch.content, false);
            }
          } else {
            // Set value
            this.value = exactMatch.value;
          } // value can't be invalid as an exact match is selected


          if (this.forceSelection) {
            this.invalid = false;
          } // Hide the suggestions so the result can be seen


          this.hideSuggestions(); // Emit the change event when a selection is made from an exact match

          if (isChange === true) {
            this.trigger('change');
          }
        } else if (this.forceSelection) {
          // Invalid
          if (this.multiple) {
            this.invalid = value !== '' || this.values.length === 1 && this.values[0] === '' || this.values.length === 0;
          } else {
            this.invalid = true;
          } // Leave suggestions open if nothing matches

        } else {
          // DO NOT select the corresponding item, as this would add an item
          // This would result in adding items that match what the user typed, resulting in selections
          // this._selectItem(value);
          isChange = this.value !== value;

          if (this.multiple) {
            if (value.trim()) {
              // Add tag for non-empty values
              this._addValue(value, null, false);
            }
          } else {
            // Set value
            this.value = value;
          } // Hide the suggestions so the result can be seen


          this.hideSuggestions(); // Emit the change event when arbitrary data is entered

          if (isChange === true) {
            this.trigger('change');
          }
        }

        this._updateButtonAccessibilityLabel();
      }
      /**
       This ensures the collection API is up to date with selected items, even if they come from suggestions.
        @private
       */

    }, {
      key: "_selectItem",
      value: function _selectItem(value, content, asHTML) {
        // Don't get caught up with internal changes
        this._stopObserving(); // Select autocomplete item if it's there


        var item = this.querySelector("coral-autocomplete-item[value=".concat(JSON.stringify(value), "]"));

        if (item) {
          // Select the existing item
          item.setAttribute('selected', '');
        } else {
          var labelContent = {};
          content = typeof content === 'undefined' ? value : content;

          if (asHTML) {
            labelContent.innerHTML = content;
          } else {
            labelContent.textContent = content;
          } // Add a new, selected item


          this.items.add(new AutocompleteItem().set({
            value: value,
            content: labelContent,
            selected: true
          }));
        } // Resume watching for changes


        this._startObserving();
      }
      /** @private */

    }, {
      key: "_handleInputUpKeypress",
      value: function _handleInputUpKeypress(event) {
        // Stop any consequences of pressing the key
        event.preventDefault();

        if (this._elements.overlay.open) {
          if (event.altKey) {
            this.hideSuggestions();
          } else {
            this._focusPreviousItem();
          }
        } else {
          // Show the menu and do not focus on the first item
          // Implements behavior of http://www.w3.org/TR/wai-aria-practices/#autocomplete
          this._showSuggestions();
        }
      }
      /** @private */

    }, {
      key: "_handleInputDownKeypress",
      value: function _handleInputDownKeypress(event) {
        // Stop any consequences of pressing the key
        event.preventDefault();

        if (this._elements.overlay.open) {
          this._focusNextItem();
        } else {
          // Show the menu and do not focus on the first item
          // Implements behavior of http://www.w3.org/TR/wai-aria-practices/#autocomplete
          this._showSuggestions();
        }
      }
      /** @private */

    }, {
      key: "_handleInputTabKeypress",
      value: function _handleInputTabKeypress(event) {
        // if the select list is open and a list item has focus, prevent default to trap focus.
        if (this._elements.overlay.open && this._elements.input.getAttribute('aria-activedescendant')) {
          event.preventDefault();
        }
      }
      /**
       Handle selections in the selectList.
        @ignore
       */

    }, {
      key: "_handleSelect",
      value: function _handleSelect(event) {
        var _this6 = this;

        var selectListItem = event.matchedTarget;

        if (!selectListItem || selectListItem.disabled) {
          // @todo it doesn't seem like this should ever happen, but it does
          return;
        } // Select the corresponding item, or add one if it doesn't exist


        this._selectItem(selectListItem.value, selectListItem.content.innerHTML, true);

        if (!this.multiple) {
          this.value = selectListItem.value; // Make sure the value is changed
          // The setter won't run if we set the same value again
          // This forces the DOM to update

          this._setInputValues(this.value, selectListItem.content.textContent, false);
        } else {
          // Add to values
          this._addValue(selectListItem.value, selectListItem.content.innerHTML, true);
        } // Focus on the input element
        // We have to wait a frame here because the item steals focus when selected


        window.requestAnimationFrame(function () {
          _this6._elements.input.focus();
        }); // Hide the options when option is selected in all cases

        this.hideSuggestions(); // Emit the change event when a selection is made

        this.trigger('change');
      }
      /**
       Don't let the internal change event bubble and confuse users
        @ignore
       */

    }, {
      key: "_preventTagListChangeEvent",
      value: function _preventTagListChangeEvent(event) {
        event.stopImmediatePropagation();
      }
    }, {
      key: "_handleTagAdded",
      value: function _handleTagAdded() {
        // Forces tags to wrap
        this._elements.tagList.style.width = "".concat(this.offsetWidth, "px");
      }
      /**
       Handle tags that are removed by the user.
        @ignore
       */

    }, {
      key: "_handleTagRemoved",
      value: function _handleTagRemoved(event) {
        // Get the tag from the event
        var tagValue = event.detail.item.value; // Remove from values only if there is no other tags with the same value are attached (as this component constantly adds and removes tags)
        // this._elements.tagList.values does not seem to work so iterate over the tags to check values

        var removeValue = true;

        var tags = this._elements.tagList.items.getAll();

        for (var i = 0; i < tags.length; i++) {
          if (tags[i].value === tagValue) {
            removeValue = false;
            break;
          }
        }

        if (removeValue) {
          this._removeValue(tagValue);
        } // If all tags were removed, return focus to the input


        if (this.selectedItems.length === 0) {
          this._elements.input.focus();
        }

        this._updateButtonAccessibilityLabel();
      }
      /**
       Handles value changes on a child item.
        @private
       */

    }, {
      key: "_handleItemValueChange",
      value: function _handleItemValueChange(event) {
        // stop event propogation
        event.stopImmediatePropagation(); // Update option map from scratch
        // @todo use attributeOldValue mutationobserver option and update map instead of re-creating

        this._createOptionsFromDOM();
      }
      /**
       Handles content changes on a child item.
        @private
       */

    }, {
      key: "_handleItemContentChange",
      value: function _handleItemContentChange(event) {
        // stop event propogation
        event.stopImmediatePropagation(); // Update option map from scratch with new content

        this._createOptionsFromDOM();
      }
      /**
       Handles selected changes on a child item.
        @private
       */

    }, {
      key: "_handleItemSelectedChange",
      value: function _handleItemSelectedChange(event) {
        // stop event propogation
        event.stopImmediatePropagation();
        var target = event.target;
        var selected = target.hasAttribute('selected');

        if (this.multiple) {
          this[selected ? '_addValue' : '_removeValue'](target.value, target.content.innerHTML, true);
        } else if (selected) {
          // Set the input text accordingly
          this._elements.input.value = target.content.textContent.replace(/\s{2,}/g, ' ').trim(); // Set the value accordingly

          this.value = target.value; // value can't be invalid as an item is selected

          this.invalid = false; // Deselect the other elements if selected programatically changed

          this._deselectExcept(target);
        } // Remove values if deselected
        // Only do this if we're the current value
        // If the selected item was changed, this.value will be different
        else if (this.value === target.value) {
            this.value = ''; // CUI-5533 Since checks inside of _handleInput will assume the value hasn't change,
            // We need to trigger here

            this.trigger('change');
          }
      }
      /**
       Check if the given option partially matches the given value.
        @param {HTMLElement} option
       The option to test
       @param {String} value
       The value to test
        @returns {Boolean} true if the value matches, false if not.
        @protected
       */

    }, {
      key: "_optionContainsValue",
      value: function _optionContainsValue(option, value) {
        value = (typeof value === 'string' ? value : '').toLowerCase();
        return (option.text || option.content).toLowerCase().indexOf(value) !== -1;
      }
      /**
       Check if the given option starts with the given value.
        @param {HTMLElement} option
       The option to test
       @param {String} value
       The value to test
        @returns {Boolean} true if the value matches, false if not.
        @protected
       */

    }, {
      key: "_optionStartsWithValue",
      value: function _optionStartsWithValue(option, value) {
        value = (typeof value === 'string' ? value : '').toLowerCase();
        return option.content.toLowerCase().trim().indexOf(value) === 0;
      }
      /**
       Check if the given option exactly matches the given value.
        @param {HTMLElement} option
       The option to test
       @param {String} value
       The value to test
        @returns {Boolean} true if the value matches, false if not.
        @protected
       */

    }, {
      key: "_optionEqualsValue",
      value: function _optionEqualsValue(option, value) {
        value = (typeof value === 'string' ? value : '').toLowerCase();
        return option.content.toLowerCase().trim() === value;
      }
      /**
       Updates label on toggle button to communicate number of suggestions in list.
        @param {Number} num
       The number of suggestions available
       @private
       */

    }, {
      key: "_updateButtonAccessibilityLabel",
      value: function _updateButtonAccessibilityLabel(num) {
        var str = i18n.get('Show suggestions');

        if (num === 1) {
          str = i18n.get('Show suggestion');
        } else if (num > 1) {
          str = i18n.get('Show {0} suggestions', num);
        }

        this._elements.trigger.setAttribute('aria-label', str);

        this._elements.trigger.setAttribute('title', str);
      }
      /**
       Clears the current selected value or items.
       */

    }, {
      key: "clear",
      value: function clear() {
        this.value = '';

        this._elements.input.clear();

        if (this.multiple) {
          this._clearValues();
        }
      }
      /**
       Clear the list of suggestions.
       */

    }, {
      key: "clearSuggestions",
      value: function clearSuggestions() {
        this._elements.selectList.items.clear();

        this._updateButtonAccessibilityLabel();
      }
      /**
       A suggestion object.
        @typedef {Object} AutocompleteSuggestion
        @property {String} value
       The form submission value to use when this suggestion is selected.
       @property {String} [content=value]
       The content to disable in the suggestion dropdown.
       */

      /**
       Add the provided list of suggestions and clear loading status.
        @param {Array.<AutocompleteSuggestion>} suggestions
       The list of suggestions to show.
       @param {Boolean} clear
       If true, existing suggestions will be cleared.
       */

    }, {
      key: "addSuggestions",
      value: function addSuggestions(suggestions, clear) {
        // Disable loading mode
        this.loading = false;

        if (clear) {
          // Remove existing selectList items
          this.clearSuggestions();
        } // Add items to the selectlist


        for (var i = 0; i < suggestions.length; i++) {
          var value = suggestions[i].value;
          var content = suggestions[i].content;
          var icon = suggestions[i].icon;
          var disabled = !!suggestions[i].disabled; // Only add the item if it's not a selected value or we're in single mode

          if (!this.multiple || this.values.indexOf(value) === -1) {
            this._elements.selectList.items.add({
              value: value,
              type: 'button',
              icon: icon,
              disabled: disabled,
              id: commons.getUID(),
              tabIndex: -1,
              content: {
                innerHTML: content
              }
            });

            this._elements.selectList.items.last().setAttribute('role', 'option');
          }
        }

        if (!suggestions.length && !this._elements.selectList.items.length) {
          // Show "no results" when no suggestions are found at all
          this._elements.selectList.items.add({
            type: 'button',
            content: {
              innerHTML: "<em>".concat(i18n.get('No matching results.'), "</em>")
            },
            disabled: true
          });

          this._elements.selectList.items.last().setAttribute('role', 'status');

          this._elements.selectList.items.last().setAttribute('aria-live', 'polite');

          this._elements.input.removeAttribute('aria-activedescendant');

          this._updateButtonAccessibilityLabel();
        } else {
          this._updateButtonAccessibilityLabel(this._elements.selectList.items.length);
        }
      }
      /**
       Shows the suggestion UI.
       */

    }, {
      key: "showSuggestions",
      value: function showSuggestions() {
        var _this7 = this;

        if (!this._showSuggestionsCalled) {
          this._showSuggestions();
        } else {
          this._showSuggestionsCalled = false;
        } // Just show


        this._elements.overlay.open = true; // Force overlay repositioning (e.g because of remote loading)

        requestAnimationFrame(function () {
          _this7._elements.overlay._onAnimate();

          _this7._elements.overlay.reposition();
        });

        this._elements.input.setAttribute('aria-expanded', 'true');

        this._elements.trigger.setAttribute('aria-expanded', 'true');
      }
      /**
       Hides the suggestion UI.
       */

    }, {
      key: "hideSuggestions",
      value: function hideSuggestions() {
        this._elements.overlay.open = false;

        this._elements.input.setAttribute('aria-expanded', 'false');

        this._elements.trigger.setAttribute('aria-expanded', 'false');

        this._elements.input.removeAttribute('aria-activedescendant'); // Don't let the suggestions show


        window.clearTimeout(this._timeout); // Trigger an event

        this.trigger('coral-autocomplete:hidesuggestions');
      }
      /**
       Matches the accessibility to the state of the popover.
        @ignore
       */

    }, {
      key: "_onOverlayOpenOrClose",
      value: function _onOverlayOpenOrClose(event) {
        if (this._elements.overlay.open) {
          this._elements.input.setAttribute('aria-expanded', 'true');

          this._elements.trigger.setAttribute('aria-expanded', 'true');
        } else {
          this._elements.input.setAttribute('aria-expanded', 'false');

          this._elements.trigger.setAttribute('aria-expanded', 'false');

          this._elements.input.removeAttribute('aria-activedescendant');
        }
      }
      /**
       Inherited from {@link BaseFormField#reset}.
       */

    }, {
      key: "reset",
      value: function reset() {
        // reset the values to the initial values
        this.values = this._initialSelectedValues;
      }
      /**
       Returns {@link Autocomplete} match options.
        @return {AutocompleteMatchEnum}
       */

    }, {
      key: "connectedCallback",

      /** @ignore */
      value: function connectedCallback() {
        _get(_getPrototypeOf(_class.prototype), "connectedCallback", this).call(this);

        var overlay = this._elements.overlay; // Cannot be open by default when rendered

        overlay.removeAttribute('open'); // Restore in DOM

        if (overlay._parent) {
          overlay._parent.appendChild(overlay);
        }
      }
    }, {
      key: "render",
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$z); // Container role per ARIA Autocomplete

        this.setAttribute('role', 'group'); // Input attributes per ARIA Autocomplete

        this._elements.input.setAttribute('role', 'combobox');

        this._elements.input.setAttribute('aria-autocomplete', 'list');

        this._elements.input.setAttribute('aria-haspopup', 'listbox');

        this._elements.input.setAttribute('aria-expanded', 'false');

        this._elements.input.setAttribute('aria-controls', this._elements.selectList.id); // Trigger button attributes per ARIA Autocomplete


        this._elements.trigger.setAttribute('aria-haspopup', 'listbox');

        this._elements.trigger.setAttribute('aria-expanded', 'false');

        this._elements.trigger.setAttribute('aria-controls', this._elements.selectList.id); // Default reflected attributes


        if (!this._variant) {
          this.variant = variant$a.DEFAULT;
        } // Create a fragment


        var frag = document.createDocumentFragment(); // Render the template

        frag.appendChild(this._elements.field);
        frag.appendChild(this._elements.inputGroup);
        frag.appendChild(this._elements.tagList);
        frag.appendChild(this._elements.overlay);
        this._elements.overlay.target = this._elements.trigger; // Clean up

        while (this.firstChild) {
          var child = this.firstChild; // Only works if all root template elements have a handle attribute

          if (child.nodeType === Node.TEXT_NODE || child.hasAttribute && !child.hasAttribute('handle')) {
            // Add non-template elements to the content
            frag.appendChild(child);
          } else {
            // Remove anything else
            this.removeChild(child);
          }
        } // Append the fragment to the component


        this.appendChild(frag); // Set the state from the DOM when initialized

        this._setStateFromDOM(); // save initial selection (used for reset)


        this._initialSelectedValues = this.values.slice(0);
      }
      /** @ignore */

    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        _get(_getPrototypeOf(_class.prototype), "disconnectedCallback", this).call(this);

        var overlay = this._elements.overlay; // In case it was moved out don't forget to remove it

        if (!this.contains(overlay)) {
          overlay._parent = overlay._repositioned ? document.body : this;
          overlay.remove();
        }
      }
      /**
       Triggered when the {@link Autocomplete} could accept external data to be loaded by the user.
       If <code>preventDefault()</code> is called, then a loading indicator will be shown.
       {@link Autocomplete#loading} should be set to false to indicate that the data has been successfully loaded.
        @typedef {CustomEvent} coral-autocomplete:showsuggestions
        @property {String} detail.value
       The user input.
       */

      /**
       Triggered when the {@link Autocomplete} hides the suggestions.
       This is typically used to cancel a load request because the suggestions will not be shown anymore.
        @typedef {CustomEvent} coral-autocomplete:hidesuggestions
       */

    }, {
      key: "overlay",
      get: function get() {
        return this._elements.overlay;
      }
      /**
       The item collection.
        @type {SelectableCollection}
       @readonly
       */

    }, {
      key: "items",
      get: function get() {
        // Construct the collection on first request:
        if (!this._items) {
          this._items = new SelectableCollection({
            itemTagName: 'coral-autocomplete-item',
            host: this
          });
        }

        return this._items;
      }
      /**
       Indicates if the autocomplete is a single or multiple mode. In multiple mode, the user can select multiple
       values.
        @type {Boolean}
       @default false
       @htmlattribute multiple
       @htmlattributereflected
       */

    }, {
      key: "multiple",
      get: function get() {
        return this._multiple || false;
      },
      set: function set(value) {
        this._multiple = transform.booleanAttr(value);

        this._reflectAttribute('multiple', this._multiple);

        this._setName(this.name);

        if (this._multiple) {
          this._elements.tagList.hidden = false;
        } else {
          this._elements.tagList.hidden = true;

          this._elements.tagList.items.clear();
        }

        this.labelledBy = this.labelledBy;
      }
      /**
       Amount of time, in milliseconds, to wait after typing a character before the suggestion is shown.
        @type {Number}
       @default 200
       @htmlattribute delay
       */

    }, {
      key: "delay",
      get: function get() {
        return typeof this._delay === 'number' ? this._delay : 200;
      },
      set: function set(value) {
        value = transform.number(value);

        if (typeof value === 'number' && value >= 0) {
          this._delay = transform.number(value);
        }
      }
      /**
       Set to <code>true</code> to restrict the selected value to one of the given options from the suggestions.
       When set to <code>false</code>, users can enter anything.
        <strong>NOTE:</strong> This API is under review and may be removed or changed in a subsequent release.
       @ignore
        @type {Boolean}
       @default false
       @htmlattribute forceselection
       @htmlattributereflected
       */

    }, {
      key: "forceSelection",
      get: function get() {
        return this._forceSelection || false;
      },
      set: function set(value) {
        this._forceSelection = transform.booleanAttr(value);

        this._reflectAttribute('forceselection', this._forceSelection);
      }
      /**
       A hint to the user of what can be entered.
        @type {String}
       @default ""
       @htmlattribute placeholder
       @htmlattributereflected
       */

    }, {
      key: "placeholder",
      get: function get() {
        return this._elements.input.placeholder;
      },
      set: function set(value) {
        this._elements.input.placeholder = value;

        this._reflectAttribute('placeholder', this.placeholder);
      }
      /**
       Max length for the Input field
        @type {Number}
       @htmlattribute maxlength
       @htmlattributereflected
       */

    }, {
      key: "maxLength",
      get: function get() {
        return this._elements.input.maxLength;
      },
      set: function set(value) {
        this._elements.input.maxLength = value;

        this._reflectAttribute('maxlength', this._elements.input.maxLength);
      }
      /**
       The Autocomplete's variant. See {@link AutocompleteVariantEnum}.
        @type {AutocompleteVariantEnum}
       @default AutocompleteVariantEnum.DEFAULT
       @htmlattribute variant
       @htmlattributereflected
       */

    }, {
      key: "variant",
      get: function get() {
        return this._variant || variant$a.DEFAULT;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        this._variant = validate.enumeration(variant$a)(value) && value || variant$a.DEFAULT;

        this._reflectAttribute('variant', this._variant);

        if (this._variant === variant$a.QUIET) {
          this._elements.inputGroup.classList.add('_coral-InputGroup--quiet');

          this._elements.input.variant = Textfield.variant.QUIET;

          this._elements.trigger.classList.add('_coral-FieldButton--quiet');
        } else {
          this._elements.inputGroup.classList.remove('_coral-InputGroup--quiet');

          this._elements.input.variant = Textfield.variant.DEFAULT;

          this._elements.trigger.classList.remove('_coral-FieldButton--quiet');
        }
      }
      /**
       The match mode. See {@link AutocompleteMatchEnum}.
        @type {String}
       @default AutocompleteMatchEnum.CONTAINS
       @htmlattribute match
       */

    }, {
      key: "match",
      get: function get() {
        return this._match || match$1.CONTAINS;
      },
      set: function set(value) {
        if (typeof value === 'function') {
          this._match = value;
          this._matchFunction = value;
        } else {
          value = transform.string(value).toLowerCase();
          this._match = validate.enumeration(match$1)(value) && value || match$1.CONTAINS;

          if (this._match === match$1.STARTSWITH) {
            this._matchFunction = this._optionStartsWithValue;
          } else if (this._match === match$1.CONTAINS) {
            this._matchFunction = this._optionContainsValue;
          }
        }
      }
      /**
       Indicates that the component is currently loading remote data. This will set the wait indicator inside the list.
        @type {Boolean}
       @default false
       @htmlattribute loading
       */

    }, {
      key: "loading",
      get: function get() {
        return this._loading || false;
      },
      set: function set(value) {
        this._loading = transform.booleanAttr(value);

        if (this._loading) {
          var overlay = this._elements.overlay; // we decide first if we need to scroll to the bottom since adding the load will change the dimensions

          var scrollToBottom = overlay.scrollTop >= overlay.scrollHeight - overlay.clientHeight; // if it does not exist we create it

          if (!this._elements.loadIndicator) {
            template$h.call(this._elements);
          } // inserts the item at the end


          this._elements.selectList.appendChild(this._elements.loadIndicator); // we make the load indicator visible


          if (scrollToBottom) {
            overlay.scrollTop = overlay.scrollHeight;
          }
        } else if (this._elements.loadIndicator) {
          this._elements.loadIndicator.remove();
        }
      }
      /**
       Returns an Array containing the set selected items.
       @type {Array.<HTMLElement>}
       @readonly
       */

    }, {
      key: "selectedItems",
      get: function get() {
        return this.items._getAllSelected();
      }
      /**
       Returns the first selected item in the Autocomplete. The value <code>null</code> is returned if no element is
       selected.
       @type {?HTMLElement}
       @readonly
       */

    }, {
      key: "selectedItem",
      get: function get() {
        return this.items._getAllSelected()[0] || null;
      }
      /**
       The current value, as submitted during form submission.
       When {@link Coral.Autocomplete#multiple} is <code>true</code>, the first selected value will be returned.
        @type {String}
       @default ""
       @htmlattribute value
       */

    }, {
      key: "value",
      get: function get() {
        // Get the first value (or empty string)
        var values = this.values;
        return values && values.length > 0 ? values[0] : '';
      },
      set: function set(value) {
        this.values = [transform.string(value)];
      }
      /**
       The current values, as submitted during form submission.
       When {@link Coral.Autocomplete#multiple} is <code>false</code>, this will be an array of length 1.
        @type {Array.<String>}
       */

    }, {
      key: "values",
      get: function get() {
        return this._values;
      },
      set: function set(values) {
        if (values === undefined || values === null) {
          values = [];
        }

        if (Array.isArray(values)) {
          // if value was set to empty string
          if (values.length === 1 && values[0] === '') {
            values = [];
          }

          var i;
          var value;
          var selectedValues = []; // Valid values only

          if (this.forceSelection) {
            // Add each valid value
            for (i = 0; i < values.length; i++) {
              value = values[i];

              if (this._optionsMap[value] !== undefined) {
                selectedValues.push(value);
              }
            }
          } // Any value goes
          else {
              for (i = 0; i < values.length; i++) {
                value = values[i];
                selectedValues.push(value);
              }
            }

          if (this.multiple) {
            // Remove existing tags, DOM selection, etc
            // This is a full override
            this._clearValues(); // Add each tag


            for (i = 0; i < selectedValues.length; i++) {
              value = selectedValues[i]; // Ensure the item is selected if it's present in the DOM
              // This keeps the DOM in sync with the JS API and prevents bugs like CUI-5681

              this._selectItem(value); // Add the value to the tag list


              this._addValue(value, null, true);
            }
          } else {
            // Set value
            this._values = selectedValues.length > 0 ? [selectedValues[0]] : [];

            this._reflectCurrentValue();
          }
        }
      }
      /**
       Name used to submit the data in a form.
       @type {String}
       @default ""
       @htmlattribute name
       @htmlattributereflected
       */

    }, {
      key: "name",
      get: function get() {
        return this._getName();
      },
      set: function set(value) {
        this._reflectAttribute('name', value);

        this._setName(value);
      }
      /**
       Inherited from {@link BaseFormField#invalid}.
       */

    }, {
      key: "invalid",
      get: function get() {
        return _get(_getPrototypeOf(_class.prototype), "invalid", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(_class.prototype), "invalid", value, this, true); // Add to outer component


        this._elements.inputGroup.classList.toggle('is-invalid', this.invalid);

        this._elements.trigger.classList.toggle('is-invalid', this.invalid);

        this._elements.input.invalid = this.invalid;
      }
      /**
       Whether this field is disabled or not.
       @type {Boolean}
       @default false
       @htmlattribute disabled
       @htmlattributereflected
       */

    }, {
      key: "disabled",
      get: function get() {
        return this._disabled || false;
      },
      set: function set(value) {
        this._disabled = transform.booleanAttr(value);

        this._reflectAttribute('disabled', this._disabled);

        this[this._disabled ? 'setAttribute' : 'removeAttribute']('aria-disabled', this._disabled);

        this._elements.inputGroup.classList.toggle('is-disabled', this._disabled);

        this._elements.input.disabled = this._disabled;
        var disabledOrReadOnly = this._disabled || this.readOnly;
        this._elements.trigger.disabled = disabledOrReadOnly;
        this._elements.tagList.disabled = disabledOrReadOnly; // Prevents the overlay to be shown

        this._elements.inputGroup.disabled = disabledOrReadOnly;
      }
      /**
       Whether this field is readOnly or not. Indicating that the user cannot modify the value of the control.
       @type {Boolean}
       @default false
       @htmlattribute readonly
       @htmlattributereflected
       */

    }, {
      key: "readOnly",
      get: function get() {
        return this._readOnly || false;
      },
      set: function set(value) {
        this._readOnly = transform.booleanAttr(value);

        this._reflectAttribute('readonly', this._readOnly);

        this._elements.input.readOnly = this._readOnly;
        var readOnlyOrDisabled = this._readOnly || this.disabled;
        this._elements.trigger.readOnly = readOnlyOrDisabled;
        this._elements.tagList.readOnly = readOnlyOrDisabled; // Prevents the overlay to be shown

        this._elements.inputGroup.disabled = readOnlyOrDisabled;
      }
      /**
       Whether this field is required or not.
       @type {Boolean}
       @default false
       @htmlattribute required
       @htmlattributereflected
       */

    }, {
      key: "required",
      get: function get() {
        return this._required || false;
      },
      set: function set(value) {
        this._required = transform.booleanAttr(value);

        this._reflectAttribute('required', this._required);

        this._elements.input.required = this._required;
      }
      /**
       Inherited from {@link BaseFormField#labelled}.
       */

    }, {
      key: "labelled",
      get: function get() {
        return _get(_getPrototypeOf(_class.prototype), "labelled", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(_class.prototype), "labelled", value, this, true);

        this[this.labelled ? 'setAttribute' : 'removeAttribute']('aria-label', this.labelled);

        this._elements.selectList[this.labelled ? 'setAttribute' : 'removeAttribute']('aria-label', this.labelled);

        if (this.labelled && this.multiple) {
          this._elements.tagList.setAttribute('aria-label', this.labelled);
        } else {
          this._elements.tagList.removeAttribute('aria-label');
        }
      }
      /**
       Inherited from {@link BaseFormField#labelledBy}.
       */

    }, {
      key: "labelledBy",
      get: function get() {
        return _get(_getPrototypeOf(_class.prototype), "labelledBy", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(_class.prototype), "labelledBy", value, this, true);

        this[this.labelledBy ? 'setAttribute' : 'removeAttribute']('aria-labelledby', this.labelledBy);

        this._elements.selectList[this.labelledBy ? 'setAttribute' : 'removeAttribute']('aria-labelledby', this.labelledBy);

        if (this.labelledBy && this.multiple) {
          this._elements.tagList.setAttribute('aria-labelledby', this.labelledBy);
        } else {
          this._elements.tagList.removeAttribute('aria-labelledby');
        }
      }
      /**
       @ignore
        Not supported anymore.
       */

    }, {
      key: "icon",
      get: function get() {
        return this._icon || '';
      },
      set: function set(value) {
        this._icon = transform.string(value);

        this._reflectAttribute('icon', this._icon);
      }
    }], [{
      key: "match",
      get: function get() {
        return match$1;
      }
      /**
       Returns {@link Autocomplete} variants.
        @return {AutocompleteVariantEnum}
       */

    }, {
      key: "variant",
      get: function get() {
        return variant$a;
      }
    }, {
      key: "_attributePropertyMap",
      get: function get() {
        return commons.extend(_get(_getPrototypeOf(_class), "_attributePropertyMap", this), {
          forceselection: 'forceSelection',
          maxlength: 'maxLength'
        });
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['multiple', 'delay', 'forceselection', 'placeholder', 'maxlength', 'icon', 'match', 'loading', 'variant']);
      }
    }]);

    return _class;
  }(BaseFormField(BaseComponent(HTMLElement))));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons.extend(strings, {
    'coral-component-autocomplete': translations$a
  }); // Expose component on the Coral namespace

  commons._define('coral-autocomplete-item', AutocompleteItem);

  commons._define('coral-autocomplete', Autocomplete);

  Autocomplete.Item = AutocompleteItem;

  var CLASSNAME$A = '_coral-Banner';
  /**
   Enumeration for {@link Banner} variants.

   @typedef {Object} BannerVariantEnum

   @property {String} ERROR
   A banner to indicate that an error has occurred.
   @property {String} WARNING
   A banner to warn the user of something important.
   @property {String} INFO
   A banner to inform the user of non-critical information.
   */

  var variant$b = {
    ERROR: 'error',
    WARNING: 'warning',
    INFO: 'info'
  }; // An array of all possible variant classnames

  var ALL_VARIANT_CLASSES$7 = [];

  for (var variantValue$5 in variant$b) {
    ALL_VARIANT_CLASSES$7.push("".concat(CLASSNAME$A, "--").concat(variant$b[variantValue$5]));
  }
  /**
   @class Coral.Banner
   @classdesc A Banner component
   @htmltag coral-banner
   @extends {HTMLElement}
   @extends {BaseComponent}
   */


  var Banner = Decorator( /*#__PURE__*/function (_BaseComponent) {
    _inherits(_class, _BaseComponent);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this); // Fetch content zones

      _this._elements = {
        header: _this.querySelector('coral-banner-header') || document.createElement('coral-banner-header'),
        content: _this.querySelector('coral-banner-content') || document.createElement('coral-banner-content')
      };
      return _this;
    }
    /**
     The banner variant style to use. See {@link BannerVariantEnum}.
      @type {String}
     @default BannerVariantEnum.INFO
     @htmlattribute variant
     @htmlattributereflected
     */


    _createClass(_class, [{
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$A); // Default reflected attributes

        if (!this._variant) {
          this.variant = variant$b.INFO;
        }

        var header = this._elements.header;
        var content = this._elements.content; // When the content zone was not created, we need to make sure that everything is added inside it as a content.

        if (!content.parentNode) {
          while (this.firstChild) {
            var child = this.firstChild; // Don't move header into content

            if (child === header) {
              child.remove();
            } else {
              content.appendChild(this.firstChild);
            }
          }
        } // Assign content zones


        this.header = this._elements.header;
        this.content = this._elements.content;
      }
    }, {
      key: "variant",
      get: function get() {
        return this._variant || variant$b.INFO;
      },
      set: function set(value) {
        var _this$classList;

        value = transform.string(value).toLowerCase();
        this._variant = validate.enumeration(variant$b)(value) && value || variant$b.INFO;

        this._reflectAttribute('variant', this._variant); // Remove all variant classes


        (_this$classList = this.classList).remove.apply(_this$classList, ALL_VARIANT_CLASSES$7); // Set new variant class


        this.classList.add("".concat(CLASSNAME$A, "--").concat(this._variant));
      }
      /**
       The banner's header.
        @type {BannerHeader}
       @contentzone
       */

    }, {
      key: "header",
      get: function get() {
        return this._getContentZone(this._elements.header);
      },
      set: function set(value) {
        this._setContentZone('header', value, {
          handle: 'header',
          tagName: 'coral-banner-header',
          insert: function insert(header) {
            header.classList.add("".concat(CLASSNAME$A, "-header"));
            this.insertBefore(header, this.firstChild);
          }
        });
      }
      /**
       The banner's content.
        @type {BannerContent}
       @contentzone
       */

    }, {
      key: "content",
      get: function get() {
        return this._getContentZone(this._elements.content);
      },
      set: function set(value) {
        this._setContentZone('content', value, {
          handle: 'content',
          tagName: 'coral-banner-content',
          insert: function insert(content) {
            content.classList.add("".concat(CLASSNAME$A, "-content"));
            this.appendChild(content);
          }
        });
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-banner-header': 'header',
          'coral-banner-content': 'content'
        };
      }
      /**
       Returns {@link Banner} variants.
        @return {BannerVariantEnum}
       */

    }], [{
      key: "variant",
      get: function get() {
        return variant$b;
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return ['variant'];
      }
    }]);

    return _class;
  }(BaseComponent(HTMLElement)));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Banner.Header
   @classdesc A Banner Header component
   @htmltag coral-banner-header
   @return {HTMLElement}
   */
  var BannerHeader = (function () {
    return document.createElement('coral-banner-header');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Banner.Content
   @classdesc A Banner Content component
   @htmltag coral-banner-content
   @return {HTMLElement}
   */
  var BannerContent = (function () {
    return document.createElement('coral-banner-content');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons._define('coral-banner', Banner);

  Banner.Header = BannerHeader;
  Banner.Content = BannerContent;

  var template$i = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["nativeSelect"] = document.createElement("select");
    el0.className += " _coral-ButtonGroup-select";
    el0.setAttribute("tabindex", "-1");
    el0.setAttribute("handle", "nativeSelect");
    frag.appendChild(el0);
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    return frag;
  };

  /**
   Enumeration for {@link ButtonGroup} selection options.

   @typedef {Object} ButtonGroupSelectionModeEnum

   @property {String} NONE
   None is default, selection of buttons doesn't happen based on click.
   @property {String} SINGLE
   Single selection mode, button group behaves like radio input elements.
   @property {String} MULTIPLE
   Multiple selection mode, button group behaves like checkbox input elements.
   */

  var selectionMode = {
    NONE: 'none',
    SINGLE: 'single',
    MULTIPLE: 'multiple'
  };
  /** @const Selector used to recognized an item of the ButtonGroup */

  var ITEM_SELECTOR = 'button[is="coral-button"]';
  /**
   Extracts the value from the item in case no explicit value was provided.
   @param {HTMLElement} item
   the item whose value will be extracted.
   @returns {String} the value that will be submitted for this item.
   @private
   */

  var itemValueFromDOM$2 = function itemValueFromDOM(item) {
    var attr = item.getAttribute('value'); // checking explicitely for null allows to differenciate between non set values and empty strings

    return attr !== null ? attr : item.textContent.replace(/\s{2,}/g, ' ').trim();
  };

  var CLASSNAME$B = '_coral-ButtonGroup';
  /**
   @class Coral.ButtonGroup
   @classdesc A ButtonGroup component that can be used as a selection form field.
   @htmltag coral-buttongroup
   @extends {HTMLElement}
   @extends {BaseComponent}
   @extends {BaseFormField}
   */

  var ButtonGroup = Decorator( /*#__PURE__*/function (_BaseFormField) {
    _inherits(_class, _BaseFormField);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this); // Store template

      _this._elements = {};
      template$i.call(_this._elements); // Pre-define labellable element

      _this._labellableElement = _assertThisInitialized(_this); // save initial selection (used for reset)

      _this._initalSelectedValues = []; // Attach events

      _this._delegateEvents(commons.extend(_this._events, {
        'click button[is="coral-button"]': '_onButtonClick',
        'capture:focus button[is="coral-button"]': '_onButtonFocus',
        'capture:blur button[is="coral-button"]': '_onButtonBlur',
        'key:up button[is="coral-button"]': '_onButtonKeyUpLeft',
        'key:left button[is="coral-button"]': '_onButtonKeyUpLeft',
        'key:down button[is="coral-button"]': '_onButtonKeyDownRight',
        'key:right button[is="coral-button"]': '_onButtonKeyDownRight',
        'key:home button[is="coral-button"]': '_onButtonKeyHome',
        'key:end button[is="coral-button"]': '_onButtonKeyEnd',
        'coral-button:_valuechanged button[is="coral-button"]': '_onButtonValueChanged',
        'coral-button:_selectedchanged button[is="coral-button"]': '_onButtonSelectedChanged'
      })); // Init the mutation observer but we don't handle the initial items in the constructor


      _this.items._startHandlingItems(true);

      return _this;
    }
    /**
     The Collection Interface that allows interacting with the items that the component contains.
      @type {SelectableCollection}
     @readonly
     */


    _createClass(_class, [{
      key: "reset",

      /**
       Inherited from {@link BaseFormField#reset}.
       */
      value: function reset() {
        // reset the values to the initial values
        this.values = this._initalSelectedValues;
      }
      /** @private */

    }, {
      key: "_onButtonClick",
      value: function _onButtonClick(event) {
        // uses matchTarget to make sure the buttons is handled and not an internal component
        var item = event.matchedTarget;

        this._onButtonFocus(event);

        if (this.readOnly) {
          event.preventDefault();
          event.stopImmediatePropagation();
          return;
        }

        if (this.selectionMode === selectionMode.SINGLE) {
          // prevent event only if selectionMode is not of type none
          event.preventDefault(); // first unselect the other element

          var selectedItems = this.items._getAllSelected(); // we deselect the previously selected item


          if (selectedItems.length !== 0 && selectedItems[0] !== item) {
            this._toggleItemSelection(selectedItems[0], false);
          } // forces the selection on the clicked item


          this._toggleItemSelection(item, true); // if the same button was clicked we do not need to trigger an event


          if (selectedItems[0] !== item) {
            this.trigger('change');
          }
        } else if (this.selectionMode === selectionMode.MULTIPLE) {
          // prevent event only if selectionMode is not of type none
          event.preventDefault();

          this._toggleItemSelection(item); // since we toggle the selection we always trigger a change event


          this.trigger('change');
        }
      }
      /** @private */

    }, {
      key: "_onButtonFocus",
      value: function _onButtonFocus(event) {
        var item = event.matchedTarget;
        var buttons = this.items.getAll();
        var buttonsCount = buttons.length;
        var button;

        for (var i = 0; i < buttonsCount; i++) {
          // stores the reference
          button = buttons[i];
          button.setAttribute('tabindex', button === item ? 0 : -1);
        }
      }
      /** @private */

    }, {
      key: "_onButtonBlur",
      value: function _onButtonBlur(event) {
        var item = event.matchedTarget;
        var buttons = this.items.getAll();
        var buttonsCount = buttons.length;
        var button;
        var tabindex;
        var selectedItemsLength = this.selectedItems.length;

        var firstSelectable = this.items._getFirstSelectable();

        var isSelected = false;

        for (var i = 0; i < buttonsCount; i++) {
          // stores the reference
          button = buttons[i];
          isSelected = button.hasAttribute('selected');

          if (this.selectionMode === selectionMode.SINGLE) {
            // selected item should be tabbable
            tabindex = isSelected ? 0 : -1;
          } else if (this.selectionMode === selectionMode.MULTIPLE) {
            tabindex = // if no items are selected, first item should be tabbable
            !selectedItemsLength && i === 0 || // if the element losing focus is selected, it should be tabbable
            isSelected && button === item || // if the element losing focus is not selected, the last selected item should be tabbable
            !item.hasAttribute('selected') && button === (this.selectedItems[selectedItemsLength - 1] || firstSelectable) ? 0 : -1;
          } else {
            // first item should be tabbable
            tabindex = button === firstSelectable ? 0 : -1;
          }

          button.setAttribute('tabindex', tabindex);
        }
      }
      /** @private */

    }, {
      key: "_onButtonKeyUpLeft",
      value: function _onButtonKeyUpLeft(event) {
        event.preventDefault();
        var item = event.matchedTarget;
        var button = item.previousElementSibling; // skip disabled items

        while (!button || button.disabled || button.nodeName !== 'BUTTON') {
          if (!button) {
            button = this.items._getLastSelectable();
          } else {
            button = button.previousElementSibling;
          }
        }

        if (button !== item) {
          if (this.selectionMode === selectionMode.SINGLE) {
            button.click();
          }

          this._setFocusToButton(button);
        }
      }
      /** @private */

    }, {
      key: "_onButtonKeyDownRight",
      value: function _onButtonKeyDownRight(event) {
        event.preventDefault();
        var item = event.matchedTarget;
        var button = item.nextElementSibling; // skip disabled items

        while (!button || button.disabled || button.nodeName !== 'BUTTON') {
          if (!button) {
            button = this.items._getFirstSelectable();
          } else {
            button = button.nextElementSibling;
          }
        }

        if (button !== item) {
          if (this.selectionMode === selectionMode.SINGLE) {
            button.click();
          }

          this._setFocusToButton(button);
        }
      }
      /** @private */

    }, {
      key: "_onButtonKeyHome",
      value: function _onButtonKeyHome(event) {
        event.preventDefault();
        var item = event.matchedTarget;

        var button = this.items._getFirstSelectable();

        if (button !== item) {
          if (this.selectionMode === selectionMode.SINGLE) {
            button.click();
          }

          this._setFocusToButton(button);
        }
      }
      /** @private */

    }, {
      key: "_onButtonKeyEnd",
      value: function _onButtonKeyEnd(event) {
        event.preventDefault();
        var item = event.matchedTarget;

        var button = this.items._getLastSelectable();

        if (button !== item) {
          if (this.selectionMode === selectionMode.SINGLE) {
            button.click();
          }

          this._setFocusToButton(button);
        }
      }
      /** @private */

    }, {
      key: "_setFocusToButton",
      value: function _setFocusToButton(button) {
        if (button) {
          button.focus();
        }
      }
      /** @private */

    }, {
      key: "_onItemAdded",
      value: function _onItemAdded(item) {
        // Store variant to be able to reset it when item is removed
        item._initialVariant = item._initialVariant || item.variant; // Force action variant

        if (!(item.variant === Button.variant.ACTION || item.variant === Button.variant.QUIET_ACTION)) {
          item.variant = item.variant === Button.variant.QUIET ? Button.variant.QUIET_ACTION : Button.variant.ACTION;
        }

        if (this.selectionMode !== selectionMode.NONE) {
          if (this.selectionMode === selectionMode.SINGLE) {
            item.setAttribute('role', 'radio');
            item.setAttribute('tabindex', item.hasAttribute('selected') ? 0 : -1);
          } else {
            item.setAttribute('role', 'checkbox');
          }

          item.setAttribute('aria-checked', item.hasAttribute('selected'));
        } else {
          item.removeAttribute('role');
        }

        item.disabled = this.disabled || this.readOnly && !item.hasAttribute('selected');
        item[this.readOnly ? 'setAttribute' : 'removeAttribute']('aria-disabled', true);

        this._addItemOption(item); // Handle the case where we might have multiple items selected while single selection mode is on


        if (this.selectionMode === selectionMode.SINGLE) {
          var selectedItems = this.items._getAllSelected(); // The last added item will stay selected


          if (selectedItems.length > 1 && item.hasAttribute('selected')) {
            item.removeAttribute('selected');
          }
        }
      }
      /** @private */

    }, {
      key: "_onItemRemoved",
      value: function _onItemRemoved(item) {
        // Restore variant
        item.variant = item._initialVariant;
        item._initialVariant = undefined;
        item.removeAttribute('role');

        if (!item.parentNode) {
          // Remove the item from the initial selected values
          var index = this._initalSelectedValues.indexOf(item.value);

          if (index !== -1) {
            this._initalSelectedValues.splice(index, 1);
          }
        } // delete option


        if (item.option) {
          item.option.parentNode.removeChild(item.option);
          item.option = undefined;
        }
      }
      /** @private */

    }, {
      key: "_onCollectionChange",
      value: function _onCollectionChange() {
        // we need to make sure that the state of the selectionMode is valid
        this._validateSelection();
      }
      /** @private */

    }, {
      key: "_onButtonSelectedChanged",
      value: function _onButtonSelectedChanged(event) {
        event.stopImmediatePropagation();
        var button = event.target;
        var isSelected = button.hasAttribute('selected'); // when in single mode, we need to make sure the current selection is valid

        if (this.selectionMode === selectionMode.SINGLE) {
          this._validateSelection(isSelected ? button : null);
        } else {
          // we simply toggle the selection
          this._toggleItemSelection(button, isSelected);
        }
      }
      /** @private */

    }, {
      key: "_onButtonValueChanged",
      value: function _onButtonValueChanged(event) {
        event.stopImmediatePropagation();
        var button = event.target; // Make sure option is attached before setting the value

        if (this.selectionMode !== selectionMode.NONE) {
          button.option.value = itemValueFromDOM$2(button);
        }
      }
      /**
       Toggles the selected state of the item. When <code>selected</code> is provided, it is set as the current state. If
       the value is ommited, then the selected is toggled.
        @param {HTMLElement} item
       Item whose selection needs to be updated.
       @param {Boolean} [selected]
       Whether the item is selected. If it is not provided, then it is toggled.
        @private
       */

    }, {
      key: "_toggleItemSelection",
      value: function _toggleItemSelection(item, selected) {
        var ariaCheckedAttr = item.getAttribute('aria-checked');
        var tabIndexAttr = item.getAttribute('tabindex'); // if selected is provided it is used to enforce the selection, otherwise we toggle the current state

        selected = typeof selected !== 'undefined' ? selected : !item.hasAttribute('selected'); // only manipulates the attributes when necessary to avoid unnecessary mutations

        if (selected) {
          if (!item.hasAttribute('selected')) {
            item.setAttribute('selected', '');
          }

          if (ariaCheckedAttr !== 'true') {
            item.setAttribute('aria-checked', true);
          }

          if (this.selectionMode === selectionMode.SINGLE && tabIndexAttr !== '0') {
            item.setAttribute('tabindex', 0);
          }
        } else if (!selected) {
          if (item.hasAttribute('selected')) {
            item.removeAttribute('selected');
          }

          if (this.selectionMode !== selectionMode.NONE) {
            if (ariaCheckedAttr !== 'false') {
              item.setAttribute('aria-checked', false);
            }

            if (this.selectionMode === selectionMode.SINGLE && tabIndexAttr !== '-1') {
              item.setAttribute('tabindex', -1);
            }
          } else {
            item.removeAttribute('aria-checked');
            item.removeAttribute('tabindex');
          }
        } // if element.option is present - absent when selection mode changed to none


        if (item.option) {
          item.option.selected = selected;
        }
      }
    }, {
      key: "_selectItemByValue",
      value: function _selectItemByValue(values) {
        // queries all the buttons to change their selection state
        var buttons = this.items.getAll();
        var item;

        for (var i = 0, buttonsCount = buttons.length; i < buttonsCount; i++) {
          // stores the reference
          item = buttons[i]; // if the value is inside the new values array it should be selected

          this._toggleItemSelection(item, values.indexOf(itemValueFromDOM$2(item)) !== -1);
        }
      }
      /** @private */

    }, {
      key: "_setInitialValues",
      value: function _setInitialValues() {
        if (this.selectionMode !== selectionMode.NONE) {
          var selectedItems = this.selectedItems;

          for (var i = 0, selectedItemsCount = selectedItems.length; i < selectedItemsCount; i++) {
            // Store _initalSelectedValues for reset
            this._initalSelectedValues.push(selectedItems[i].value); // Same goes for native select


            this._addItemOption(selectedItems[i]);
          }
        }
      }
      /** @private */

    }, {
      key: "_addItemOption",
      value: function _addItemOption(item) {
        if (this.selectionMode === selectionMode.NONE) {
          return;
        } // if already attached return


        if (item.option) {
          return;
        }

        var option = document.createElement('option');
        option.value = itemValueFromDOM$2(item);

        if (item.hasAttribute('selected')) {
          option.setAttribute('selected', '');
        } // add it to DOM. In single selectionMode the first item gets selected automatically


        item.option = option;

        this._elements.nativeSelect.add(option); // we make sure the options reflect the state of the button


        this._toggleItemSelection(item, item.hasAttribute('selected'));
      }
      /** @private */

    }, {
      key: "_removeItemOptions",
      value: function _removeItemOptions() {
        // Find all buttons and try attaching corresponding option elem
        var buttons = this.items.getAll();
        var item;

        for (var i = 0, buttonsCount = buttons.length; i < buttonsCount; i++) {
          // stores the reference
          item = buttons[i];
          item.removeAttribute('role');
          item.removeAttribute('aria-checked'); // single we are removing the options, selection must also go away

          if (item.hasAttribute('selected')) {
            this._toggleItemSelection(item, false);
          } // we clear the related option element


          if (item.option) {
            item.option.parentNode.removeChild(item.option);
            delete item.option;
          }
        }
      }
      /** @private */

    }, {
      key: "_syncItemOptions",
      value: function _syncItemOptions() {
        // finds all buttons and try attaching corresponding option elem
        var buttons = this.items.getAll();
        var buttonsCount = buttons.length;
        var i = 0;
        var role = null;

        if (this.selectionMode === selectionMode.SINGLE) {
          role = 'radio';
        } else if (this.selectionMode === selectionMode.MULTIPLE) {
          role = 'checkbox';
        }

        var button;
        var isSelected = false;

        for (i; i < buttonsCount; i++) {
          // try attaching corresponding input element
          this._addItemOption(buttons[i]);
        } // We need to set the right state for the native select AFTER all buttons have been added
        // (as we can't disable options while there is only one option attached [at least in FF])


        for (i = buttonsCount - 1; i >= 0; i--) {
          button = buttons[i];
          isSelected = button.hasAttribute('selected');
          button.option.selected = isSelected;
          button.setAttribute('aria-checked', isSelected);

          if (role) {
            button.setAttribute('role', role);
          } else {
            button.removeAttribute('role');
          }
        }
      }
      /** @private */

    }, {
      key: "_validateSelection",
      value: function _validateSelection(item) {
        // when selectionMode = single, we need to force a selection
        if (this.selectionMode === selectionMode.SINGLE) {
          // gets the current selection
          var selection = this.items._getAllSelected();

          var selectionCount = selection.length; // if no item is currently selected, we need to find a candidate

          if (selectionCount === 0) {
            // gets the first candidate for selection
            var selectable = this.items._getFirstSelectable();

            if (selectable) {
              this._toggleItemSelection(selectable, true);
            }
          } // more items are selected, so we find a single item and deselect everything else
          else if (selectionCount > 1) {
              // if no item was provided we force the selection on the first item
              item = item || selection[0]; // we make sure the item is selected, this is important to match the options with the selection

              this._toggleItemSelection(item, true);

              for (var i = 0; i < selectionCount; i++) {
                if (selection[i] !== item) {
                  this._toggleItemSelection(selection[i], false);
                }
              }
            }
        }
      }
      /**
       Returns {@link ButtonGroup} selection options.
        @return {ButtonGroupSelectionModeEnum}
       */

    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$B); // Default reflected attributes

        if (!this._selectionMode) {
          this.selectionMode = selectionMode.NONE;
        } // Create a fragment


        var frag = document.createDocumentFragment(); // Render the template

        frag.appendChild(this._elements.nativeSelect); // Clean up

        while (this.firstChild) {
          var child = this.firstChild;

          if (child.nodeType === Node.TEXT_NODE || child.getAttribute('handle') !== 'nativeSelect') {
            // Add non-template elements to the content
            frag.appendChild(child);
          } else {
            // Remove anything else
            this.removeChild(child);
          }
        } // Append the fragment to the component


        this.appendChild(frag); // Need to store and set the initially selected values in the native select so that it can reset

        this._setInitialValues(); // Call onItemAdded and onCollectionChange on the existing items


        this.items._startHandlingItems();
      }
    }, {
      key: "items",
      get: function get() {
        // we do lazy initialization of the collection
        if (!this._items) {
          this._items = new SelectableCollection({
            host: this,
            itemBaseTagName: 'button',
            itemTagName: 'coral-button',
            itemSelector: ITEM_SELECTOR,
            onlyHandleChildren: true,
            onItemAdded: this._onItemAdded,
            onItemRemoved: this._onItemRemoved,
            onCollectionChange: this._onCollectionChange
          });
        }

        return this._items;
      }
      /**
       Selection mode of Button group
        @type {String}
       @default ButtonGroupSelectionModeEnum.NONE
       @htmlattribute selectionmode
       @htmlattributereflected
       */

    }, {
      key: "selectionMode",
      get: function get() {
        return this._selectionMode || selectionMode.NONE;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        this._selectionMode = validate.enumeration(selectionMode)(value) && value || selectionMode.NONE;

        this._reflectAttribute('selectionmode', this._selectionMode); // update select element if multiple
        // this is required while appplying default selection
        // if selection mode is single first elem gets selected but for multiple its not


        this._elements.nativeSelect.multiple = this._selectionMode === selectionMode.MULTIPLE; // Sync

        if (this._selectionMode === selectionMode.SINGLE) {
          this.setAttribute('role', 'radiogroup'); // makes sure the internal options are properly initialized

          this._syncItemOptions(); // we make sure the selection is valid by explicitly finding a candidate or making sure just 1 item is
          // selected


          this._validateSelection();
        } else if (this._selectionMode === selectionMode.MULTIPLE) {
          this.setAttribute('role', 'group'); // makes sure the internal options are properly initialized

          this._syncItemOptions();
        } else {
          this.setAttribute('role', 'group');

          this._removeItemOptions();
        }
      }
      /**
       Name used to submit the data in a form.
       @type {String}
       @default ""
       @htmlattribute name
       @htmlattributereflected
       */

    }, {
      key: "name",
      get: function get() {
        return this._elements.nativeSelect.name;
      },
      set: function set(value) {
        this._reflectAttribute('name', value);

        this._elements.nativeSelect.name = value;
      }
      /**
       This field's current value.
       @type {String}
       @default ""
       @htmlattribute value
       */

    }, {
      key: "value",
      get: function get() {
        return this._elements.nativeSelect.value;
      },
      set: function set(value) {
        if (this.selectionMode === selectionMode.NONE) {
          return;
        } // we proceed to select the provided value


        this._selectItemByValue([value]);
      }
      /**
       Returns an Array containing the selected buttons.
        @type {Array.<HTMLElement>}
       @readonly
       */

    }, {
      key: "selectedItems",
      get: function get() {
        if (this.selectionMode === selectionMode.MULTIPLE) {
          return this.items._getAllSelected();
        }

        var item = this.selectedItem;
        return item ? [item] : [];
      }
      /**
       Returns the first selected button in the Button Group. The value <code>null</code> is returned if no button is
       selected.
        @type {HTMLElement}
       @readonly
       */

    }, {
      key: "selectedItem",
      get: function get() {
        return this.selectionMode === selectionMode.MULTIPLE ? this.items._getFirstSelected() : this.items._getLastSelected();
      }
      /**
       Current selected values as submitted during form submission.
        @type {Array.<String>}
       */

    }, {
      key: "values",
      get: function get() {
        var values = []; // uses the nativeSelect since it holds the truth of what will be submitted with the form

        var selectedOptions = this._elements.nativeSelect.querySelectorAll(':checked');

        for (var i = 0, selectedOptionsCount = selectedOptions.length; i < selectedOptionsCount; i++) {
          values.push(selectedOptions[i].value);
        }

        return values;
      },
      set: function set(values) {
        if (Array.isArray(values) && this.selectionMode !== selectionMode.NONE) {
          // just keeps the first value if selectionMode is not multiple
          if (this.selectionMode !== selectionMode.MULTIPLE && values.length > 1) {
            values = [values[0]];
          } // we proceed to select the provided values


          this._selectItemByValue(values);
        }
      }
      /**
       Whether this field is disabled or not.
       @type {Boolean}
       @default false
       @htmlattribute disabled
       @htmlattributereflected
       */

    }, {
      key: "disabled",
      get: function get() {
        return this._disabled || false;
      },
      set: function set(value) {
        this._disabled = transform.booleanAttr(value);

        this._reflectAttribute('disabled', this._disabled);

        var isDisabled = this.disabled || this.readOnly;
        this._elements.nativeSelect.disabled = isDisabled; // Also update for all the items the disabled property so it matches the native select.

        this.items.getAll().forEach(function (item) {
          item.disabled = isDisabled;
        });
        this[isDisabled ? 'setAttribute' : 'removeAttribute']('aria-disabled', isDisabled);
      }
      /**
       Whether this field is readOnly or not. Indicating that the user cannot modify the value of the control.
       @type {Boolean}
       @default false
       @htmlattribute readonly
       @htmlattributereflected
       */

    }, {
      key: "readOnly",
      get: function get() {
        return this._readOnly || false;
      },
      set: function set(value) {
        var _this2 = this;

        this._readOnly = transform.booleanAttr(value);

        this._reflectAttribute('readonly', this._readOnly);

        this._elements.nativeSelect.disabled = this.readOnly || this.disabled; // Also update for all the items the disabled property so it matches the native select.

        this.items.getAll().forEach(function (item) {
          item.disabled = _this2.disabled || _this2.readOnly && !item.hasAttribute('selected');
          item[_this2.readOnly ? 'setAttribute' : 'removeAttribute']('aria-disabled', true);
        }); // aria-readonly is not permitted on elements with role="radiogroup" or role="group"

        this.removeAttribute('aria-readonly');
      }
      /**
       Whether this field is required or not.
       @type {Boolean}
       @default false
       @htmlattribute required
       @htmlattributereflected
       */

    }, {
      key: "required",
      get: function get() {
        return this._required || false;
      },
      set: function set(value) {
        this._required = transform.booleanAttr(value);

        this._reflectAttribute('required', this._required);

        this._elements.nativeSelect.required = this.required; // aria-required is permitted on elements with role="radiogroup" but not with role="group"

        if (this.selectionMode !== selectionMode.SINGLE) {
          this.removeAttribute('aria-required');
        }
      }
      /**
       Inherited from {@link BaseFormField#labelledBy}.
       */

    }, {
      key: "labelledBy",
      get: function get() {
        return _get(_getPrototypeOf(_class.prototype), "labelledBy", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(_class.prototype), "labelledBy", value, this, true);

        this._elements.nativeSelect.setAttribute('aria-labelledby', this.labelledBy);
      }
    }], [{
      key: "selectionMode",
      get: function get() {
        return selectionMode;
      }
    }, {
      key: "_attributePropertyMap",
      get: function get() {
        return commons.extend(_get(_getPrototypeOf(_class), "_attributePropertyMap", this), {
          selectionmode: 'selectionMode'
        });
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['selectionmode', 'selectionMode']);
      }
    }]);

    return _class;
  }(BaseFormField(BaseComponent(HTMLElement))));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons._define('coral-buttongroup', ButtonGroup);

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var translations$b = {
    "en-US": {
      "Previous": "Previous",
      "Next": "Next",
      "Today, {0} selected/[translation hint:date]": "Today, {0} selected",
      "Today, {0}/[translation hint:date]": "Today, {0}",
      "{0} selected/[translation hint:date]": "{0} selected",
      "Previous Month": "Previous Month",
      "Next Month": "Next Month"
    },
    "fr-FR": {
      "Previous": "Précédent",
      "Next": "Suivant",
      "Today, {0} selected/[translation hint:date]": "Aujourd’hui, sélection de {0}",
      "Today, {0}/[translation hint:date]": "Aujourd’hui, {0}",
      "{0} selected/[translation hint:date]": "Sélection de {0}",
      "Previous Month": "Mois précédent",
      "Next Month": "Mois suivant"
    },
    "de-DE": {
      "Previous": "Zurück",
      "Next": "Weiter",
      "Today, {0} selected/[translation hint:date]": "Heute, {0} ausgewählt",
      "Today, {0}/[translation hint:date]": "Heute, {0}",
      "{0} selected/[translation hint:date]": "{0} ausgewählt",
      "Previous Month": "Vorheriger Monat",
      "Next Month": "Nächster Monat"
    },
    "it-IT": {
      "Previous": "Precedente",
      "Next": "Successivo",
      "Today, {0} selected/[translation hint:date]": "Oggi, {0} selezionati",
      "Today, {0}/[translation hint:date]": "Oggi, {0}",
      "{0} selected/[translation hint:date]": "{0} selezionati",
      "Previous Month": "Mese precedente",
      "Next Month": "Mese successivo"
    },
    "es-ES": {
      "Previous": "Anterior",
      "Next": "Siguiente",
      "Today, {0} selected/[translation hint:date]": "Hoy, {0} seleccionados",
      "Today, {0}/[translation hint:date]": "Hoy, {0}",
      "{0} selected/[translation hint:date]": "{0} seleccionados",
      "Previous Month": "Mes anterior",
      "Next Month": "Mes siguiente"
    },
    "pt-BR": {
      "Previous": "Anterior",
      "Next": "Próximo",
      "Today, {0} selected/[translation hint:date]": "Hoje, {0} selecionados",
      "Today, {0}/[translation hint:date]": "Hoje, {0}",
      "{0} selected/[translation hint:date]": "{0} selecionados",
      "Previous Month": "Mês Anterior",
      "Next Month": "Mês Seguinte"
    },
    "ja-JP": {
      "Previous": "前へ",
      "Next": "次へ",
      "Today, {0} selected/[translation hint:date]": "今日、{0} が選択されました",
      "Today, {0}/[translation hint:date]": "今日、{0}",
      "{0} selected/[translation hint:date]": "{0} が選択されました",
      "Previous Month": "前月",
      "Next Month": "翌月"
    },
    "ko-KR": {
      "Previous": "이전으로",
      "Next": "다음",
      "Today, {0} selected/[translation hint:date]": "현재 {0}이(가) 선택됨",
      "Today, {0}/[translation hint:date]": "현재 {0}",
      "{0} selected/[translation hint:date]": "{0}이(가) 선택됨",
      "Previous Month": "지난 달",
      "Next Month": "다음 달"
    },
    "zh-CN": {
      "Previous": "上一步",
      "Next": "下一步",
      "Today, {0} selected/[translation hint:date]": "已选定今天 {0}",
      "Today, {0}/[translation hint:date]": "今天 {0}",
      "{0} selected/[translation hint:date]": "已选定 {0}",
      "Previous Month": "上个月",
      "Next Month": "下个月"
    },
    "zh-TW": {
      "Previous": "上一頁",
      "Next": "下一頁",
      "Today, {0} selected/[translation hint:date]": "今天，已選取 {0}",
      "Today, {0}/[translation hint:date]": "今天，{0}",
      "{0} selected/[translation hint:date]": "已選取 {0} ",
      "Previous Month": "上個月",
      "Next Month": "下個月"
    },
    "nl-NL": {
      "Previous": "Vorige",
      "Next": "Volgende",
      "Today, {0} selected/[translation hint:date]": "Vandaag {0} geselecteerd",
      "Today, {0}/[translation hint:date]": "Vandaag {0} ",
      "{0} selected/[translation hint:date]": "{0} geselecteerd",
      "Previous Month": "Vorige maand",
      "Next Month": "Volgende maand"
    },
    "da-DK": {
      "Previous": "Foregående",
      "Next": "Næste",
      "Today, {0} selected/[translation hint:date]": "I dag, {0} valgt",
      "Today, {0}/[translation hint:date]": "I dag, {0} ",
      "{0} selected/[translation hint:date]": "{0} valgt",
      "Previous Month": "Sidste måned",
      "Next Month": "Næste måned"
    },
    "fi-FI": {
      "Previous": "Edellinen",
      "Next": "Seuraava",
      "Today, {0} selected/[translation hint:date]": "Tänään, {0} valittu",
      "Today, {0}/[translation hint:date]": "Tänään, {0}",
      "{0} selected/[translation hint:date]": "{0} valittu",
      "Previous Month": "Edellinen kuukausi",
      "Next Month": "Seuraava kuukausi"
    },
    "nb-NO": {
      "Previous": "Forrige",
      "Next": "Neste",
      "Today, {0} selected/[translation hint:date]": "I dag, {0} valgt",
      "Today, {0}/[translation hint:date]": "I dag, {0}",
      "{0} selected/[translation hint:date]": "{0} valgt",
      "Previous Month": "Forrige måned",
      "Next Month": "Neste måned"
    },
    "sv-SE": {
      "Previous": "Föregående",
      "Next": "Nästa",
      "Today, {0} selected/[translation hint:date]": "Idag, {0} vald",
      "Today, {0}/[translation hint:date]": "Idag, {0}",
      "{0} selected/[translation hint:date]": "{0} vald",
      "Previous Month": "Föregående månad",
      "Next Month": "Nästa månad"
    },
    "cs-CZ": {
      "Previous": "Předchozí",
      "Next": "Další",
      "Today, {0} selected/[translation hint:date]": "Dnes je vybráno: {0}",
      "Today, {0}/[translation hint:date]": "Dnes, {0}",
      "{0} selected/[translation hint:date]": "Vybráno: {0}",
      "Previous Month": "Předchozí měsíc",
      "Next Month": "Příští měsíc"
    },
    "pl-PL": {
      "Previous": "Wstecz",
      "Next": "Dalej",
      "Today, {0} selected/[translation hint:date]": "Dziś, wybrano {0}",
      "Today, {0}/[translation hint:date]": "Dziś, {0}",
      "{0} selected/[translation hint:date]": "wybrano {0}",
      "Previous Month": "Poprzedni miesiąc",
      "Next Month": "Następny miesiąc"
    },
    "ru-RU": {
      "Previous": "Предыдущий",
      "Next": "Следующий",
      "Today, {0} selected/[translation hint:date]": "Сегодня, {0}, выбрано",
      "Today, {0}/[translation hint:date]": "Сегодня, {0}",
      "{0} selected/[translation hint:date]": "{0} выбрано",
      "Previous Month": "Предыдущий месяц",
      "Next Month": "Следующий месяц"
    },
    "tr-TR": {
      "Previous": "Önceki",
      "Next": "İleri",
      "Today, {0} selected/[translation hint:date]": "Bugün, {0} seçildi",
      "Today, {0}/[translation hint:date]": "Bugün, {0}",
      "{0} selected/[translation hint:date]": "{0} seçildi",
      "Previous Month": "Önceki Ay",
      "Next Month": "Gelecek Ay"
    }
  };

  var template$j = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var data = data_0 = typeof data_0 === "undefined" ? {} : data_0;
    var el0 = this["input"] = document.createElement("input");
    el0.setAttribute("handle", "input");
    el0.setAttribute("type", "hidden");
    el0.setAttribute("name", "");
    frag.appendChild(el0);
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    var el2 = this["header"] = document.createElement("div");
    el2.setAttribute("handle", "header");
    el2.className += " _coral-Calendar-header";
    var el3 = document.createTextNode("\n  ");
    el2.appendChild(el3);
    var el4 = this["heading"] = document.createElement("div");
    el4.setAttribute("handle", "heading");
    el4.className += " _coral-Calendar-title";
    el4.setAttribute("role", "heading");
    el4.setAttribute("aria-live", "assertive");
    el4.setAttribute("aria-atomic", "true");
    el4.setAttribute("aria-level", "2");
    el4.id = data_0["commons"]["getUID"]();
    el2.appendChild(el4);
    var el5 = document.createTextNode("\n  ");
    el2.appendChild(el5);
    var el6 = this["prev"] = document.createElement("button", "coral-button");
    el6.setAttribute("type", "button");
    el6.setAttribute("handle", "prev");
    el6.className += " _coral-Calendar-prevMonth";
    el6.setAttribute("is", "coral-button");
    el6.setAttribute("variant", "quietaction");
    el6.setAttribute("aria-label", data_0["i18n"]["get"]('Previous Month'));
    el6.setAttribute("title", data_0["i18n"]["get"]('Previous Month'));
    var el7 = document.createTextNode("\n    ");
    el6.appendChild(el7);
    var el8 = this["prevLabel"] = document.createElement("coral-button-label");
    el8.setAttribute("handle", "prevLabel");
    el6.appendChild(el8);
    var el9 = document.createTextNode("\n  ");
    el6.appendChild(el9);
    el2.appendChild(el6);
    var el10 = document.createTextNode("\n  ");
    el2.appendChild(el10);
    var el11 = this["next"] = document.createElement("button", "coral-button");
    el11.setAttribute("type", "button");
    el11.setAttribute("handle", "next");
    el11.className += " _coral-Calendar-nextMonth";
    el11.setAttribute("is", "coral-button");
    el11.setAttribute("variant", "quietaction");
    el11.setAttribute("aria-label", data_0["i18n"]["get"]('Next Month'));
    el11.setAttribute("title", data_0["i18n"]["get"]('Next Month'));
    var el12 = document.createTextNode("\n    ");
    el11.appendChild(el12);
    var el13 = this["nextLabel"] = document.createElement("coral-button-label");
    el13.setAttribute("handle", "nextLabel");
    el11.appendChild(el13);
    var el14 = document.createTextNode("\n  ");
    el11.appendChild(el14);
    el2.appendChild(el11);
    var el15 = document.createTextNode("\n  ");
    el2.appendChild(el15);
    data = data_0; // Don't wait for button MO to pick up the label

    this.prev._elements.label = this.prevLabel;
    this.next._elements.label = this.nextLabel; // Render chevron icon

    this.prev.insertAdjacentHTML('beforeend', data.Icon._renderSVG('spectrum-css-icon-ChevronLeftLarge', ['_coral-UIIcon-ChevronLeftLarge']));
    this.next.insertAdjacentHTML('beforeend', data.Icon._renderSVG('spectrum-css-icon-ChevronRightLarge', ['_coral-UIIcon-ChevronRightLarge']));
    data_0 = data;
    var el17 = document.createTextNode("\n");
    el2.appendChild(el17);
    frag.appendChild(el2);
    var el18 = document.createTextNode("\n");
    frag.appendChild(el18);
    var el19 = this["body"] = document.createElement("div");
    el19.className += " _coral-Calendar-body";
    el19.setAttribute("handle", "body");
    el19.setAttribute("role", "grid");
    el19.setAttribute("tabindex", "0");
    el19.setAttribute("aria-readonly", "true");
    el19.setAttribute("aria-labelledby", this["heading"]["id"]);
    frag.appendChild(el19);
    var el20 = document.createTextNode("\n");
    frag.appendChild(el20);
    return frag;
  };

  var template$k = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["container"] = document.createElement("div");
    el0.className += " _coral-DatePicker-calendarSlidingContainer";
    el0.setAttribute("handle", "container");
    el0.setAttribute("style", "width: " + data_0["width"] + "px; height: " + data_0["height"] + "px;");
    frag.appendChild(el0);
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    return frag;
  };

  var template$l = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var data = data_0 = typeof data_0 === "undefined" ? {} : data_0;
    data = data_0;
    this.i18n = data.i18n;
    this.commons = data.commons;
    data_0 = data;
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    var el2 = this["table"] = document.createElement("table");
    el2.setAttribute("handle", "table");
    el2.className += " _coral-Calendar-table";
    el2.setAttribute("role", "presentation");
    var el3 = document.createTextNode("\n  ");
    el2.appendChild(el3);
    var el4 = document.createElement("thead");
    el4.setAttribute("role", "presentation");
    var el5 = document.createTextNode("\n    ");
    el4.appendChild(el5);
    var el6 = document.createElement("tr");
    el6.setAttribute("role", "row");
    var el7 = document.createTextNode("\n      ");
    el6.appendChild(el7);
    var iterated_1 = data_0["dayNames"];

    for (var i1 = 0, ni1 = iterated_1.length; i1 < ni1; i1++) {
      var data_1 = data = iterated_1[i1];
      var el9 = document.createTextNode("\n        ");
      el6.appendChild(el9);
      var el10 = document.createElement("th");
      el10.setAttribute("role", "columnheader");
      el10.setAttribute("scope", "col");
      el10.className += " _coral-Calendar-tableCell";
      var el11 = document.createTextNode("\n          ");
      el10.appendChild(el11);
      var el12 = document.createElement("abbr");
      el12.className += " _coral-Calendar-dayOfWeek";
      el12.setAttribute("title", data_1["dayFullName"]);
      el12.textContent = data_1["dayAbbr"];
      el10.appendChild(el12);
      var el13 = document.createTextNode("\n        ");
      el10.appendChild(el13);
      el6.appendChild(el10);
      var el14 = document.createTextNode("\n      ");
      el6.appendChild(el14);
    }

    var el15 = document.createTextNode("\n    ");
    el6.appendChild(el15);
    el4.appendChild(el6);
    var el16 = document.createTextNode("\n  ");
    el4.appendChild(el16);
    el2.appendChild(el4);
    var el17 = document.createTextNode("\n  ");
    el2.appendChild(el17);
    var el18 = document.createElement("tbody");
    el18.setAttribute("role", "presentation");
    var el19 = document.createTextNode("\n    ");
    el18.appendChild(el19);
    var iterated_1 = data_0["weeks"];

    for (var i1 = 0, ni1 = iterated_1.length; i1 < ni1; i1++) {
      var data_1 = data = iterated_1[i1];
      var el21 = document.createTextNode("\n      ");
      el18.appendChild(el21);
      var el22 = document.createElement("tr");
      el22.setAttribute("role", "row");
      var el23 = document.createTextNode("\n        ");
      el22.appendChild(el23);
      var iterated_2 = data_1;

      for (var i2 = 0, ni2 = iterated_2.length; i2 < ni2; i2++) {
        var data_2 = data = iterated_2[i2];
        var el25 = document.createTextNode("\n          ");
        el22.appendChild(el25);
        data = data_2;
        var calendarTitle;
        var calendarDate = data.dateLabel + ', ' + data.formattedDate;

        if (data.isToday) {
          if (data.ariaSelected) {
            calendarTitle = this.i18n.get('Today, {0} selected', calendarDate, 'date');
          } else {
            calendarTitle = this.i18n.get('Today, {0}', calendarDate, 'date');
          }
        } else {
          if (data.ariaSelected) {
            calendarTitle = this.i18n.get('{0} selected', calendarDate, 'date');
          } else {
            calendarTitle = calendarTitle = calendarDate;
          }
        }

        data_2 = data;
        var el27 = document.createTextNode("\n          ");
        el22.appendChild(el27);
        var el28 = this["cell"] = document.createElement("td");
        el28.setAttribute("handle", "cell");
        el28.setAttribute("role", "gridcell");
        el28.id = this["commons"]["getUID"]() + "-row" + i1 + "-col" + i2;
        el28.className += " _coral-Calendar-tableCell";
        el28.setAttribute("aria-selected", data_2["ariaSelected"]);

        if (data_2["isDisabled"]) {
          el28.setAttribute("aria-disabled", "true");
        }

        if (data_2["ariaInvalid"]) {
          el28.setAttribute("aria-invalid", "true");
        }

        if (data_2["formattedDate"]) {
          el28.setAttribute("title", calendarTitle);
        }

        var el29 = document.createTextNode("\n            ");
        el28.appendChild(el29);
        data = data_2;

        if (data.cssClass.indexOf('is-outsideMonth') !== -1) {
          this.cell.classList.add('is-outsideMonth');
        }

        data_2 = data;
        var el31 = document.createTextNode("\n            ");
        el28.appendChild(el31);

        if (data_2["dateAttr"]) {
          var el33 = document.createTextNode("\n                ");
          el28.appendChild(el33);
          var el34 = document.createElement("a");
          el34.setAttribute("role", "presentation");
          el34.className += " _coral-Calendar-date " + data_2["cssClass"];
          el34.setAttribute("data-date", data_2["dateAttr"]);
          el34.textContent = data_2["dateText"];
          el28.appendChild(el34);
          var el35 = document.createTextNode("\n              ");
          el28.appendChild(el35);
          var el36 = document.createTextNode("\n            ");
          el28.appendChild(el36);
        } else {
          var el37 = document.createTextNode("\n                ");
          el28.appendChild(el37);
          var el38 = document.createElement("span");
          el38.setAttribute("role", "presentation");
          el38.className += " _coral-Calendar-date " + data_2["cssClass"];
          el38.textContent = data_2["dateText"];
          el28.appendChild(el38);
          var el39 = document.createTextNode("\n              ");
          el28.appendChild(el39);
        }

        var el40 = document.createTextNode("\n          ");
        el28.appendChild(el40);
        el22.appendChild(el28);
        var el41 = document.createTextNode("\n        ");
        el22.appendChild(el41);
      }

      var el42 = document.createTextNode("\n      ");
      el22.appendChild(el42);
      el18.appendChild(el22);
      var el43 = document.createTextNode("\n    ");
      el18.appendChild(el43);
    }

    var el44 = document.createTextNode("\n  ");
    el18.appendChild(el44);
    el2.appendChild(el18);
    var el45 = document.createTextNode("\n  ");
    el2.appendChild(el45);
    var el46 = document.createElement("caption");
    el46.className += " u-coral-screenReaderOnly";
    el46.setAttribute("aria-live", "assertive");
    el46.setAttribute("aria-atomic", "true");
    el2.appendChild(el46);
    var el47 = document.createTextNode("\n");
    el2.appendChild(el47);
    frag.appendChild(el2);
    var el48 = document.createTextNode("\n");
    frag.appendChild(el48);
    return frag;
  };

  /** @ignore */

  function isDateInRange(date, startDate, endDate) {
    if (!date) {
      return false;
    }

    if (startDate === null && endDate === null) {
      return true;
    } else if (startDate === null) {
      return date.toDate() <= endDate;
    } else if (endDate === null) {
      return date.toDate() >= startDate;
    }

    return startDate <= date.toDate() && date.toDate() <= endDate;
  }
  /** @ignore */


  function toMoment(value, format) {
    if (value === 'today') {
      return new DateTime.Moment().startOf('day');
    } else if (DateTime.Moment.isMoment(value)) {
      return value.isValid() ? value.clone() : null;
    } // if the value provided is a date it does not make sense to provide a format to parse the date


    var result = new DateTime.Moment(value, value instanceof Date ? null : format);
    return result.isValid() ? result.startOf('day') : null;
  }
  /** @ignore */


  function validateAsChangedAndValidMoment(newValue, oldValue) {
    // if the value is undefined we change it to null since moment considers both to be different
    newValue = newValue || null;
    oldValue = oldValue || null;

    if (newValue !== oldValue && !new DateTime.Moment(newValue).isSame(oldValue, 'day')) {
      return newValue === null || newValue.isValid();
    }

    return false;
  }
  /**
   Slides in new month tables, slides out old tables, and then cleans up the leftovers when it is done.

   @ignore
   */


  function TableAnimator(host) {
    var _this = this;

    this.host = host;

    this._addContainerIfNotPresent = function (width, height) {
      if (!_this.container) {
        // Get a fresh container for the animation:
        template$k.call(_this, {
          width: width,
          height: height
        });

        _this.host.appendChild(_this.container);
      }
    };

    this._removeContainerIfEmpty = function () {
      if (_this.container && _this.container.children.length === 0) {
        _this.host.removeChild(_this.container);

        _this.container = null;
      }
    };

    this.slide = function (newTable, direction) {
      var replace = direction === undefined;
      var isLeft = direction === 'left';
      var oldTable = _this.oldTable; // Should the replace flag be raised, or no old table be present, then do a non-transitioned (re)place and exit

      if (replace || !oldTable) {
        if (oldTable) {
          oldTable.parentNode.removeChild(oldTable);
        }

        _this.host.insertBefore(newTable, _this.host.firstChild);

        _this.oldTable = newTable;
        return;
      }

      var boundingClientRect = oldTable.getBoundingClientRect();
      var width = boundingClientRect.width;
      var height = boundingClientRect.height;

      _this._addContainerIfNotPresent(width, height); // Add both the old and the new table to the container:


      _this.container.appendChild(oldTable);

      _this.container.appendChild(newTable); // Set the existing table to start from being in full view, and mark it to transition on `left` changing


      oldTable.classList.add('_coral-Calendar-table--transit');
      commons.transitionEnd(oldTable, function () {
        oldTable.parentNode.removeChild(oldTable);

        _this._removeContainerIfEmpty();
      }); // Set the new table to start out of view (either left or right depending on the direction of the slide), and mark
      // it to transition on `left` changing

      newTable.classList.add('_coral-Calendar-table--transit');
      newTable.style.left = "".concat(isLeft ? width : -width, "px"); // When the transition is done, have the transition class lifted

      commons.transitionEnd(newTable, function () {
        newTable.classList.remove('_coral-Calendar-table--transit');

        _this.host.appendChild(newTable);

        _this._removeContainerIfEmpty();
      }); // Force a redraw by querying the browser for its offsetWidth. Without this, the re-positioning code later on
      // would not lead to a transition. Note that there's no significance to the resulting value being assigned to
      // 'height'

      height = _this.container.offsetWidth; // Set the `left` positions to transition to:

      oldTable.style.left = "".concat(isLeft ? -width : width, "px");
      newTable.style.left = 0;
      _this.oldTable = newTable;
    };
  }
  /** @ignore */


  var ARRAYOF6 = [0, 0, 0, 0, 0, 0];
  /** @ignore */

  var ARRAYOF7 = [0, 0, 0, 0, 0, 0, 0];
  /** @ignore */

  var INTERNAL_FORMAT = 'YYYY-MM-DD';
  /** @ignore */

  var timeUnit = {
    YEAR: 'year',
    MONTH: 'month',
    WEEK: 'week',
    DAY: 'day'
  };
  var CLASSNAME$C = '_coral-Calendar';
  /**
   @class Coral.Calendar
   @classdesc A Calendar component that can be used as a date selection form field. Leverages {@link momentJS} if loaded
   on the page.
   @htmltag coral-calendar
   @extends {HTMLElement}
   @extends {BaseComponent}
   @extends {BaseFormField}
   */

  var Calendar = Decorator( /*#__PURE__*/function (_BaseFormField) {
    _inherits(_class, _BaseFormField);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this2;

      _classCallCheck(this, _class);

      _this2 = _super.call(this); // Default value

      _this2._value = null;

      _this2._delegateEvents(commons.extend(_this2._events, {
        'click ._coral-Calendar-nextMonth,._coral-Calendar-prevMonth': '_onNextOrPreviousMonthClick',
        'click ._coral-Calendar-body ._coral-Calendar-date': '_onDayClick',
        'capture:focus ._coral-Calendar-body': '_onBodyFocus',
        'mousedown ._coral-Calendar-body ._coral-Calendar-date': '_onDayMouseDown',
        'key:up ._coral-Calendar-body': '_onUpKey',
        'key:right ._coral-Calendar-body': '_onRightKey',
        'key:down ._coral-Calendar-body': '_onDownKey',
        'key:left ._coral-Calendar-body': '_onLeftKey',
        'key:home ._coral-Calendar-body': '_onHomeOrEndKey',
        'key:end ._coral-Calendar-body': '_onHomeOrEndKey',
        'key:pageup': '_onPageUpKey',
        'key:pagedown': '_onPageDownKey',
        // On OSX we use Command+Page Up
        'key:meta+pageup': '_onCtrlPageUpKey',
        // On OSX we use Command+Page Down
        'key:meta+pagedown': '_onCtrlPageDownKey',
        // On Windows, we use CTRL+Page Up
        'key:ctrl+pageup': '_onCtrlPageUpKey',
        // On Windows, we use CTRL+Page Down
        'key:ctrl+pagedown': '_onCtrlPageDownKey',
        // Use alt+pageup/alt+pagedown and shift+pageup/shift+pagedown to jump by year
        'key:alt+pageup': '_onCtrlPageUpKey',
        'key:alt+pagedown': '_onCtrlPageDownKey',
        'key:shift+pageup': '_onCtrlPageUpKey',
        'key:shift+pagedown': '_onCtrlPageDownKey',
        'key:enter ._coral-Calendar-body': '_onEnterKey',
        'key:return ._coral-Calendar-body': '_onEnterKey',
        'key:space ._coral-Calendar-body': '_onEnterKey'
      })); // Prepare templates


      _this2._elements = {};
      template$j.call(_this2._elements, {
        commons: commons,
        i18n: i18n,
        Icon: Icon
      }); // Pre-define labellable element

      _this2._labellableElement = _assertThisInitialized(_this2); // Internal keeper of the month that is currently on display.

      _this2._cursor = null; // Internal keeper for the id of the currently focused date cell or the cell that would receive focus when the
      // calendar body receives focus.

      _this2._activeDescendant = null;
      _this2._animator = new TableAnimator(_this2._elements.body);
      return _this2;
    }
    /**
     Defines the start day for the week, 0 = Sunday, 1 = Monday etc., as depicted on the calendar days grid.
      @type {Number}
     @default 0
     @htmlattribute startday
     */


    _createClass(_class, [{
      key: "_renderCalendar",

      /** @ignore */
      value: function _renderCalendar(slide) {
        var _this3 = this;

        var cursor = this._requireCursor();

        var displayYear = cursor.year();
        var displayMonth = cursor.month();
        var oldTable = this._animator.oldTable;
        this._elements.heading.innerHTML = new DateTime.Moment([displayYear, displayMonth, 1]).format(this.headerFormat);

        var newTable = this._renderTable(displayYear, displayMonth + 1);

        if (oldTable) {
          commons.transitionEnd(newTable, function () {
            _this3._setActiveDescendant();
          });
        }

        this._animator.slide(newTable, slide);

        var el = this._elements.body.querySelector('.is-selected'); // This will be overwritten later if there is any other function setting the attribute


        this._activeDescendant = el ? el.id : null;

        this._setActiveDescendant();
      }
      /**
       Returns <code>true</code> if moment specified is before <code>min</code>.
        @param {moment} currentMoment
       A moment to test.
       @param {String} unit
       Year, Month, Week, Day
       @returns {Boolean}
       <code>true</code> if moment specified is before <code>min</code>
        @ignore
       */

    }, {
      key: "_isBeforeMin",
      value: function _isBeforeMin(currentMoment, unit) {
        var min = this.min ? new DateTime.Moment(this.min) : null;
        return min && currentMoment.isBefore(min, unit);
      }
      /**
       Returns <code>true</code> if moment specified is after <code>max</code>.
        @param {moment} currentMoment
       A moment to test.
       @param {String} unit
       Year, Month, Week, Day
       @returns {Boolean}
       <code>true</code> if moment specified is after <code>max</code>
        @ignore
       */

    }, {
      key: "_isAfterMax",
      value: function _isAfterMax(currentMoment, unit) {
        var max = this.max ? new DateTime.Moment(this.max) : null;
        return max && currentMoment.isAfter(max, unit);
      }
      /**
       Returns <code>true</code> if moment specified is greater than or equal to <code>min</code> and less than or equal to <code>max</code>.
        @param {moment} currentMoment
       A moment to test.
       @param {String} unit
       Year, Month, Week, Day
       @returns {Boolean}
       <code>true</code> if moment specified falls within <code>min</code>/<code>max</code> date range.
        @ignore
       */

    }, {
      key: "_isInRange",
      value: function _isInRange(currentMoment, unit) {
        return !(this._isBeforeMin(currentMoment, unit) || this._isAfterMax(currentMoment, unit));
      }
      /**
       Updates the aria-activedescendant property for the calendar grid to communicate the currently focused date, or the
       date that should get focus when the grid receives focus, to assistive technology.
        @ignore
       */

    }, {
      key: "_setActiveDescendant",
      value: function _setActiveDescendant() {
        var _this4 = this;

        var el;

        var isActiveDescendantMissing = function isActiveDescendantMissing() {
          return !_this4._activeDescendant || !_this4._elements.body.querySelector("#".concat(_this4._activeDescendant, " [data-date]"));
        };

        if (isActiveDescendantMissing()) {
          this._activeDescendant = null;
          el = this._elements.body.querySelector('.is-selected');
          this._activeDescendant = el && el.id;

          if (isActiveDescendantMissing()) {
            var currentMoment = this._value;

            if (currentMoment) {
              var dates = this._elements.body.querySelectorAll('[data-date]');

              if (this._isBeforeMin(currentMoment)) {
                el = dates[0];
              } else if (this._isAfterMax(currentMoment)) {
                el = dates.length ? dates[dates.length - 1] : null;
              }
            } else {
              el = this._elements.body.querySelector('.is-focused') || this._elements.body.querySelector('.is-today');
            }

            if (el) {
              this._activeDescendant = el.parentElement.id;
            }
          }
        }

        el = this._elements.body.querySelector('.is-focused');

        if (el) {
          el.classList.remove('is-focused');
        }

        this._elements.body[this._activeDescendant ? 'setAttribute' : 'removeAttribute']('aria-activedescendant', this._activeDescendant);

        this._updateTableCaption();

        if (!this._activeDescendant) {
          return;
        }

        el = document.getElementById(this._activeDescendant);

        if (!el) {
          return;
        }

        var newTable = this.querySelector('._coral-Calendar-table--transit');
        var isTransitioning = newTable !== null;

        if (isTransitioning) {
          window.requestAnimationFrame(function () {
            el.querySelector('._coral-Calendar-date').classList.add('is-focused');
          });
        } else {
          // Focus the selected date
          el.querySelector('._coral-Calendar-date').classList.add('is-focused');
        }
      }
      /**
       Updates the table caption which serves as a live region to announce the currently focused date to assistive
       technology, improving compatibility across operating systems, browsers and screen readers.
        @ignore
       */

    }, {
      key: "_updateTableCaption",
      value: function _updateTableCaption() {
        var caption = this._elements.body.querySelector('caption');

        if (!caption) {
          return;
        }

        if (caption.firstChild) {
          caption.removeChild(caption.firstChild);
        }

        if (this._activeDescendant) {
          var activeDescendant = this._elements.body.querySelector("#".concat(this._activeDescendant));

          var captionText = document.createTextNode(activeDescendant.getAttribute('title'));
          caption.appendChild(captionText);
        }
      }
      /** @ignore */

    }, {
      key: "_renderTable",
      value: function _renderTable(year, month) {
        var _this5 = this;

        var firstDate = new DateTime.Moment([year, month - 1, 1]);
        var monthStartsAt = (firstDate.day() - this.startDay) % 7;
        var dateLocal = this._value ? this._value.clone().startOf('day') : null;

        if (monthStartsAt < 0) {
          monthStartsAt += 7;
        }

        var data = {
          i18n: i18n,
          commons: commons,
          // eslint-disable-next-line no-unused-vars
          dayNames: ARRAYOF7.map(function (currentIndex, index) {
            var dayMoment = new DateTime.Moment().day((index + _this5.startDay) % 7);
            return {
              dayAbbr: dayMoment.format('dd'),
              dayFullName: dayMoment.format('dddd')
            };
          }, this),
          // eslint-disable-next-line no-unused-vars, arrow-body-style
          weeks: ARRAYOF6.map(function (currentWeekIndex, weekIndex) {
            // eslint-disable-next-line no-unused-vars
            return ARRAYOF7.map(function (currentDayIndex, dayIndex) {
              var result = {};
              var cssClass = _this5.disabled ? ['is-disabled'] : [];
              var ariaSelected = false;
              var ariaInvalid = false;
              var day = weekIndex * 7 + dayIndex - monthStartsAt;
              var cursor = new DateTime.Moment([year, month - 1]); // we use add() since 'day' could be a negative value

              cursor.add(day, 'days');
              var isCurrentMonth = cursor.month() + 1 === parseFloat(month);
              var dayOfWeek = new DateTime.Moment().day((dayIndex + _this5.startDay) % 7).format('dddd');
              var isToday = cursor.isSame(new DateTime.Moment(), 'day');
              var cursorLocal = cursor.clone().startOf('day');

              if (isToday) {
                cssClass.push('is-today');
              }

              if (dateLocal && cursorLocal.isSame(dateLocal, 'day')) {
                ariaSelected = true;
                cssClass.push('is-selected');

                if (_this5.invalid) {
                  ariaInvalid = true;
                  cssClass.push('is-invalid');
                }
              }

              if (isCurrentMonth) {
                cssClass.push('is-currentMonth');

                if (!_this5.disabled && isDateInRange(cursor, _this5.min, _this5.max)) {
                  result.dateAttr = cursorLocal.format(INTERNAL_FORMAT);
                  result.weekIndex = cursor.week();
                  result.formattedDate = cursor.format('LL');
                } else {
                  cssClass.push('is-disabled');
                }
              } else {
                cssClass.push('is-outsideMonth');
              }

              result.isDisabled = _this5.disabled || !result.dateAttr;
              result.dateText = cursor.date();
              result.cssClass = cssClass.join(' ');
              result.isToday = isToday;
              result.ariaSelected = ariaSelected;
              result.ariaInvalid = ariaInvalid;
              result.dateLabel = dayOfWeek;
              result.weekIndex = cursor.week();
              return result;
            }, _this5);
          }, this)
        };
        var handles = {};
        template$l.call(handles, data);
        return handles.table;
      }
      /** @ignore */

    }, {
      key: "_requireCursor",
      value: function _requireCursor() {
        var cursor = this._cursor;

        if (!cursor || !cursor.isValid()) {
          // When its unknown what month we should be showing, use the set date. If that is not available, use 'today'
          cursor = (this._value ? this._value.clone().startOf('day') : new DateTime.Moment()).startOf('month');
          this._cursor = cursor;
        }

        return cursor;
      }
      /**
       Navigate to previous or next timeUnit interval.
        @param {String} unit
       Year, Month, Week, Day
       @param {Boolean} isNext
       Whether to navigate forward or backward.
        @private
       */

    }, {
      key: "_gotoPreviousOrNextTimeUnit",
      value: function _gotoPreviousOrNextTimeUnit(unit, isNext) {
        var direction = isNext ? 'left' : 'right';
        var operator = isNext ? 'add' : 'subtract';

        var el = this._elements.body.querySelector('._coral-Calendar-date.is-focused');

        var currentActive;
        var currentMoment;
        var newMoment;
        var difference;

        if (el) {
          currentActive = el.dataset.date;
          currentMoment = new DateTime.Moment(currentActive);
          newMoment = currentMoment[operator](1, unit); // make sure new moment is in range before transitioning

          if (!this._isInRange(newMoment)) {
            // advance to closest value in range
            if (this._isBeforeMin(newMoment)) {
              newMoment = this.min;
            } else if (this._isAfterMax(newMoment)) {
              newMoment = this.max;
            }

            newMoment = new DateTime.Moment(newMoment);
          }

          difference = Math.abs(new DateTime.Moment(currentActive).diff(newMoment, 'days'));

          this._getToNewMoment(direction, operator, difference);

          this._setActiveDescendant();
        } else {
          this._requireCursor(); // if cursor is out of range


          if (!this._isInRange(this._cursor)) {
            // advance to closest value in range
            if (this._isBeforeMin(this._cursor)) {
              newMoment = this.min;
            } else if (this._isAfterMax(this._cursor)) {
              newMoment = this.max;
            }

            newMoment = new DateTime.Moment(newMoment);
            difference = Math.abs(this._cursor.diff(newMoment, 'days'));

            this._getToNewMoment(direction, operator, difference);

            this._setActiveDescendant();

            return;
          }

          this._cursor[operator](1, unit);

          this._renderCalendar(direction);
        }
      }
      /**
       Checks if the Calendar is valid or not. This is done by checking that the current value is between the
       provided <code>min</code> and <code>max</code> values. This check is only performed on user interaction.
       @ignore
       */

    }, {
      key: "_validateCalendar",
      value: function _validateCalendar() {
        var isInvalid = !(this._value === null || isDateInRange(this._value, this.min, this.max));

        if (this.invalid !== isInvalid) {
          this.invalid = isInvalid;
        }
      }
      /** @ignore */

    }, {
      key: "_onNextOrPreviousMonthClick",
      value: function _onNextOrPreviousMonthClick(event) {
        event.preventDefault();

        this._gotoPreviousOrNextTimeUnit(event.altKey || event.metaKey || event.shiftKey ? timeUnit.YEAR : timeUnit.MONTH, this._elements.next === event.matchedTarget);

        event.matchedTarget.focus();

        this._validateCalendar();
      }
      /** @ignore */

    }, {
      key: "_getToNewMoment",
      value: function _getToNewMoment(direction, operator, difference) {
        var el = this._elements.body.querySelector('._coral-Calendar-date.is-focused');

        var currentActive;

        if (el) {
          currentActive = el.dataset.date;
        } else {
          this._requireCursor();

          currentActive = this._cursor.format(INTERNAL_FORMAT);
        }

        var currentMoment = new DateTime.Moment(currentActive);
        var currentMonth = currentMoment.month();
        var currentYear = currentMoment.year();
        var newMoment = currentMoment[operator](difference, 'days');
        var newMonth = newMoment.month();
        var newYear = newMoment.year();
        var newMomentValue = newMoment.format(INTERNAL_FORMAT);

        if (newMonth !== currentMonth) {
          this._requireCursor();

          this._cursor[operator](1, 'months');

          this._renderCalendar(direction);
        } else if (newMonth === currentMonth && newYear !== currentYear) {
          this._requireCursor();

          this._cursor[operator](1, 'years');

          this._renderCalendar(direction);
        }

        var dateQuery = "._coral-Calendar-date[data-date^=".concat(JSON.stringify(newMomentValue), "]");

        var newDescendant = this._elements.body.querySelector(dateQuery);

        if (newDescendant) {
          this._activeDescendant = newDescendant.parentNode.getAttribute('id');
        }
      }
      /** @ignore */

    }, {
      key: "_onDayMouseDown",
      value: function _onDayMouseDown(event) {
        this._activeDescendant = event.target.parentNode.id;

        this._setActiveDescendant();

        this._elements.body.focus();

        this._validateCalendar();
      }
      /** @ignore */

    }, {
      key: "_onDayClick",
      value: function _onDayClick(event) {
        event.preventDefault();

        this._elements.body.focus();

        var date = new DateTime.Moment(event.target.dataset.date, INTERNAL_FORMAT);
        var dateLocal; // Carry over any user set time info

        if (this._value) {
          dateLocal = this._value.clone();
        } // Set attribute so a change event will be triggered if the user has selected a different date


        if (validateAsChangedAndValidMoment(date, dateLocal)) {
          this.value = date;
          this.trigger('change');
        }

        this._validateCalendar();
      }
      /** @ignore */

    }, {
      key: "_onEnterKey",
      value: function _onEnterKey(event) {
        event.preventDefault();

        var el = this._elements.body.querySelector('._coral-Calendar-date.is-focused');

        if (el) {
          el.click();
        }

        this._validateCalendar();
      }
      /** @ignore */

    }, {
      key: "_onUpKey",
      value: function _onUpKey(event) {
        event.preventDefault();
        event.stopPropagation();

        this._gotoPreviousOrNextTimeUnit(timeUnit.WEEK, false);

        this._validateCalendar();
      }
      /** @ignore */

    }, {
      key: "_onDownKey",
      value: function _onDownKey(event) {
        event.preventDefault();
        event.stopPropagation();

        this._gotoPreviousOrNextTimeUnit(timeUnit.WEEK, true);

        this._validateCalendar();
      }
      /** @ignore */

    }, {
      key: "_onRightKey",
      value: function _onRightKey(event) {
        event.preventDefault();
        event.stopPropagation();

        this._gotoPreviousOrNextTimeUnit(timeUnit.DAY, true);

        this._validateCalendar();
      }
      /** @ignore */

    }, {
      key: "_onLeftKey",
      value: function _onLeftKey(event) {
        event.preventDefault();
        event.stopPropagation();

        this._gotoPreviousOrNextTimeUnit(timeUnit.DAY, false);

        this._validateCalendar();
      }
      /** @ignore */

    }, {
      key: "_onHomeOrEndKey",
      value: function _onHomeOrEndKey(event) {
        event.preventDefault();
        event.stopPropagation();
        var isHome = event.keyCode === Keys.keyToCode('home');
        var direction = '';
        var operator = isHome ? 'subtract' : 'add';

        var el = this._elements.body.querySelector('._coral-Calendar-date.is-focused');

        if (el) {
          var currentActive = el.dataset.date;
          var currentMoment = new DateTime.Moment(currentActive);
          var difference = isHome ? currentMoment.date() - 1 : currentMoment.daysInMonth() - currentMoment.date();

          this._getToNewMoment(direction, operator, difference);

          this._setActiveDescendant();
        }

        this._validateCalendar();
      }
      /** @ignore */

    }, {
      key: "_onPageDownKey",
      value: function _onPageDownKey(event) {
        event.preventDefault();
        event.stopPropagation();

        this._gotoPreviousOrNextTimeUnit(timeUnit.MONTH, true);

        this._validateCalendar();
      }
      /** @ignore */

    }, {
      key: "_onPageUpKey",
      value: function _onPageUpKey(event) {
        event.preventDefault();
        event.stopPropagation();

        this._gotoPreviousOrNextTimeUnit(timeUnit.MONTH, false);

        this._validateCalendar();
      }
      /** @ignore */

    }, {
      key: "_onCtrlPageDownKey",
      value: function _onCtrlPageDownKey(event) {
        event.preventDefault();
        event.stopPropagation();

        this._gotoPreviousOrNextTimeUnit(timeUnit.YEAR, true);

        this._validateCalendar();
      }
      /** @ignore */

    }, {
      key: "_onCtrlPageUpKey",
      value: function _onCtrlPageUpKey(event) {
        event.preventDefault();
        event.stopPropagation();

        this._gotoPreviousOrNextTimeUnit(timeUnit.YEAR, false);

        this._validateCalendar();
      }
      /** @ignore */

    }, {
      key: "_onBodyFocus",
      value: function _onBodyFocus() {
        if (Boolean(this._value)) {
          this._setActiveDescendant();

          this._validateCalendar();
        }
      }
      /**
       sets focus to appropriate descendant
       */

    }, {
      key: "focus",
      value: function focus() {
        var focusedElement = this._elements.body.querySelector('.is-focused');

        if (focusedElement !== document.activeElement && !this.disabled) {
          this._setActiveDescendant();

          this._elements.body.focus();
        }
      }
    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$C);
        this.setAttribute('role', 'group'); // Default reflected attribute

        if (!this._valueFormat) {
          this.valueFormat = INTERNAL_FORMAT;
        }

        var frag = document.createDocumentFragment(); // Render template

        frag.appendChild(this._elements.input);
        frag.appendChild(this._elements.header);
        frag.appendChild(this._elements.body); /// Clean Up (cloneNode support)

        while (this.firstChild) {
          this.removeChild(this.firstChild);
        }

        this.appendChild(frag); // Render the calendar body if it's empty

        if (!this._elements.body.firstElementChild) {
          this._renderCalendar();
        }
      }
    }, {
      key: "startDay",
      get: function get() {
        if (this._startDay) {
          return this._startDay;
        }

        if (typeof DateTime.Moment.localeData(i18n.locale).firstDayOfWeek !== 'undefined') {
          return DateTime.Moment.localeData(i18n.locale).firstDayOfWeek();
        }

        return 0;
      },
      set: function set(value) {
        if (value >= 0 && value < 7) {
          this._startDay = value;

          this._renderCalendar();
        }
      }
      /**
       The format used to display the current month and year.
       'MMMM YYYY' is supported by default. Include momentjs to support additional format string options see
       http://momentjs.com/docs/#/displaying/.
        @type {String}
       @default "MMMM YYYY"
       @htmlattribute headerformat
       */

    }, {
      key: "headerFormat",
      get: function get() {
        return this._headerFormat || 'MMMM YYYY';
      },
      set: function set(value) {
        this._headerFormat = transform.string(value);

        this._renderCalendar();
      }
      /**
       The minimal selectable date in the Calendar view. When passed a string, it needs to be 'YYYY-MM-DD' formatted.
        @type {String|Date}
       @default null
       @htmlattribute min
       */

    }, {
      key: "min",
      get: function get() {
        return this._min ? this._min.toDate() : null;
      },
      set: function set(value) {
        value = toMoment(value, this.valueFormat);

        if (validateAsChangedAndValidMoment(value, this._min)) {
          this._min = value;

          this._renderCalendar();
        }
      }
      /**
       The max selectable date in the Calendar view. When passed a string, it needs to be 'YYYY-MM-DD'
       formatted.
        @type {String|Date}
       @default null
       @htmlattribute max
       */

    }, {
      key: "max",
      get: function get() {
        return this._max ? this._max.toDate() : null;
      },
      set: function set(value) {
        value = toMoment(value, this.valueFormat);

        if (validateAsChangedAndValidMoment(value, this._max)) {
          this._max = value;

          this._renderCalendar();
        }
      }
      /**
       The format to use on expressing the selected date as a string on the <code>value</code> attribute.
       'YYYY-MM-DD' is supported by default. Include momentjs to support additional format string options see
       http://momentjs.com/docs/#/displaying/.
        @type {String}
       @default "YYYY-MM-DD"
       @htmlattribute valueformat
       @htmlattributereflected
       */

    }, {
      key: "valueFormat",
      get: function get() {
        return this._valueFormat || INTERNAL_FORMAT;
      },
      set: function set(value) {
        var _this6 = this;

        value = transform.string(value);

        var setValueFormat = function setValueFormat(newValue) {
          _this6._valueFormat = newValue;

          _this6._reflectAttribute('valueformat', _this6._valueFormat);
        }; // Once the valueFormat is set, we make sure the value is also correct


        if (!this._valueFormat && this._originalValue) {
          setValueFormat(value);
          this.value = this._originalValue;
        } else {
          setValueFormat(value);
          this._elements.input.value = this.value;
        }
      }
      /**
       The value returned, or set, as a Date. If the value is '' it will return <code>null</code>.
        @type {Date}
       @default null
       */

    }, {
      key: "valueAsDate",
      get: function get() {
        return this._value ? this._value.toDate() : null;
      },
      set: function set(value) {
        if (value instanceof Date) {
          this._valueAsDate = new DateTime.Moment(value);
          this.value = this._valueAsDate;
        } else {
          this._valueAsDate = null;
          this.value = '';
        }
      }
      /**
       The current value. When set to 'today', the value is coerced into the clients local date expressed as string
       formatted in accordance to the set <code>valueFormat</code>.
        @type {String}
       @default ""
       @htmlattribute value
       */

    }, {
      key: "value",
      get: function get() {
        return this._value ? this._value.format(this.valueFormat) : '';
      },
      set: function set(value) {
        // This is used to change the value if valueformat is also set but afterwards
        this._originalValue = value;
        value = toMoment(value, this.valueFormat);

        if (validateAsChangedAndValidMoment(value, this._value)) {
          this._value = value;
          this._elements.input.value = this.value; // resets the view cursor, so the selected month will be in view

          this._cursor = null;

          this._renderCalendar();

          this.required = this.required;
        }
      }
      /**
       Name used to submit the data in a form.
       @type {String}
       @default ""
       @htmlattribute name
       @htmlattributereflected
       */

    }, {
      key: "name",
      get: function get() {
        return this._elements.input.name;
      },
      set: function set(value) {
        this._reflectAttribute('name', value);

        this._elements.input.name = value;
      }
      /**
       Whether this field is required or not.
       @type {Boolean}
       @default false
       @htmlattribute required
       @htmlattributereflected
       */

    }, {
      key: "required",
      get: function get() {
        return this._required || false;
      },
      set: function set(value) {
        this._required = transform.booleanAttr(value);

        this._reflectAttribute('required', this._required);

        this.classList.toggle('is-required', this._required && this._value === null);
      }
      /**
       Whether this field is disabled or not.
       @type {Boolean}
       @default false
       @htmlattribute disabled
       @htmlattributereflected
       */

    }, {
      key: "disabled",
      get: function get() {
        return this._disabled || false;
      },
      set: function set(value) {
        this._disabled = transform.booleanAttr(value);

        this._reflectAttribute('disabled', this._disabled);

        this.classList.toggle('is-disabled', this._disabled);
        this._elements.prev.disabled = this._disabled;
        this._elements.next.disabled = this._disabled;

        this._elements.body[this._disabled ? 'setAttribute' : 'removeAttribute']('aria-disabled', this._disabled);

        this._elements.body[this._disabled ? 'removeAttribute' : 'setAttribute']('tabindex', '0');

        this._renderCalendar();
      }
      /**
       Inherited from {@link BaseFormField#invalid}.
       */

    }, {
      key: "invalid",
      get: function get() {
        return _get(_getPrototypeOf(_class.prototype), "invalid", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(_class.prototype), "invalid", value, this, true);

        this._renderCalendar();
      }
      /**
       Whether this field is readOnly or not. Indicating that the user cannot modify the value of the control.
       @type {Boolean}
       @default false
       @htmlattribute readonly
       @htmlattributereflected
       */

    }, {
      key: "readOnly",
      get: function get() {
        return this._readOnly || false;
      },
      set: function set(value) {
        this._readOnly = transform.booleanAttr(value);

        this._reflectAttribute('readonly', this._readOnly);

        this._elements.prev.disabled = this._readOnly;
        this._elements.next.disabled = this._readOnly;

        this._elements.body[this._readOnly ? 'removeAttribute' : 'setAttribute']('tabindex', '0');

        this.classList.toggle('is-readOnly', this._readOnly);
      }
    }], [{
      key: "_attributePropertyMap",
      get: function get() {
        return commons.extend(_get(_getPrototypeOf(_class), "_attributePropertyMap", this), {
          startday: 'startDay',
          headerformat: 'headerFormat',
          valueformat: 'valueFormat'
        });
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['startday', 'headerformat', 'min', 'max', 'valueformat']);
      }
    }]);

    return _class;
  }(BaseFormField(BaseComponent(HTMLElement))));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons.extend(strings, {
    'coral-component-calendar': translations$b
  }); // Expose component on the Coral namespace

  commons._define('coral-calendar', Calendar);

  var template$m = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["wrapper"] = document.createElement("div");
    el0.setAttribute("handle", "wrapper");
    el0.className += " _coral-Card-wrapper";
    frag.appendChild(el0);
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    return frag;
  };

  var COLOR_HINT_REG_EXP = /^#[0-9A-F]{6}$/i;
  /**
   Enumeration for {@link Card} variants.

   @typedef {Object} CardVariantEnum

   @property {String} DEFAULT
   Default card variant that shows the asset, overlay and content in their default positions.
   @property {String} QUIET
   Quiet card variant that shows the asset, overlay and content in their default positions.
   @property {String} CONDENSED
   Condensed card variant where the overlay is hidden and the content is shown over the image.
   @property {String} INVERTED
   Condensed card variant where the overlay is hidden and the content is shown over the image with a dark style.
   @property {String} ASSET
   Card variant where only the asset is shown.
   */

  var variant$c = {
    DEFAULT: 'default',
    QUIET: 'quiet',
    CONDENSED: 'condensed',
    INVERTED: 'inverted',
    ASSET: 'asset'
  }; // the card's base classname

  var CLASSNAME$D = '_coral-Card'; // builds a string containing all possible variant classnames. this will be used to remove classnames when the variant
  // changes

  var ALL_VARIANT_CLASSES$8 = [];

  for (var variantValue$6 in variant$c) {
    ALL_VARIANT_CLASSES$8.push("".concat(CLASSNAME$D, "--").concat(variant$c[variantValue$6]));
  }
  /**
   @class Coral.Card
   @classdesc A Card component to display content in different variations.
   @htmltag coral-card
   @extends {HTMLElement}
   @extends {BaseComponent}
   */


  var Card = Decorator( /*#__PURE__*/function (_BaseComponent) {
    _inherits(_class, _BaseComponent);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this); // Prepare templates

      _this._elements = {
        // Fetch or create the content zone elements
        asset: _this.querySelector('coral-card-asset') || document.createElement('coral-card-asset'),
        content: _this.querySelector('coral-card-content') || document.createElement('coral-card-content'),
        info: _this.querySelector('coral-card-info') || document.createElement('coral-card-info'),
        overlay: _this.querySelector('coral-card-overlay') || document.createElement('coral-card-overlay')
      };
      template$m.call(_this._elements); // Events

      _this._delegateEvents({
        'capture:load coral-card-asset img': '_onLoad'
      });

      return _this;
    }
    /**
     The Asset of the card.
      @type {CardAsset}
     @contentzone
     */


    _createClass(_class, [{
      key: "_onLoad",

      /** @ignore */
      value: function _onLoad(event) {
        // @todo fix me for multiple images
        // sets the image as loaded
        this._loaded = true; // removes the height style since the asset has been completely loaded

        this._elements.asset.style.height = ''; // enables the transition

        event.target.classList.remove('is-loading');
      }
    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        var _this2 = this;

        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$D); // Default reflected attributes

        if (!this._variant) {
          this.variant = variant$c.DEFAULT;
        }

        var content = this._elements.content;
        var asset = this._elements.asset; // Prepares images to be loaded nicely

        var images = asset.querySelectorAll('img');
        var imagesCount = images.length;

        for (var i = 0; i < imagesCount; i++) {
          var image = images[i];

          if (!image.complete) {
            image.classList.add('is-loading');
          }
        }

        for (var contentZone in this._contentZones) {
          var element = this._elements[this._contentZones[contentZone]]; // Remove it so we can process children

          if (element.parentNode) {
            element.parentNode.removeChild(element);
          }
        } // Moves everything into the main content zone


        while (this.firstChild) {
          var child = this.firstChild; // Removes the empty spaces

          if (child.nodeType === Node.TEXT_NODE && child.textContent.trim() !== '' || child.nodeType === Node.ELEMENT_NODE && child.getAttribute('handle') !== 'wrapper') {
            // Add non-template elements to the content
            content.appendChild(child);
          } // Remove anything else element
          else {
              this.removeChild(child);
            }
        } // Assign the content zones so the insert functions will be called


        this.overlay = this._elements.overlay;
        this.content = content;
        this.info = this._elements.info;
        this.appendChild(this._elements.wrapper); // The 'asset' setter knows to insert the element just before the wrapper node.

        this.asset = asset; // In case a lot of alerts are added, they will not overflow the card
        // Also check whether any alerts are available

        requestAnimationFrame(function () {
          _this2.classList.toggle("".concat(CLASSNAME$D, "--overflow"), _this2.info.childNodes.length && _this2.info.scrollHeight > _this2.clientHeight);
        });
      }
    }, {
      key: "asset",
      get: function get() {
        return this._getContentZone(this._elements.asset);
      },
      set: function set(value) {
        this._setContentZone('asset', value, {
          handle: 'asset',
          tagName: 'coral-card-asset',
          insert: function insert(asset) {
            this.insertBefore(asset, this.info || this._elements.wrapper || null);
          }
        });
      }
      /**
       Hints the height of the asset that is going to be loaded. This prepares the size so that when the image is
       loaded no reflow is triggered. Both <code>assetHeight</code> and <code>assetWidth</code> need to be specified
       for this feature to take effect.
        @type {String}
       @default ""
       @htmlattribute assetheight
       */

    }, {
      key: "assetHeight",
      get: function get() {
        return this._assetHeight || '';
      },
      set: function set(value) {
        var _this3 = this;

        this._assetHeight = transform.number(value); // Avoid a forced reflow by executing following in the next frame

        window.requestAnimationFrame(function () {
          // both hint dimensions need to be set in order to use this feature
          if (!_this3._loaded && _this3._elements.asset && _this3.assetWidth && _this3._assetHeight) {
            // gets the width without the border of the card
            var clientRect = _this3.getBoundingClientRect();

            var width = clientRect.right - clientRect.left; // calculates the image ratio used to resize the height

            var ratio = width / _this3.assetWidth; // the image is considered "low resolution"
            // @todo: check this after removal of lowResolution

            if (ratio > 1) {
              // 32 = $card-asset-lowResolution-padding * 2
              _this3._elements.asset.style.height = "".concat(_this3._assetHeight + 32, "px");
            } // for non-low resolution images, condensed and inverted cards do not require the height to be set
            else if (_this3.variant !== variant$c.CONDENSED && _this3.variant !== variant$c.INVERTED) {
                _this3._elements.asset.style.height = "".concat(ratio * _this3._assetHeight, "px");
              }
          }
        });
      }
      /**
       Hints the width of the asset that is going to be loaded. This prepares the size so that when the image is
       loaded no reflow is triggered. Both <code>assetHeight</code> and <code>assetWidth</code> need to be specified
       for this feature to take effect.
        @type {String}
       @default ""
       @htmlattribute assetwidth
       */

    }, {
      key: "assetWidth",
      get: function get() {
        return this._assetWidth || '';
      },
      set: function set(value) {
        this._assetWidth = transform.number(value);
      }
      /**
       @type {String}
       @default ""
       @htmlattribute colorhint
       */

    }, {
      key: "colorHint",
      get: function get() {
        return this._colorHint || '';
      },
      set: function set(value) {
        if (COLOR_HINT_REG_EXP.test(value)) {
          this._colorHint = value; // if the image is already loaded we do not add the color hint to the asset

          if (!this._loaded) {
            this._elements.asset.style['background-color'] = this._colorHint;
          }
        }
      }
      /**
       The Content of the card.
        @type {CardContent}
       @contentzone
       */

    }, {
      key: "content",
      get: function get() {
        return this._getContentZone(this._elements.content);
      },
      set: function set(value) {
        this._setContentZone('content', value, {
          handle: 'content',
          tagName: 'coral-card-content',
          insert: function insert(content) {
            // Ensure title comes first
            var title = content.querySelector('coral-card-title');

            if (title) {
              content.insertBefore(title, content.firstChild);
            }

            this._elements.wrapper.insertBefore(content, this.overlay || null);
          }
        });
      }
      /**
       The information area of the card, which is placed over all the content. It is typically used for alerts.
        @type {CardInfo}
       @contentzone
       */

    }, {
      key: "info",
      get: function get() {
        return this._getContentZone(this._elements.info);
      },
      set: function set(value) {
        this._setContentZone('info', value, {
          handle: 'info',
          tagName: 'coral-card-info',
          insert: function insert(info) {
            this.appendChild(info);
          }
        });
      }
      /**
       Fixes the width of the card. By default cards will take the width of their containers allowing them to interact
       nicely with grids. Whenever they are used standalone fixing the width might be desired.
        @type {Boolean}
       @default false
       @htmlattribute fixedwidth
       @htmlattributereflected
       */

    }, {
      key: "fixedWidth",
      get: function get() {
        return this._fixedWidth || false;
      },
      set: function set(value) {
        this._fixedWidth = transform.booleanAttr(value);

        this._reflectAttribute('fixedwidth', this._fixedWidth);

        this.classList.toggle("".concat(CLASSNAME$D, "--fixedWidth"), this._fixedWidth);
      }
      /**
       The Overlay of the card.
        @type {CardOverlay}
       @contentzone
       */

    }, {
      key: "overlay",
      get: function get() {
        return this._getContentZone(this._elements.overlay);
      },
      set: function set(value) {
        this._setContentZone('overlay', value, {
          handle: 'overlay',
          tagName: 'coral-card-overlay',
          insert: function insert(overlay) {
            this._elements.wrapper.appendChild(overlay);
          }
        });
      }
      /**
       Whether the card is stacked or not. This is used to represent several assets grouped together.
        @type {Boolean}
       @default false
       @htmlattribute stacked
       @htmlattributereflected
       */

    }, {
      key: "stacked",
      get: function get() {
        return this._stacked || false;
      },
      set: function set(value) {
        this._stacked = transform.booleanAttr(value);

        this._reflectAttribute('stacked', this._stacked);

        this.classList.toggle("".concat(CLASSNAME$D, "--stacked"), this._stacked);
      }
      /**
       The card's variant. It determines which sections of the Card and in which position they are shown.
       See {@link CardVariantEnum}.
        @type {String}
       @default CardVariantEnum.DEFAULT
       @htmlattribute variant
       */

    }, {
      key: "variant",
      get: function get() {
        return this._variant || variant$c.DEFAULT;
      },
      set: function set(value) {
        var _this$classList;

        value = transform.string(value).toLowerCase();
        this._variant = validate.enumeration(variant$c)(value) && value || variant$c.DEFAULT;

        this._reflectAttribute('variant', this._variant);

        (_this$classList = this.classList).remove.apply(_this$classList, ALL_VARIANT_CLASSES$8);

        if (this._variant !== variant$c.DEFAULT) {
          this.classList.add("".concat(CLASSNAME$D, "--").concat(this._variant));
        }

        this.assetHeight = this.assetHeight;
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-card-asset': 'asset',
          'coral-card-content': 'content',
          'coral-card-info': 'info',
          'coral-card-overlay': 'overlay'
        };
      }
      /**
       Returns {@link Card} variants.
        @return {CardVariantEnum}
       */

    }], [{
      key: "variant",
      get: function get() {
        return variant$c;
      }
    }, {
      key: "_attributePropertyMap",
      get: function get() {
        return commons.extend(_get(_getPrototypeOf(_class), "_attributePropertyMap", this), {
          assetwidth: 'assetWidth',
          assetheight: 'assetHeight',
          colorhint: 'colorHint',
          fixedwidth: 'fixedWidth'
        });
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['assetwidth', 'assetheight', 'colorhint', 'fixedwidth', 'variant', 'stacked']);
      }
    }]);

    return _class;
  }(BaseComponent(HTMLElement)));

  var template$n = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["icon"] = document.createElement("coral-icon");
    el0.setAttribute("handle", "icon");
    el0.setAttribute("size", "XS");
    el0.className += " _coral-Card-property-icon";
    el0.setAttribute("autoarialabel", "on");
    frag.appendChild(el0);
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    return frag;
  };

  var CLASSNAME$E = '_coral-Card-property';
  /**
   @class Coral.Card.Property
   @classdesc A Card property component
   @htmltag coral-card-property
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var CardProperty = Decorator( /*#__PURE__*/function (_BaseComponent) {
    _inherits(_class, _BaseComponent);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this); // Prepare templates

      _this._elements = {
        content: _this.querySelector('coral-card-property-content') || document.createElement('coral-card-property-content')
      };
      template$n.call(_this._elements);
      return _this;
    }
    /**
     The property's content zone
      @type {CardPropertyContent}
     @contentzone
     */


    _createClass(_class, [{
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$E, 'coral-Body--small'); // Create a fragment

        var frag = document.createDocumentFragment(); // Render the main template

        if (this.icon) {
          frag.appendChild(this._elements.icon);
        }

        var content = this._elements.content; // Remove it so we can process children

        if (content.parentNode) {
          content.parentNode.removeChild(content);
        }

        while (this.firstChild) {
          var child = this.firstChild;

          if (child.nodeType === Node.TEXT_NODE || child.nodeType === Node.ELEMENT_NODE && child.getAttribute('handle') !== 'icon') {
            // Add non-template elements to the label
            content.appendChild(child);
          } else {
            this.removeChild(child);
          }
        } // Add the frag to the component


        this.appendChild(frag); // Assign the content zones, moving them into place in the process

        this.content = content;
      }
    }, {
      key: "content",
      get: function get() {
        return this._getContentZone(this._elements.content);
      },
      set: function set(value) {
        this._setContentZone('content', value, {
          handle: 'content',
          tagName: 'coral-card-property-content',
          insert: function insert(content) {
            this.appendChild(content);
          }
        });
      }
      /**
       Specifies the icon name used inside the property. See {@link Icon} for valid icon names.
        @type {String}
       @default ""
       @htmlattribute icon
       */

    }, {
      key: "icon",
      get: function get() {
        return this._elements.icon.icon;
      },
      set: function set(value) {
        this._elements.icon.icon = value; // removes the icon element from the DOM since there is no valid icon. this causes the content to have the
        // correct styling

        if (this.icon === '') {
          this._elements.icon.remove();
        } else if (!this._elements.icon.parentNode) {
          this.insertBefore(this._elements.icon, this.firstChild);
        }
      }
      /**
       Specifies the alternative text to be used for the icon.
        @type {String}
       @default ""
       @htmlattribute iconalt
       */

    }, {
      key: "iconAlt",
      get: function get() {
        return this._elements.icon ? this._elements.icon.getAttribute('alt') : undefined;
      },
      set: function set(value) {
        this._elements.icon && this._elements.icon.setAttribute('alt', value);
      }
      /**
       Specifies the title attribute to be used for the icon.
        @type {String}
       @default ""
       @htmlattribute icontitle
       */

    }, {
      key: "iconTitle",
      get: function get() {
        return this._elements.icon ? this._elements.icon.getAttribute('title') : undefined;
      },
      set: function set(value) {
        this._elements.icon && this._elements.icon.setAttribute('title', value);
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-card-property-content': 'content'
        };
      }
    }], [{
      key: "_attributePropertyMap",
      get: function get() {
        return commons.extend(_get(_getPrototypeOf(_class), "_attributePropertyMap", this), {
          iconalt: 'iconAlt',
          icontitle: 'iconTitle'
        });
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['icon', 'iconalt', 'icontitle']);
      }
    }]);

    return _class;
  }(BaseComponent(HTMLElement)));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Card.Title
   @classdesc A Card title component
   @htmltag coral-card-title
   @return {HTMLElement}
   */
  var CardTitle = (function () {
    return document.createElement('coral-card-title');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Card.Subtitle
   @classdesc A Card sub title component
   @htmltag coral-card-subtitle
   @return {HTMLElement}
   */
  var CardSubtitle = (function () {
    return document.createElement('coral-card-subtitle');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Card.Context
   @classdesc A Card context component
   @htmltag coral-card-context
   @return {HTMLElement}
   */
  var CardContext = (function () {
    return document.createElement('coral-card-context');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Card.Description
   @classdesc A Card description component
   @htmltag coral-card-description
   @return {HTMLElement}
   */
  var CardDescription = (function () {
    return document.createElement('coral-card-description');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Card.Asset
   @classdesc The Card Asset
   @htmltag coral-card-asset
   @return {HTMLElement}
   */
  var CardAsset = (function () {
    return document.createElement('coral-card-asset');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Card.Overlay
   @classdesc The Card Overlay
   @htmltag coral-card-overlay
   @return {HTMLElement}
   */
  var CardOverlay = (function () {
    return document.createElement('coral-card-overlay');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Card.Info
   @classdesc The Card Info
   @htmltag coral-card-info
   @return {HTMLElement}
   */
  var CardInfo = (function () {
    return document.createElement('coral-card-info');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Card.Content
   @classdesc The Card Content
   @htmltag coral-card-content
   @return {HTMLElement}
   */
  var CardContent = (function () {
    return document.createElement('coral-card-content');
  });

  /**
   @class Coral.Card.PropertyList
   @classdesc The Card PropertyList component
   @htmltag coral-card-propertylist
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var CardPropertyList = Decorator( /*#__PURE__*/function (_BaseComponent) {
    _inherits(_class, _BaseComponent);

    var _super = _createSuper(_class);

    function _class() {
      _classCallCheck(this, _class);

      return _super.apply(this, arguments);
    }

    _createClass(_class, [{
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add('u-coral-clearFix'); // Empty it if no items

        if (this.innerHTML.trim() === '') {
          this.textContent = '';
        }
      }
    }]);

    return _class;
  }(BaseComponent(HTMLElement)));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Card.Property.Content
   @classdesc A Card Property Content component
   @htmltag coral-card-property-content
   @return {HTMLElement}
   */
  var CardPropertyContent = (function () {
    return document.createElement('coral-card-property-content');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons._define('coral-card-propertylist', CardPropertyList);

  commons._define('coral-card-property', CardProperty);

  commons._define('coral-card', Card);

  Card.Property = CardProperty;
  Card.Property.Content = CardPropertyContent;
  Card.Title = CardTitle;
  Card.Subtitle = CardSubtitle;
  Card.Context = CardContext;
  Card.Description = CardDescription;
  Card.Asset = CardAsset;
  Card.Overlay = CardOverlay;
  Card.Info = CardInfo;
  Card.Content = CardContent;
  Card.PropertyList = CardPropertyList;

  var CLASSNAME$F = '_coral-CharacterCount';
  /**
   Enumeration for {@link CharacterCount} targets.

   @typedef {Object} CharacterCountTargetEnum

   @property {String} PREVIOUS
   Relates the CharacterCount to the previous sibling.
   @property {String} NEXT
   Relates the CharacterCount to the next sibling.
   */

  var target$1 = {
    PREVIOUS: '_prev',
    NEXT: '_next'
  };
  /**
   @class Coral.CharacterCount
   @classdesc A CharacterCount component that indicates the remaining characters in a Textfield or Textarea.
   @htmltag coral-charactercount
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var CharacterCount = Decorator( /*#__PURE__*/function (_BaseComponent) {
    _inherits(_class, _BaseComponent);

    var _super = _createSuper(_class);

    function _class() {
      _classCallCheck(this, _class);

      return _super.apply(this, arguments);
    }

    _createClass(_class, [{
      key: "_getCharCount",

      /** @ignore */
      value: function _getCharCount() {
        var elementLength = 0;

        if (this._targetEl && this._targetEl.value) {
          elementLength = this._targetEl.value.length;
        }

        return this._maxLength ? this._maxLength - elementLength : elementLength;
      }
      /** @ignore */

    }, {
      key: "_refreshCharCount",
      value: function _refreshCharCount() {
        var currentCount = this._getCharCount();
        /** @ignore */


        this.innerHTML = currentCount;
        var isMaxExceeded = currentCount < 0;

        if (this._targetEl) {
          this._targetEl.classList.toggle('is-invalid', isMaxExceeded);

          this.classList.toggle('is-invalid', isMaxExceeded);
        }
      }
      /**
       Returns {@link CharacterCount} target options.
        @return {CharacterCountTargetEnum}
       */

    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$F, 'coral-Body--S'); // Set defaults

        this.target = this.target; // Refresh once connected

        this._refreshCharCount();
      }
    }, {
      key: "target",

      /**
       The target Textfield or Textarea for this component. It accepts values from {@link CharacterCountTargetEnum},
       as well as any DOM element or CSS selector.
        @type {HTMLElement|String}
       @default CharacterCountTargetEnum.PREVIOUS
       @htmlattribute target
       */
      get: function get() {
        return this._target || target$1.PREVIOUS;
      },
      set: function set(value) {
        if (typeof value === 'string' || value instanceof Node) {
          this._target = value; // Remove previous event listener

          if (this._targetEl) {
            this._targetEl.removeEventListener('input', this._refreshCharCount.bind(this));
          } // Get the target DOM element


          if (value === target$1.NEXT) {
            this._targetEl = this.nextElementSibling;
          } else if (value === target$1.PREVIOUS) {
            this._targetEl = this.previousElementSibling;
          } else if (typeof value === 'string') {
            this._targetEl = document.querySelector(value);
          } else {
            this._targetEl = value;
          }

          if (this._targetEl) {
            this._targetEl.addEventListener('input', this._refreshCharCount.bind(this)); // Try to get maxlength from target element


            if (this._targetEl.getAttribute('maxlength')) {
              this.maxLength = this._targetEl.getAttribute('maxlength');
            }
          }
        }
      }
      /**
       Maximum character length for the TextField/TextArea (will be read from target field markup if able).
        @type {Number}
       @default null
       @htmlattribute maxlength
       @htmlattributereflected
       */

    }, {
      key: "maxLength",
      get: function get() {
        return this._maxLength || null;
      },
      set: function set(value) {
        this._maxLength = transform.number(value);

        this._reflectAttribute('maxlength', this._maxLength);

        this._refreshCharCount();
      }
    }], [{
      key: "target",
      get: function get() {
        return target$1;
      }
    }, {
      key: "_attributePropertyMap",
      get: function get() {
        return commons.extend(_get(_getPrototypeOf(_class), "_attributePropertyMap", this), {
          maxlength: 'maxLength'
        });
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['target', 'maxlength']);
      }
    }]);

    return _class;
  }(BaseComponent(HTMLElement)));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons._define('coral-charactercount', CharacterCount);

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var translations$c = {
    "en-US": {
      "am": "am",
      "pm": "pm",
      "Hours": "Hours",
      "Minutes": "Minutes",
      "AM/PM": "AM/PM",
      "invalidTime": "Please enter a valid time"
    },
    "de-DE": {
      "am": "vormittags",
      "pm": "nachmittags",
      "Hours": "Stunden",
      "Minutes": "Minuten",
      "AM/PM": "AM/PM"
    },
    "fr-FR": {
      "am": "matin",
      "pm": "après-midi",
      "Hours": "Heures",
      "Minutes": "Minutes",
      "AM/PM": "AM/PM"
    },
    "ja-JP": {
      "am": "午前",
      "pm": "午後",
      "Hours": "時間",
      "Minutes": "分",
      "AM/PM": "午前 / 午後"
    },
    "es-ES": {
      "am": "a. m.",
      "pm": "p. m.",
      "Hours": "Horas",
      "Minutes": "Minutos",
      "AM/PM": "a. m./p. m."
    },
    "ko-KR": {
      "am": "오전",
      "pm": "오후",
      "Hours": "시간",
      "Minutes": "분",
      "AM/PM": "오전/오후"
    },
    "zh-CN": {
      "am": "上午",
      "pm": "下午",
      "Hours": "小时",
      "Minutes": "分钟",
      "AM/PM": "上午/下午"
    },
    "zh-TW": {
      "am": "上午",
      "pm": "下午",
      "Hours": "小時",
      "Minutes": "分鐘",
      "AM/PM": "上午/下午"
    },
    "pt-BR": {
      "am": "am",
      "pm": "pm",
      "Hours": "Horas",
      "Minutes": "Minutos",
      "AM/PM": "AM/PM"
    },
    "it-IT": {
      "am": "am",
      "pm": "pm",
      "Hours": "Ore",
      "Minutes": "Minuti",
      "AM/PM": "AM/PM"
    },
    "nl-NL": {
      "am": "am",
      "pm": "pm",
      "Hours": "Uren",
      "Minutes": "Minuten",
      "AM/PM": "AM/PM"
    },
    "da-DK": {
      "am": "am",
      "pm": "pm",
      "Hours": "Timer",
      "Minutes": "Minutter",
      "AM/PM": "AM/PM"
    },
    "fi-FI": {
      "am": "ap.",
      "pm": "ip.",
      "Hours": "Tunnit",
      "Minutes": "Minuutit",
      "AM/PM": "ap./ip."
    },
    "nb-NO": {
      "am": "am",
      "pm": "pm",
      "Hours": "Timer",
      "Minutes": "Minutter",
      "AM/PM": "AM/PM"
    },
    "sv-SE": {
      "am": "am",
      "pm": "pm",
      "Hours": "Timmar",
      "Minutes": "Minuter",
      "AM/PM": "AM/PM"
    },
    "cs-CZ": {
      "am": "am",
      "pm": "pm",
      "Hours": "hodin",
      "Minutes": "minut",
      "AM/PM": "AM/PM"
    },
    "pl-PL": {
      "am": "przed południem",
      "pm": "po południu",
      "Hours": "Godz.",
      "Minutes": "Min",
      "AM/PM": "Przed południem / Po południu"
    },
    "ru-RU": {
      "am": "дп",
      "pm": "пп",
      "Hours": "ч.",
      "Minutes": "мин.",
      "AM/PM": "ДП/ПП"
    },
    "tr-TR": {
      "am": "öö",
      "pm": "ös",
      "Hours": "Saat",
      "Minutes": "Dakika",
      "AM/PM": "ÖÖ/ÖS"
    }
  };

  var template$o = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var data = data_0 = typeof data_0 === "undefined" ? {} : data_0;
    data = data_0;
    var labelHourId = data.commons.getUID();
    var labelMinuteId = data.commons.getUID();
    data_0 = data;
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    var el2 = this["input"] = document.createElement("input");
    el2.setAttribute("type", "hidden");
    el2.setAttribute("name", "");
    el2.setAttribute("handle", "input");
    frag.appendChild(el2);
    var el3 = document.createTextNode("\n");
    frag.appendChild(el3);
    var el4 = this["valueAsText"] = document.createElement("time");
    el4.setAttribute("handle", "valueAsText");
    el4.id = data_0["commons"]["getUID"]();
    el4.setAttribute("hidden", "");
    frag.appendChild(el4);
    var el5 = document.createTextNode("\n");
    frag.appendChild(el5);
    var el6 = document.createElement("label");
    el6.setAttribute("for", labelHourId);
    el6.className += " coral-Form-fieldlabel";
    el6.textContent = data_0["i18n"]["get"]('Hours');
    frag.appendChild(el6);
    var el7 = document.createTextNode("\n");
    frag.appendChild(el7);
    var el8 = this["hours"] = document.createElement("input", "coral-textfield");
    el8.setAttribute("is", "coral-textfield");
    el8.id = labelHourId;
    el8.setAttribute("type", "number");
    el8.setAttribute("min", "0");
    el8.setAttribute("max", "23");
    el8.className += " _coral-Clock-hour";
    el8.setAttribute("handle", "hours");
    frag.appendChild(el8);
    var el9 = document.createTextNode("\n");
    frag.appendChild(el9);
    var el10 = this["divider"] = document.createElement("span");
    el10.className += " _coral-Clock-divider";
    el10.setAttribute("handle", "divider");
    el10.textContent = ":";
    frag.appendChild(el10);
    var el11 = document.createTextNode("\n");
    frag.appendChild(el11);
    var el12 = document.createElement("label");
    el12.setAttribute("for", labelMinuteId);
    el12.className += " coral-Form-fieldlabel";
    el12.textContent = data_0["i18n"]["get"]('Minutes');
    frag.appendChild(el12);
    var el13 = document.createTextNode("\n");
    frag.appendChild(el13);
    var el14 = this["minutes"] = document.createElement("input", "coral-textfield");
    el14.setAttribute("is", "coral-textfield");
    el14.id = labelMinuteId;
    el14.setAttribute("type", "number");
    el14.setAttribute("min", "0");
    el14.setAttribute("max", "59");
    el14.className += " _coral-Clock-minute";
    el14.setAttribute("handle", "minutes");
    frag.appendChild(el14);
    var el15 = document.createTextNode("\n");
    frag.appendChild(el15);
    var el16 = this["period"] = document.createElement("coral-select");
    el16.setAttribute("handle", "period");
    el16.className += " _coral-Clock-period";
    el16.setAttribute("hidden", "");
    el16.setAttribute("aria-label", data_0["i18n"]["get"]('AM/PM'));
    var el17 = document.createTextNode("\n  ");
    el16.appendChild(el17);
    var el18 = document.createElement("coral-select-item");
    el18.setAttribute("value", "am");
    el16.appendChild(el18);
    var el19 = document.createTextNode("\n  ");
    el16.appendChild(el19);
    var el20 = document.createElement("coral-select-item");
    el20.setAttribute("value", "pm");
    el16.appendChild(el20);
    var el21 = document.createTextNode("\n");
    el16.appendChild(el21);
    frag.appendChild(el16);
    var el22 = document.createTextNode("\n");
    frag.appendChild(el22);
    var el23 = document.createElement("label");
    el23.className += " coral-Form-errorlabel";
    el23.setAttribute("hidden", "");
    el23.textContent = data_0["i18n"]["get"]('invalidTime');
    frag.appendChild(el23);
    return frag;
  };

  var DEFAULT_HOUR_FORMAT = 'HH';
  var DEFAULT_MINUTE_FORMAT = 'mm';
  var DEFAULT_TIME_FORMAT = "".concat(DEFAULT_HOUR_FORMAT, ":").concat(DEFAULT_MINUTE_FORMAT); // Used to extract the time format from a date format

  var AUTHORIZED_TOKENS = '(A|a|H{1,2}|h{1,2}|k{1,2}|m{1,2})';
  var TIME_REG_EXP = new RegExp("".concat(AUTHORIZED_TOKENS, ".*").concat(AUTHORIZED_TOKENS, "|").concat(AUTHORIZED_TOKENS));
  var HOUR_REG_EXP = new RegExp('h{1,2}|H{1,2}|k{1,2}');
  var MIN_REG_EXP = new RegExp('m{1,2}');
  /**
   Enumeration for {@link Clock} variants.

   @typedef {Object} ClockVariantEnum

   @property {String} DEFAULT
   A default, gray Clock.
   @property {String} QUIET
   A Clock with no border or background.
   */

  var variant$d = {
    DEFAULT: 'default',
    QUIET: 'quiet'
  };
  var CLASSNAME$G = '_coral-Clock'; // builds an array containing all possible variant classnames. this will be used to remove classnames when the variant
  // changes

  var ALL_VARIANT_CLASSES$9 = [];

  for (var variantValue$7 in variant$d) {
    ALL_VARIANT_CLASSES$9.push("".concat(CLASSNAME$G, "--").concat(variant$d[variantValue$7]));
  }
  /**
   @class Coral.Clock
   @classdesc A Clock component that can be used as a time selection form field. Leverages {@link momentJS} if loaded
   on the page.
   @htmltag coral-clock
   @extends {HTMLElement}
   @extends {BaseComponent}
   @extends {BaseFormField}
   */


  var Clock = Decorator( /*#__PURE__*/function (_BaseFormField) {
    _inherits(_class, _BaseFormField);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this); // Default value

      _this._value = ''; // Events

      _this._delegateEvents(commons.extend(_this._events, {
        'change [handle="period"]': '_onPeriodChange'
      })); // Prepare templates


      _this._elements = {};
      _this._template = template$o.call(_this._elements, {
        commons: commons,
        i18n: i18n
      }); // Pre-define labellable element

      _this._labellableElement = _assertThisInitialized(_this); // Add aria-errormessage attribute to coral-clock element

      _this.errorID = (_this.id || commons.getUID()) + "-coral-clock-error-label"; // Prevent typing in specific characters which can be added to number inputs

      var forbiddenChars = ["-", "+", "e", ",", "."];

      _this.addEventListener("keydown", function (e) {
        if (forbiddenChars.includes(e.key)) {
          e.preventDefault();
        }
      });

      return _this;
    }
    /**
     The format used to display the selected time to the user. If the user manually types a time, this format
     will be used to parse the value. 'HH:mm' is supported by default. Include momentjs to support additional format
     string options see http://momentjs.com/docs/#/displaying/.
      @type {String}
     @default "HH:mm"
     @htmlattribute displayformat
     @htmlattributereflected
     */


    _createClass(_class, [{
      key: "_extractTimeFormat",

      /**
       Ignore the date part and use the time part only
        @private
       */
      value: function _extractTimeFormat(format, regExp, defaultFormat) {
        var match = regExp.exec(format);
        return match && match.length && match[0] !== '' ? match[0] : defaultFormat;
      }
      /**
       Sync time display based on the format
        @private
       */

    }, {
      key: "_syncDisplay",
      value: function _syncDisplay() {
        var hourFormat = this._extractTimeFormat(this.displayFormat, HOUR_REG_EXP, DEFAULT_HOUR_FORMAT);

        var minuteFormat = this._extractTimeFormat(this.displayFormat, MIN_REG_EXP, DEFAULT_MINUTE_FORMAT);

        this._elements.hours.placeholder = hourFormat;
        this._elements.minutes.placeholder = minuteFormat;
        this._elements.hours.value = this._getValueAsString(this._value, hourFormat);
        this._elements.minutes.value = this._getValueAsString(this._value, minuteFormat);

        this._syncPeriod();

        this._syncValueAsText();
      }
      /**
       Sync period selector based on the format
        @private
       */

    }, {
      key: "_syncPeriod",
      value: function _syncPeriod() {
        var period = this._elements.period;
        var time = this._value;
        var am = i18n.get('am');
        var pm = i18n.get('pm');
        var items = period.items.getAll();

        if (time && time.isValid()) {
          if (time.hours() < 12) {
            period.value = 'am';
          } else {
            period.value = 'pm';
          }
        } // Check for am/pm


        if (this.displayFormat.indexOf('a') !== -1) {
          items[0].textContent = am;
          items[1].textContent = pm;

          this._togglePeriod(true);
        } else if (this.displayFormat.indexOf('A') !== -1) {
          items[0].textContent = am.toUpperCase();
          items[1].textContent = pm.toUpperCase();

          this._togglePeriod(true);
        } else {
          this._togglePeriod(false);
        }
      }
      /** @private */

    }, {
      key: "_togglePeriod",
      value: function _togglePeriod(show) {
        this.classList.toggle("".concat(CLASSNAME$G, "--extended"), show);
        this._elements.period.hidden = !show;
      }
      /** @private */

    }, {
      key: "_onPeriodChange",
      value: function _onPeriodChange(event) {
        // stops the event from leaving the component
        event.stopImmediatePropagation();
        var time = this._value;
        var period = this._elements.period; // we check if a change event needs to be triggered since it was produced via user interaction

        if (time && time.isValid()) {
          if (this.displayFormat.indexOf('h') !== -1) {
            if (period.value === 'am') {
              time.subtract(12, 'h');
            } else {
              time.add(12, 'h');
            }
          }

          this.value = time.format(this.valueFormat);
          this.trigger('change');
        }
      }
    }, {
      key: "_syncValueAsText",
      value: function _syncValueAsText() {
        this._elements.valueAsText.textContent = this._getValueAsString(this._value, this.displayFormat);

        if (!this.getAttribute('aria-labelledby')) {
          this.labelledBy = this.labelledBy;
        }
      }
      /**
       Kills the internal _onInputChange from BaseFormField because it does not check the target.
        @private
       */

    }, {
      key: "_onInputChange",
      value: function _onInputChange(event) {
        // stops the event from leaving the component
        event.stopImmediatePropagation();
        var newTime = new DateTime.Moment();
        var oldTime = this._value;
        var hours = parseInt(this._elements.hours.value, 10);
        var minutes = parseInt(this._elements.minutes.value, 10);

        if (window.isNaN(hours) || window.isNaN(minutes)) {
          newTime = '';
        } else {
          if (!this._elements.period.hidden && this.displayFormat.indexOf('h') !== -1 && this._elements.period.value === 'pm') {
            hours += 12;
          }

          newTime.hours(hours);
          newTime.minutes(minutes);
        } // we check if a change event needs to be triggered since it was produced via user interaction


        if (newTime && newTime.isValid()) {
          // @polyfill ie
          this.invalid = false;

          if (!newTime.isSame(oldTime, 'hour') || !newTime.isSame(oldTime, 'minute')) {
            this.value = newTime.format(this.valueFormat);
            this.trigger('change');
          }
        } else {
          // @polyfill ie
          this.invalid = true; // does not sync the inputs so allow the user to continue typing the date

          this._value = '';

          if (newTime !== oldTime) {
            this.trigger('change');
          }
        }
      }
      /**
       Helper class that converts the internal moment value into a String using the provided date format. If the value is
       invalid, empty string will be returned.
        @param {?Moment} value
       The value representing the date. It has to be a moment object or <code>null</code>
       @param {String} format
       The Date format to be used.
        @returns {String} a String representing the value in the given format.
        @ignore
       */

    }, {
      key: "_getValueAsString",
      value: function _getValueAsString(value, format) {
        return value && value.isValid() ? value.format(format) : '';
      }
    }, {
      key: "focus",
      value: function focus() {
        // Sets focus to appropriate descendant
        if (!this.contains(document.activeElement)) {
          this._elements.hours.focus();
        }
      }
      /**
       Returns {@link Clock} variants.
        @return {ClockVariantEnum}
       */

    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$G); // a11y

        this.setAttribute('role', 'group'); // Default reflected attributes

        if (!this._variant) {
          this.variant = variant$d.DEFAULT;
        }

        if (!this._valueFormat) {
          this.valueFormat = DEFAULT_TIME_FORMAT;
        }

        if (!this._displayFormat) {
          this.displayFormat = DEFAULT_TIME_FORMAT;
        } // clean up to be able to clone it


        while (this.firstChild) {
          this.removeChild(this.firstChild);
        } // Render template


        this.appendChild(this._template);

        this._syncDisplay();
      }
    }, {
      key: "displayFormat",
      get: function get() {
        return this._displayFormat || DEFAULT_TIME_FORMAT;
      },
      set: function set(value) {
        this._displayFormat = this._extractTimeFormat(transform.string(value).trim(), TIME_REG_EXP, DEFAULT_TIME_FORMAT);

        this._reflectAttribute('displayformat', this._displayFormat);

        this._syncDisplay();
      }
      /**
       The format to use on expressing the time as a string on the <code>value</code> attribute. The value
       will be sent to the server using this format. If an empty string is provided, then the default value per type
       will be used. 'HH:mm' is supported by default. Include momentjs to support additional format string options
       see http://momentjs.com/docs/#/displaying/.
        @type {String}
       @default "HH:mm"
       @htmlattribute valueformat
       @htmlattributereflected
       */

    }, {
      key: "valueFormat",
      get: function get() {
        return this._valueFormat || DEFAULT_TIME_FORMAT;
      },
      set: function set(value) {
        var _this2 = this;

        var setValueFormat = function setValueFormat(newValue) {
          _this2._valueFormat = _this2._extractTimeFormat(transform.string(newValue).trim(), TIME_REG_EXP, DEFAULT_TIME_FORMAT);

          _this2._reflectAttribute('valueformat', _this2._valueFormat);
        }; // Once the valueFormat is set, we make sure the value is also correct


        if (!this._valueFormat && this._originalValue) {
          setValueFormat(value);
          this.value = this._originalValue;
        } else {
          setValueFormat(value);
          this._elements.input.value = this.value;
        }
      }
      /**
       The current value as a Date. If the value is "" or an invalid date, <code>null</code> will be returned.
        @type {Date}
       @default null
       */

    }, {
      key: "valueAsDate",
      get: function get() {
        return this._value ? new Date(this._value.toDate().getTime()) : null;
      },
      set: function set(value) {
        this.value = value instanceof Date ? new DateTime.Moment(value, null, true).format(this.valueFormat) : '';
      }
      /**
       The clock's variant. See {@link ClockVariantEnum}.
        @type {String}
       @default ClockVariantEnum.DEFAULT
       @htmlattribute variant
       @htmlattributereflected
       */

    }, {
      key: "variant",
      get: function get() {
        return this._variant || variant$d.DEFAULT;
      },
      set: function set(value) {
        var _this$classList;

        value = transform.string(value).toLowerCase();
        this._variant = validate.enumeration(variant$d)(value) && value || variant$d.DEFAULT;

        this._reflectAttribute('variant', this._variant); // passes down the variant to the underlying components


        this._elements.hours.variant = this._variant;
        this._elements.minutes.variant = this._variant;
        this._elements.period.variant = this._variant; // removes every existing variant

        (_this$classList = this.classList).remove.apply(_this$classList, ALL_VARIANT_CLASSES$9);

        if (this._variant !== variant$d.DEFAULT) {
          this.classList.add("".concat(CLASSNAME$G, "--").concat(this._variant));
        }
      }
      /**
       Name used to submit the data in a form.
       @type {String}
       @default ""
       @htmlattribute name
       @htmlattributereflected
       */

    }, {
      key: "name",
      get: function get() {
        return this._elements.input.name;
      },
      set: function set(value) {
        this._reflectAttribute('name', value);

        this._elements.input.name = value;
      }
      /**
       Whether this field is disabled or not.
       @type {Boolean}
       @default false
       @htmlattribute disabled
       @htmlattributereflected
       */

    }, {
      key: "disabled",
      get: function get() {
        return this._disabled || false;
      },
      set: function set(value) {
        this._disabled = transform.booleanAttr(value);

        this._reflectAttribute('disabled', this._disabled);

        this[this._disabled ? 'setAttribute' : 'removeAttribute']('aria-disabled', this._disabled);
        this.classList.toggle('is-disabled', this._disabled);
        this._elements.hours.disabled = this._disabled;
        this._elements.minutes.disabled = this._disabled; // stops the form submission

        this._elements.input.disabled = this._disabled;
      }
      /**
       Inherited from {@link BaseFormField#invalid}.
       */

    }, {
      key: "invalid",
      get: function get() {
        return _get(_getPrototypeOf(_class.prototype), "invalid", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(_class.prototype), "invalid", value, this, true);

        this._elements.hours.invalid = this._invalid;
        this._elements.minutes.invalid = this._invalid;

        this._elements.hours.setAttribute("aria-errormessage", this.errorID);

        this._elements.minutes.setAttribute("aria-errormessage", this.errorID);

        var ERROR_LABEL_ELEMENT_CLASS = "._coral-Clock .coral-Form-errorlabel";
        var errorLabel = this.querySelector(ERROR_LABEL_ELEMENT_CLASS);

        if (this._elements.hours.invalid || this._elements.minutes.invalid) {
          errorLabel.setAttribute("id", this.errorID);
          errorLabel.setAttribute("aria-live", "assertive");
          errorLabel.hidden = false;
          errorLabel.style.display = "table-caption";
          errorLabel.style["caption-side"] = "bottom";
        } else {
          errorLabel.setAttribute("aria-live", "off");
          errorLabel.hidden = true;
        }
      }
      /**
       Whether this field is required or not.
       @type {Boolean}
       @default false
       @htmlattribute required
       @htmlattributereflected
       */

    }, {
      key: "required",
      get: function get() {
        return this._required || false;
      },
      set: function set(value) {
        this._required = transform.booleanAttr(value);

        this._reflectAttribute('required', this._required);

        this._elements.hours.required = this._required;
        this._elements.minutes.required = this._required;
        this._elements.input.required = this._required;
      }
      /**
       Whether this field is readOnly or not. Indicating that the user cannot modify the value of the control.
       @type {Boolean}
       @default false
       @htmlattribute readonly
       @htmlattributereflected
       */

    }, {
      key: "readOnly",
      get: function get() {
        return this._readOnly || false;
      },
      set: function set(value) {
        this._readOnly = transform.booleanAttr(value);

        this._reflectAttribute('readonly', this._readOnly);

        this._elements.hours.readOnly = this._readOnly;
        this._elements.minutes.readOnly = this._readOnly;
        this._elements.input.readOnly = this._readOnly;
      }
      /**
       This field's current value.
       @type {String}
       @default ""
       @htmlattribute value
       */

    }, {
      key: "value",
      get: function get() {
        return this._getValueAsString(this._value, this.valueFormat);
      },
      set: function set(value) {
        value = typeof value === 'string' ? value : ''; // This is used to change the value if valueformat is also set but afterwards

        this._originalValue = value; // we do strict conversion of the values

        var time = new DateTime.Moment(value, this.valueFormat, true);
        this._value = time.isValid() ? time : '';
        this._elements.input.value = this.value;

        this._syncValueAsText();

        this._syncDisplay();
      }
      /**
       Inherited from {@link BaseFormField#labelledBy}.
       */

    }, {
      key: "labelledBy",
      get: function get() {
        // Get current aria-labelledby attribute on the labellable element.
        var labelledBy = this.getAttribute('aria-labelledby'); // If a labelledBy attribute has been defined,

        if (labelledBy) {
          // and strip the valueAsText element id from the end of the aria-labelledby string.
          labelledBy = labelledBy.replace(this._elements.valueAsText.id, '').trim(); // If the resulting labelledBy string is empty, return null.

          if (!labelledBy.length) {
            labelledBy = null;
          }
        }

        return labelledBy;
      },
      set: function set(value) {
        _set(_getPrototypeOf(_class.prototype), "labelledBy", value, this, true); // The specified labelledBy property.


        var labelledBy = this.labelledBy; // An array of element ids to label control, the last being the valueAsText element id.

        var ids = [this._elements.valueAsText.id]; // If a labelledBy property exists,

        if (labelledBy) {
          // prepend the labelledBy value to the ids array
          ids.unshift(labelledBy); // Set aria-labelledby attribute on the labellable element joining ids array into space-delimited list of ids.

          this.setAttribute('aria-labelledby', ids.join(' '));
        } else {
          // labelledBy property is null, remove the aria-labelledby attribute.
          this.removeAttribute('aria-labelledby');
        }
      }
    }], [{
      key: "variant",
      get: function get() {
        return variant$d;
      }
    }, {
      key: "_attributePropertyMap",
      get: function get() {
        return commons.extend(_get(_getPrototypeOf(_class), "_attributePropertyMap", this), {
          displayformat: 'displayFormat',
          valueformat: 'valueFormat'
        });
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['displayformat', 'valueformat', 'variant']);
      }
    }]);

    return _class;
  }(BaseFormField(BaseComponent(HTMLElement))));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons.extend(strings, {
    'coral-component-clock': translations$c
  }); // Expose component on the Coral namespace

  commons._define('coral-clock', Clock);

  var template$p = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = document.createElement("div");
    el0.className += " _coral-CoachMarkIndicator-ring";
    frag.appendChild(el0);
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    var el2 = document.createElement("div");
    el2.className += " _coral-CoachMarkIndicator-ring";
    frag.appendChild(el2);
    var el3 = document.createTextNode("\n");
    frag.appendChild(el3);
    var el4 = document.createElement("div");
    el4.className += " _coral-CoachMarkIndicator-ring";
    frag.appendChild(el4);
    var el5 = document.createTextNode("\n");
    frag.appendChild(el5);
    return frag;
  };

  /**
   Enumeration for {@link CoachMark} sizes.

   @typedef {Object} CoachMarkSizeEnum

   @property {String} SMALL
   A small sized coach mark.
   @property {String} MEDIUM
   A default sized coach mark.
   */

  var size$5 = {
    SMALL: 'S',
    MEDIUM: 'M'
  };
  /**
   Enumeration for {@link CoachMark} variants.

   @typedef {Object} CoachMarkVariantEnum

   @property {String} DEFAULT
   The default styled coach mark.
   @property {String} LIGHT
   A styled coach mark for dark backgrounds.
   @property {String} DARK
   A styled coach mark for light backgrounds.
   */

  var variant$e = {
    DEFAULT: 'default',
    LIGHT: 'light',
    DARK: 'dark'
  };
  var CLASSNAME$H = '_coral-CoachMarkIndicator';
  /**
   @class Coral.CoachMark
   @classdesc A coach mark component to highlight UI elements on the page.
   @htmltag coral-coachmark
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var CoachMark = Decorator( /*#__PURE__*/function (_BaseComponent) {
    _inherits(_class, _BaseComponent);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this); // Templates

      _this._elements = {};
      _this._template = template$p.call(_this._elements);
      return _this;
    }
    /**
     The element the coach mark should position relative to. It accepts values from {@link OverlayTargetEnum}, as
     well as a DOM element or a CSS selector. If a CSS selector is provided, the first matching element will be used.
      @type {?HTMLElement|String}
     @default null
     */


    _createClass(_class, [{
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$H); // Default reflected attributes

        if (!this._size) {
          this.size = size$5.MEDIUM;
        }

        if (!this._variant) {
          this.variant = variant$e.DEFAULT;
        } // Support cloneNode


        var template = this.getElementsByClassName('_coral-CoachMarkIndicator-ring');

        while (template.length) {
          template[0].remove();
        } // Render template


        this.appendChild(this._template);
      }
    }, {
      key: "target",
      get: function get() {
        return this._target || null;
      },
      set: function set(value) {
        var _this2 = this;

        // We don't want to validate that the value must change here
        // If a selector is provided, we'll take the first element matching that selector
        // If the DOM is modified and the user wants a new target with the same selector,
        // They should be able to set target = 'selector' again and get a different element
        if (value === null || typeof value === 'string' || value instanceof Node) {
          this._target = value;
          requestAnimationFrame(function () {
            var targetElement = Overlay._getTarget(_this2);

            if (targetElement) {
              // Initialize popper only if we have a target
              _this2._popper = _this2._popper || new Popper(targetElement, _this2); // Update target only if valid

              if (targetElement) {
                _this2._popper.reference = targetElement;
              }

              _this2._popper.options.placement = 'top';

              _this2._popper.modifiers.forEach(function (modifier) {
                if (modifier.name === 'offset') {
                  var lengthOffset = targetElement.clientHeight / 2 + _this2.clientHeight / 2;
                  modifier.offset = "0, -".concat(lengthOffset);
                } else if (modifier.name === 'preventOverflow') {
                  modifier.padding = 0;
                }
              });

              _this2._popper.update();
            }
          });
        }
      }
      /**
       The coach mark size. See {@link CoachMarkSizeEnum}.
        @type {String}
       @default CoachMarkSizeEnum.MEDIUM
       @htmlattribute size
       @htmlattributereflected
       */

    }, {
      key: "size",
      get: function get() {
        return this._size || size$5.MEDIUM;
      },
      set: function set(value) {
        value = transform.string(value).toUpperCase();
        this._size = validate.enumeration(size$5)(value) && value || size$5.MEDIUM;

        this._reflectAttribute('size', this._size);

        this.classList.toggle("".concat(CLASSNAME$H, "--quiet"), this._size === size$5.SMALL);
      }
      /**
       The coach mark variant. See {@link CoachMarkVariantEnum}.
        @type {String}
       @default CoachMarkVariantEnum.DEFAULT
       @htmlattribute variant
       @htmlattributereflected
       */

    }, {
      key: "variant",
      get: function get() {
        return this._variant || variant$e.DEFAULT;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        this._variant = validate.enumeration(variant$e)(value) && value || variant$e.DEFAULT;

        this._reflectAttribute('variant', this._variant);

        this.classList.toggle("".concat(CLASSNAME$H, "--light"), this._variant === variant$e.LIGHT);
        this.classList.toggle("".concat(CLASSNAME$H, "--dark"), this._variant === variant$e.DARK);
      }
      /**
       Returns {@link CoachMark} sizes options.
        @return {CoachMarkSizeEnum}
       */

    }], [{
      key: "size",
      get: function get() {
        return size$5;
      }
      /**
       Returns {@link CoachMark} variant options.
        @return {CoachMarkVariantEnum}
       */

    }, {
      key: "variant",
      get: function get() {
        return variant$e;
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['size', 'variant', 'target']);
      }
    }]);

    return _class;
  }(BaseComponent(HTMLElement)));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons._define('coral-coachmark', CoachMark);

  /** @ignore */

  var colorSpace = {
    RGB: 'rgb',
    HEX: 'hex',
    CMYK: 'cmyk',
    HSB: 'hsb',
    HSL: 'hsl'
  };
  /**
   Transforms part of a color (r,g,b) into a hex value.

   @static
   @param {Number} x
   value between 0-255

   @return {String} Hex representation
   @ignore
   */

  function _hex(x) {
    return "0".concat(x.toString(16)).slice(-2);
  }
  /** @ignore */


  function _slice(str, startStr) {
    var sliced = [];
    str = transform.string(str).toLowerCase();
    startStr = transform.string(startStr).toLowerCase();

    if (str.indexOf(startStr) !== -1) {
      sliced = str.substring(str.indexOf(startStr) + startStr.length, str.lastIndexOf(')')).split(/,\s*/);
    }

    return sliced;
  }
  /**
   Parse an rgb value into an object.
   e.g.: 'rgb(0,0,0)' => {r:0, g:0, b:0}

   @static
   @param {String} rgbStr
   The string representing the rgb value

   @return {Object} {r, g, b} Returns null if string could not be parsed
   @ignore
   */


  function _parseRGB(rgbStr) {
    var sliced = _slice(rgbStr, 'rgb(');

    if (sliced.length !== 3) {
      return null;
    }

    var r = parseInt(sliced[0], 10);
    var g = parseInt(sliced[1], 10);
    var b = parseInt(sliced[2], 10);

    if (isNaN(r) || isNaN(g) || isNaN(b)) {
      return null;
    }

    if (r < 0 || r > 255 || g < 0 || g > 255 || b < 0 || b > 255) {
      return null;
    }

    return {
      r: r,
      g: g,
      b: b
    };
  }
  /**
   Serialize an rgb object into a string.
   e.g.: {r:0, g:0, b:0} => 'rgb(0,0,0)'

   @static
   @param {Object} rgb
   @return {String} rgbStr The string representing the rgb value
   @ignore
   */


  function _serializeRGB(rgb) {
    if (rgb) {
      return "rgb(".concat(rgb.r, ",").concat(rgb.g, ",").concat(rgb.b, ")");
    }

    return '';
  }
  /**
   Parse an rgba value into an object.
   e.g.: 'rgba(0,0,0,0.5)' => {r:0, g:0, b:0, a:0.5}

   @static
   @param {String} rgbaStr
   The string representing the rgba value.

   @return {Object} {r, g, b, a} Returns null if string could not be parsed
   @ignore
   */


  function _parseRGBA(rgbaStr) {
    var sliced = _slice(rgbaStr, 'rgba(');

    if (sliced.length !== 4) {
      return null;
    }

    var r = parseInt(sliced[0], 10);
    var g = parseInt(sliced[1], 10);
    var b = parseInt(sliced[2], 10);
    var a = parseFloat(sliced[3]);

    if (isNaN(r) || isNaN(g) || isNaN(b) || isNaN(a)) {
      return null;
    }

    if (r < 0 || r > 255 || g < 0 || g > 255 || b < 0 || b > 255 || a < 0 || a > 1) {
      return null;
    }

    return {
      r: r,
      g: g,
      b: b,
      a: a
    };
  }
  /**
   Serialize an rgba object into a string.
   e.g.: {r:0, g:0, b:0, a:0.5} => 'rgb(0,0,0,0.5)'

   @static
   @param {Object} rgba
   @return {String} rgbaStr The string representing the rgba value
   @ignore
   */


  function _serializeRGBA(rgba) {
    if (rgba) {
      return "rgba(".concat(rgba.r, ",").concat(rgba.g, ",").concat(rgba.b, ",").concat(rgba.a, ")");
    }

    return '';
  }
  /**
   Parse an cmyk value into an object.
   e.g.: 'cmyk(0, 100, 50, 0)' => {c:0, m:100, y:50, k:0}

   @static
   @param {String} cmykStr
   The string representing the cmyk value.

   @return {Object} {c, m, y, k} Returns null if string could not be parsed
   @ignore
   */


  function _parseCMYK(cmykStr) {
    var sliced = _slice(cmykStr, 'cmyk(');

    if (sliced.length !== 4) {
      return null;
    }

    var c = parseFloat(sliced[0]);
    var m = parseFloat(sliced[1]);
    var y = parseFloat(sliced[2]);
    var k = parseFloat(sliced[3]);

    if (isNaN(c) || isNaN(m) || isNaN(y) || isNaN(k)) {
      return null;
    }

    if (c < 0 || c > 100 || m < 0 || m > 100 || y < 0 || y > 100 || k < 0 || k > 100) {
      return null;
    }

    return {
      c: c,
      m: m,
      y: y,
      k: k
    };
  }
  /**
   Serialize an cmyk object into a string.
   e.g.: {c:0, m:100, y:50, k:0} => 'cmyk(0, 100, 50, 0)'

   @static
   @param {Object} cmyk
   @return {String} cmykStr The string representing the cmyk value
   @ignore
   */


  function _serializeCMYK(cmyk) {
    if (cmyk) {
      // make sure there are not more than 2 digits after dot
      var c = parseFloat(cmyk.c.toFixed(2));
      var m = parseFloat(cmyk.m.toFixed(2));
      var y = parseFloat(cmyk.y.toFixed(2));
      var k = parseFloat(cmyk.k.toFixed(2));
      return "cmyk(".concat(c, ",").concat(m, ",").concat(y, ",").concat(k, ")");
    }

    return '';
  }
  /**
   Parse an hex value into a number. Corrects a hex value, if it is represented by 3 or 6 characters with or without
   '#'.

   @static
   @param {String} hexStr The string representing the hex value
   @return {Number} Returns a number representing the parsed hex value
   @ignore
   */


  function _parseHex(hexStr) {
    hexStr = transform.string(hexStr).replace('#', '');

    if (hexStr.length === 3) {
      hexStr = hexStr.charAt(0) + hexStr.charAt(0) + hexStr.charAt(1) + hexStr.charAt(1) + hexStr.charAt(2) + hexStr.charAt(2);
    } // test if this could be a hex value


    var isOk = /^[0-9A-F]{6}$/i.test(hexStr);

    if (!isOk) {
      return null;
    }

    return parseInt(hexStr, 16);
  }
  /**
   Transforms a hex color into RGB representation.

   @static
   @param {Number} hex
   The color hex representation.

   @return {Object} {r, g, b}
   @ignore
   */


  function _hexToRgb(hex) {
    // explicitly test null (0 is valid)
    if (hex !== null) {
      return {
        r: hex >> 16,
        // eslint-disable-next-line no-extra-parens
        g: (hex & 0x00FF00) >> 8,
        // eslint-disable-next-line no-extra-parens
        b: hex & 0x0000FF
      };
    }

    return null;
  }
  /**
   Serialize a hex number into a string.

   @static
   @param {Number} hex
   @return {String}
   @ignore
   */


  function _serializeHex(hex) {
    // explicitly test null (0 is valid)
    if (hex !== null) {
      var rgb = _hexToRgb(hex);

      return "#".concat(_hex(rgb.r) + _hex(rgb.g) + _hex(rgb.b));
    }

    return '';
  }
  /**
   Transforms a RGB color into HEX representation.

   @static
   @param {Object} rgb
   @return {Number} hex The color hex representation
   @ignore
   */


  function _rgbToHex(rgb) {
    if (rgb) {
      return _parseHex(_hex(rgb.r) + _hex(rgb.g) + _hex(rgb.b));
    }

    return null;
  }
  /**
   Transforms a cmyk color into RGB representation. Converting CMYK to RGB will incur slight loss because both color
   spaces are not absolute and there will be some round-off error in the conversion process.

   @static
   @param {Object} cmyk
   @return {Object} {r, g, b}
   @ignore
   */


  function _cmykToRgb(cmyk) {
    if (!cmyk) {
      return null;
    }

    var result = {
      r: 0,
      g: 0,
      b: 0
    };
    var c = parseFloat(cmyk.c) / 100;
    var m = parseFloat(cmyk.m) / 100;
    var y = parseFloat(cmyk.y) / 100;
    var k = parseFloat(cmyk.k) / 100;
    result.r = 1 - Math.min(1, c * (1 - k) + k);
    result.g = 1 - Math.min(1, m * (1 - k) + k);
    result.b = 1 - Math.min(1, y * (1 - k) + k);
    result.r = Math.round(result.r * 255);
    result.g = Math.round(result.g * 255);
    result.b = Math.round(result.b * 255);
    return result;
  }
  /**
   Transforms a rgb color into cmyk representation. Converting CMYK to RGB will incur slight loss because both color
   spaces are not absolute and there will be some round-off error in the conversion process.

   @static
   @param {Object} rgb
   @return {Object} {c, m, y, k}
   @ignore
   */


  function _rgbToCmyk(rgb) {
    if (!rgb) {
      return null;
    }

    var result = {
      c: 0,
      m: 0,
      y: 0,
      k: 0
    };

    if (rgb.r === 0 && rgb.g === 0 && rgb.b === 0) {
      result.k = 100;
      return result;
    }

    var r = rgb.r / 255;
    var g = rgb.g / 255;
    var b = rgb.b / 255;
    result.k = Math.min(1 - r, 1 - g, 1 - b);
    result.c = (1 - r - result.k) / (1 - result.k);
    result.m = (1 - g - result.k) / (1 - result.k);
    result.y = (1 - b - result.k) / (1 - result.k);
    result.c = Math.round(result.c * 100);
    result.m = Math.round(result.m * 100);
    result.y = Math.round(result.y * 100);
    result.k = Math.round(result.k * 100);
    return result;
  }
  /**
   Parse an hsb value into an object.
   e.g.: 'hsb(360,100,0)' => {h:360, s:100, b:0}

   @static
   @param {String} hsbStr
   The string representing the hsb value.

   @return {Object} {h, s, b} Returns null if string could not be parsed
   @ignore
   */


  function _parseHSB(hsbStr) {
    var sliced = _slice(hsbStr, 'hsb(');

    if (sliced.length !== 3) {
      return null;
    } // make sure there are not more than 2 digits after dot


    var h = parseFloat(sliced[0]);
    var s = parseFloat(sliced[1]);
    var b = parseFloat(sliced[2]);

    if (isNaN(h) || isNaN(s) || isNaN(b)) {
      return null;
    }

    if (h < 0 || h > 360 || s < 0 || s > 100 || b < 0 || b > 100) {
      return null;
    }

    return {
      h: h,
      s: s,
      b: b
    };
  }
  /**
   Serialize an hsb object into a string.
   e.g.: {h:0, s:0, b:0} => 'hsb(0,0,0)'

   @static
   @param {Object} hsb
   @return {String} hsb The string representing the hsb value
   @ignore
   */


  function _serializeHSB(hsb) {
    if (hsb) {
      // make sure there are not more than 2 digits after dot
      var h = parseFloat(hsb.h.toFixed(2));
      var s = parseFloat(hsb.s.toFixed(2));
      var b = parseFloat(hsb.b.toFixed(2));
      return "hsb(".concat(h, ",").concat(s, ",").concat(b, ")");
    }

    return '';
  }
  /**
   Transforms a HSB (same as HSV) color into RGB representation.
   h (hue has value between 0-360 degree)
   s (saturation has a value between 0-100 percent)
   b (brightness has a value between 0-100 percent)

   @static
   @param {Object} hsb
   @return {Object} {r, g, b}
   @ignore
   */


  function _hsbToRgb(hsb) {
    if (!hsb) {
      return null;
    }

    var h = hsb.h / 360;
    var s = hsb.s / 100;
    var v = hsb.b / 100;
    var r, g, b;
    var i = Math.floor(h * 6);
    var f = h * 6 - i;
    var p = v * (1 - s);
    var q = v * (1 - f * s);
    var t = v * (1 - (1 - f) * s);

    switch (i % 6) {
      case 0:
        r = v;
        g = t;
        b = p;
        break;

      case 1:
        r = q;
        g = v;
        b = p;
        break;

      case 2:
        r = p;
        g = v;
        b = t;
        break;

      case 3:
        r = p;
        g = q;
        b = v;
        break;

      case 4:
        r = t;
        g = p;
        b = v;
        break;

      case 5:
        r = v;
        g = p;
        b = q;
        break;
    }

    return {
      r: Math.round(r * 255),
      g: Math.round(g * 255),
      b: Math.round(b * 255)
    };
  }
  /**
   Transforms a RGB color into HSB (same as HSV) representation.

   @static
   @param {Object} rgb
   @return {Object} {h, s, b}
   @ignore
   */


  function _rgbToHsb(rgb) {
    if (!rgb) {
      return null;
    }

    var r = rgb.r;
    var g = rgb.g;
    var b = rgb.b;
    var max = Math.max(r, g, b);
    var min = Math.min(r, g, b);
    var d = max - min;
    var h;
    var s = max === 0 ? 0 : d / max;
    var v = max / 255;

    switch (max) {
      case min:
        h = 0;
        break;

      case r:
        h = g - b + d * (g < b ? 6 : 0);
        h /= 6 * d;
        break;

      case g:
        h = b - r + d * 2;
        h /= 6 * d;
        break;

      case b:
        h = r - g + d * 4;
        h /= 6 * d;
        break;
    }

    return {
      h: h * 360,
      s: s * 100,
      b: v * 100
    };
  }
  /**
   Parse an hsl value into an object.
   e.g.: 'hsl(360,100,0)' => {h:360, s:100, b:0}

   @static
   @param {String} hslStr
   The string representing the hsl value.

   @return {Object} {h, s, l} Returns null if string could not be parsed
   @ignore
   */


  function _parseHSL(hslStr) {
    var sliced = _slice(hslStr, 'hsl(');

    if (sliced.length !== 3) {
      return null;
    } // make sure there are not more than 2 digits after dot


    var h = parseFloat(sliced[0]);
    var s = parseFloat(sliced[1]);
    var l = parseFloat(sliced[2]);

    if (isNaN(h) || isNaN(s) || isNaN(l)) {
      return null;
    }

    if (h < 0 || h > 360 || s < 0 || s > 100 || l < 0 || l > 100) {
      return null;
    }

    return {
      h: h,
      s: s,
      l: l
    };
  }
  /**
   Serialize an hsl object into a string.
   e.g.: {h:0, s:0, l:0} => 'hsl(0,0%,0%)'

   @static
   @param {Object} hsl
   @return {String} hsb The string representing the hsb value
   @ignore
   */


  function _serializeHSL(hsl) {
    if (hsl) {
      // make sure there are not more than 2 digits after dot
      var h = parseFloat(hsl.h.toFixed(2));
      var s = parseFloat(hsl.s.toFixed(2));
      var l = parseFloat(hsl.l.toFixed(2));
      return "hsl(".concat(h, ",").concat(s, "%,").concat(l, "%)");
    }

    return '';
  }
  /**
   Transforms a HSL color into RGB representation.
   h (hue has value between 0-360 degree)
   s (saturation has a value between 0-100 percent)
   l (lightness has a value between 0-100 percent)

   @static
   @param {Object} hsl
   @return {Object} {r, g, b}
   @ignore
   */


  function _hslToRgb(hsl) {
    if (!hsl) {
      return null;
    }

    var h = hsl.h / 360;
    var s = hsl.s / 100;
    var l = hsl.l / 100;
    var r;
    var g;
    var b;

    if (s === 0) {
      // achromatic
      r = g = b = l;
    } else {
      var hue2rgb = function hue2rgb(p, q, t) {
        if (t < 0) {
          t += 1;
        }

        if (t > 1) {
          t -= 1;
        }

        if (t < 1 / 6) {
          return p + (q - p) * 6 * t;
        }

        if (t < 1 / 2) {
          return q;
        }

        if (t < 2 / 3) {
          return p + (q - p) * (2 / 3 - t) * 6;
        }

        return p;
      };

      var qValue = l < 0.5 ? l * (1 + s) : l + s - l * s;
      var pValue = 2 * l - qValue;
      r = hue2rgb(pValue, qValue, h + 1 / 3);
      g = hue2rgb(pValue, qValue, h);
      b = hue2rgb(pValue, qValue, h - 1 / 3);
    }

    return {
      r: Math.round(r * 255),
      g: Math.round(g * 255),
      b: Math.round(b * 255)
    };
  }
  /**
   Transforms an RGB color into HSL representation.

   @static
   @param {Object} rgb
   @return {Object} {h, s, l}
   @ignore
   */


  function _rgbToHsl(rgb) {
    if (!rgb) {
      return null;
    }

    var r = rgb.r / 255;
    var g = rgb.g / 255;
    var b = rgb.b / 255;
    var max = Math.max(r, g, b);
    var min = Math.min(r, g, b);
    var h;
    var s;
    var l = (max + min) / 2;

    if (max === min) {
      // achromatic
      h = s = 0;
    } else {
      var d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

      switch (max) {
        case r:
          h = (g - b) / d + (g < b ? 6 : 0);
          break;

        case g:
          h = (b - r) / d + 2;
          break;

        case b:
          h = (r - g) / d + 4;
          break;
      }

      h /= 6;
    }

    return {
      h: h * 360,
      s: s * 100,
      l: l * 100
    };
  }
  /**
   Parse an hsla value into an object.
   e.g.: 'hsla(360,100%,0%,0.5)' => {h:360, s:100, l:0, 0.5}

   @static
   @param {String} hslaStr
   The string representing the hsl value.

   @return {Object} {h, s, l, a} Returns null if string could not be parsed
   @ignore
   */


  function _parseHSLA(hslaStr) {
    var sliced = _slice(hslaStr, 'hsla(');

    if (sliced.length !== 4) {
      return null;
    } // make sure there are not more than 2 digits after dot


    var h = parseFloat(sliced[0]);
    var s = parseFloat(sliced[1]);
    var l = parseFloat(sliced[2]);
    var a = parseFloat(sliced[3]);

    if (isNaN(h) || isNaN(s) || isNaN(l)) {
      return null;
    }

    if (h < 0 || h > 360 || s < 0 || s > 100 || l < 0 || l > 100 || a < 0 || a > 1) {
      return null;
    }

    return {
      h: h,
      s: s,
      l: l,
      a: a
    };
  }
  /**
   Serialize an hsla object into a string.
   e.g.: {h:0, s:0, l:0, a:0.5} => 'hsl(0,0%,0%,0.5)'

   @static
   @param {Object} hsla
   @return {String} hsb The string representing the hsb value
   @ignore
   */


  function _serializeHSLA(hsla) {
    if (hsla) {
      // make sure there are not more than 2 digits after dot
      var h = parseFloat(hsla.h.toFixed(2));
      var s = parseFloat(hsla.s.toFixed(2));
      var l = parseFloat(hsla.l.toFixed(2));
      var a = parseFloat(hsla.a.toFixed(2));
      return "hsla(".concat(h, ",").concat(s, "%,").concat(l, "%,").concat(a, ")");
    }

    return '';
  }
  /**
   Color is used to get a color in different color spaces, calculate tints and shades etc.
   */


  var Color = /*#__PURE__*/function () {
    /** @ignore */
    function Color() {
      _classCallCheck(this, Color);

      // Set defaults
      this._colorSpace = colorSpace.HEX;
      this._value = '';
      this._alpha = 1;
    }
    /**
     The value of the color. This value can be set in different formats (HEX, RGB, RGBA, HSB, HSL, HSLA and CMYK).
     Corrects a hex value, if it is represented by 3 or 6 characters with or without '#'.
      e.g:
     HEX:  #FFFFFF
     RGB:  rgb(16,16,16)
     RGBA: rgba(215,40,40,0.9)
     HSB:  hsb(360,100,100)
     HSL:  hsl(360,100%,100%)
     HSLA: hsla(360,100%,100%,0.9)
     CMYK: cmyk(0,100,50,0)
      @type {String}
     @default ""
     */


    _createClass(Color, [{
      key: "clone",

      /**
       Clone this color.
        @type {Color}
       */
      value: function clone() {
        var clone = new this.constructor();
        clone.value = this.value;
        clone.alpha = this.alpha;
        return clone;
      }
      /**
       Test if this Color is similar to another color.
        @type {Boolean}
       @param {Color} compareColor
       The color to compare this color too.
        @param {Boolean} [allowSlightColorDifference=true]
       While converting between color spaces slight loses might happen => we should normally consider colors equal,
       even if they are minimally different.
        */

    }, {
      key: "isSimilarTo",
      value: function isSimilarTo(compareColor, allowSlightColorDifference) {
        if (this.rgb === null && (!compareColor || compareColor.rgb === null)) {
          // Consider an rgb of null equal to a null object (or another value of null)
          return true;
        }

        if (!compareColor || compareColor.rgb === null || this.rgb === null) {
          return false;
        }

        var allowedRgbDifference = 1;
        var allowedAlphaDifference = 0.01;

        if (allowSlightColorDifference === false) {
          allowedRgbDifference = 0;
          allowedAlphaDifference = 0;
        }

        var rgb = this.rgb;
        var rgb2 = compareColor.rgb;
        var rDiff = Math.abs(rgb2.r - rgb.r);
        var gDiff = Math.abs(rgb2.g - rgb.g);
        var bDiff = Math.abs(rgb2.b - rgb.b);
        var aDiff = Math.abs(this.alpha - compareColor.alpha);

        if (rDiff <= allowedRgbDifference && gDiff <= allowedRgbDifference && bDiff <= allowedRgbDifference && aDiff <= allowedAlphaDifference) {
          return true;
        }

        return false;
      }
      /**
       Calculates an array of lighter colors.
        @type {Array<Coral.Color>}
       @param {Number} amount
       Amount of tint colors to generate.
        */

    }, {
      key: "calculateTintColors",
      value: function calculateTintColors(amount) {
        var tintColors = [];
        var tintColor = null;
        var rgb = this.rgb;

        if (rgb) {
          var r = rgb.r;
          var g = rgb.g;
          var b = rgb.b;
          var tintFactor = 1;

          for (var i = 1; i <= amount; i++) {
            tintFactor = i / (amount + 1);
            tintColor = this.clone(); // alpha value kept from original

            tintColor.rgb = {
              r: r + (255 - r) * tintFactor,
              g: g + (255 - g) * tintFactor,
              b: b + (255 - b) * tintFactor
            };
            tintColors.push(tintColor);
          }
        }

        return tintColors;
      }
      /**
       Calculates an array of darker colors.
        @type {Array<Coral.Color>}
       @param {Number} amount
       Amount of shade colors to generate.
        */

    }, {
      key: "calculateShadeColors",
      value: function calculateShadeColors(amount) {
        var shadeColors = [];
        var shadeColor = null;
        var rgb = this.rgb;

        if (rgb) {
          var r = rgb.r;
          var g = rgb.g;
          var b = rgb.b;
          var shadeFactor = 1;

          for (var i = 1; i <= amount; i++) {
            shadeFactor = i / (amount + 1);
            shadeColor = this.clone(); // alpha value kept from original

            shadeColor.rgb = {
              r: r * (1 - shadeFactor),
              g: g * (1 - shadeFactor),
              b: b * (1 - shadeFactor)
            };
            shadeColors.push(shadeColor);
          }
        }

        return shadeColors;
      }
    }, {
      key: "value",
      get: function get() {
        return this._value;
      },
      set: function set(value) {
        // Two color formats with alpha values
        var rgba = _parseRGBA(value);

        var hsla = _parseHSLA(value);

        var rgb = _parseRGB(value);

        var cmyk = _parseCMYK(value);

        var hsb = _parseHSB(value);

        var hsl = _parseHSL(value);

        var hex = _parseHex(value);

        if (rgba !== null) {
          this._colorSpace = colorSpace.RGB;
          this.alpha = rgba.a;
          value = _serializeRGB({
            r: rgba.r,
            g: rgba.g,
            b: rgba.b
          });
        } else if (hsla !== null) {
          this._colorSpace = colorSpace.HSL;
          this.alpha = hsla.a;
          value = _serializeHSL({
            h: hsla.h,
            s: hsla.s,
            l: hsla.l
          });
        } else if (rgb !== null) {
          this._colorSpace = colorSpace.RGB;
        } else if (cmyk !== null) {
          this._colorSpace = colorSpace.CMYK;
        } else if (hsb !== null) {
          this._colorSpace = colorSpace.HSB;
        } else if (hsl !== null) {
          this._colorSpace = colorSpace.HSL;
        } else if (hex !== null) {
          this._colorSpace = colorSpace.HEX;
        } else {
          // restore defaults
          this._colorSpace = colorSpace.HEX;
          value = '';
        }

        this._value = value;
      }
      /**
       The alpha value of the color (value between 0-1).
        @type {Number}
       @default 1
       */

    }, {
      key: "alpha",
      get: function get() {
        return this._alpha;
      },
      set: function set(value) {
        if (isNaN(value) || value < 0 || value > 1) {
          return;
        }

        this._alpha = transform.number(value);
      }
      /**
       The rgb values of the color (value between 0-255).
       e.g.: {r:0, g:0, b:0}
        @type {Object}
       @default null
       */

    }, {
      key: "rgb",
      get: function get() {
        var rgb = null;

        if (this._colorSpace === colorSpace.RGB) {
          rgb = _parseRGB(this.value);
        } else if (this._colorSpace === colorSpace.HEX) {
          var hex = _parseHex(this.value);

          rgb = _hexToRgb(hex);
        } else if (this._colorSpace === colorSpace.CMYK) {
          var cmyk = _parseCMYK(this.value);

          rgb = _cmykToRgb(cmyk);
        } else if (this._colorSpace === colorSpace.HSB) {
          var hsb = _parseHSB(this.value);

          rgb = _hsbToRgb(hsb);
        } else if (this._colorSpace === colorSpace.HSL) {
          var hsl = _parseHSL(this.value);

          rgb = _hslToRgb(hsl);
        }

        return rgb;
      },
      set: function set(value) {
        this.value = _serializeRGB(value);
      }
      /**
       The serialized rgb values of the color (r,g,b values between 0-255).
       e.g: 'rgb(0,0,0)'
        @type {String}
       @default ""
       */

    }, {
      key: "rgbValue",
      get: function get() {
        return _serializeRGB(this.rgb);
      },
      set: function set(value) {
        this.value = value;
      }
      /**
       The rgba values of the color (r,g,b values between 0-255 and a between 0-1).
       e.g: {r:0, g:0, b:0, a:1}
        @type {Object}
       @default null
       */

    }, {
      key: "rgba",
      get: function get() {
        var rgb = this.rgb;

        if (rgb) {
          return {
            r: rgb.r,
            g: rgb.g,
            b: rgb.b,
            a: this.alpha
          };
        }

        return null;
      },
      set: function set(value) {
        this.value = _serializeRGBA(value);
      }
      /**
       The serialized rgba values of the color (r,g,b values between 0-255 and alpha between 0-1).
       e.g: 'rgba(0,0,0,1)'
        @type {String}
       @default ""
       */

    }, {
      key: "rgbaValue",
      get: function get() {
        return _serializeRGBA(this.rgba);
      },
      set: function set(value) {
        this.value = value;
      }
      /**
       The hex value of the color.
        @type {Number}
       @default null
       */

    }, {
      key: "hex",
      get: function get() {
        // as hex color space is essentially just the same as rgb and there is no loss in conversion, we can do it this way
        return _rgbToHex(this.rgb);
      },
      set: function set(value) {
        this.value = _serializeHex(value);
      }
      /**
       The serialized hex value of the color.
       e.g: '#94CD4B'
        @type {String}
       @default ""
       */

    }, {
      key: "hexValue",
      get: function get() {
        return _serializeHex(this.hex);
      },
      set: function set(value) {
        this.value = value;
      }
      /**
       The cmyk values of the color (all values between 0-100).
       e.g: {c:0, m:100, y:0, k:100}
        @type {Object}
       @default null
       */

    }, {
      key: "cmyk",
      get: function get() {
        var cmyk = null;
        var rgb = null;

        if (this._colorSpace === colorSpace.RGB) {
          rgb = _parseRGB(this.value);
          cmyk = _rgbToCmyk(rgb);
        } else if (this._colorSpace === colorSpace.HEX) {
          var hex = _parseHex(this.value);

          rgb = _hexToRgb(hex);
          cmyk = _rgbToCmyk(rgb);
        } else if (this._colorSpace === colorSpace.CMYK) {
          cmyk = _parseCMYK(this.value);
        } else if (this._colorSpace === colorSpace.HSB) {
          var hsb = _parseHSB(this.value);

          rgb = _hsbToRgb(hsb);
          cmyk = _rgbToCmyk(rgb);
        } else if (this._colorSpace === colorSpace.HSL) {
          var hsl = _parseHSL(this.value);

          rgb = _hslToRgb(hsl);
          cmyk = _rgbToCmyk(rgb);
        }

        return cmyk;
      },
      set: function set(value) {
        this.value = _serializeCMYK(value);
      }
      /**
       The serialized cmyk values of the color (all values between 0-100).
       e.g: 'cmyk(100,100,100,100)'
        @type {String}
       @default ""
       */

    }, {
      key: "cmykValue",
      get: function get() {
        return _serializeCMYK(this.cmyk);
      },
      set: function set(value) {
        this.value = value;
      }
      /**
       The hsb values of the color.
       h (hue has value between 0-360 degree)
       s (saturation has a value between 0-100 percent)
       b (brightness has a value between 0-100 percent)
        @type {Object}
       @default null
       */

    }, {
      key: "hsb",
      get: function get() {
        var hsb = null;
        var rgb = null;

        if (this._colorSpace === colorSpace.RGB) {
          rgb = _parseRGB(this.value);
          hsb = _rgbToHsb(rgb);
        } else if (this._colorSpace === colorSpace.HEX) {
          var hex = _parseHex(this.value);

          rgb = _hexToRgb(hex);
          hsb = _rgbToHsb(rgb);
        } else if (this._colorSpace === colorSpace.CMYK) {
          var cmyk = _parseCMYK(this.value);

          rgb = _cmykToRgb(cmyk);
          hsb = _rgbToHsb(rgb);
        } else if (this._colorSpace === colorSpace.HSB) {
          hsb = _parseHSB(this.value);
        } else if (this._colorSpace === colorSpace.HSL) {
          var hsl = _parseHSL(this.value);

          rgb = _hslToRgb(hsl);
          hsb = _rgbToHsb(rgb);
        }

        return hsb;
      },
      set: function set(value) {
        this.value = _serializeHSB(value);
      }
      /**
       The serialized hsb values of the color (s and b values between 0-100, h between 0-360).
       e.g: 'hsb(360,100,100)'
        @type {String}
       @default ""
       */

    }, {
      key: "hsbValue",
      get: function get() {
        return _serializeHSB(this.hsb);
      },
      set: function set(value) {
        this.value = value;
      }
      /*
       The hsl values of the color.
       h (hue has value between 0-360 degree)
       s (saturation has a value between 0-100 percent)
       l (lightness has a value between 0-100 percent)
        @type {Object}
       @default null
       */

    }, {
      key: "hsl",
      get: function get() {
        var hsl = null;
        var rgb = null;

        if (this._colorSpace === colorSpace.RGB) {
          rgb = _parseRGB(this.value);
          hsl = _rgbToHsl(rgb);
        } else if (this._colorSpace === colorSpace.HEX) {
          var hex = _parseHex(this.value);

          rgb = _hexToRgb(hex);
          hsl = _rgbToHsl(rgb);
        } else if (this._colorSpace === colorSpace.CMYK) {
          var cmyk = _parseCMYK(this.value);

          rgb = _cmykToRgb(cmyk);
          hsl = _rgbToHsl(rgb);
        } else if (this._colorSpace === colorSpace.HSB) {
          var hsb = _parseHSB(this.value);

          rgb = _hsbToRgb(hsb);
          hsl = _rgbToHsl(rgb);
        } else if (this._colorSpace === colorSpace.HSL) {
          hsl = _parseHSL(this.value);
        }

        return hsl;
      },
      set: function set(value) {
        this.value = _serializeHSL(value);
      }
      /**
       The serialized hsl values of the color (s and l values between 0-100 in percent, h between 0-360).
       e.g: 'hsl(360,100%,100%)'
        @type {String}
       @default ""
       */

    }, {
      key: "hslValue",
      get: function get() {
        return _serializeHSL(this.hsl);
      },
      set: function set(value) {
        this.value = value;
      }
      /**
       The hsla values of the color.
       h (hue has value between 0-360 degree)
       s (saturation has a value between 0-100 percent)
       l (lightness has a value between 0-100 percent)
       a (alpha has a value between 0-1)
        @type {Object}
       @default null
       */

    }, {
      key: "hsla",
      get: function get() {
        var hsl = this.hsl;

        if (hsl) {
          return {
            h: hsl.h,
            s: hsl.s,
            l: hsl.l,
            a: this.alpha
          };
        }

        return null;
      },
      set: function set(value) {
        this.value = _serializeHSLA(value);
      }
      /**
       The serialized hsla values of the color.
       h (hue has value between 0-360 degree)
       s (saturation has a value between 0-100 percent)
       l (lightness has a value between 0-100 percent)
       a (alpha has a value between 0-1)
       e.g: 'hsla(360,50%,50%,0.9)'
        @type {String}
       @default ""
       */

    }, {
      key: "hslaValue",
      get: function get() {
        return _serializeHSLA(this.hsla);
      },
      set: function set(value) {
        this.value = value;
      }
    }]);

    return Color;
  }();

  /**
   @class Coral.ColorInput.Item
   @classdesc A ColorInput Item component
   @htmltag coral-colorinput-item
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var ColorInputItem = Decorator( /*#__PURE__*/function (_BaseComponent) {
    _inherits(_class, _BaseComponent);

    var _super = _createSuper(_class);

    function _class() {
      _classCallCheck(this, _class);

      return _super.apply(this, arguments);
    }

    _createClass(_class, [{
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this); // adds the role to support accessibility


        this.setAttribute('role', 'option');
      }
    }, {
      key: "value",

      /**
       The value of the color. This value can be set in different formats (HEX, RGB, RGBA, HSB, HSL, HSLA and CMYK).
       Corrects a hex value, if it is represented by 3 or 6 characters with or without '#'.
        e.g:
       HEX:  #FFFFFF
       RGB:  rgb(16,16,16)
       RGBA: rgba(215,40,40,0.9)
       HSB: hsb(360,100,100)
       HSL: hsl(360,100,100)
       HSLA: hsla(360,100%,100%, 0.9)
       CMYK: cmyk(0,100,50,0)
        @type {String}
       @default ""
       @htmlattribute value
       @htmlattributereflected
       */
      get: function get() {
        return this._value || '';
      },
      set: function set(value) {
        // invalid values fallback to empty string
        var color = new Color();
        color.value = value; // invalid values fallback to empty string

        this._value = color.rgb !== null ? value : '';

        this._reflectAttribute('value', this._value);
      }
      /**
       Whether the Item is selected.
       @type {Boolean}
       @default false
       @htmlattribute selected
       @htmlattributereflected
       */

    }, {
      key: "selected",
      get: function get() {
        return this._selected || false;
      },
      set: function set(value) {
        value = transform.booleanAttr(value);
        this._selected = value;

        this._reflectAttribute('selected', this._selected);

        this.classList.toggle('is-selected', this._selected);
        this.setAttribute('aria-selected', this._selected);
        this.trigger('coral-colorinput-item:_selectedchanged');
      }
      /** @ignore */

    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['selected', 'value']);
      }
    }]);

    return _class;
  }(BaseComponent(HTMLElement)));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @base BaseColorInputAbstractSubview
   @classdesc An abstract subview class that other subviews should extend.
   */
  var BaseColorInputAbstractSubview = function BaseColorInputAbstractSubview(superClass) {
    return /*#__PURE__*/function (_superClass) {
      _inherits(_class, _superClass);

      var _super = _createSuper(_class);

      /** @ignore */
      function _class() {
        var _this;

        _classCallCheck(this, _class);

        _this = _super.call(this);
        _this._events = {
          'click ._coral-ColorInput-preview': '_onPreviewClicked'
        }; // export a static variable used by all subviews

        _this.constructor._lastValidColor = null;
        return _this;
      }
      /** @ignore */


      _createClass(_class, [{
        key: "_onPreviewClicked",
        value: function _onPreviewClicked() {
          if (this._colorinput.valueAsColor !== null) {
            this.constructor._lastValidColor = this._colorinput.valueAsColor;

            this._colorinput._setActiveColor(null);
          } else if (this.constructor._lastValidColor !== null) {
            this._colorinput._setActiveColor(this.constructor._lastValidColor);
          }
        }
        /** @ignore */

      }, {
        key: "_beforeOverlayOpen",
        value: function _beforeOverlayOpen() {} // overwrite callback in subclass if needed

        /** @ignore */

      }, {
        key: "_onColorInputChange",
        value: function _onColorInputChange() {} // overwrite callback in subclass if needed

        /** @ignore */

      }, {
        key: "connectedCallback",
        value: function connectedCallback() {
          _get(_getPrototypeOf(_class.prototype), "connectedCallback", this).call(this);

          var overlay = this.closest('._coral-ColorInput-overlay');

          if (overlay && overlay._colorinput) {
            // save references to bound callbacks (in order to be able to remove them again from event system)
            this.__beforeOverlayOpen = this._beforeOverlayOpen.bind(this);
            this.__onColorInputChange = this._onColorInputChange.bind(this); // cache colorinput if this component is attached to dom

            this._colorinput = overlay._colorinput;

            this._colorinput.on('coral-overlay:beforeopen', this.__beforeOverlayOpen);

            this._colorinput.on('coral-colorinput:_valuechange', this.__onColorInputChange); // trigger one change initially


            this._onColorInputChange();
          }
        }
        /** @ignore */

      }, {
        key: "disconnectedCallback",
        value: function disconnectedCallback() {
          _get(_getPrototypeOf(_class.prototype), "disconnectedCallback", this).call(this);

          if (this._colorinput) {
            this._colorinput.off('coral-overlay:beforeopen', this.__beforeOverlayOpen);

            this._colorinput.off('coral-colorinput:_valuechange', this.__onColorInputChange);
          }

          this._colorinput = null;
        }
      }]);

      return _class;
    }(superClass);
  };

  var template$q = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["label"] = document.createElement("div");
    el0.className += " _coral-Slider-labelContainer";
    el0.setAttribute("handle", "label");
    var el1 = document.createTextNode("\n  ");
    el0.appendChild(el1);
    var el2 = this["labelContent"] = document.createElement("label");
    el2.className += " _coral-Slider-label";
    el2.setAttribute("handle", "labelContent");
    el0.appendChild(el2);
    var el3 = document.createTextNode("\n  ");
    el0.appendChild(el3);
    var el4 = this["labelValue"] = document.createElement("label");
    el4.className += " _coral-Slider-value";
    el4.setAttribute("handle", "labelValue");
    el4.setAttribute("hidden", "");
    el0.appendChild(el4);
    var el5 = document.createTextNode("\n");
    el0.appendChild(el5);
    frag.appendChild(el0);
    var el6 = document.createTextNode("\n");
    frag.appendChild(el6);
    var el7 = this["controls"] = document.createElement("div");
    el7.className += " _coral-Slider-controls";
    el7.setAttribute("role", "presentation");
    el7.setAttribute("handle", "controls");
    var el8 = document.createTextNode("\n  ");
    el7.appendChild(el8);
    var el9 = document.createElement("div");
    el9.className += " _coral-Slider-track";
    el7.appendChild(el9);
    var el10 = document.createTextNode("\n  ");
    el7.appendChild(el10);
    var el11 = this["leftHandle"] = document.createElement("div");
    el11.className += " _coral-Slider-handle";
    el11.setAttribute("handle", "leftHandle");
    var el12 = document.createTextNode("\n    ");
    el11.appendChild(el12);
    var el13 = this["leftInput"] = document.createElement("input");
    el13.setAttribute("handle", "leftInput");
    el13.setAttribute("value", "1");
    el13.setAttribute("type", "range");
    el13.className += " _coral-Slider-input";
    el11.appendChild(el13);
    var el14 = document.createTextNode("\n  ");
    el11.appendChild(el14);
    el7.appendChild(el11);
    var el15 = document.createTextNode("\n  ");
    el7.appendChild(el15);
    var el16 = document.createElement("div");
    el16.className += " _coral-Slider-track";
    el7.appendChild(el16);
    var el17 = document.createTextNode("\n");
    el7.appendChild(el17);
    frag.appendChild(el7);
    var el18 = document.createTextNode("\n");
    frag.appendChild(el18);
    return frag;
  };

  var CLASSNAME$I = '_coral-Slider';
  var CLASSNAME_HANDLE = '_coral-Slider-handle';
  var CLASSNAME_INPUT = '_coral-Slider-input';
  /**
   Enumeration for {@link Slider} orientations.

   @typedef {Object} SliderOrientationEnum

   @property {String} HORIZONTAL
   Horizontal slider.
   @property {String} VERTICAL
   Not supported. Falls back to HORIZONTAL.
   */

  var orientation$2 = {
    HORIZONTAL: 'horizontal',
    VERTICAL: 'vertical'
  };
  /**
   @class Coral.Slider
   @classdesc A Slider component is a form field that can be used to set a number within a range.
   @htmltag coral-slider
   @extends {HTMLElement}
   @extends {BaseComponent}
   @extends {BaseFormField}
   */

  var ExtensibleSlider = /*#__PURE__*/function (_BaseFormField) {
    _inherits(ExtensibleSlider, _BaseFormField);

    var _super = _createSuper(ExtensibleSlider);

    /** @ignore */
    function ExtensibleSlider() {
      var _this;

      _classCallCheck(this, ExtensibleSlider);

      _this = _super.call(this);

      _this._delegateEvents(commons.extend(_this._events, {
        'key:up ._coral-Slider-handle': '_handleKey',
        'key:right ._coral-Slider-handle': '_handleKey',
        'key:down ._coral-Slider-handle': '_handleKey',
        'key:left ._coral-Slider-handle': '_handleKey',
        'key:pageUp ._coral-Slider-handle': '_handleKey',
        'key:pageDown ._coral-Slider-handle': '_handleKey',
        'key:home ._coral-Slider-handle': '_handleKey',
        'key:end ._coral-Slider-handle': '_handleKey',
        'input': '_onInputChangeHandler',
        'touchstart': '_onMouseDown',
        'mousedown': '_onMouseDown',
        'capture:focus': '_focus',
        'capture:blur': '_blur'
      })); // Prepare templates


      _this._elements = {};

      _this._getTemplate().call(_this._elements, {
        commons: commons
      }); // Pre-define labellable element


      _this._labellableElement = _this._elements.leftInput; // Content zone

      _this._elements.content = _this.querySelector('coral-slider-content') || document.createElement('coral-slider-content'); // Additional shortcuts

      var handleContainer = _this._elements.controls;
      _this._elements.handles = Array.prototype.slice.call(handleContainer.querySelectorAll(".".concat(CLASSNAME_HANDLE)));
      _this._elements.inputs = Array.prototype.slice.call(handleContainer.querySelectorAll(".".concat(CLASSNAME_INPUT))); // Binding

      _this._onInteraction = _this._onInteraction.bind(_assertThisInitialized(_this)); // Init the collection mutation observer

      _this.items._startHandlingItems(true);

      return _this;
    }
    /**
     The slider's content.
      @type {SliderContent}
     @contentzone
     */


    _createClass(ExtensibleSlider, [{
      key: "_getValueOf",

      /** @private */
      value: function _getValueOf(name, defaultValue) {
        if (typeof this["_".concat(name)] === 'number') {
          return this["_".concat(name)];
        } else if (this.hasAttribute(name)) {
          return parseFloat(this.getAttribute(name));
        }

        return defaultValue;
      }
      /**
       handles any mousedown/touchstart on the whole slider
       @private
       */

    }, {
      key: "_onMouseDown",
      value: function _onMouseDown(event) {
        if (this.disabled) {
          return;
        } // do not accept right mouse button clicks


        if (event instanceof MouseEvent) {
          if ((event.which || event.button) !== 1) {
            return;
          }
        }

        event.preventDefault();
        this._currentHandle = event.target.closest(".".concat(CLASSNAME_HANDLE)); // If no handle was touched:
        // the closest handle needs to jump to the closest valid position

        if (!this._currentHandle) {
          var p = this._getPoint(event);

          var val = this._getValueFromCoord(p.pageX, p.pageY, true);

          this._currentHandle = this._findNearestHandle(p.pageX, p.pageY);

          this._updateValue(this._currentHandle, val);

          this._setHandleFocus(this._currentHandle);
        }

        this._currentHandle.classList.add('is-dragged');

        document.body.classList.add('u-coral-closedHand');
        this._draggingHandler = this._handleDragging.bind(this);
        this._mouseUpHandler = this._mouseUp.bind(this);
        events.on('mousemove.Slider', this._draggingHandler);
        events.on('mouseup.Slider', this._mouseUpHandler);
        events.on('touchmove.Slider', this._draggingHandler);
        events.on('touchend.Slider', this._mouseUpHandler);
        events.on('touchcancel.Slider', this._mouseUpHandler);

        this._setHandleFocus(this._currentHandle);
      }
      /**
       @private
       @return {Object} which contains the real coordinates
       */

    }, {
      key: "_getPoint",
      value: function _getPoint(event) {
        if (event.changedTouches && event.changedTouches.length > 0) {
          return event.changedTouches[0];
        } else if (event.touches && event.touches.length > 0) {
          return event.touches[0];
        }

        return event;
      }
      /**
       will set the focus either on the handle element
       or its input if range is supported
        @protected
       */

    }, {
      key: "_setHandleFocus",
      value: function _setHandleFocus(handle) {
        handle.querySelector(".".concat(CLASSNAME_INPUT)).focus();
      }
      /**
       Handles keyboard interaction with the handlers.
       In case input[type=range] is supported, the focus
       will be on the input and keyboard handling will happen natively
        @private
       */

    }, {
      key: "_handleKey",
      value: function _handleKey(event) {
        event.preventDefault();

        this._focus(event);

        var handle = event.matchedTarget;

        var idx = this._elements.handles.indexOf(handle);

        var v = parseInt(this._values[idx], 10); // increase

        if (event.keyCode === Keys.keyToCode('up') || event.keyCode === Keys.keyToCode('right') || event.keyCode === Keys.keyToCode('pageUp')) {
          v += this.step;
        } // decrease
        else if (event.keyCode === Keys.keyToCode('down') || event.keyCode === Keys.keyToCode('left') || event.keyCode === Keys.keyToCode('pageDown')) {
            v -= this.step;
          } // min
          else if (event.keyCode === Keys.keyToCode('home')) {
              v = this.min;
            } // max
            else if (event.keyCode === Keys.keyToCode('end')) {
                v = this.max;
              }

        this._updateValue(handle, v);
      }
      /**
       Finds the nearest handle based on X/Y coordinates
        @private
       */

    }, {
      key: "_findNearestHandle",
      value: function _findNearestHandle(mouseX, mouseY) {
        var closestDistance = Infinity;
        var closestHandle;

        function calculateDistance(elem, x, y) {
          var box = elem.getBoundingClientRect();
          var top = box.top + window.pageYOffset;
          var left = box.left + window.pageXOffset;
          return Math.floor(Math.sqrt(Math.pow(x - (left + box.width / 2), 2) + Math.pow(y - (top + box.height / 2), 2)));
        } // Find the nearest handle


        this._elements.handles.forEach(function (handle) {
          var distance = calculateDistance(handle, mouseX, mouseY);

          if (distance < closestDistance) {
            closestDistance = distance;
            closestHandle = handle;
          }
        });

        return closestHandle;
      }
      /**
       Moves the handles to right position
       based on the data in this._values
        @private
       */

    }, {
      key: "_moveHandles",
      value: function _moveHandles() {
        var _this2 = this;

        var calculatePercent = function calculatePercent(value) {
          return (value - _this2.min) / (_this2.max - _this2.min) * 100;
        };

        var labelValue = []; // Set the handle position as a percentage based on the stored values

        if (this._elements.handles.length === 1) {
          var handle = this._elements.handles[0];
          var percent = calculatePercent(this._values[0]);
          handle.style.left = "".concat(percent, "%");
          handle.previousElementSibling.style.width = "".concat(percent, "%");
          handle.nextElementSibling.style.width = "".concat(100 - percent, "%");
          labelValue.push(this._getLabel(this._values[0]));
        } else {
          var leftHandle = this._elements.handles[0];
          var leftPercent = calculatePercent(this._values[0]);
          leftHandle.style.left = "".concat(leftPercent, "%");
          var rightHandle = this._elements.handles[1];
          var rightPercent = calculatePercent(this._values[1]);
          rightHandle.style.left = "".concat(rightPercent, "%");
          leftHandle.previousElementSibling.style.width = "".concat(leftPercent, "%");
          leftHandle.nextElementSibling.style.left = "".concat(leftPercent, "%");
          var middlePercent = 100 - rightPercent;
          leftHandle.nextElementSibling.style.right = "".concat(middlePercent, "%");
          rightHandle.nextElementSibling.style.width = "".concat(middlePercent, "%");
          labelValue.push(this._getLabel(this._values[0]));
          labelValue.push(this._getLabel(this._values[1]));
        }

        this._elements.labelValue.textContent = labelValue.length > 1 ? labelValue.join(' - ') : labelValue[0];
      }
      /**
       Handles "onchange" events from the input.
       This is only neede in case of IE10 which doesn't handle "oninput event".
       In that case, the _onInputChangeHandler will be called from this handler.
        @private
       */

    }, {
      key: "_onInputChange",
      value: function _onInputChange(event) {
        if (typeof event.target.oninput === 'undefined') {
          this._onInputChangeHandler(event);
        }
      }
      /**
       Handles "oninput" events from the input.
       This makes ensures native inputs like
       - direct keyboard interaction with input[type=range]
       - accessibility features with input[type=range]
        Note we are not using the "_onInputChange" directly because Firefox
       will trigger the "change" event only after the focus has been lost.
        @private
       */

    }, {
      key: "_onInputChangeHandler",
      value: function _onInputChangeHandler(event) {
        // stops the current event
        event.stopPropagation();
        var handle = event.target.closest(".".concat(CLASSNAME_HANDLE));

        if (event.target === document.activeElement) {
          this._focus(event);
        }

        this._updateValue(handle, event.target.value, true);
      }
      /**
       Handles "focusin" event from  either an input or its handle.
        @private
       */

    }, {
      key: "_focus",
      value: function _focus(event) {
        // Depending on support for input[type=range],
        // the event.target could be either the handle or its child input.
        // Use closest() to locate the actual handle.
        event.target.closest(".".concat(CLASSNAME_HANDLE)).classList.add('is-focused');
        events.on('touchstart.Slider', this._onInteraction);
        events.on('mousedown.Slider', this._onInteraction);
      }
      /**
       Handles the blur
        @private
       */

    }, {
      key: "_onInteraction",
      value: function _onInteraction(event) {
        if (!this.contains(event.target)) {
          return;
        }

        event.target.blur();
      }
      /**
       Handles "focusout" event from  either an input or its handle.
        @private
       */

    }, {
      key: "_blur",
      value: function _blur(event) {
        // Depending on support for input[type=range],
        // the event.target could be either the handle or its child input.
        // Use closest() to locate the actual handle.
        event.target.closest(".".concat(CLASSNAME_HANDLE)).classList.remove('is-focused');
        events.off('touchstart.Slider');
        events.off('mousedown.Slider');
      }
      /**
       handles mousemove/touchmove after a succesful start on an handle
        @private
       */

    }, {
      key: "_handleDragging",
      value: function _handleDragging(event) {
        var p = this._getPoint(event);

        this._updateValue(this._currentHandle, this._getValueFromCoord(p.pageX, p.pageY));

        event.preventDefault();
      }
      /**
       updates the value for a handle
       @param handle
       @param val
       @param {Boolean} forceEvent
       Always triggers the event. If <code>true</code> the change event will be triggered without checking if the value really changed. This is useful if we are called from something like the _onInputChange where new value has already been updated AND we are certain the change event should be triggered without checking.
       @protected
       */

    }, {
      key: "_updateValue",
      value: function _updateValue(handle, val, forceEvent) {
        // this is prepared to work for multiple handles
        var idx = this._elements.handles.indexOf(handle);

        var values = this._values;
        values[idx] = val;
        var oldValues = this._values;
        this._values = values;
        var newValues = this._values;

        if (forceEvent || oldValues.join(':') !== newValues.join(':')) {
          this.trigger('change');
        }
      }
      /** @private */
      // eslint-disable-next-line no-unused-vars

    }, {
      key: "_getValueFromCoord",
      value: function _getValueFromCoord(posX, posY, restrictBounds) {
        var boundingClientRect = this.getBoundingClientRect();
        var elementWidth = boundingClientRect.width;
        var percent = (posX - boundingClientRect.left) / elementWidth; // if the bounds are restricted, as with _handleClick, we shouldn't change the value.

        if (restrictBounds && (percent < 0 || percent > 1)) {
          return NaN;
        }

        var rawValue = this.min + (this.max - this.min) * percent; // Snap value to nearest step

        return this._snapValueToStep(rawValue, this.min, this.max, this.step);
      }
      /** @private */

    }, {
      key: "_snapValueToStep",
      value: function _snapValueToStep(rawValue, min, max, step) {
        step = parseFloat(step);
        var remainder = (rawValue - min) % step;
        var floatString = step.toString().replace(/^(?:\d+)(?:\.(\d+))?$/g, '$1');
        var precision = floatString.length;
        var snappedValue;

        if (Math.abs(remainder) * 2 >= step) {
          snappedValue = rawValue - Math.abs(remainder) + step;
        } else {
          snappedValue = rawValue - remainder;
        }

        if (snappedValue < min) {
          snappedValue = min;
        } else if (snappedValue > max) {
          snappedValue = min + Math.floor((max - min) / step) * step;
        } // correct floating point behavior by rounding to step precision


        if (precision > 0) {
          snappedValue = parseFloat(snappedValue.toFixed(precision));
        }

        return snappedValue;
      }
      /**
       end operation of a dragging flow
       @private
       */

    }, {
      key: "_mouseUp",
      value: function _mouseUp() {
        if (this._currentHandle) {
          this._currentHandle.style.cursor = 'grab';

          this._currentHandle.classList.remove('is-dragged');
        }

        document.body.classList.remove('u-coral-closedHand');
        events.off('mousemove.Slider', this._draggingHandler);
        events.off('touchmove.Slider', this._draggingHandler);
        events.off('mouseup.Slider', this._mouseUpHandler);
        events.off('touchend.Slider', this._mouseUpHandler);
        events.off('touchcancel.Slider', this._mouseUpHandler);
        this._currentHandle = null;
        this._draggingHandler = null;
        this._mouseUpHandler = null;
      }
      /**
       Gets the label for a passed value.
        @param value
       @return {String|Number} the known label from the item or the value itself
       @protected
       */

    }, {
      key: "_getLabel",
      value: function _getLabel(value) {
        var items = this.items.getAll();
        var item;

        for (var i = 0; i < items.length; i++) {
          if (transform.number(items[i].getAttribute('value')) === transform.number(value)) {
            item = items[i];
            break;
          }
        } // Use the innerHTML of the item if one was found


        return item ? item.innerHTML : value;
      } // To be overridden by RangedSlider

    }, {
      key: "_getTemplate",
      value: function _getTemplate() {
        return template$q;
      }
    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(ExtensibleSlider.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$I); // Default reflected attributes

        if (!this._min) {
          this.min = this.min;
        }

        if (!this._max) {
          this.max = this.max;
        }

        if (!this._step) {
          this.step = this.step;
        }

        if (!this._orientation) {
          this.orientation = orientation$2.HORIZONTAL;
        } // A11y


        this.setAttribute('role', 'presentation'); // Support cloneNode

        var template = this.querySelectorAll('._coral-Slider-labelContainer, ._coral-Slider-controls');

        for (var i = 0; i < template.length; i++) {
          template[i].remove();
        } // Render the main template


        var frag = document.createDocumentFragment();
        frag.appendChild(this._elements.label);
        frag.appendChild(this._elements.controls);
        var content = this._elements.content; // If no default content zone was provided, move everything there

        if (!content.parentNode) {
          // Process remaining elements as necessary
          while (this.firstChild) {
            var child = this.firstChild;

            if (child.nodeName === 'CORAL-SLIDER-ITEM') {
              // Add items to the fragment
              frag.appendChild(child);
            } else {
              // Add anything else to the content
              content.appendChild(child);
            }
          }
        } // Add the frag to the component


        this.appendChild(frag); // Assign the content zone so the insert function will be called

        this.content = content; // Defaults

        this._moveHandles();
      }
    }, {
      key: "content",
      get: function get() {
        return this._getContentZone(this._elements.content);
      },
      set: function set(value) {
        this._setContentZone('content', value, {
          handle: 'content',
          tagName: 'coral-slider-content',
          insert: function insert(content) {
            this._elements.labelContent.appendChild(content);
          }
        });
      }
      /**
       The Collection Interface that allows interacting with the items that the component contains.
        @type {Collection}
       @readonly
       */

    }, {
      key: "items",
      get: function get() {
        // just init on demand
        if (!this._items) {
          this._items = new Collection$1({
            host: this,
            itemTagName: 'coral-slider-item'
          });
        }

        return this._items;
      }
      /**
       Increment value of one step.
        @type {Number}
       @default 1
       @htmlattribute step
       @htmlattributereflected
       */

    }, {
      key: "step",
      get: function get() {
        return this._getValueOf('step', 1);
      },
      set: function set(value) {
        var _this3 = this;

        value = transform.number(value);

        if (value > 0) {
          this._step = value;

          this._reflectAttribute('step', this._step);

          this._elements.inputs.forEach(function (input) {
            input.setAttribute('step', _this3._step);
          });
        }
      }
      /**
       The minimum value.
        @type {Number}
       @default 1
       @htmlattribute min
       @htmlattributereflected
       */

    }, {
      key: "min",
      get: function get() {
        return this._getValueOf('min', 1);
      },
      set: function set(value) {
        var _this4 = this;

        this._min = transform.number(value);

        this._reflectAttribute('min', this._min);

        this._elements.inputs.forEach(function (input) {
          input.setAttribute('min', _this4._min);
        });
      }
      /**
       The maximum value.
        @type {Number}
       @default 100
       @htmlattribute max
       @htmlattributereflected
       */

    }, {
      key: "max",
      get: function get() {
        return this._getValueOf('max', 100);
      },
      set: function set(value) {
        var _this5 = this;

        this._max = transform.number(value);

        this._reflectAttribute('max', this._max);

        this._elements.inputs.forEach(function (input) {
          input.setAttribute('max', _this5._max);
        });
      }
      /**
       @ignore
        Not supported anymore. Use "showValue" instead.
       */

    }, {
      key: "tooltips",
      get: function get() {
        return this.showValue;
      },
      set: function set(value) {
        this.showValue = value;
      }
      /**
       Display the slider value.
        @type {Boolean}
       @default false
       @htmlattribute showvalue
       @htmlattributereflected
       */

    }, {
      key: "showValue",
      get: function get() {
        return this._showValue || false;
      },
      set: function set(value) {
        this._showValue = transform.booleanAttr(value);

        this._reflectAttribute('showvalue', this._showValue);

        this._elements.labelValue.hidden = !this._showValue;
      }
      /**
       Orientation of the slider. See {@link SliderOrientationEnum}.
        @type {String}
       @default SliderOrientationEnum.HORIZONTAL
       @htmlattribute orientation
       @htmlattributereflected
       */

    }, {
      key: "orientation",
      get: function get() {
        return this._orientation || orientation$2.HORIZONTAL;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        this._orientation = validate.enumeration(orientation$2)(value) && value || orientation$2.HORIZONTAL;

        this._reflectAttribute('orientation', this._orientation);
      }
      /**
       Fill a value or value range using a highlight color.
        @type {Boolean}
       @default false
       @htmlattribute filled
       @htmlattributereflected
       */

    }, {
      key: "filled",
      get: function get() {
        return this._filled || false;
      },
      set: function set(value) {
        this._filled = transform.booleanAttr(value);

        this._reflectAttribute('filled', this._filled);

        this.classList.toggle("".concat(CLASSNAME$I, "--filled"), this._filled);
      }
      /**
       The value returned as a Number. Value is <code>NaN</code> if conversion to Number is not possible.
        @type {Number}
       @default NaN
       */

    }, {
      key: "valueAsNumber",
      get: function get() {
        return parseFloat(this.value);
      },
      set: function set(value) {
        this.value = transform.float(value);
      }
      /**
       Name used to submit the data in a form.
       @type {String}
       @default ""
       @htmlattribute name
       @htmlattributereflected
       */

    }, {
      key: "name",
      get: function get() {
        return this._elements.inputs[0].name;
      },
      set: function set(value) {
        var _this6 = this;

        this._reflectAttribute('name', value);

        this._elements.inputs.forEach(function (input) {
          input.name = _this6.getAttribute('name');
        });
      }
      /**
       This field's current value.
       @type {String}
       @default ""
       @htmlattribute value
       */

    }, {
      key: "value",
      get: function get() {
        return this._elements.inputs[0].value;
      },
      set: function set(value) {
        value = transform.number(value); // setting the value should always set the first value

        if (this._elements.handles.length === 1) {
          var input = this._elements.inputs[0];
          value = this._snapValueToStep(value, this.min, this.max, this.step);
          input.value = value;

          if (input.value) {
            input.setAttribute('aria-valuenow', value);
            input.setAttribute('aria-valuetext', this._getLabel(value));
          } else {
            input.removeAttribute('aria-valuenow');
            input.removeAttribute('aria-valuetext');
          }

          this._moveHandles(); // in order to keep the reset value in sync, we need to handle the "value" attribute of the inner input


          var valueAttribute = this.getAttribute('value');
          input[valueAttribute ? 'setAttribute' : 'removeAttribute']('value', valueAttribute);
        }
      }
      /**
       Whether this field is disabled or not.
       @type {Boolean}
       @default false
       @htmlattribute disabled
       @htmlattributereflected
       */

    }, {
      key: "disabled",
      get: function get() {
        return this._disabled || false;
      },
      set: function set(value) {
        var _this7 = this;

        this._disabled = transform.booleanAttr(value);

        this._reflectAttribute('disabled', this._disabled);

        this.classList.toggle('is-disabled', this._disabled);
        this[this._disabled ? 'setAttribute' : 'removeAttribute']('aria-disabled', this._disabled);

        this._elements.inputs.forEach(function (input) {
          input.disabled = _this7._disabled;
        });
      }
      /**
       Whether this field is required or not.
       @type {Boolean}
       @default false
       @htmlattribute required
       @htmlattributereflected
       */

    }, {
      key: "required",
      get: function get() {
        return this._required || false;
      },
      set: function set(value) {
        var _this8 = this;

        this._required = transform.booleanAttr(value);

        this._reflectAttribute('required', this._required);

        this._elements.inputs.forEach(function (input) {
          input.required = _this8._required;
        });
      }
      /**
       Whether this field is readOnly or not. Indicating that the user cannot modify the value of the control.
       @type {Boolean}
       @default false
       @htmlattribute readonly
       @htmlattributereflected
       */

    }, {
      key: "readOnly",
      get: function get() {
        return this._readOnly || false;
      },
      set: function set(value) {
        var _this9 = this;

        this._readOnly = transform.booleanAttr(value);

        this._reflectAttribute('readonly', this._readOnly);

        this._elements.inputs.forEach(function (input) {
          input.readOnly = _this9._readOnly;
        });
      }
      /**
       Inherited from {@link BaseFormField#labelledBy}.
       */

    }, {
      key: "labelledBy",
      get: function get() {
        return _get(_getPrototypeOf(ExtensibleSlider.prototype), "labelledBy", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(ExtensibleSlider.prototype), "labelledBy", value, this, true);

        if (this._elements.inputs.length > 1) {
          var input = this._elements.inputs[1];
          var labelledBy = this.labelledBy;
          input[labelledBy ? 'setAttribute' : 'removeAttribute']('aria-labelledby', labelledBy);
        }
      }
      /** @private */

    }, {
      key: "_values",
      get: function get() {
        return this._elements.inputs.map(function (input) {
          return String(parseInt(input.value, 10));
        });
      },
      set: function set(values) {
        var _this10 = this;

        if (values && values.length === this._elements.handles.length) {
          this._elements.inputs.forEach(function (input, i) {
            var value = values[i] = _this10._snapValueToStep(values[i], _this10.min, _this10.max, _this10.step);

            input.value = value;

            if (input.value) {
              input.setAttribute('aria-valuenow', value);
              input.setAttribute('aria-valuetext', _this10._getLabel(value));
            } else {
              input.removeAttribute('aria-valuenow');
              input.removeAttribute('aria-valuetext');
            }
          });

          this._moveHandles();
        }
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-slider-content': 'content'
        };
      }
      /**
       Returns {@link Slider} orientation options.
        @return {SliderOrientationEnum}
       */

    }], [{
      key: "orientation",
      get: function get() {
        return orientation$2;
      }
    }, {
      key: "_attributePropertyMap",
      get: function get() {
        return commons.extend(_get(_getPrototypeOf(ExtensibleSlider), "_attributePropertyMap", this), {
          showvalue: 'showValue'
        });
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(ExtensibleSlider), "observedAttributes", this).concat(['step', 'min', 'max', 'tooltips', 'showvalue', 'orientation', 'filled']);
      }
    }]);

    return ExtensibleSlider;
  }(BaseFormField(BaseComponent(HTMLElement)));

  var Slider = Decorator(ExtensibleSlider);

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Slider.Content
   @classdesc Slider's content component
   @htmltag coral-slider-content
   @return {HTMLElement}
   */
  var SliderContent = (function () {
    return document.createElement('coral-slider-content');
  });

  var CLASSNAME$J = '_coral-Slider-item';
  /**
   @class Coral.Slider.Item
   @classdesc The Slider item
   @htmltag coral-slider-item
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var SliderItem = Decorator( /*#__PURE__*/function (_BaseComponent) {
    _inherits(_class, _BaseComponent);

    var _super = _createSuper(_class);

    function _class() {
      _classCallCheck(this, _class);

      return _super.apply(this, arguments);
    }

    _createClass(_class, [{
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$J);
      }
    }, {
      key: "value",

      /**
       The slider's item value.
       This should contain a number formatted as a string (e.g.: "10") or an empty string.
        @type {String}
       @default ""
       @htmlattribute value
       @htmlattributereflected
       */
      get: function get() {
        return this.getAttribute('value');
      },
      set: function set(value) {
        this._reflectAttribute('value', transform.string(value));
      } // @compat

    }, {
      key: "content",
      get: function get() {
        return this;
      },
      set: function set(value) {
        if (value instanceof HTMLElement) {
          /** @ignore */
          this.innerHTML = value.innerHTML;
        }
      }
    }]);

    return _class;
  }(BaseComponent(HTMLElement)));

  var template$r = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var data = data_0 = typeof data_0 === "undefined" ? {} : data_0;
    data = data_0;
    data.uidMin = data.commons.getUID();
    data.uidMax = data.commons.getUID();
    data_0 = data;
    var el1 = document.createTextNode("\n\n");
    frag.appendChild(el1);
    var el2 = this["label"] = document.createElement("div");
    el2.className += " _coral-Slider-labelContainer";
    el2.setAttribute("handle", "label");
    var el3 = document.createTextNode("\n  ");
    el2.appendChild(el3);
    var el4 = this["labelContent"] = document.createElement("label");
    el4.className += " _coral-Slider-label";
    el4.setAttribute("handle", "labelContent");
    el2.appendChild(el4);
    var el5 = document.createTextNode("\n  ");
    el2.appendChild(el5);
    var el6 = this["labelValue"] = document.createElement("label");
    el6.className += " _coral-Slider-value";
    el6.setAttribute("handle", "labelValue");
    el6.setAttribute("hidden", "");
    el2.appendChild(el6);
    var el7 = document.createTextNode("\n");
    el2.appendChild(el7);
    frag.appendChild(el2);
    var el8 = document.createTextNode("\n");
    frag.appendChild(el8);
    var el9 = this["controls"] = document.createElement("div");
    el9.className += " _coral-Slider-controls";
    el9.setAttribute("role", "presentation");
    el9.setAttribute("handle", "controls");
    var el10 = document.createTextNode("\n  ");
    el9.appendChild(el10);
    var el11 = document.createElement("div");
    el11.className += " _coral-Slider-track";
    el9.appendChild(el11);
    var el12 = document.createTextNode("\n  ");
    el9.appendChild(el12);
    var el13 = this["leftHandle"] = document.createElement("div");
    el13.className += " _coral-Slider-handle";
    el13.setAttribute("handle", "leftHandle");
    var el14 = document.createTextNode("\n    ");
    el13.appendChild(el14);
    var el15 = this["leftLabel"] = document.createElement("label");
    el15.setAttribute("handle", "leftLabel");
    el15.className += " u-coral-screenReaderOnly";
    el15.id = data_0["uidMin"] + "-label";
    el15.setAttribute("for", data_0["uidMin"]);
    el15.setAttribute("aria-hidden", "true");
    el15.textContent = "Minimum";
    el13.appendChild(el15);
    var el16 = document.createTextNode("\n    ");
    el13.appendChild(el16);
    var el17 = this["leftInput"] = document.createElement("input");
    el17.setAttribute("handle", "leftInput");
    el17.setAttribute("value", "1");
    el17.setAttribute("type", "range");
    el17.className += " _coral-Slider-input";
    el17.id = data_0["uidMin"];
    el13.appendChild(el17);
    var el18 = document.createTextNode("\n  ");
    el13.appendChild(el18);
    el9.appendChild(el13);
    var el19 = document.createTextNode("\n  ");
    el9.appendChild(el19);
    var el20 = document.createElement("div");
    el20.className += " _coral-Slider-track";
    el9.appendChild(el20);
    var el21 = document.createTextNode("\n  ");
    el9.appendChild(el21);
    var el22 = this["rightHandle"] = document.createElement("div");
    el22.className += " _coral-Slider-handle";
    el22.setAttribute("handle", "rightHandle");
    var el23 = document.createTextNode("\n    ");
    el22.appendChild(el23);
    var el24 = this["rightLabel"] = document.createElement("label");
    el24.setAttribute("handle", "rightLabel");
    el24.className += " u-coral-screenReaderOnly";
    el24.id = data_0["uidMax"] + "-label";
    el24.setAttribute("for", data_0["uidMax"]);
    el24.setAttribute("aria-hidden", "true");
    el24.textContent = "Maximum";
    el22.appendChild(el24);
    var el25 = document.createTextNode("\n    ");
    el22.appendChild(el25);
    var el26 = this["rightInput"] = document.createElement("input");
    el26.setAttribute("handle", "rightInput");
    el26.setAttribute("value", "100");
    el26.setAttribute("type", "range");
    el26.className += " _coral-Slider-input";
    el26.id = data_0["uidMax"];
    el22.appendChild(el26);
    var el27 = document.createTextNode("\n  ");
    el22.appendChild(el27);
    el9.appendChild(el22);
    var el28 = document.createTextNode("\n  ");
    el9.appendChild(el28);
    var el29 = document.createElement("div");
    el29.className += " _coral-Slider-track";
    el9.appendChild(el29);
    var el30 = document.createTextNode("\n");
    el9.appendChild(el30);
    frag.appendChild(el9);
    var el31 = document.createTextNode("\n");
    frag.appendChild(el31);
    return frag;
  };

  /**
   @class Coral.RangedSlider
   @classdesc A Ranged Slider
   @htmltag coral-rangedslider
   @extends {Slider}
   */

  var RangedSlider = Decorator( /*#__PURE__*/function (_ExtensibleSlider) {
    _inherits(_class, _ExtensibleSlider);

    var _super = _createSuper(_class);

    function _class() {
      _classCallCheck(this, _class);

      return _super.apply(this, arguments);
    }

    _createClass(_class, [{
      key: "_getHighestValue",

      /** @private */
      value: function _getHighestValue() {
        return Math.max.apply(null, this.values);
      }
      /** @private */

    }, {
      key: "_getLowestValue",
      value: function _getLowestValue() {
        return Math.min.apply(null, this.values);
      }
      /** @override */

    }, {
      key: "_updateValue",
      value: function _updateValue(handle, val) {
        var idx = this._elements.handles.indexOf(handle);

        if (idx === 0) {
          if (val > parseFloat(this.values[1])) {
            val = this.values[1];
          }

          this._elements.rightInput.min = val;

          this._elements.rightHandle.setAttribute('aria-valuemin', val);
        } else {
          if (val < parseFloat(this.values[0])) {
            val = this.values[0];
          }

          this._elements.leftInput.max = val;

          this._elements.leftHandle.setAttribute('aria-valuemax', val);
        }

        var resValue = [this.values[0], this.values[1]];
        resValue[idx] = val;
        var oldValues = this.values;
        this.values = resValue;
        var newValues = this.values;

        if (oldValues.join(':') !== newValues.join(':')) {
          this.trigger('change');
        }
      }
      /** @override */

    }, {
      key: "_getTemplate",
      value: function _getTemplate() {
        return template$r;
      }
      /**
       Inherited from {@link BaseFormField#clear}.
       */

    }, {
      key: "clear",
      value: function clear() {
        this.startValue = this.min;
        this.endValue = this.max;
      }
      /**
       Inherited from {@link BaseFormField#reset}.
       */

    }, {
      key: "reset",
      value: function reset() {
        // since the 'value' property is not reflected, form components use it to restore the initial value. When a
        // component has support for values, this method needs to be overwritten
        var initialStartValue = this.getAttribute('startvalue') || this.getAttribute('value');
        var initialEndValue = this.getAttribute('endvalue');
        this.startValue = transform.string(initialStartValue);
        this.endValue = transform.string(initialEndValue);
      }
    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add('_coral-Slider--range'); // Set filled attribute by default

        this.setAttribute('filled', '');
      }
    }, {
      key: "filled",

      /**
       Ranged sliders are always filled.
        @type {Boolean}
       @default true
       @htmlattribute filled
       @htmlattributereflected
       */
      get: function get() {
        return true;
      },
      set: function set(value) {
        if (!transform.booleanAttr(value)) {
          commons._log('warn', 'Coral.RangedSlider: filled can not be set to false.');
        }
      }
      /**
       This field's current value.
       @type {String}
       @default ""
       @htmlattribute value
       */

    }, {
      key: "value",
      get: function get() {
        return this.startValue;
      },
      set: function set(value) {
        this.startValue = value;
      }
      /**
       The starting value of the range.
        @type {String}
       @default '1'
       @emits {change}
       @htmlattribute startValue
       */

    }, {
      key: "startValue",
      get: function get() {
        return this.values[0] || '1';
      },
      set: function set(value) {
        // Snap value to step
        value = String(this._snapValueToStep(transform.number(value), this.min, this.max, this.step));
        var values = this.values;
        values[0] = value;
        this.values = values; // in order to keep the reset value in sync, we need to handle the "startvalue" attribute of the inner input

        var input = this._elements.inputs[0];
        var valueAttribute = this.getAttribute('startvalue') || this.getAttribute('value');
        input[valueAttribute ? 'setAttribute' : 'removeAttribute']('value', valueAttribute);
      }
      /**
       The ending value of the range.
        @type {String}
       @default '100'
       @emits {change}
       @htmlattribute endValue
       */

    }, {
      key: "endValue",
      get: function get() {
        return this.values[1] || '100';
      },
      set: function set(value) {
        // Snap value to step
        value = String(this._snapValueToStep(transform.number(value), this.min, this.max, this.step));
        var values = this.values;
        values[1] = value;
        this.values = values; // in order to keep the reset value in sync, we need to handle the "endvalue" attribute of the inner input

        var input = this._elements.inputs[1];
        var valueAttribute = this.getAttribute('endvalue');
        input[valueAttribute ? 'setAttribute' : 'removeAttribute']('value', valueAttribute);
      }
      /**
       The current values of the ranged slider.
        @type {Array.<String>}
       @default [{@link Coral.RangedSlider#startValue},{@link Coral.RangedSlider#endValue}]
       @emits {change}
       */

    }, {
      key: "values",
      get: function get() {
        return this._values;
      },
      set: function set(values) {
        this._values = values;
      }
    }], [{
      key: "_attributePropertyMap",
      get: function get() {
        return commons.extend(_get(_getPrototypeOf(_class), "_attributePropertyMap", this), {
          startvalue: 'startValue',
          endvalue: 'endValue'
        });
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['startvalue', 'endvalue']);
      }
    }]);

    return _class;
  }(ExtensibleSlider));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons._define('coral-slider-item', SliderItem);

  commons._define('coral-rangedslider', RangedSlider);

  commons._define('coral-slider', Slider);

  Slider.Content = SliderContent;
  Slider.Item = SliderItem;

  var template$s = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["label"] = document.createElement("div");
    el0.className += " _coral-Slider-labelContainer";
    el0.setAttribute("handle", "label");
    var el1 = document.createTextNode("\n  ");
    el0.appendChild(el1);
    var el2 = this["labelContent"] = document.createElement("label");
    el2.className += " _coral-Slider-label";
    el2.setAttribute("handle", "labelContent");
    el0.appendChild(el2);
    var el3 = document.createTextNode("\n  ");
    el0.appendChild(el3);
    var el4 = this["labelValue"] = document.createElement("label");
    el4.className += " _coral-Slider-value";
    el4.setAttribute("handle", "labelValue");
    el4.setAttribute("hidden", "");
    el0.appendChild(el4);
    var el5 = document.createTextNode("\n");
    el0.appendChild(el5);
    frag.appendChild(el0);
    var el6 = document.createTextNode("\n");
    frag.appendChild(el6);
    var el7 = this["controls"] = document.createElement("div");
    el7.className += " _coral-Slider-controls u-coral-noMargin";
    el7.setAttribute("role", "presentation");
    el7.setAttribute("handle", "controls");
    var el8 = document.createTextNode("\n  ");
    el7.appendChild(el8);
    var el9 = this["bar"] = document.createElement("div");
    el9.className += " _coral-Slider-track _coral-ColorInput-sliderBar u-coral-clearFix";
    el9.setAttribute("handle", "bar");
    el7.appendChild(el9);
    var el10 = document.createTextNode("\n  ");
    el7.appendChild(el10);
    var el11 = this["leftHandle"] = document.createElement("div");
    el11.className += " _coral-Slider-handle _coral-ColorInput-sliderHandle";
    el11.setAttribute("handle", "leftHandle");
    var el12 = document.createTextNode("\n    ");
    el11.appendChild(el12);
    var el13 = this["leftInput"] = document.createElement("input");
    el13.setAttribute("aria-orientation", "horizontal");
    el13.setAttribute("handle", "leftInput");
    el13.setAttribute("value", "1");
    el13.setAttribute("type", "range");
    el13.className += " _coral-Slider-input";
    el11.appendChild(el13);
    var el14 = document.createTextNode("\n  ");
    el11.appendChild(el14);
    el7.appendChild(el11);
    var el15 = document.createTextNode("\n");
    el7.appendChild(el15);
    frag.appendChild(el7);
    var el16 = document.createTextNode("\n");
    frag.appendChild(el16);
    return frag;
  };

  var CLASSNAMES$1 = ['_coral-ColorInput-slider', '_coral-Slider--color'];
  /**
   @class Coral.ColorInput.Slider
   @classdesc A ColorInput Slider component
   @htmltag coral-colorinput-slider
   @extends {Slider}
   */

  var ColorInputSlider = Decorator( /*#__PURE__*/function (_ExtensibleSlider) {
    _inherits(_class, _ExtensibleSlider);

    var _super = _createSuper(_class);

    function _class() {
      _classCallCheck(this, _class);

      return _super.apply(this, arguments);
    }

    _createClass(_class, [{
      key: "_moveHandles",
      value: function _moveHandles() {
        var _this = this;

        var calculatePercent = function calculatePercent(value) {
          return (value - _this.min) / (_this.max - _this.min) * 100;
        };

        var labelValue = []; // Set the handle position as a percentage based on the stored values

        this._elements.handles.forEach(function (handle, index) {
          var percent = calculatePercent(_this._values[index]);
          handle.style.left = "".concat(percent, "%");
          labelValue.push(_this._getLabel(_this._values[index]));
        });

        this._elements.labelValue.textContent = labelValue.length > 1 ? labelValue.join(' - ') : labelValue[0];
      }
      /** @override */

    }, {
      key: "_getTemplate",
      value: function _getTemplate() {
        return template$s;
      }
      /** @ignore */

    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        var _this$classList;

        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        (_this$classList = this.classList).add.apply(_this$classList, CLASSNAMES$1);
      }
    }, {
      key: "gradient",

      /**
       The gradient shown as slider background as space separated values (at least 2 values needed).
       e.g: #ff0000 #ffff00 #00ff00 #00ffff #0000ff #ff00ff #ff0000
        @type {String}
       @default ""
       @htmlattribute gradient
       */
      get: function get() {
        return this._gradient || '';
      },
      set: function set(value) {
        this._gradient = transform.string(value);
        var bar = this._elements.bar;
        var barStyle = bar.style;
        var stops = this.gradient.split(' ');
        var amountStops = stops.length; // remove old gradients

        barStyle.backgroundImage = 'none';
        barStyle.filter = '';

        if (amountStops < 2) {
          return;
        }

        var partialGradientStr = '';

        for (var i = 0; i < amountStops; i++) {
          partialGradientStr += ", ".concat(stops[i], " ").concat(Math.abs(i * 100 / (amountStops - 1)), "%");
        }

        barStyle.backgroundImage = "-moz-linear-gradient(to right".concat(partialGradientStr, ")");
        barStyle.backgroundImage = "-ms-linear-gradient(to right".concat(partialGradientStr, ")");
        barStyle.backgroundImage = "-o-linear-gradient(to right".concat(partialGradientStr, ")");
        barStyle.backgroundImage = "-webkit-linear-gradient(to right".concat(partialGradientStr, ")");
        barStyle.backgroundImage = "linear-gradient(to right".concat(partialGradientStr, ")");
        barStyle.filter = "progid:DXImageTransform.Microsoft.gradient(startColorstr='".concat(stops[0], "', endColorstr='").concat(stops[1], "', gradientType=1)");
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['gradient']);
      }
    }]);

    return _class;
  }(ExtensibleSlider));

  var template$t = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var data = data_0 = typeof data_0 === "undefined" ? {} : data_0;
    data = data_0;
    var uid = data.commons.getUID();
    data_0 = data;
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    var el2 = this["propertiesSubview"] = document.createElement("div");
    el2.className += " _coral-ColorInput-propertiesSubview";
    el2.setAttribute("handle", "propertiesSubview");
    el2.setAttribute("role", "group");
    var el3 = document.createTextNode("\n  ");
    el2.appendChild(el3);
    var el4 = document.createElement("div");
    el4.className += " _coral-ColorInput-previewView";
    el4.setAttribute("role", "presentation");
    var el5 = document.createTextNode("\n    ");
    el4.appendChild(el5);
    var el6 = document.createElement("div");
    el6.className += " _coral-ColorInput-preview-container";
    el6.setAttribute("role", "presentation");
    var el7 = document.createTextNode("\n      ");
    el6.appendChild(el7);
    var el8 = this["colorPreview2"] = document.createElement("button", "coral-button");
    el8.setAttribute("is", "coral-button");
    el8.setAttribute("handle", "colorPreview2");
    el8.setAttribute("variant", "action");
    el8.className += " _coral-ColorInput-preview";
    el8.setAttribute("type", "button");
    el8.setAttribute("aria-pressed", "false");
    el6.appendChild(el8);
    var el9 = document.createTextNode("\n    ");
    el6.appendChild(el9);
    el4.appendChild(el6);
    var el10 = document.createTextNode("\n    ");
    el4.appendChild(el10);
    var el11 = document.createElement("div");
    el11.className += " _coral-ColorInput-editHex";
    el11.setAttribute("role", "presentation");
    var el12 = document.createTextNode("\n      ");
    el11.appendChild(el12);
    var el13 = document.createElement("label");
    el13.className += " _coral-ColorInput-editHex-label";
    var el14 = document.createTextNode("\n        ");
    el13.appendChild(el14);
    var el15 = document.createElement("span");
    el15.textContent = "#";
    el13.appendChild(el15);
    var el16 = document.createTextNode("\n        ");
    el13.appendChild(el16);
    var el17 = this["hexInput"] = document.createElement("input", "coral-textfield");
    el17.className += " _coral-ColorInput-editHex-input";
    el17.setAttribute("type", "text");
    el17.setAttribute("handle", "hexInput");
    el17.setAttribute("is", "coral-textfield");
    el17.setAttribute("aria-label", data_0["i18n"]["get"]('HEX'));
    el17.setAttribute("placeholder", data_0["i18n"]["get"]('HEX'));
    el17.setAttribute("maxlength", "6");
    el17.setAttribute("value", "");
    el17.setAttribute("variant", "quiet");
    el13.appendChild(el17);
    var el18 = document.createTextNode("\n      ");
    el13.appendChild(el18);
    el11.appendChild(el13);
    var el19 = document.createTextNode("\n    ");
    el11.appendChild(el19);
    el4.appendChild(el11);
    var el20 = document.createTextNode("\n  ");
    el4.appendChild(el20);
    el2.appendChild(el4);
    var el21 = document.createTextNode("\n  ");
    el2.appendChild(el21);
    var el22 = document.createElement("div");
    el22.className += " _coral-ColorInput-rgbaView _coral-ColorInput-editRgba";
    el22.setAttribute("role", "presentation");
    var el23 = document.createTextNode("\n    ");
    el22.appendChild(el23);
    var el24 = document.createElement("div");
    el24.setAttribute("role", "group");
    el24.className += " _coral-ColorInput-editRgba-group";
    var el25 = document.createTextNode("\n      ");
    el24.appendChild(el25);
    var el26 = document.createElement("label");
    el26.className += " _coral-ColorInput-editRgba-group-label";
    el26.id = uid + "-r-label";
    el26.setAttribute("for", uid + "-r");
    el26.textContent = data_0["i18n"]["get"]('R');
    el24.appendChild(el26);
    var el27 = document.createTextNode("\n      ");
    el24.appendChild(el27);
    var el28 = this["redSlider"] = document.createElement("coral-colorinput-slider");
    el28.setAttribute("handle", "redSlider");
    el28.setAttribute("min", "0");
    el28.setAttribute("max", "255");
    el28.setAttribute("value", "0");
    el28.setAttribute("gradient", "#000000 #FF0000");
    el28.setAttribute("labelledby", uid + "-r-label");
    el24.appendChild(el28);
    var el29 = document.createTextNode("\n      ");
    el24.appendChild(el29);
    var el30 = this["redInput"] = document.createElement("input", "coral-textfield");
    el30.className += " _coral-ColorInput-editRgba-group-input";
    el30.id = uid + "-r";
    el30.setAttribute("handle", "redInput");
    el30.setAttribute("is", "coral-textfield");
    el30.setAttribute("type", "number");
    el30.setAttribute("placeholder", data_0["i18n"]["get"]('R'));
    el30.setAttribute("maxlength", "3");
    el30.setAttribute("value", "");
    el30.setAttribute("variant", "quiet");
    el24.appendChild(el30);
    var el31 = document.createTextNode("\n    ");
    el24.appendChild(el31);
    el22.appendChild(el24);
    var el32 = document.createTextNode("\n    ");
    el22.appendChild(el32);
    var el33 = document.createElement("div");
    el33.setAttribute("role", "group");
    el33.className += " _coral-ColorInput-editRgba-group";
    var el34 = document.createTextNode("\n      ");
    el33.appendChild(el34);
    var el35 = document.createElement("label");
    el35.className += " _coral-ColorInput-editRgba-group-label";
    el35.id = uid + "-g-label";
    el35.setAttribute("for", uid + "-g");
    el35.textContent = data_0["i18n"]["get"]('G');
    el33.appendChild(el35);
    var el36 = document.createTextNode("\n      ");
    el33.appendChild(el36);
    var el37 = this["greenSlider"] = document.createElement("coral-colorinput-slider");
    el37.setAttribute("handle", "greenSlider");
    el37.setAttribute("min", "0");
    el37.setAttribute("max", "255");
    el37.setAttribute("value", "0");
    el37.setAttribute("gradient", "#000000 #00FF00");
    el37.setAttribute("labelledby", uid + "-g-label");
    el33.appendChild(el37);
    var el38 = document.createTextNode("\n      ");
    el33.appendChild(el38);
    var el39 = this["greenInput"] = document.createElement("input", "coral-textfield");
    el39.className += " _coral-ColorInput-editRgba-group-input";
    el39.id = uid + "-g";
    el39.setAttribute("handle", "greenInput");
    el39.setAttribute("is", "coral-textfield");
    el39.setAttribute("type", "number");
    el39.setAttribute("placeholder", data_0["i18n"]["get"]('G'));
    el39.setAttribute("maxlength", "3");
    el39.setAttribute("value", "");
    el39.setAttribute("variant", "quiet");
    el33.appendChild(el39);
    var el40 = document.createTextNode("\n    ");
    el33.appendChild(el40);
    el22.appendChild(el33);
    var el41 = document.createTextNode("\n    ");
    el22.appendChild(el41);
    var el42 = document.createElement("div");
    el42.setAttribute("role", "group");
    el42.className += " _coral-ColorInput-editRgba-group";
    var el43 = document.createTextNode("\n      ");
    el42.appendChild(el43);
    var el44 = document.createElement("label");
    el44.className += " _coral-ColorInput-editRgba-group-label";
    el44.id = uid + "-b-label";
    el44.setAttribute("for", uid + "-b");
    el44.textContent = data_0["i18n"]["get"]('B');
    el42.appendChild(el44);
    var el45 = document.createTextNode("\n      ");
    el42.appendChild(el45);
    var el46 = this["blueSlider"] = document.createElement("coral-colorinput-slider");
    el46.setAttribute("handle", "blueSlider");
    el46.setAttribute("min", "0");
    el46.setAttribute("max", "255");
    el46.setAttribute("value", "0");
    el46.setAttribute("gradient", "#000000 #0000FF");
    el46.setAttribute("labelledby", uid + "-b-label");
    el42.appendChild(el46);
    var el47 = document.createTextNode("\n      ");
    el42.appendChild(el47);
    var el48 = this["blueInput"] = document.createElement("input", "coral-textfield");
    el48.className += " _coral-ColorInput-editRgba-group-input";
    el48.id = uid + "-b";
    el48.setAttribute("handle", "blueInput");
    el48.setAttribute("is", "coral-textfield");
    el48.setAttribute("type", "number");
    el48.setAttribute("placeholder", data_0["i18n"]["get"]('B'));
    el48.setAttribute("maxlength", "3");
    el48.setAttribute("value", "");
    el48.setAttribute("variant", "quiet");
    el42.appendChild(el48);
    var el49 = document.createTextNode("\n    ");
    el42.appendChild(el49);
    el22.appendChild(el42);
    var el50 = document.createTextNode("\n    ");
    el22.appendChild(el50);
    var el51 = document.createElement("div");
    el51.setAttribute("role", "group");
    el51.className += " _coral-ColorInput-editRgba-group";
    var el52 = document.createTextNode("\n      ");
    el51.appendChild(el52);
    var el53 = document.createElement("label");
    el53.className += " _coral-ColorInput-editRgba-group-label";
    el53.id = uid + "-a-label";
    el53.setAttribute("for", uid + "-a");
    el53.textContent = data_0["i18n"]["get"]('A');
    el51.appendChild(el53);
    var el54 = document.createTextNode("\n      ");
    el51.appendChild(el54);
    var el55 = this["alphaSlider"] = document.createElement("coral-colorinput-slider");
    el55.setAttribute("handle", "alphaSlider");
    el55.setAttribute("min", "0");
    el55.setAttribute("max", "100");
    el55.setAttribute("value", "100");
    el55.setAttribute("gradient", "rgba(255,255,255,0) rgba(255,255,255,1)");
    el55.setAttribute("labelledby", uid + "-a-label");
    el51.appendChild(el55);
    var el56 = document.createTextNode("\n      ");
    el51.appendChild(el56);
    var el57 = this["alphaInput"] = document.createElement("input", "coral-textfield");
    el57.className += " _coral-ColorInput-editRgba-group-input";
    el57.id = uid + "-a";
    el57.setAttribute("handle", "alphaInput");
    el57.setAttribute("is", "coral-textfield");
    el57.setAttribute("type", "number");
    el57.setAttribute("placeholder", data_0["i18n"]["get"]('A'));
    el57.setAttribute("maxlength", "3");
    el57.setAttribute("value", "");
    el57.setAttribute("variant", "quiet");
    el51.appendChild(el57);
    var el58 = document.createTextNode("\n    ");
    el51.appendChild(el58);
    el22.appendChild(el51);
    var el59 = document.createTextNode("\n  ");
    el22.appendChild(el59);
    el2.appendChild(el22);
    var el60 = document.createTextNode("\n");
    el2.appendChild(el60);
    frag.appendChild(el2);
    var el61 = document.createTextNode("\n");
    frag.appendChild(el61);
    return frag;
  };

  var CLASSNAME$K = '_coral-ColorInput-colorProperties';
  /**
   @class Coral.ColorInput.ColorProperties
   @classdesc A ColorInput Color properties component
   @htmltag coral-colorinput-colorproperties
   @extends {HTMLElement}
   @extends {BaseComponent}
   @extends {BaseColorInputAbstractSubview}
   */

  var ColorInputColorProperties = Decorator( /*#__PURE__*/function (_BaseColorInputAbstra) {
    _inherits(_class, _BaseColorInputAbstra);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this);

      _this._delegateEvents(commons.extend(_this._events, {
        'change [handle="redSlider"]': '_onRedSliderChange',
        'change [handle="greenSlider"]': '_onGreenSliderChange',
        'change [handle="blueSlider"]': '_onBlueSliderChange',
        'change [handle="alphaSlider"]': '_onAlphaSliderChange',
        'change ._coral-ColorInput-editHex': '_onChangeHex',
        'change ._coral-ColorInput-editRgba': '_onChangeRgba'
      })); // Templates


      _this._elements = {};
      template$t.call(_this._elements, {
        commons: commons,
        i18n: i18n
      });
      return _this;
    }
    /** @ignore */


    _createClass(_class, [{
      key: "_onColorInputChange",
      value: function _onColorInputChange() {
        var newColor = this._colorinput.valueAsColor;
        var colorPreview = this._elements.colorPreview2;
        var rgba;

        if (!newColor) {
          // update the colorPreview background color, state, and label
          colorPreview.setAttribute('aria-pressed', 'true');
          colorPreview.setAttribute('aria-label', i18n.get('Color not set')); // reset Hex value to empty

          this._elements.hexInput.value = '';
        } else {
          rgba = newColor.rgba; // update the colorPreview background color, state, and label

          colorPreview.style.backgroundColor = newColor.rgbValue;
          colorPreview.setAttribute('aria-pressed', 'false');
          colorPreview.setAttribute('aria-label', i18n.get('{value}, Color', {
            value: parseFloat(rgba.a) === 1 ? newColor.value : newColor.rgbaValue
          })); // update the Hex input value

          this._elements.hexInput.value = newColor.hexValue.substr(1);
        }

        var prefixes = ['red', 'green', 'blue', 'alpha'];
        var prefixesLength = prefixes.length;
        var prefix;
        var abbr;
        var isAlpha;
        var val; // update rgba slider and input values

        for (var i = 0; i < prefixesLength; i++) {
          prefix = prefixes[i];
          abbr = prefix.substr(0, 1);
          isAlpha = i === prefixesLength - 1; // default slider and input value

          val = isAlpha ? 100 : 127; // with new color, get appropriate RGBA value

          if (newColor) {
            if (!rgba) {
              val = '';
            } else if (isAlpha) {
              val = parseInt(rgba[abbr] * 100, 10);
            } else {
              val = rgba[abbr];
            }
          } // update the slider and input values


          this._elements["".concat(prefix, "Slider")].value = this._elements["".concat(prefix, "Input")].value = val;
        }

        if (colorPreview === document.activeElement) {
          // force blur and focus on colorButton so that new color or state is announced
          colorPreview.blur(); // delay focus by 100ms so that screen reader has time to adjust to label with updated color value

          window.setTimeout(function () {
            colorPreview.focus();
          }, 100);
        }
      }
      /** @ignore */

    }, {
      key: "_onRedSliderChange",
      value: function _onRedSliderChange(event) {
        this._elements.redInput.value = this._elements.redSlider.value;

        this._onChangeRgba(event);
      }
      /** @ignore */

    }, {
      key: "_onGreenSliderChange",
      value: function _onGreenSliderChange(event) {
        this._elements.greenInput.value = this._elements.greenSlider.value;

        this._onChangeRgba(event);
      }
      /** @ignore */

    }, {
      key: "_onBlueSliderChange",
      value: function _onBlueSliderChange(event) {
        this._elements.blueInput.value = this._elements.blueSlider.value;

        this._onChangeRgba(event);
      }
      /** @ignore */

    }, {
      key: "_onAlphaSliderChange",
      value: function _onAlphaSliderChange(event) {
        this._elements.alphaInput.value = this._elements.alphaSlider.value;

        this._onChangeRgba(event);
      }
      /** @ignore */

    }, {
      key: "_onChangeHex",
      value: function _onChangeHex(event) {
        event.stopPropagation(); // Value of hexInput field is without '#'.

        var value = "#".concat(this._elements.hexInput.value);
        var color = new Color();
        color.value = value;

        if (color.hex === null) {
          // no valid color value
          this._elements.hexInput.value = ''; // Save last valid color

          if (this._colorinput.valueAsColor !== null) {
            this.constructor._lastValidColor = this._colorinput.valueAsColor;
          }

          this._colorinput._setActiveColor(null);
        } else {
          this._colorinput._setActiveColor(color);
        }
      }
      /** @ignore */

    }, {
      key: "_onChangeRgba",
      value: function _onChangeRgba(event) {
        event.stopPropagation();
        var r = parseInt(this._elements.redInput.value, 10);
        var g = parseInt(this._elements.greenInput.value, 10);
        var b = parseInt(this._elements.blueInput.value, 10);
        var a = parseInt(this._elements.alphaInput.value, 10);
        var colorValid = true;

        if (isNaN(r) || r < 0 || r > 255) {
          colorValid = false;
          this._elements.redInput.value = '';
        }

        if (isNaN(g) || g < 0 || g > 255) {
          colorValid = false;
          this._elements.greenInput.value = '';
        }

        if (isNaN(b) || b < 0 || b > 255) {
          colorValid = false;
          this._elements.blueInput.value = '';
        }

        if (isNaN(a) || a < 0 || a > 100) {
          colorValid = false;
          this._elements.alphaInput.value = '';
        }

        if (colorValid) {
          var color = new Color();
          color.rgba = {
            r: r,
            g: g,
            b: b,
            a: a / 100
          };

          this._colorinput._setActiveColor(color);
        }
      }
      /** @ignore */

    }, {
      key: "render",
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$K); // Support cloneNode

        var subview = this.querySelector('._coral-ColorInput-propertiesSubview');

        if (subview) {
          subview.remove();
        }

        this.appendChild(this._elements.propertiesSubview);
      }
    }]);

    return _class;
  }(BaseColorInputAbstractSubview(BaseComponent(HTMLElement))));

  var template$u = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["colorButton"] = document.createElement("button", "coral-button");
    el0.setAttribute("is", "coral-button");
    el0.setAttribute("variant", "action");
    el0.setAttribute("handle", "colorButton");
    el0.setAttribute("icon", "checkmark");
    el0.setAttribute("type", "button");
    el0.setAttribute("role", "option");
    frag.appendChild(el0);
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    this.colorButton.label.classList.add('u-coral-screenReaderOnly');
    var el3 = document.createTextNode("\n");
    frag.appendChild(el3);
    return frag;
  };

  var CLASSNAME$L = '_coral-ColorInput-swatch';
  /**
   @class Coral.ColorInput.Swatch
   @classdesc A ColorInput Swatch component
   @htmltag coral-colorinput-swatch
   @extends {HTMLElement}
   @extends {BaseComponent}
   @extends {BaseColorInputAbstractSubview}
   */

  var ColorInputSwatch = Decorator( /*#__PURE__*/function (_BaseColorInputAbstra) {
    _inherits(_class, _BaseColorInputAbstra);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this); // Events

      _this._delegateEvents(_this._events); // Templates


      _this._elements = {};
      template$u.call(_this._elements);
      return _this;
    }
    /**
     Whether the Item is selected.
     @type {Boolean}
     @default false
     @htmlattribute selected
     @htmlattributereflected
     */


    _createClass(_class, [{
      key: "_onColorInputChange",

      /** @ignore */
      value: function _onColorInputChange() {
        if (this.targetColor) {
          // sync selections
          this.selected = this.targetColor.selected;
        }
      }
    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$L, 'u-coral-clearFix'); // adds the role to support accessibility

        this.setAttribute('role', 'presentation'); // Support cloneNode

        var button = this.querySelector('[handle="colorButton"]');

        if (button) {
          button.remove();
        }

        this.appendChild(this._elements.colorButton);
      }
    }, {
      key: "selected",
      get: function get() {
        return this._selected || false;
      },
      set: function set(value) {
        value = transform.booleanAttr(value);

        if (!value || value && !this.disabled) {
          this._selected = value;

          this._reflectAttribute('selected', this.disabled ? false : this._selected);

          this.removeAttribute('aria-selected', this._selected);
          this.classList.toggle('is-selected', this._selected);

          this._elements.colorButton.setAttribute('aria-selected', this._selected);

          this._elements.colorButton.tabIndex = this.tabIndex;
          this.removeAttribute('tabindex');

          this._elements.colorButton[this._selected ? 'setAttribute' : 'removeAttribute']('aria-label', "".concat(i18n.get('checked'), " ").concat(this._elements.colorButton.label.textContent));

          this.trigger('coral-colorinput-swatch:_selectedchanged');
        }
      }
      /**
       The Coral.ColorInput.Item that the swatch is a visual representation of. It accepts a DOM element or a CSS selector.
       If a CSS selector is provided, the first matching element will be used.
        @type {HTMLElement|String}
       @default null
       @htmlattribute targetcolor
       */

    }, {
      key: "targetColor",
      get: function get() {
        return this._targetColor || null;
      },
      set: function set(value) {
        if (typeof value === 'string') {
          value = this.querySelector(value);
        } // Store new value


        this._targetColor = value;
        var cssColorValue = '';
        var hexColorValue = '';

        if (this._targetColor) {
          var color = new Color();
          color.value = this._targetColor.value;
          cssColorValue = color.rgbaValue;
          hexColorValue = color.hexValue;
        } // Update background color and text label for color swatch


        if (cssColorValue) {
          this._elements.colorButton.style.backgroundColor = cssColorValue;
          this._elements.colorButton.label.textContent = hexColorValue;
          this.setAttribute('data-value', hexColorValue);
        } else {
          this._elements.colorButton.classList.add('_coral-ColorInput-swatch-novalue');

          this._elements.colorButton.label.textContent = i18n.get('unset');
          this.setAttribute('data-value', '');
        }
      }
      /**
       Whether the color preview is disabled or not.
        @type {Boolean}
       @default false
       @htmlattribute disabled
       @htmlattributereflected
       */

    }, {
      key: "disabled",
      get: function get() {
        return this._elements.colorButton.disabled;
      },
      set: function set(value) {
        this._elements.colorButton.disabled = value;

        this._reflectAttribute('disabled', this.disabled);
      }
      /**
       The tabindex of the color preview button.
       So that we don't wind up with nested focusable elements,
       the internal colorButton should should receive the tabIndex property,
       while the coral-colorinput-swatch should reflect the value using the _tabindex attribute.
        @type {Integer}
       @default -1
       @htmlattribute tabindex
       @htmlattributereflected
       */

    }, {
      key: "tabIndex",
      get: function get() {
        return this._elements.colorButton.tabIndex;
      },
      set: function set(value) {
        this._elements.colorButton.tabIndex = value;
        this.removeAttribute('tabindex');
      }
    }], [{
      key: "_attributePropertyMap",
      get: function get() {
        return commons.extend(_get(_getPrototypeOf(_class), "_attributePropertyMap", this), {
          tabindex: 'tabIndex',
          targetcolor: 'targetColor'
        });
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['selected', 'tabindex', 'disabled', 'targetcolor']);
      }
    }]);

    return _class;
  }(BaseColorInputAbstractSubview(BaseComponent(HTMLElement))));

  var template$v = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["swatchesSubview"] = document.createElement("div");
    el0.className += " _coral-ColorInput-swatchesSubview";
    el0.setAttribute("role", "presentation");
    el0.setAttribute("handle", "swatchesSubview");
    var el1 = document.createTextNode("\n  ");
    el0.appendChild(el1);
    var el2 = document.createElement("div");
    el2.className += " _coral-ColorInput-swatches-header-title coral-Heading coral-Heading--5";
    el2.setAttribute("role", "presentation");
    el2.setAttribute("aria-hidden", "true");
    var el3 = document.createTextNode("\n    ");
    el2.appendChild(el3);
    var el4 = this["swatchesHeaderTitle"] = document.createElement("span");
    el4.setAttribute("handle", "swatchesHeaderTitle");
    el4.id = data_0["commons"]["getUID"]();
    el4.setAttribute("role", "heading");
    el4.setAttribute("aria-level", "2");
    el4.textContent = "\n      " + data_0["i18n"]["get"]('Swatches');
    el2.appendChild(el4);
    var el5 = document.createTextNode("\n  ");
    el2.appendChild(el5);
    el0.appendChild(el2);
    var el6 = document.createTextNode("\n  ");
    el0.appendChild(el6);
    var el7 = document.createElement("div");
    el7.className += " _coral-ColorInput-swatches-container";
    el7.setAttribute("role", "presentation");
    var el8 = document.createTextNode("\n    ");
    el7.appendChild(el8);
    var el9 = this["swatchesContainer"] = document.createElement("div");
    el9.setAttribute("handle", "swatchesContainer");
    el9.setAttribute("role", "presentation");
    el7.appendChild(el9);
    var el10 = document.createTextNode("\n  ");
    el7.appendChild(el10);
    el0.appendChild(el7);
    var el11 = document.createTextNode("\n");
    el0.appendChild(el11);
    frag.appendChild(el0);
    var el12 = document.createTextNode("\n");
    frag.appendChild(el12);
    return frag;
  };

  var CLASSNAME$M = '_coral-ColorInput-swatches';
  /**
   @class Coral.ColorInput.Swatches
   @classdesc A ColorInput Swatches component
   @htmltag coral-colorinput-swatches
   @extends {HTMLElement}
   @extends {BaseComponent}
   @extends {BaseColorInputAbstractSubview}
   */

  var ColorInputSwatches = Decorator( /*#__PURE__*/function (_BaseColorInputAbstra) {
    _inherits(_class, _BaseColorInputAbstra);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this); // Events

      _this._delegateEvents(commons.extend(_this._events, {
        'click coral-colorinput-swatch': '_onSwatchClicked',
        'keydown ._coral-ColorInput-swatch': '_onKeyDown',
        'capture:focus coral-colorinput-swatch': '_onFocus',
        // private
        'coral-colorinput-swatch:_selectedchanged': '_onItemSelectedChanged'
      })); // Templates


      _this._elements = {};
      template$v.call(_this._elements, {
        commons: commons,
        i18n: i18n
      }); // Used for eventing

      _this._oldSelection = null; // Init the collection mutation observer

      _this.items._startHandlingItems(true);

      return _this;
    }
    /**
     The Collection Interface that allows interacting with the items that the component contains.
      @type {SelectableCollection}
     @readonly
     */


    _createClass(_class, [{
      key: "_onItemSelectedChanged",

      /** @private */
      value: function _onItemSelectedChanged(event) {
        event.stopImmediatePropagation();

        this._validateSelection(event.target);
      }
      /** @private */

    }, {
      key: "_validateSelection",
      value: function _validateSelection(item) {
        var _this2 = this;

        var selectedItems = this.items._getAllSelected(); // Last selected item wins


        item = item || selectedItems[selectedItems.length - 1];

        if (item && item.hasAttribute('selected') && selectedItems.length > 1) {
          selectedItems.forEach(function (selectedItem) {
            if (selectedItem !== item) {
              // Don't trigger change events
              _this2._preventTriggeringEvents = true;
              selectedItem.removeAttribute('selected');
            }
          }); // We can trigger change events again

          this._preventTriggeringEvents = false;
        }

        this._triggerChangeEvent();
      }
      /** @private */

    }, {
      key: "_triggerChangeEvent",
      value: function _triggerChangeEvent() {
        var selectedItem = this.selectedItem;
        var oldSelection = this._oldSelection;

        if (!this._preventTriggeringEvents && selectedItem !== oldSelection) {
          // update hidden fields
          if (selectedItem) {
            this.value = selectedItem.value;
          }

          this.trigger('coral-colorinput-swatches:change', {
            oldSelection: oldSelection,
            selection: selectedItem
          });
          this._oldSelection = selectedItem;
        }
      }
      /** @ignore */

    }, {
      key: "_beforeOverlayOpen",
      value: function _beforeOverlayOpen() {
        // relayout swatches if items have been added/removed/moved...
        var colorElements = this._colorinput.items.getAll();

        var colorsElementsChanged = false;

        if (!this._cachedColorElements) {
          colorsElementsChanged = true;
        } else if (this._cachedColorElements.length !== colorElements.length) {
          colorsElementsChanged = true;
        } else if (this._cachedColorElements.length === colorElements.length) {
          for (var i = 0; i < colorElements.length; i++) {
            if (this._cachedColorElements[i] !== colorElements[i]) {
              colorsElementsChanged = true;
              break;
            }
          }
        }

        this._cachedColorElements = colorElements;

        if (colorsElementsChanged) {
          this._layoutColorSwatch();
        }

        this._ensureKeyboardAccess();
      }
      /** @ignore */

    }, {
      key: "_onColorInputChange",
      value: function _onColorInputChange() {
        this._ensureKeyboardAccess();
      }
      /**
       If no swatch is selected, make sure that the first swatch is tabbable
       @ignore
       */

    }, {
      key: "_ensureKeyboardAccess",
      value: function _ensureKeyboardAccess() {
        if (!this.querySelector('coral-colorinput-swatch[selected]')) {
          var firstSwatch = this.querySelector('coral-colorinput-swatch');

          if (firstSwatch) {
            firstSwatch.tabIndex = 0;
          }
        }
      }
      /** @ignore */

    }, {
      key: "_layoutColorSwatch",
      value: function _layoutColorSwatch() {
        // Clear container before adding elements to avoid multiple addition
        this._elements.swatchesContainer.innerHtml = '';

        var colors = this._colorinput.items.getAll();

        var colorsLength = colors.length;
        var swatchSelected = false;

        for (var colorCount = 0; colorCount < colorsLength; colorCount++) {
          var color = colors[colorCount];
          var swatch = new ColorInputSwatch();

          this._elements.swatchesContainer.appendChild(swatch);

          swatch.targetColor = color;

          if (color.selected) {
            swatch[color.selected ? 'setAttribute' : 'removeAttribute']('selected', color.selected);
            swatchSelected = true;
          } // Update color button tabindex depending on selected state


          swatch.tabIndex = swatch.selected ? 0 : -1;
        } // If no swatch is selected, make sure that the first swatch is focusable


        if (!swatchSelected) {
          this._ensureKeyboardAccess();
        }
      }
      /** @ignore */

    }, {
      key: "_onSwatchClicked",
      value: function _onSwatchClicked(event) {
        event.stopPropagation();
        var colorButton = event.target;
        var swatch = colorButton.closest('coral-colorinput-swatch');

        if (!swatch.selected) {
          var color = new Color();
          color.value = swatch.targetColor ? swatch.targetColor.value : '';

          this._colorinput._setActiveColor(color);

          swatch.selected = true;
        }

        swatch.firstChild.focus();
      }
      /** @ignore */

    }, {
      key: "_onKeyDown",
      value: function _onKeyDown(event) {
        var overlay = this._colorinput._elements.overlay; // only if overlay is open

        if (!overlay.open) {
          return;
        }

        var allItems = this.items.getAll();
        var currentIndex = allItems.indexOf(event.matchedTarget);
        var preventDefault = true;
        var newIndex = currentIndex;

        switch (event.which) {
          // return
          case 13:
            // Wait a frame before closing so that focus is restored correctly
            window.requestAnimationFrame(function () {
              overlay.open = false;
            });
            break;
          // left arrow

          case 37:
            newIndex -= 1;
            break;
          // up arrow

          case 38:
            newIndex -= 4;
            break;
          // right arrow

          case 39:
            newIndex += 1;
            break;
          // down arrow

          case 40:
            newIndex += 4;
            break;

          default:
            preventDefault = false;
            break;
        } // If any action has been taken prevent event propagation


        if (preventDefault) {
          event.preventDefault();

          if (newIndex < 0 || newIndex >= allItems.length) {
            return;
          } // show right page in carousel and focus right swatch


          var swatch = allItems[newIndex];
          var color = new Color();
          color.value = swatch.targetColor ? swatch.targetColor.value : '';

          this._colorinput._setActiveColor(color);

          swatch.selected = true;
          swatch.firstChild.focus();
        }
      }
      /**
       Ensure that only one swatch can receive tab focus at a time
       @ignore
       */

    }, {
      key: "_onFocus",
      value: function _onFocus(event) {
        var allItems = this.items.getAll();

        for (var i = 0; i < allItems.length; i++) {
          var swatch = allItems[i];

          if (!swatch.contains(event.matchedTarget)) {
            swatch.tabIndex = -1;
          }
        }

        event.matchedTarget.tabIndex = 0;

        if (document.activeElement !== event.matchedTarget.firstChild) {
          event.matchedTarget.firstChild.focus();
        }
      }
      /** @ignore */

    }, {
      key: "render",
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$M); // adds the role to support accessibility

        this.setAttribute('role', 'listbox'); // Support cloneNode

        var swatchesSubview = this.querySelector('._coral-ColorInput-swatchesSubview');

        if (swatchesSubview) {
          swatchesSubview.remove();
        } // add header


        this.appendChild(this._elements.swatchesSubview); // add accessibility label

        this.setAttribute('aria-labelledby', this._elements.swatchesHeaderTitle.id); // Don't trigger events once connected

        this._preventTriggeringEvents = true;

        this._validateSelection();

        this._preventTriggeringEvents = false;
        this._oldSelection = this.selectedItem;
      }
    }, {
      key: "items",
      get: function get() {
        // just init on demand
        if (!this._items) {
          this._items = new SelectableCollection({
            host: this,
            itemTagName: 'coral-colorinput-swatch',
            onItemAdded: this._validateSelection
          });
        }

        return this._items;
      }
      /**
       The selected item.
        @type {HTMLElement}
       @readonly
       */

    }, {
      key: "selectedItem",
      get: function get() {
        return this.items._getLastSelected();
      }
    }]);

    return _class;
  }(BaseColorInputAbstractSubview(BaseComponent(HTMLElement))));

  var template$w = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var data = data_0 = typeof data_0 === "undefined" ? {} : data_0;
    var el0 = this["defaultPalette"] = document.createElement("div");
    el0.setAttribute("handle", "defaultPalette");
    var el1 = document.createTextNode("\n  ");
    el0.appendChild(el1);
    var el2 = document.createElement("coral-colorinput-item");
    el2.setAttribute("value", "");
    el0.appendChild(el2);
    var el3 = document.createTextNode("\n  ");
    el0.appendChild(el3);
    var el4 = document.createElement("coral-colorinput-item");
    el4.setAttribute("value", "#001F3F");
    el0.appendChild(el4);
    var el5 = document.createTextNode("\n  ");
    el0.appendChild(el5);
    var el6 = document.createElement("coral-colorinput-item");
    el6.setAttribute("value", "#0074D9");
    el0.appendChild(el6);
    var el7 = document.createTextNode("\n  ");
    el0.appendChild(el7);
    var el8 = document.createElement("coral-colorinput-item");
    el8.setAttribute("value", "#7FDBFF");
    el0.appendChild(el8);
    var el9 = document.createTextNode("\n  ");
    el0.appendChild(el9);
    var el10 = document.createElement("coral-colorinput-item");
    el10.setAttribute("value", "#39CCCC");
    el0.appendChild(el10);
    var el11 = document.createTextNode("\n  ");
    el0.appendChild(el11);
    var el12 = document.createElement("coral-colorinput-item");
    el12.setAttribute("value", "#3D9970");
    el0.appendChild(el12);
    var el13 = document.createTextNode("\n  ");
    el0.appendChild(el13);
    var el14 = document.createElement("coral-colorinput-item");
    el14.setAttribute("value", "#2ECC40");
    el0.appendChild(el14);
    var el15 = document.createTextNode("\n  ");
    el0.appendChild(el15);
    var el16 = document.createElement("coral-colorinput-item");
    el16.setAttribute("value", "#01FF70");
    el0.appendChild(el16);
    var el17 = document.createTextNode("\n  ");
    el0.appendChild(el17);
    var el18 = document.createElement("coral-colorinput-item");
    el18.setAttribute("value", "#FFDC00");
    el0.appendChild(el18);
    var el19 = document.createTextNode("\n  ");
    el0.appendChild(el19);
    var el20 = document.createElement("coral-colorinput-item");
    el20.setAttribute("value", "#FF851B");
    el0.appendChild(el20);
    var el21 = document.createTextNode("\n  ");
    el0.appendChild(el21);
    var el22 = document.createElement("coral-colorinput-item");
    el22.setAttribute("value", "#FF4136");
    el0.appendChild(el22);
    var el23 = document.createTextNode("\n  ");
    el0.appendChild(el23);
    var el24 = document.createElement("coral-colorinput-item");
    el24.setAttribute("value", "#85144B");
    el0.appendChild(el24);
    var el25 = document.createTextNode("\n  ");
    el0.appendChild(el25);
    var el26 = document.createElement("coral-colorinput-item");
    el26.setAttribute("value", "#F012BE");
    el0.appendChild(el26);
    var el27 = document.createTextNode("\n  ");
    el0.appendChild(el27);
    var el28 = document.createElement("coral-colorinput-item");
    el28.setAttribute("value", "#B10DC9");
    el0.appendChild(el28);
    var el29 = document.createTextNode("\n  ");
    el0.appendChild(el29);
    var el30 = document.createElement("coral-colorinput-item");
    el30.setAttribute("value", "#111111");
    el0.appendChild(el30);
    var el31 = document.createTextNode("\n  ");
    el0.appendChild(el31);
    var el32 = document.createElement("coral-colorinput-item");
    el32.setAttribute("value", "#AAAAAA");
    el0.appendChild(el32);
    var el33 = document.createTextNode("\n  ");
    el0.appendChild(el33);
    var el34 = document.createElement("coral-colorinput-item");
    el34.setAttribute("value", "#DDDDDD");
    el0.appendChild(el34);
    var el35 = document.createTextNode("\n");
    el0.appendChild(el35);
    frag.appendChild(el0);
    var el36 = document.createTextNode("\n");
    frag.appendChild(el36);
    data = data_0;
    var uid = data.commons.getUID();
    data_0 = data;
    var el38 = document.createTextNode("\n");
    frag.appendChild(el38);
    var el39 = this["input"] = document.createElement("input", "coral-textfield");
    el39.setAttribute("handle", "input");
    el39.setAttribute("is", "coral-textfield");
    el39.className += " _coral-ColorInput-input";
    el39.setAttribute("type", "text");
    el39.setAttribute("value", "");
    el39.setAttribute("role", "combobox");
    el39.setAttribute("aria-autocomplete", "none");
    el39.setAttribute("aria-haspopup", "dialog");
    el39.setAttribute("aria-expanded", "false");
    el39.setAttribute("aria-controls", uid);
    frag.appendChild(el39);
    var el40 = document.createTextNode("\n");
    frag.appendChild(el40);
    var el41 = this["buttonWrapper"] = document.createElement("div");
    el41.className += " _coral-ColorInput-buttonWrapper";
    el41.setAttribute("handle", "buttonWrapper");
    el41.setAttribute("role", "presentation");
    var el42 = document.createTextNode("\n  ");
    el41.appendChild(el42);
    var el43 = this["colorPreview"] = document.createElement("button", "coral-button");
    el43.setAttribute("handle", "colorPreview");
    el43.setAttribute("is", "coral-button");
    el43.setAttribute("variant", "_custom");
    el43.className += " _coral-FieldButton _coral-ColorInput-button _coral-ColorInput-preview";
    el43.setAttribute("type", "button");
    el43.setAttribute("aria-haspopup", "dialog");
    el43.setAttribute("aria-expanded", "false");
    el43.setAttribute("aria-controls", uid);
    el41.appendChild(el43);
    var el44 = document.createTextNode("\n  ");
    el41.appendChild(el44);
    data = data_0; // Since we don't have a mutation observer anymore to replace content zones magically, we have to do it manually.

    this.colorPreview.label.classList.add('u-coral-screenReaderOnly');
    this.colorPreview.label.innerText = data.i18n.get('Color Picker');
    this.colorPreview.label.id = uid + '-coral-button-label';
    data_0 = data;
    var el46 = document.createTextNode("\n");
    el41.appendChild(el46);
    frag.appendChild(el41);
    var el47 = document.createTextNode("\n");
    frag.appendChild(el47);
    var el48 = this["overlay"] = document.createElement("coral-popover");
    el48.setAttribute("smart", "");
    el48.className += " _coral-ColorInput-overlay";
    el48.setAttribute("role", "dialog");
    el48.setAttribute("focusonshow", "on");
    el48.setAttribute("trapfocus", "on");
    el48.setAttribute("handle", "overlay");
    el48.setAttribute("breadthoffset", "50%r - 50%p");
    el48.setAttribute("placement", "bottom");
    el48.id = uid;
    el48.setAttribute("aria-label", data_0["i18n"]["get"]('Color Picker'));
    var el49 = document.createTextNode("\n  ");
    el48.appendChild(el49);
    var el50 = this["propertiesView"] = document.createElement("coral-colorinput-colorproperties");
    el50.setAttribute("handle", "propertiesView");
    el48.appendChild(el50);
    var el51 = document.createTextNode("\n  ");
    el48.appendChild(el51);
    var el52 = this["swatchesView"] = document.createElement("coral-colorinput-swatches");
    el52.setAttribute("handle", "swatchesView");
    el48.appendChild(el52);
    var el53 = document.createTextNode("\n");
    el48.appendChild(el53);
    frag.appendChild(el48);
    var el54 = document.createTextNode("\n");
    frag.appendChild(el54);
    return frag;
  };

  var CLASSNAME$N = '_coral-ColorInput';
  /**
   Enumeration for {@link ColorInput} variants.

   @typedef {Object} ColorInputVariantEnum

   @property {String} DEFAULT
   Use ColorInput as a formfield (default).
   @property {String} SWATCH
   Use a simple swatch as ColorInput.
   */

  var variant$f = {
    DEFAULT: 'default',
    SWATCH: 'swatch'
  };
  /**
   Enumeration for {@link ColorInput} auto generated colors options.

   @typedef {Object} ColorInputAutoGenerateColorsEnum

   @property {String} OFF
   Disable auto generation.
   @property {String} SHADES
   Automatically generate shades (darker colors) of all colors.
   @property {String} TINTS
   Automatically generate tints (lighter colors) of all colors.
   */

  var autoGenerateColors = {
    OFF: 'off',
    SHADES: 'shades',
    TINTS: 'tints'
  };
  /**
   Enumeration for {@link ColorInput} swatches display options.

   @typedef {Object} ColorInputShowSwatchesEnum

   @property {String} ON
   Display swatches view (default).
   @property {String} OFF
   Hide swatches view.
   */

  var showSwatches = {
    ON: 'on',
    OFF: 'off'
  };
  /**
   Enumeration for {@link ColorInput} color properties display options.

   @typedef {Object} ColorInputShowPropertiesEnum

   @property {String} ON
   Display color properties view (default).
   @property {String} OFF
   Hide color properties view.
   */

  var showProperties = {
    ON: 'on',
    OFF: 'off'
  };
  /**
   Enumeration for {@link ColorInput} default colors display options.

   @typedef {Object} ColorInputShowDefaultColorsEnum

   @property {String} ON
   Display default colors (default).
   @property {String} OFF
   Hide default colors.
   */

  var showDefaultColors = {
    ON: 'on',
    OFF: 'off'
  };
  /**
   @class Coral.ColorInput
   @classdesc A ColorInput component than can be used as a form field to select from a list of color options.
   @htmltag coral-colorinput
   @extends {HTMLElement}
   @extends {BaseComponent}
   @extends {BaseFormField}
   */

  var ColorInput = Decorator( /*#__PURE__*/function (_BaseFormField) {
    _inherits(_class, _BaseFormField);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this); // Prepare templates

      _this._elements = {};
      template$w.call(_this._elements, {
        commons: commons,
        i18n: i18n
      });
      var overlay = _this._elements.overlay;
      var overlayId = overlay.id; // Add a reference to this

      overlay._colorinput = _assertThisInitialized(_this); // Extend form field events

      var events = commons.extend(_this._events, {
        'key:down ._coral-ColorInput-input:not([readonly])': '_onKeyDown',
        'key:down [handle="colorPreview"]': '_onKeyDown',
        'click [handle="colorPreview"]': '_onColorPreviewClick',
        'key:esc input': '_onKeyEsc',
        'key:enter input': '_onKeyEsc',
        // private
        'coral-colorinput-item:_selectedchanged': '_onItemSelectedChanged'
      }); // Overlay

      events["global:capture:coral-overlay:beforeopen #".concat(overlayId)] = '_beforeOverlayOpen';
      events["global:capture:coral-overlay:close #".concat(overlayId)] = '_onOverlayClose';
      events["global:key:esc #".concat(overlayId)] = '_onKeyEsc'; // Events

      _this._delegateEvents(events); // Pre-define labellable element


      _this._labellableElement = _this._elements.input; // Used for eventing

      _this._oldSelection = null; // Init the collection mutation observer

      _this.items._startHandlingItems(true);

      return _this;
    }
    /**
     Returns the inner overlay to allow customization.
      @type {Popover}
     @readonly
     */


    _createClass(_class, [{
      key: "_onItemSelectedChanged",

      /** @private */
      value: function _onItemSelectedChanged(event) {
        event.stopImmediatePropagation();

        this._validateSelection(event.target);
      }
      /** @private */

    }, {
      key: "_onItemAdded",
      value: function _onItemAdded(item) {
        this._validateSelection(item);

        if (this._elements.overlay.open) {
          // simply close the overlay whenever a color is added
          this._elements.overlay.open = false;
        }
      }
      /** @private */

    }, {
      key: "_onItemRemoved",
      value: function _onItemRemoved() {
        if (this._elements.overlay.open) {
          // simply close the overlay whenever a color is removed
          this._elements.overlay.open = false;
        }
      }
      /** @private */

    }, {
      key: "_validateSelection",
      value: function _validateSelection(item) {
        var _this2 = this;

        var selectedItems = this.items._getAllSelected(); // Last selected item wins


        item = item || selectedItems[selectedItems.length - 1];

        if (item && item.hasAttribute('selected') && selectedItems.length > 1) {
          selectedItems.forEach(function (selectedItem) {
            if (selectedItem !== item) {
              // Don't trigger change events
              _this2._preventTriggeringEvents = true;
              selectedItem.removeAttribute('selected');
            }
          }); // We can trigger change events again

          this._preventTriggeringEvents = false;
        }

        this._triggerChangeEvent();
      }
      /** @private */

    }, {
      key: "_triggerChangeEvent",
      value: function _triggerChangeEvent() {
        var selectedItem = this.selectedItem;
        var oldSelection = this._oldSelection;

        if (!this._preventTriggeringEvents && selectedItem !== oldSelection) {
          // update hidden fields
          if (selectedItem) {
            this.value = selectedItem.getAttribute('value');
          }

          this.trigger('coral-colorinput:change', {
            oldSelection: oldSelection,
            selection: selectedItem
          });
          this._oldSelection = selectedItem;
        }
      }
      /** @ignore */

    }, {
      key: "_onColorPreviewClick",
      value: function _onColorPreviewClick(event) {
        // restore focus to appropriate element when overlay closes
        this._elements.overlay.returnFocusTo(this.variant === variant$f.SWATCH ? event.matchedTarget : this._elements.input);
      }
    }, {
      key: "_onInputChange",
      value: function _onInputChange(event) {
        if (event.target === this._elements.input) {
          // only handle changes to the hidden input field ...
          // stops the current event
          event.stopPropagation();
          var color = new Color();
          color.value = event.target[this._eventTargetProperty];

          this._setActiveColor(color);
        }
      }
      /** @ignore */

    }, {
      key: "_onKeyDown",
      value: function _onKeyDown(event) {
        event.stopPropagation(); // restore focus to appropriate element when overlay closes

        this._elements.overlay.returnFocusTo(this.variant === variant$f.SWATCH ? event.matchedTarget : this._elements.input);

        this._elements.overlay.open = true;
      }
      /** @ignore */

    }, {
      key: "_onKeyEsc",
      value: function _onKeyEsc(event) {
        if (!this._elements.overlay.open) {
          return;
        }

        event.stopPropagation();
        this._elements.overlay.open = false;
      }
      /** @ignore */

    }, {
      key: "_beforeOverlayOpen",
      value: function _beforeOverlayOpen() {
        // Make sure appropriate tabbable descendant will receive focus
        if (this.showProperties === showProperties.ON) {
          this._elements.overlay.focusOnShow = this._elements.propertiesView._elements.colorPreview2;
        } else if (this.showSwatches === showSwatches.ON) {
          this._elements.overlay.focusOnShow = this._elements.overlay.querySelector('coral-colorinput-swatch[selected] > button') || 'coral-colorinput-swatch > button';
        } // set aria-expanded state


        this._elements.input.setAttribute('aria-expanded', true);

        this._elements.colorPreview.setAttribute('aria-expanded', true);
      }
      /** @ignore */

    }, {
      key: "_onOverlayClose",
      value: function _onOverlayClose() {
        // set aria-expanded state
        this._elements.input.setAttribute('aria-expanded', true);

        this._elements.colorPreview.setAttribute('aria-expanded', false);
      }
      /**
       Checks if the current input is valid or not. This check will only be performed on user interaction.
        @ignore
       */

    }, {
      key: "_validateInputValue",
      value: function _validateInputValue() {
        this.invalid = this.value !== '' && this.valueAsColor === null;
      }
      /** @ignore */

    }, {
      key: "_showOrHideView",
      value: function _showOrHideView(view, hide) {
        view.hidden = hide; // Remove both classes and add only the required one

        this._elements.overlay.classList.remove('_coral-ColorInput-onlySwatchesView', '_coral-ColorInput-onlyPropertiesView');

        if (!this._elements.propertiesView.hidden && this._elements.swatchesView.hidden) {
          this._elements.overlay.classList.add('_coral-ColorInput-onlyPropertiesView');
        } else if (this._elements.propertiesView.hidden && !this._elements.swatchesView.hidden) {
          this._elements.overlay.classList.add('_coral-ColorInput-onlySwatchesView');
        } // Update accessibility label for colorPreview button when only swatches are shown


        if (this.showProperties === showProperties.OFF && this.showSwatches === showSwatches.ON) {
          this._elements.colorPreview.label.textContent = i18n.get('Swatches');

          this._elements.overlay.setAttribute('aria-label', i18n.get('Swatches'));
        } else {
          this._elements.colorPreview.label.textContent = i18n.get('Color Picker');

          this._elements.overlay.setAttribute('aria-label', i18n.get('Color Picker'));
        }
      }
      /** @ignore */

    }, {
      key: "_recalculateGeneratedColors",
      value: function _recalculateGeneratedColors() {
        // remove old generated tint colors
        var childrenList = this.querySelectorAll('coral-colorinput-item[coral-colorinput-generatedcolor]');
        var childrenListLength = childrenList.length;

        for (var i = 0; i < childrenListLength; i++) {
          childrenList[i].remove();
        }

        if (this.autoGenerateColors !== autoGenerateColors.OFF) {
          var colorElements = this.items.getAll();
          var colorEl = null;
          var color = null;
          var colorIndex = 0;
          var generatedIndex = 0;
          var generatedColorEl = null;
          var generatedColors = [];

          for (colorIndex = 0; colorIndex < colorElements.length; colorIndex++) {
            colorEl = colorElements[colorIndex];
            color = new Color();
            color.value = colorEl.value;
            generatedColors = this.autoGenerateColors === autoGenerateColors.TINTS ? color.calculateTintColors(5) : color.calculateShadeColors(5);

            for (generatedIndex = generatedColors.length - 1; generatedIndex >= 0; generatedIndex--) {
              generatedColorEl = new ColorInputItem(); // be sure to add alpha

              generatedColorEl.value = generatedColors[generatedIndex].rgbaValue;
              generatedColorEl.setAttribute('coral-colorinput-generatedcolor', '');
              colorEl.parentNode.insertBefore(generatedColorEl, colorEl.nextSibling);
            }
          }
        }
      }
      /** @ignore */

    }, {
      key: "_syncColorPreviewIcon",
      value: function _syncColorPreviewIcon() {
        var colorPreview = this._elements.colorPreview;
        colorPreview.icon = this.disabled && this.variant === variant$f.SWATCH ? 'lockClosed' : '';
        colorPreview.iconSize = Icon.size.SMALL;
      }
      /** @ignore */

    }, {
      key: "_setActiveColor",
      value: function _setActiveColor(color) {
        // method used by subviews to set a color and trigger a change event if needed
        var oldColor = this.valueAsColor ? this.valueAsColor : new Color();
        this.valueAsColor = color;

        if (!oldColor.isSimilarTo(this.valueAsColor, false)) {
          // test if current color is invalid
          this._validateInputValue(); // trigger a change event (change events should only be triggered when an user interaction happened)


          this.trigger('change');
        }
      }
      /** @ignore */

    }, {
      key: "_selectColorInputColor",
      value: function _selectColorInputColor(newColor) {
        var selectColorInItems = true;

        if (this.selectedItem) {
          var selectedColor = new Color();
          selectedColor.value = this.selectedItem.value; // only select color if it is not already selected

          selectColorInItems = !selectedColor.isSimilarTo(newColor, true);
        }

        if (selectColorInItems) {
          // select right color in this.items (if necessary and possible)
          var selectedItem = this.selectedItem;

          if (selectedItem) {
            selectedItem.removeAttribute('selected');
          }

          var colorElements = this.items.getAll();
          var colorElementsCount = colorElements.length;
          var color = null;

          for (var i = 0; i < colorElementsCount; i++) {
            color = new Color();
            color.value = colorElements[i].getAttribute('value');

            if (color.isSimilarTo(newColor, true)) {
              colorElements[i].setAttribute('selected', '');
              break;
            }
          }
        }
      }
      /** @private */

    }, {
      key: "_setDefaultSelectedItem",
      value: function _setDefaultSelectedItem() {
        var selectedItem = this.selectedItem;
        var value = this.value; // Sync selectedItem if value is set

        if (value && !selectedItem) {
          var color = new Color();
          color.value = value;

          this._selectColorInputColor(color);
        } // Also sync color preview


        this._updateColorPreview();
      }
    }, {
      key: "_updateColorPreview",
      value: function _updateColorPreview() {
        var isValueEmpty = this.value === ''; // update color preview

        var currentColor = this.valueAsColor;
        this._elements.colorPreview.style.backgroundColor = currentColor ? currentColor.rgbaValue : '';
        this.classList.toggle('_coral-ColorInput--novalue', isValueEmpty); // Update preview in overlay

        var preview = this._elements.overlay.querySelector('._coral-ColorInput-preview');

        if (preview) {
          preview.classList.toggle('_coral-ColorInput-preview--novalue', isValueEmpty);
        }
      }
      /**
       Returns {@link ColorInput} variants.
        @return {ColorInputVariantEnum}
       */

    }, {
      key: "connectedCallback",

      /** @ignore */
      value: function connectedCallback() {
        _get(_getPrototypeOf(_class.prototype), "connectedCallback", this).call(this);

        var overlay = this._elements.overlay; // Cannot be open by default when rendered

        overlay.removeAttribute('open'); // Restore in DOM

        if (overlay._parent) {
          overlay._parent.appendChild(overlay);
        }
      }
      /** @ignore */

    }, {
      key: "render",
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$N);
        this.setAttribute('role', 'group');
        var frag = document.createDocumentFragment(); // Render template

        frag.appendChild(this._elements.defaultPalette);
        frag.appendChild(this._elements.input);
        frag.appendChild(this._elements.buttonWrapper);
        frag.appendChild(this._elements.overlay); // Support cloneNode

        while (this.firstChild) {
          var child = this.firstChild;

          if (child.nodeType === Node.ELEMENT_NODE && child.hasAttribute('handle')) {
            this.removeChild(child);
          } else {
            frag.appendChild(child);
          }
        } // we use 'this' so properly aligns to the input


        this._elements.overlay.target = this._elements.colorPreview;
        this.appendChild(frag); // Make sure colors are generated

        this.autoGenerateColors = this.autoGenerateColors;
        this.showDefaultColors = this.showDefaultColors; // Don't trigger events once connected

        this._preventTriggeringEvents = true; // Make sure we don't have multiple items selected

        this._validateSelection(); // If value is set to default palette item value, we have to make sure it's selected


        this._setDefaultSelectedItem(); // We can trigger events gain


        this._preventTriggeringEvents = false;
        this._oldSelection = this.selectedItem;
      }
      /** @ignore */

    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        _get(_getPrototypeOf(_class.prototype), "disconnectedCallback", this).call(this);

        var overlay = this._elements.overlay; // In case it was moved out don't forget to remove it

        if (!this.contains(overlay)) {
          overlay._parent = overlay._repositioned ? document.body : this;
          overlay.remove();
        }
      }
    }, {
      key: "overlay",
      get: function get() {
        return this._elements.overlay;
      }
      /**
       The Collection Interface that allows interacting with the items that the component contains.
        @type {SelectableCollection}
       @readonly
       */

    }, {
      key: "items",
      get: function get() {
        // just init on demand
        if (!this._items) {
          this._items = new SelectableCollection({
            host: this,
            itemTagName: 'coral-colorinput-item',
            onItemAdded: this._onItemAdded,
            onItemRemoved: this._onItemRemoved
          });
        }

        return this._items;
      }
      /**
       The selected item in the ColorInput.
        @type {HTMLElement}
       @readonly
       */

    }, {
      key: "selectedItem",
      get: function get() {
        return this.items._getLastSelected();
      }
      /**
       The ColorInput variant. See {@link ColorInputVariantEnum}.
        @default ColorInputVariantEnum.DEFAULT
       @type {String}
       @htmlattribute variant
       @htmlattributereflected
       */

    }, {
      key: "variant",
      get: function get() {
        return this._variant || variant$f.DEFAULT;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        this._variant = validate.enumeration(variant$f)(value) && value || variant$f.DEFAULT;

        this._reflectAttribute('variant', this._variant);

        if (this._variant === variant$f.SWATCH) {
          this.classList.add('_coral-ColorInput--swatch');

          this._elements.input.setAttribute('tabindex', -1);

          this._elements.colorPreview.removeAttribute('tabindex');
        } else {
          this.classList.remove('_coral-ColorInput--swatch');

          this._elements.input.removeAttribute('tabindex');
        }

        this._syncColorPreviewIcon();
      }
      /**
       Convenient property to get/set the the current color. If the value is no valid color it will return
       <code>null</code> (The getter will return a copy of the current selected color).
        @type {Color}
       */

    }, {
      key: "valueAsColor",
      get: function get() {
        if (!this._color) {
          this._color = new Color();
        } // sync this._color with the hidden field if necessary


        var newColor = new Color();
        newColor.value = this.value;

        if (!this._color.isSimilarTo(newColor, true)) {
          this._color.value = newColor.value;
          this._color.alpha = newColor.alpha;
        }

        if (this._color.rgb === null) {
          return null;
        }

        return this._color.clone();
      },
      set: function set(value) {
        if (!this._color) {
          this._color = new Color();
        }

        if (!value) {
          // clear color values
          this._color.value = '';
          this.value = '';
        } else {
          // set color values
          this._color = value;

          if (value.alpha < 1) {
            // if an alpha value is used store rgba in the hidden field (it is the only format that can store alpha)
            this.value = value.rgbaValue;
          } else {
            this.value = value.value;
          }
        }
      }
      /**
       Should shades (darker colors) or tints (lighter colors) automatically be generated.
       See {@link ColorInputAutoGenerateColorsEnum}.
        @default Coral.ColorInput.autoGenerateColors.OFF
       @type {String}
       @htmlattribute autogeneratecolors
       */

    }, {
      key: "autoGenerateColors",
      get: function get() {
        return this._autoGenerateColors || autoGenerateColors.OFF;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        this._autoGenerateColors = validate.enumeration(autoGenerateColors)(value) && value || autoGenerateColors.OFF;

        this._recalculateGeneratedColors();
      }
      /**
       Whether swatches view should be displayed. See {@link ColorInputSwatches}.
        @default ColorInputShowSwatchesEnum.ON
       @type {ColorInputSwatches}
       @htmlattribute showswatches
       */

    }, {
      key: "showSwatches",
      get: function get() {
        return this._showSwatches || showSwatches.ON;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        this._showSwatches = validate.enumeration(showSwatches)(value) && value || showSwatches.ON;

        this._showOrHideView(this._elements.swatchesView, this._showSwatches === showSwatches.OFF);
      }
      /**
       Whether properties view should be displayed. See {@link ColorInputColorProperties}.
        @default ColorInputShowPropertiesEnum.ON
       @type {String}
       @htmlattribute showproperties
       */

    }, {
      key: "showProperties",
      get: function get() {
        return this._showProperties || showProperties.ON;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        this._showProperties = validate.enumeration(showProperties)(value) && value || showProperties.ON;

        this._showOrHideView(this._elements.propertiesView, this._showProperties === showProperties.OFF);
      }
      /**
       Whether default colors should be displayed. Link {@link ColorInputShowDefaultColorsEnum}.
        @default ColorInputShowDefaultColorsEnum.ON
       @type {String}
       @htmlattribute showdefaultcolors
       */

    }, {
      key: "showDefaultColors",
      get: function get() {
        return this._showDefaultColors || showDefaultColors.ON;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        this._showDefaultColors = validate.enumeration(showDefaultColors)(value) && value || showDefaultColors.ON;
        var defaultPalette = this._elements.defaultPalette;

        if (this._showDefaultColors === showDefaultColors.ON) {
          if (!defaultPalette.parentNode) {
            this.insertBefore(defaultPalette, this.firstChild || null);
          }
        } else if (defaultPalette.parentNode) {
          defaultPalette.parentNode.removeChild(defaultPalette);
        }
      }
      /**
       Short hint that describes the expected value of the ColorInput. It is displayed when the ColorInput is empty
       and the variant is {@link Coral.ColorInput.variant.DEFAULT}
        @type {String}
       @default ""
       @htmlattribute placeholder
       @htmlattributereflected
       */

    }, {
      key: "placeholder",
      get: function get() {
        return this._elements.input.placeholder;
      },
      set: function set(value) {
        this._reflectAttribute('placeholder', value);

        this._elements.input.placeholder = value;
      }
      /**
       The value of the color. This value can be set in 5 different formats (HEX, RGB, RGBA, HSB and CMYK). Corrects a
       hex value, if it is represented by 3 or 6 characters with or without '#'
        e.g:
       HEX:  #FFFFFF
       RGB:  rgb(16,16,16)
       RGBA: rgba(215,40,40,0.9)
       RGBA: hsb(360,100,100)
       CMYK: cmyk(0,100,50,0)
        @type {String}
       @default ""
       @htmlattribute value
       */

    }, {
      key: "value",
      get: function get() {
        return this._value || '';
      },
      set: function set(value) {
        var oldColor = new Color();
        oldColor.value = this.value;
        var newColor = new Color();
        newColor.value = value;

        if (!newColor.isSimilarTo(oldColor, false)) {
          this._value = value; // make sure right ColorInput.Item is selected even if input field was set by hand

          this._selectColorInputColor(newColor); // trigger a change event


          this.trigger('coral-colorinput:_valuechange');
        } // always set the input to the current value


        this._elements.input.value = this.value;

        this._updateColorPreview();
      }
      /**
       Name used to submit the data in a form.
       @type {String}
       @default ""
       @htmlattribute name
       @htmlattributereflected
       */

    }, {
      key: "name",
      get: function get() {
        return this._elements.input.name;
      },
      set: function set(value) {
        this._reflectAttribute('name', value);

        this._elements.input.name = value;
      }
      /**
       Whether this field is disabled or not.
       @type {Boolean}
       @default false
       @htmlattribute disabled
       @htmlattributereflected
       */

    }, {
      key: "disabled",
      get: function get() {
        return this._disabled || false;
      },
      set: function set(value) {
        this._disabled = transform.booleanAttr(value);

        this._reflectAttribute('disabled', this._disabled);

        this[this._disabled ? 'setAttribute' : 'removeAttribute']('aria-disabled', this._disabled);
        this.classList.toggle('is-disabled', this._disabled);
        this._elements.input.disabled = this.disabled;
        this._elements.colorPreview.disabled = this._disabled || this.readOnly;

        this._syncColorPreviewIcon();
      }
      /**
       Inherited from {@link BaseFormField#invalid}.
       */

    }, {
      key: "invalid",
      get: function get() {
        return _get(_getPrototypeOf(_class.prototype), "invalid", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(_class.prototype), "invalid", value, this, true);

        this._elements.input.invalid = this.invalid;
      }
      /**
       Whether this field is required or not.
       @type {Boolean}
       @default false
       @htmlattribute required
       @htmlattributereflected
       */

    }, {
      key: "required",
      get: function get() {
        return this._required || false;
      },
      set: function set(value) {
        this._required = transform.booleanAttr(value);

        this._reflectAttribute('required', this._required);

        this._elements.input.required = this._required;
      }
      /**
       Whether this field is readOnly or not. Indicating that the user cannot modify the value of the control.
       @type {Boolean}
       @default false
       @htmlattribute readonly
       @htmlattributereflected
       */

    }, {
      key: "readOnly",
      get: function get() {
        return this._readOnly || false;
      },
      set: function set(value) {
        this._readOnly = transform.booleanAttr(value);

        this._reflectAttribute('readonly', this._readOnly);

        this._elements.input.readOnly = this._readOnly;
        this._elements.colorPreview.disabled = this.disabled || this._readOnly;
      }
      /**
       Inherited from {@link BaseFormField#labelledBy}.
       */

    }, {
      key: "labelledBy",
      get: function get() {
        return _get(_getPrototypeOf(_class.prototype), "labelledBy", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(_class.prototype), "labelledBy", value, this, true); // Sync input aria-labelledby


        this._elements.input[value ? 'setAttribute' : 'removeAttribute']('aria-labelledby', value); // in case the user focuses the buttons, he will still get a notion of the usage of the component


        if (this.labelledBy) {
          this.setAttribute('aria-labelledby', this.labelledBy);

          this._elements.colorPreview.setAttribute('aria-labelledby', [this.labelledBy, this._elements.colorPreview.label.id].join(' '));
        } else {
          this.removeAttribute('aria-labelledby');

          this._elements.colorPreview.removeAttribute('aria-labelledby');
        }
      }
    }], [{
      key: "variant",
      get: function get() {
        return variant$f;
      }
      /**
       Returns {@link ColorInput} auto generated colors options.
        @return {ColorInputAutoGenerateColorsEnum}
       */

    }, {
      key: "autoGenerateColors",
      get: function get() {
        return autoGenerateColors;
      }
      /**
       Returns {@link ColorInput} swatches display options.
        @return {ColorInputShowSwatchesEnum}
       */

    }, {
      key: "showSwatches",
      get: function get() {
        return showSwatches;
      }
      /**
       Returns {@link ColorInput} color properties display options.
        @return {ColorInputShowDefaultColorsEnum}
       */

    }, {
      key: "showDefaultColors",
      get: function get() {
        return showDefaultColors;
      }
      /**
       Returns {@link ColorInput} default colors display options.
        @return {ColorInputShowPropertiesEnum}
       */

    }, {
      key: "showProperties",
      get: function get() {
        return showProperties;
      }
    }, {
      key: "_attributePropertyMap",
      get: function get() {
        return commons.extend(_get(_getPrototypeOf(_class), "_attributePropertyMap", this), {
          autogeneratecolors: 'autoGenerateColors',
          showswatches: 'showSwatches',
          showproperties: 'showProperties',
          showdefaultcolors: 'showDefaultColors'
        });
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['variant', 'autogeneratecolors', 'showswatches', 'showproperties', 'showdefaultcolors', 'placeholder']);
      }
    }]);

    return _class;
  }(BaseFormField(BaseComponent(HTMLElement))));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var translations$d = {
    "en-US": {
      "Swatches": "Swatches",
      "R": "R",
      "G": "G",
      "B": "B",
      "A": "A",
      "HEX": "HEX",
      "Color Picker": "Color Picker",
      "unset": "Not set",
      "checked": "Checked",
      "{value}, Color": "{value}, Color",
      "Color not set": "Color not set"
    },
    "fr-FR": {
      "Swatches": "Échantillons",
      "R": "R",
      "G": "G",
      "B": "B",
      "A": "A",
      "HEX": "HEX",
      "Color Picker": "Sélecteur de couleurs",
      "unset": "Non défini",
      "checked": "Activé",
      "{value}, Color": "{value}, Couleur",
      "Color not set": "Couleur non défini"
    },
    "de-DE": {
      "Swatches": "Muster",
      "R": "R",
      "G": "G",
      "B": "B",
      "A": "A",
      "HEX": "HEX",
      "Color Picker": "Farbauswahl",
      "unset": "Nicht gesetzt",
      "checked": "Aktiviert",
      "{value}, Color": "{value}, Farbe",
      "Color not set": "Farbe nicht gesetzt"
    },
    "it-IT": {
      "Swatches": "Campioni",
      "R": "R",
      "G": "G",
      "B": "B",
      "A": "A",
      "HEX": "HEX",
      "Color Picker": "Selettore colori",
      "unset": "Non impostato",
      "checked": "Selezionato",
      "{value}, Color": "{value}, Colore",
      "Color not set": "Colore non impostato"
    },
    "es-ES": {
      "Swatches": "Muestras",
      "R": "R",
      "G": "G",
      "B": "B",
      "A": "A",
      "HEX": "HEX",
      "Color Picker": "Selector de colores",
      "unset": "No establecido",
      "checked": "Activado",
      "{value}, Color": "{value}, Color",
      "Color not set": "Color no establecido"
    },
    "pt-BR": {
      "Swatches": "Amostras",
      "R": "R",
      "G": "G",
      "B": "B",
      "A": "A",
      "HEX": "HEX",
      "Color Picker": "Seletor de cores",
      "unset": "Não definida",
      "checked": "Selecionado",
      "{value}, Color": "{value}, Cor",
      "Color not set": "Cor não definida"
    },
    "ja-JP": {
      "Swatches": "スウォッチ",
      "R": "R",
      "G": "G",
      "B": "B",
      "A": "A",
      "HEX": "16 進",
      "Color Picker": "カラー ピッカー",
      "unset": "設定解除",
      "checked": "選択",
      "{value}, Color": "{value}, カラー",
      "Color not set": "色が設定されていません"
    },
    "ko-KR": {
      "Swatches": "견본",
      "R": "R",
      "G": "G",
      "B": "B",
      "A": "A",
      "HEX": "HEX",
      "Color Picker": "색 선택",
      "unset": "설정 해제",
      "checked": "선택됨",
      "{value}, Color": "{value}, 색",
      "Color not set": "색상이 설정되지 않았습니다."
    },
    "zh-CN": {
      "Swatches": "色板",
      "R": "R",
      "G": "G",
      "B": "B",
      "A": "A",
      "HEX": "十六进制",
      "Color Picker": "颜色选取器",
      "unset": "取消设置",
      "checked": "已选中",
      "{value}, Color": "{value}, 颜色",
      "Color not set": "颜色未设定"
    },
    "zh-TW": {
      "Swatches": "色票",
      "R": "R",
      "G": "G",
      "B": "B",
      "A": "A",
      "HEX": "十六進位",
      "Color Picker": "色彩選擇器",
      "unset": "取消設定",
      "checked": "已檢查",
      "{value}, Color": "{value}, 色彩",
      "Color not set": "顏色未設定"
    },
    "nl-NL": {
      "Swatches": "Stalen",
      "R": "R",
      "G": "G",
      "B": "B",
      "A": "A",
      "HEX": "HEX",
      "Color Picker": "Kleurenkiezer",
      "unset": "Niet ingesteld",
      "checked": "Geselecteerd",
      "{value}, Color": "{value}, Kleur",
      "Color not set": "Kleur niet ingesteld"
    },
    "da-DK": {
      "Swatches": "Farveprøver",
      "R": "R",
      "G": "G",
      "B": "B",
      "A": "A",
      "HEX": "HEX",
      "Color Picker": "Farvevælger",
      "unset": "annuller indstilling",
      "checked": "kontrolleret",
      "{value}, Color": "{value}, Farve",
      "Color not set": "Farve ikke indstillet"
    },
    "fi-FI": {
      "Swatches": "Värimallit",
      "R": "R",
      "G": "G",
      "B": "B",
      "A": "A",
      "HEX": "HEX",
      "Color Picker": "Värimuokkain",
      "unset": "poista asetus",
      "checked": "valittu",
      "{value}, Color": "{value}, väri",
      "Color not set": "Väriä ei ole asetettu."
    },
    "nb-NO": {
      "Swatches": "Fargekart",
      "R": "R",
      "G": "G",
      "B": "B",
      "A": "A",
      "HEX": "HEX",
      "Color Picker": "Fargevelger",
      "unset": "fjern",
      "checked": "avmerket",
      "{value}, Color": "{value}, farge",
      "Color not set": "Farge ikke angitt"
    },
    "sv-SE": {
      "Swatches": "Färgrutor",
      "R": "R",
      "G": "G",
      "B": "B",
      "A": "A",
      "HEX": "HEX",
      "Color Picker": "Färgväljaren",
      "unset": "ställ tillbaka",
      "checked": "kontrollerade",
      "{value}, Color": "{value}, Färg",
      "Color not set": "Färg inte inställd"
    },
    "cs-CZ": {
      "Swatches": "Vzorníky",
      "R": "R",
      "G": "G",
      "B": "B",
      "A": "A",
      "HEX": "HEX",
      "Color Picker": "Výběr barvy",
      "unset": "nenastaveno",
      "checked": "zkontrolováno",
      "{value}, Color": "{value}, Barva",
      "Color not set": "Barva není nastavena"
    },
    "pl-PL": {
      "Swatches": "Próbki",
      "R": "R",
      "G": "G",
      "B": "B",
      "A": "A",
      "HEX": "HEX",
      "Color Picker": "Próbnik kolorów",
      "unset": "usuń ustawienie",
      "checked": "sprawdzono",
      "{value}, Color": "{value}, kolor",
      "Color not set": "Nie ustawiono koloru"
    },
    "ru-RU": {
      "Swatches": "Цветовые образцы",
      "R": "R",
      "G": "G",
      "B": "B",
      "A": "A",
      "HEX": "HEX",
      "Color Picker": "Палитра цветов",
      "unset": "не задано",
      "checked": "проверено",
      "{value}, Color": "{value}, цвет",
      "Color not set": "Цвет не задан"
    },
    "tr-TR": {
      "Swatches": "Renk Örnekleri",
      "R": "R",
      "G": "G",
      "B": "B",
      "A": "A",
      "HEX": "HEX",
      "Color Picker": "Renk Seçici",
      "unset": "ayarı kaldır",
      "checked": "denetlendi",
      "{value}, Color": "{value}, Renk",
      "Color not set": "Renk ayarlanmadı"
    }
  };

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons.extend(strings, {
    'coral-component-colorinput': translations$d
  }); // Expose component on the Coral namespace

  commons._define('coral-colorinput-swatches', ColorInputSwatches);

  commons._define('coral-colorinput-swatch', ColorInputSwatch);

  commons._define('coral-colorinput-slider', ColorInputSlider);

  commons._define('coral-colorinput-colorproperties', ColorInputColorProperties);

  commons._define('coral-colorinput-item', ColorInputItem);

  commons._define('coral-colorinput', ColorInput);

  ColorInput.Item = ColorInputItem;
  ColorInput.Swatches = ColorInputSwatches;
  ColorInput.Swatch = ColorInputSwatch;
  ColorInput.Slider = ColorInputSlider;
  ColorInput.ColorProperties = ColorInputColorProperties;

  /**
   * Copyright 2021 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var ColorFormats = {
    HSL: "hsl",
    HSV: "hsv",
    RGB: "rgb",
    PRGB: "prgb",
    HEX: "hex",
    HEX3: "hex3",
    HEX4: "hex4",
    HEX8: "hex8",
    NAME: "name"
  };

  var template$x = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var data = data_0 = typeof data_0 === "undefined" ? {} : data_0;
    data = data_0;
    var uid = data.commons.getUID();
    data_0 = data;
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    data = data_0;
    var uidBtn = data.commons.getUID();
    data_0 = data;
    var el3 = document.createTextNode("\n");
    frag.appendChild(el3);
    data = data_0;
    var uidInput = data.commons.getUID();
    data_0 = data;
    var el5 = document.createTextNode("\n");
    frag.appendChild(el5);
    var el6 = this["input"] = document.createElement("input", "coral-textfield");
    el6.setAttribute("handle", "input");
    el6.id = "#" + uidInput;
    el6.setAttribute("is", "coral-textfield");
    el6.className += " _coral-ColorPicker-input";
    el6.setAttribute("type", "text");
    el6.setAttribute("value", "");
    el6.setAttribute("role", "combobox");
    el6.setAttribute("aria-autocomplete", "none");
    el6.setAttribute("aria-haspopup", "dialog");
    el6.setAttribute("aria-expanded", "false");
    el6.setAttribute("aria-controls", uid);
    frag.appendChild(el6);
    var el7 = document.createTextNode("\n");
    frag.appendChild(el7);
    var el8 = this["buttonWrapper"] = document.createElement("div");
    el8.className += " _coral-ColorPicker-buttonWrapper";
    el8.setAttribute("handle", "buttonWrapper");
    el8.setAttribute("role", "presentation");
    var el9 = document.createTextNode("\n  ");
    el8.appendChild(el9);
    var el10 = this["colorPreview"] = document.createElement("button", "coral-button");
    el10.id = uidBtn;
    el10.setAttribute("handle", "colorPreview");
    el10.setAttribute("is", "coral-button");
    el10.setAttribute("variant", "_custom");
    el10.className += " _coral-FieldButton _coral-ColorPicker-button _coral-ColorPicker-preview";
    el10.setAttribute("type", "button");
    el10.setAttribute("aria-haspopup", "dialog");
    el10.setAttribute("aria-expanded", "false");
    el10.setAttribute("aria-controls", uid);
    el8.appendChild(el10);
    var el11 = document.createTextNode("\n  ");
    el8.appendChild(el11);
    data = data_0;
    this.colorPreview.label.classList.add('u-coral-screenReaderOnly');
    this.colorPreview.label.innerText = data.i18n.get('Color Picker');
    this.colorPreview.label.id = uid + '-coral-button-label';
    data_0 = data;
    var el13 = document.createTextNode("\n");
    el8.appendChild(el13);
    frag.appendChild(el8);
    var el14 = document.createTextNode("\n");
    frag.appendChild(el14);
    var el15 = this["overlay"] = document.createElement("coral-popover");
    el15.className += " _coral-ColorPicker-overlay";
    el15.setAttribute("target", "#" + uidBtn);
    el15.setAttribute("variant", "info");
    el15.setAttribute("role", "dialog");
    el15.setAttribute("focusonshow", "on");
    el15.setAttribute("trapfocus", "on");
    el15.setAttribute("handle", "overlay");
    el15.setAttribute("placement", "right");
    el15.id = uid;
    el15.setAttribute("aria-label", data_0["i18n"]["get"]('Color Picker'));
    el15.setAttribute("aria-live", "off");
    var el16 = document.createTextNode("\n  ");
    el15.appendChild(el16);
    var el17 = this["propertiesView"] = document.createElement("coral-colorpicker-colorproperties");
    el17.setAttribute("handle", "propertiesView");
    el15.appendChild(el17);
    var el18 = document.createTextNode("\n");
    el15.appendChild(el18);
    frag.appendChild(el15);
    return frag;
  };

  /**
   * Take input from [0, n] and return it as [0, 1]
   * @hidden
   */
  function bound01(n, max) {
    if (isOnePointZero(n)) {
      n = '100%';
    }

    var isPercent = isPercentage(n);
    n = max === 360 ? n : Math.min(max, Math.max(0, parseFloat(n))); // Automatically convert percentage into number

    if (isPercent) {
      n = parseInt(String(n * max), 10) / 100;
    } // Handle floating point rounding errors


    if (Math.abs(n - max) < 0.000001) {
      return 1;
    } // Convert into [0, 1] range if it isn't already


    if (max === 360) {
      // If n is a hue given in degrees,
      // wrap around out-of-range values into [0, 360] range
      // then convert into [0, 1].
      n = (n < 0 ? n % max + max : n % max) / parseFloat(String(max));
    } else {
      // If n not a hue given in degrees
      // Convert into [0, 1] range if it isn't already.
      n = n % max / parseFloat(String(max));
    }

    return n;
  }
  /**
   * Force a number between 0 and 1
   * @hidden
   */

  function clamp01(val) {
    return Math.min(1, Math.max(0, val));
  }
  /**
   * Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1
   * <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>
   * @hidden
   */

  function isOnePointZero(n) {
    return typeof n === 'string' && n.indexOf('.') !== -1 && parseFloat(n) === 1;
  }
  /**
   * Check to see if string passed in is a percentage
   * @hidden
   */

  function isPercentage(n) {
    return typeof n === 'string' && n.indexOf('%') !== -1;
  }
  /**
   * Return a valid alpha value [0,1] with all invalid values being set to 1
   * @hidden
   */

  function boundAlpha(a) {
    a = parseFloat(a);

    if (isNaN(a) || a < 0 || a > 1) {
      a = 1;
    }

    return a;
  }
  /**
   * Replace a decimal with it's percentage value
   * @hidden
   */

  function convertToPercentage(n) {
    if (n <= 1) {
      return Number(n) * 100 + "%";
    }

    return n;
  }
  /**
   * Force a hex value to have 2 characters
   * @hidden
   */

  function pad2(c) {
    return c.length === 1 ? '0' + c : String(c);
  }

  // <http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript>

  /**
   * Handle bounds / percentage checking to conform to CSS color spec
   * <http://www.w3.org/TR/css3-color/>
   * *Assumes:* r, g, b in [0, 255] or [0, 1]
   * *Returns:* { r, g, b } in [0, 255]
   */

  function rgbToRgb(r, g, b) {
    return {
      r: bound01(r, 255) * 255,
      g: bound01(g, 255) * 255,
      b: bound01(b, 255) * 255
    };
  }
  /**
   * Converts an RGB color value to HSL.
   * *Assumes:* r, g, and b are contained in [0, 255] or [0, 1]
   * *Returns:* { h, s, l } in [0,1]
   */

  function rgbToHsl(r, g, b) {
    r = bound01(r, 255);
    g = bound01(g, 255);
    b = bound01(b, 255);
    var max = Math.max(r, g, b);
    var min = Math.min(r, g, b);
    var h = 0;
    var s = 0;
    var l = (max + min) / 2;

    if (max === min) {
      s = 0;
      h = 0; // achromatic
    } else {
      var d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

      switch (max) {
        case r:
          h = (g - b) / d + (g < b ? 6 : 0);
          break;

        case g:
          h = (b - r) / d + 2;
          break;

        case b:
          h = (r - g) / d + 4;
          break;
      }

      h /= 6;
    }

    return {
      h: h,
      s: s,
      l: l
    };
  }

  function hue2rgb(p, q, t) {
    if (t < 0) {
      t += 1;
    }

    if (t > 1) {
      t -= 1;
    }

    if (t < 1 / 6) {
      return p + (q - p) * (6 * t);
    }

    if (t < 1 / 2) {
      return q;
    }

    if (t < 2 / 3) {
      return p + (q - p) * (2 / 3 - t) * 6;
    }

    return p;
  }
  /**
   * Converts an HSL color value to RGB.
   *
   * *Assumes:* h is contained in [0, 1] or [0, 360] and s and l are contained [0, 1] or [0, 100]
   * *Returns:* { r, g, b } in the set [0, 255]
   */


  function hslToRgb(h, s, l) {
    var r;
    var g;
    var b;
    h = bound01(h, 360);
    s = bound01(s, 100);
    l = bound01(l, 100);

    if (s === 0) {
      // achromatic
      g = l;
      b = l;
      r = l;
    } else {
      var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      var p = 2 * l - q;
      r = hue2rgb(p, q, h + 1 / 3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1 / 3);
    }

    return {
      r: r * 255,
      g: g * 255,
      b: b * 255
    };
  }
  /**
   * Converts an RGB color value to HSV
   *
   * *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]
   * *Returns:* { h, s, v } in [0,1]
   */

  function rgbToHsv(r, g, b) {
    r = bound01(r, 255);
    g = bound01(g, 255);
    b = bound01(b, 255);
    var max = Math.max(r, g, b);
    var min = Math.min(r, g, b);
    var h = 0;
    var v = max;
    var d = max - min;
    var s = max === 0 ? 0 : d / max;

    if (max === min) {
      h = 0; // achromatic
    } else {
      switch (max) {
        case r:
          h = (g - b) / d + (g < b ? 6 : 0);
          break;

        case g:
          h = (b - r) / d + 2;
          break;

        case b:
          h = (r - g) / d + 4;
          break;
      }

      h /= 6;
    }

    return {
      h: h,
      s: s,
      v: v
    };
  }
  /**
   * Converts an HSV color value to RGB.
   *
   * *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]
   * *Returns:* { r, g, b } in the set [0, 255]
   */

  function hsvToRgb(h, s, v) {
    h = bound01(h, 360) * 6;
    s = bound01(s, 100);
    v = bound01(v, 100);
    var i = Math.floor(h);
    var f = h - i;
    var p = v * (1 - s);
    var q = v * (1 - f * s);
    var t = v * (1 - (1 - f) * s);
    var mod = i % 6;
    var r = [v, q, p, p, t, v][mod];
    var g = [t, v, v, q, p, p][mod];
    var b = [p, p, t, v, v, q][mod];
    return {
      r: r * 255,
      g: g * 255,
      b: b * 255
    };
  }
  /**
   * Converts an RGB color to hex
   *
   * Assumes r, g, and b are contained in the set [0, 255]
   * Returns a 3 or 6 character hex
   */

  function rgbToHex(r, g, b, allow3Char) {
    var hex = [pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16))]; // Return a 3 character hex if possible

    if (allow3Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1))) {
      return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
    }

    return hex.join('');
  }
  /**
   * Converts an RGBA color plus alpha transparency to hex
   *
   * Assumes r, g, b are contained in the set [0, 255] and
   * a in [0, 1]. Returns a 4 or 8 character rgba hex
   */
  // eslint-disable-next-line max-params

  function rgbaToHex(r, g, b, a, allow4Char) {
    var hex = [pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16)), pad2(convertDecimalToHex(a))]; // Return a 4 character hex if possible

    if (allow4Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1)) && hex[3].startsWith(hex[3].charAt(1))) {
      return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
    }

    return hex.join('');
  }
  /** Converts a decimal to a hex value */

  function convertDecimalToHex(d) {
    return Math.round(parseFloat(d) * 255).toString(16);
  }
  /** Converts a hex value to a decimal */

  function convertHexToDecimal(h) {
    return parseIntFromHex(h) / 255;
  }
  /** Parse a base-16 hex value into a base-10 integer */

  function parseIntFromHex(val) {
    return parseInt(val, 16);
  }
  function numberInputToObject(color) {
    return {
      r: color >> 16,
      g: (color & 0xff00) >> 8,
      b: color & 0xff
    };
  }

  // https://github.com/bahamas10/css-color-names/blob/master/css-color-names.json

  /**
   * @hidden
   */
  var names = {
    aliceblue: '#f0f8ff',
    antiquewhite: '#faebd7',
    aqua: '#00ffff',
    aquamarine: '#7fffd4',
    azure: '#f0ffff',
    beige: '#f5f5dc',
    bisque: '#ffe4c4',
    black: '#000000',
    blanchedalmond: '#ffebcd',
    blue: '#0000ff',
    blueviolet: '#8a2be2',
    brown: '#a52a2a',
    burlywood: '#deb887',
    cadetblue: '#5f9ea0',
    chartreuse: '#7fff00',
    chocolate: '#d2691e',
    coral: '#ff7f50',
    cornflowerblue: '#6495ed',
    cornsilk: '#fff8dc',
    crimson: '#dc143c',
    cyan: '#00ffff',
    darkblue: '#00008b',
    darkcyan: '#008b8b',
    darkgoldenrod: '#b8860b',
    darkgray: '#a9a9a9',
    darkgreen: '#006400',
    darkgrey: '#a9a9a9',
    darkkhaki: '#bdb76b',
    darkmagenta: '#8b008b',
    darkolivegreen: '#556b2f',
    darkorange: '#ff8c00',
    darkorchid: '#9932cc',
    darkred: '#8b0000',
    darksalmon: '#e9967a',
    darkseagreen: '#8fbc8f',
    darkslateblue: '#483d8b',
    darkslategray: '#2f4f4f',
    darkslategrey: '#2f4f4f',
    darkturquoise: '#00ced1',
    darkviolet: '#9400d3',
    deeppink: '#ff1493',
    deepskyblue: '#00bfff',
    dimgray: '#696969',
    dimgrey: '#696969',
    dodgerblue: '#1e90ff',
    firebrick: '#b22222',
    floralwhite: '#fffaf0',
    forestgreen: '#228b22',
    fuchsia: '#ff00ff',
    gainsboro: '#dcdcdc',
    ghostwhite: '#f8f8ff',
    goldenrod: '#daa520',
    gold: '#ffd700',
    gray: '#808080',
    green: '#008000',
    greenyellow: '#adff2f',
    grey: '#808080',
    honeydew: '#f0fff0',
    hotpink: '#ff69b4',
    indianred: '#cd5c5c',
    indigo: '#4b0082',
    ivory: '#fffff0',
    khaki: '#f0e68c',
    lavenderblush: '#fff0f5',
    lavender: '#e6e6fa',
    lawngreen: '#7cfc00',
    lemonchiffon: '#fffacd',
    lightblue: '#add8e6',
    lightcoral: '#f08080',
    lightcyan: '#e0ffff',
    lightgoldenrodyellow: '#fafad2',
    lightgray: '#d3d3d3',
    lightgreen: '#90ee90',
    lightgrey: '#d3d3d3',
    lightpink: '#ffb6c1',
    lightsalmon: '#ffa07a',
    lightseagreen: '#20b2aa',
    lightskyblue: '#87cefa',
    lightslategray: '#778899',
    lightslategrey: '#778899',
    lightsteelblue: '#b0c4de',
    lightyellow: '#ffffe0',
    lime: '#00ff00',
    limegreen: '#32cd32',
    linen: '#faf0e6',
    magenta: '#ff00ff',
    maroon: '#800000',
    mediumaquamarine: '#66cdaa',
    mediumblue: '#0000cd',
    mediumorchid: '#ba55d3',
    mediumpurple: '#9370db',
    mediumseagreen: '#3cb371',
    mediumslateblue: '#7b68ee',
    mediumspringgreen: '#00fa9a',
    mediumturquoise: '#48d1cc',
    mediumvioletred: '#c71585',
    midnightblue: '#191970',
    mintcream: '#f5fffa',
    mistyrose: '#ffe4e1',
    moccasin: '#ffe4b5',
    navajowhite: '#ffdead',
    navy: '#000080',
    oldlace: '#fdf5e6',
    olive: '#808000',
    olivedrab: '#6b8e23',
    orange: '#ffa500',
    orangered: '#ff4500',
    orchid: '#da70d6',
    palegoldenrod: '#eee8aa',
    palegreen: '#98fb98',
    paleturquoise: '#afeeee',
    palevioletred: '#db7093',
    papayawhip: '#ffefd5',
    peachpuff: '#ffdab9',
    peru: '#cd853f',
    pink: '#ffc0cb',
    plum: '#dda0dd',
    powderblue: '#b0e0e6',
    purple: '#800080',
    rebeccapurple: '#663399',
    red: '#ff0000',
    rosybrown: '#bc8f8f',
    royalblue: '#4169e1',
    saddlebrown: '#8b4513',
    salmon: '#fa8072',
    sandybrown: '#f4a460',
    seagreen: '#2e8b57',
    seashell: '#fff5ee',
    sienna: '#a0522d',
    silver: '#c0c0c0',
    skyblue: '#87ceeb',
    slateblue: '#6a5acd',
    slategray: '#708090',
    slategrey: '#708090',
    snow: '#fffafa',
    springgreen: '#00ff7f',
    steelblue: '#4682b4',
    tan: '#d2b48c',
    teal: '#008080',
    thistle: '#d8bfd8',
    tomato: '#ff6347',
    turquoise: '#40e0d0',
    violet: '#ee82ee',
    wheat: '#f5deb3',
    white: '#ffffff',
    whitesmoke: '#f5f5f5',
    yellow: '#ffff00',
    yellowgreen: '#9acd32'
  };

  /**
   * Given a string or object, convert that input to RGB
   *
   * Possible string inputs:
   * ```
   * "red"
   * "#f00" or "f00"
   * "#ff0000" or "ff0000"
   * "#ff000000" or "ff000000"
   * "rgb 255 0 0" or "rgb (255, 0, 0)"
   * "rgb 1.0 0 0" or "rgb (1, 0, 0)"
   * "rgba (255, 0, 0, 1)" or "rgba 255, 0, 0, 1"
   * "rgba (1.0, 0, 0, 1)" or "rgba 1.0, 0, 0, 1"
   * "hsl(0, 100%, 50%)" or "hsl 0 100% 50%"
   * "hsla(0, 100%, 50%, 1)" or "hsla 0 100% 50%, 1"
   * "hsv(0, 100%, 100%)" or "hsv 0 100% 100%"
   * ```
   */

  function inputToRGB(color) {
    var rgb = {
      r: 0,
      g: 0,
      b: 0
    };
    var a = 1;
    var s = null;
    var v = null;
    var l = null;
    var ok = false;
    var format = false;

    if (typeof color === 'string') {
      color = stringInputToObject(color);
    }

    if (_typeof(color) === 'object') {
      if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
        rgb = rgbToRgb(color.r, color.g, color.b);
        ok = true;
        format = String(color.r).substr(-1) === '%' ? 'prgb' : 'rgb';
      } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
        s = convertToPercentage(color.s);
        v = convertToPercentage(color.v);
        rgb = hsvToRgb(color.h, s, v);
        ok = true;
        format = 'hsv';
      } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
        s = convertToPercentage(color.s);
        l = convertToPercentage(color.l);
        rgb = hslToRgb(color.h, s, l);
        ok = true;
        format = 'hsl';
      }

      if (Object.prototype.hasOwnProperty.call(color, 'a')) {
        a = color.a;
      }
    }

    a = boundAlpha(a);
    return {
      ok: ok,
      format: color.format || format,
      r: Math.min(255, Math.max(rgb.r, 0)),
      g: Math.min(255, Math.max(rgb.g, 0)),
      b: Math.min(255, Math.max(rgb.b, 0)),
      a: a
    };
  } // <http://www.w3.org/TR/css3-values/#integers>

  var CSS_INTEGER = '[-\\+]?\\d+%?'; // <http://www.w3.org/TR/css3-values/#number-value>

  var CSS_NUMBER = '[-\\+]?\\d*\\.\\d+%?'; // Allow positive/negative integer/number.  Don't capture the either/or, just the entire outcome.

  var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")"; // Actual matching.
  // Parentheses and commas are optional, but not required.
  // Whitespace can take the place of commas or opening paren

  var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
  var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
  var matchers = {
    CSS_UNIT: new RegExp(CSS_UNIT),
    rgb: new RegExp('rgb' + PERMISSIVE_MATCH3),
    rgba: new RegExp('rgba' + PERMISSIVE_MATCH4),
    hsl: new RegExp('hsl' + PERMISSIVE_MATCH3),
    hsla: new RegExp('hsla' + PERMISSIVE_MATCH4),
    hsv: new RegExp('hsv' + PERMISSIVE_MATCH3),
    hsva: new RegExp('hsva' + PERMISSIVE_MATCH4),
    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
  };
  /**
   * Permissive string parsing.  Take in a number of formats, and output an object
   * based on detected format.  Returns `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}`
   */

  function stringInputToObject(color) {
    color = color.trim().toLowerCase();

    if (color.length === 0) {
      return false;
    }

    var named = false;

    if (names[color]) {
      color = names[color];
      named = true;
    } else if (color === 'transparent') {
      return {
        r: 0,
        g: 0,
        b: 0,
        a: 0,
        format: 'name'
      };
    } // Try to match string input using regular expressions.
    // Keep most of the number bounding out of this function - don't worry about [0,1] or [0,100] or [0,360]
    // Just return an object and let the conversion functions handle that.
    // This way the result will be the same whether the tinycolor is initialized with string or object.


    var match = matchers.rgb.exec(color);

    if (match) {
      return {
        r: match[1],
        g: match[2],
        b: match[3]
      };
    }

    match = matchers.rgba.exec(color);

    if (match) {
      return {
        r: match[1],
        g: match[2],
        b: match[3],
        a: match[4]
      };
    }

    match = matchers.hsl.exec(color);

    if (match) {
      return {
        h: match[1],
        s: match[2],
        l: match[3]
      };
    }

    match = matchers.hsla.exec(color);

    if (match) {
      return {
        h: match[1],
        s: match[2],
        l: match[3],
        a: match[4]
      };
    }

    match = matchers.hsv.exec(color);

    if (match) {
      return {
        h: match[1],
        s: match[2],
        v: match[3]
      };
    }

    match = matchers.hsva.exec(color);

    if (match) {
      return {
        h: match[1],
        s: match[2],
        v: match[3],
        a: match[4]
      };
    }

    match = matchers.hex8.exec(color);

    if (match) {
      return {
        r: parseIntFromHex(match[1]),
        g: parseIntFromHex(match[2]),
        b: parseIntFromHex(match[3]),
        a: convertHexToDecimal(match[4]),
        format: named ? 'name' : 'hex8'
      };
    }

    match = matchers.hex6.exec(color);

    if (match) {
      return {
        r: parseIntFromHex(match[1]),
        g: parseIntFromHex(match[2]),
        b: parseIntFromHex(match[3]),
        format: named ? 'name' : 'hex'
      };
    }

    match = matchers.hex4.exec(color);

    if (match) {
      return {
        r: parseIntFromHex(match[1] + match[1]),
        g: parseIntFromHex(match[2] + match[2]),
        b: parseIntFromHex(match[3] + match[3]),
        a: convertHexToDecimal(match[4] + match[4]),
        format: named ? 'name' : 'hex8'
      };
    }

    match = matchers.hex3.exec(color);

    if (match) {
      return {
        r: parseIntFromHex(match[1] + match[1]),
        g: parseIntFromHex(match[2] + match[2]),
        b: parseIntFromHex(match[3] + match[3]),
        format: named ? 'name' : 'hex'
      };
    }

    return false;
  }
  /**
   * Check to see if it looks like a CSS unit
   * (see `matchers` above for definition).
   */

  function isValidCSSUnit(color) {
    return Boolean(matchers.CSS_UNIT.exec(String(color)));
  }

  var TinyColor =
  /** @class */
  function () {
    function TinyColor(color, opts) {
      if (color === void 0) {
        color = '';
      }

      if (opts === void 0) {
        opts = {};
      }

      var _a; // If input is already a tinycolor, return itself


      if (color instanceof TinyColor) {
        // eslint-disable-next-line no-constructor-return
        return color;
      }

      if (typeof color === 'number') {
        color = numberInputToObject(color);
      }

      this.originalInput = color;
      var rgb = inputToRGB(color);
      this.originalInput = color;
      this.r = rgb.r;
      this.g = rgb.g;
      this.b = rgb.b;
      this.a = rgb.a;
      this.roundA = Math.round(100 * this.a) / 100;
      this.format = (_a = opts.format) !== null && _a !== void 0 ? _a : rgb.format;
      this.gradientType = opts.gradientType; // Don't let the range of [0,255] come back in [0,1].
      // Potentially lose a little bit of precision here, but will fix issues where
      // .5 gets interpreted as half of the total, instead of half of 1
      // If it was supposed to be 128, this was already taken care of by `inputToRgb`

      if (this.r < 1) {
        this.r = Math.round(this.r);
      }

      if (this.g < 1) {
        this.g = Math.round(this.g);
      }

      if (this.b < 1) {
        this.b = Math.round(this.b);
      }

      this.isValid = rgb.ok;
    }

    TinyColor.prototype.isDark = function () {
      return this.getBrightness() < 128;
    };

    TinyColor.prototype.isLight = function () {
      return !this.isDark();
    };
    /**
     * Returns the perceived brightness of the color, from 0-255.
     */


    TinyColor.prototype.getBrightness = function () {
      // http://www.w3.org/TR/AERT#color-contrast
      var rgb = this.toRgb();
      return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
    };
    /**
     * Returns the perceived luminance of a color, from 0-1.
     */


    TinyColor.prototype.getLuminance = function () {
      // http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
      var rgb = this.toRgb();
      var R;
      var G;
      var B;
      var RsRGB = rgb.r / 255;
      var GsRGB = rgb.g / 255;
      var BsRGB = rgb.b / 255;

      if (RsRGB <= 0.03928) {
        R = RsRGB / 12.92;
      } else {
        // eslint-disable-next-line prefer-exponentiation-operator
        R = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
      }

      if (GsRGB <= 0.03928) {
        G = GsRGB / 12.92;
      } else {
        // eslint-disable-next-line prefer-exponentiation-operator
        G = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
      }

      if (BsRGB <= 0.03928) {
        B = BsRGB / 12.92;
      } else {
        // eslint-disable-next-line prefer-exponentiation-operator
        B = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
      }

      return 0.2126 * R + 0.7152 * G + 0.0722 * B;
    };
    /**
     * Returns the alpha value of a color, from 0-1.
     */


    TinyColor.prototype.getAlpha = function () {
      return this.a;
    };
    /**
     * Sets the alpha value on the current color.
     *
     * @param alpha - The new alpha value. The accepted range is 0-1.
     */


    TinyColor.prototype.setAlpha = function (alpha) {
      this.a = boundAlpha(alpha);
      this.roundA = Math.round(100 * this.a) / 100;
      return this;
    };
    /**
     * Returns the object as a HSVA object.
     */


    TinyColor.prototype.toHsv = function () {
      var hsv = rgbToHsv(this.r, this.g, this.b);
      return {
        h: hsv.h * 360,
        s: hsv.s,
        v: hsv.v,
        a: this.a
      };
    };
    /**
     * Returns the hsva values interpolated into a string with the following format:
     * "hsva(xxx, xxx, xxx, xx)".
     */


    TinyColor.prototype.toHsvString = function () {
      var hsv = rgbToHsv(this.r, this.g, this.b);
      var h = Math.round(hsv.h * 360);
      var s = Math.round(hsv.s * 100);
      var v = Math.round(hsv.v * 100);
      return this.a === 1 ? "hsv(" + h + ", " + s + "%, " + v + "%)" : "hsva(" + h + ", " + s + "%, " + v + "%, " + this.roundA + ")";
    };
    /**
     * Returns the object as a HSLA object.
     */


    TinyColor.prototype.toHsl = function () {
      var hsl = rgbToHsl(this.r, this.g, this.b);
      return {
        h: hsl.h * 360,
        s: hsl.s,
        l: hsl.l,
        a: this.a
      };
    };
    /**
     * Returns the hsla values interpolated into a string with the following format:
     * "hsla(xxx, xxx, xxx, xx)".
     */


    TinyColor.prototype.toHslString = function () {
      var hsl = rgbToHsl(this.r, this.g, this.b);
      var h = Math.round(hsl.h * 360);
      var s = Math.round(hsl.s * 100);
      var l = Math.round(hsl.l * 100);
      return this.a === 1 ? "hsl(" + h + ", " + s + "%, " + l + "%)" : "hsla(" + h + ", " + s + "%, " + l + "%, " + this.roundA + ")";
    };
    /**
     * Returns the hex value of the color.
     * @param allow3Char will shorten hex value to 3 char if possible
     */


    TinyColor.prototype.toHex = function (allow3Char) {
      if (allow3Char === void 0) {
        allow3Char = false;
      }

      return rgbToHex(this.r, this.g, this.b, allow3Char);
    };
    /**
     * Returns the hex value of the color -with a # appened.
     * @param allow3Char will shorten hex value to 3 char if possible
     */


    TinyColor.prototype.toHexString = function (allow3Char) {
      if (allow3Char === void 0) {
        allow3Char = false;
      }

      return '#' + this.toHex(allow3Char);
    };
    /**
     * Returns the hex 8 value of the color.
     * @param allow4Char will shorten hex value to 4 char if possible
     */


    TinyColor.prototype.toHex8 = function (allow4Char) {
      if (allow4Char === void 0) {
        allow4Char = false;
      }

      return rgbaToHex(this.r, this.g, this.b, this.a, allow4Char);
    };
    /**
     * Returns the hex 8 value of the color -with a # appened.
     * @param allow4Char will shorten hex value to 4 char if possible
     */


    TinyColor.prototype.toHex8String = function (allow4Char) {
      if (allow4Char === void 0) {
        allow4Char = false;
      }

      return '#' + this.toHex8(allow4Char);
    };
    /**
     * Returns the object as a RGBA object.
     */


    TinyColor.prototype.toRgb = function () {
      return {
        r: Math.round(this.r),
        g: Math.round(this.g),
        b: Math.round(this.b),
        a: this.a
      };
    };
    /**
     * Returns the RGBA values interpolated into a string with the following format:
     * "RGBA(xxx, xxx, xxx, xx)".
     */


    TinyColor.prototype.toRgbString = function () {
      var r = Math.round(this.r);
      var g = Math.round(this.g);
      var b = Math.round(this.b);
      return this.a === 1 ? "rgb(" + r + ", " + g + ", " + b + ")" : "rgba(" + r + ", " + g + ", " + b + ", " + this.roundA + ")";
    };
    /**
     * Returns the object as a RGBA object.
     */


    TinyColor.prototype.toPercentageRgb = function () {
      var fmt = function fmt(x) {
        return Math.round(bound01(x, 255) * 100) + "%";
      };

      return {
        r: fmt(this.r),
        g: fmt(this.g),
        b: fmt(this.b),
        a: this.a
      };
    };
    /**
     * Returns the RGBA relative values interpolated into a string
     */


    TinyColor.prototype.toPercentageRgbString = function () {
      var rnd = function rnd(x) {
        return Math.round(bound01(x, 255) * 100);
      };

      return this.a === 1 ? "rgb(" + rnd(this.r) + "%, " + rnd(this.g) + "%, " + rnd(this.b) + "%)" : "rgba(" + rnd(this.r) + "%, " + rnd(this.g) + "%, " + rnd(this.b) + "%, " + this.roundA + ")";
    };
    /**
     * The 'real' name of the color -if there is one.
     */


    TinyColor.prototype.toName = function () {
      if (this.a === 0) {
        return 'transparent';
      }

      if (this.a < 1) {
        return false;
      }

      var hex = '#' + rgbToHex(this.r, this.g, this.b, false);

      for (var _i = 0, _a = Object.entries(names); _i < _a.length; _i++) {
        var _b = _a[_i],
            key = _b[0],
            value = _b[1];

        if (hex === value) {
          return key;
        }
      }

      return false;
    };

    TinyColor.prototype.toString = function (format) {
      var formatSet = Boolean(format);
      format = format !== null && format !== void 0 ? format : this.format;
      var formattedString = false;
      var hasAlpha = this.a < 1 && this.a >= 0;
      var needsAlphaFormat = !formatSet && hasAlpha && (format.startsWith('hex') || format === 'name');

      if (needsAlphaFormat) {
        // Special case for "transparent", all other non-alpha formats
        // will return rgba when there is transparency.
        if (format === 'name' && this.a === 0) {
          return this.toName();
        }

        return this.toRgbString();
      }

      if (format === 'rgb') {
        formattedString = this.toRgbString();
      }

      if (format === 'prgb') {
        formattedString = this.toPercentageRgbString();
      }

      if (format === 'hex' || format === 'hex6') {
        formattedString = this.toHexString();
      }

      if (format === 'hex3') {
        formattedString = this.toHexString(true);
      }

      if (format === 'hex4') {
        formattedString = this.toHex8String(true);
      }

      if (format === 'hex8') {
        formattedString = this.toHex8String();
      }

      if (format === 'name') {
        formattedString = this.toName();
      }

      if (format === 'hsl') {
        formattedString = this.toHslString();
      }

      if (format === 'hsv') {
        formattedString = this.toHsvString();
      }

      return formattedString || this.toHexString();
    };

    TinyColor.prototype.toNumber = function () {
      return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
    };

    TinyColor.prototype.clone = function () {
      return new TinyColor(this.toString());
    };
    /**
     * Lighten the color a given amount. Providing 100 will always return white.
     * @param amount - valid between 1-100
     */


    TinyColor.prototype.lighten = function (amount) {
      if (amount === void 0) {
        amount = 10;
      }

      var hsl = this.toHsl();
      hsl.l += amount / 100;
      hsl.l = clamp01(hsl.l);
      return new TinyColor(hsl);
    };
    /**
     * Brighten the color a given amount, from 0 to 100.
     * @param amount - valid between 1-100
     */


    TinyColor.prototype.brighten = function (amount) {
      if (amount === void 0) {
        amount = 10;
      }

      var rgb = this.toRgb();
      rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
      rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
      rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
      return new TinyColor(rgb);
    };
    /**
     * Darken the color a given amount, from 0 to 100.
     * Providing 100 will always return black.
     * @param amount - valid between 1-100
     */


    TinyColor.prototype.darken = function (amount) {
      if (amount === void 0) {
        amount = 10;
      }

      var hsl = this.toHsl();
      hsl.l -= amount / 100;
      hsl.l = clamp01(hsl.l);
      return new TinyColor(hsl);
    };
    /**
     * Mix the color with pure white, from 0 to 100.
     * Providing 0 will do nothing, providing 100 will always return white.
     * @param amount - valid between 1-100
     */


    TinyColor.prototype.tint = function (amount) {
      if (amount === void 0) {
        amount = 10;
      }

      return this.mix('white', amount);
    };
    /**
     * Mix the color with pure black, from 0 to 100.
     * Providing 0 will do nothing, providing 100 will always return black.
     * @param amount - valid between 1-100
     */


    TinyColor.prototype.shade = function (amount) {
      if (amount === void 0) {
        amount = 10;
      }

      return this.mix('black', amount);
    };
    /**
     * Desaturate the color a given amount, from 0 to 100.
     * Providing 100 will is the same as calling greyscale
     * @param amount - valid between 1-100
     */


    TinyColor.prototype.desaturate = function (amount) {
      if (amount === void 0) {
        amount = 10;
      }

      var hsl = this.toHsl();
      hsl.s -= amount / 100;
      hsl.s = clamp01(hsl.s);
      return new TinyColor(hsl);
    };
    /**
     * Saturate the color a given amount, from 0 to 100.
     * @param amount - valid between 1-100
     */


    TinyColor.prototype.saturate = function (amount) {
      if (amount === void 0) {
        amount = 10;
      }

      var hsl = this.toHsl();
      hsl.s += amount / 100;
      hsl.s = clamp01(hsl.s);
      return new TinyColor(hsl);
    };
    /**
     * Completely desaturates a color into greyscale.
     * Same as calling `desaturate(100)`
     */


    TinyColor.prototype.greyscale = function () {
      return this.desaturate(100);
    };
    /**
     * Spin takes a positive or negative amount within [-360, 360] indicating the change of hue.
     * Values outside of this range will be wrapped into this range.
     */


    TinyColor.prototype.spin = function (amount) {
      var hsl = this.toHsl();
      var hue = (hsl.h + amount) % 360;
      hsl.h = hue < 0 ? 360 + hue : hue;
      return new TinyColor(hsl);
    };
    /**
     * Mix the current color a given amount with another color, from 0 to 100.
     * 0 means no mixing (return current color).
     */


    TinyColor.prototype.mix = function (color, amount) {
      if (amount === void 0) {
        amount = 50;
      }

      var rgb1 = this.toRgb();
      var rgb2 = new TinyColor(color).toRgb();
      var p = amount / 100;
      var rgba = {
        r: (rgb2.r - rgb1.r) * p + rgb1.r,
        g: (rgb2.g - rgb1.g) * p + rgb1.g,
        b: (rgb2.b - rgb1.b) * p + rgb1.b,
        a: (rgb2.a - rgb1.a) * p + rgb1.a
      };
      return new TinyColor(rgba);
    };

    TinyColor.prototype.analogous = function (results, slices) {
      if (results === void 0) {
        results = 6;
      }

      if (slices === void 0) {
        slices = 30;
      }

      var hsl = this.toHsl();
      var part = 360 / slices;
      var ret = [this];

      for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results;) {
        hsl.h = (hsl.h + part) % 360;
        ret.push(new TinyColor(hsl));
      }

      return ret;
    };
    /**
     * taken from https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js
     */


    TinyColor.prototype.complement = function () {
      var hsl = this.toHsl();
      hsl.h = (hsl.h + 180) % 360;
      return new TinyColor(hsl);
    };

    TinyColor.prototype.monochromatic = function (results) {
      if (results === void 0) {
        results = 6;
      }

      var hsv = this.toHsv();
      var h = hsv.h;
      var s = hsv.s;
      var v = hsv.v;
      var res = [];
      var modification = 1 / results;

      while (results--) {
        res.push(new TinyColor({
          h: h,
          s: s,
          v: v
        }));
        v = (v + modification) % 1;
      }

      return res;
    };

    TinyColor.prototype.splitcomplement = function () {
      var hsl = this.toHsl();
      var h = hsl.h;
      return [this, new TinyColor({
        h: (h + 72) % 360,
        s: hsl.s,
        l: hsl.l
      }), new TinyColor({
        h: (h + 216) % 360,
        s: hsl.s,
        l: hsl.l
      })];
    };
    /**
     * Compute how the color would appear on a background
     */


    TinyColor.prototype.onBackground = function (background) {
      var fg = this.toRgb();
      var bg = new TinyColor(background).toRgb();
      return new TinyColor({
        r: bg.r + (fg.r - bg.r) * fg.a,
        g: bg.g + (fg.g - bg.g) * fg.a,
        b: bg.b + (fg.b - bg.b) * fg.a
      });
    };
    /**
     * Alias for `polyad(3)`
     */


    TinyColor.prototype.triad = function () {
      return this.polyad(3);
    };
    /**
     * Alias for `polyad(4)`
     */


    TinyColor.prototype.tetrad = function () {
      return this.polyad(4);
    };
    /**
     * Get polyad colors, like (for 1, 2, 3, 4, 5, 6, 7, 8, etc...)
     * monad, dyad, triad, tetrad, pentad, hexad, heptad, octad, etc...
     */


    TinyColor.prototype.polyad = function (n) {
      var hsl = this.toHsl();
      var h = hsl.h;
      var result = [this];
      var increment = 360 / n;

      for (var i = 1; i < n; i++) {
        result.push(new TinyColor({
          h: (h + i * increment) % 360,
          s: hsl.s,
          l: hsl.l
        }));
      }

      return result;
    };
    /**
     * compare color vs current color
     */


    TinyColor.prototype.equals = function (color) {
      return this.toRgbString() === new TinyColor(color).toRgbString();
    };

    return TinyColor;
  }();

  var ColorUtil = /*#__PURE__*/function () {
    function ColorUtil() {
      _classCallCheck(this, ColorUtil);
    }
    /**
     Utility function to convert a color to Hsl string.
      @param {String} hue
     The hue value  which is preserved in color conversion.
     @param {String} colorString
     The color string
     */


    _createClass(ColorUtil, [{
      key: "toHslString",
      value: function toHslString(hue, colorString) {
        var color = new TinyColor(colorString);
        var hueExp = /(^hs[v|l]a?\()\d{1,3}/;
        return color.toHslString().replace(hueExp, "$1".concat(hue));
      }
      /**
       Utility function to convert a color to Hsv string.
        @param {String} hue
       The hue value  which is preserved in color conversion.
       @param {String} colorString
       The color string
       */

    }, {
      key: "toHsvString",
      value: function toHsvString(hue, colorString) {
        var color = new TinyColor(colorString);
        var hueExp = /(^hs[v|l]a?\()\d{1,3}/;
        return color.toHsvString().replace(hueExp, "$1".concat(hue));
      }
      /**
       Utility function to extract  h,s and v from a color string.
       @param {String} colorString
       The color string
       */

    }, {
      key: "extractHsv",
      value: function extractHsv(colorString) {
        var exp = /^hsva?\((\d{1,3}),\s*(\d{1,3}%),\s*(\d{1,3}%)/;

        if (!colorString.startsWith("hsv")) {
          colorString = new TinyColor(colorString).toHsvString();
        }

        var groups = exp.exec(colorString);
        var h = parseInt(groups[1]);
        var s = parseInt(groups[2]) / 100;
        var v = parseInt(groups[3]) / 100;
        return {
          h: h,
          s: s,
          v: v
        };
      }
      /**
      Utility function to extract hue.
      @param {String} colorString
      The color string
      */

    }, {
      key: "getHue",
      value: function getHue(colorString) {
        if (colorString.startsWith('hs')) {
          var hueExp = /^hs[v|l]a?\((\d{1,3})/;
          var values = hueExp.exec(colorString);

          var _values = _slicedToArray(values, 2),
              h = _values[1];

          return Number(h);
        } else {
          return new TinyColor(colorString).toHsv().h;
        }
      }
      /**
      Utility function to validate given formats in supported formats and return a list of formats.
      Any invalid/unsupported format is ignored.
      @param {Array} formats 
      An  array of formats to validate
      */

    }, {
      key: "getValidFormats",
      value: function getValidFormats(formats) {
        var supportedFormats = Object.values(ColorFormats);
        var validFormats = [];
        formats.forEach(function (value) {
          if (supportedFormats.indexOf(value) !== -1) {
            validFormats.push(value);
          }
        });
        return validFormats;
      }
      /**
      Utility function to convert a color into a desired format.
      @param {String} color 
      The color string
      @param {String} format
      A color format
      */

    }, {
      key: "formatColorString",
      value: function formatColorString(color, format) {
        var hue = this.getHue(color);

        if (format === ColorFormats.HSV) {
          return this.toHsvString(hue, color);
        } else if (format === ColorFormats.HSL) {
          return this.toHslString(hue, color);
        } else {
          return new TinyColor(color).toString(format);
        }
      }
    }]);

    return ColorUtil;
  }();

  var colorUtil = new ColorUtil();

  var CLASSNAME$O = '_coral-ColorPicker';
  /**
   @class Coral.ColorPicker
   @classdesc A ColorPicker component than can be used as a form field to select from a list of color options.
   @htmltag coral-colorpicker
   @extends {HTMLElement}
   @extends {BaseComponent}
   @extends {BaseFormField}
   */

  var ColorPicker = /*#__PURE__*/function (_BaseFormField) {
    _inherits(ColorPicker, _BaseFormField);

    var _super = _createSuper(ColorPicker);

    /** @ignore */
    function ColorPicker() {
      var _this;

      _classCallCheck(this, ColorPicker);

      _this = _super.call(this); // Prepare templates

      _this._elements = {};
      template$x.call(_this._elements, {
        commons: commons,
        i18n: i18n
      });
      var overlay = _this._elements.overlay;
      var overlayId = overlay.id; // Extend form field events

      var events = commons.extend(_this._events, {
        'key:down ._coral-ColorPicker-input:not([readonly])': '_onKeyDown',
        'key:down [handle="colorPreview"]': '_onKeyDown',
        'click [handle="colorPreview"]': '_onColorPreviewClick',
        'key:esc input': '_onKeyEsc',
        'key:enter input': '_onKeyEsc',
        'capture:change  [handle="input"]': '_onColorInputChange',
        'change [handle="propertiesView"]': '_onPropertyChange'
      }); // Overlay

      events["global:capture:coral-overlay:beforeopen #".concat(overlayId)] = '_beforeOverlayOpen';
      events["global:capture:coral-overlay:close #".concat(overlayId)] = '_onOverlayClose';
      events["global:key:esc #".concat(overlayId)] = '_onKeyEsc'; // Events

      _this._delegateEvents(events);

      _this.value = "";
      _this._format = ColorFormats.HSL;
      _this._sendChaneEvent = _this._chaneEventDebounced();
      return _this;
    }
    /** @ignore */


    _createClass(ColorPicker, [{
      key: "connectedCallback",
      value: function connectedCallback() {
        _get(_getPrototypeOf(ColorPicker.prototype), "connectedCallback", this).call(this);

        var overlay = this._elements.overlay; // Cannot be open by default when rendered

        overlay.removeAttribute('open'); // Restore in DOM

        if (overlay._parent) {
          overlay._parent.appendChild(overlay);
        }
      }
      /** @ignore */

    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        _get(_getPrototypeOf(ColorPicker.prototype), "disconnectedCallback", this).call(this);

        var overlay = this._elements.overlay; // In case it was moved out don't forget to remove it

        if (!this.contains(overlay)) {
          overlay._parent = overlay._repositioned ? document.body : this;
          overlay.remove();
        }
      }
      /** @ignore */

    }, {
      key: "render",
      value: function render() {
        _get(_getPrototypeOf(ColorPicker.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$O);
        this.setAttribute('role', 'group');
        var frag = document.createDocumentFragment(); // Render template

        frag.appendChild(this._elements.input);
        frag.appendChild(this._elements.buttonWrapper);
        frag.appendChild(this._elements.overlay); // Support cloneNode

        while (this.firstChild) {
          var child = this.firstChild;

          if (child.nodeType === Node.ELEMENT_NODE && child.hasAttribute('handle')) {
            this.removeChild(child);
          } else {
            frag.appendChild(child);
          }
        }

        this.appendChild(frag); // These should be used to set a property since property handler aren't called until elements are attached to dom.
        // Attribute values are delivered to change-listeners even if element isn't attached to dom yet, so attributes 
        // can be set to e.g. this._elements.colorPreview.

        this._input = this.querySelector("[handle='input']");
        this._preview = this.querySelector("[handle='colorPreview']");
        this._overlay = this.querySelector("[handle='overlay']");

        this._overlay.setAttribute('aria-live', 'off');

        this._properties = this._overlay.querySelector("[handle='propertiesView']");

        this._update(this._value);
      }
      /** @ignore */

    }, {
      key: "_update",

      /**  @private */
      value: function _update(value) {
        if (this.value === value) {
          return;
        } // sync UI for empty value


        this.classList[value == "" ? 'add' : 'remove']('_coral-ColorPicker--novalue');

        this._elements.colorPreview.classList[value == "" ? 'add' : 'remove']('_coral-ColorPicker-preview--novalue'); // Empty value isn't invalid.


        var color = new TinyColor(value);
        var isInvalid = value !== "" && !color.isValid;
        this[isInvalid ? 'setAttribute' : 'removeAttribute']('invalid', "true");

        this._elements.input[isInvalid ? 'setAttribute' : 'removeAttribute']('invalid', "true");

        if (color.isValid && (!this._formats || this._formats.indexOf(color.format) !== -1)) {
          this._format = color.format;
        }

        this._value = value == "" || !color.isValid ? value : colorUtil.formatColorString(value, this._format);
        this._elements.input.value = this._value;

        this._elements.propertiesView.setAttribute('color', this._value);

        this._elements.colorPreview.style["background-color"] = new TinyColor(this._value).toHslString();
      }
    }, {
      key: "_debounce",
      value: function _debounce(func) {
        var _this2 = this;

        var timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;
        var timer;
        return function () {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          clearTimeout(timer);
          timer = setTimeout(function () {
            func.apply(_this2, args);
          }, timeout);
        };
      }
    }, {
      key: "_chaneEventDebounced",
      value: function _chaneEventDebounced() {
        var self = this;
        return this._debounce(function () {
          self.trigger('change');
        }, 1000);
      }
      /**  @private */

    }, {
      key: "_change",
      value: function _change(color) {
        this._update(color);

        this._sendChaneEvent();
      }
      /***************** Interaction handlers***********/

      /**  @private */

    }, {
      key: "_onKeyDown",
      value: function _onKeyDown(event) {
        event.stopPropagation(); // restore focus to appropriate element when overlay closes

        this._elements.overlay.returnFocusTo(event.matchedTarget);

        this._elements.overlay.open = true;
      }
      /**  @private */

    }, {
      key: "_onKeyEsc",
      value: function _onKeyEsc(event) {
        if (!this._elements.overlay.open) {
          return;
        }

        event.stopPropagation();
        this._elements.overlay.open = false;
      }
      /**  @private */

    }, {
      key: "_onColorPreviewClick",
      value: function _onColorPreviewClick(event) {
        // restore focus to appropriate element when overlay closes
        this._elements.overlay.returnFocusTo(event.matchedTarget);
      }
      /**  @private */

    }, {
      key: "_beforeOverlayOpen",
      value: function _beforeOverlayOpen() {
        // set aria-expanded state
        this._elements.input.setAttribute('aria-expanded', true);

        this._elements.colorPreview.setAttribute('aria-expanded', true);
      }
    }, {
      key: "_onOverlayClose",
      value: function _onOverlayClose() {
        // set aria-expanded state
        this._elements.input.setAttribute('aria-expanded', true);

        this._elements.colorPreview.setAttribute('aria-expanded', false);
      }
      /**  @private */

    }, {
      key: "_onColorInputChange",
      value: function _onColorInputChange(event) {
        this._update(this._input.value);
      }
      /**  @private */

    }, {
      key: "_onPropertyChange",
      value: function _onPropertyChange(event) {
        event.stopImmediatePropagation();

        this._change(this._properties.color);
      }
    }, {
      key: "label",

      /**   
      The ColorPicker label.
      @default 'Select Color'
      @type {String}
      @htmlattribute label
      @htmlattributereflected
      */
      get: function get() {
        return this._label || i18n.get('Color Picker');
      },
      set: function set(value) {
        this._label = value;

        this._reflectAttribute('label', this.label);

        this._elements.input.setAttribute('aria-label', this.label);
      }
      /**
       Inherited from {@link BaseFormField#labelledBy}.
       */

    }, {
      key: "labelledBy",
      get: function get() {
        return _get(_getPrototypeOf(ColorPicker.prototype), "labelledBy", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(ColorPicker.prototype), "labelledBy", value, this, true); // Sync input aria-labelledby


        this._elements.input[value ? 'setAttribute' : 'removeAttribute']('aria-labelledby', value); // in case the user focuses the buttons, he will still get a notion of the usage of the component


        if (this.labelledBy) {
          this.setAttribute('aria-labelledby', this.labelledBy);

          this._elements.colorPreview.setAttribute('aria-labelledby', [this.labelledBy, this._elements.colorPreview.label.id].join(' '));
        } else {
          this.removeAttribute('aria-labelledby');

          this._elements.colorPreview.removeAttribute('aria-labelledby');
        }
      }
      /**
       Whether this field is disabled or not.
       @type {Boolean}
       @default false
       @htmlattribute disabled
       @htmlattributereflected
       */

    }, {
      key: "disabled",
      get: function get() {
        return this._disabled || false;
      },
      set: function set(value) {
        this._disabled = transform.booleanAttr(value);

        this._reflectAttribute('disabled', this._disabled);

        this[this._disabled ? 'setAttribute' : 'removeAttribute']('aria-disabled', this._disabled);
        this.classList.toggle('is-disabled', this._disabled);

        this._elements.input[this._disabled ? 'setAttribute' : 'removeAttribute']('disabled', this._disabled);

        this._elements.colorPreview[this._disabled ? 'setAttribute' : 'removeAttribute']('disabled', this._disabled);
      }
      /**
       Whether this field is readOnly or not. Indicating that the user cannot modify the value of the control.
       @type {Boolean}
       @default false
       @htmlattribute readonly
       @htmlattributereflected
       */

    }, {
      key: "readOnly",
      get: function get() {
        return this._readOnly || false;
      },
      set: function set(value) {
        this._readOnly = transform.booleanAttr(value);

        this._reflectAttribute('readonly', this._readOnly);

        this._elements.input[this._readOnly ? 'setAttribute' : 'removeAttribute']('readonly', this._readOnly);

        this._elements.colorPreview[this.disabled || this._readOnly ? 'setAttribute' : 'removeAttribute']('disabled', this.disabled || this._readOnly);
      }
      /**   
       The ColorPicker value. value should be a valid color in supported format.
       @default Empty
       @type {String}
       @htmlattribute label
       @htmlattributereflected
       */

    }, {
      key: "value",
      get: function get() {
        return this._value;
      },
      set: function set(value) {
        this._update(value);
      }
      /**
       The ColorPicker formats. comma separated formats should be in supported formats.
       Any invalid/unsupported format is ignored.
       Values selected in any other format will be converted to this format.
       @default ColorFormats.HSL
       @type {String}
       @htmlattribute formats
       @htmlattributereflected
       */

    }, {
      key: "formats",
      get: function get() {
        return this._formats || "";
      },
      set: function set(value) {
        var formats = value.split(',');
        formats = colorUtil.getValidFormats(formats);

        if (formats.length > 0) {
          this._formats = formats;
          this._format = formats[0];

          this._reflectAttribute('formats', this._formats);

          this._elements.propertiesView.setAttribute('formats', value); // refresh color in this new format


          this._update(colorUtil.formatColorString(this.value, this._format));
        }
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(ColorPicker), "observedAttributes", this).concat(['value', 'formats', 'disabled', 'label', 'labelledby', 'readonly']);
      }
      /** @ignore */

    }, {
      key: "_attributePropertyMap",
      get: function get() {
        return commons.extend(_get(_getPrototypeOf(ColorPicker), "_attributePropertyMap", this), {
          labelledby: 'labelledBy',
          readonly: 'readOnly'
        });
      }
    }]);

    return ColorPicker;
  }(BaseFormField(BaseComponent(HTMLElement)));

  var template$y = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var data = data_0 = typeof data_0 === "undefined" ? {} : data_0;
    data = data_0;
    var uid = data.commons.getUID();
    data_0 = data;
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    var el2 = this["propertiesSubview"] = document.createElement("div");
    el2.className += " _coral-ColorPicker-propertiesSubview";
    el2.setAttribute("handle", "propertiesSubview");
    el2.setAttribute("role", "group");
    var el3 = document.createTextNode("\n  ");
    el2.appendChild(el3);
    var el4 = document.createElement("div");
    el4.className += " _coral-ColorPicker-propertiesContainer1";
    el4.setAttribute("role", "presentation");
    var el5 = document.createTextNode("\n    ");
    el4.appendChild(el5);
    var el6 = this["propertySL"] = document.createElement("coral-colorpicker-colorarea");
    el6.setAttribute("handle", "propertySL");
    el6.setAttribute("label", data_0["i18n"]["get"]('Saturation and Brightness'));
    el4.appendChild(el6);
    var el7 = document.createTextNode("\n    ");
    el4.appendChild(el7);
    var el8 = this["propertyHue"] = document.createElement("coral-colorpicker-colorsliderhue");
    el8.setAttribute("handle", "propertyHue");
    el8.setAttribute("label", data_0["i18n"]["get"]('Hue'));
    el4.appendChild(el8);
    var el9 = document.createTextNode("\n  ");
    el4.appendChild(el9);
    el2.appendChild(el4);
    var el10 = document.createTextNode("\n  ");
    el2.appendChild(el10);
    var el11 = document.createElement("div");
    el11.className += " _coral-ColorPicker-propertiesContainer2";
    el11.setAttribute("role", "presentation");
    var el12 = document.createTextNode("\n    ");
    el11.appendChild(el12);
    var el13 = this["formatSelector"] = document.createElement("coral-select");
    el13.className += " _coral-ColorPicker-formatSelector";
    el13.setAttribute("handle", "formatSelector");
    el13.setAttribute("variant", "quiet");
    el13.setAttribute("labelled", data_0["i18n"]["get"]('Select Color Format'));
    var el14 = document.createTextNode("\n       ");
    el13.appendChild(el14);
    var el15 = document.createElement("coral-select-item");
    el15.setAttribute("value", "hsl");
    el15.textContent = data_0["i18n"]["get"]('HSL');
    el13.appendChild(el15);
    var el16 = document.createTextNode("\n       ");
    el13.appendChild(el16);
    var el17 = document.createElement("coral-select-item");
    el17.setAttribute("value", "hsv");
    el17.textContent = data_0["i18n"]["get"]('HSV');
    el13.appendChild(el17);
    var el18 = document.createTextNode("\n       ");
    el13.appendChild(el18);
    var el19 = document.createElement("coral-select-item");
    el19.setAttribute("value", "hex");
    el19.textContent = data_0["i18n"]["get"]('Hex');
    el13.appendChild(el19);
    var el20 = document.createTextNode("\n       ");
    el13.appendChild(el20);
    var el21 = document.createElement("coral-select-item");
    el21.setAttribute("value", "hex3");
    el21.textContent = data_0["i18n"]["get"]('Hex3');
    el13.appendChild(el21);
    var el22 = document.createTextNode("\n       ");
    el13.appendChild(el22);
    var el23 = document.createElement("coral-select-item");
    el23.setAttribute("value", "hex4");
    el23.textContent = data_0["i18n"]["get"]('Hex4');
    el13.appendChild(el23);
    var el24 = document.createTextNode("\n       ");
    el13.appendChild(el24);
    var el25 = document.createElement("coral-select-item");
    el25.setAttribute("value", "hex8");
    el25.textContent = data_0["i18n"]["get"]('Hex8');
    el13.appendChild(el25);
    var el26 = document.createTextNode("\n       ");
    el13.appendChild(el26);
    var el27 = document.createElement("coral-select-item");
    el27.setAttribute("value", "rgb");
    el27.textContent = data_0["i18n"]["get"]('RGB');
    el13.appendChild(el27);
    var el28 = document.createTextNode("\n       ");
    el13.appendChild(el28);
    var el29 = document.createElement("coral-select-item");
    el29.setAttribute("value", "prgb");
    el29.textContent = data_0["i18n"]["get"]('PRGB');
    el13.appendChild(el29);
    var el30 = document.createTextNode("\n       ");
    el13.appendChild(el30);
    var el31 = document.createElement("coral-select-item");
    el31.setAttribute("value", "name");
    el31.textContent = data_0["i18n"]["get"]('Name');
    el13.appendChild(el31);
    var el32 = document.createTextNode("\n    ");
    el13.appendChild(el32);
    el11.appendChild(el13);
    var el33 = document.createTextNode("\n    ");
    el11.appendChild(el33);
    var el34 = this["colorInput"] = document.createElement("input", "coral-textfield");
    el34.setAttribute("type", "text");
    el34.setAttribute("is", "coral-textfield");
    el34.className += " _coral-ColorPicker-inputField";
    el34.setAttribute("placeholder", data_0["i18n"]["get"]('Enter Color Value'));
    el34.setAttribute("handle", "colorInput");
    el34.setAttribute("variant", "quiet");
    el34.setAttribute("aria-label", data_0["i18n"]["get"]('Color Value'));
    el11.appendChild(el34);
    var el35 = document.createTextNode("\n  ");
    el11.appendChild(el35);
    el2.appendChild(el11);
    var el36 = document.createTextNode("\n");
    el2.appendChild(el36);
    frag.appendChild(el2);
    return frag;
  };

  var CLASSNAME$P = '_coral-ColorPicker-properties';
  /**
   @class Coral.ColorPicker.ColorProperties
   @classdesc A ColorPicker Color properties component
   @htmltag coral-colorpicker-properties
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var ColorProperties = /*#__PURE__*/function (_BaseComponent) {
    _inherits(ColorProperties, _BaseComponent);

    var _super = _createSuper(ColorProperties);

    function ColorProperties() {
      var _this;

      _classCallCheck(this, ColorProperties);

      _this = _super.call(this);

      _this._delegateEvents(commons.extend(_this._events, {
        'change [handle="propertyHue"]': '_onHueChange',
        'change [handle="propertySL"]': '_onSLChange',
        'change  [handle="formatSelector"]': '_onFormatChange',
        'capture:change  [handle="colorInput"]': '_onColorInputChange'
      })); // Templates


      _this._elements = {};
      template$y.call(_this._elements, {
        commons: commons,
        i18n: i18n
      });
      _this._hue = 240;
      _this._s = 1;
      _this._l = 0.5;
      _this._a = 1;
      _this._format = ColorFormats.HSV;
      return _this;
    }

    _createClass(ColorProperties, [{
      key: "render",
      value: function render() {
        _get(_getPrototypeOf(ColorProperties.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$P);
        var frag = document.createDocumentFragment(); // Render template

        frag.appendChild(this._elements.propertiesSubview); // Support cloneNode

        while (this.firstChild) {
          var child = this.firstChild;

          if (child.nodeType === Node.ELEMENT_NODE && child.hasAttribute('handle')) {
            this.removeChild(child);
          } else {
            frag.appendChild(child);
          }
        }

        this.appendChild(frag); //these should be used to set a property since property handler aren't called until elements are attached to dom.
        // Attribute values are delivered to change-listeners even if element isn't attached to dom yet.

        this._colorArea = this.querySelector("[handle='propertySL']");
        this._colorSliderHue = this.querySelector("[handle='propertyHue']");
        this._formatSelector = this.querySelector("[handle='formatSelector']");
        this._colorInput = this.querySelector("[handle='colorInput']"); // update color in all subviews

        this._updateFormat(this._format);

        this._updateHue(this._hue);

        this._updateSL(this._s, this._l);

        this._updateAlpha(this._a);

        this._updateValue();
      }
      /**
       Whether this field is disabled or not.
       @type {Boolean}
       @default false
       @htmlattribute disabled
       @htmlattributereflected
       */

    }, {
      key: "_onHueChange",

      /** @private */
      value: function _onHueChange(event) {
        event.stopImmediatePropagation();

        this._updateHue(this._colorSliderHue.value);

        this.trigger('change');
      }
      /** @private */

    }, {
      key: "_onSLChange",
      value: function _onSLChange(event) {
        event.stopImmediatePropagation();
        var color = new TinyColor({
          h: this._hue,
          s: this._colorArea.x,
          v: this._colorArea.y
        });

        this._updateSL(color.toHsl().s, color.toHsl().l);

        this.trigger('change');
      }
      /** @private */

    }, {
      key: "_onFormatChange",
      value: function _onFormatChange(event) {
        event.stopImmediatePropagation();

        this._updateFormat(this._formatSelector.value);

        this.trigger('change');
      }
      /** @private */

    }, {
      key: "_onColorInputChange",
      value: function _onColorInputChange(event) {
        event.stopImmediatePropagation();
        this.color = this._colorInput.value;
        this.trigger('change');
      }
      /** @private */

    }, {
      key: "_updateFormat",
      value: function _updateFormat(format) {
        this._format = format;

        this._elements.formatSelector.setAttribute('value', this._format);

        this._updateValue();
      }
      /** @private */

    }, {
      key: "_updateHue",
      value: function _updateHue(hue) {
        this._hue = Math.round(hue);

        var color = this._getColorFromProps();

        this._elements.propertyHue.setAttribute('color', colorUtil.toHslString(this._hue, color.toHslString())); // need to update hue in ColorArea but not s and v, so get s and v  from ColorArea


        this._elements.propertySL.setAttribute('color', this._toHsvString(this._hue, this._elements.propertySL.x, this._elements.propertySL.y));

        this._updateValue();
      }
      /** @private */

    }, {
      key: "_updateSL",
      value: function _updateSL(s, l) {
        this._s = s;
        this._l = l;
        var color = new TinyColor({
          h: this._hue,
          s: this._s,
          l: this._l
        });

        this._elements.propertySL.setAttribute('color', colorUtil.toHslString(this._hue, color.toHslString()));

        this._updateValue();
      }
      /** @private */

    }, {
      key: "_updateAlpha",
      value: function _updateAlpha(a) {
        this._a = a;

        this._updateValue();
      }
      /** @private */

    }, {
      key: "_toHsvString",
      value: function _toHsvString(hue, x, y) {
        var s = "".concat(Math.round(x * 100), "%");
        var v = "".concat(Math.round(y * 100), "%");
        return "hsv(".concat(this._hue, ", ").concat(s, ", ").concat(v, ")");
      }
      /** @private */

    }, {
      key: "_getColorFromProps",
      value: function _getColorFromProps() {
        return new TinyColor({
          h: this._hue,
          s: this._s,
          l: this._l,
          a: this._a
        });
      }
      /** @private */

    }, {
      key: "_updateValue",
      value: function _updateValue() {
        this._reflectAttribute('color', this.color);

        this._elements.colorInput.value = this.color;
      }
    }, {
      key: "disabled",
      get: function get() {
        return this._disabled || false;
      },
      set: function set(value) {
        this._disabled = transform.booleanAttr(value);

        this._reflectAttribute('disabled', this._disabled);

        this[this._disabled ? 'setAttribute' : 'removeAttribute']('aria-disabled', this._disabled);
        this.classList.toggle('is-disabled', this._disabled);

        this._elements.propertySL[this._disabled ? 'setAttribute' : 'removeAttribute']('disabled', this._disabled);

        this._elements.propertyHue[this._disabled ? 'setAttribute' : 'removeAttribute']('disabled', this._disabled);

        this._elements.formatSelector[this._disabled ? 'setAttribute' : 'removeAttribute']('disabled', this._disabled);

        this._elements.colorInput[this._disabled ? 'setAttribute' : 'removeAttribute']('disabled', this._disabled);
      }
      /**
       The ColorProperties formats. comma separated formats should be in supported formats.
       First format will be used as default format.
       Values selected in any other format will be converted to default format.
       @default ColorFormats.HSL
       @type {Array}
       @htmlattribute formats
       @htmlattributereflected
       */

    }, {
      key: "formats",
      get: function get() {
        return this._formats || "";
      },
      set: function set(value) {
        if (value == "") {
          return;
        }

        var formats = value.split(',');
        formats = colorUtil.getValidFormats(formats);

        if (formats.length > 0) {
          this._formats = formats;
          this._format = formats[0];

          this._elements.formatSelector.setAttribute('value', this._format); // update input value to this format


          this._elements.colorInput.value = this.color; // populate format selector list

          var selList = this._elements.formatSelector.querySelectorAll('coral-select-item');

          selList.forEach(function (element) {
            if (formats.indexOf(element.value) == -1) {
              element.remove();
            }
          });

          this._reflectAttribute('formats', this._formats);
        }
      }
      /**
       The ColorProperties color string.
       @default hsla(0, 100%, 50%, 1)
       @type {String}
       @htmlattribute color
       @htmlattributereflected
       */

    }, {
      key: "color",
      get: function get() {
        return colorUtil.formatColorString(colorUtil.toHslString(this._hue, this._getColorFromProps()), this._format);
      },
      set: function set(value) {
        var color = new TinyColor(value);

        if (!color.isValid) {
          color = new TinyColor("hsla(240, 100%, 50%, 1)");
          value = color.toHslString();
        }

        if (this.color === value) {
          return;
        }

        this._updateFormat(color.format);

        this._updateHue(colorUtil.getHue(value));

        this._updateSL(color.toHsl().s, color.toHsl().l);

        this._updateAlpha(color.a);

        this._updateValue();
      }
      /** @ignore */

    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(ColorProperties), "observedAttributes", this).concat(['disabled', 'color', 'formats']);
      }
    }]);

    return ColorProperties;
  }(BaseComponent(HTMLElement));

  var template$z = function anonymous(data_0) {
    var el0 = this["colorAreaGradient"] = document.createElement("div");
    el0.className += " _coral-ColorPicker-ColorArea-gradient";
    el0.setAttribute("handle", "colorAreaGradient");
    el0.setAttribute("role", "presentation");
    var el1 = document.createTextNode("\n");
    el0.appendChild(el1);
    var el2 = this["colorHandle"] = document.createElement("coral-colorpicker-colorhandle");
    el2.className += " _coral-ColorPicker-ColorArea-colorHandle";
    el2.setAttribute("handle", "colorHandle");
    el2.setAttribute("style", "position: absolute;top: 0%;left: 100%");
    el2.setAttribute("role", "presentation");
    el0.appendChild(el2);
    var el3 = document.createTextNode("\n");
    el0.appendChild(el3);
    var el4 = this["sliderX"] = document.createElement("input");
    el4.setAttribute("type", "range");
    el4.setAttribute("handle", "sliderX");
    el4.className += " _coral-ColorPicker-ColorArea-slider";
    el4.setAttribute("name", "x");
    el4.setAttribute("aria-label", data_0["i18n"]["get"]('Saturation and Brightness'));
    el4.setAttribute("min", "0");
    el4.setAttribute("max", "1");
    el4.setAttribute("step", "0.01");
    el0.appendChild(el4);
    var el5 = document.createTextNode("\n");
    el0.appendChild(el5);
    var el6 = this["sliderY"] = document.createElement("input");
    el6.setAttribute("type", "range");
    el6.setAttribute("handle", "sliderY");
    el6.className += " _coral-ColorPicker-ColorArea-slider";
    el6.setAttribute("name", "y");
    el6.setAttribute("aria-label", data_0["i18n"]["get"]('Saturation and Brightness'));
    el6.setAttribute("min", "0");
    el6.setAttribute("max", "1");
    el6.setAttribute("step", "0.01");
    el0.appendChild(el6);
    return el0;
  };

  var CLASSNAME$Q = '_coral-ColorPicker-ColorArea';
  /**
   @class Coral.ColorPicker.ColorArea
   @classdesc A ColorPicker area component to select Saturation and Value
   @htmltag coral-colorpicker-colorarea
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var ColorArea = /*#__PURE__*/function (_BaseComponent) {
    _inherits(ColorArea, _BaseComponent);

    var _super = _createSuper(ColorArea);

    function ColorArea() {
      var _this;

      _classCallCheck(this, ColorArea);

      _this = _super.call(this);

      _this._delegateEvents(commons.extend(_this._events, {
        'key:up': '_handleKey',
        'key:right': '_handleKey',
        'key:down': '_handleKey',
        'key:left': '_handleKey',
        'key:pageUp': '_handleKey',
        'key:pageDown': '_handleKey',
        'key:home': '_handleKey',
        'key:end': '_handleKey',
        'input': '_onInputChangeHandler',
        'touchstart': '_onMouseDown',
        'mousedown': '_onMouseDown',
        'capture:focus': '_focus',
        'capture:blur': '_blur'
      })); // Templates


      _this._elements = {};
      template$z.call(_this._elements, {
        commons: commons,
        i18n: i18n
      }); // default values

      _this._x = 1;
      _this._y = 1;
      _this._hue = 120;
      _this._minX = 0;
      _this._minY = 0;
      _this._maxX = 1;
      _this._maxY = 1;
      _this._stepX = 0.01;
      _this._stepY = 0.01;
      return _this;
    }
    /** @ignore */


    _createClass(ColorArea, [{
      key: "render",
      value: function render() {
        _get(_getPrototypeOf(ColorArea.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$Q);
        var frag = document.createDocumentFragment(); // Render template

        frag.appendChild(this._elements.colorAreaGradient);
        frag.appendChild(this._elements.colorHandle);
        frag.appendChild(this._elements.sliderX);
        frag.appendChild(this._elements.sliderY); // Support cloneNode

        while (this.firstChild) {
          var child = this.firstChild;

          if (child.nodeType === Node.ELEMENT_NODE && child.hasAttribute('handle')) {
            this.removeChild(child);
          } else {
            frag.appendChild(child);
          }
        }

        this.appendChild(frag); // These should be used to set a property since property handler aren't called until elements are attached to dom.
        // Attribute values are delivered to change-listeners even if element isn't attached to dom yet, so attributes 
        // can be set to e.g. this._elements.colorHandle.

        this._handle = this.querySelector('._coral-ColorPicker-ColorArea-colorHandle');
        this._sliderX = this.querySelector('._coral-ColorPicker-ColorArea-slider[name="x"]');
        this._sliderY = this.querySelector('._coral-ColorPicker-ColorArea-slider[name="y"]');
        this._gradient = this.querySelector('._coral-ColorPicker-ColorArea-gradient');

        this._updateHue(this._hue);

        this.x = this._x;
        this.y = this._y;

        this._updateHandle(this._hue, this.x, this.y, this.color);

        this._reflectAttribute('color', this.color);
      }
      /**   
       The ColorArea label.
       @default ''
       @type {String}
       @htmlattribute label
       @htmlattributereflected
       */

    }, {
      key: "_toHsvString",

      /** @private */
      value: function _toHsvString(hue, x, y) {
        var s = "".concat(Math.round(this._x / (this._maxX - this._minX) * 100), "%");
        var v = "".concat(Math.round(this._y / (this._maxY - this._minY) * 100), "%");
        return "hsv(".concat(this._hue, ", ").concat(s, ", ").concat(v, ")");
      }
      /**   
       The ColorArea y value. value should be in multiple of y-step size.
       @default 1
       @type {String}
       @htmlattribute label
       @htmlattributereflected
       */

    }, {
      key: "focus",
      value: function focus() {
        this._sliderX.focus();
      }
      /** @private **/

    }, {
      key: "_updateHue",
      value: function _updateHue(hue) {
        this._hue = hue;

        if (this._gradient) {
          this._gradient.style.background = "linear-gradient(to top, black 0%, hsla(".concat(this._hue, ", 100%, 0%, 0) 100%),\n        linear-gradient(to right, white 0%, hsla(").concat(this._hue, ", 100%, 0%, 0) 100%),\n        hsl(").concat(this._hue, ", 100%, 50%)");
        }
      }
      /** @private */

    }, {
      key: "_snapValueToStep",
      value: function _snapValueToStep(rawValue, min, max, step) {
        var remainder = (rawValue - min) % step;
        var snappedValue = rawValue;

        if (Math.abs(remainder) * 2 >= step) {
          snappedValue = rawValue - remainder + step;
        } else {
          snappedValue = rawValue - remainder;
        }

        if (snappedValue < min) {
          snappedValue = min;
        } else if (snappedValue > max) {
          snappedValue = min + Math.floor((max - min) / step) * step;
        }

        return snappedValue;
      }
      /** @private */

    }, {
      key: "_updateHandle",
      value: function _updateHandle(hue, x, y, colorStr) {
        var percent = 100 - (y - this._minY) / (this._maxY - this._minY) * 100;

        if (this._handle) {
          this._handle.style.top = "".concat(percent, "%");
        }

        percent = (x - this._minX) / (this._maxX - this._minX) * 100;

        if (this._handle) {
          this._handle.style.left = "".concat(percent, "%");
        }

        this._elements.colorHandle.setAttribute('color', colorStr);
      }
      /** @private */

    }, {
      key: "_focusHandle",
      value: function _focusHandle(isFocused) {
        if (this._handle) {
          if (isFocused === true) {
            this._handle.focus();
          } else {
            this._handle.blur();
          }
        }
      }
      /** @private */

    }, {
      key: "_changeValue",
      value: function _changeValue(x, y) {
        if (this.x !== x || this.y !== y) {
          var currX = this.x;
          var currY = this.y;
          this.x = x;
          this.y = y;

          if (this.x !== currX || this.y !== currY) {
            this.trigger('change');
          }
        }
      }
    }, {
      key: "_focusX",
      value: function _focusX() {
        this._sliderX.focus();
      }
    }, {
      key: "_focusY",
      value: function _focusY() {
        this._sliderY.focus();
      }
      /******* Events Handling **************/

      /** @private */

    }, {
      key: "_onInputChangeHandler",
      value: function _onInputChangeHandler(event) {
        this._focusHandle(true);

        event.stopPropagation();

        if (event.target === this._sliderX) {
          this._changeValue(event.target.value, this.y);
        } else {
          this._changeValue(this.x, event.target.value);
        }
      }
      /** @private */

    }, {
      key: "_handleKey",
      value: function _handleKey(event) {
        this._focusHandle(true);

        event.preventDefault();
        event.stopPropagation();
        var y = this.y;
        var x = this.x; // increase

        if (event.keyCode === Keys.keyToCode('up') || event.keyCode === Keys.keyToCode('pageUp')) {
          y += this._stepY;

          this._focusY();
        } // decrease
        else if (event.keyCode === Keys.keyToCode('down') || event.keyCode === Keys.keyToCode('pageDown')) {
            y -= this._stepY;

            this._focusY();
          } // increase


        if (event.keyCode === Keys.keyToCode('right')) {
          x += this._stepX;

          this._focusX();
        } // decrease
        else if (event.keyCode === Keys.keyToCode('left')) {
            x -= this._stepX;

            this._focusX();
          } // min
          else if (event.keyCode === Keys.keyToCode('home')) {
              x = this._minX;
              y = this._minY;

              this._focusX();
            } // max
            else if (event.keyCode === Keys.keyToCode('end')) {
                x = this._maxX;
                y = this._maxY;

                this._focusX();
              }

        this._changeValue(x, y);
      }
      /** @private */

    }, {
      key: "_onMouseDown",
      value: function _onMouseDown() {
        if (event instanceof MouseEvent) {
          if ((event.which || event.button) !== 1) {
            return;
          }
        }

        event.preventDefault();

        this._handle.classList.add('is-dragged');

        document.body.classList.add('u-coral-closedHand');
        this.focus();

        this._focusHandle(true);

        var _this$_getValuesFromC = this._getValuesFromCoord(this._getPoint(event)),
            x = _this$_getValuesFromC.x,
            y = _this$_getValuesFromC.y;

        this._changeValue(x, y);
        this._draggingHandler = this._handleDragging.bind(this);
        this._mouseUpHandler = this._mouseUp.bind(this);
        events.on('mousemove.CoralArea', this._draggingHandler);
        events.on('mouseup.CoralArea', this._mouseUpHandler);
        events.on('touchmove.CoralArea', this._draggingHandler);
        events.on('touchend.CoralArea', this._mouseUpHandler);
        events.on('touchcancel.CoralArea', this._mouseUpHandler);
      }
      /**  @private */

    }, {
      key: "_getValuesFromCoord",
      value: function _getValuesFromCoord(point) {
        var boundingClientRect = this.getBoundingClientRect();
        var height = boundingClientRect.height;
        var width = boundingClientRect.width;
        var posY = point.clientY;
        var posX = point.clientX;

        if (posY < boundingClientRect.top) {
          posY = boundingClientRect.top;
        } else if (posY > boundingClientRect.bottom) {
          posY = boundingClientRect.bottom;
        }

        if (posX < boundingClientRect.left) {
          posX = boundingClientRect.left;
        } else if (posX > boundingClientRect.right) {
          posX = boundingClientRect.right;
        }

        var positionFraction = (height - (posY - boundingClientRect.top)) / height;
        var rawY = this._minY + positionFraction * (this._maxY - this._minY);
        positionFraction = (posX - boundingClientRect.left) / width;
        var rawX = this._minX + positionFraction * (this._maxX - this._minX);
        return {
          x: rawX,
          y: rawY
        };
      }
      /** @private */

    }, {
      key: "_handleDragging",
      value: function _handleDragging(event) {
        var _this$_getValuesFromC2 = this._getValuesFromCoord(this._getPoint(event)),
            x = _this$_getValuesFromC2.x,
            y = _this$_getValuesFromC2.y;

        this._changeValue(x, y);

        event.preventDefault();
      }
      /** @private */

    }, {
      key: "_mouseUp",
      value: function _mouseUp(event) {
        this._handle.style.cursor = 'grab';

        this._handle.classList.remove('is-dragged');

        document.body.classList.remove('u-coral-closedHand');

        this._focusHandle(false);
        events.off('mousemove.CoralArea', this._draggingHandler);
        events.off('touchmove.CoralArea', this._draggingHandler);
        events.off('mouseup.CoralArea', this._mouseUpHandler);
        events.off('touchend.CoralArea', this._mouseUpHandler);
        events.off('touchcancel.CoralArea', this._mouseUpHandler);
        this._currentHandle = null;
        this._draggingHandler = null;
        this._mouseUpHandler = null;
      }
      /**
       @private
       @return {Object} which contains the real coordinates
       */

    }, {
      key: "_getPoint",
      value: function _getPoint(event) {
        if (event.changedTouches && event.changedTouches.length > 0) {
          return event.changedTouches[0];
        } else if (event.touches && event.touches.length > 0) {
          return event.touches[0];
        }

        return event;
      }
      /**
       Handles "focusin" event.
        @private
       */

    }, {
      key: "_focus",
      value: function _focus(event) {
        this._focusHandle(true);
      }
      /**
       Handles "focusout" event.
        @private
       */

    }, {
      key: "_blur",
      value: function _blur(event) {
        this._focusHandle(false);
      }
    }, {
      key: "label",
      get: function get() {
        return this._label;
      },
      set: function set(value) {
        this._label = value;

        this._reflectAttribute('label', this._label);

        if (this._elements.sliderX.getAttribute('aria-label') !== this._label) {
          this._elements.sliderX.setAttribute('aria-label', this._label);

          this._elements.sliderY.setAttribute('aria-label', this._label);
        }
      }
      /**   
       The ColorArea x value. value should be in multiple of x-step size.
       @default 1
       @type {String}
       @htmlattribute label
       @htmlattributereflected
       */

    }, {
      key: "x",
      get: function get() {
        return this._x;
      },
      set: function set(value) {
        var rawX = Number(value, 10);

        if (parseFloat(rawX).toFixed(3) !== parseFloat(this._x).toFixed(3)) {
          if (isNaN(rawX)) {
            rawX = this._minX;
          }

          this._x = this._snapValueToStep(rawX, this._minX, this._maxX, this._stepX);

          this._reflectAttribute('x', this._x);

          this.color = this._toHsvString(this._hue, this._x, this.y);
        }

        this._elements.sliderX.setAttribute('aria-valuetext', "".concat(i18n.get('Saturation'), ": ").concat(Math.round(this._x / (this._maxX - this._minX) * 100), "%"));

        this._elements.sliderX.setAttribute('title', this.color);

        this._elements.sliderX.setAttribute('value', this._x);
      }
    }, {
      key: "y",
      get: function get() {
        return this._y;
      },
      set: function set(value) {
        var rawY = Number(value, 10);

        if (parseFloat(rawY).toFixed(3) !== parseFloat(this._y).toFixed(3)) {
          if (isNaN(rawY)) {
            rawY = this._minY;
          }

          this._y = this._snapValueToStep(rawY, this._minY, this._maxY, this._stepY);

          this._reflectAttribute('y', this._y);

          this.color = this._toHsvString(this._hue, this.x, this._y);
        }

        this._elements.sliderY.setAttribute('aria-valuetext', "".concat(i18n.get('Brightness'), ": ").concat(Math.round(this._y / (this._maxY - this._minY) * 100), "%"));

        this._elements.sliderY.setAttribute('title', this.color);

        this._elements.sliderY.setAttribute('value', this._y);
      }
      /**
       The ColorArea color string in hsla format.
       @default hsla(0, 100%, 50%, 1)
       @type {String}
       @htmlattribute color
       @htmlattributereflected
       */

    }, {
      key: "color",
      get: function get() {
        return colorUtil.toHslString(this._hue, new TinyColor({
          h: this._hue,
          s: this.x,
          v: this.y
        }).toHslString());
      },
      set: function set(value) {
        var color = new TinyColor(value);

        if (!color.isValid) {
          color = new TinyColor("hsla(120, 100%, 50%, 1)");
          value = color.toHslString();
        } // if  color strings are equal or colors are equivalent  


        if (this.color === value || new TinyColor(this.color).toString(color.format) === color) {
          return;
        }

        var _colorUtil$extractHsv = colorUtil.extractHsv(value),
            h = _colorUtil$extractHsv.h,
            s = _colorUtil$extractHsv.s,
            v = _colorUtil$extractHsv.v;

        if (h !== this._hue) {
          this._updateHue(colorUtil.getHue(value));
        }

        if (s !== this._x) {
          this.x = s;
        }

        if (v !== this.Y) {
          this.y = v;
        }

        this._updateHandle(this._hue, this.x, this.y, this.color);

        this._reflectAttribute('color', this.color);
      }
      /** @ignore */

    }, {
      key: "disabled",

      /**
       Whether this field is disabled or not.
       @type {Boolean}
       @default false
       @htmlattribute disabled
       @htmlattributereflected
       */
      get: function get() {
        return this._disabled || false;
      },
      set: function set(value) {
        this._disabled = transform.booleanAttr(value);

        this._reflectAttribute('disabled', this._disabled);

        this.classList.toggle('is-disabled', this._disabled);
        this[this._disabled ? 'setAttribute' : 'removeAttribute']('aria-disabled', this._disabled);

        this._elements.sliderX[this._disabled ? 'setAttribute' : 'removeAttribute']('disabled', this._disabled);

        this._elements.sliderY[this._disabled ? 'setAttribute' : 'removeAttribute']('disabled', this._disabled);

        this._elements.colorHandle[this._disabled ? 'setAttribute' : 'removeAttribute']('disabled', this._disabled);
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(ColorArea), "observedAttributes", this).concat(['label', 'x', 'y', 'disabled', 'color']);
      }
    }]);

    return ColorArea;
  }(BaseComponent(HTMLElement));

  var template$A = function anonymous(data_0) {
    var el0 = this["checkerboard"] = document.createElement("div");
    el0.className += " _coral-ColorPicker-ColorSlider-checkerboard";
    el0.setAttribute("handle", "checkerboard");
    el0.setAttribute("role", "presentation");
    var el1 = document.createTextNode("\n    ");
    el0.appendChild(el1);
    var el2 = document.createElement("div");
    el2.className += " _coral-ColorPicker-ColorSlider-gradient";
    el2.setAttribute("role", "presentation");
    el2.textContent = "\n";
    el0.appendChild(el2);
    var el3 = document.createTextNode("\n");
    el0.appendChild(el3);
    var el4 = this["colorHandle"] = document.createElement("coral-colorpicker-colorhandle");
    el4.className += " _coral-ColorPicker-ColorSlider-colorHandle";
    el4.setAttribute("handle", "colorHandle");
    el4.setAttribute("style", "position: absolute;top: 100%;");
    el0.appendChild(el4);
    var el5 = document.createTextNode("\n");
    el0.appendChild(el5);
    var el6 = this["slider"] = document.createElement("input");
    el6.setAttribute("type", "range");
    el6.setAttribute("handle", "slider");
    el6.className += " _coral-ColorPicker-ColorSlider-slider";
    el0.appendChild(el6);
    return el0;
  };

  var CLASSNAME$R = '_coral-ColorPicker-ColorSlider';
  /**
   @@base ColorSlider
   @classdesc A ColorPicker color slider component
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var ColorSlider = /*#__PURE__*/function (_BaseComponent) {
    _inherits(ColorSlider, _BaseComponent);

    var _super = _createSuper(ColorSlider);

    /** @ignore */
    function ColorSlider() {
      var _this;

      _classCallCheck(this, ColorSlider);

      _this = _super.call(this);

      _this._delegateEvents(commons.extend(_this._events, {
        'key:up': '_handleKey',
        'key:right': '_handleKey',
        'key:down': '_handleKey',
        'key:left': '_handleKey',
        'key:pageUp': '_handleKey',
        'key:pageDown': '_handleKey',
        'key:home': '_handleKey',
        'key:end': '_handleKey',
        'input': '_onInputChangeHandler',
        'touchstart': '_onMouseDown',
        'mousedown': '_onMouseDown',
        'capture:focus': '_focus',
        'capture:blur': '_blur'
      })); // Templates


      _this._elements = {};
      template$A.call(_this._elements, {
        commons: commons,
        i18n: i18n
      }); // default value

      _this._label = "";
      _this._value = 180;
      _this._color = new TinyColor("hsla(180, 100%, 50%, 1)");
      _this._hue = 180;
      _this._min = 0;
      _this._max = 100;
      _this._step = 1;
      return _this;
    }
    /** @ignore */


    _createClass(ColorSlider, [{
      key: "render",
      value: function render() {
        _get(_getPrototypeOf(ColorSlider.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$R);
        var frag = document.createDocumentFragment(); // Render template

        frag.appendChild(this._elements.checkerboard);
        frag.appendChild(this._elements.colorHandle);
        frag.appendChild(this._elements.slider); // Support cloneNode

        while (this.firstChild) {
          var child = this.firstChild;

          if (child.nodeType === Node.ELEMENT_NODE && child.hasAttribute('handle')) {
            this.removeChild(child);
          } else {
            frag.appendChild(child);
          }
        }

        this.appendChild(frag);

        this._syncInputSliderAttrs(); // These should be used to set a property since property handler aren't called until elements are attached to dom.
        // Attribute values are delivered to change-listeners even if element isn't attached to dom yet, so attributes 
        // can be set to e.g. this._elements.colorHandle.    


        this._handle = this.querySelector('._coral-ColorPicker-ColorSlider-colorHandle');
        this._slider = this.querySelector('._coral-ColorPicker-ColorSlider-slider');

        this._updateValue(this._hue);
      }
      /**   
       The ColorSlider label.
       @default 'Hue'
       @type {String}
       @htmlattribute label
       @htmlattributereflected
       */

    }, {
      key: "focus",
      value: function focus() {
        this._slider.focus();
      }
      /** @private */

    }, {
      key: "_colorFromValue",
      value: function _colorFromValue(value) {
        return new TinyColor({
          h: value,
          s: 1,
          l: .5,
          a: 1
        });
      }
      /** @private */

    }, {
      key: "_syncInputSliderAttrs",
      value: function _syncInputSliderAttrs() {
        if (Number(this._elements.slider.getAttribute('min')) !== this._min) {
          this._elements.slider.setAttribute('min', this._min);
        }

        if (Number(this._elements.slider.getAttribute('max')) !== this._max) {
          this._elements.slider.setAttribute('max', this._max);
        }

        if (Number(this._elements.slider.getAttribute('step')) !== this._step) {
          this._elements.slider.setAttribute('step', this._step);
        }

        if (this._elements.slider.getAttribute('aria-label') !== this._label) {
          this._elements.slider.setAttribute('aria-label', this._label);
        }
      }
      /** @private */

    }, {
      key: "_snapValueToStep",
      value: function _snapValueToStep(rawValue, min, max, step) {
        var remainder = (rawValue - min) % step;
        var snappedValue = rawValue;

        if (Math.abs(remainder) * 2 >= step) {
          snappedValue = rawValue - remainder + step;
        } else {
          snappedValue = rawValue - remainder;
        }

        if (snappedValue < min) {
          snappedValue = min;
        } else if (snappedValue > max) {
          snappedValue = min + Math.floor((max - min) / step) * step;
        }

        return snappedValue;
      }
      /** @private */

    }, {
      key: "_updateHandlePosition",
      value: function _updateHandlePosition() {
        var percent = 100 - (this._value - this._min) / (this._max - this._min) * 100;

        if (this._handle) {
          this._handle.style.top = "".concat(percent, "%");
        }
      }
      /** @private */

    }, {
      key: "_focusHandle",
      value: function _focusHandle(isFocused) {
        if (this._handle) {
          if (isFocused === true) {
            this._handle.focus();
          } else {
            this._handle.blur();
          }
        }
      }
      /** @private */

    }, {
      key: "_updateValue",
      value: function _updateValue(value) {
        var rawValue = Number(value, 10);

        if (isNaN(rawValue)) {
          rawValue = this._min;
        }

        this._value = this._snapValueToStep(rawValue, this._min, this._max, this._step);
        this._hue = this._value; // update color

        this._color = this._colorFromValue(this._value);

        this._elements.colorHandle.setAttribute('color', colorUtil.toHslString(this._hue, this._color.toHslString()));

        this._reflectAttribute('color', colorUtil.toHslString(this._hue, this._color.toHslString()));

        this._reflectAttribute('value', this._value);

        this._elements.slider.setAttribute('value', this._value);

        this._updateHandlePosition();
      }
      /** @private */

    }, {
      key: "_changeValue",
      value: function _changeValue(value) {
        if (value !== this.value) {
          var currVal = this.value;

          this._updateValue(value);

          if (currVal !== this.value) {
            this.trigger('change');
          }
        }
      }
      /******* Events Handling **************/

      /** @private */

    }, {
      key: "_onInputChangeHandler",
      value: function _onInputChangeHandler(event) {
        this.focus();

        this._focusHandle(true);

        event.stopPropagation();

        this._changeValue(event.target.value);
      }
      /** @private */

    }, {
      key: "_handleKey",
      value: function _handleKey(event) {
        this.focus();

        this._focusHandle(true);

        event.preventDefault();
        event.stopPropagation();
        var value = this._value; // increase

        if (event.keyCode === Keys.keyToCode('up') || event.keyCode === Keys.keyToCode('right') || event.keyCode === Keys.keyToCode('pageUp')) {
          value += this._step;
        } // decrease
        else if (event.keyCode === Keys.keyToCode('down') || event.keyCode === Keys.keyToCode('left') || event.keyCode === Keys.keyToCode('pageDown')) {
            value -= this._step;
          } // min
          else if (event.keyCode === Keys.keyToCode('home')) {
              value = this._min;
            } // max
            else if (event.keyCode === Keys.keyToCode('end')) {
                value = this._max;
              }

        this._changeValue(value);
      }
      /** @private */

    }, {
      key: "_onMouseDown",
      value: function _onMouseDown() {
        if (event instanceof MouseEvent) {
          if ((event.which || event.button) !== 1) {
            return;
          }
        }

        event.preventDefault();

        this._handle.classList.add('is-dragged');

        document.body.classList.add('u-coral-closedHand');
        this.focus();

        this._focusHandle(true);

        this._changeValue(this._getValueFromCoord(this._getPoint(event).clientY));
        this._draggingHandler = this._handleDragging.bind(this);
        this._mouseUpHandler = this._mouseUp.bind(this);
        events.on('mousemove.CoralSlider', this._draggingHandler);
        events.on('mouseup.CoralSlider', this._mouseUpHandler);
        events.on('touchmove.CoralSlider', this._draggingHandler);
        events.on('touchend.CoralSlider', this._mouseUpHandler);
        events.on('touchcancel.CoralSlider', this._mouseUpHandler);
      }
      /**  @private */

    }, {
      key: "_getValueFromCoord",
      value: function _getValueFromCoord(posY) {
        var boundingClientRect = this.getBoundingClientRect();
        var height = boundingClientRect.height;

        if (posY < boundingClientRect.top) {
          posY = boundingClientRect.top;
        } else if (posY > boundingClientRect.bottom) {
          posY = boundingClientRect.bottom;
        }

        var positionFraction = (height - (posY - boundingClientRect.top)) / height;
        var rawValue = this._min + positionFraction * (this._max - this._min);
        return this._snapValueToStep(rawValue, this._min, this._max, this._step);
      }
      /** @private */

    }, {
      key: "_handleDragging",
      value: function _handleDragging(event) {
        this._changeValue(this._getValueFromCoord(this._getPoint(event).clientY));

        event.preventDefault();
      }
      /** @private */

    }, {
      key: "_mouseUp",
      value: function _mouseUp(event) {
        this._handle.style.cursor = 'grab';

        this._handle.classList.remove('is-dragged');

        document.body.classList.remove('u-coral-closedHand');

        this._focusHandle(false);
        events.off('mousemove.CoralSlider', this._draggingHandler);
        events.off('touchmove.CoralSlider', this._draggingHandler);
        events.off('mouseup.CoralSlider', this._mouseUpHandler);
        events.off('touchend.CoralSlider', this._mouseUpHandler);
        events.off('touchcancel.CoralSlider', this._mouseUpHandler);
        this._currentHandle = null;
        this._draggingHandler = null;
        this._mouseUpHandler = null;
      }
      /**
       @private
       @return {Object} which contains the real coordinates
       */

    }, {
      key: "_getPoint",
      value: function _getPoint(event) {
        if (event.changedTouches && event.changedTouches.length > 0) {
          return event.changedTouches[0];
        } else if (event.touches && event.touches.length > 0) {
          return event.touches[0];
        }

        return event;
      }
      /**
       Handles "focusin" event.
        @private
       */

    }, {
      key: "_focus",
      value: function _focus(event) {
        this._focusHandle(true);
      }
      /**
       Handles "focusout" event.
        @private
       */

    }, {
      key: "_blur",
      value: function _blur(event) {
        this._focusHandle(false);
      }
    }, {
      key: "label",
      get: function get() {
        return this._label;
      },
      set: function set(value) {
        this._label = value;

        this._reflectAttribute('label', this._label);

        this._syncInputSliderAttrs();
      }
      /**   
       The ColorSlider value. value should be in multiple of step size.
       @default 0
       @type {String}
       @htmlattribute label
       @htmlattributereflected
       */

    }, {
      key: "value",
      get: function get() {
        return this._value;
      },
      set: function set(value) {
        if (this._value !== value) {
          this._updateValue(value);
        }
      }
      /**
       The ColorSlider color string in hsla format.
       @default hsla(0, 100%, 50%, 1)
       @type {String}
       @htmlattribute color
       @htmlattributereflected
       */

    }, {
      key: "color",
      get: function get() {
        return colorUtil.toHslString(this._hue, this._color.toHslString());
      },
      set: function set(value) {
        if (this.color === value) {
          return;
        }

        var color = new TinyColor(value);

        if (!color.isValid) {
          color = new TinyColor("hsla(180, 100%, 50%, 1)");
          value = color.toHslString();
        }

        this._hue = colorUtil.getHue(value);

        this._updateValue(this._hue);
      }
      /** @ignore */

    }, {
      key: "disabled",

      /**
       Whether this field is disabled or not.
       @type {Boolean}
       @default false
       @htmlattribute disabled
       @htmlattributereflected
       */
      get: function get() {
        return this._disabled || false;
      },
      set: function set(value) {
        this._disabled = transform.booleanAttr(value);

        this._reflectAttribute('disabled', this._disabled);

        this.classList.toggle('is-disabled', this._disabled);
        this[this._disabled ? 'setAttribute' : 'removeAttribute']('aria-disabled', this._disabled);

        this._elements.slider[this._disabled ? 'setAttribute' : 'removeAttribute']('disabled', this._disabled);

        this._elements.colorHandle[this._disabled ? 'setAttribute' : 'removeAttribute']('disabled', this._disabled);
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(ColorSlider), "observedAttributes", this).concat(['label', 'value', 'disabled', 'color']);
      }
    }]);

    return ColorSlider;
  }(BaseComponent(HTMLElement));

  var CLASSNAME$S = '_coral-ColorPicker-ColorSlider-hue';
  /**
   @class Coral.ColorPicker.ColorSliderHue
   @classdesc A ColorPicker color slider hue component to select Hue
   @htmltag coral-colorpicker-colorsliderhue
   @extends {ColorSlider}
   */

  var ColorSliderHue = /*#__PURE__*/function (_ColorSlider) {
    _inherits(ColorSliderHue, _ColorSlider);

    var _super = _createSuper(ColorSliderHue);

    /** @ignore */
    function ColorSliderHue() {
      var _this;

      _classCallCheck(this, ColorSliderHue);

      _this = _super.call(this);
      _this._min = 0;
      _this._max = 360;
      _this._step = 1;
      return _this;
    }
    /** @private */


    _createClass(ColorSliderHue, [{
      key: "_updateValue",
      value: function _updateValue(value) {
        _get(_getPrototypeOf(ColorSliderHue.prototype), "_updateValue", this).call(this, value);

        this._elements.slider.setAttribute('aria-valuetext', "".concat(this.value, "\xB0"));
      }
      /** @ignore */

    }, {
      key: "render",
      value: function render() {
        _get(_getPrototypeOf(ColorSliderHue.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$S);

        this._updateValue(this.value);
      }
      /** @private */

    }, {
      key: "_colorFromValue",
      value: function _colorFromValue(value) {
        return new TinyColor({
          h: value,
          s: 1,
          l: .50,
          a: 1
        });
      }
    }]);

    return ColorSliderHue;
  }(ColorSlider);

  var template$B = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var data = data_0 = typeof data_0 === "undefined" ? {} : data_0;
    data = data_0;
    var uid = data.commons.getUID();
    data_0 = data;
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    var el2 = this["colorHandleSubView"] = document.createElement("div");
    el2.setAttribute("handle", "colorHandleSubView");
    el2.className += " _coral-ColorPicker-colorHandle-color";
    el2.setAttribute("style", "background-color: rgba(255, 0, 0, 1.0);");
    frag.appendChild(el2);
    return frag;
  };

  var CLASSNAME$T = '_coral-ColorPicker-colorHandle';
  /**
   @class Coral.ColorPicker.ColorHandle
   @classdesc A ColorHandle component
   @htmltag coral-colorpicker-colorhandle
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var ColorHandle = /*#__PURE__*/function (_BaseComponent) {
    _inherits(ColorHandle, _BaseComponent);

    var _super = _createSuper(ColorHandle);

    /** @ignore */
    function ColorHandle() {
      var _this;

      _classCallCheck(this, ColorHandle);

      _this = _super.call(this);

      _this._delegateEvents(commons.extend(_this._events, {})); // Templates


      _this._elements = {};
      template$B.call(_this._elements, {
        commons: commons,
        i18n: i18n
      });
      _this._color = new TinyColor("hsla(0, 100%, 50%, 1)");
      _this._hue = 0;
      return _this;
    }
    /** @ignore */


    _createClass(ColorHandle, [{
      key: "render",
      value: function render() {
        _get(_getPrototypeOf(ColorHandle.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$T);
        var frag = document.createDocumentFragment(); // Render template

        frag.appendChild(this._elements.colorHandleSubView); // Support cloneNode

        while (this.firstChild) {
          var child = this.firstChild;

          if (child.nodeType === Node.ELEMENT_NODE && child.hasAttribute('handle')) {
            this.removeChild(child);
          } else {
            frag.appendChild(child);
          }
        }

        this.appendChild(frag);
        this._subView = this.querySelector("._coral-ColorPicker-colorHandle-color");
        this.color = colorUtil.toHslString(this._hue, this._color.toHslString());
      }
      /** @ignore */

    }, {
      key: "focus",
      value: function focus() {
        this.classList.add("is-focused");
      }
      /** @ignore */

    }, {
      key: "blur",
      value: function blur() {
        this.classList.remove("is-focused");
      }
      /**
       Whether this field is disabled or not.
       @type {Boolean}
       @default false
       @htmlattribute disabled
       @htmlattributereflected
       */

    }, {
      key: "disabled",
      get: function get() {
        return this._disabled || false;
      },
      set: function set(value) {
        this._disabled = transform.booleanAttr(value);

        this._reflectAttribute('disabled', this._disabled);

        this.classList.toggle('is-disabled', this._disabled);
        this[this._disabled ? 'setAttribute' : 'removeAttribute']('aria-disabled', this._disabled);
      }
      /**   
       The ColorSlider color.
       @default hsla(0, 100%, 50%, 1)
       @type {String}
       @htmlattribute label
       @htmlattributereflected
       */

    }, {
      key: "color",
      get: function get() {
        return this._color.toHslString();
      },
      set: function set(value) {
        var color = new TinyColor(value);

        if (!color.isValid) {
          color = new TinyColor("hsla(0, 100%, 50%, 1)");
          value = color.toHslString();
        }

        this._color = color;
        this._hue = colorUtil.getHue(value);

        this._reflectAttribute('color', colorUtil.toHslString(this._hue, this._color.toHslString()));

        if (this._subView) {
          this._subView.style["background-color"] = colorUtil.toHslString(this._hue, this._color.toHslString());
        }
      }
      /** @ignore */

    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(ColorHandle), "observedAttributes", this).concat(['disabled', 'color']);
      }
    }]);

    return ColorHandle;
  }(BaseComponent(HTMLElement));

  /**
   * Copyright 2021 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var translations$e = {
    "en-US": {
      "Hex": "Hex",
      "Hex3": "Hex3",
      "Hex4": "Hex4",
      "Hex8": "Hex8",
      "RGB": "RGB",
      "HSV": "HSV",
      "HSL": "HSL",
      "Name": "Name",
      "Hue": "Hue",
      "Color Value": "Color Value",
      "Enter Color Value": "Enter Color Value",
      "Color Picker": "Color Picker",
      "Saturation and Brightness": "Saturation and Brightness",
      "Saturation": "Saturation",
      "Brightness": "Brightness",
      "Select Color Format": "Select Color Format"
    },
    "cs-CZ": {
      "Brightness": "Jas",
      "Color Picker": "Výběr barvy",
      "Color Value": "Barevná hodnota",
      "Enter Color Value": "Zadejte barevnou hodnotu",
      "HSL": "HSL",
      "HSV": "HSV",
      "Hex": "Hex",
      "Hex3": "Hex3",
      "Hex4": "Hex4",
      "Hex8": "Hex8",
      "Hue": "Odstín",
      "Name": "Název",
      "RGB": "RGB",
      "Saturation": "Sytost",
      "Saturation and Brightness": "Sytost a jas",
      "Select Color Format": "Vyberte formát barvy"
    },
    "da-DK": {
      "Brightness": "Lysstyrke",
      "Color Picker": "Farvevælger",
      "Color Value": "Farveværdi",
      "Enter Color Value": "Angiv farveværdi",
      "HSL": "HSL",
      "HSV": "HSV",
      "Hex": "Hex",
      "Hex3": "Hex3",
      "Hex4": "Hex4",
      "Hex8": "Hex8",
      "Hue": "Farvetone",
      "Name": "Navn",
      "RGB": "RGB",
      "Saturation": "Mætning",
      "Saturation and Brightness": "Mætning og lysstyrke",
      "Select Color Format": "Vælg farveformat"
    },
    "de-DE": {
      "Brightness": "Helligkeit",
      "Color Picker": "Farbwähler",
      "Color Value": "Farbwert",
      "Enter Color Value": "Farbwert eingeben",
      "HSL": "HSL",
      "HSV": "HSV",
      "Hex": "Hex",
      "Hex3": "Hex3",
      "Hex4": "Hex4",
      "Hex8": "Hex8",
      "Hue": "Farbton",
      "Name": "Name",
      "RGB": "RGB",
      "Saturation": "Sättigung",
      "Saturation and Brightness": "Sättigung und Helligkeit",
      "Select Color Format": "Farbformat auswählen"
    },
    "es-ES": {
      "Brightness": "Brillo",
      "Color Picker": "Selector de color",
      "Color Value": "Valor del color",
      "Enter Color Value": "Indique el valor del color",
      "HSL": "HSL",
      "HSV": "HSV",
      "Hex": "Valor hexadecimal",
      "Hex3": "Hex3",
      "Hex4": "Hex4",
      "Hex8": "Hex8",
      "Hue": "Tono",
      "Name": "Nombre",
      "RGB": "RGB",
      "Saturation": "Saturación",
      "Saturation and Brightness": "Saturación y brillo",
      "Select Color Format": "Seleccione el formato del color"
    },
    "fi-FI": {
      "Brightness": "Kirkkaus",
      "Color Picker": "Värimuokkain",
      "Color Value": "Värin arvo",
      "Enter Color Value": "Syötä värin arvo",
      "HSL": "HSL",
      "HSV": "HSV",
      "Hex": "Hex",
      "Hex3": "Hex3",
      "Hex4": "Hex4",
      "Hex8": "Hex8",
      "Hue": "Sävy",
      "Name": "Nimi",
      "RGB": "RGB",
      "Saturation": "Kylläisyys",
      "Saturation and Brightness": "Kylläisyys ja kirkkaus",
      "Select Color Format": "Valitse värimuoto"
    },
    "fr-FR": {
      "Brightness": "Luminosité",
      "Color Picker": "Sélecteur de couleurs",
      "Color Value": "Valeur de la couleur",
      "Enter Color Value": "Saisir la valeur de la couleur",
      "HSL": "HSL",
      "HSV": "HSV",
      "Hex": "Hex",
      "Hex3": "Hex3",
      "Hex4": "Hex4",
      "Hex8": "Hex8",
      "Hue": "Teinte",
      "Name": "Nom",
      "RGB": "RGB",
      "Saturation": "Saturation",
      "Saturation and Brightness": "Saturation et luminosité",
      "Select Color Format": "Sélectionner le format de couleur"
    },
    "it-IT": {
      "Brightness": "Luminosità",
      "Color Picker": "Selettore colore",
      "Color Value": "Valore colore",
      "Enter Color Value": "Immetti il valore del colore",
      "HSL": "HSL",
      "HSV": "HSV",
      "Hex": "Hex",
      "Hex3": "Hex3",
      "Hex4": "Hex4",
      "Hex8": "Hex8",
      "Hue": "Tonalità",
      "Name": "Nome",
      "RGB": "RGB",
      "Saturation": "Saturazione",
      "Saturation and Brightness": "Saturazione e luminosità",
      "Select Color Format": "Seleziona il formato del colore"
    },
    "ja-JP": {
      "Brightness": "明るさ",
      "Color Picker": "カラーピッカー",
      "Color Value": "カラー値",
      "Enter Color Value": "カラー値を入力",
      "HSL": "HSL",
      "HSV": "HSV",
      "Hex": "16 進数",
      "Hex3": "Hex3",
      "Hex4": "Hex4",
      "Hex8": "Hex8",
      "Hue": "色相",
      "Name": "名前",
      "RGB": "RGB",
      "Saturation": "彩度",
      "Saturation and Brightness": "彩度と明るさ",
      "Select Color Format": "カラー形式を選択"
    },
    "ko-KR": {
      "Brightness": "명도",
      "Color Picker": "색상 피커",
      "Color Value": "색상 값",
      "Enter Color Value": "색상 값 입력",
      "HSL": "HSL",
      "HSV": "HSV",
      "Hex": "Hex",
      "Hex3": "Hex3",
      "Hex4": "Hex4",
      "Hex8": "Hex8",
      "Hue": "색조",
      "Name": "이름",
      "RGB": "RGB",
      "Saturation": "채도",
      "Saturation and Brightness": "채도 및 명도",
      "Select Color Format": "색상 포맷 선택"
    },
    "nb-NO": {
      "Brightness": "Lysstyrke",
      "Color Picker": "Fargevelger",
      "Color Value": "Fargeverdi",
      "Enter Color Value": "Angi fargeverdi",
      "HSL": "HSL",
      "HSV": "HSV",
      "Hex": "Hex",
      "Hex3": "Hex3",
      "Hex4": "Hex4",
      "Hex8": "Hex8",
      "Hue": "Fargetone",
      "Name": "Navn",
      "RGB": "RGB",
      "Saturation": "Metning",
      "Saturation and Brightness": "Metning og lysstyrke",
      "Select Color Format": "Velg fargeformat"
    },
    "nl-NL": {
      "Brightness": "Helderheid",
      "Color Picker": "Kleurkiezer",
      "Color Value": "Kleurwaarde",
      "Enter Color Value": "Kleurwaarde invoeren",
      "HSL": "HSL",
      "HSV": "HSV",
      "Hex": "Hex",
      "Hex3": "Hex3",
      "Hex4": "Hex4",
      "Hex8": "Hex8",
      "Hue": "Kleurtoon",
      "Name": "Naam",
      "RGB": "RGB",
      "Saturation": "Verzadiging",
      "Saturation and Brightness": "Verzadiging en helderheid",
      "Select Color Format": "Kleuropmaak selecteren"
    },
    "pl-PL": {
      "Brightness": "Jasność",
      "Color Picker": "Próbnik kolorów",
      "Color Value": "Wartość koloru",
      "Enter Color Value": "Wprowadź wartość koloru",
      "HSL": "HSL",
      "HSV": "HSV",
      "Hex": "Hex",
      "Hex3": "Hex3",
      "Hex4": "Hex4",
      "Hex8": "Hex8",
      "Hue": "Odcień",
      "Name": "Nazwa",
      "RGB": "RGB",
      "Saturation": "Nasycenie",
      "Saturation and Brightness": "Nasycenie i jasność",
      "Select Color Format": "Wybierz format kolorów"
    },
    "pt-BR": {
      "Brightness": "Brilho",
      "Color Picker": "Seletor de cores",
      "Color Value": "Valor da cor",
      "Enter Color Value": "Insira o valor da cor",
      "HSL": "HSL",
      "HSV": "HSV",
      "Hex": "Hexadecimal",
      "Hex3": "Hex3",
      "Hex4": "Hex4",
      "Hex8": "Hex8",
      "Hue": "Matiz",
      "Name": "Nome",
      "RGB": "RGB",
      "Saturation": "Saturação",
      "Saturation and Brightness": "Saturação e brilho",
      "Select Color Format": "Selecione o formato da cor"
    },
    "ru-RU": {
      "Brightness": "Яркость",
      "Color Picker": "Палитра цветов",
      "Color Value": "Значение цвета",
      "Enter Color Value": "Введите значение цвета",
      "HSL": "HSL",
      "HSV": "HSV",
      "Hex": "Hex",
      "Hex3": "Hex3",
      "Hex4": "Hex4",
      "Hex8": "Hex8",
      "Hue": "Hue",
      "Name": "Имя",
      "RGB": "RGB",
      "Saturation": "Насыщенность",
      "Saturation and Brightness": "Насыщенность и яркость",
      "Select Color Format": "Выберите формат цвета"
    },
    "sv-SE": {
      "Brightness": "Ljusstyrka",
      "Color Picker": "Färgväljaren",
      "Color Value": "Färgvärde",
      "Enter Color Value": "Ange färgvärde",
      "HSL": "HSL",
      "HSV": "HSV",
      "Hex": "Hex",
      "Hex3": "Hex3",
      "Hex4": "Hex4",
      "Hex8": "Hex8",
      "Hue": "Nyans",
      "Name": "Namn",
      "RGB": "RGB",
      "Saturation": "Mättnad",
      "Saturation and Brightness": "Mättnad och ljusstyrka",
      "Select Color Format": "Välj färgformat"
    },
    "tr-TR": {
      "Brightness": "Parlaklık",
      "Color Picker": "Renk Seçici",
      "Color Value": "Renk Değeri",
      "Enter Color Value": "Renk Değerini Gir",
      "HSL": "HSL",
      "HSV": "HSV",
      "Hex": "Hex",
      "Hex3": "Hex3",
      "Hex4": "Hex4",
      "Hex8": "Hex8",
      "Hue": "Ton",
      "Name": "Adı",
      "RGB": "RGB",
      "Saturation": "Doygunluk",
      "Saturation and Brightness": "Doygunluk ve Parlaklık",
      "Select Color Format": "Renk Formatını Seç"
    },
    "zh-CN": {
      "Brightness": "亮度",
      "Color Picker": "拾色器",
      "Color Value": "颜色值",
      "Enter Color Value": "输入颜色值",
      "HSL": "HSL",
      "HSV": "HSV",
      "Hex": "Hex",
      "Hex3": "Hex3",
      "Hex4": "Hex4",
      "Hex8": "Hex8",
      "Hue": "色相",
      "Name": "名称",
      "RGB": "RGB",
      "Saturation": "饱和度",
      "Saturation and Brightness": "饱和度和亮度",
      "Select Color Format": "选择颜色格式"
    },
    "zh-TW": {
      "Brightness": "亮度",
      "Color Picker": "檢色器",
      "Color Value": "顏色值",
      "Enter Color Value": "輸入顏色值",
      "HSL": "HSL",
      "HSV": "HSV",
      "Hex": "Hex",
      "Hex3": "Hex3",
      "Hex4": "Hex4",
      "Hex8": "Hex8",
      "Hue": "色相",
      "Name": "名稱",
      "RGB": "RGB",
      "Saturation": "飽和度",
      "Saturation and Brightness": "飽和度和亮度",
      "Select Color Format": "選取顏色格式"
    }
  };

  /**
   * Copyright 2021 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons.extend(strings, {
    'coral-component-colorpicker': translations$e
  }); // Expose component on the Coral namespace

  commons._define('coral-colorpicker', ColorPicker);

  commons._define('coral-colorpicker-colorproperties', ColorProperties);

  commons._define('coral-colorpicker-colorarea', ColorArea);

  commons._define('coral-colorpicker-colorsliderhue', ColorSliderHue);

  commons._define('coral-colorpicker-colorhandle', ColorHandle);

  ColorPicker.ColorProperties = ColorProperties;
  ColorPicker.ColorHandle = ColorHandle;
  ColorPicker.ColorArea = ColorArea;
  ColorPicker.ColorSliderHue = ColorSliderHue;

  var template$C = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["accessibilityState"] = document.createElement("span");
    el0.setAttribute("handle", "accessibilityState");
    el0.className += " u-coral-screenReaderOnly";
    el0.setAttribute("aria-hidden", "true");
    el0.id = data_0["commons"]["getUID"]();
    el0.setAttribute("role", "presentation");
    el0.setAttribute("aria-live", "off");
    el0.setAttribute("aria-atomic", "true");
    frag.appendChild(el0);
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    return frag;
  };

  /**
   @class Coral.ColumnView.Collection
   @classdesc The ColumnView collection
   @extends {SelectableCollection}
   */

  var ColumnViewCollection = /*#__PURE__*/function (_SelectableCollection) {
    _inherits(ColumnViewCollection, _SelectableCollection);

    var _super = _createSuper(ColumnViewCollection);

    function ColumnViewCollection() {
      _classCallCheck(this, ColumnViewCollection);

      return _super.apply(this, arguments);
    }

    _createClass(ColumnViewCollection, [{
      key: "_deselectAndDeactivateAllExcept",
      value: function _deselectAndDeactivateAllExcept(item) {
        this.getAll().forEach(function (el) {
          if (el.hasAttribute('selected') || el.hasAttribute('active')) {
            el.removeAttribute('selected');

            if (el !== item) {
              el.removeAttribute('active');
            }
          }
        });
      }
    }, {
      key: "_deactivateAll",
      value: function _deactivateAll() {
        this._deselectAllExcept(null, 'active');
      }
    }, {
      key: "_deactivateAllExceptFirst",
      value: function _deactivateAllExceptFirst() {
        this._deselectAllExceptFirst('active');
      }
    }, {
      key: "_getAllActive",
      value: function _getAllActive() {
        return this._getAllSelected('active');
      }
    }, {
      key: "_selectAll",
      value: function _selectAll() {
        this.getAll().forEach(function (el) {
          if (!el.hasAttribute('selected')) {
            el.setAttribute('selected', '');
          }
        });
      }
    }]);

    return ColumnViewCollection;
  }(SelectableCollection);

  /**
   * Copyright 2020 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   * Helper function to test whether event.target is explicitly marked as interactive.
   *
   * Interactive elements included in an Item should respond to keyboard events without the event being handled by the Item as well.
   *
   * @private
   */
  var isInteractiveTarget = function isInteractiveTarget(target) {
    return target.hasAttribute('coral-interactive') || target.closest('[coral-interactive]') !== null;
  };

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   Enumeration for {@link ColumnView} selection options.

   @typedef {Object} ColumnViewSelectionModeEnum

   @property {String} NONE
   None is default, selection of items does not happen based on click.
   @property {String} SINGLE
   Single selection mode, only one item per column can be selected.
   @property {String} MULTIPLE
   Multiple selection mode, multiple items per column can be selected.
   */
  var selectionMode$1 = {
    NONE: 'none',
    SINGLE: 'single',
    MULTIPLE: 'multiple'
  };

  var CLASSNAME$U = '_coral-MillerColumns';

  var scrollTo = function scrollTo(element, to, duration, scrollCallback) {
    if (duration <= 0) {
      if (scrollCallback) {
        scrollCallback();
      }

      return;
    }

    var difference = to - element.scrollLeft;
    var perTick = difference / duration * 10;
    window.setTimeout(function () {
      element.scrollLeft = element.scrollLeft + perTick;

      if (element.scrollLeft === to) {
        if (scrollCallback) {
          scrollCallback();
        }
      } else {
        scrollTo(element, to, duration - 10, scrollCallback);
      }
    }, 10);
  };
  /**
   @class Coral.ColumnView
   @classdesc A ColumnView component to display and allow users to browse and select items in a dynamic tree structure
   (e.g. a filesystem or multi-level navigation).
   @htmltag coral-columnview
   @extends {HTMLElement}
   @extends {BaseComponent}
   */


  var ColumnView = Decorator( /*#__PURE__*/function (_BaseComponent) {
    _inherits(_class, _BaseComponent);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this); // Content zone

      _this._elements = {
        accessibilityState: _this.querySelector('span[handle="accessibilityState"]')
      };

      if (!_this._elements.accessibilityState) {
        // Templates
        template$C.call(_this._elements, {
          commons: commons
        });

        _this._elements.accessibilityState.removeAttribute('aria-hidden');

        _this._elements.accessibilityState.hidden = true;
      } // Events


      _this._delegateEvents({
        // Prevents text selection while selecting multiple items
        'global:keyup': '_onGlobalKeyUp',
        'global:keydown': '_onGlobalKeyDown',
        'key:up': '_onKeyUp',
        'key:down': '_onKeyDown',
        'key:right': '_onKeyRight',
        'key:left': '_onKeyLeft',
        'key:shift+up': '_onKeyShiftAndUp',
        'key:shift+down': '_onKeyShiftAndDown',
        'key:space': '_onKeySpace',
        'key:control+a': '_onKeyCtrlA',
        'key:command+a': '_onKeyCtrlA',
        'key:control+shift+a': '_onKeyCtrlShiftA',
        'key:command+shift+a': '_onKeyCtrlShiftA',
        'key:esc': '_onKeyCtrlShiftA',
        'capture:focus coral-columnview-item': '_onItemFocus',
        'mousedown coral-columnview-item': '_onItemMouseDown',
        'mouseup coral-columnview-item': '_onItemMouseUp',
        // column events
        'coral-columnview-column:_loaditems': '_onColumnLoadItems',
        'coral-columnview-column:_activeitemchanged': '_onColumnActiveItemChanged',
        'coral-columnview-column:_selecteditemchanged': '_onColumnSelectedItemChanged'
      }); // Defaults


      _this._oldActiveItem = null;
      _this._oldSelection = []; // default value of inner flag to process events

      _this._bulkSelectionChange = false; // initializes the mutation observer that used to detect when new items are added or removed

      _this._observer = new MutationObserver(_this._handleMutation.bind(_assertThisInitialized(_this)));

      _this._observer.observe(_assertThisInitialized(_this), {
        // only watch the childList, items will tell us if selected/value/content changes
        childList: true
      }); // Init the collection mutation observer


      _this.items._startHandlingItems(true);

      _this.columns._startHandlingItems(true);

      return _this;
    }
    /**
     Collection that holds all the columns inside the ColumnView.
      @type {ColumnViewCollection}
     @readonly
     */


    _createClass(_class, [{
      key: "_onColumnActiveItemChanged",

      /** @private */
      value: function _onColumnActiveItemChanged(event) {
        // this is a private event and should not leave the column view
        event.stopImmediatePropagation(); // ignores event handling due to bulk select operation

        if (this._bulkSelectionChange) {
          return;
        }

        var column = event.target; // clears the internal selection cursor

        this._handleKeyboardMultiselect(null);

        this._bulkSelectionChange = true;

        if (!event.detail.activeItem) {
          // all items to the right must be removed. we do this at the end to be able to extract the values before
          // removing everything
          this._afterItemSelectedInColumn(column);
        } else {
          // when there is an active item, selection must not exist
          this.items._deselectAllExcept(); // we need to deactivate every item to the right of the new active item to keep a correct DOM representation


          var nextColumn = column.nextElementSibling;

          while (nextColumn) {
            // We ignore preview columns
            if (nextColumn.tagName === 'CORAL-COLUMNVIEW-COLUMN' && nextColumn.items) {
              nextColumn.items._deactivateAll();
            }

            nextColumn = nextColumn.nextElementSibling;
          }
        }

        this._bulkSelectionChange = false; // we trigger the appropiate events

        this._validateColumnViewChange();
      }
      /**
       Requests external data to be loaded.
        @emits {coral-columnview:loaditems}
        @private
       */

    }, {
      key: "_onColumnLoadItems",
      value: function _onColumnLoadItems(event) {
        // this is a private event and should not leave the column view
        event.stopImmediatePropagation();

        this._updateAriaLevel(event.target);

        this._ensureTabbableItem(); // triggers an event to indicate more data could be loaded


        this.trigger('coral-columnview:loaditems', {
          column: event.target,
          start: event.detail.start,
          item: event.detail.item
        });
      }
      /**
       Handle when first selectable item is added and make sure it is tabbable.
       @param {HTMLElement} [item]
       @private
       */

    }, {
      key: "_onItemAdd",
      value: function _onItemAdd() {
        var _this2 = this;

        window.requestAnimationFrame(function () {
          return _this2._ensureTabbableItem();
        });
      }
      /**
       Handle when item is removed, make sure that at least one element is tabbable, or if there are no items, and add listener to handle when item is added.
       @param {HTMLElement} [item]
       Item that was removed.
       @private
       */

    }, {
      key: "_onItemRemoved",
      value: function _onItemRemoved() {
        var _this3 = this;

        window.requestAnimationFrame(function () {
          return _this3._ensureTabbableItem();
        });
      }
      /* @private */

    }, {
      key: "_ensureTabbableItem",
      value: function _ensureTabbableItem() {
        this._vent.off('coral-collection:add', this._onItemAdd);

        this._vent.off('coral-collection:remove', this._onItemRemoved); // Ensures that item will receive focus


        if (!this.selectedItem && !this.activeItem) {
          var selectableItems = this.items._getSelectableItems(); // If there are no selectable items, stop listening for items being removed and start listening for the next item added.


          if (!selectableItems.length) {
            this._vent.off('coral-collection:remove', this._onItemRemoved);

            this._vent.on('coral-collection:add', this._onItemAdd);
          } else {
            // Otherwise, if there is a selectable item, make sure it has a tabIndex.
            selectableItems[0].tabIndex = 0; // Listen for item removal so that we can handle the edge case where all items have been removed.

            this._vent.on('coral-collection:remove', this._onItemRemoved);
          }
        } else if (this.selectedItem && this.selectedItem.tabIndex !== 0) {
          // If the selectedItem is not tabbable, make sure that it has tabIndex === 0
          this.selectedItem.tabIndex = 0;
        } else if (this.activeItem && this.activeItem.tabIndex !== 0) {
          // If the activeItem is not tabbable, make sure that it has tabIndex === 0
          this.activeItem.tabIndex = 0;
        }
      }
      /** @private */

    }, {
      key: "_onColumnSelectedItemChanged",
      value: function _onColumnSelectedItemChanged(event) {
        // this is a private event and should not leave the column view
        event.stopImmediatePropagation(); // ignores event handling due to bulk select operation

        if (this._bulkSelectionChange || this.selectionMode === selectionMode$1.NONE) {
          return;
        }

        this._bulkSelectionChange = true; // we need to deselect any other selection that is not part of the same column

        this._oldSelection.forEach(function (el) {
          if (event.detail.selection.indexOf(el) === -1) {
            el.removeAttribute('selected');
          }
        });

        this._bulkSelectionChange = false; // we trigger the appropiate events

        this._validateColumnViewChange();
      }
      /** @private */

    }, {
      key: "_onGlobalKeyUp",
      value: function _onGlobalKeyUp(event) {
        // removes the class to stop selection
        if (event.keyCode === 16 && !isInteractiveTarget(event.target)) {
          this.classList.remove('is-unselectable');
        }
      }
      /** @private */

    }, {
      key: "_onGlobalKeyDown",
      value: function _onGlobalKeyDown(event) {
        // adds a class that prevents the text selection, otherwise shift + click would select the text
        if (event.keyCode === 16 || !isInteractiveTarget(event.target)) {
          this.classList.add('is-unselectable');
        }
      }
      /** @private */

    }, {
      key: "_onKeyShiftAndUp",
      value: function _onKeyShiftAndUp(event) {
        var matchedTarget = this._getRealMatchedTarget(event); // don't select items when focus is within the preview


        if (matchedTarget.closest('coral-columnview-preview') || isInteractiveTarget(event.target)) {
          return;
        }

        event.preventDefault();

        if (this.selectionMode === selectionMode$1.NONE) {
          this._onKeyUp(event);

          return;
        } // using _oldSelection since it should be equivalent to this.items._getSelectedItems() but faster


        var oldSelectedItems = this._oldSelection;
        this._isKeyBoardMultiselect = true; // first make sure to select the active item as we want to multiselect

        if (oldSelectedItems.length === 0) {
          var activeItem = this.activeItem;

          if (activeItem) {
            activeItem.setAttribute('selected', '');
          }
        } // gets all the selected items of the active column. calling _getSelectedItems() will include the active item
        // if it was selected


        var selectedItems = this.items._getAllSelected(); // reference of the last selected item to know the direction of the selection while using the multiselection


        var lastSelected = this._lastSelected;
        var selectedItem; // when no previous selection is stored we need to initialize it with the current information

        if (!lastSelected) {
          selectedItem = selectedItems[0].previousElementSibling; // selects the item

          selectedItem.setAttribute('selected', '');
        } else if (lastSelected.item) {
          selectedItem = lastSelected.item; // we have reached the upper selection limit

          if (selectedItem.matches(':first-child')) {
            this._isKeyBoardMultiselect = false;
            return;
          }

          if (!lastSelected.direction || lastSelected.direction === 'up') {
            selectedItem = selectedItem.previousElementSibling;
            selectedItem.setAttribute('selected', '');
          } else {
            if (selectedItem !== lastSelected.firstSelectedItem) {
              selectedItem.removeAttribute('selected');
            } else {
              // switches the direction if this was the last item selected
              lastSelected.direction = 'up';
            }

            selectedItem = selectedItem.previousElementSibling;
            selectedItem.setAttribute('selected', '');
          }
        } // stores the reference and direction to be able to perform the multiple selection correctly


        this._lastSelected = {
          item: selectedItem,
          direction: lastSelected && lastSelected.direction ? lastSelected.direction : 'up',
          firstSelectedItem: lastSelected && lastSelected.firstSelectedItem ? lastSelected.firstSelectedItem : selectedItem.nextElementSibling
        };

        if (selectedItem && selectedItem !== document.activeElement) {
          selectedItem.focus();
        }

        this._isKeyBoardMultiselect = false;
      }
      /** @private */

    }, {
      key: "_onKeyShiftAndDown",
      value: function _onKeyShiftAndDown(event) {
        var matchedTarget = this._getRealMatchedTarget(event); // don't select items when focus is within the preview


        if (matchedTarget.closest('coral-columnview-preview') || isInteractiveTarget(event.target)) {
          return;
        }

        event.preventDefault();

        if (this.selectionMode === selectionMode$1.NONE) {
          this._onKeyDown(event);

          return;
        } // using _oldSelection since it should be equivalent to this.items._getSelectedItems() but faster


        var oldSelectedItems = this._oldSelection;
        this._isKeyBoardMultiselect = true; // first make sure to select the active item as we want to multiselect

        if (oldSelectedItems.length === 0) {
          var activeItem = this.activeItem;

          if (activeItem) {
            activeItem.setAttribute('selected', '');
          }
        } // gets all the selected items of the active column. calling _getSelectedItems() will include the active item
        // if it was selected


        var selectedItems = this.items._getAllSelected(); // reference of the last selected item to know the direction of the selection while using the multiselection


        var lastSelected = this._lastSelected;
        var selectedItem; // when no previous selection is stored we need to initialize it with the current information

        if (!lastSelected) {
          selectedItem = selectedItems[selectedItems.length - 1].nextElementSibling; // selects the item

          selectedItem.setAttribute('selected', '');
        } else if (lastSelected.item) {
          selectedItem = lastSelected.item; // we have reached the lower selection limit

          if (selectedItem.matches(':last-child')) {
            this._isKeyBoardMultiselect = false;
            return;
          }

          if (!lastSelected.direction || lastSelected.direction === 'down') {
            selectedItem = selectedItem.nextElementSibling;
            selectedItem.setAttribute('selected', '');
          } else {
            if (selectedItem !== lastSelected.firstSelectedItem) {
              selectedItem.removeAttribute('selected');
            } else {
              // switches the direction if this was the last item selected
              lastSelected.direction = 'down';
            }

            selectedItem = selectedItem.nextElementSibling;
            selectedItem.setAttribute('selected', '');
          }
        } // stores the reference and direction to be able to perform the multiple selection correctly


        this._lastSelected = {
          item: selectedItem,
          direction: lastSelected && lastSelected.direction ? lastSelected.direction : 'down',
          firstSelectedItem: lastSelected && lastSelected.firstSelectedItem ? lastSelected.firstSelectedItem : selectedItem.previousElementSibling
        };

        if (selectedItem && selectedItem !== document.activeElement) {
          selectedItem.focus();
        }

        this._isKeyBoardMultiselect = false;
      }
      /** @private */

    }, {
      key: "_onKeyUp",
      value: function _onKeyUp(event) {
        var matchedTarget = this._getRealMatchedTarget(event); // don't navigate items when focus is within the preview


        if (matchedTarget.closest('coral-columnview-preview') || isInteractiveTarget(event.target)) {
          return;
        }

        event.preventDefault(); // selection will win over active buttons, because they are the right most item. using _oldSelection since it
        // should be equivalent to this.items._getSelectedItems() but faster

        var selectedItems = this._oldSelection;
        var item;

        if (selectedItems.length !== 0) {
          var selectedItem = matchedTarget;
          item = selectedItem.previousElementSibling;

          if (!item) {
            item = selectedItem;
          }
        } // when there is no active item to select, we get the last item of the column. this way users can interact with
        // the column view when there is nothing selected or activated
        else if (this._oldActiveItem === null) {
            item = this.items._getLastSelectable();
          } else {
            item = this._oldActiveItem.previousElementSibling;
          } // we use click instead of selected to force the deselection of the other items


        if (item && item !== document.activeElement) {
          item.focus();

          if (this.selectionMode === selectionMode$1.NONE || selectedItems.length === 0 || // For use case in cascading schema editor,
          // where the focused item is not in the same column as the selected items,
          // we should activate the item so that coral-columnview:activeitemchange gets called.
          item.parentElement !== selectedItems[0].parentElement) {
            item.click();
          }
        }
      }
      /** @private */

    }, {
      key: "_onKeyDown",
      value: function _onKeyDown(event) {
        var matchedTarget = this._getRealMatchedTarget(event); // don't navigate items when focus is within the preview


        if (matchedTarget.closest('coral-columnview-preview') || isInteractiveTarget(event.target)) {
          return;
        }

        event.preventDefault(); // selection will win over active buttons, because they are the right most item. using _oldSelection since it
        // should be equivalent to this.items._getSelectedItems() but faster

        var selectedItems = this._oldSelection;
        var item;

        if (selectedItems.length !== 0) {
          var selectedItem = matchedTarget;
          item = selectedItem.nextElementSibling; // when

          if (!item) {
            item = matchedTarget;
          }
        } // when there is no active item to select, we get the first item of the column. this way users can interact with
        // the column view when there is nothing selected or activated
        else if (this._oldActiveItem === null) {
            item = this.items._getFirstSelectable();
          } else {
            item = this._oldActiveItem.nextElementSibling;
          } // we use click instead of selected to force the deselection of the other items


        if (item && item !== document.activeElement) {
          item.focus();

          if (this.selectionMode === selectionMode$1.NONE || selectedItems.length === 0 || // For use case in cascading schema editor,
          // where the focused item is not in the same column as the selected items,
          // we should activate the item so that coral-columnview:activeitemchange gets called.
          item.parentElement !== selectedItems[0].parentElement) {
            item.click();
          }
        }
      }
      /** @private */

    }, {
      key: "_onKeyRight",
      value: function _onKeyRight(event) {
        var _this4 = this;

        var matchedTarget = this._getRealMatchedTarget(event);

        if (matchedTarget.variant !== ColumnView.Item.variant.DRILLDOWN) {
          return false;
        }

        if (isInteractiveTarget(event.target)) {
          return;
        }

        event.preventDefault(); // we can only navigate right when there is a column on the right side to navigate to

        var nextColumn; // using _oldSelection since it should be equivalent to this.items._getSelectedItems() but faster

        var selectedItems = this._oldSelection; // when there is an active item, we use the item containing the active item as reference

        if (matchedTarget) {
          nextColumn = matchedTarget.closest('coral-columnview-column').nextElementSibling;
        } // otherwise when there is selection, we use the item containing the selected items as reference
        else if (selectedItems.length !== 0) {
            nextColumn = selectedItems[0].closest('coral-columnview-column').nextElementSibling;
          }

        if (nextColumn && nextColumn.tagName === 'CORAL-COLUMNVIEW-COLUMN') {
          // we need to make sure the column is initialized
          commons.ready(nextColumn, function () {
            return _this4._focusAndActivateFirstSelectableItem(nextColumn);
          });
        }
      }
      /** @private */

    }, {
      key: "_onKeyLeft",
      value: function _onKeyLeft(event) {
        if (isInteractiveTarget(event.target)) {
          return;
        }

        event.preventDefault(); // we can only navigate left when there is a column on the left side to navigate to

        var previousColumn; // using _oldSelection since it should be equivalent to this.items._getSelectedItems() but faster

        var selectedItems = this._oldSelection; // when there is selection, we use the previous column as a reference

        if (selectedItems.length !== 0) {
          previousColumn = selectedItems[0].closest('coral-columnview-column').previousElementSibling;
        } // otherwise we use the activeItems as a reference
        else if (this.activeItem) {
            var col = this.activeItem.closest('coral-columnview-column');
            previousColumn = event.target.closest('coral-columnview-preview') ? col : col.previousElementSibling;
          }

        if (previousColumn && previousColumn.tagName === 'CORAL-COLUMNVIEW-COLUMN') {
          // we need to make sure the column is initialized
          var activeDescendant = previousColumn.activeItem || previousColumn.items._getFirstSelected() || previousColumn.items._getFirstSelectable();

          if (activeDescendant && activeDescendant !== document.activeElement) {
            activeDescendant.focus();

            if (this.selectionMode === selectionMode$1.NONE || selectedItems.length === 0) {
              activeDescendant.click();
            }
          }
        }
      }
      /** @private */

    }, {
      key: "_onKeySpace",
      value: function _onKeySpace(event) {
        var matchedTarget = this._getRealMatchedTarget(event); // don't select item when focus is within the preview


        if (matchedTarget.closest('coral-columnview-preview') || isInteractiveTarget(event.target)) {
          return;
        }

        event.preventDefault(); // using _oldSelection since it should be equivalent to this.items._getSelectedItems() but faster

        var selectedItems = this._oldSelection;
        var activeDescendant; // when there is a selection, we need to activate the first item of the selection

        if (selectedItems.length !== 0) {
          activeDescendant = matchedTarget;

          if (activeDescendant.hasAttribute('selected', '')) {
            if (selectedItems.length === 1) {
              activeDescendant.setAttribute('active', '');
            } else {
              activeDescendant.removeAttribute('selected', '');
            }
          } else {
            activeDescendant.setAttribute('selected', '');
          }
        } else {
          var activeItem = this.activeItem || matchedTarget; // toggles the selection between active and selected

          if (activeItem && this.selectionMode !== selectionMode$1.NONE) {
            // select the item
            activeItem.setAttribute('selected', '');
            activeDescendant = activeItem;
          }
        }
      }
      /** @private */

    }, {
      key: "_onKeyCtrlA",
      value: function _onKeyCtrlA(event) {
        var matchedTarget = this._getRealMatchedTarget(event); // don't select item when focus is within the preview


        if (matchedTarget.closest('coral-columnview-preview') || isInteractiveTarget(event.target)) {
          return;
        }

        event.preventDefault();

        if (this.selectionMode === selectionMode$1.MULTIPLE) {
          var currentColumn = matchedTarget.closest('coral-columnview-column');

          currentColumn.items._selectAll();
        } else if (this.selectionMode === selectionMode$1.SINGLE) {
          if (!matchedTarget.hasAttribute('selected')) {
            matchedTarget.setAttribute('selected', '');
          }
        }
      }
      /** @private */

    }, {
      key: "_onKeyCtrlShiftA",
      value: function _onKeyCtrlShiftA(event) {
        var matchedTarget = this._getRealMatchedTarget(event); // don't select item when focus is within the preview


        if (matchedTarget.closest('coral-columnview-preview') || isInteractiveTarget(event.target)) {
          return;
        }

        event.preventDefault();

        if (this.selectionMode !== selectionMode$1.NONE) {
          var currentColumn = matchedTarget.closest('coral-columnview-column');

          currentColumn.items._deselectAndDeactivateAllExcept(matchedTarget);

          if (!matchedTarget.hasAttribute('active')) {
            matchedTarget.setAttribute('active', '');
          }
        }
      }
      /** @private */

    }, {
      key: "_onItemFocus",
      value: function _onItemFocus(event) {
        if (isInteractiveTarget(event.target)) {
          return;
        }

        var matchedTarget = this._getRealMatchedTarget(event);

        if (!this.activeItem && !this._oldSelection.length && !matchedTarget._flagMouseDown) {
          matchedTarget.setAttribute('active', '');
        }

        this.items._getSelectableItems().forEach(function (item) {
          item.tabIndex = item === matchedTarget ? 0 : -1;
        });

        if (matchedTarget.contains(document.activeElement)) {
          matchedTarget.focus();
        }
      }
      /** @ignore */

    }, {
      key: "_onItemMouseDown",
      value: function _onItemMouseDown(event) {
        if (isInteractiveTarget(event.target)) {
          return;
        }

        var matchedTarget = this._getRealMatchedTarget(event);

        matchedTarget._flagMouseDown = true;
      }
      /** @ignore */

    }, {
      key: "_onItemMouseUp",
      value: function _onItemMouseUp(event) {
        if (isInteractiveTarget(event.target)) {
          return;
        }

        var matchedTarget = this._getRealMatchedTarget(event);

        delete matchedTarget._flagMouseDown;
      }
      /** @ignore */

    }, {
      key: "_updateAriaLevel",
      value: function _updateAriaLevel(column) {
        var colIndex = this.columns.getAll().indexOf(column);
        var level = colIndex + 1;

        if (column.items) {
          var items = column.items.getAll();
          items.filter(function (item, index) {
            item.setAttribute('aria-posinset', index + 1);
            item.setAttribute('aria-setsize', items.length);
            return !item.hasAttribute('aria-level');
          }).forEach(function (item) {
            item.setAttribute('aria-level', level);
          });
        } // root column has role="presentation"


        if (colIndex === 0) {
          column.setAttribute('role', 'presentation'); // and should not be labeled.

          return;
        } // Make sure the column group has a label so that it can be navigated with VoiceOver


        if (!column.hasAttribute('aria-labelledby')) {
          if (!column.hasAttribute('aria-label')) {
            column.setAttribute('aria-label', this.getAttribute('aria-label') || '…');
          }
        } else if (column.getAttribute('aria-label') === (this.getAttribute('aria-label') || '…')) {
          column.removeAttribute('aria-label');
        }
      }
      /** @private */

    }, {
      key: "_arraysAreDifferent",
      value: function _arraysAreDifferent(selection, oldSelection) {
        var diff = [];

        if (oldSelection.length === selection.length) {
          diff = oldSelection.filter(function (item) {
            return selection.indexOf(item) === -1;
          });
        } // since we guarantee that they are arrays, we can start by comparing their size


        return oldSelection.length !== selection.length || diff.length !== 0;
      }
      /** @private */

    }, {
      key: "_handleKeyboardMultiselect",
      value: function _handleKeyboardMultiselect(newSelectedItem) {
        if (!this._isKeyBoardMultiselect) {
          this._lastSelected = undefined; // if there is a new selected item save this (but without direction info)

          if (newSelectedItem) {
            this._lastSelected = {
              item: newSelectedItem,
              direction: null,
              firstSelectedItem: newSelectedItem
            };
          }
        }
      }
      /**
       Scrolls the given {@link Coral.ColumnView.Column} into view.
        @param {HTMLElement} column
       The column that needs to be scrolled into view.
       @param {Boolean} clearEmptyColumns
       Remove empty columns once animation is done.
       @param {Boolean} triggerEvent
        @private
       */

    }, {
      key: "_scrollColumnIntoView",
      value: function _scrollColumnIntoView(column, clearEmptyColumns, triggerEvent) {
        var _this5 = this;

        // @todo: improve animation effect when key is kept press
        var left = 0;
        var duration; // we return if the column is not inside the current column view

        if (!this.contains(column)) {
          return;
        } // make sure to clear columns next to this column if animation is done


        var completeCallback = function completeCallback() {
          if (clearEmptyColumns) {
            _this5._removeEmptyColumnsWithSmoothTransition(triggerEvent);
          }
        }; // scroll right to the given column


        if (column.getBoundingClientRect().left + column.offsetWidth >= this.offsetWidth) {
          var next = column.nextElementSibling;

          while (next) {
            next.parentNode.removeChild(next);
            next = column.nextElementSibling;
          }

          left = this.scrollWidth - this.offsetWidth;
          duration = left - this.scrollLeft;
          scrollTo(this, left, duration, completeCallback);
        } else if (clearEmptyColumns) {
          this._removeEmptyColumnsWithSmoothTransition(triggerEvent);
        }
      }
      /**
       Handling of the column view after selecting an item.
        @param {HTMLElement} column
        @private
       */

    }, {
      key: "_afterItemSelectedInColumn",
      value: function _afterItemSelectedInColumn(column) {
        // @todo: emptying the columns allows them to be queried
        this._emptyColumnsNextToColumn(column);

        this._scrollColumnIntoView(column, true, true);
      }
      /**
       Empties all the columns to the right of the provided column.
        @param {HTMLElement} column
        @private
       */

    }, {
      key: "_emptyColumnsNextToColumn",
      value: function _emptyColumnsNextToColumn(column) {
        if (column !== null) {
          var next = column.nextElementSibling;

          while (next && next.innerHTML.length) {
            next.innerHTML = '';
            next = next.nextElementSibling;
          }
        }
      }
      /**
       Remove all empty columns with a smooth transition. Optionally the navigate event is triggered when all the extra
       columns are removed from the DOM.
        @param {Boolean} triggerEvent
       Whether the navigate event must be triggered.
        @private
       */

    }, {
      key: "_removeEmptyColumnsWithSmoothTransition",
      value: function _removeEmptyColumnsWithSmoothTransition(triggerEvent) {
        var _this6 = this;

        // fade width of empty items to 0 before removing the columns (for better usability while navigating)
        var emptyColumns = Array.prototype.filter.call(this.querySelectorAll('coral-columnview-column, coral-columnview-preview'), function (el) {
          return !el.firstChild;
        });

        if (emptyColumns.length) {
          emptyColumns.forEach(function (column, i) {
            column.style.visibility = 'hidden';
            column.classList.add('is-collapsing');
            commons.transitionEnd(column, function () {
              column.remove();

              if (i === emptyColumns.length - 1 && triggerEvent) {
                _this6._validateNavigation(_this6.columns.last());
              }
            });
            column.style.width = 0;
          });
        } else if (triggerEvent) {
          this._validateNavigation(this.columns.last());
        }
      }
      /** @private */

    }, {
      key: "_triggerCollectionEvents",
      value: function _triggerCollectionEvents(addedNodes, removedNodes) {
        var item;
        var addedNodesCount = addedNodes.length;

        for (var i = 0; i < addedNodesCount; i++) {
          item = addedNodes[i];

          if (this.activeItem) {
            // @a11y add aria-owns attribute to active item to express relationship of added column to the active item
            this.activeItem.setAttribute('aria-owns', item.id); // @a11y column or preview should be labelled by active item

            item.setAttribute('aria-labelledby', this.activeItem.content.id); // @a11y preview should provide description for active item

            if (item.tagName === 'CORAL-COLUMNVIEW-PREVIEW') {
              this.activeItem.setAttribute('aria-describedby', item.id);
            }
          }

          if (item.tagName === 'CORAL-COLUMNVIEW-COLUMN') {
            // we use the property since the item may not be ready
            item.setAttribute('_selectionmode', this.selectionMode);
            this.trigger('coral-collection:add', {
              item: item
            });

            this._updateAriaLevel(item);
          }
        } // @todo: check if special handling is needed when selected column is removed


        var removedNodesCount = removedNodes.length;

        for (var j = 0; j < removedNodesCount; j++) {
          item = removedNodes[j]; // @todo: should I handle it specially if it was selected? should a selection and active event be triggered?

          if (item.tagName === 'CORAL-COLUMNVIEW-COLUMN') {
            this.trigger('coral-collection:remove', {
              item: item
            });
          }
        }
      }
      /** @private */

    }, {
      key: "_setStateFromDOM",
      value: function _setStateFromDOM() {
        // @todo: should I trigger change events?
        // initial state of the columnview
        this._oldActiveItem = this.activeItem;
        this._oldSelection = this.selectedItems;

        this._ensureTabbableItem();

        if (this.columns) {
          var columns = this.columns.getAll();
          var self = this;
          columns.forEach(function (column) {
            self._updateAriaLevel(column);
          });
        }
      }
      /** @private */

    }, {
      key: "_handleMutation",
      value: function _handleMutation(mutations) {
        var mutationsCount = mutations.length;

        for (var i = 0; i < mutationsCount; i++) {
          var mutation = mutations[i]; // we handle the collection events

          this._triggerCollectionEvents(mutation.addedNodes, mutation.removedNodes);
        } // sets the internal state based on the existing columns


        this._setStateFromDOM();
      }
      /**
       Determines if something of the internal state of the component has changed. Active item event is always triggered
       first and then the selection event.
        @private
       */

    }, {
      key: "_validateColumnViewChange",
      value: function _validateColumnViewChange() {
        // we evaluate first the active event since we always need to trigger active first and then selection
        var activeItem = this.activeItem;
        var oldActiveItem = this._oldActiveItem; // same column events are only triggered if the active item changed, otherwise they are ignored

        if (activeItem !== oldActiveItem) {
          this.trigger('coral-columnview:activeitemchange', {
            activeItem: activeItem,
            oldActiveItem: oldActiveItem
          }); // we cache the old active item to be able to report correct change events

          this._oldActiveItem = activeItem;
        } // when there is no selection we avoid triggering any change event but we do not stop items from having the
        // selected attribute


        if (this.selectionMode === selectionMode$1.NONE) {
          return;
        }

        var newSelection = this.selectedItems;
        var oldSelection = this._oldSelection || []; // use first newly selected item for new selection

        var newSelectedItems = newSelection.filter(function (item) {
          return oldSelection.indexOf(item) === -1;
        });

        this._handleKeyboardMultiselect(newSelectedItems.length > 0 ? newSelectedItems[0] : null);

        if (this._arraysAreDifferent(newSelection, oldSelection)) {
          this.trigger('coral-columnview:change', {
            selection: newSelection,
            oldSelection: oldSelection
          }); // changes the old selection array since we selected something new

          this._oldSelection = newSelection; // announce the selection state for the focused item

          this._announceActiveElementState();
        }
      }
      /**
       Triggers the navigation event. Navigation would happen when a) a new column is added, and it is ready to be
       used or b) columns are removed and the active changed. In case the column is actually a preview column, the event
       will only be triggered when there is no selection (meanning a real navigation was performed).
        @param {HTMLElement} column
       Last column of the ColumnView.
        @emits {coral-columnview:navigate}
        @private
       */

    }, {
      key: "_validateNavigation",
      value: function _validateNavigation(column) {
        // we use _oldSelection because it is faster
        if (column.tagName === 'CORAL-COLUMNVIEW-PREVIEW' && this._oldSelection.length !== 0) {
          return;
        }

        this.trigger('coral-columnview:navigate', {
          activeItem: this.activeItem,
          column: column
        });
      }
      /* @private */

    }, {
      key: "_announceActiveElementState",
      value: function _announceActiveElementState() {
        var _this7 = this;

        // @a11y Add live region element to ensure announcement of selected state
        var accessibilityState = this._elements.accessibilityState; // @a11y accessibility state string should announce in document lang, rather than item lang.

        accessibilityState.setAttribute('lang', i18n.locale); // @a11y append live region content element

        if (!this.contains(accessibilityState)) {
          this.appendChild(accessibilityState);
        } // utility method to clean up accessibility state


        function resetAccessibilityState() {
          accessibilityState.hidden = true;
          accessibilityState.setAttribute('aria-live', 'off');
          accessibilityState.innerHTML = '';
        }

        resetAccessibilityState();

        if (this._addTimeout || this._removeTimeout) {
          clearTimeout(this._addTimeout);
          clearTimeout(this._removeTimeout);
        } // we use setTimeout instead of nextFrame to give screen reader
        // more time to respond to live region update in order to announce
        // complete text content when the state changes.


        this._addTimeout = window.setTimeout(function () {
          var activeElement = document.activeElement.closest('coral-columnview-item') || document.activeElement;

          if (!_this7.contains(activeElement) || activeElement.tagName !== 'CORAL-COLUMNVIEW-ITEM') {
            return;
          }

          var span = document.createElement('span');
          var contentSpan = document.createElement('span');
          var lang = !activeElement.hasAttribute('lang') && activeElement.closest('[lang]') ? activeElement.closest('[lang]').getAttribute('lang') : activeElement.getAttribute('lang');

          if (lang && lang !== i18n.locale) {
            contentSpan.setAttribute('lang', lang);
          }

          contentSpan.innerText = activeElement._elements.content.innerText;
          span.appendChild(contentSpan);
          span.appendChild(document.createTextNode(i18n.get(activeElement.selected ? ', checked' : ', unchecked')));
          accessibilityState.hidden = false;
          accessibilityState.setAttribute('aria-live', 'assertive');
          accessibilityState.appendChild(span); // give screen reader 2 secs before clearing the live region, to provide enough time for announcement

          _this7._removeTimeout = window.setTimeout(function () {
            resetAccessibilityState();

            if (accessibilityState.parentNode) {
              _this7._elements.accessibilityState = accessibilityState.parentNode.removeChild(accessibilityState);
            }
          }, 2000);
        }, 20);
      }
      /**
       * Helper function to extract the correct matchedTarget from the event.
       *
       * Tests can interact with ColumnView directly where the key events are triggered on
       * the ColumnView itself. In that case the event.matchedTarget point to the ColumnView
       * instead of the ColumnViewItem, in other word the active or selected element.
       *
       * @private
       **/

    }, {
      key: "_getRealMatchedTarget",
      value: function _getRealMatchedTarget(event) {
        if (event.matchedTarget.nodeName !== 'CORAL-COLUMNVIEW') {
          return event.matchedTarget;
        }

        if (event.matchedTarget.contains(document.activeElement) && document.activeElement.nodeName === 'CORAL-COLUMNVIEW-ITEM') {
          return document.activeElement;
        }

        if (event.matchedTarget.selectedItem) {
          return event.matchedTarget.selectedItem;
        }

        if (event.matchedTarget.activeItem) {
          return event.matchedTarget.activeItem;
        }
      }
    }, {
      key: "_focusAndActivateFirstSelectableItem",
      value: function _focusAndActivateFirstSelectableItem(column) {
        var item;
        var selectedItems = this.selectedItems;

        if (column.items) {
          item = column.items._getFirstSelectable();
        } else if (column.tagName === 'CORAL-COLUMNVIEW-PREVIEW') {
          item = selectedItems[0] || this.activeItem;
        }

        if (item && item !== document.activeElement) {
          item.focus();

          if (this.selectionMode === selectionMode$1.NONE || this._oldSelection.length === 0 || selectedItems.length === 0 || // For use case in cascading schema editor,
          // where the focused item is not in the same column as the selected items,
          // we should activate the item so that coral-columnview:activeitemchange gets called.
          item.parentElement !== selectedItems[0].parentElement) {
            item.click();
          }
        }
      }
      /** @ignore */

    }, {
      key: "focus",
      value: function focus() {
        // selected items go first because there is no active item in a column with selection
        var item = this.selectedItems[0] || this.activeItem;

        if (item && item !== document.activeElement) {
          item.focus();
        }
      }
      /**
       Sets the next column given a reference column. This will handle cleaning the DOM and removing any columns as
       required.
        @param {HTMLElement} newColumn
       The new column to add to the column view. It will be placed next to the <code>referenceColumn</code> if
       provided.
       @param {HTMLElement} referenceColumn
       The column that will be used as a reference to place the new column. This column needs to be already inside the
       DOM.
       @param {Boolean} [scrollToColumn = true]
       Whether the columnview show scroll to have the <code>newColumn</code> visible.
        @emits {coral-columnview:navigate}
       */

    }, {
      key: "setNextColumn",
      value: function setNextColumn(newColumn, referenceColumn, scrollToColumn) {
        var _this8 = this;

        scrollToColumn = typeof scrollToColumn === 'undefined' || scrollToColumn;
        var column = referenceColumn || null;
        var columnReplacedContainedFocus = false; // handles the case where the first column needs to be added

        if (column === null || !this.contains(column)) {
          this.appendChild(newColumn);
        } else {
          var nextColumn = column.nextElementSibling;

          if (nextColumn) {
            columnReplacedContainedFocus = nextColumn.contains(document.activeElement);

            this._emptyColumnsNextToColumn(column);

            var before = nextColumn.nextElementSibling;
            this.removeChild(nextColumn);
            this.insertBefore(newColumn, before);
          } else {
            this.appendChild(newColumn);
          }
        } // if we want to scroll to it, we need for it to be ready due to measurements


        commons.ready(newColumn, function () {
          if (scrollToColumn) {
            // event is not triggered because it is handled separately
            _this8._scrollColumnIntoView(newColumn, true, false);
          } // we notify that the columnview navigated and it is ready to be used


          _this8._validateNavigation(newColumn); // if the column the newColumn replaces contained focus, restore focus to an item in the newColumn


          if (columnReplacedContainedFocus && !newColumn.contains(document.activeElement)) {
            _this8._focusAndActivateFirstSelectableItem(newColumn);
          }
        });
      }
      /**
       Returns {@link ColumnView} selection options.
        @return {ColumnViewSelectionModeEnum}
       */

    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$U); // @a11y

        this.setAttribute('role', 'tree'); // @a11y: the columnview needs to be focusable to handle a11y properly

        this.tabIndex = -1; // @a11y: the columnview should be labelled so that its entire content
        // is not read as its accessibility name

        if (!this.hasAttribute('aria-label') && !this.hasAttribute('aria-labelledby')) {
          this.setAttribute('aria-label', i18n.get('Column View'));
        } // Default reflect attributes


        if (!this._selectionMode) {
          this._selectionMode = selectionMode$1.NONE;
        } // no need to wait for the mutation observers


        this._setStateFromDOM();
      }
      /**
       Triggered when additional items can be loaded into the {@link ColumnView}. This will happen when the current column can
       still hold more items, when the user scrolls down the current column or when a new column needs to be loaded. If
       <code>preventDefault()</code> is called, then a loading indicator will be shown.
       {@link ColumnViewColumn#loading} should be set to false to indicate that the data has been successfully
       loaded.
        @typedef {CustomEvent} coral-columnview:loaditems
        @property {ColumnViewColumn} detail.column
       The column that is requesting more items. While doing pagination, it will become the target of the loaded items.
       @property {Number} detail.start
       Indicates the current amount of items in the <code>column</code> to do pagination. If <code>item</code> is
       available, start will be 0 to denote that the column should be loaded from the start.
       @property {ColumnViewItem} detail.item
       The item that initialized the load. If item is provided, it means that a new column needs to be added after
       the load is performed. In this scenario, <code>column</code> will be refer to the column that holds the item.
       */

      /**
       Triggered when the selection inside the {@link ColumnViewColumn} changes. In case both the selection and the active item change,
       the <code>coral-columnview:activeitemchange</code> will be triggered first.
        @typedef {CustomEvent} coral-columnview:change
        @property {ColumnViewColumn} detail.column
       The column whose selection changed.
       @property {ColumnViewItem|Array.<ColumnViewItem>} detail.selection
       The new selection of the Column.
       @property {ColumnViewItem|Array.<ColumnViewItem>} detail.oldSelection
       The old selection of the Column.
       */

      /**
       Triggered when the active item of the {@link ColumnViewColumn} changes.
        @typedef {CustomEvent} coral-columnview:activeitemchange
        @property {ColumnViewColumn} detail.column
       The column whose active item has changed.
       @property {ColumnViewItem} detail.activeItem
       The currently active item of the column.
       @property {ColumnViewItem} detail.oldActiveItem
       The item of the column that was active before.
       */

      /**
       Triggered when the {@link ColumnView} navigation is complete and the new columns are ready.
        @typedef {CustomEvent} coral-columnview:navigate
        @property {ColumnViewColumn} detail.column
       The last Column of the ColumnView that is used to determine the path. If the navigate was triggered because a
       new {@link ColumnViewColumn} was added, then it will match that column. In case the path was
       reduced, the column will match the last column.
       @property {ColumnViewItem} detail.activeItem
       The currently active item of the ColumnView.
       */

    }, {
      key: "columns",
      get: function get() {
        // constructs the collection on first request
        if (!this._columns) {
          this._columns = new ColumnViewCollection({
            host: this,
            itemTagName: 'coral-columnview-column',
            onlyHandleChildren: true
          });
        }

        return this._columns;
      }
      /**
       Collection used to represent the coral-columnview-item across all columns.
        @type {ColumnViewCollection}
       @readonly
        @private
       */

    }, {
      key: "items",
      get: function get() {
        // constructs the collection on first request
        if (!this._items) {
          this._items = new ColumnViewCollection({
            host: this,
            itemTagName: 'coral-columnview-item'
          });
        }

        return this._items;
      }
      /**
       Selection mode of the ColumnView. See {@link ColumnViewSelectionModeEnum}.
        @type {String}
       @default ColumnViewSelectionModeEnum.NONE
       @htmlattribute selectionmode
       @htmlattributereflected
       */

    }, {
      key: "selectionMode",
      get: function get() {
        return this._selectionMode || selectionMode$1.NONE;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        value = validate.enumeration(selectionMode$1)(value) && value || selectionMode$1.NONE;

        this._reflectAttribute('selectionmode', value);

        if (validate.valueMustChange(this._selectionMode, value)) {
          this._selectionMode = value; // propagates the selection mode to the columns

          var columns = this.columns.getAll();
          columns.forEach(function (item) {
            item.setAttribute('_selectionmode', value);
          });
          this.classList.remove("".concat(CLASSNAME$U, "--selection"));

          if (value !== selectionMode$1.NONE) {
            this.classList.add("".concat(CLASSNAME$U, "--selection"));
          } // @a11y


          this.setAttribute('aria-multiselectable', value === selectionMode$1.MULTIPLE);
        }
      }
      /**
       First selected item of the ColumnView.
        @type {HTMLElement}
       @readonly
       */

    }, {
      key: "selectedItem",
      get: function get() {
        return this.selectionMode !== selectionMode$1.NONE ? this.items._getFirstSelected() : null;
      }
      /**
       Array containing the set selected items. The items will match only one column since selection across columns is
       not allowed.
        @type {Array.<HTMLElement>}
       @readonly
       */

    }, {
      key: "selectedItems",
      get: function get() {
        return this.selectionMode !== selectionMode$1.NONE ? this.items._getAllSelected() : [];
      }
      /**
       Active Item that corresponds to the last item in the path.
        @type {HTMLElement}
       @readonly
       */

    }, {
      key: "activeItem",
      get: function get() {
        return this.items._getAllActive().pop() || null;
      }
    }], [{
      key: "selectionMode",
      get: function get() {
        return selectionMode$1;
      }
    }, {
      key: "_attributePropertyMap",
      get: function get() {
        return commons.extend(_get(_getPrototypeOf(_class), "_attributePropertyMap", this), {
          selectionmode: 'selectionMode'
        });
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['selectionmode']);
      }
    }]);

    return _class;
  }(BaseComponent(HTMLElement)));

  var CLASSNAME$V = '_coral-MillerColumns-item'; // The number of milliseconds for which scroll events should be debounced.

  var SCROLL_DEBOUNCE$2 = 100; // Height if every item to avoid using offsetHeight during calculations.

  var ITEM_HEIGHT = 40; // Flag to check if window load was called

  var WINDOW_LOAD = false;
  window.addEventListener('load', function () {
    WINDOW_LOAD = true;
  });
  /**
   @class Coral.ColumnView.Column
   @classdesc A ColumnView Column component
   @htmltag coral-columnview-column
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var ColumnViewColumn = Decorator( /*#__PURE__*/function (_BaseComponent) {
    _inherits(_class, _BaseComponent);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this); // Events

      _this._delegateEvents({
        // we need to use capture as scroll events do not bubble
        'capture:scroll coral-columnview-column-content': '_onContentScroll',
        'click coral-columnview-column-content': '_onColumnContentClick',
        // item interaction
        'click coral-columnview-item': '_onItemClick',
        'click [coral-columnview-itemselect]': '_onItemSelectClick',
        // item events
        'coral-columnview-item:_activechanged coral-columnview-item': '_onItemActiveChange',
        'coral-columnview-item:_selectedchanged coral-columnview-item': '_onItemSelectedChange'
      }); // Content zone


      _this._elements = {
        content: _this.querySelector('coral-columnview-column-content') || document.createElement('coral-columnview-column-content')
      }; // default values

      _this._bulkSelectionChange = false;
      _this._oldSelection = [];
      _this._oldActiveItem = null; // cache bound event handler functions

      _this._onDebouncedScroll = _this._onDebouncedScroll.bind(_assertThisInitialized(_this));
      _this._toggleItemSelection = _this._toggleItemSelection.bind(_assertThisInitialized(_this)); // Init the collection mutation observer

      _this.items._startHandlingItems(true);

      return _this;
    }
    /**
     The current active item.
      @type {HTMLElement}
     @readonly
     @default null
     */


    _createClass(_class, [{
      key: "_onItemClick",

      /** @private */
      value: function _onItemClick(event) {
        if (isInteractiveTarget(event.target)) {
          return;
        } // since transform will kill the modification, we trigger the event manually


        if (event.matchedTarget.hasAttribute('active')) {
          // directly calls the event since setting the attribute will not trigger an event
          this._onItemActiveChange(event);
        } else {
          // sets the item as active. while handling mouse interaction, items are not toggled
          event.matchedTarget.active = true;
        }
      }
    }, {
      key: "_toggleItemSelection",
      value: function _toggleItemSelection(item) {
        item[this._selectionMode !== selectionMode$1.NONE ? 'setAttribute' : 'removeAttribute']('_selectable', '');
      }
      /** @private */

    }, {
      key: "_onItemSelectClick",
      value: function _onItemSelectClick(event) {
        if (this._selectionMode && this._selectionMode !== selectionMode$1.NONE) {
          // stops propagation so that active is not called as well
          event.stopPropagation();
          var item = event.matchedTarget.parentElement; // toggles the selection of the item

          var isSelected = item.hasAttribute('selected'); // Handle multi-selection with shiftKey

          if (!isSelected && event.shiftKey && this._selectionMode === selectionMode$1.MULTIPLE) {
            var lastSelectedItem = this._lastSelectedItems[this._lastSelectedItems.length - 1];

            if (lastSelectedItem) {
              var items = this.items.getAll();
              var lastSelectedItemIndex = items.indexOf(lastSelectedItem);
              var selectedItemIndex = items.indexOf(item); // true : selection goes up, false : selection goes down

              var direction = selectedItemIndex < lastSelectedItemIndex;
              var selectionRange = [];
              var selectionIndex = lastSelectedItemIndex; // Retrieve all items in the range

              while (selectedItemIndex !== selectionIndex) {
                selectionIndex = direction ? selectionIndex - 1 : selectionIndex + 1;
                selectionRange.push(items[selectionIndex]);
              } // Select all items in the range silently


              selectionRange.forEach(function (rangeItem) {
                // Except for item which is needed to trigger the selection change event
                if (rangeItem !== item) {
                  rangeItem.set('selected', true, true);
                }
              });
            }
          }

          item[isSelected ? 'removeAttribute' : 'setAttribute']('selected', ''); // if item was selected, make it active

          if (isSelected && !this._lastSelectedItems.length) {
            item.setAttribute('active', '');
          }
        }
      }
      /**
       Handles the item activation, this causes the current item to get active and sets the next column to the item's
       src.
        @private
       */

    }, {
      key: "_onItemActiveChange",
      value: function _onItemActiveChange(event) {
        // we stop propagation since it is a private event
        event.stopImmediatePropagation(); // ignores event handling due to bulk select operation

        if (this._bulkSelectionChange) {
          return;
        }

        var item = event.matchedTarget;
        this._bulkSelectionChange = true; // clears the selection and keeps the item active. this force only 1 item to be active per column

        this.items._deselectAndDeactivateAllExcept(item);

        this._bulkSelectionChange = false; // we check if the selection requires an event to be triggered

        this._validateColumnChange(item); // loads data using the item as the activator and 0 as the start since it is a new column


        this._loadItems(0, item);
      }
      /**
       Handles selecting multiple items in the same column. Selection could result in none, a single or multiple selected
       items.
        @private
       */

    }, {
      key: "_onItemSelectedChange",
      value: function _onItemSelectedChange(event) {
        // we stop propagation since it is a private event
        event.stopImmediatePropagation(); // item that was selected

        var item = event.target;
        var isSelected = item.selected;

        if (isSelected) {
          // Remember the last selected item
          this._lastSelectedItems.push(item);
        } else {
          var removedItemIndex = this._lastSelectedItems.indexOf(item);

          if (removedItemIndex !== -1) {
            this._lastSelectedItems = this._lastSelectedItems.splice(removedItemIndex, 1);
          }
        } // ignores event handling due to bulk select operation


        if (this._bulkSelectionChange) {
          return;
        } // when the item is selected, we need to enforce the selection mode


        if (isSelected) {
          this._bulkSelectionChange = true; // when there is selection, no item can be active

          this.items._deactivateAll(); // enforces the selection mode


          if (this._selectionMode === selectionMode$1.SINGLE) {
            this.items._deselectAllExcept(item);
          }

          this._bulkSelectionChange = false;
        } // we make sure the change event is triggered before the load event.


        this._validateColumnChange();
      }
      /** @ignore */

    }, {
      key: "_tryToLoadAdditionalItems",
      value: function _tryToLoadAdditionalItems() {
        var _this2 = this;

        // makes sure that not too many events are triggered (only one per frame)
        if (this._bulkCollectionChange) {
          return;
        }

        this._bulkCollectionChange = true; // we use setTimeout instead of nextFrame because macrotasks allow for more flexibility since they are less
        // aggressive in executing the code

        window.setTimeout(function () {
          // trigger 'coral-columnview:loaditems' asynchronously in order to be sure the application is done
          // adding/removing elements. Also make sure that only one event is triggered at once
          // bulkCollectionChange has to be reset before loading new items
          _this2._bulkCollectionChange = false;

          _this2._loadFittingAdditionalItems();
        }, 0);
      }
      /** @private */

    }, {
      key: "_onContentScroll",
      value: function _onContentScroll() {
        window.clearTimeout(this._scrollTimeout);
        this._scrollTimeout = window.setTimeout(this._onDebouncedScroll, SCROLL_DEBOUNCE$2);
      }
      /**
       Handles the column click. When the column body is clicked, we need to deselect everything up to that column.
        @private
       */

    }, {
      key: "_onColumnContentClick",
      value: function _onColumnContentClick(event) {
        // we make sure the content was clicked directly and not an item
        if (event.target !== event.matchedTarget || isInteractiveTarget(event.target)) {
          return;
        }

        event.preventDefault(); // ignores event handling due to bulk select operation

        if (this._bulkSelectionChange) {
          return false;
        }

        this._bulkSelectionChange = true; // clears the current column

        this.items._deselectAndDeactivateAllExcept();

        this._bulkSelectionChange = false; // we check if the selection requires an event to be triggered

        this._validateColumnChange();
      }
      /** @private */

    }, {
      key: "_onDebouncedScroll",
      value: function _onDebouncedScroll() {
        var threshold = 20;

        if (this.content.scrollTop + this.offsetHeight >= this.content.scrollHeight - threshold) {
          this._loadItems(this.items.length, undefined);
        }
      }
      /** @private */

    }, {
      key: "_arraysAreDifferent",
      value: function _arraysAreDifferent(selection, oldSelection) {
        var diff = [];

        if (oldSelection.length === selection.length) {
          diff = oldSelection.filter(function (item) {
            return selection.indexOf(item) === -1;
          });
        } // since we guarantee that they are arrays, we can start by comparing their size


        return oldSelection.length !== selection.length || diff.length !== 0;
      }
      /** @private */

    }, {
      key: "_validateColumnChange",
      value: function _validateColumnChange(item) {
        var newActiveItem = this.activeItem;
        var oldActiveItem = this._oldActiveItem || null; // we have to force the event in case the same active item was clicked again, but still try to avoid triggering as
        // less events as possible

        if (newActiveItem !== oldActiveItem || item === newActiveItem) {
          this.trigger('coral-columnview-column:_activeitemchanged', {
            activeItem: newActiveItem,
            oldActiveItem: oldActiveItem
          }); // we cache the active item for the next time

          this._oldActiveItem = newActiveItem;
        }

        var newSelection = this.selectedItems;
        var oldSelection = this._oldSelection;

        if (this._arraysAreDifferent(newSelection, oldSelection)) {
          this.trigger('coral-columnview-column:_selecteditemchanged', {
            selection: newSelection,
            oldSelection: oldSelection
          }); // changes the old selection array since we selected something new

          this._oldSelection = newSelection;
        }
      }
      /**
       Loads additional Items if the current items of the column to not exceed its height and a path this.next is given.
        @private
       */

    }, {
      key: "_loadFittingAdditionalItems",
      value: function _loadFittingAdditionalItems() {
        var itemsCount = this.items.length; // this value must match $columnview-item-height

        var itemsHeight = itemsCount * ITEM_HEIGHT; // we request more items if there is still space for them. in case the values are the same, we request more data
        // just to be sure, specially when the value is 0

        if (itemsHeight <= this.offsetHeight) {
          this._loadItems(itemsCount, undefined);
        }
      }
      /**
       Loads additional items. If the given item is not <code>active</code>, no data will be requested.
        @param {Number} count
       Amount of items in the column.
       @param {?HTMLElement} item
       Item that triggered the load.
        @private
       */

    }, {
      key: "_loadItems",
      value: function _loadItems(count, item) {
        // if the given item is not active, it should not request data
        if (!item || item.hasAttribute('active')) {
          this.trigger('coral-columnview-column:_loaditems', {
            start: count,
            item: item
          });
        }
      }
      /**
       Updates the active and selected options from the DOM.
        @ignore
       */

    }, {
      key: "_setStateFromDOM",
      value: function _setStateFromDOM() {
        // if the selection mode has not been set, we do no try to force selection
        if (this._selectionMode) {
          // single: only the last item is selected
          if (this._selectionMode === selectionMode$1.SINGLE) {
            this.items._deselectAllExceptLast();
          } // none: deselects everything
          else if (this._selectionMode === selectionMode$1.NONE) {
              this.items._deselectAllExcept();
            } // makes sure only one item is active


          this.items._deactivateAllExceptFirst();
        }
      }
      /** @private */

    }, {
      key: "_handleMutation",
      value: function _handleMutation() {
        this._setStateFromDOM(); // in case items were added removed and selection changed


        this._validateColumnChange(); // checks if more items can be added after the childlist change


        this._tryToLoadAdditionalItems();
      }
    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        var _this3 = this;

        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$V); // @a11y

        if (!this.hasAttribute('role')) {
          this.setAttribute('role', 'group');
        }

        this.id = this.id || commons.getUID(); // @todo: initial collection items needs to be triggered

        var content = this._elements.content; // when the content zone was not created, we need to make sure that everything is added inside it as a content.
        // this stops the content zone from being voracious

        if (!content.parentNode) {
          // move the contents of the item into the content zone
          while (this.firstChild) {
            content.appendChild(this.firstChild);
          }
        } // @a11y


        content.setAttribute('role', 'presentation'); // Call content zone insert

        this.content = content; // handles the initial selection

        this._setStateFromDOM(); // we keep a list of the last selection to determine if something changed. we need to do this after
        // validateSelection since it modifies the initial state based on the option


        this._oldSelection = this.selectedItems;
        this._oldActiveItem = this.activeItem;

        if (!WINDOW_LOAD) {
          // instead of being super aggressive on requesting data, we use window onload so it is scheduled after
          // all the code has been executed, this way events can be added before
          window.addEventListener('load', function () {
            _this3._loadFittingAdditionalItems();
          });
        } else {
          // macro-task is necessary for the same reasons as listed above
          window.setTimeout(function () {
            _this3._loadFittingAdditionalItems();
          });
        }
      }
    }, {
      key: "activeItem",
      get: function get() {
        return this.items._getAllActive()[0] || null;
      }
      /**
       The content of the column. This container is where the items should be added and is responsible for handling the
       scrolling.
        @type {ColumnViewColumnContent}
       @contentzone
       */

    }, {
      key: "content",
      get: function get() {
        return this._getContentZone(this._elements.content);
      },
      set: function set(value) {
        this._setContentZone('content', value, {
          handle: 'content',
          tagName: 'coral-columnview-column-content',
          insert: function insert(content) {
            content.classList.add('_coral-AssetList');
            this.appendChild(content);
          }
        });
      }
      /**
       The Collection Interface that allows interacting with the items that the component contains.
        @type {ColumnViewCollection}
       @readonly
       */

    }, {
      key: "items",
      get: function get() {
        // we do lazy initialization of the collection
        if (!this._items) {
          this._items = new ColumnViewCollection({
            host: this,
            container: this._elements.content,
            itemTagName: 'coral-columnview-item',
            onItemAdded: this._toggleItemSelection,
            onCollectionChange: this._handleMutation
          });
        }

        return this._items;
      }
      /**
       Returns the first selected item in the ColumnView. The value <code>null</code> is returned if no element is
       selected.
        @type {?HTMLElement}
       @readonly
       */

    }, {
      key: "selectedItem",
      get: function get() {
        return this._selectionMode !== selectionMode$1.NONE ? this.items._getFirstSelected() : null;
      }
      /**
       Returns an Array containing the set selected items inside this Column.
        @type {Array.<HTMLElement>}
       @readonly
       */

    }, {
      key: "selectedItems",
      get: function get() {
        return this._selectionMode !== selectionMode$1.NONE ? this.items._getAllSelected() : [];
      }
      /**
       Private property that indicates the selection mode. If the <code>Coral.ColumnView.Column</code> is not inside
       a <code>Coral.ColumnView</code> this value will be <code>undefined</code>.
       See {@link ColumnViewSelectionModeEnum}.
        @type {String}
       @htmlattribute _selectionmode
       @htmlattributereflected
       @private
       */

    }, {
      key: "_selectionMode",
      get: function get() {
        return this.__selectionMode;
      },
      set: function set(value) {
        var _this4 = this;

        value = transform.string(value).toLowerCase();
        value = validate.enumeration(selectionMode$1)(value) && value || null;

        this._reflectAttribute('_selectionmode', value);

        if (validate.valueMustChange(this.__selectionMode, value)) {
          this.__selectionMode = value;
          var items = this.items.getAll();
          items.forEach(function (item) {
            return _this4._toggleItemSelection(item);
          });

          this._setStateFromDOM();
        }
      }
      /**
       Returns an Array containing the last selected items inside this Column in selected order.
        @type {Array.<HTMLElement>}
       @private
       */

    }, {
      key: "_lastSelectedItems",
      get: function get() {
        return this.__lastSelectedItems || this.selectedItems;
      },
      set: function set(value) {
        this.__lastSelectedItems = value;
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-columnview-column-content': 'content'
        };
      }
    }], [{
      key: "_attributePropertyMap",
      get: function get() {
        return commons.extend(_get(_getPrototypeOf(_class), "_attributePropertyMap", this), {
          _selectionmode: '_selectionMode'
        });
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['_selectionmode']);
      }
    }]);

    return _class;
  }(BaseComponent(HTMLElement)));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.ColumnView.Column.Content
   @classdesc ColumnView's Column content component
   @htmltag coral-columnview-column-content
   @return {HTMLElement}
   */
  var ColumnViewColumnContent = (function () {
    return document.createElement('coral-columnview-column-content');
  });

  var CLASSNAME$W = '_coral-AssetList-item';
  /**
   Enumeration for {@link ColumnViewItem} variants.

   @typedef {Object} ColumnViewItemVariantEnum

   @property {String} DEFAULT
   Default item variant. Contains no special decorations.
   @property {String} DRILLDOWN
   An item with a right arrow indicating that the navigation will go one level down.
   */

  var variant$g = {
    DEFAULT: 'default',
    DRILLDOWN: 'drilldown'
  };
  /**
   Utility that identifies Chrome on macOS, which announces drilldown items as "row 1 expanded" or "row 1 collapsed" when navigating between items.
   */

  var isChromeMacOS = !!window && !!window.chrome && /Mac/i.test(window.navigator.platform);
  /**
   @class Coral.ColumnView.Item
   @classdesc A ColumnView Item component
   @htmltag coral-columnview-item
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var ColumnViewItem = Decorator( /*#__PURE__*/function (_BaseLabellable) {
    _inherits(_class, _BaseLabellable);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this); // Content zone

      _this._elements = {
        content: _this.querySelector('coral-columnview-item-content') || document.createElement('coral-columnview-item-content'),
        thumbnail: _this.querySelector('coral-columnview-item-thumbnail') || document.createElement('coral-columnview-item-thumbnail'),
        accessibilityState: _this.querySelector('span[handle="accessibilityState"]')
      };

      if (!_this._elements.accessibilityState) {
        // Templates
        template$C.call(_this._elements, {
          commons: commons
        });
      }

      return _this;
    }
    /**
     The content of the item.
      @type {ColumnViewItemContent}
     @contentzone
     */


    _createClass(_class, [{
      key: "attributeChangedCallback",

      /** @ignore */
      value: function attributeChangedCallback(name, oldValue, value) {
        if (name === '_selectable') {
          // Disable selection
          if (value === null) {
            this.classList.remove('is-selectable');
          } // Enable selection
          else {
              this.classList.add('is-selectable');
              var itemSelector = this.querySelector('[coral-columnview-itemselect]'); // Render checkbox on demand

              if (!itemSelector) {
                itemSelector = new Checkbox();
                itemSelector.setAttribute('coral-columnview-itemselect', '');

                if (this.classList.contains('is-selected')) {
                  itemSelector.setAttribute('checked', '');
                }

                itemSelector._elements.input.tabIndex = -1;
                itemSelector.setAttribute('labelledby', this._elements.content.id); // Add the item selector as first child

                this.insertBefore(itemSelector, this.firstChild);
              }
            }
        } else {
          _get(_getPrototypeOf(_class.prototype), "attributeChangedCallback", this).call(this, name, oldValue, value);
        }
      }
      /**
       Returns {@link ColumnViewItem} variants.
        @return {ColumnViewItemVariantEnum}
       */

    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$W); // @a11y

        this.setAttribute('role', 'treeitem');
        this.id = this.id || commons.getUID(); // only set tabIndex if it is not already set

        if (!this.hasAttribute('tabindex')) {
          this.tabIndex = this.active || this.selected ? 0 : -1;
        } // Default reflected attributes


        if (!this._variant) {
          this.variant = variant$g.DEFAULT;
        }

        var thumbnail = this._elements.thumbnail;
        var content = this._elements.content;
        var contentZoneProvided = content.parentNode || thumbnail.parentNode;

        if (!contentZoneProvided) {
          // move the contents of the item into the content zone
          while (this.firstChild) {
            content.appendChild(this.firstChild);
          }
        } // Assign content zones


        this.content = content;
        this.thumbnail = thumbnail; // @a11y thumbnail img element should have alt attribute

        var thumbnailImg = thumbnail.querySelector('img:not([alt])');

        if (thumbnailImg) {
          thumbnailImg.setAttribute('alt', '');
        } // @ally add aria-labelledby so that JAWS/IE announces item correctly


        thumbnail.id = thumbnail.id || commons.getUID();
        content.id = content.id || commons.getUID(); // @a11y Add live region element to ensure announcement of selected state

        var accessibilityState = this._elements.accessibilityState; // @a11y accessibility state string should announce in document lang, rather than item lang.

        accessibilityState.setAttribute('lang', i18n.locale); // @a11y Item should be labelled by thumbnail, content, and accessibility state.

        this.setAttribute('aria-labelledby', thumbnail.id + ' ' + content.id); //adding html title, on hovering over textcontent title will be visible

        this.setAttribute('title', this.content.textContent.trim());
      }
    }, {
      key: "content",
      get: function get() {
        return this._getContentZone(this._elements.content);
      },
      set: function set(value) {
        this._setContentZone('content', value, {
          handle: 'content',
          tagName: 'coral-columnview-item-content',
          insert: function insert(content) {
            content.classList.add("".concat(CLASSNAME$W, "Label")); // Insert before chevron

            this.insertBefore(content, this.querySelector('._coral-AssetList-itemChildIndicator'));
          }
        });
      }
      /**
       The thumbnail of the item. It is used to hold an icon or an image.
        @type {ColumnViewItemThumbnail}
       @contentzone
       */

    }, {
      key: "thumbnail",
      get: function get() {
        return this._getContentZone(this._elements.thumbnail);
      },
      set: function set(value) {
        this._setContentZone('thumbnail', value, {
          handle: 'thumbnail',
          tagName: 'coral-columnview-item-thumbnail',
          insert: function insert(thumbnail) {
            thumbnail.classList.add("".concat(CLASSNAME$W, "Thumbnail")); // Insert before content

            this.insertBefore(thumbnail, this.content || null);
          }
        });
      }
      /**
       The item's variant. See {@link ColumnViewItemVariantEnum}.
        @type {String}
       @default ColumnViewItemVariantEnum.DEFAULT
       @htmlattribute variant
       @htmlattributereflected
       */

    }, {
      key: "variant",
      get: function get() {
        return this._variant || variant$g.DEFAULT;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        value = validate.enumeration(variant$g)(value) && value || variant$g.DEFAULT;

        this._reflectAttribute('variant', value);

        if (validate.valueMustChange(this._variant, value)) {
          this._variant = value;

          if (value === variant$g.DRILLDOWN) {
            // Render chevron on demand
            var childIndicator = this.querySelector('._coral-AssetList-itemChildIndicator');

            if (!childIndicator) {
              this.insertAdjacentHTML('beforeend', Icon._renderSVG('spectrum-css-icon-ChevronRightMedium', ['_coral-AssetList-itemChildIndicator', '_coral-UIIcon-ChevronRightMedium']));
            }

            this.classList.add('is-branch'); // @a11y Update aria-expanded. Active drilldowns should be expanded.
            // Note: Omit aria-expanded on Chrome for macOS, because with VoiceOver tends
            // to announce drilldown items as "row 1 expanded" or "row 1 collapsed" when
            // navigating between items.

            if (this.selected || isChromeMacOS && this.getAttribute('aria-level') === '1') {
              this.removeAttribute('aria-expanded');
            } else {
              this.setAttribute('aria-expanded', this.active);
            }
          } else {
            this.classList.remove('is-branch');
            this.removeAttribute('aria-expanded');
          }
        }
      }
      /**
       Specifies the icon that will be placed inside the thumbnail. The size of the icon is always controlled by the
       component.
        @type {String}
       @default ""
       @htmlattribute icon
       @htmlattributereflected
       */

    }, {
      key: "icon",
      get: function get() {
        return this._icon || '';
      },
      set: function set(value) {
        value = transform.string(value);

        this._reflectAttribute('icon', value);

        if (validate.valueMustChange(this._icon, value)) {
          this._icon = value; // ignored if it is an empty string

          if (value) {
            // creates a new icon element
            if (!this._elements.icon) {
              this._elements.icon = new Icon(); // register observer only if there present an icon field.

              _get(_getPrototypeOf(_class.prototype), "_observeLabel", this).call(this);
            }

            this._elements.icon.icon = this.icon;
            this._elements.icon.size = Icon.size.SMALL; // removes all the items, since the icon attribute has precedence

            this._elements.thumbnail.innerHTML = ''; // adds the newly created icon

            this._elements.thumbnail.appendChild(this._elements.icon);
          }

          _get(_getPrototypeOf(_class.prototype), "_toggleIconAriaHidden", this).call(this);
        }
      }
      /**
       Whether the item is selected.
        @type {Boolean}
       @default false
       @htmlattribute selected
       @htmlattributereflected
       */

    }, {
      key: "selected",
      get: function get() {
        return this._selected || false;
      },
      set: function set(value) {
        var _this2 = this;

        value = transform.booleanAttr(value);

        this._reflectAttribute('selected', value);

        if (validate.valueMustChange(this._selected, value)) {
          this._selected = value;
          this.trigger('coral-columnview-item:_selectedchanged'); // wait a frame before updating attributes

          commons.nextFrame(function () {
            _this2.classList.toggle('is-selected', value);

            _this2.setAttribute('aria-selected', value); // @a11y Update aria-expanded. Active drilldowns should be expanded.
            // Note: Omit aria-expanded on Chrome for macOS, because with VoiceOver tends
            // to announce drilldown items as "row 1 expanded" or "row 1 collapsed" when
            // navigating between items.


            if (value === variant$g.DRILLDOWN) {
              if (_this2._selected || isChromeMacOS && _this2.getAttribute('aria-level') === '1') {
                _this2.removeAttribute('aria-expanded');
              } else {
                _this2.setAttribute('aria-expanded', _this2.active);
              }
            }

            var accessibilityState = _this2._elements.accessibilityState;

            if (value) {
              // @a11y Panels to right of selected item are removed, so remove aria-owns and aria-describedby attributes.
              _this2.removeAttribute('aria-owns');

              _this2.removeAttribute('aria-describedby'); // @a11y Update content to ensure that checked state is announced by assistive technology when the item receives focus


              accessibilityState.innerHTML = i18n.get(', checked'); // @a11y append live region content element

              if (!_this2.contains(accessibilityState)) {
                _this2.appendChild(accessibilityState);
              }
            } // @a11y If deselecting from checked state,
            else {
                // @a11y remove, but retain reference to accessibilityState state
                if (accessibilityState.parentNode) {
                  _this2._elements.accessibilityState = accessibilityState.parentNode.removeChild(accessibilityState);
                } // @a11y Update content to remove checked state


                _this2._elements.accessibilityState.innerHTML = '';
              } // @a11y Item should be labelled by thumbnail, content, and if appropriate accessibility state.


            var ariaLabelledby = _this2._elements.thumbnail.id + ' ' + _this2._elements.content.id;

            _this2.setAttribute('aria-labelledby', _this2.selected ? "".concat(ariaLabelledby, " ").concat(accessibilityState.id) : ariaLabelledby); // Sync checkbox item selector


            var itemSelector = _this2.querySelector('coral-checkbox[coral-columnview-itemselect]');

            if (itemSelector) {
              itemSelector[value ? 'setAttribute' : 'removeAttribute']('checked', '');
            }
          });
        }
      }
      /**
       Whether the item is active.
        @type {Boolean}
       @default false
       @htmlattribut active
       @htmlattributereflected
       */

    }, {
      key: "active",
      get: function get() {
        return this._active || false;
      },
      set: function set(value) {
        value = transform.booleanAttr(value);

        this._reflectAttribute('active', value);

        if (validate.valueMustChange(this._active, value)) {
          this._active = value;
          this.classList.toggle('is-navigated', value);
          this.setAttribute('aria-selected', this.hasAttribute('_selectable') ? this.selected : value); // @a11y Update aria-expanded. Active drilldowns should be expanded.
          // Note: Omit aria-expanded on Chrome for macOS, because with VoiceOver tends
          // to announce drilldown items as "row 1 expanded" or "row 1 collapsed" when
          // navigating between items.

          if (this.variant === variant$g.DRILLDOWN) {
            if (this.selected || isChromeMacOS && this.getAttribute('aria-level') === '1') {
              this.removeAttribute('aria-expanded');
            } else {
              this.setAttribute('aria-expanded', this.active);
            }
          }

          if (!value) {
            // @a11y Inactive items are not expanded, so remove aria-owns and aria-describedby attributes.
            this.removeAttribute('aria-owns');
            this.removeAttribute('aria-describedby');
          }

          this.trigger('coral-columnview-item:_activechanged');
        }
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-columnview-item-content': 'content',
          'coral-columnview-item-thumbnail': 'thumbnail'
        };
      }
    }], [{
      key: "variant",
      get: function get() {
        return variant$g;
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['variant', 'icon', 'selected', 'active', '_selectable']);
      }
    }]);

    return _class;
  }(BaseLabellable(BaseComponent(HTMLElement))));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.ColumnView.Item.Content
   @classdesc ColumnView's Item content component
   @htmltag coral-columnview-item-content
   @return {HTMLElement}
   */
  var ColumnViewItemContent = (function () {
    return document.createElement('coral-columnview-item-content');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.ColumnView.Item.Thumbnail
   @classdesc ColumnView's Item thumbnail component
   @htmltag coral-columnview-item-thumbnail
   @return {HTMLElement}
   */
  var ColumnViewItemThumbnail = (function () {
    return document.createElement('coral-columnview-item-thumbnail');
  });

  var CLASSNAME$X = '_coral-MillerColumns-item';
  /**
   @class Coral.ColumnView.Preview
   @classdesc A ColumnView Preview component
   @htmltag coral-columnview-preview
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var ColumnViewPreview = Decorator( /*#__PURE__*/function (_BaseComponent) {
    _inherits(_class, _BaseComponent);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this); // Content zone

      _this._elements = {
        content: _this.querySelector('coral-columnview-preview-content') || document.createElement('coral-columnview-preview-content')
      };
      return _this;
    }
    /**
     The content of the Preview.
      @type {ColumnViewPreviewContent}
     @contentzone
     */


    _createClass(_class, [{
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.setAttribute('role', 'group');
        this.id = this.id || commons.getUID();
        this.classList.add(CLASSNAME$X);
        var content = this._elements.content; // when the content zone was not created, we need to make sure that everything is added inside it as a content.
        // this stops the content zone from being voracious

        if (!content.parentNode) {
          // move the contents of the item into the content zone
          while (this.firstChild) {
            content.appendChild(this.firstChild);
          }
        } // Call content zone insert


        this.content = content;

        this._makeAccessible();
      }
      /** @ignore */

    }, {
      key: "_makeAccessible",
      value: function _makeAccessible() {
        // @a11y For item values with a label, identify the value as a focusable, readOnly textbox labeled by the label.
        var elements = this.content.querySelectorAll('coral-columnview-preview-label + coral-columnview-preview-value');
        var length = elements.length;
        var i;
        var element;
        var elementLabel; // @a11y If the previous column has selected items,
        // do not include item values in the tab order,
        // so that a keyboard user can quickly advance to a subsequent toolbar.

        var tabIndex = this.parentElement && this.parentElement.tagName === 'CORAL-COLUMNVIEW' && this.parentElement.selectedItems.length ? -1 : 0;

        for (i = 0; i < length; i++) {
          element = elements[i];
          elementLabel = element.previousElementSibling;
          elementLabel.id = elementLabel.id || commons.getUID();
          element.setAttribute('aria-labelledby', elementLabel.id);
          element.setAttribute('role', 'textbox');
          element.setAttribute('tabindex', tabIndex);
          element.setAttribute('aria-readonly', 'true'); // force ChromeVox to read value of textbox

          if (window.cvox) {
            element.setAttribute('aria-valuetext', element.textContent);
          }
        } // @a11y Expose separator as a horizontally-oriented separator.


        elements = this.content.querySelectorAll('coral-columnview-preview-separator');
        length = elements.length;

        for (i = 0; i < length; i++) {
          element = elements[i];
          element.setAttribute('role', 'separator');
          element.setAttribute('aria-orientation', 'horizontal');
        } // @a11y If the preview asset image does not include an alt attribute, set alt="", so that screen readers do not announce the image url.


        elements = this.content.querySelectorAll('coral-columnview-preview-asset > img:not([alt])');
        length = elements.length;

        for (i = 0; i < length; i++) {
          element = elements[i];
          element.setAttribute('alt', '');
        }
      }
    }, {
      key: "content",
      get: function get() {
        return this._getContentZone(this._elements.content);
      },
      set: function set(value) {
        this._setContentZone('content', value, {
          handle: 'content',
          tagName: 'coral-columnview-preview-content',
          insert: function insert(content) {
            content.classList.add('coral-Body--small');
            this.appendChild(content);
          }
        });
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-columnview-preview-content': 'content'
        };
      }
    }]);

    return _class;
  }(BaseComponent(HTMLElement)));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.ColumnView.Preview.Asset
   @classdesc ColumnView's preview asset component
   @htmltag coral-columnview-preview-asset
   @return {HTMLElement}
   */
  var ColumnViewPreviewAsset = (function () {
    return document.createElement('coral-columnview-preview-asset');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.ColumnView.Preview.Content
   @classdesc ColumnView's preview content component
   @htmltag coral-columnview-preview-content
   @return {HTMLElement}
   */
  var ColumnViewPreviewContent = (function () {
    return document.createElement('coral-columnview-preview-content');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.ColumnView.Preview.Label
   @classdesc ColumnView's preview label component
   @htmltag coral-columnview-preview-label
   @return {HTMLElement}
   */
  var ColumnViewPreviewLabel = (function () {
    return document.createElement('coral-columnview-preview-label');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.ColumnView.Preview.Separator
   @classdesc ColumnView's preview separator component
   @htmltag coral-columnview-preview-separator
   @return {HTMLElement}
   */
  var ColumnViewPreviewSeparator = (function () {
    return document.createElement('coral-columnview-preview-separator');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.ColumnView.Preview.Value
   @classdesc ColumnView's preview value component
   @htmltag coral-columnview-preview-value
   @return {HTMLElement}
   */
  var ColumnViewPreviewValue = (function () {
    return document.createElement('coral-columnview-preview-value');
  });

  /**
   * Copyright 2020 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var translations$f = {
    "en-US": {
      "Column View": "Column View",
      ", checked": ", checked",
      ", unchecked": ", unchecked"
    },
    "de-DE": {
      "Column View": "Column View",
      ", checked": ", markiert",
      ", unchecked": ", nicht markiert"
    },
    "fr-FR": {
      "Column View": "Column View",
      ", checked": ", cochée",
      ", unchecked": ", pas cochée"
    },
    "it-IT": {
      "Column View": "Column View",
      ", checked": ", selezionata",
      ", unchecked": ", non selezionata"
    },
    "ja-JP": {
      "Column View": "Column View",
      ", checked": "、チェック",
      ", unchecked": "、未チェック"
    },
    "es-ES": {
      "Column View": "Column View",
      ", checked": ", marcada",
      ", unchecked": ", desmarcada"
    },
    "ko-KR": {
      "Column View": "Column View",
      ", checked": ", 선택됨",
      ", unchecked": ", 선택되지 않은"
    },
    "zh-CN": {
      "Column View": "Column View",
      ", checked": "，选中",
      ", unchecked": "，未选中"
    },
    "zh-TW": {
      "Column View": "Column View",
      ", checked": "，選中",
      ", unchecked": "，未選中"
    },
    "pt-BR": {
      "Column View": "Column View",
      ", checked": ", marcada",
      ", unchecked": ", desmarcada"
    },
    "nl-NL": {
      "Column View": "Column View",
      ", checked": ", geselecteerd",
      ", unchecked": ", neit geselecteerd"
    },
    "da-DK": {
      ", checked": ", valgte",
      ", unchecked": ", ikke valgt"
    },
    "fi-FI": {
      "Column View": "Column View",
      ", checked": ", valittu",
      ", unchecked": ", valittuna"
    },
    "nb-NO": {
      "Column View": "Column View",
      ", checked": ", valgt",
      ", unchecked": ", ikke valgt"
    },
    "sv-SE": {
      "Column View": "Column View",
      ", checked": ", markerad",
      ", unchecked": ", avmarkerad"
    },
    "cs-CZ": {
      "Column View": "Column View",
      ", checked": ", vybráno",
      ", unchecked": ", není vybráno"
    },
    "pl-PL": {
      "Column View": "Column View",
      ", checked": ", zaznaczone",
      ", unchecked": ", nie zaznaczone"
    },
    "ru-RU": {
      "Column View": "Column View",
      ", checked": ", выбранный",
      ", unchecked": ", неотобранный"
    },
    "tr-TR": {
      "Column View": "Column View",
      ", checked": ", seçilmiş",
      ", unchecked": ", seçilmemiş"
    }
  };

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons.extend(strings, {
    'coral-component-columnview': translations$f
  }); // Expose component on the Coral namespace

  commons._define('coral-columnview-preview', ColumnViewPreview);

  commons._define('coral-columnview-column', ColumnViewColumn);

  commons._define('coral-columnview-item', ColumnViewItem);

  commons._define('coral-columnview', ColumnView);

  ColumnView.Column = ColumnViewColumn;
  ColumnView.Column.Content = ColumnViewColumnContent;
  ColumnView.Item = ColumnViewItem;
  ColumnView.Item.Content = ColumnViewItemContent;
  ColumnView.Item.Thumbnail = ColumnViewItemThumbnail;
  ColumnView.Preview = ColumnViewPreview;
  ColumnView.Preview.Asset = ColumnViewPreviewAsset;
  ColumnView.Preview.Content = ColumnViewPreviewContent;
  ColumnView.Preview.Label = ColumnViewPreviewLabel;
  ColumnView.Preview.Separator = ColumnViewPreviewSeparator;
  ColumnView.Preview.Value = ColumnViewPreviewValue;

  /**
   Enum for {CycleButtonItem} display options.

   @typedef {Object} CycleButtonItemDisplayModeEnum

   @property {String} ICON
   Icon display mode.
   @property {String} TEXT
   Text display mode.
   @property {String} ICON_TEXT
   Icon and text display mode.
   @property {String} INHERIT
   Inherit display mode.
   */

  var displayMode = {
    ICON: 'icon',
    TEXT: 'text',
    ICON_TEXT: 'icontext',
    INHERIT: 'inherit'
  };
  /**
   @class Coral.CycleButton.Item
   @classdesc A CycleButton Item component
   @htmltag coral-cyclebutton-item
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var CycleButtonItem = Decorator( /*#__PURE__*/function (_BaseComponent) {
    _inherits(_class, _BaseComponent);

    var _super = _createSuper(_class);

    function _class() {
      _classCallCheck(this, _class);

      return _super.apply(this, arguments);
    }

    _createClass(_class, [{
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this); // adds the role to support accessibility


        this.setAttribute('role', 'menuitemradio'); // Default reflected attributes

        if (!this._displayMode) {
          this.displayMode = displayMode.INHERIT;
        }
      }
    }, {
      key: "icon",

      /**
       The Item's icon. See {@link Coral.Icon} for valid icon names.
        @type {String}
       @default ""
       @htmlattribute icon
       @htmlattributereflected
       */
      get: function get() {
        return this._icon || '';
      },
      set: function set(value) {
        var _icon = transform.string(value);

        if (this._icon === _icon) {
          return;
        }

        this._icon = _icon;

        this._reflectAttribute('icon', this._icon);

        this.trigger('coral-cyclebutton-item:_iconchanged');
      } // @compat

    }, {
      key: "content",
      get: function get() {
        return this;
      },
      set: function set(value) {
        // Support configs
        if (_typeof(value) === 'object') {
          for (var prop in value) {
            /** @ignore */
            this[prop] = value[prop];
          }
        }
      }
      /**
       Whether the Item is disabled. When set to true, this will prevent every user interacting with it.
        @type {Boolean}
       @default false
       @htmlattribute disabled
       @htmlattributereflected
       */

    }, {
      key: "disabled",
      get: function get() {
        return this._disabled || false;
      },
      set: function set(value) {
        this._disabled = transform.booleanAttr(value);

        this._reflectAttribute('disabled', this._disabled);

        this.classList.toggle('is-disabled', this.disabled);
        this[this._disabled ? 'setAttribute' : 'removeAttribute']('aria-disabled', this._disabled);

        if (this._disabled && this.selected) {
          this.selected = false;
        }

        if (!this._disabled && !this.selected) {
          // We inform the parent to verify if this item should be selected because it's the only one left
          this.trigger('coral-cyclebutton-item:_validateselection');
        }
      }
      /**
       Whether the Item is selected.
       @type {Boolean}
       @default false
       @htmlattribute selected
       @htmlattributereflected
       */

    }, {
      key: "selected",
      get: function get() {
        return this._selected || false;
      },
      set: function set(value) {
        var _selected = transform.booleanAttr(value);

        if (this._selected === _selected) {
          return;
        }

        if (!_selected || _selected && !this.disabled) {
          this._selected = _selected;

          this._reflectAttribute('selected', this.disabled ? false : this._selected);

          this.classList.toggle('is-selected', this._selected);
          this.setAttribute('aria-checked', this._selected);
          this.trigger('coral-cyclebutton-item:_selectedchanged');
        }
      }
      /**
       The displayMode to be used when the particular item is selected. When this value is set to <code>inherit</code>
       it will defer to the component level displayMode. If the selected item does not have the necessary icon or text
       information, then fallback to show whichever is available. The appearance of collapsed items in the popover are
       not affected by this property.
       See {@link CycleButtonItemDisplayModeEnum}.
        @type {String}
       @default CycleButtonItemDisplayModeEnum.INHERIT
       @htmlattribute displaymode
       @htmlattributereflected
       */

    }, {
      key: "displayMode",
      get: function get() {
        return this._displayMode || displayMode.INHERIT;
      },
      set: function set(value) {
        var _value = transform.string(value).toLowerCase();

        var _displayMode = validate.enumeration(displayMode)(_value) && _value || displayMode.INHERIT;

        if (this._displayMode === _displayMode) {
          return;
        }

        this._displayMode = _displayMode;

        this._reflectAttribute('displaymode', this._displayMode);

        this.trigger('coral-cyclebutton-item:_displaymodechanged');
      }
      /**
       Inherited from {@link BaseComponent#trackingElement}.
       */

    }, {
      key: "trackingElement",
      get: function get() {
        return typeof this._trackingElement === 'undefined' ? // keep spaces to only 1 max and trim. this mimics native html behaviors
        (this.content || this).textContent.replace(/\s{2,}/g, ' ').trim() || this.icon : this._trackingElement;
      },
      set: function set(value) {
        _set(_getPrototypeOf(_class.prototype), "trackingElement", value, this, true);
      }
      /**
       Returns {@link CycleButtonItem} display options.
        @return {CycleButtonItemDisplayModeEnum}
       */

    }], [{
      key: "displayMode",
      get: function get() {
        return displayMode;
      }
    }, {
      key: "_attributePropertyMap",
      get: function get() {
        return commons.extend(_get(_getPrototypeOf(_class), "_attributePropertyMap", this), {
          displaymode: 'displayMode'
        });
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['selected', 'disabled', 'icon', 'displaymode']);
      }
    }]);

    return _class;
  }(BaseComponent(HTMLElement)));

  var template$D = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var data = data_0 = typeof data_0 === "undefined" ? {} : data_0;
    data = data_0;
    data.buttonId = data.id + '-button';
    data.menuId = data.id + '-menu';
    data_0 = data;
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    var el2 = this["button"] = document.createElement("button", "coral-button");
    el2.setAttribute("tracking", "off");
    el2.id = data_0["buttonId"];
    el2.setAttribute("handle", "button");
    el2.className += " _coral-CycleSelect-button";
    el2.setAttribute("is", "coral-button");
    el2.setAttribute("type", "button");
    el2.setAttribute("variant", "quietaction");
    el2.setAttribute("iconsize", "S");
    var el3 = document.createTextNode("\n  ");
    el2.appendChild(el3);
    var el4 = this["label"] = document.createElement("coral-button-label");
    el4.className += " _coral-ActionButton-label";
    el4.setAttribute("handle", "label");
    el2.appendChild(el4);
    var el5 = document.createTextNode("\n");
    el2.appendChild(el5);
    frag.appendChild(el2);
    var el6 = document.createTextNode("\n");
    frag.appendChild(el6);
    data = data_0; // Don't wait for button MO to pick up the label

    this.button._elements.label = this.label; // Render chevron icon

    this.button.insertAdjacentHTML('afterbegin', data.Icon._renderSVG('spectrum-css-icon-ChevronDownMedium', ['_coral-CycleSelect-icon', '_coral-UIIcon-ChevronDownMedium']));
    data_0 = data;
    var el8 = document.createTextNode("\n");
    frag.appendChild(el8);
    var el9 = this["overlay"] = document.createElement("coral-popover");
    el9.setAttribute("tracking", "off");
    el9.setAttribute("smart", "");
    el9.id = data_0["menuId"];
    el9.setAttribute("handle", "overlay");
    el9.setAttribute("focusonshow", "coral-selectlist");
    el9.setAttribute("placement", "bottom");
    el9.setAttribute("aria-live", "off");
    el9.setAttribute("role", "menu");
    var el10 = document.createTextNode("\n  ");
    el9.appendChild(el10);
    var el11 = this["selectList"] = document.createElement("coral-selectlist");
    el11.setAttribute("role", "group");
    el11.setAttribute("tracking", "off");
    el11.className += " _coral-CycleSelect-list";
    el11.setAttribute("handle", "selectList");
    el11.id = data_0["commons"]["getUID"]();
    el9.appendChild(el11);
    var el12 = document.createTextNode("\n  ");
    el9.appendChild(el12);
    var el13 = this["separator"] = document.createElement("div");
    el13.setAttribute("role", "separator");
    el13.setAttribute("handle", "separator");
    el13.className += " _coral-CycleButton-separator";
    el13.setAttribute("hidden", "");
    el9.appendChild(el13);
    var el14 = document.createTextNode("\n  ");
    el9.appendChild(el14);
    var el15 = this["actionList"] = document.createElement("coral-buttonlist");
    el15.setAttribute("role", "presentation");
    el15.setAttribute("tracking", "off");
    el15.className += " _coral-CycleSelect-buttonList";
    el15.setAttribute("handle", "actionList");
    el15.setAttribute("hidden", "");
    el9.appendChild(el15);
    var el16 = document.createTextNode("\n");
    el9.appendChild(el16);
    frag.appendChild(el9);
    var el17 = document.createTextNode("\n");
    frag.appendChild(el17);
    return frag;
  };

  /**
   Enumeration for {@link CycleButton} display options.

   @typedef {Object} CycleButtonDisplayModeEnum

   @property {String} ICON
   Icon display mode.
   @property {String} TEXT
   Text display mode.
   @property {String} ICON_TEXT
   Icon and text display mode.
   */

  var displayMode$1 = {
    ICON: 'icon',
    TEXT: 'text',
    ICON_TEXT: 'icontext'
  };
  /**
   Regex used to remove whitespace from selectedItem label for use as an aria-label for accessibility.

   @ignore
   */

  var WHITESPACE_REGEX = /[\t\n\r ]+/g;
  /** @ignore */

  var ACTION_TAG_NAME = 'coral-cyclebutton-action';
  var CLASSNAME$Y = '_coral-CycleSelect';
  /**
   @class Coral.CycleButton
   @classdesc A CycleButton component is a simple multi-state toggle button that toggles between the possible items below
   a certain threshold, and shows them in a popover selector when above.
   @htmltag coral-cyclebutton
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var CycleButton = Decorator( /*#__PURE__*/function (_BaseComponent) {
    _inherits(_class, _BaseComponent);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this);
      _this._id = _this.id || commons.getUID(); // Templates

      _this._elements = {};
      template$D.call(_this._elements, {
        Icon: Icon,
        commons: commons,
        id: _this._id
      });
      var events = {
        'click button[is="coral-button"]': '_onMouseDown',
        'click ._coral-CycleSelect-button': '_onItemClick',
        'click coral-cyclebutton-item': '_onItemClick',
        'key:down ._coral-CycleSelect-button[aria-expanded=false]': '_onItemClick',
        // private
        'coral-cyclebutton-item:_selectedchanged': '_onItemSelectedChanged',
        'coral-cyclebutton-item:_validateselection': '_onValidateSelection',
        'coral-cyclebutton-item:_iconchanged coral-cyclebutton-item[selected]': '_onSelectedItemPropertyChange',
        'coral-cyclebutton-item:_displaymodechanged coral-cyclebutton-item[selected]': '_onSelectedItemPropertyChange',
        'key:pageup coral-selectlist-item, [coral-list-item]': '_onFocusPreviousItem',
        'key:left coral-selectlist-item, [coral-list-item]': '_onFocusPreviousItem',
        'key:up coral-selectlist-item, [coral-list-item]': '_onFocusPreviousItem',
        'key:pagedown coral-selectlist-item, [coral-list-item]': '_onFocusNextItem',
        'key:right coral-selectlist-item, [coral-list-item]': '_onFocusNextItem',
        'key:down coral-selectlist-item, [coral-list-item]': '_onFocusNextItem',
        'key:home coral-selectlist-item, [coral-list-item]': '_onFocusFirstItem',
        'key:end coral-selectlist-item, [coral-list-item]': '_onFocusLastItem',
        'capture:focus coral-selectlist-item, [coral-list-item]': '_onItemFocus',
        'capture:blur coral-selectlist-item, [coral-list-item]': '_onItemBlur',
        'coral-overlay:open': '_onOverlayOpen',
        'coral-overlay:close': '_onOverlayClose'
      };
      var overlay = _this._elements.overlay;
      var overlayId = overlay.id; // Overlay

      events["global:capture:click #".concat(overlayId, " button[is=\"coral-buttonlist-item\"]")] = '_onActionClick';
      events["global:capture:coral-selectlist:beforechange #".concat(overlayId)] = '_onSelectListBeforeChange';
      events["global:capture:coral-selectlist:change #".concat(overlayId)] = '_onSelectListChange'; // Keyboard interaction

      events["global:keypress #".concat(overlayId)] = '_onOverlayKeyPress'; // Attach events

      _this._delegateEvents(events); // Used for eventing


      _this._oldSelection = null; // Init the collection mutation observer

      _this.items._startHandlingItems(true);

      _this.actions._startHandlingItems(true);

      return _this;
    }
    /**
     Returns the inner overlay to allow customization.
      @type {Popover}
     @readonly
     */


    _createClass(_class, [{
      key: "_hasMenuItemRadioGroup",

      /** @private */
      value: function _hasMenuItemRadioGroup() {
        return this.items.getAll().length > 0 && this.actions.getAll().length > 0;
      }
      /** @private */

    }, {
      key: "_onItemAdded",
      value: function _onItemAdded(item) {
        if (!this.selectedItem) {
          item.setAttribute('selected', '');
        } else {
          this._validateSelection(item);
        }

        this._checkExtended();
      }
      /** @private */

    }, {
      key: "_onItemRemoved",
      value: function _onItemRemoved() {
        if (!this.selectedItem) {
          this._selectFirstItem();
        }

        this._checkExtended();
      }
      /** @private */

    }, {
      key: "_onItemSelectedChanged",
      value: function _onItemSelectedChanged(event) {
        event.stopImmediatePropagation();

        this._validateSelection(event.target);
      }
      /** @private */

    }, {
      key: "_onValidateSelection",
      value: function _onValidateSelection(event) {
        event.stopImmediatePropagation();

        this._validateSelection();
      }
      /** @private */

    }, {
      key: "_selectFirstItem",
      value: function _selectFirstItem() {
        var item = this.items._getFirstSelectable();

        if (item) {
          item.setAttribute('selected', '');
        }
      }
      /** @private */

    }, {
      key: "_validateSelection",
      value: function _validateSelection(item) {
        var _this2 = this;

        var selectedItems = this.items._getAllSelected();

        if (item) {
          // Deselected item
          if (!item.hasAttribute('selected') && !selectedItems.length) {
            var siblingItem = this.items._getNextSelectable(item); // Next selectable item is forced to be selected if selection is cleared


            if (item !== siblingItem) {
              siblingItem.setAttribute('selected', '');
            }
          } // Selected item
          else if (item.hasAttribute('selected') && selectedItems.length > 1) {
              selectedItems.forEach(function (selectedItem) {
                if (selectedItem !== item) {
                  // Don't trigger change events
                  _this2._preventTriggeringEvents = true;
                  selectedItem.removeAttribute('selected');
                }
              }); // We can trigger change events again

              this._preventTriggeringEvents = false;
            }
        } else if (selectedItems.length > 1) {
          // If multiple items are selected, the last one wins
          item = selectedItems[selectedItems.length - 1];
          selectedItems.forEach(function (selectedItem) {
            if (selectedItem !== item) {
              // Don't trigger change events
              _this2._preventTriggeringEvents = true;
              selectedItem.removeAttribute('selected');
            }
          }); // We can trigger change events again

          this._preventTriggeringEvents = false;
        } // First selectable item is forced to be selected if no selection at all
        else if (!selectedItems.length) {
            this._selectFirstItem();
          }

        this._renderSelectedItem(this.selectedItem);

        this._triggerChangeEvent();
      }
      /** @private */

    }, {
      key: "_triggerChangeEvent",
      value: function _triggerChangeEvent() {
        var selectedItem = this.selectedItem;
        var oldSelection = this._oldSelection;

        if (!this._preventTriggeringEvents && selectedItem !== oldSelection) {
          this.trigger('coral-cyclebutton:change', {
            oldSelection: oldSelection,
            selection: selectedItem
          });
          this._oldSelection = selectedItem;
        }
      }
    }, {
      key: "_onMouseDown",
      value: function _onMouseDown(event) {
        event.preventDefault();
        event.stopPropagation();

        this._trackEvent('click', 'coral-cyclebutton', event);
      }
      /** @private */

    }, {
      key: "_onItemClick",
      value: function _onItemClick(event) {
        event.preventDefault();
        var items = this.items.getAll();
        var itemCount = items.length; // When we have more than a specified number of items, use the overlay selection. If threshold is 0, then we never
        // show the popover. If there are actions, we always show the popover.

        if (this._isExtended()) {
          // we toggle the overlay if it was already open
          this[this._elements.overlay.classList.contains('is-open') ? '_hideOverlay' : '_showOverlay']();
        } // Unless this is the only item we have, select the next item in line:
        else if (itemCount > 1) {
            var neighbor = this.selectedItem.nextElementSibling;
            var nextItem = neighbor.nodeName === 'CORAL-CYCLEBUTTON-ITEM' ? neighbor : items[0];

            this._selectCycleItem(nextItem);

            this._focusItem(this._elements.button);
          }
      }
      /**
       Render the provided item as selected according to resolved icon and displayMode properties.
        @private
       */

    }, {
      key: "_renderSelectedItem",
      value: function _renderSelectedItem(item) {
        if (!item || !item.content) {
          return;
        } // resolve effective values by checking for item and component level properties


        var effectiveDisplayMode = this.displayMode;
        var effectiveIcon = item.icon || this.icon || '';

        if (item.displayMode !== CycleButtonItem.displayMode.INHERIT) {
          effectiveDisplayMode = item.displayMode;
        }

        if (!item.content.textContent.trim() || !effectiveIcon.trim()) {
          // if icon or text missing then we fallback to showing whichever is available
          effectiveDisplayMode = displayMode$1.ICON_TEXT;
        } // manipulate button sub-component depending on display mode


        if (effectiveDisplayMode === displayMode$1.ICON) {
          this._elements.button.icon = effectiveIcon;
          this._elements.button.label.innerHTML = ''; // @a11y

          var ariaLabel = item.content.textContent.replace(WHITESPACE_REGEX, ' ');

          this._elements.button.setAttribute('aria-label', ariaLabel);

          this._elements.button.setAttribute('title', ariaLabel);

          if (ariaLabel && effectiveIcon !== '' && this._elements.button._elements.icon) {
            this._elements.button._elements.icon.setAttribute('aria-hidden', true);
          }
        } else {
          // handle display modes that include text
          if (effectiveDisplayMode === displayMode$1.TEXT) {
            this._elements.button.icon = '';
          }

          if (effectiveDisplayMode === displayMode$1.ICON_TEXT) {
            this._elements.button.icon = effectiveIcon;

            if (effectiveIcon !== '' && this._elements.button._elements.icon) {
              this._elements.button._elements.icon.setAttribute('aria-hidden', true);
            }
          }

          this._elements.button.label.innerHTML = item.content.innerHTML; // @a11y we do not require aria attributes since we already show text

          this._elements.button.removeAttribute('aria-label');

          this._elements.button.removeAttribute('title');
        }
      }
      /**
       Update currently selected item if it's <code>icon</code> or <code>displayMode</code> properties have changed.
        @private
       */

    }, {
      key: "_onSelectedItemPropertyChange",
      value: function _onSelectedItemPropertyChange(event) {
        // stops propagation because the event is internal to the component
        event.stopImmediatePropagation();

        this._renderSelectedItem(event.target);
      }
      /** @private */

    }, {
      key: "_onSelectListBeforeChange",
      value: function _onSelectListBeforeChange(event) {
        if (event.detail.item.selected) {
          event.preventDefault();

          if (!this._isPopulatingLists) {
            // Hide the overlay, cleanup will be done before overlay.show()
            this._hideOverlay();
          }
        }
      }
      /** @private */

    }, {
      key: "_onSelectListChange",
      value: function _onSelectListChange(event) {
        event.stopImmediatePropagation();
        event.preventDefault();
        var origNode;
        var selectListItem = event.detail.selection;

        if (selectListItem) {
          origNode = selectListItem._originalItem;

          this._selectCycleItem(origNode);

          if (!this._isPopulatingLists) {
            // Hide the overlay, cleanup will be done before overlay.show()
            this._hideOverlay();
          }
        }

        this._trackEvent('selected', 'coral-cyclebutton-item', event, origNode);
      }
    }, {
      key: "_onOverlayKeyPress",
      value: function _onOverlayKeyPress(event) {
        // Focus on item which text starts with pressed keys
        this._elements.selectList._onKeyPress(event);
      }
      /** @private */

    }, {
      key: "_onActionClick",
      value: function _onActionClick(event) {
        event.stopPropagation();
        var item = event.matchedTarget;

        var proxyEvent = item._originalItem.trigger('click');

        if (!proxyEvent.defaultPrevented) {
          this._hideOverlay();
        }

        this._trackEvent('selected', 'coral-cyclebutton-action', event, item);
      }
      /** @private */

    }, {
      key: "_isExtended",
      value: function _isExtended() {
        var hasActions = this.actions.getAll().length > 0;
        return this.threshold > 0 && this.items.getAll().length >= this.threshold || hasActions;
      }
      /** @private */

    }, {
      key: "_checkExtended",
      value: function _checkExtended() {
        var isExtended = this._isExtended();

        this.classList.toggle("".concat(CLASSNAME$Y, "--extended"), isExtended); // @a11y

        if (isExtended) {
          this._elements.button.setAttribute('aria-controls', this._elements.overlay.id);

          this._elements.button.setAttribute('aria-haspopup', true);

          this._elements.button.setAttribute('aria-expanded', false); // Assign the button as the target for the overlay


          this._elements.overlay.target = this._elements.button;
          this._elements.overlay.hidden = false; // Regions within the overlay should have role=presentation

          this._elements.overlay.content.setAttribute('role', 'presentation');
        } else {
          this._elements.button.removeAttribute('aria-controls');

          this._elements.button.removeAttribute('aria-haspopup');

          this._elements.button.removeAttribute('aria-expanded'); // Remove target and hide overlay


          this._elements.overlay.target = null;
          this._elements.overlay.hidden = true;
        }
      }
      /** @ignore */

    }, {
      key: "_focusItem",
      value: function _focusItem(item) {
        if (item) {
          item.focus();
        }
      }
      /** @private */

    }, {
      key: "_onFocusPreviousItem",
      value: function _onFocusPreviousItem(event) {
        event.preventDefault();

        var items = this._getSelectableItems();

        if (items.length > 1) {
          var el = event.matchedTarget;
          var index = items.indexOf(el);

          if (index > 0) {
            this._focusItem(items[index - 1]);
          } else if (document.activeElement !== el) {
            // make sure ButtonList doesn't wrap focus
            this._focusItem(el);
          }
        }
      }
      /** @private */

    }, {
      key: "_onFocusNextItem",
      value: function _onFocusNextItem(event) {
        event.preventDefault();

        var items = this._getSelectableItems();

        if (items.length > 1) {
          var el = event.matchedTarget;
          var index = items.indexOf(el);

          if (index < items.length - 1) {
            this._focusItem(items[index + 1]);
          } else if (document.activeElement !== el) {
            // make sure ButtonList doesn't wrap focus
            this._focusItem(el);
          }
        }
      }
      /** @private */

    }, {
      key: "_onFocusFirstItem",
      value: function _onFocusFirstItem(event) {
        event.preventDefault();

        this._focusItem(this._getSelectableItems()[0]);
      }
      /** @private */

    }, {
      key: "_onFocusLastItem",
      value: function _onFocusLastItem(event) {
        event.preventDefault();

        var items = this._getSelectableItems();

        this._focusItem(items[items.length - 1]);
      }
      /** @private */

    }, {
      key: "_getSelectableItems",
      value: function _getSelectableItems() {
        var items = this.items.getAll();
        var actions = this.actions.getAll();
        return items.concat(actions).map(function (item) {
          return item._selectListItem || item._buttonListItem;
        }).filter(function (item) {
          !item.hasAttribute('hidden') && !item.hasAttribute('disabled') && item.offsetParent !== null && (item.offsetWidth > 0 || item.offsetHeight > 0);
        });
      }
      /** @private */

    }, {
      key: "_onItemFocus",
      value: function _onItemFocus(event) {
        this._elements.selectList.classList.toggle('is-focused', true);

        event.matchedTarget.classList.toggle('focus-ring', true);
      }
      /** @private */

    }, {
      key: "_onItemBlur",
      value: function _onItemBlur(event) {
        this._elements.selectList.classList.toggle('is-focused', false);

        event.matchedTarget.classList.toggle('focus-ring', false);
      }
    }, {
      key: "_onOverlayClose",
      value: function _onOverlayClose() {
        // @a11y
        this._elements.button.setAttribute('aria-expanded', false);
      }
    }, {
      key: "_onOverlayOpen",
      value: function _onOverlayOpen() {
        // @a11y
        this._elements.button.setAttribute('aria-expanded', true);
      }
      /** @ignore */

    }, {
      key: "_hideOverlay",
      value: function _hideOverlay() {
        this._elements.overlay.hide();
      }
      /** @ignore */

    }, {
      key: "_getSelectListItem",
      value: function _getSelectListItem(item) {
        var selectListItem = new SelectList.Item(); // Needs to be reflected on the generated Item.

        selectListItem.trackingElement = item.trackingElement; // We do first the content, so that the icon is not destroyed

        var selectListItemContent = new SelectList.Item.Content();
        selectListItemContent.innerHTML = item.content.innerHTML;
        selectListItem.content = selectListItemContent; // Specify the icon

        if (item.icon) {
          selectListItem.icon = item.icon;
        }

        selectListItem.disabled = item.disabled;
        selectListItem.selected = item.selected;
        selectListItem.setAttribute('role', item.getAttribute('role'));
        selectListItem.setAttribute('aria-checked', item.selected);
        selectListItem._originalItem = item;
        item._selectListItem = selectListItem;
        return selectListItem;
      }
      /** @ignore */

    }, {
      key: "_getActionListItem",
      value: function _getActionListItem(action) {
        var actionListItem = new ButtonList.Item();
        actionListItem.icon = action.icon;
        actionListItem.disabled = action.disabled;
        actionListItem.setAttribute('role', action.getAttribute('role'));
        actionListItem.tabIndex = action.tabIndex; // Needs to be reflected on the generated Action.

        actionListItem.trackingElement = action.trackingElement;
        actionListItem.content.innerHTML = action.content.innerHTML;
        actionListItem._originalItem = action;
        action._buttonListItem = actionListItem;
        return actionListItem;
      }
      /** @ignore */

    }, {
      key: "_populateLists",
      value: function _populateLists() {
        var _this3 = this;

        var selectList = this._elements.selectList;
        var actionList = this._elements.actionList;
        var items = this.items.getAll();
        var actions = this.actions.getAll();
        var itemCount = items.length;
        var actionCount = actions.length;
        var selectListItem;
        var actionListItem;
        this._isPopulatingLists = true; // we empty the existing items before populating the lists again

        selectList.items.clear();
        actionList.items.clear(); // adds the items to the selectList

        for (var i = 0; i < itemCount; i++) {
          var item = items[i];
          selectListItem = this._getSelectListItem(item);
          selectListItem.icon = item.icon;
          selectListItem.setAttribute('aria-checked', item.selected);

          selectListItem._elements.icon.setAttribute('aria-hidden', true);

          selectListItem.set({
            disabled: item.disabled,
            selected: item.selected
          }, true);
          selectList.items.add(selectListItem);
        } // adds any additional actions to the actions buttonList


        if (actionCount > 0) {
          for (var j = 0; j < actionCount; j++) {
            var action = actions[j];
            actionListItem = this._getActionListItem(action);
            actionListItem.disabled = action.disabled;
            actionListItem.icon = action.icon;

            actionListItem._elements.icon.setAttribute('aria-hidden', true);

            actionList.items.add(actionListItem);
          }

          this._elements.actionList.removeAttribute('hidden');

          if (itemCount > 0) {
            this._elements.separator.removeAttribute('hidden');
          }
        } else {
          this._elements.actionList.setAttribute('hidden', '');

          this._elements.separator.setAttribute('hidden', '');
        }

        commons.nextFrame(function () {
          _this3._isPopulatingLists = false;
        });
      }
      /** @private */

    }, {
      key: "_selectCycleItem",
      value: function _selectCycleItem(item) {
        item.setAttribute('selected', '');
      }
      /** @ignore */

    }, {
      key: "_showOverlay",
      value: function _showOverlay() {
        this._populateLists();

        this._elements.overlay.show();
      }
      /**
       Returns {@link CycleButton} display options.
        @return {CycleButtonDisplayModeEnum}
       */

    }, {
      key: "attributeChangedCallback",

      /** @ignore */
      value: function attributeChangedCallback(name, oldValue, value) {
        // The accessibility name for the button element
        if (name === 'aria-label') {
          var hasMenuItemRadioGroup = this._hasMenuItemRadioGroup(); // aria-labelledby takes precedence over aria-label


          if (this.getAttribute('aria-labelledby')) {
            // Button should be labeled by the container and the button, with the selected value, itself
            this._elements.button.setAttribute('aria-labelledby', "".concat(this.id, " ").concat(this._elements.button.id)); // Overlay should be labeled by the container with aria-label


            this._elements.overlay.setAttribute('aria-labelledby', this.id); // With both items and actions, the items should be grouped and the group should be labeled
            // SelectList menuitemradio group should be labeled by the container with aria-label,
            // Otherwise the selectList should not be labeled independantly from the menu


            this._elements.selectList[hasMenuItemRadioGroup ? 'setAttribute' : 'removeAttribute']('aria-labelledby', this.id);
          } else {
            //  With no aria-label, clean up aria-labelledby on _elements
            this._elements.button.removeAttribute('aria-labelledby');

            this._elements.overlay.setAttribute('aria-labelledby', this._elements.button.id); // With both items and actions, the items should be grouped and the group should be labeled
            // SelectList menuitemradio group should be labeled by the button, with the selected value, itself,
            // Otherwise the selectList should not be labeled independantly from the menu


            this._elements.selectList[hasMenuItemRadioGroup ? 'setAttribute' : 'removeAttribute']('aria-labelledby', this._elements.button.id);
          }
        } // The id reference for an HTML element that labels the button element accessibility name for the button element
        else if (name === 'aria-labelledby') {
            if (value || !this.getAttribute('aria-label')) {
              this._elements.button.setAttribute('aria-labelledby', "".concat(value, " ").concat(this._elements.button.id));

              this._elements.overlay.setAttribute('aria-labelledby', value || this._elements.button.id);

              this._elements.selectList[this._hasMenuItemRadioGroup() ? 'setAttribute' : 'removeAttribute']('aria-labelledby', value || this._elements.button.id);
            }
          } else {
            _get(_getPrototypeOf(_class.prototype), "attributeChangedCallback", this).call(this, name, oldValue, value);
          }
      }
      /** @ignore */

    }, {
      key: "connectedCallback",
      value: function connectedCallback() {
        _get(_getPrototypeOf(_class.prototype), "connectedCallback", this).call(this);

        var overlay = this._elements.overlay; // Cannot be open by default when rendered

        overlay.removeAttribute('open'); // Restore in DOM

        if (overlay._parent) {
          overlay._parent.appendChild(overlay);
        }
      }
      /** @ignore */

    }, {
      key: "render",
      value: function render() {
        var _this4 = this;

        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        if (!this.id) {
          this.id = this._id;
        }

        this.classList.add(CLASSNAME$Y); // Default reflected attributes

        if (typeof this._threshold === 'undefined') {
          this.threshold = 3;
        }

        if (!this._displayMode) {
          this.displayMode = displayMode$1.ICON;
        } // checks the component's extended mode


        this._checkExtended();

        ['button', 'overlay'].forEach(function (handleName) {
          var handle = _this4.querySelector("[handle=\"".concat(handleName, "\"]"));

          if (handle) {
            handle.remove();
          }
        });
        var frag = document.createDocumentFragment(); // Render the base layout

        frag.appendChild(this._elements.button);
        frag.appendChild(this._elements.overlay); // Inserting the template before the items

        this.appendChild(frag); // Don't trigger events once connected

        this._preventTriggeringEvents = true;

        this._validateSelection();

        this._preventTriggeringEvents = false;
        this._oldSelection = this.selectedItem;
      }
      /** @ignore */

    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        _get(_getPrototypeOf(_class.prototype), "disconnectedCallback", this).call(this);

        var overlay = this._elements.overlay; // In case it was moved out don't forget to remove it

        if (!this.contains(overlay)) {
          overlay._parent = overlay._repositioned ? document.body : this;
          overlay.remove();
        }
      }
      /**
       Triggered when the {@link CycleButton} selected item has changed.
        @typedef {CustomEvent} coral-cyclebutton:change
        @property {CycleButtonItem} detail.oldSelection
       The prior selected item(s).
       @property {CycleButtonItem} detail.selection
       The newly selected item(s).
       */

    }, {
      key: "overlay",
      get: function get() {
        return this._elements.overlay;
      }
      /**
       The Collection Interface that allows interacting with the items that the component contains.
        @type {SelectableCollection}
       @readonly
       */

    }, {
      key: "items",
      get: function get() {
        // just init on demand
        if (!this._items) {
          this._items = new SelectableCollection({
            host: this,
            itemTagName: 'coral-cyclebutton-item',
            onItemAdded: this._onItemAdded,
            onItemRemoved: this._onItemRemoved
          });
        }

        return this._items;
      }
      /**
       The selected item in the CycleButton.
        @type {HTMLElement}
       @readonly
       */

    }, {
      key: "selectedItem",
      get: function get() {
        return this.items._getLastSelected();
      }
      /**
       General icon of the CycleButton. The icon will be displayed no matter the selection. If the selected item has
       its own icon, it will be overwritten.
        @type {String}
       @default ""
       @htmlattribute icon
       @htmlattributereflected
       */

    }, {
      key: "icon",
      get: function get() {
        return this._icon || '';
      },
      set: function set(value) {
        this._icon = transform.string(value);

        this._reflectAttribute('icon', this._icon);

        var selectedItem = this.selectedItem;

        if (selectedItem) {
          this._renderSelectedItem(selectedItem);
        }
      }
      /**
       Number of items that can be directly cycled through before collapsing. If <code>0</code> is used, the items
       will never be collapsed.
        @type {Number}
       @default 3
       @htmlattribute threshold
       @htmlattributereflected
       */

    }, {
      key: "threshold",
      get: function get() {
        return typeof this._threshold === 'number' ? this._threshold : 3;
      },
      set: function set(value) {
        value = transform.number(value);

        if (value > -1) {
          this._threshold = value;

          this._checkExtended();
        }
      }
      /**
       The Collection Interface that allows interaction with the {@link CycleButtonAction} elements.
        @type {SelectableCollection}
       @readonly
       */

    }, {
      key: "actions",
      get: function get() {
        if (!this._actions) {
          this._actions = new SelectableCollection({
            host: this,
            itemTagName: ACTION_TAG_NAME,
            itemSelector: ACTION_TAG_NAME,
            onCollectionChange: this._checkExtended
          });
        }

        return this._actions;
      }
      /**
       The CycleButton's displayMode. This defines how the selected item is displayed. If the selected item does not
       have the necessary icon or text information then fallback to show whichever is available. The appearance of
       collapsed items in the popover are not affected by this property. The displayMode property can be set on an
       item to override the component level value when that item is selected.
       See {@link CycleButtonDisplayModeEnum}.
        @type {String}
       @default CycleButtonDisplayModeEnum.ICON
       @htmlattribute displaymode
       @htmlattributereflected
       */

    }, {
      key: "displayMode",
      get: function get() {
        return this._displayMode || displayMode$1.ICON;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        this._displayMode = validate.enumeration(displayMode$1)(value) && value || displayMode$1.ICON;

        this._reflectAttribute('displaymode', this._displayMode);

        var selectedItem = this.selectedItem;

        if (selectedItem) {
          this._renderSelectedItem(selectedItem);
        }
      }
    }], [{
      key: "displayMode",
      get: function get() {
        return displayMode$1;
      }
    }, {
      key: "_attributePropertyMap",
      get: function get() {
        return commons.extend(_get(_getPrototypeOf(_class), "_attributePropertyMap", this), {
          displaymode: 'displayMode'
        });
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['icon', 'threshold', 'displaymode', 'aria-label', 'aria-labelledby']);
      }
    }]);

    return _class;
  }(BaseComponent(HTMLElement)));

  /**
   @class Coral.CycleButton.Action
   @classdesc A CycleButton Action component
   @htmltag coral-cyclebutton-action
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var CycleButtonAction = Decorator( /*#__PURE__*/function (_BaseComponent) {
    _inherits(_class, _BaseComponent);

    var _super = _createSuper(_class);

    function _class() {
      _classCallCheck(this, _class);

      return _super.apply(this, arguments);
    }

    _createClass(_class, [{
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this); // adds the role to support accessibility


        this.setAttribute('role', 'menuitem');
        this.tabIndex = -1;
      }
    }, {
      key: "icon",

      /**
       The Action's icon. See {@link Coral.Icon} for valid icon names.
        @type {String}
       @default ""
       @htmlattribute icon
       @htmlattributereflected
       */
      get: function get() {
        return this._icon || '';
      },
      set: function set(value) {
        this._icon = transform.string(value);

        this._reflectAttribute('icon', this._icon);
      } // @compat

    }, {
      key: "content",
      get: function get() {
        return this;
      },
      set: function set(value) {
        // Support configs
        if (_typeof(value) === 'object') {
          for (var prop in value) {
            /** @ignore */
            this[prop] = value[prop];
          }
        }
      }
      /**
       Inherited from {@link BaseComponent#trackingElement}.
       */

    }, {
      key: "trackingElement",
      get: function get() {
        return typeof this._trackingElement === 'undefined' ? // keep spaces to only 1 max and trim. this mimics native html behaviors
        (this.content || this).textContent.replace(/\s{2,}/g, ' ').trim() || this.icon : this._trackingElement;
      },
      set: function set(value) {
        _set(_getPrototypeOf(_class.prototype), "trackingElement", value, this, true);
      }
      /** @ignore */

    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['icon']);
      }
    }]);

    return _class;
  }(BaseComponent(HTMLElement)));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons._define('coral-cyclebutton-action', CycleButtonAction);

  commons._define('coral-cyclebutton-item', CycleButtonItem);

  commons._define('coral-cyclebutton', CycleButton);

  CycleButton.Item = CycleButtonItem;
  CycleButton.Action = CycleButtonAction;

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var translations$g = {
    "en-US": {
      "Time": "Time",
      "Calendar": "Calendar"
    },
    "de-DE": {
      "Time": "Zeit",
      "Calendar": "Kalender"
    },
    "fr-FR": {
      "Time": "Heure",
      "Calendar": "Calendrier"
    },
    "it-IT": {
      "Time": "Ora",
      "Calendar": "Calendario"
    },
    "ja-JP": {
      "Time": "時間",
      "Calendar": "カレンダー"
    },
    "es-ES": {
      "Time": "Hora",
      "Calendar": "Calendario"
    },
    "ko-KR": {
      "Time": "시간",
      "Calendar": "달력"
    },
    "zh-CN": {
      "Time": "时间",
      "Calendar": "日历"
    },
    "zh-TW": {
      "Time": "時間",
      "Calendar": "日曆"
    },
    "pt-BR": {
      "Time": "Hora",
      "Calendar": "Calendário"
    },
    "nl-NL": {
      "Time": "Tijd",
      "Calendar": "Kalender"
    },
    "da-DK": {
      "Time": "Tid",
      "Calendar": "Kalender"
    },
    "fi-FI": {
      "Time": "Aika",
      "Calendar": "Kalenteri"
    },
    "nb-NO": {
      "Time": "Klokkeslett",
      "Calendar": "Kalender"
    },
    "sv-SE": {
      "Time": "Tid",
      "Calendar": "Kalender"
    },
    "cs-CZ": {
      "Time": "Čas",
      "Calendar": "Kalendář"
    },
    "pl-PL": {
      "Time": "Czas",
      "Calendar": "Kalendarz"
    },
    "ru-RU": {
      "Time": "Время",
      "Calendar": "Календарь"
    },
    "tr-TR": {
      "Time": "Zaman",
      "Calendar": "Takvim"
    }
  };

  var template$E = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["overlay"] = document.createElement("coral-popover");
    el0.setAttribute("tracking", "off");
    el0.setAttribute("smart", "");
    el0.className += " _coral-Datepicker-overlay";
    el0.setAttribute("handle", "overlay");
    el0.id = data_0["commons"]["getUID"]();
    el0.setAttribute("breadthoffset", "50%r - 50%p");
    el0.setAttribute("placement", "bottom");
    el0.setAttribute("style", "max-height: 75vh;");
    frag.appendChild(el0);
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    var el2 = this["hiddenInput"] = document.createElement("input");
    el2.setAttribute("type", "hidden");
    el2.setAttribute("handle", "hiddenInput");
    frag.appendChild(el2);
    var el3 = document.createTextNode("\n");
    frag.appendChild(el3);
    var el4 = this["input"] = document.createElement("input", "coral-textfield");
    el4.setAttribute("tracking", "off");
    el4.setAttribute("is", "coral-textfield");
    el4.setAttribute("type", "text");
    el4.setAttribute("handle", "input");
    el4.className += " _coral-InputGroup-field";
    el4.setAttribute("role", "textbox");
    frag.appendChild(el4);
    var el5 = document.createTextNode("\n");
    frag.appendChild(el5);
    var el6 = this["toggle"] = document.createElement("button", "coral-button");
    el6.setAttribute("tracking", "off");
    el6.setAttribute("is", "coral-button");
    el6.setAttribute("variant", "_custom");
    el6.className += " _coral-InputGroup-button _coral-FieldButton";
    el6.setAttribute("type", "button");
    el6.setAttribute("handle", "toggle");
    el6.setAttribute("aria-haspopup", "dialog");
    el6.setAttribute("aria-label", data_0["i18n"]["get"]('Calendar'));
    el6.setAttribute("title", data_0["i18n"]["get"]('Calendar'));
    var el7 = document.createTextNode("\n  ");
    el6.appendChild(el7);
    var el8 = this["icon"] = document.createElement("coral-icon");
    el8.setAttribute("icon", "calendar");
    el8.setAttribute("iconsize", "S");
    el8.className += " u-coral-noMargin";
    el8.setAttribute("handle", "icon");
    el6.appendChild(el8);
    var el9 = document.createTextNode("\n  ");
    el6.appendChild(el9);
    var el10 = document.createElement("coral-button-label");
    el6.appendChild(el10);
    var el11 = document.createTextNode("\n");
    el6.appendChild(el11);
    frag.appendChild(el6);
    var el12 = document.createTextNode("\n");
    frag.appendChild(el12);
    return frag;
  };

  var template$F = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var data = data_0 = typeof data_0 === "undefined" ? {} : data_0;
    data = data_0;
    var uid = data.commons.getUID();
    data_0 = data;
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    var el2 = this["calendar"] = document.createElement("coral-calendar");
    el2.setAttribute("handle", "calendar");
    el2.className += " _coral-Datepicker-calendar";
    el2.setAttribute("aria-labelledby", uid + "-calendar");
    var el3 = document.createTextNode("\n  ");
    el2.appendChild(el3);
    var el4 = document.createElement("span");
    el4.id = uid + "-calendar";
    el4.className += " u-coral-screenReaderOnly";
    el4.setAttribute("hidden", "");
    el4.textContent = data_0["i18n"]["get"]("Calendar");
    el2.appendChild(el4);
    var el5 = document.createTextNode("\n");
    el2.appendChild(el5);
    frag.appendChild(el2);
    var el6 = document.createTextNode("\n");
    frag.appendChild(el6);
    var el7 = this["clock"] = document.createElement("coral-clock");
    el7.setAttribute("handle", "clock");
    el7.className += " _coral-Datepicker-clock";
    el7.setAttribute("aria-labelledby", uid + "-clock");
    var el8 = document.createTextNode("\n  ");
    el7.appendChild(el8);
    var el9 = document.createElement("span");
    el9.id = uid + "-clock";
    el9.className += " u-coral-screenReaderOnly";
    el9.setAttribute("hidden", "");
    el9.textContent = data_0["i18n"]["get"]("Time");
    el7.appendChild(el9);
    var el10 = document.createTextNode("\n");
    el7.appendChild(el10);
    frag.appendChild(el7);
    var el11 = document.createTextNode("\n");
    frag.appendChild(el11);
    return frag;
  };

  /**
   Enum for {@link Datepicker} variant values.

   @typedef {Object} DatepickerVariantEnum

   @property {String} DEFAULT
   A default, gray Datepicker.
   @property {String} QUIET
   A Datepicker with no border or background.
   */

  var variant$h = {
    DEFAULT: 'default',
    QUIET: 'quiet'
  };
  var CLASSNAME$Z = '_coral-InputGroup'; // builds a string containing all possible variant classnames. This will be used to remove
  // classnames when the variant changes.

  var ALL_VARIANT_CLASSES$a = [];

  for (var variantKey in variant$h) {
    ALL_VARIANT_CLASSES$a.push("".concat(CLASSNAME$Z, "--").concat(variant$h[variantKey]));
  }
  /** @ignore */


  function toMoment$1(value, format) {
    if (value === 'today') {
      return new DateTime.Moment();
    } else if (DateTime.Moment.isMoment(value)) {
      return value.isValid() ? value.clone() : null;
    } // if the value provided is a date it does not make sense to provide a format to parse the date


    var result = new DateTime.Moment(value, value instanceof Date ? null : format);
    return result.isValid() ? result : null;
  }
  /**
   Enumeration for {@link Datepicker} variants.

   @typedef {Object} DatepickerTypeEnum

   @property {String} DATE
   The selection overlay contains only a calendar.
   @property {String} DATETIME
   Provides both calendar and time controls in the selection overlay.
   @property {String} TIME
   The selection overlay provides only time controls.
   */


  var type = {
    DATE: 'date',
    DATETIME: 'datetime',
    TIME: 'time'
  }; // Used to determine if the client is on a mobile device

  var IS_MOBILE_DEVICE$1 = navigator.userAgent.match(/iPhone|iPad|iPod|Android/i) !== null;
  var NATIVE_FORMATS = {
    date: 'YYYY-MM-DD',
    datetime: 'YYYY-MM-DD[T]HH:mmZ',
    time: 'HH:mm'
  };

  var isNativeFormat = function isNativeFormat(format) {
    var res = false;

    for (var key in NATIVE_FORMATS) {
      if (format === NATIVE_FORMATS[key]) {
        res = true;
      }
    }

    return res;
  };
  /**
   @class Coral.Datepicker
   @classdesc A Datepicker component that can be used as a date and time selection form field. Leverages {@link momentJS}
   if loaded on the page.
   @htmltag coral-datepicker
   @extends {HTMLElement}
   @extends {BaseComponent}
   @extends {BaseFormField}
   */


  var Datepicker = Decorator( /*#__PURE__*/function (_BaseFormField) {
    _inherits(_class, _BaseFormField);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this); // Prepare templates

      _this._elements = {};
      template$E.call(_this._elements, {
        commons: commons,
        i18n: i18n
      }); // Creates and stores the contents of the popover separately

      _this._calendarFragment = template$F.call(_this._elements, {
        commons: commons,
        i18n: i18n
      }); // Pre-define labellable element

      _this._labellableElement = _this._elements.input;
      var overlayId = _this._elements.overlay.id;
      var events = {};
      events["global:capture:click #".concat(overlayId, " coral-calendar")] = '_onCalendarDayClick';
      events["global:capture:change #".concat(overlayId)] = '_onChange';
      events["global:capture:coral-overlay:beforeopen #".concat(overlayId)] = '_onPopoverBeforeOpen';
      events["global:capture:coral-overlay:open #".concat(overlayId)] = '_onPopoverOpenOrClose';
      events["global:capture:coral-overlay:close #".concat(overlayId)] = '_onPopoverOpenOrClose';
      events['key:alt+down [handle="input"],[handle="toggle"]'] = '_onAltDownKey';
      events['key:down [handle="toggle"]'] = '_onAltDownKey';
      events['change coral-datepicker > input[is="coral-textfield"]'] = '_onInputChange'; // Events

      _this._delegateEvents(commons.extend(_this._events, events));

      return _this;
    }
    /**
     Returns the inner overlay to allow customization.
      @type {Popover}
     @readonly
     */


    _createClass(_class, [{
      key: "_onPopoverBeforeOpen",

      /** @ignore */
      value: function _onPopoverBeforeOpen() {
        this._elements.overlay.returnFocusTo(this._elements.input);

        this._elements.calendar._validateCalendar();

        this._renderCalendar();
      }
      /**
       Matches the accessibility to the state of the popover.
        @ignore
       */

    }, {
      key: "_onPopoverOpenOrClose",
      value: function _onPopoverOpenOrClose(event) {
        // set focus to calendar grid
        if (this._elements.overlay.open) {
          if (this.type === type.TIME) {
            this._elements.clock.focus();
          } else {
            this._elements.calendar.focus();
          }

          this._elements.input.setAttribute('aria-expanded', 'true');

          this._elements.toggle.setAttribute('aria-expanded', 'true');

          this._trackEvent('open', 'coral-datepicker', event);
        } else {
          this._elements.input.setAttribute('aria-expanded', 'false');

          this._elements.toggle.setAttribute('aria-expanded', 'false');

          this._trackEvent('close', 'coral-datepicker', event);
        }
      }
      /** @ignore */

    }, {
      key: "_onCalendarDayClick",
      value: function _onCalendarDayClick(event) {
        if (event.target.tagName === 'A') {
          // since a selection has been made, we close the popover. we cannot use the _onChange listener to handle this
          // because clicking on the same button will not trigger a change event
          this._elements.overlay.open = false;

          this._trackEvent('click', 'coral-datepicker', event);
        }
      }
      /** @ignore */

    }, {
      key: "_onInputChange",
      value: function _onInputChange(event) {
        // because we are reimplementing the form field mix in, we will have to stop the propagation and trigger the
        // 'change' event from here
        event.stopPropagation();
        this.value = new DateTime.Moment(event.target.value, this.displayFormat);

        this._validateValue();

        this.trigger('change');

        this._trackEvent('change', 'coral-datepicker', event);
      }
      /** @ignore */

    }, {
      key: "_onChange",
      value: function _onChange(event) {
        if (event.target.tagName === 'CORAL-CALENDAR' || event.target.tagName === 'CORAL-CLOCK') {
          event.stopPropagation(); // we create the new value using both calendar and clock controls
          // datepicker should set the current time as default when no time is set, but a date was chosen (if in datetime
          // mode)

          this.value = this._mergeCalendarAndClockDates(true);

          this._validateValue();

          this.trigger('change');
        }
      }
      /** @private */

    }, {
      key: "_onAltDownKey",
      value: function _onAltDownKey(event) {
        // Stop any consequences of pressing the key
        event.preventDefault();

        if (!this._elements.overlay.open) {
          this._elements.overlay.open = true;
        }
      }
      /** @ignore */

    }, {
      key: "_validateValue",
      value: function _validateValue() {
        // calendar validates only on user input, we have to manually force the validation
        this._elements.calendar._validateCalendar(); // check if the current value is valid and update the internal state of the component


        if (this.type === type.DATE) {
          this.invalid = this._elements.calendar.invalid;
        } else if (this.type === type.TIME) {
          this.invalid = this._elements.clock.invalid;
        } else {
          this.invalid = this._elements.calendar.invalid || this._elements.clock.invalid;
        }
      }
      /** @ignore */

    }, {
      key: "_mergeCalendarAndClockDates",
      value: function _mergeCalendarAndClockDates(autoSetTimeIfNeeded) {
        var value = new DateTime.Moment(this._elements.calendar.valueAsDate);
        var time = this._elements.clock.valueAsDate;

        if (autoSetTimeIfNeeded && value && !time && this.type === type.DATETIME) {
          // datepicker should set the current time as default when no time is set, but a date was chosen (if in datetime
          // mode)
          time = new DateTime.Moment().toDate();
        }

        if (time) {
          if (!value.isValid()) {
            value = new DateTime.Moment();
          }

          value.hours(time.getHours());
          value.minutes(time.getMinutes());
        }

        return value;
      }
      /**
       Helper class that converts the internal moment value into a String using the provided date format. If the value is
       invalid, empty string will be returned.
        @param {?Moment} value
       The value representing the date. It has to be a moment object or <code>null</code>
       @param {String} format
       The Date format to be used.
        @ignore
       */

    }, {
      key: "_getValueAsString",
      value: function _getValueAsString(value, format) {
        return value && value.isValid() ? value.format(format) : '';
      }
      /** @ignore */

    }, {
      key: "_renderCalendar",
      value: function _renderCalendar() {
        if (this._elements.overlay.content.innerHTML === '') {
          this._elements.overlay.content.appendChild(this._calendarFragment);

          this._calendarFragment = undefined;
        }
      }
      /**
       Returns {@link Datepicker} variants.
        @return {DatepickerVariantEnum}
       */

    }, {
      key: "connectedCallback",

      /** @ignore */
      value: function connectedCallback() {
        _get(_getPrototypeOf(_class.prototype), "connectedCallback", this).call(this);

        var overlay = this._elements.overlay; // Cannot be open by default when rendered

        overlay.removeAttribute('open'); // Restore in DOM

        if (overlay._parent) {
          overlay._parent.appendChild(overlay);
        }
      }
      /** @ignore */

    }, {
      key: "render",
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$Z); // a11y

        this.setAttribute('role', 'group'); // Input attributes per ARIA Autocomplete

        this._elements.input.setAttribute('role', 'combobox');

        this._elements.input.setAttribute('aria-autocomplete', 'none');

        this._elements.input.setAttribute('aria-haspopup', 'dialog');

        this._elements.input.setAttribute('aria-expanded', 'false');

        this._elements.input.setAttribute('aria-controls', this._elements.overlay.id); // Trigger button attributes per ARIA Autocomplete


        this._elements.toggle.setAttribute('aria-haspopup', 'dialog');

        this._elements.toggle.setAttribute('aria-expanded', 'false');

        this._elements.toggle.setAttribute('aria-controls', this._elements.overlay.id); // a11y we only have AUTO mode.


        this._useNativeInput = IS_MOBILE_DEVICE$1; // Default reflected attributes

        if (!this._variant) {
          this.variant = variant$h.DEFAULT;
        } // "type" takes care of reflecting "displayFormat" and "valueFormat"


        if (!this._type) {
          this.type = type.DATE;
        } // clean up to be able to clone it


        while (this.firstChild) {
          this.removeChild(this.firstChild);
        }

        var frag = document.createDocumentFragment(); // Render template

        frag.appendChild(this._elements.hiddenInput);
        frag.appendChild(this._elements.input);
        frag.appendChild(this._elements.toggle);
        frag.appendChild(this._elements.overlay); // Point at the button from the bottom

        this._elements.overlay.target = this._elements.toggle;
        this.appendChild(frag);
      }
      /** @ignore */

    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        _get(_getPrototypeOf(_class.prototype), "disconnectedCallback", this).call(this);

        var overlay = this._elements.overlay; // In case it was moved out don't forget to remove it

        if (!this.contains(overlay)) {
          overlay._parent = overlay._repositioned ? document.body : this;
          overlay.remove();
        }
      }
    }, {
      key: "overlay",
      get: function get() {
        return this._elements.overlay;
      }
      /**
       The type of datepicker to show to the user. See {@link DatepickerTypeEnum}.
        @type {DatepickerTypeEnum}
       @default DatepickerTypeEnum.DATE
       @htmlattribute type
       @htmlattributereflected
       */

    }, {
      key: "type",
      get: function get() {
        return this._type || type.DATE;
      },
      set: function set(value) {
        // Flag to indicate that we are changing the type for the first time
        this._typeFormatChanged = typeof this._type === 'undefined';
        value = transform.string(value).toLowerCase();
        this._type = validate.enumeration(type)(value) && value || type.DATE;

        this._reflectAttribute('type', this._type);

        var format = NATIVE_FORMATS[this._type];
        var isTime = this._type === type.TIME;
        var isDate = this._type === type.DATE;
        this._elements.icon.icon = isTime ? 'clock' : 'calendar';
        var toggleLabel = isTime ? i18n.get('Time') : i18n.get('Calendar');

        this._elements.toggle.setAttribute('aria-label', toggleLabel);

        this._elements.toggle.setAttribute('title', toggleLabel);

        this._elements.clock.hidden = isDate;

        this._elements.clock.setAttribute('aria-hidden', isDate);

        this._elements.calendar.hidden = isTime;

        this._elements.calendar.setAttribute('aria-hidden', isTime); // Change format if we have a native format set


        if (isNativeFormat(this.valueFormat)) {
          this.valueFormat = format;
        }

        if (isNativeFormat(this.displayFormat)) {
          this.displayFormat = format;
        }

        this._useNativeInput = this._useNativeInput;
        this._typeFormatChanged = false;
      }
      /**
       The format used to display the selected date(time) to the user. If the user manually types a date, this format
       will be used to parse the value. When using this component on a mobile device, the display format must follow
       the format used by the native input. If an empty string is provided, then the default value per type will
       be used. The default value depends on the <code>type</code>, which can be one from <code>YYYY-MM-DD</code>,
       <code>YYYY-MM-DD[T]HH:mmZ</code> or <code>HH:mm</code>.  Include momentjs to support additional format string options
       see http://momentjs.com/docs/#/displaying/.
        @type {String}
       @default "YYYY-MM-DD"
       @htmlattribute displayformat
       @htmlattributereflected
       */

    }, {
      key: "displayFormat",
      get: function get() {
        // we ignore _useNativeInput when the type is datetime because it is not supported by mobile libraries
        if (this._useNativeInput && this.type !== type.DATETIME) {
          return NATIVE_FORMATS[this.type];
        }

        return typeof this._displayFormat === 'undefined' ? NATIVE_FORMATS[this.type] : this._displayFormat;
      },
      set: function set(value) {
        value = transform.string(value).trim(); // In case a custom display format was set, we make sure that type doesn't change it to a native format

        var displayFormatAttribute = this.getAttribute('displayformat');

        if (this._typeFormatChanged && displayFormatAttribute && displayFormatAttribute !== value) {
          value = displayFormatAttribute;
        }

        this._displayFormat = value === '' ? NATIVE_FORMATS[this.type] : value;

        this._reflectAttribute('displayformat', this._displayFormat);

        this._elements.clock.displayFormat = this._displayFormat;
        this._elements.input.value = this._getValueAsString(this._value, this._displayFormat);
      }
      /**
       The format to use on expressing the selected date as a string on the <code>value</code> attribute. The value
       will be sent to the server using this format. If an empty string is provided, then the default value per type
       will be used. The default value depends on the <code>type</code>, which can be one from <code>YYYY-MM-DD</code>,
       <code>YYYY-MM-DD[T]HH:mmZ</code> or <code>HH:mm</code>. Include momentjs to support additional format string options
       see http://momentjs.com/docs/#/displaying/.
        @type {String}
       @default "YYYY-MM-DD"
       @htmlattribute valueformat
       @htmlattributereflected
       */

    }, {
      key: "valueFormat",
      get: function get() {
        return typeof this._valueFormat === 'undefined' ? NATIVE_FORMATS[this.type] : this._valueFormat;
      },
      set: function set(value) {
        var _this2 = this;

        var setValueFormat = function setValueFormat(newValue) {
          _this2._valueFormat = newValue === '' ? NATIVE_FORMATS[_this2.type] : newValue;

          _this2._reflectAttribute('valueformat', _this2._valueFormat);
        };

        value = transform.string(value).trim(); // In case a custom display format was set, we make sure that type doesn't change it to a native format

        var valueFormatAttribute = this.getAttribute('valueformat');

        if (this._typeFormatChanged && valueFormatAttribute && valueFormatAttribute !== value) {
          value = valueFormatAttribute;
        } // Once the valueFormat is set, we make sure the value is also correct


        if (!this._valueFormat && this._originalValue) {
          setValueFormat(value);
          this.value = this._originalValue;
        } else {
          setValueFormat(value);
        }

        this._elements.calendar.valueFormat = this._valueFormat;
        this._elements.hiddenInput.value = this.value;
      }
      /**
       The value of the element, interpreted as a date, or <code>null</code> if conversion is not possible.
        @type {Date}
       @default null
       */

    }, {
      key: "valueAsDate",
      get: function get() {
        var value = this._value; // If type is DATE, then you strip out the time

        if (this.type === 'date' && value) {
          value = value.startOf('day');
        }

        return value ? value.toDate() : null;
      },
      set: function set(value) {
        this._valueAsDate = value instanceof Date ? new DateTime.Moment(value) : '';
        this.value = this._valueAsDate;
      }
      /**
       The minimum date that the Datepicker will accept as valid. It must not be greated that its maximum. It accepts
       both date and string values. When a string is provided, it should match the {@link Coral.Datepicker#valueFormat}.
        See {@link Coral.Calendar#min}
        @type {String|Date}
       @default null
       @htmlattribute min
       */

    }, {
      key: "min",
      get: function get() {
        return this._elements.calendar.min;
      },
      set: function set(value) {
        this._elements.calendar.min = value;
      }
      /**
       The maximum date that the Datepicker will accept as valid. It must not be less than its minimum. It accepts both
       date and string values. When a string is provided, it should match the {@link Coral.Datepicker#valueFormat}.
        See {@link Coral.Calendar#max}
        @type {String|Date}
       @default null
       @htmlattribute max
       */

    }, {
      key: "max",
      get: function get() {
        return this._elements.calendar.max;
      },
      set: function set(value) {
        this._elements.calendar.max = value;
      }
      /**
       The format used to display the current month and year.
       'MMMM YYYY' is supported by default. Include momentjs to support additional format string options see
       http://momentjs.com/docs/#/displaying/.
        See {@link Coral.Calendar#startDay}
        @type {String}
       @default "MMMM YYYY"
       @htmlattribute headerformat
       */

    }, {
      key: "headerFormat",
      get: function get() {
        return this._elements.calendar.headerFormat;
      },
      set: function set(value) {
        this._elements.calendar.headerFormat = value;
      }
      /**
       Defines the start day for the week, 0 = Sunday, 1 = Monday etc., as depicted on the calendar days grid.
        See {@link Coral.Calendar#startDay}
        @type {Number}
       @default 0
       @htmlattribute startday
       */

    }, {
      key: "startDay",
      get: function get() {
        return this._elements.calendar.startDay;
      },
      set: function set(value) {
        this._elements.calendar.startDay = value;
      }
      /**
       The current value. When set to "today", the value is coerced into the client's local date expressed as string
       formatted in accordance to the set <code>valueFormat</code>.
        See {@link Coral.Calendar#value}
        @type {String}
       @default ""
       @htmlattribute value
       */

    }, {
      key: "value",
      get: function get() {
        return this._getValueAsString(this._value, this.valueFormat);
      },
      set: function set(value) {
        // This is used to change the value if valueformat is also set but afterwards
        this._originalValue = value;
        this._value = toMoment$1(value, this.valueFormat);
        this._elements.calendar.valueAsDate = this.valueAsDate;
        this._elements.clock.valueAsDate = this.valueAsDate;
        this._elements.input.value = this._getValueAsString(this._value, this.displayFormat);
        this._elements.hiddenInput.value = this.value;
      }
      /**
       Short hint that describes the expected value of the Datepicker. It is displayed when the Datepicker is empty.
        @type {String}
       @default ""
       @htmlattribute placeholder
       @htmlattributereflected
       */

    }, {
      key: "placeholder",
      get: function get() {
        return this._elements.input.placeholder;
      },
      set: function set(value) {
        this._elements.input.placeholder = value;

        this._reflectAttribute('placeholder', this.placeholder);
      }
      /**
       The datepicker's variant. See {@link DatepickerVariantEnum}.
        @type {DatepickerVariantEnum}
       @default DatepickerVariantEnum.DEFAULT
       @htmlattribute variant
       @htmlattributereflected
       */

    }, {
      key: "variant",
      get: function get() {
        return this._variant || variant$h.DEFAULT;
      },
      set: function set(value) {
        var _this$classList;

        value = transform.string(value).toLowerCase();
        this._variant = validate.enumeration(variant$h)(value) && value || variant$h.DEFAULT; // passes down the variant to the underlying components

        this._elements.input.variant = this._variant;

        this._elements.toggle.classList.toggle('_coral-FieldButton--quiet', this._variant === variant$h.QUIET); // removes every existing variant


        (_this$classList = this.classList).remove.apply(_this$classList, ALL_VARIANT_CLASSES$a);

        if (this._variant !== variant$h.DEFAULT) {
          this.classList.add("".concat(CLASSNAME$Z, "--").concat(this._variant));
        }
      }
      /**
       Name used to submit the data in a form.
       @type {String}
       @default ""
       @htmlattribute name
       @htmlattributereflected
       */

    }, {
      key: "name",
      get: function get() {
        return this._elements.hiddenInput.name;
      },
      set: function set(value) {
        this._reflectAttribute('name', value);

        this._elements.hiddenInput.name = value;
      }
      /**
       Whether this field is disabled or not.
       @type {Boolean}
       @default false
       @htmlattribute disabled
       @htmlattributereflected
       */

    }, {
      key: "disabled",
      get: function get() {
        return this._disabled || false;
      },
      set: function set(value) {
        this._disabled = transform.booleanAttr(value);

        this._reflectAttribute('disabled', this._disabled);

        this[this._disabled ? 'setAttribute' : 'removeAttribute']('aria-disabled', this._disabled);
        this.classList.toggle('is-disabled', this._disabled);
        this._elements.input.disabled = this._disabled;
        this._elements.hiddenInput.disabled = this._disabled;
        this._elements.toggle.disabled = this._disabled || this.readOnly;

        this._elements.toggle.setAttribute("tabindex", !this._elements.toggle.disabled ? "0" : "-1");
      }
      /**
       Inherited from {@link BaseFormField#invalid}.
       */

    }, {
      key: "invalid",
      get: function get() {
        return _get(_getPrototypeOf(_class.prototype), "invalid", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(_class.prototype), "invalid", value, this, true);

        this.classList.toggle('is-invalid', this.invalid);

        this._elements.toggle.classList.toggle('is-invalid', this.invalid);

        this._elements.input.invalid = this.invalid;

        this._elements.input.setAttribute('aria-invalid', this.invalid);
      }
      /**
       Whether this field is required or not.
       @type {Boolean}
       @default false
       @htmlattribute required
       @htmlattributereflected
       */

    }, {
      key: "required",
      get: function get() {
        return this._required || false;
      },
      set: function set(value) {
        this._required = transform.booleanAttr(value);

        this._reflectAttribute('required', this._required);

        this._elements.toggle.classList.toggle('is-invalid', this._required);

        this._elements.input.required = this._required;
      }
      /**
       Whether this field is readOnly or not. Indicating that the user cannot modify the value of the control.
       @type {Boolean}
       @default false
       @htmlattribute readonly
       @htmlattributereflected
       */

    }, {
      key: "readOnly",
      get: function get() {
        return this._readOnly || false;
      },
      set: function set(value) {
        this._readOnly = transform.booleanAttr(value);

        this._reflectAttribute('readonly', this._readOnly);

        this._elements.hiddenInput.readOnly = this.readOnly;
        this._elements.input.readOnly = this._readOnly;
        this._elements.toggle.disabled = this._readOnly || this.disabled;

        this._elements.toggle.setAttribute("tabindex", !this._elements.toggle.disabled ? "0" : "-1");
      }
      /**
       Inherited from {@link BaseFormField#labelled}.
       */

    }, {
      key: "labelled",
      get: function get() {
        return _get(_getPrototypeOf(_class.prototype), "labelled", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(_class.prototype), "labelled", value, this, true); // in case the user focuses the buttons, he will still get a notion of the usage of the component


        this[this.labelled ? 'setAttribute' : 'removeAttribute']('aria-label', this.labelled);

        this._elements.overlay[this.labelled ? 'setAttribute' : 'removeAttribute']('aria-label', this.labelled);

        this._elements.calendar[this.labelled ? 'setAttribute' : 'removeAttribute']('labelled', this.labelled);
      }
      /**
       Inherited from {@link BaseFormField#labelledBy}.
       */

    }, {
      key: "labelledBy",
      get: function get() {
        return _get(_getPrototypeOf(_class.prototype), "labelledBy", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(_class.prototype), "labelledBy", value, this, true); // in case the user focuses the buttons, he will still get a notion of the usage of the component


        this[this.labelledBy ? 'setAttribute' : 'removeAttribute']('aria-labelledby', this.labelledBy);

        this._elements.overlay[this.labelledBy ? 'setAttribute' : 'removeAttribute']('aria-labelledby', this.labelledBy);

        this._elements.calendar[this.labelledBy ? 'setAttribute' : 'removeAttribute']('aria-labelledby', this.labelledBy);
      }
      /**
       When <code>true</code> the component will default to the native input for the date selection. When
       {@link Coral.Datepicker.type.DATETIME} has been set, it will still use the Coral way because mobile browsers
       cannot handle a datetime input.
        @ignore
       */

    }, {
      key: "_useNativeInput",
      get: function get() {
        return this.__useNativeInput;
      },
      set: function set(value) {
        this.__useNativeInput = value; // we ignore _useNativeInput when the type is datetime because it is not supported by mobile libraries

        if (this.__useNativeInput && this.type !== type.DATETIME) {
          // Switch to native date/time picker:
          this._elements.toggle.hidden = true;

          this._elements.input.setAttribute('type', this.type); // Hide pop-over and remove related attributes:


          this._elements.overlay.hidden = true;

          this._elements.input.removeAttribute('role');

          this._elements.input.removeAttribute('aria-autocomplete');

          this._elements.input.removeAttribute('aria-haspopup');

          this._elements.input.removeAttribute('aria-expanded');

          this._elements.input.removeAttribute('aria-controls');
        } else {
          // Switch to Calendar picker
          this._elements.toggle.hidden = false;

          this._elements.input.setAttribute('type', 'text'); // Show pop-over and add related attributes:


          this._elements.overlay.hidden = false; // Input attributes per ARIA Autocomplete

          this._elements.input.setAttribute('role', 'combobox');

          this._elements.input.setAttribute('aria-autocomplete', 'none');

          this._elements.input.setAttribute('aria-haspopup', 'dialog');

          this._elements.input.setAttribute('aria-expanded', this._elements.overlay.open);

          this._elements.input.setAttribute('aria-controls', this._elements.overlay.id); // Trigger button attributes per ARIA Autocomplete


          this._elements.toggle.setAttribute('aria-haspopup', 'dialog');

          this._elements.toggle.setAttribute('aria-expanded', this._elements.overlay.open);

          this._elements.toggle.setAttribute('aria-controls', this._elements.overlay.id);
        }
      }
    }], [{
      key: "variant",
      get: function get() {
        return variant$h;
      }
      /**
       Returns {@link Datepicker} types.
        @return {DatepickerTypeEnum}
       */

    }, {
      key: "type",
      get: function get() {
        return type;
      }
    }, {
      key: "_attributePropertyMap",
      get: function get() {
        return commons.extend(_get(_getPrototypeOf(_class), "_attributePropertyMap", this), {
          startday: 'startDay',
          headerformat: 'headerFormat',
          displayformat: 'displayFormat',
          valueformat: 'valueFormat'
        });
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['min', 'max', 'type', 'placeholder', 'startday', 'headerFormat', 'displayformat', 'valueformat', 'variant']);
      }
    }]);

    return _class;
  }(BaseFormField(BaseComponent(HTMLElement))));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons.extend(strings, {
    'coral-component-datepicker': translations$g
  }); // Expose component on the Coral namespace

  commons._define('coral-datepicker', Datepicker);

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var translations$h = {
    "en-US": {
      "More": "More"
    },
    "de-DE": {
      "More": "Mehr"
    },
    "fr-FR": {
      "More": "Plus"
    },
    "it-IT": {
      "More": "Altro"
    },
    "ja-JP": {
      "More": "その他"
    },
    "es-ES": {
      "More": "Más"
    },
    "ko-KR": {
      "More": "자세히"
    },
    "zh-CN": {
      "More": "更多"
    },
    "zh-TW": {
      "More": "更多"
    },
    "pt-BR": {
      "More": "Mais"
    },
    "nl-NL": {
      "More": "Meer"
    },
    "da-DK": {
      "More": "Mere"
    },
    "fi-FI": {
      "More": "Lisää"
    },
    "nb-NO": {
      "More": "Mer"
    },
    "sv-SE": {
      "More": "Mer"
    },
    "cs-CZ": {
      "More": "Více"
    },
    "pl-PL": {
      "More": "Więcej"
    },
    "ru-RU": {
      "More": "Дополнительно"
    },
    "tr-TR": {
      "More": "Daha Fazla"
    }
  };

  var template$G = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var data = data_0 = typeof data_0 === "undefined" ? {} : data_0;
    data = data_0;
    var buttonId = data.commons.getUID();
    var contentId = data.commons.getUID();
    data_0 = data;
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    var el2 = this["slider"] = document.createElement("div");
    el2.setAttribute("handle", "slider");
    el2.className += " _coral-Drawer-slider";
    var el3 = document.createTextNode("\n  ");
    el2.appendChild(el3);
    var el4 = this["contentWrapper"] = document.createElement("div");
    el4.setAttribute("handle", "contentWrapper");
    el4.className += " _coral-Drawer-content";
    el4.id = contentId;
    el4.setAttribute("aria-labelledby", buttonId);
    el4.setAttribute("role", "region");
    el2.appendChild(el4);
    var el5 = document.createTextNode("\n");
    el2.appendChild(el5);
    frag.appendChild(el2);
    var el6 = document.createTextNode("\n");
    frag.appendChild(el6);
    var el7 = this["toggle"] = document.createElement("div");
    el7.className += " _coral-Drawer-toggle";
    el7.setAttribute("handle", "toggle");
    var el8 = document.createTextNode("\n  ");
    el7.appendChild(el8);
    var el9 = this["toggleButton"] = document.createElement("button", "coral-button");
    el9.id = buttonId;
    el9.setAttribute("aria-controls", contentId);
    el9.setAttribute("aria-label", data_0["i18n"]["get"]('More'));
    el9.className += " _coral-Drawer-toggleButton";
    el9.setAttribute("type", "button");
    el9.setAttribute("handle", "toggleButton");
    el9.setAttribute("is", "coral-button");
    el9.setAttribute("variant", "quiet");
    el7.appendChild(el9);
    var el10 = document.createTextNode("\n");
    el7.appendChild(el10);
    frag.appendChild(el7);
    var el11 = document.createTextNode("\n");
    frag.appendChild(el11);
    return frag;
  };

  /**
   Enumeration for {@link Drawer} directions.

   @typedef {Object} DrawerDirectionEnum

   @property {String} DOWN
   A drawer with a toggle button on the bottom.
   @property {String} UP
   A drawer with a toggle button on top.
   */

  var direction$1 = {
    DOWN: 'down',
    UP: 'up'
  }; // The drawer's base classname

  var CLASSNAME$_ = '_coral-Drawer'; // A string of all possible direction classnames

  var ALL_DIRECTION_CLASSES = [];

  for (var directionValue in direction$1) {
    ALL_DIRECTION_CLASSES.push("".concat(CLASSNAME$_, "--").concat(direction$1[directionValue]));
  }
  /**
   @class Coral.Drawer
   @classdesc A Drawer component to display content that can be opened and closed with a sliding animation.
   @htmltag coral-drawer
   @extends {HTMLElement}
   @extends {BaseComponent}
   */


  var Drawer = Decorator( /*#__PURE__*/function (_BaseComponent) {
    _inherits(_class, _BaseComponent);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this); // Templates

      _this._elements = {
        content: _this.querySelector('coral-drawer-content') || document.createElement('coral-drawer-content')
      };
      template$G.call(_this._elements, {
        commons: commons,
        i18n: i18n
      }); // Events

      _this._delegateEvents({
        'click ._coral-Drawer-toggleButton': '_onClick'
      });

      return _this;
    }
    /**
     Whether this item is disabled or not. This will stop every user interaction with the item.
      @type {Boolean}
     @default false
     @htmlattribute disabled
     @htmlattributereflected
     */


    _createClass(_class, [{
      key: "_onClick",

      /** @private */
      value: function _onClick() {
        this.open = !this.open;
      }
    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$_, 'coral-Well'); // Default reflected attributes

        if (!this._direction) {
          this.direction = direction$1.DOWN;
        }

        if (!this._open) {
          this.open = false;
        } // Create a fragment


        var fragment = document.createDocumentFragment();
        var templateHandleNames = ['slider', 'toggle']; // Render the template

        fragment.appendChild(this._elements.slider);
        fragment.appendChild(this._elements.toggle); // Fetch or create the content content zone element

        var content = this._elements.content; // Move any remaining elements into the content sub-component

        while (this.firstChild) {
          var child = this.firstChild;

          if (child.nodeType === Node.TEXT_NODE || child.nodeType === Node.ELEMENT_NODE && templateHandleNames.indexOf(child.getAttribute('handle')) === -1) {
            // Add non-template elements to the label
            content.appendChild(child);
          } else {
            // Remove anything else
            this.removeChild(child);
          }
        } // Add the frag to the component


        this.appendChild(fragment); // Assign the content zone

        this.content = content;
      }
      /**
       Triggered when the {@link Drawer} is opened.
        @typedef {CustomEvent} coral-drawer:open
       */

      /**
       Triggered when the {@link Drawer} is closed.
        @typedef {CustomEvent} coral-drawer:close
       */

    }, {
      key: "disabled",
      get: function get() {
        return this._disabled || false;
      },
      set: function set(value) {
        this._disabled = transform.booleanAttr(value);

        this._reflectAttribute('disabled', this._disabled);

        this[this._disabled ? 'setAttribute' : 'removeAttribute']('aria-disabled', this._disabled);
        this._elements.toggle.hidden = this._disabled;
      }
      /**
       The drawer's content element.
        @type {DrawerContent}
       @htmlttribute content
       @contentzone
       */

    }, {
      key: "content",
      get: function get() {
        return this._getContentZone(this._elements.content);
      },
      set: function set(value) {
        this._setContentZone('content', value, {
          handle: 'content',
          tagName: 'coral-drawer-content',
          insert: function insert(content) {
            this._elements.contentWrapper.appendChild(content);
          }
        });
      }
      /**
       The drawer's direction. See {@link DrawerDirectionEnum}.
        @type {String}
       @default DrawerDirectionEnum.DOWN
       @htmlattribute direction
       @htmlattributereflected
       */

    }, {
      key: "direction",
      get: function get() {
        return this._direction || direction$1.DOWN;
      },
      set: function set(value) {
        var _this$classList;

        value = transform.string(value).toLowerCase();
        this._direction = validate.enumeration(direction$1)(value) && value || direction$1.DOWN;

        this._reflectAttribute('direction', this._direction);

        (_this$classList = this.classList).remove.apply(_this$classList, ALL_DIRECTION_CLASSES);

        this.classList.add("".concat(CLASSNAME$_, "--").concat(this._direction));
      }
      /**
       Whether the Drawer is expanded or not.
        @type {Boolean}
       @default false
       @htmlattribute open
       @htmlattributereflected
       */

    }, {
      key: "open",
      get: function get() {
        return this._open || false;
      },
      set: function set(value) {
        var _this2 = this;

        var silenced = this._silenced;
        this._open = transform.booleanAttr(value);

        this._reflectAttribute('open', this._open);

        this._elements.toggleButton.setAttribute('aria-expanded', this._open); // eslint-disable-next-line no-unused-vars

        var slider = this._elements.slider; // Don't animate on initialization

        if (this._animate) {
          commons.transitionEnd(slider, function () {
            // Keep it silenced
            _this2._silenced = silenced; // Remove height as we want the drawer to naturally grow if content is added later

            if (_this2._open) {
              slider.style.height = '';
            } // Trigger once transition is finished


            _this2.trigger("coral-drawer:".concat(_this2._open ? 'open' : 'close'));

            _this2._silenced = false;
          });

          if (!this._open) {
            // Force height to enable transition
            slider.style.height = "".concat(slider.scrollHeight, "px");
          } // Do transition in next task as browser might batch up the height property change before painting


          window.setTimeout(function () {
            slider.style.height = _this2._open ? "".concat(slider.scrollHeight, "px") : 0;
          }, 10);
        } else {
          // Make sure it's animated next time
          this._animate = true; // Hide it on initialization if closed

          if (!this._open) {
            slider.style.height = 0;
          }
        }
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-drawer-content': 'content'
        };
      }
      /**
       Returns {@link Drawer} direction options.
        @return {DrawerDirectionEnum}
       */

    }], [{
      key: "direction",
      get: function get() {
        return direction$1;
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['disabled', 'direction', 'open']);
      }
    }]);

    return _class;
  }(BaseComponent(HTMLElement)));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Drawer.Content
   @classdesc Drawer content component
   @htmltag coral-drawer-content
   @return {HTMLElement}
   */
  var DrawerContent = (function () {
    return document.createElement('coral-drawer-content');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons.extend(strings, {
    'coral-component-drawer': translations$h
  }); // Expose component on the Coral namespace

  commons._define('coral-drawer', Drawer);

  Drawer.Content = DrawerContent;

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var MIME_TYPES = {
    ".123": "application/vnd.lotus-1-2-3",
    ".3dml": "text/vnd.in3d.3dml",
    ".3g2": "video/3gpp2",
    ".3gp": "video/3gpp",
    ".a": "application/octet-stream",
    ".aab": "application/x-authorware-bin",
    ".aac": "audio/x-aac",
    ".aam": "application/x-authorware-map",
    ".aas": "application/x-authorware-seg",
    ".abw": "application/x-abiword",
    ".acc": "application/vnd.americandynamics.acc",
    ".ace": "application/x-ace-compressed",
    ".acu": "application/vnd.acucobol",
    ".acutc": "application/vnd.acucorp",
    ".adp": "audio/adpcm",
    ".aep": "application/vnd.audiograph",
    ".afm": "application/x-font-type1",
    ".afp": "application/vnd.ibm.modcap",
    ".ai": "application/postscript",
    ".aif": "audio/x-aiff",
    ".aifc": "audio/x-aiff",
    ".aiff": "audio/x-aiff",
    ".air": "application/vnd.adobe.air-application-installer-package+zip",
    ".ami": "application/vnd.amiga.ami",
    ".apk": "application/vnd.android.package-archive",
    ".application": "application/x-ms-application",
    ".apr": "application/vnd.lotus-approach",
    ".asc": "application/pgp-signature",
    ".asf": "video/x-ms-asf",
    ".asm": "text/x-asm",
    ".aso": "application/vnd.accpac.simply.aso",
    ".asx": "video/x-ms-asf",
    ".atc": "application/vnd.acucorp",
    ".atom": "application/atom+xml",
    ".atomcat": "application/atomcat+xml",
    ".atomsvc": "application/atomsvc+xml",
    ".atx": "application/vnd.antix.game-component",
    ".au": "audio/basic",
    ".avi": "video/x-msvideo",
    ".aw": "application/applixware",
    ".azf": "application/vnd.airzip.filesecure.azf",
    ".azs": "application/vnd.airzip.filesecure.azs",
    ".azw": "application/vnd.amazon.ebook",
    ".bat": "application/x-msdownload",
    ".bcpio": "application/x-bcpio",
    ".bdf": "application/x-font-bdf",
    ".bdm": "application/vnd.syncml.dm+wbxml",
    ".bh2": "application/vnd.fujitsu.oasysprs",
    ".bin": "application/octet-stream",
    ".bmi": "application/vnd.bmi",
    ".bmp": "image/bmp",
    ".book": "application/vnd.framemaker",
    ".box": "application/vnd.previewsystems.box",
    ".boz": "application/x-bzip2",
    ".bpk": "application/octet-stream",
    ".btif": "image/prs.btif",
    ".bz": "application/x-bzip",
    ".bz2": "application/x-bzip2",
    ".c": "text/x-c",
    ".c4d": "application/vnd.clonk.c4group",
    ".c4f": "application/vnd.clonk.c4group",
    ".c4g": "application/vnd.clonk.c4group",
    ".c4p": "application/vnd.clonk.c4group",
    ".c4u": "application/vnd.clonk.c4group",
    ".cab": "application/vnd.ms-cab-compressed",
    ".car": "application/vnd.curl.car",
    ".cat": "application/vnd.ms-pki.seccat",
    ".cc": "text/x-c",
    ".cct": "application/x-director",
    ".ccxml": "application/ccxml+xml",
    ".cdbcmsg": "application/vnd.contact.cmsg",
    ".cdf": "application/x-netcdf",
    ".cdkey": "application/vnd.mediastation.cdkey",
    ".cdx": "chemical/x-cdx",
    ".cdxml": "application/vnd.chemdraw+xml",
    ".cdy": "application/vnd.cinderella",
    ".cer": "application/pkix-cert",
    ".cgm": "image/cgm",
    ".chat": "application/x-chat",
    ".chm": "application/vnd.ms-htmlhelp",
    ".chrt": "application/vnd.kde.kchart",
    ".cif": "chemical/x-cif",
    ".cii": "application/vnd.anser-web-certificate-issue-initiation",
    ".cil": "application/vnd.ms-artgalry",
    ".cla": "application/vnd.claymore",
    ".class": "application/java-vm",
    ".clkk": "application/vnd.crick.clicker.keyboard",
    ".clkp": "application/vnd.crick.clicker.palette",
    ".clkt": "application/vnd.crick.clicker.template",
    ".clkw": "application/vnd.crick.clicker.wordbank",
    ".clkx": "application/vnd.crick.clicker",
    ".clp": "application/x-msclip",
    ".cmc": "application/vnd.cosmocaller",
    ".cmdf": "chemical/x-cmdf",
    ".cml": "chemical/x-cml",
    ".cmp": "application/vnd.yellowriver-custom-menu",
    ".cmx": "image/x-cmx",
    ".cod": "application/vnd.rim.cod",
    ".com": "application/x-msdownload",
    ".conf": "text/plain",
    ".cpio": "application/x-cpio",
    ".cpp": "text/x-c",
    ".cpt": "application/mac-compactpro",
    ".crd": "application/x-mscardfile",
    ".crl": "application/pkix-crl",
    ".crt": "application/x-x509-ca-cert",
    ".csh": "application/x-csh",
    ".csml": "chemical/x-csml",
    ".csp": "application/vnd.commonspace",
    ".css": "text/css",
    ".cst": "application/x-director",
    ".csv": ["text/csv", "application/vnd.ms-excel"],
    ".cu": "application/cu-seeme",
    ".curl": "text/vnd.curl",
    ".cww": "application/prs.cww",
    ".cxt": "application/x-director",
    ".cxx": "text/x-c",
    ".daf": "application/vnd.mobius.daf",
    ".dataless": "application/vnd.fdsn.seed",
    ".davmount": "application/davmount+xml",
    ".dcr": "application/x-director",
    ".dcurl": "text/vnd.curl.dcurl",
    ".dd2": "application/vnd.oma.dd2+xml",
    ".ddd": "application/vnd.fujixerox.ddd",
    ".deb": "application/x-debian-package",
    ".def": "text/plain",
    ".deploy": "application/octet-stream",
    ".der": "application/x-x509-ca-cert",
    ".dfac": "application/vnd.dreamfactory",
    ".dic": "text/x-c",
    ".diff": "text/plain",
    ".dir": "application/x-director",
    ".dis": "application/vnd.mobius.dis",
    ".dist": "application/octet-stream",
    ".distz": "application/octet-stream",
    ".djv": "image/vnd.djvu",
    ".djvu": "image/vnd.djvu",
    ".dll": "application/x-msdownload",
    ".dmg": "application/octet-stream",
    ".dms": "application/octet-stream",
    ".dna": "application/vnd.dna",
    ".doc": "application/msword",
    ".docm": "application/vnd.ms-word.document.macroenabled.12",
    ".docx": "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    ".dot": "application/msword",
    ".dotm": "application/vnd.ms-word.template.macroenabled.12",
    ".dotx": "application/vnd.openxmlformats-officedocument.wordprocessingml.template",
    ".dp": "application/vnd.osgi.dp",
    ".dpg": "application/vnd.dpgraph",
    ".dsc": "text/prs.lines.tag",
    ".dtb": "application/x-dtbook+xml",
    ".dtd": "application/xml-dtd",
    ".dts": "audio/vnd.dts",
    ".dtshd": "audio/vnd.dts.hd",
    ".dump": "application/octet-stream",
    ".dvi": "application/x-dvi",
    ".dwf": "model/vnd.dwf",
    ".dwg": "image/vnd.dwg",
    ".dxf": "image/vnd.dxf",
    ".dxp": "application/vnd.spotfire.dxp",
    ".dxr": "application/x-director",
    ".ecelp4800": "audio/vnd.nuera.ecelp4800",
    ".ecelp7470": "audio/vnd.nuera.ecelp7470",
    ".ecelp9600": "audio/vnd.nuera.ecelp9600",
    ".ecma": "application/ecmascript",
    ".edm": "application/vnd.novadigm.edm",
    ".edx": "application/vnd.novadigm.edx",
    ".efif": "application/vnd.picsel",
    ".ei6": "application/vnd.pg.osasli",
    ".elc": "application/octet-stream",
    ".eml": "message/rfc822",
    ".emma": "application/emma+xml",
    ".eol": "audio/vnd.digital-winds",
    ".eot": "application/vnd.ms-fontobject",
    ".eps": "application/postscript",
    ".epub": "application/epub+zip",
    ".es3": "application/vnd.eszigno3+xml",
    ".esf": "application/vnd.epson.esf",
    ".et3": "application/vnd.eszigno3+xml",
    ".etx": "text/x-setext",
    ".exe": "application/x-msdownload",
    ".ext": "application/vnd.novadigm.ext",
    ".ez": "application/andrew-inset",
    ".ez2": "application/vnd.ezpix-album",
    ".ez3": "application/vnd.ezpix-package",
    ".f": "text/x-fortran",
    ".f4v": "video/x-f4v",
    ".f77": "text/x-fortran",
    ".f90": "text/x-fortran",
    ".fbs": "image/vnd.fastbidsheet",
    ".fdf": "application/vnd.fdf",
    ".fe_launch": "application/vnd.denovo.fcselayout-link",
    ".fg5": "application/vnd.fujitsu.oasysgp",
    ".fgd": "application/x-director",
    ".fh": "image/x-freehand",
    ".fh4": "image/x-freehand",
    ".fh5": "image/x-freehand",
    ".fh7": "image/x-freehand",
    ".fhc": "image/x-freehand",
    ".fig": "application/x-xfig",
    ".fli": "video/x-fli",
    ".flo": "application/vnd.micrografx.flo",
    ".flv": "video/x-flv",
    ".flw": "application/vnd.kde.kivio",
    ".flx": "text/vnd.fmi.flexstor",
    ".fly": "text/vnd.fly",
    ".fm": "application/vnd.framemaker",
    ".fnc": "application/vnd.frogans.fnc",
    ".for": "text/x-fortran",
    ".fpx": "image/vnd.fpx",
    ".frame": "application/vnd.framemaker",
    ".fsc": "application/vnd.fsc.weblaunch",
    ".fst": "image/vnd.fst",
    ".ftc": "application/vnd.fluxtime.clip",
    ".fti": "application/vnd.anser-web-funds-transfer-initiation",
    ".fvt": "video/vnd.fvt",
    ".fzs": "application/vnd.fuzzysheet",
    ".g3": "image/g3fax",
    ".gac": "application/vnd.groove-account",
    ".gdl": "model/vnd.gdl",
    ".geo": "application/vnd.dynageo",
    ".gex": "application/vnd.geometry-explorer",
    ".ggb": "application/vnd.geogebra.file",
    ".ggt": "application/vnd.geogebra.tool",
    ".ghf": "application/vnd.groove-help",
    ".gif": "image/gif",
    ".gim": "application/vnd.groove-identity-message",
    ".gmx": "application/vnd.gmx",
    ".gnumeric": "application/x-gnumeric",
    ".gph": "application/vnd.flographit",
    ".gqf": "application/vnd.grafeq",
    ".gqs": "application/vnd.grafeq",
    ".gram": "application/srgs",
    ".gre": "application/vnd.geometry-explorer",
    ".grv": "application/vnd.groove-injector",
    ".grxml": "application/srgs+xml",
    ".gsf": "application/x-font-ghostscript",
    ".gtar": "application/x-gtar",
    ".gtm": "application/vnd.groove-tool-message",
    ".gtw": "model/vnd.gtw",
    ".gv": "text/vnd.graphviz",
    ".gz": "application/x-gzip",
    ".h": "text/x-c",
    ".h261": "video/h261",
    ".h263": "video/h263",
    ".h264": "video/h264",
    ".hbci": "application/vnd.hbci",
    ".hdf": "application/x-hdf",
    ".hh": "text/x-c",
    ".hlp": "application/winhlp",
    ".hpgl": "application/vnd.hp-hpgl",
    ".hpid": "application/vnd.hp-hpid",
    ".hps": "application/vnd.hp-hps",
    ".hqx": "application/mac-binhex40",
    ".htke": "application/vnd.kenameaapp",
    ".htm": "text/html",
    ".html": "text/html",
    ".hvd": "application/vnd.yamaha.hv-dic",
    ".hvp": "application/vnd.yamaha.hv-voice",
    ".hvs": "application/vnd.yamaha.hv-script",
    ".icc": "application/vnd.iccprofile",
    ".ice": "x-conference/x-cooltalk",
    ".icm": "application/vnd.iccprofile",
    ".ico": "image/x-icon",
    ".ics": "text/calendar",
    ".ief": "image/ief",
    ".ifb": "text/calendar",
    ".ifm": "application/vnd.shana.informed.formdata",
    ".iges": "model/iges",
    ".igl": "application/vnd.igloader",
    ".igs": "model/iges",
    ".igx": "application/vnd.micrografx.igx",
    ".iif": "application/vnd.shana.informed.interchange",
    ".imp": "application/vnd.accpac.simply.imp",
    ".ims": "application/vnd.ms-ims",
    ".in": "text/plain",
    ".ipk": "application/vnd.shana.informed.package",
    ".irm": "application/vnd.ibm.rights-management",
    ".irp": "application/vnd.irepository.package+xml",
    ".iso": "application/octet-stream",
    ".itp": "application/vnd.shana.informed.formtemplate",
    ".ivp": "application/vnd.immervision-ivp",
    ".ivu": "application/vnd.immervision-ivu",
    ".jad": "text/vnd.sun.j2me.app-descriptor",
    ".jam": "application/vnd.jam",
    ".jar": "application/java-archive",
    ".java": "text/x-java-source",
    ".jisp": "application/vnd.jisp",
    ".jlt": "application/vnd.hp-jlyt",
    ".jnlp": "application/x-java-jnlp-file",
    ".joda": "application/vnd.joost.joda-archive",
    ".jpe": "image/jpeg",
    ".jpeg": "image/jpeg",
    ".jpg": "image/jpeg",
    ".jpgm": "video/jpm",
    ".jpgv": "video/jpeg",
    ".jpm": "video/jpm",
    ".js": "application/javascript",
    ".json": "application/json",
    ".kar": "audio/midi",
    ".karbon": "application/vnd.kde.karbon",
    ".kfo": "application/vnd.kde.kformula",
    ".kia": "application/vnd.kidspiration",
    ".kil": "application/x-killustrator",
    ".kml": "application/vnd.google-earth.kml+xml",
    ".kmz": "application/vnd.google-earth.kmz",
    ".kne": "application/vnd.kinar",
    ".knp": "application/vnd.kinar",
    ".kon": "application/vnd.kde.kontour",
    ".kpr": "application/vnd.kde.kpresenter",
    ".kpt": "application/vnd.kde.kpresenter",
    ".ksh": "text/plain",
    ".ksp": "application/vnd.kde.kspread",
    ".ktr": "application/vnd.kahootz",
    ".ktz": "application/vnd.kahootz",
    ".kwd": "application/vnd.kde.kword",
    ".kwt": "application/vnd.kde.kword",
    ".latex": "application/x-latex",
    ".lbd": "application/vnd.llamagraphics.life-balance.desktop",
    ".lbe": "application/vnd.llamagraphics.life-balance.exchange+xml",
    ".les": "application/vnd.hhe.lesson-player",
    ".lha": "application/octet-stream",
    ".link66": "application/vnd.route66.link66+xml",
    ".list": "text/plain",
    ".list3820": "application/vnd.ibm.modcap",
    ".listafp": "application/vnd.ibm.modcap",
    ".log": "text/plain",
    ".lostxml": "application/lost+xml",
    ".lrf": "application/octet-stream",
    ".lrm": "application/vnd.ms-lrm",
    ".ltf": "application/vnd.frogans.ltf",
    ".lvp": "audio/vnd.lucent.voice",
    ".lwp": "application/vnd.lotus-wordpro",
    ".lzh": "application/octet-stream",
    ".m13": "application/x-msmediaview",
    ".m14": "application/x-msmediaview",
    ".m1v": "video/mpeg",
    ".m2a": "audio/mpeg",
    ".m2v": "video/mpeg",
    ".m3a": "audio/mpeg",
    ".m3u": "audio/x-mpegurl",
    ".m4u": "video/vnd.mpegurl",
    ".m4v": "video/x-m4v",
    ".ma": "application/mathematica",
    ".mag": "application/vnd.ecowin.chart",
    ".maker": "application/vnd.framemaker",
    ".man": "text/troff",
    ".mathml": "application/mathml+xml",
    ".mb": "application/mathematica",
    ".mbk": "application/vnd.mobius.mbk",
    ".mbox": "application/mbox",
    ".mc1": "application/vnd.medcalcdata",
    ".mcd": "application/vnd.mcd",
    ".mcurl": "text/vnd.curl.mcurl",
    ".mdb": "application/x-msaccess",
    ".mdi": "image/vnd.ms-modi",
    ".me": "text/troff",
    ".mesh": "model/mesh",
    ".mfm": "application/vnd.mfmp",
    ".mgz": "application/vnd.proteus.magazine",
    ".mht": "message/rfc822",
    ".mhtml": "message/rfc822",
    ".mid": "audio/midi",
    ".midi": "audio/midi",
    ".mif": "application/vnd.mif",
    ".mime": "message/rfc822",
    ".mj2": "video/mj2",
    ".mjp2": "video/mj2",
    ".mlp": "application/vnd.dolby.mlp",
    ".mmd": "application/vnd.chipnuts.karaoke-mmd",
    ".mmf": "application/vnd.smaf",
    ".mmr": "image/vnd.fujixerox.edmics-mmr",
    ".mny": "application/x-msmoney",
    ".mobi": "application/x-mobipocket-ebook",
    ".mov": "video/quicktime",
    ".movie": "video/x-sgi-movie",
    ".mp2": "audio/mpeg",
    ".mp2a": "audio/mpeg",
    ".mp3": "audio/mpeg",
    ".mp4": "video/mp4",
    ".mp4a": "audio/mp4",
    ".mp4s": "application/mp4",
    ".mp4v": "video/mp4",
    ".mpa": "video/mpeg",
    ".mpc": "application/vnd.mophun.certificate",
    ".mpe": "video/mpeg",
    ".mpeg": "video/mpeg",
    ".mpg": "video/mpeg",
    ".mpg4": "video/mp4",
    ".mpga": "audio/mpeg",
    ".mpkg": "application/vnd.apple.installer+xml",
    ".mpm": "application/vnd.blueice.multipass",
    ".mpn": "application/vnd.mophun.application",
    ".mpp": "application/vnd.ms-project",
    ".mpt": "application/vnd.ms-project",
    ".mpy": "application/vnd.ibm.minipay",
    ".mqy": "application/vnd.mobius.mqy",
    ".mrc": "application/marc",
    ".ms": "text/troff",
    ".mscml": "application/mediaservercontrol+xml",
    ".mseed": "application/vnd.fdsn.mseed",
    ".mseq": "application/vnd.mseq",
    ".msf": "application/vnd.epson.msf",
    ".msh": "model/mesh",
    ".msi": "application/x-msdownload",
    ".msl": "application/vnd.mobius.msl",
    ".msty": "application/vnd.muvee.style",
    ".mts": "model/vnd.mts",
    ".mus": "application/vnd.musician",
    ".musicxml": "application/vnd.recordare.musicxml+xml",
    ".mvb": "application/x-msmediaview",
    ".mwf": "application/vnd.mfer",
    ".mxf": "application/mxf",
    ".mxl": "application/vnd.recordare.musicxml",
    ".mxml": "application/xv+xml",
    ".mxs": "application/vnd.triscape.mxs",
    ".mxu": "video/vnd.mpegurl",
    ".n-gage": "application/vnd.nokia.n-gage.symbian.install",
    ".nb": "application/mathematica",
    ".nc": "application/x-netcdf",
    ".ncx": "application/x-dtbncx+xml",
    ".ngdat": "application/vnd.nokia.n-gage.data",
    ".nlu": "application/vnd.neurolanguage.nlu",
    ".nml": "application/vnd.enliven",
    ".nnd": "application/vnd.noblenet-directory",
    ".nns": "application/vnd.noblenet-sealer",
    ".nnw": "application/vnd.noblenet-web",
    ".npx": "image/vnd.net-fpx",
    ".nsf": "application/vnd.lotus-notes",
    ".nws": "message/rfc822",
    ".o": "application/octet-stream",
    ".oa2": "application/vnd.fujitsu.oasys2",
    ".oa3": "application/vnd.fujitsu.oasys3",
    ".oas": "application/vnd.fujitsu.oasys",
    ".obd": "application/x-msbinder",
    ".obj": "application/octet-stream",
    ".oda": "application/oda",
    ".odb": "application/vnd.oasis.opendocument.database",
    ".odc": "application/vnd.oasis.opendocument.chart",
    ".odf": "application/vnd.oasis.opendocument.formula",
    ".odft": "application/vnd.oasis.opendocument.formula-template",
    ".odg": "application/vnd.oasis.opendocument.graphics",
    ".odi": "application/vnd.oasis.opendocument.image",
    ".odp": "application/vnd.oasis.opendocument.presentation",
    ".ods": "application/vnd.oasis.opendocument.spreadsheet",
    ".odt": "application/vnd.oasis.opendocument.text",
    ".oga": "audio/ogg",
    ".ogg": "audio/ogg",
    ".ogv": "video/ogg",
    ".ogx": "application/ogg",
    ".onepkg": "application/onenote",
    ".onetmp": "application/onenote",
    ".onetoc": "application/onenote",
    ".onetoc2": "application/onenote",
    ".opf": "application/oebps-package+xml",
    ".oprc": "application/vnd.palm",
    ".org": "application/vnd.lotus-organizer",
    ".osf": "application/vnd.yamaha.openscoreformat",
    ".osfpvg": "application/vnd.yamaha.openscoreformat.osfpvg+xml",
    ".otc": "application/vnd.oasis.opendocument.chart-template",
    ".otf": "application/x-font-otf",
    ".otg": "application/vnd.oasis.opendocument.graphics-template",
    ".oth": "application/vnd.oasis.opendocument.text-web",
    ".oti": "application/vnd.oasis.opendocument.image-template",
    ".otm": "application/vnd.oasis.opendocument.text-master",
    ".otp": "application/vnd.oasis.opendocument.presentation-template",
    ".ots": "application/vnd.oasis.opendocument.spreadsheet-template",
    ".ott": "application/vnd.oasis.opendocument.text-template",
    ".oxt": "application/vnd.openofficeorg.extension",
    ".p": "text/x-pascal",
    ".p10": "application/pkcs10",
    ".p12": "application/x-pkcs12",
    ".p7b": "application/x-pkcs7-certificates",
    ".p7c": "application/pkcs7-mime",
    ".p7m": "application/pkcs7-mime",
    ".p7r": "application/x-pkcs7-certreqresp",
    ".p7s": "application/pkcs7-signature",
    ".pas": "text/x-pascal",
    ".pbd": "application/vnd.powerbuilder6",
    ".pbm": "image/x-portable-bitmap",
    ".pcf": "application/x-font-pcf",
    ".pcl": "application/vnd.hp-pcl",
    ".pclxl": "application/vnd.hp-pclxl",
    ".pct": "image/x-pict",
    ".pcurl": "application/vnd.curl.pcurl",
    ".pcx": "image/x-pcx",
    ".pdb": "application/vnd.palm",
    ".pdf": "application/pdf",
    ".pfa": "application/x-font-type1",
    ".pfb": "application/x-font-type1",
    ".pfm": "application/x-font-type1",
    ".pfr": "application/font-tdpfr",
    ".pfx": "application/x-pkcs12",
    ".pgm": "image/x-portable-graymap",
    ".pgn": "application/x-chess-pgn",
    ".pgp": "application/pgp-encrypted",
    ".pic": "image/x-pict",
    ".pkg": "application/octet-stream",
    ".pki": "application/pkixcmp",
    ".pkipath": "application/pkix-pkipath",
    ".pl": "text/plain",
    ".plb": "application/vnd.3gpp.pic-bw-large",
    ".plc": "application/vnd.mobius.plc",
    ".plf": "application/vnd.pocketlearn",
    ".pls": "application/pls+xml",
    ".pml": "application/vnd.ctc-posml",
    ".png": "image/png",
    ".pnm": "image/x-portable-anymap",
    ".portpkg": "application/vnd.macports.portpkg",
    ".pot": "application/vnd.ms-powerpoint",
    ".potm": "application/vnd.ms-powerpoint.template.macroenabled.12",
    ".potx": "application/vnd.openxmlformats-officedocument.presentationml.template",
    ".ppa": "application/vnd.ms-powerpoint",
    ".ppam": "application/vnd.ms-powerpoint.addin.macroenabled.12",
    ".ppd": "application/vnd.cups-ppd",
    ".ppm": "image/x-portable-pixmap",
    ".pps": "application/vnd.ms-powerpoint",
    ".ppsm": "application/vnd.ms-powerpoint.slideshow.macroenabled.12",
    ".ppsx": "application/vnd.openxmlformats-officedocument.presentationml.slideshow",
    ".ppt": "application/vnd.ms-powerpoint",
    ".pptm": "application/vnd.ms-powerpoint.presentation.macroenabled.12",
    ".pptx": "application/vnd.openxmlformats-officedocument.presentationml.presentation",
    ".pqa": "application/vnd.palm",
    ".prc": "application/x-mobipocket-ebook",
    ".pre": "application/vnd.lotus-freelance",
    ".prf": "application/pics-rules",
    ".ps": "application/postscript",
    ".psb": "application/vnd.3gpp.pic-bw-small",
    ".psd": "image/vnd.adobe.photoshop",
    ".psf": "application/x-font-linux-psf",
    ".ptid": "application/vnd.pvi.ptid1",
    ".pub": "application/x-mspublisher",
    ".pvb": "application/vnd.3gpp.pic-bw-var",
    ".pwn": "application/vnd.3m.post-it-notes",
    ".pwz": "application/vnd.ms-powerpoint",
    ".py": "text/x-python",
    ".pya": "audio/vnd.ms-playready.media.pya",
    ".pyc": "application/x-python-code",
    ".pyo": "application/x-python-code",
    ".pyv": "video/vnd.ms-playready.media.pyv",
    ".qam": "application/vnd.epson.quickanime",
    ".qbo": "application/vnd.intu.qbo",
    ".qfx": "application/vnd.intu.qfx",
    ".qps": "application/vnd.publishare-delta-tree",
    ".qt": "video/quicktime",
    ".qwd": "application/vnd.quark.quarkxpress",
    ".qwt": "application/vnd.quark.quarkxpress",
    ".qxb": "application/vnd.quark.quarkxpress",
    ".qxd": "application/vnd.quark.quarkxpress",
    ".qxl": "application/vnd.quark.quarkxpress",
    ".qxt": "application/vnd.quark.quarkxpress",
    ".ra": "audio/x-pn-realaudio",
    ".ram": "audio/x-pn-realaudio",
    ".rar": "application/x-rar-compressed",
    ".ras": "image/x-cmu-raster",
    ".rcprofile": "application/vnd.ipunplugged.rcprofile",
    ".rdf": "application/rdf+xml",
    ".rdz": "application/vnd.data-vision.rdz",
    ".rep": "application/vnd.businessobjects",
    ".res": "application/x-dtbresource+xml",
    ".rgb": "image/x-rgb",
    ".rif": "application/reginfo+xml",
    ".rl": "application/resource-lists+xml",
    ".rlc": "image/vnd.fujixerox.edmics-rlc",
    ".rld": "application/resource-lists-diff+xml",
    ".rm": "application/vnd.rn-realmedia",
    ".rmi": "audio/midi",
    ".rmp": "audio/x-pn-realaudio-plugin",
    ".rms": "application/vnd.jcp.javame.midlet-rms",
    ".rnc": "application/relax-ng-compact-syntax",
    ".roff": "text/troff",
    ".rpm": "application/x-rpm",
    ".rpss": "application/vnd.nokia.radio-presets",
    ".rpst": "application/vnd.nokia.radio-preset",
    ".rq": "application/sparql-query",
    ".rs": "application/rls-services+xml",
    ".rsd": "application/rsd+xml",
    ".rss": "application/rss+xml",
    ".rtf": "application/rtf",
    ".rtx": "text/richtext",
    ".s": "text/x-asm",
    ".saf": "application/vnd.yamaha.smaf-audio",
    ".sbml": "application/sbml+xml",
    ".sc": "application/vnd.ibm.secure-container",
    ".scd": "application/x-msschedule",
    ".scm": "application/vnd.lotus-screencam",
    ".scq": "application/scvp-cv-request",
    ".scs": "application/scvp-cv-response",
    ".scurl": "text/vnd.curl.scurl",
    ".sda": "application/vnd.stardivision.draw",
    ".sdc": "application/vnd.stardivision.calc",
    ".sdd": "application/vnd.stardivision.impress",
    ".sdkd": "application/vnd.solent.sdkm+xml",
    ".sdkm": "application/vnd.solent.sdkm+xml",
    ".sdp": "application/sdp",
    ".sdw": "application/vnd.stardivision.writer",
    ".see": "application/vnd.seemail",
    ".seed": "application/vnd.fdsn.seed",
    ".sema": "application/vnd.sema",
    ".semd": "application/vnd.semd",
    ".semf": "application/vnd.semf",
    ".ser": "application/java-serialized-object",
    ".setpay": "application/set-payment-initiation",
    ".setreg": "application/set-registration-initiation",
    ".sfd-hdstx": "application/vnd.hydrostatix.sof-data",
    ".sfs": "application/vnd.spotfire.sfs",
    ".sgl": "application/vnd.stardivision.writer-global",
    ".sgm": "text/sgml",
    ".sgml": "text/sgml",
    ".sh": "application/x-sh",
    ".shar": "application/x-shar",
    ".shf": "application/shf+xml",
    ".si": "text/vnd.wap.si",
    ".sic": "application/vnd.wap.sic",
    ".sig": "application/pgp-signature",
    ".silo": "model/mesh",
    ".sis": "application/vnd.symbian.install",
    ".sisx": "application/vnd.symbian.install",
    ".sit": "application/x-stuffit",
    ".sitx": "application/x-stuffitx",
    ".skd": "application/vnd.koan",
    ".skm": "application/vnd.koan",
    ".skp": "application/vnd.koan",
    ".skt": "application/vnd.koan",
    ".sl": "text/vnd.wap.sl",
    ".slc": "application/vnd.wap.slc",
    ".sldm": "application/vnd.ms-powerpoint.slide.macroenabled.12",
    ".sldx": "application/vnd.openxmlformats-officedocument.presentationml.slide",
    ".slt": "application/vnd.epson.salt",
    ".smf": "application/vnd.stardivision.math",
    ".smi": "application/smil+xml",
    ".smil": "application/smil+xml",
    ".snd": "audio/basic",
    ".snf": "application/x-font-snf",
    ".so": "application/octet-stream",
    ".spc": "application/x-pkcs7-certificates",
    ".spf": "application/vnd.yamaha.smaf-phrase",
    ".spl": "application/x-futuresplash",
    ".spot": "text/vnd.in3d.spot",
    ".spp": "application/scvp-vp-response",
    ".spq": "application/scvp-vp-request",
    ".spx": "audio/ogg",
    ".src": "application/x-wais-source",
    ".srx": "application/sparql-results+xml",
    ".sse": "application/vnd.kodak-descriptor",
    ".ssf": "application/vnd.epson.ssf",
    ".ssml": "application/ssml+xml",
    ".stc": "application/vnd.sun.xml.calc.template",
    ".std": "application/vnd.sun.xml.draw.template",
    ".stf": "application/vnd.wt.stf",
    ".sti": "application/vnd.sun.xml.impress.template",
    ".stk": "application/hyperstudio",
    ".stl": "application/vnd.ms-pki.stl",
    ".str": "application/vnd.pg.format",
    ".stw": "application/vnd.sun.xml.writer.template",
    ".sus": "application/vnd.sus-calendar",
    ".susp": "application/vnd.sus-calendar",
    ".sv4cpio": "application/x-sv4cpio",
    ".sv4crc": "application/x-sv4crc",
    ".svd": "application/vnd.svd",
    ".svg": "image/svg+xml",
    ".svgz": "image/svg+xml",
    ".swa": "application/x-director",
    ".swf": "application/x-shockwave-flash",
    ".swi": "application/vnd.arastra.swi",
    ".sxc": "application/vnd.sun.xml.calc",
    ".sxd": "application/vnd.sun.xml.draw",
    ".sxg": "application/vnd.sun.xml.writer.global",
    ".sxi": "application/vnd.sun.xml.impress",
    ".sxm": "application/vnd.sun.xml.math",
    ".sxw": "application/vnd.sun.xml.writer",
    ".t": "text/troff",
    ".tao": "application/vnd.tao.intent-module-archive",
    ".tar": "application/x-tar",
    ".tcap": "application/vnd.3gpp2.tcap",
    ".tcl": "application/x-tcl",
    ".teacher": "application/vnd.smart.teacher",
    ".tex": "application/x-tex",
    ".texi": "application/x-texinfo",
    ".texinfo": "application/x-texinfo",
    ".text": "text/plain",
    ".tfm": "application/x-tex-tfm",
    ".tgz": "application/x-gzip",
    ".tif": "image/tiff",
    ".tiff": "image/tiff",
    ".tmo": "application/vnd.tmobile-livetv",
    ".torrent": "application/x-bittorrent",
    ".tpl": "application/vnd.groove-tool-template",
    ".tpt": "application/vnd.trid.tpt",
    ".tr": "text/troff",
    ".tra": "application/vnd.trueapp",
    ".trm": "application/x-msterminal",
    ".tsv": "text/tab-separated-values",
    ".ttc": "application/x-font-ttf",
    ".ttf": "application/x-font-ttf",
    ".twd": "application/vnd.simtech-mindmapper",
    ".twds": "application/vnd.simtech-mindmapper",
    ".txd": "application/vnd.genomatix.tuxedo",
    ".txf": "application/vnd.mobius.txf",
    ".txt": "text/plain",
    ".u32": "application/x-authorware-bin",
    ".udeb": "application/x-debian-package",
    ".ufd": "application/vnd.ufdl",
    ".ufdl": "application/vnd.ufdl",
    ".umj": "application/vnd.umajin",
    ".unityweb": "application/vnd.unity",
    ".uoml": "application/vnd.uoml+xml",
    ".uri": "text/uri-list",
    ".uris": "text/uri-list",
    ".urls": "text/uri-list",
    ".ustar": "application/x-ustar",
    ".utz": "application/vnd.uiq.theme",
    ".uu": "text/x-uuencode",
    ".vcd": "application/x-cdlink",
    ".vcf": "text/x-vcard",
    ".vcg": "application/vnd.groove-vcard",
    ".vcs": "text/x-vcalendar",
    ".vcx": "application/vnd.vcx",
    ".vis": "application/vnd.visionary",
    ".viv": "video/vnd.vivo",
    ".vor": "application/vnd.stardivision.writer",
    ".vox": "application/x-authorware-bin",
    ".vrml": "model/vrml",
    ".vsd": "application/vnd.visio",
    ".vsf": "application/vnd.vsf",
    ".vss": "application/vnd.visio",
    ".vst": "application/vnd.visio",
    ".vsw": "application/vnd.visio",
    ".vtu": "model/vnd.vtu",
    ".vxml": "application/voicexml+xml",
    ".w3d": "application/x-director",
    ".wad": "application/x-doom",
    ".wav": "audio/x-wav",
    ".wax": "audio/x-ms-wax",
    ".wbmp": "image/vnd.wap.wbmp",
    ".wbs": "application/vnd.criticaltools.wbs+xml",
    ".wbxml": "application/vnd.wap.wbxml",
    ".wcm": "application/vnd.ms-works",
    ".wdb": "application/vnd.ms-works",
    ".wiz": "application/msword",
    ".wks": "application/vnd.ms-works",
    ".wm": "video/x-ms-wm",
    ".wma": "audio/x-ms-wma",
    ".wmd": "application/x-ms-wmd",
    ".wmf": "application/x-msmetafile",
    ".wml": "text/vnd.wap.wml",
    ".wmlc": "application/vnd.wap.wmlc",
    ".wmls": "text/vnd.wap.wmlscript",
    ".wmlsc": "application/vnd.wap.wmlscriptc",
    ".wmv": "video/x-ms-wmv",
    ".wmx": "video/x-ms-wmx",
    ".wmz": "application/x-ms-wmz",
    ".wpd": "application/vnd.wordperfect",
    ".wpl": "application/vnd.ms-wpl",
    ".wps": "application/vnd.ms-works",
    ".wqd": "application/vnd.wqd",
    ".wri": "application/x-mswrite",
    ".wrl": "model/vrml",
    ".wsdl": "application/wsdl+xml",
    ".wspolicy": "application/wspolicy+xml",
    ".wtb": "application/vnd.webturbo",
    ".wvx": "video/x-ms-wvx",
    ".x32": "application/x-authorware-bin",
    ".x3d": "application/vnd.hzn-3d-crossword",
    ".xap": "application/x-silverlight-app",
    ".xar": "application/vnd.xara",
    ".xbap": "application/x-ms-xbap",
    ".xbd": "application/vnd.fujixerox.docuworks.binder",
    ".xbm": "image/x-xbitmap",
    ".xdm": "application/vnd.syncml.dm+xml",
    ".xdp": "application/vnd.adobe.xdp+xml",
    ".xdw": "application/vnd.fujixerox.docuworks",
    ".xenc": "application/xenc+xml",
    ".xer": "application/patch-ops-error+xml",
    ".xfdf": "application/vnd.adobe.xfdf",
    ".xfdl": "application/vnd.xfdl",
    ".xht": "application/xhtml+xml",
    ".xhtml": "application/xhtml+xml",
    ".xhvml": "application/xv+xml",
    ".xif": "image/vnd.xiff",
    ".xla": "application/vnd.ms-excel",
    ".xlam": "application/vnd.ms-excel.addin.macroenabled.12",
    ".xlb": "application/vnd.ms-excel",
    ".xlc": "application/vnd.ms-excel",
    ".xlm": "application/vnd.ms-excel",
    ".xls": "application/vnd.ms-excel",
    ".xlsb": "application/vnd.ms-excel.sheet.binary.macroenabled.12",
    ".xlsm": "application/vnd.ms-excel.sheet.macroenabled.12",
    ".xlsx": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    ".xlt": "application/vnd.ms-excel",
    ".xltm": "application/vnd.ms-excel.template.macroenabled.12",
    ".xltx": "application/vnd.openxmlformats-officedocument.spreadsheetml.template",
    ".xlw": "application/vnd.ms-excel",
    ".xml": "application/xml",
    ".xo": "application/vnd.olpc-sugar",
    ".xop": "application/xop+xml",
    ".xpdl": "application/xml",
    ".xpi": "application/x-xpinstall",
    ".xpm": "image/x-xpixmap",
    ".xpr": "application/vnd.is-xpr",
    ".xps": "application/vnd.ms-xpsdocument",
    ".xpw": "application/vnd.intercon.formnet",
    ".xpx": "application/vnd.intercon.formnet",
    ".xsl": "application/xml",
    ".xslt": "application/xslt+xml",
    ".xsm": "application/vnd.syncml+xml",
    ".xspf": "application/xspf+xml",
    ".xul": "application/vnd.mozilla.xul+xml",
    ".xvm": "application/xv+xml",
    ".xvml": "application/xv+xml",
    ".xwd": "image/x-xwindowdump",
    ".xyz": "chemical/x-xyz",
    ".zaz": "application/vnd.zzazz.deck+xml",
    ".zip": "application/zip",
    ".zir": "application/vnd.zul",
    ".zirz": "application/vnd.zul",
    ".zmm": "application/vnd.handheld-entertainment+xml"
  };

  /**
   Enumeration for {@link FileUploadItem} response types.

   @typedef {Object} FileUploadItemResponseTypeEnum

   @property {String} TEXT
   String type.
   @property {String} ARRAY_BUFFER
   Array buffer type.
   @property {String} BLOB
   Blob type.
   @property {String} DOCUMENT
   Document type.
   @property {String} JSON
   JavaScript object, parsed from a JSON string returned by the server.
   */

  var responseType = {
    TEXT: 'text',
    ARRAY_BUFFER: 'arraybuffer',
    BLOB: 'blob',
    DOCUMENT: 'document',
    JSON: 'json'
  }; // eg text/plain

  var MIME_TYPE_REGEXP = /(.+)\/(.+)$/; // eg .txt

  var FILE_EXTENSION_REGEXP = /\.(.+)$/; // eg text

  var SHORTCUT_REGEXP = /.*/;
  var MIME_TYPE_AUDIO = 'audio/*';
  var MIME_TYPE_IMAGE = 'image/*';
  var MIME_TYPE_VIDEO = 'video/*';
  /**
   @class Coral.FileUpload.Item
   @classdesc A FileUpload item encapsulating file meta-data
   @param {File|HTMLElement} file
   The file element.
   */

  var FileUploadItem = /*#__PURE__*/function () {
    /**
     Takes a {File} as argument.
      @param {File} file
     */
    function FileUploadItem(file) {
      _classCallCheck(this, FileUploadItem);

      this._originalFile = file;
      this._xhr = null;
    }
    /**
     The File.
      @name file
     @readonly
     @type {File}
     */


    _createClass(FileUploadItem, [{
      key: "_isMimeTypeAllowed",

      /** @private */
      value: function _isMimeTypeAllowed(acceptedMimeTypes) {
        var isAllowed = false; // Unrecognized browser mime types have a file type of ''.

        var fileType = this.file.type || 'application/unknown';

        if (!fileType.match(MIME_TYPE_REGEXP)) {
          // File mime type is erroneous
          return false;
        }

        return acceptedMimeTypes.split(',').some(function (allowedMimeType) {
          allowedMimeType = allowedMimeType.trim();

          if (allowedMimeType === '*' || allowedMimeType === '.*' || allowedMimeType === '*/*' || fileType === 'application/unknown') {
            // Explicit wildcard case: allow any file
            // Allow unknown mime types
            isAllowed = true;
          } else if (allowedMimeType.match(MIME_TYPE_REGEXP)) {
            if (allowedMimeType === MIME_TYPE_AUDIO) {
              isAllowed = fileType.indexOf(MIME_TYPE_AUDIO.slice(0, -1)) === 0;
            } else if (allowedMimeType === MIME_TYPE_IMAGE) {
              isAllowed = fileType.indexOf(MIME_TYPE_IMAGE.slice(0, -1)) === 0;
            } else if (allowedMimeType === MIME_TYPE_VIDEO) {
              isAllowed = fileType.indexOf(MIME_TYPE_VIDEO.slice(0, -1)) === 0;
            } else {
              // Proper mime type case: directly compare with file mime type
              isAllowed = fileType === allowedMimeType;
            }
          } else if (allowedMimeType.match(FILE_EXTENSION_REGEXP)) {
            // File extension case
            var allowedMimeTypes = MIME_TYPES[allowedMimeType]; // Depending on OS and browser, a file extension can map to different mime types
            // e.g .csv maps to "text/csv" on Mac OS and to "application/vnd.ms-excel" on Windows

            if (Array.isArray(allowedMimeTypes)) {
              isAllowed = allowedMimeTypes.some(function (mimeType) {
                return fileType === mimeType;
              });
            } else {
              isAllowed = fileType === MIME_TYPES[allowedMimeType];
            }
          } else if (allowedMimeType.match(SHORTCUT_REGEXP)) {
            // "Shortcut" case: only compare first part of the file mime type with the shortcut
            isAllowed = fileType.split('/')[0] === allowedMimeType;
          } // Break the loop if file mime type is allowed


          return isAllowed;
        });
      }
      /**
       Returns {@link FileUploadItem} response types.
        @return {FileUploadItemResponseTypeEnum}
       */

    }, {
      key: "file",
      get: function get() {
        return this._originalFile;
      }
      /**
       Array of additional parameters as key:value to be uploaded with the file.
       A parameter must contain a <code>name</code> key:value and optionally a <code>value</code> key:value.
        @name parameters
       @type {Array.<Object>}
       @default []
       */

    }, {
      key: "parameters",
      get: function get() {
        return this._parameters || [];
      },
      set: function set(value) {
        var isValid = Array.isArray(value) && value.every(function (el) {
          return el && el.name;
        });

        if (isValid) {
          this._parameters = value;
        }
      }
      /**
       The item xhr <code>withCredentials</code> property.
        @name withCredentials
       @type {Boolean}
       @default false
       */

    }, {
      key: "withCredentials",
      get: function get() {
        return this._withCredentials || false;
      },
      set: function set(value) {
        this._withCredentials = transform.boolean(value);
      }
      /**
       The item xhr <code>timeout</code> property.
        @name timeout
       @type {Number}
       @default 0
       */

    }, {
      key: "timeout",
      get: function get() {
        return this._timeout || 0;
      },
      set: function set(value) {
        var timeout = transform.number(value);

        if (timeout !== null) {
          this._timeout = timeout;

          if (this._xhr) {
            this._xhr.timeout = timeout;
          }
        }
      }
      /**
       The item xhr <code>responseType</code> property. See {@link FileUploadItemResponseTypeEnum}.
        @name responseType
       @default {FileUploadItemResponseTypeEnum.TEXT}
       @type {String}
       */

    }, {
      key: "responseType",
      get: function get() {
        return this._responseType || responseType.TEXT;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        this._responseType = validate.enumeration(responseType)(value) && value || responseType.TEXT;

        if (this._xhr) {
          this._xhr.responseType = value;
        }
      }
      /**
       The item xhr <code>readyState</code> property.
        @name readyState
       @readonly
       @default 0
       @type {Number}
       */

    }, {
      key: "readyState",
      get: function get() {
        return this._xhr ? this._xhr.readyState : this._readyState || 0;
      }
      /**
       The item xhr <code>responseType</code> property. Depends on {@link Coral.FileUpload.Item#responseType}.
        @name response
       @readonly
       @default ""
       @type {String|ArrayBuffer|Blob|Document}
       */

    }, {
      key: "response",
      get: function get() {
        return this._xhr ? this._xhr.response : this._response || '';
      }
      /**
       The item xhr <code>responseText</code> property.
        @name responseText
       @readonly
       @default ""
       @type {String}
       */

    }, {
      key: "responseText",
      get: function get() {
        return this._xhr ? this._xhr.responseText : this._responseText || '';
      }
      /**
       The item xhr <code>responseXML</code> property.
        @name responseXML
       @readonly
       @default null
       @type {HTMLElement}
       */

    }, {
      key: "responseXML",
      get: function get() {
        return this._xhr ? this._xhr.responseXML : this._responseXML || null;
      }
      /**
       The item xhr <code>status</code> property.
        @name status
       @readonly
       @default 0
       @type {Number}
       */

    }, {
      key: "status",
      get: function get() {
        return this._xhr ? this._xhr.status : this._status || 0;
      }
      /**
       The item xhr <code>statusText</code> property.
        @name statusText
       @readonly
       @default ""
       @type {String}
       */

    }, {
      key: "statusText",
      get: function get() {
        return this._xhr ? this._xhr.statusText : this._statusText || '';
      }
    }], [{
      key: "responseType",
      get: function get() {
        return responseType;
      }
    }]);

    return FileUploadItem;
  }();

  var template$H = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["input"] = document.createElement("input");
    el0.id = data_0["commons"]["getUID"]();
    el0.setAttribute("handle", "input");
    el0.className += " _coral-FileUpload-input is-unselectable";
    el0.setAttribute("tabindex", "-1");
    el0.setAttribute("name", "");
    el0.setAttribute("type", "file");
    el0.setAttribute("accept", "");
    frag.appendChild(el0);
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    return frag;
  };

  var CLASSNAME$$ = '_coral-FileUpload';
  var XHR_EVENT_NAMES = ['loadstart', 'progress', 'load', 'error', 'loadend', 'readystatechange', 'abort', 'timeout'];
  /**
   Enumeration for {@link FileUpload} HTTP methods that can be used to upload files.

   @typedef {Object} FileUploadMethodEnum

   @property {String} POST
   Send a POST request. Used when creating a resource.
   @property {String} PUT
   Send a PUT request. Used when replacing a resource.
   @property {String} PATCH
   Send a PATCH request. Used when partially updating a resource.
   */

  var method = {
    POST: 'POST',
    PUT: 'PUT',
    PATCH: 'PATCH'
  };
  /**
   @class Coral.FileUpload
   @classdesc A FileUpload component that manages the upload process of multiple files. Child elements of FileUpload can
   be given special attributes to enable functionality:
   - <code>[coral-fileupload-select]</code>. Click to choose file(s), replacing existing files.
   - <code>[coral-fileupload-dropzone]</code>. Drag and drop files to choose file(s), replacing existing files.
   - <code>[coral-fileupload-clear]</code>. Click to remove all files from the queue.
   - <code>[coral-fileupload-submit]</code>. Click to start uploading.
   - <code>[coral-fileupload-abort]</code>. Click to abort all uploads.
   - <code>[coral-fileupload-abortfile="filename.txt"]</code>. Click to abort a specific file, leaving it in the queue.
   - <code>[coral-fileupload-removefile="filename.txt"]</code>. Click to remove a specific file from the queue.
   - <code>[coral-fileupload-uploadfile="filename.txt"]</code>. Click to start uploading a specific file.

   @htmltag coral-fileupload
   @extends {HTMLElement}
   @extends {BaseComponent}
   @extends {BaseFormField}
   */

  var FileUpload = Decorator( /*#__PURE__*/function (_BaseFormField) {
    _inherits(_class, _BaseFormField);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this); // Events

      _this._delegateEvents(commons.extend(_this._events, {
        // Clickable hooks
        'click [coral-fileupload-submit]': '_onSubmitButtonClick',
        'click [coral-fileupload-clear]': 'clear',
        'click [coral-fileupload-select]': '_showFileDialog',
        'click [coral-fileupload-abort]': 'abort',
        'click [coral-fileupload-abortfile]': '_onAbortFileClick',
        'click [coral-fileupload-removefile]': '_onRemoveFileClick',
        'click [coral-fileupload-uploadfile]': '_onUploadFileClick',
        // Drag & Drop zones
        'dragenter [coral-fileupload-dropzone]': '_onDragAndDrop',
        'dragover [coral-fileupload-dropzone]': '_onDragAndDrop',
        'dragleave [handle="input"]': '_onDragAndDrop',
        'drop [handle="input"]': '_onDragAndDrop',
        // Accessibility
        'capture:focus [coral-fileupload-select]': '_onButtonFocusIn',
        'capture:focus [handle="input"]': '_onInputFocusIn',
        'capture:blur [handle="input"]': '_onInputFocusOut'
      })); // Prepare templates


      _this._elements = {};
      template$H.call(_this._elements, {
        commons: commons
      }); // Pre-define labellable element

      _this._labellableElement = _this._elements.input; // Used for items

      _this._uploadQueue = []; // this should refer to the fileupload

      _this._doAddDragClass = _this._doAddDragClass.bind(_assertThisInitialized(_this));
      _this._doRemoveDragClass = _this._doRemoveDragClass.bind(_assertThisInitialized(_this));
      _this._positionInputOnDropZone = _this._positionInputOnDropZone.bind(_assertThisInitialized(_this)); // Reposition the input under the specified dropzone

      _this._observer = new MutationObserver(_this._positionInputOnDropZone);

      _this._observer.observe(_assertThisInitialized(_this), {
        childList: true,
        attributes: true,
        attributeFilter: ['coral-fileupload-dropzone'],
        subtree: true
      });

      return _this;
    }
    /**
     Name used to submit the data in a form.
     @type {String}
     @default ""
     @htmlattribute name
     @htmlattributereflected
     */


    _createClass(_class, [{
      key: "_onButtonFocusIn",

      /** @private */
      value: function _onButtonFocusIn(event) {
        // Get the input
        var input = this._elements.input; // Get the button

        var button = event.matchedTarget; // Move the input to after the button
        // This lets the next focused item be the correct one according to tab order

        button.parentNode.insertBefore(input, button.nextElementSibling);

        if (event.relatedTarget !== input) {
          // Make sure the input gets focused on FF
          window.setTimeout(function () {
            input.focus();
          }, 100);
        }
      }
      /** @private */

    }, {
      key: "_onInputFocusIn",
      value: function _onInputFocusIn() {
        // Get the input
        var input = event.matchedTarget;
        var button = this.querySelector('[coral-fileupload-select]');

        if (button) {
          // Remove from the tab order so shift+tab works
          button.tabIndex = -1; // So shifting focus backwards with screen reader doesn't create a focus trap

          button.setAttribute('aria-hidden', true); // Mark the button as focused

          button.classList.add('is-focused');
          window.requestAnimationFrame(function () {
            if (input.classList.contains('focus-ring')) {
              button.classList.add('focus-ring');
            }
          });
        }
      }
      /** @private */

    }, {
      key: "_onInputFocusOut",
      value: function _onInputFocusOut() {
        // Unmark all the focused buttons
        var button = this.querySelector('[coral-fileupload-select].is-focused');
        button.classList.remove('is-focused');
        button.classList.remove('focus-ring'); // Wait a frame so that shifting focus backwards with screen reader doesn't create a focus trap

        window.requestAnimationFrame(function () {
          button.tabIndex = 0; // @a11y: aria-hidden is removed to prevent focus trap when navigating backwards using a screen reader's
          // virtual cursor

          button.removeAttribute('aria-hidden');
        });
      }
      /** @private */

    }, {
      key: "_onAbortFileClick",
      value: function _onAbortFileClick(event) {
        if (!this.async) {
          throw new Error('Coral.FileUpload does not support aborting file(s) upload on synchronous mode.');
        } // Get file to abort


        var fileName = event.target.getAttribute('coral-fileupload-abortfile');

        if (fileName) {
          this._abortFile(fileName);
        }
      }
      /** @private */

    }, {
      key: "_onRemoveFileClick",
      value: function _onRemoveFileClick(event) {
        if (!this.async) {
          throw new Error('Coral.FileUpload does not support removing a file from the queue on synchronous mode.');
        } else {
          // Get file to remove
          var fileName = event.target.getAttribute('coral-fileupload-removefile');

          if (fileName) {
            this._clearFile(fileName);
          }
        }
      }
      /** @private */

    }, {
      key: "_onUploadFileClick",
      value: function _onUploadFileClick(event) {
        if (!this.async) {
          throw new Error('Coral.FileUpload does not support uploading a file from the queue on synchronous mode.');
        } // Get file to upload


        var fileName = event.target.getAttribute('coral-fileupload-uploadfile');

        if (fileName) {
          this.upload(fileName);
        }
      }
      /** @private */

    }, {
      key: "_onDragAndDrop",
      value: function _onDragAndDrop(event) {
        // Set dragging classes
        if (event.type === 'dragenter' || event.type === 'dragover') {
          this._addDragClass();
        } else if (event.type === 'dragleave' || event.type === 'drop') {
          this._removeDragClass();
        }

        this.trigger("coral-fileupload:".concat(event.type));
      }
      /** @private */

    }, {
      key: "_addDragClass",
      value: function _addDragClass() {
        window.clearTimeout(this._removeClassTimeout);
        this._removeClassTimeout = window.setTimeout(this._doAddDragClass, 10);
      }
      /** @private */

    }, {
      key: "_doAddDragClass",
      value: function _doAddDragClass() {
        this.classList.add('is-dragging');
        var dropZone = this.querySelector('[coral-fileupload-dropzone]');

        if (dropZone) {
          dropZone.classList.add('is-dragging');
        } // Put the input on top to enable file drop


        this._elements.input.classList.remove('is-unselectable');
      }
      /** @private */

    }, {
      key: "_removeDragClass",
      value: function _removeDragClass() {
        window.clearTimeout(this._removeClassTimeout);
        this._removeClassTimeout = window.setTimeout(this._doRemoveDragClass, 10);
      }
      /** @private */

    }, {
      key: "_doRemoveDragClass",
      value: function _doRemoveDragClass() {
        this.classList.remove('is-dragging');
        var dropZone = this.querySelector('[coral-fileupload-dropzone]');

        if (dropZone) {
          dropZone.classList.remove('is-dragging');
        } // Disable user interaction with the input


        this._elements.input.classList.add('is-unselectable');
      }
      /**
       Handles clicks to submit buttons
        @private
       */

    }, {
      key: "_onSubmitButtonClick",
      value: function _onSubmitButtonClick(event) {
        var target = event.matchedTarget; // Override or reset the action/method given the button's configuration

        this._buttonAction = target.getAttribute('formaction'); // Make sure the method provided by the button is valid

        var buttonMethod = transform.string(target.getAttribute('formmethod')).toUpperCase();
        this._buttonMethod = validate.enumeration(method)(buttonMethod) && buttonMethod || null; // Start the file upload

        this.upload();
      }
      /**
       Handles changes to the input element.
        @private
       */

    }, {
      key: "_onInputChange",
      value: function _onInputChange(event) {
        var _this2 = this;

        // Stop the current event
        event.stopPropagation();

        if (this.disabled) {
          return;
        }

        var files = [];
        var items = []; // Retrieve files for select event

        if (event.target.files && event.target.files.length) {
          this._clearQueue();

          files = event.target.files; // Verify if multiple file upload is allowed

          if (!this.multiple) {
            files = [files[0]];
          }
        } // Retrieve files for drop event
        else if (event.dataTransfer && event.dataTransfer.files && event.dataTransfer.files.length) {
            this._clearQueue();

            files = event.dataTransfer.files; // Verify if multiple file upload is allowed

            if (!this.multiple) {
              files = [files[0]];
            }
          } else {
            return;
          } // Initialize items


        for (var i = 0; i < files.length; i++) {
          items.push(new FileUploadItem(files[i]));
        } // Verify if file is allowed to be uploaded and trigger events accordingly


        items.forEach(function (item) {
          // If file is not found in uploadQueue using filename
          if (!_this2._getQueueItemByFilename(item.file.name)) {
            // Check file size
            if (_this2.sizeLimit && item.file.size > _this2.sizeLimit) {
              _this2.trigger('coral-fileupload:filesizeexceeded', {
                item: item
              });
            } // Check mime type
            else if (_this2.accept && !item._isMimeTypeAllowed(_this2.accept)) {
                _this2.trigger('coral-fileupload:filemimetyperejected', {
                  item: item
                });
              } else {
                // Add item to queue
                _this2._uploadQueue.push(item);

                _this2.trigger('coral-fileupload:fileadded', {
                  item: item
                });
              }
          }
        });

        if (this.autoStart) {
          this.upload();
        } // Explicitly re-emit the change event


        if (this._triggerChangeEvent) {
          this.trigger('change');
        } // Clear file input once files are added to the queue to make sure next file selection will trigger a change event


        if (this.async) {
          this._clearFileInputValue();
        }
      }
      /**
       Sets the disabled/readonly state of elements with the associated special attributes
        @private
       */

    }, {
      key: "_setElementState",
      value: function _setElementState() {
        var _this3 = this;

        Array.prototype.forEach.call(this.querySelectorAll('[coral-fileupload-select],' + '[coral-fileupload-dropzone],' + '[coral-fileupload-submit],' + '[coral-fileupload-clear],' + '[coral-fileupload-abort],' + '[coral-fileupload-abortfile],' + '[coral-fileupload-removefile],' + '[coral-fileupload-uploadfile]'), function (item) {
          item.classList.toggle('is-invalid', _this3.invalid);
          item.classList.toggle('is-disabled', _this3.disabled);
          item.classList.toggle('is-required', _this3.required);
          item.classList.toggle('is-readOnly', _this3.readOnly);
          item[_this3.disabled || _this3.readOnly ? 'setAttribute' : 'removeAttribute']('disabled', '');
        });
      }
      /** @private */

    }, {
      key: "_clearQueue",
      value: function _clearQueue() {
        var _this4 = this;

        this._uploadQueue.slice().forEach(function (item) {
          _this4._clearFile(item.file.name);
        });
      }
      /**
       Clear file selection on the file input
        @private
       */

    }, {
      key: "_clearFileInputValue",
      value: function _clearFileInputValue() {
        this._elements.input.value = '';
      }
      /**
       Remove a file from the upload queue.
        @param {String} filename
       The filename of the file to remove.
        @private
       */

    }, {
      key: "_clearFile",
      value: function _clearFile(filename) {
        var item = this._getQueueItemByFilename(filename);

        if (item) {
          // Abort file upload
          this._abortFile(filename); // Remove file from queue


          this._uploadQueue.splice(this._getQueueIndex(filename), 1);

          this.trigger('coral-fileupload:fileremoved', {
            item: item
          });
        }
      }
      /**
       Uploads a file in the queue. If an array is provided as the first argument, it is used as the parameters.
        @param filename {String}
       The name of the file to upload.
        @private
       */

    }, {
      key: "_uploadFile",
      value: function _uploadFile(filename) {
        var item = this._getQueueItemByFilename(filename);

        if (item) {
          this._abortFile(filename);

          this._ajaxUpload(item);
        }
      }
      /** @private */

    }, {
      key: "_showFileDialog",
      value: function _showFileDialog() {
        // Show the dialog
        // This ONLY works when the call stack traces back to another click event!
        this._elements.input.click();
      }
      /**
       Abort specific file upload.
        @param {String} filename
       The filename identifies the file to abort.
        @private
       */

    }, {
      key: "_abortFile",
      value: function _abortFile(filename) {
        var item = this._getQueueItemByFilename(filename);

        if (item && item._xhr) {
          item._xhr.abort();

          item._xhr = null;
        }
      }
      /**
       Handles the ajax upload.
        @private
       */

    }, {
      key: "_ajaxUpload",
      value: function _ajaxUpload(item) {
        var _this5 = this;

        // Use the action/method provided by the last button click, if provided
        var action = this._buttonAction || this.action;
        var requestMethod = this._buttonMethod ? this._buttonMethod.toUpperCase() : this.method; // We merge the global parameters with the specific file parameters and send them all together

        var parameters = this.parameters.concat(item.parameters);
        var formData = new FormData();
        parameters.forEach(function (additionalParameter) {
          formData.append(additionalParameter.name, additionalParameter.value);
        });
        formData.append('_charset_', 'utf-8');
        formData.append(this.name, item._originalFile); // Store the XHR on the item itself

        item._xhr = new XMLHttpRequest(); // Opening before being able to set response type to avoid IE11 InvalidStateError

        item._xhr.open(requestMethod, action); // Reflect specific xhr properties


        item._xhr.timeout = item.timeout;
        item._xhr.responseType = item.responseType;
        item._xhr.withCredentials = item.withCredentials;
        XHR_EVENT_NAMES.forEach(function (name) {
          // Progress event is the only event among other ProgressEvents that can trigger multiple times.
          // Hence it's the only one that gives away usable progress information.
          var isProgressEvent = name === 'progress';
          (isProgressEvent ? item._xhr.upload : item._xhr).addEventListener(name, function (event) {
            var detail = {
              item: item,
              action: action,
              method: requestMethod
            };

            if (isProgressEvent) {
              detail.lengthComputable = event.lengthComputable;
              detail.loaded = event.loaded;
              detail.total = event.total;
            }

            _this5.trigger("coral-fileupload:".concat(name), detail);
          });
        });

        item._xhr.send(formData);
      }
      /** @private */

    }, {
      key: "_getLabellableElement",
      value: function _getLabellableElement() {
        return this;
      }
      /** @private */

    }, {
      key: "_getQueueItemByFilename",
      value: function _getQueueItemByFilename(filename) {
        return this._getQueueItem(this._getQueueIndex(filename));
      }
      /** @private */

    }, {
      key: "_getQueueItem",
      value: function _getQueueItem(index) {
        return index > -1 ? this._uploadQueue[index] : null;
      }
      /** @private */

    }, {
      key: "_getQueueIndex",
      value: function _getQueueIndex(filename) {
        var index = -1;

        this._uploadQueue.some(function (item, i) {
          if (item.file.name === filename) {
            index = i;
            return true;
          }

          return false;
        });

        return index;
      }
      /** @private */

    }, {
      key: "_getTargetChangeInput",
      value: function _getTargetChangeInput() {
        return this._elements.input;
      }
      /** @ignore */

    }, {
      key: "_positionInputOnDropZone",
      value: function _positionInputOnDropZone() {
        var input = this._elements.input;
        var dropZone = this.querySelector('[coral-fileupload-dropzone]');

        if (dropZone) {
          var size = dropZone.getBoundingClientRect();
          input.style.top = "".concat(parseInt(dropZone.offsetTop, 10), "px");
          input.style.left = "".concat(parseInt(dropZone.offsetLeft, 10), "px");
          input.style.width = "".concat(parseInt(size.width, 10), "px");
          input.style.height = "".concat(parseInt(size.height, 10), "px");
        } else {
          input.style.width = '0';
          input.style.height = '0';
        }
      }
      /**
       Uploads the given filename, or all the files into the queue. It accepts extra parameters that are sent with the
       file.
        @param {String} [filename]
       The name of the file to upload.
       */

    }, {
      key: "upload",
      value: function upload(filename) {
        var _this6 = this;

        if (!this.async) {
          if (typeof filename === 'string') {
            throw new Error('Coral.FileUpload does not support uploading a file from the queue on synchronous mode.');
          }

          var form = this.closest('form');

          if (!form) {
            form = document.createElement('form');
            form.method = this.method.toLowerCase();
            form.enctype = 'multipart/form-data';
            form.action = this.action;
            form.hidden = true;
            form.appendChild(this._elements.input);
            Array.prototype.forEach.call(this.querySelectorAll('input[type="hidden"]'), function (hiddenInput) {
              form.appendChild(hiddenInput);
            }); // Make sure the form is connected before submission

            this.appendChild(form);
          }

          var input = document.createElement('input');
          input.type = 'hidden';
          input.name = '_charset_';
          input.value = 'utf-8';
          form.submit();
        } else if (typeof filename === 'string') {
          this._uploadFile(filename);
        } else {
          this._uploadQueue.forEach(function (item) {
            _this6._abortFile(item.file.name);

            _this6._ajaxUpload(item);
          });
        }
      }
      /**
       Remove a file or all files from the upload queue.
        @param {String} [filename]
       The filename of the file to remove. If a filename is not provided, all files will be removed.
       */

    }, {
      key: "clear",
      value: function clear(filename) {
        if (!this.async) {
          if (typeof filename === 'string') {
            throw new Error('Coral.FileUpload does not support removing a file from the queue on synchronous mode.');
          }

          this._clearQueue();

          this._clearFileInputValue();
        } else if (typeof filename === 'string') {
          this._clearFile(filename);
        } else {
          this._clearQueue();
        }
      }
      /**
       Abort upload of a given file or all files in the queue.
        @param {String} [filename]
       The filename of the file to abort. If a filename is not provided, all files will be aborted.
       */

    }, {
      key: "abort",
      value: function abort(filename) {
        var _this7 = this;

        if (!this.async) {
          throw new Error('Coral.FileUpload does not support aborting file(s) upload on synchronous mode.');
        }

        if (typeof filename === 'string') {
          // Abort a single file
          this._abortFile(filename);
        } else {
          // Abort all files
          this._uploadQueue.forEach(function (item) {
            _this7._abortFile(item.file.name);
          });
        }
      }
    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        var _this8 = this;

        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$$);
        var button = this.querySelector('[coral-fileupload-select]');

        if (button) {
          button.id = button.id || commons.getUID();
        } // If no labelledby is specified, ensure input is at labelledby the select button


        this.labelledBy = this.labelledBy; // Fetch additional parameters if any

        var parameters = [];
        Array.prototype.forEach.call(this.querySelectorAll('input[type="hidden"]'), function (input) {
          parameters.push({
            name: input.name,
            value: input.value
          });
        });
        this.parameters = parameters; // Remove the input if it's already there
        // A fresh input is preferred to value = '' as it may not work in all browsers

        var inputElement = this.querySelector('[handle="input"]');

        if (inputElement) {
          inputElement.parentNode.removeChild(inputElement);
        } // Add the input to the component


        this.appendChild(this._elements.input); // IE11 requires one more frame or the resize listener <object> will appear as an overlaying white box

        window.requestAnimationFrame(function () {
          // Handles the repositioning of the input to allow dropping files
          commons.addResizeListener(_this8, _this8._positionInputOnDropZone);
        });
      }
    }, {
      key: "name",
      get: function get() {
        return this._elements.input.name;
      },
      set: function set(value) {
        this._reflectAttribute('name', value);

        this._elements.input.name = value;
      }
      /**
       This field's current value.
       @type {String}
       @default ""
       @htmlattribute value
       */

    }, {
      key: "value",
      get: function get() {
        var item = this._uploadQueue ? this._getQueueItem(0) : null; // The first selected filename, or the empty string if no files are selected.

        return item ? "C:\\fakepath\\".concat(item.file.name) : '';
      },
      set: function set(value) {
        if (value === '' || value === null) {
          this._clearQueue();

          this._clearFileInputValue();
        } else {
          // Throws exception if value is different than an empty string or null
          throw new Error('Coral.FileUpload accepts a filename, which may only be programmatically set to empty string.');
        }
      }
      /**
       Whether this field is disabled or not.
       @type {Boolean}
       @default false
       @htmlattribute disabled
       @htmlattributereflected
       */

    }, {
      key: "disabled",
      get: function get() {
        return this._elements.input.disabled;
      },
      set: function set(value) {
        this._elements.input.disabled = transform.booleanAttr(value);

        this._reflectAttribute('disabled', this.disabled);

        this.classList.toggle('is-disabled', this.disabled);

        this._setElementState();
      }
      /**
       Inherited from {@link BaseFormField#invalid}.
       */

    }, {
      key: "invalid",
      get: function get() {
        return _get(_getPrototypeOf(_class.prototype), "invalid", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(_class.prototype), "invalid", value, this, true);

        this._elements.input.setAttribute('aria-invalid', this.invalid);

        this._setElementState();
      }
      /**
       Whether this field is required or not.
       @type {Boolean}
       @default false
       @htmlattribute required
       @htmlattributereflected
       */

    }, {
      key: "required",
      get: function get() {
        return this._elements.input.required;
      },
      set: function set(value) {
        this._elements.input.required = transform.booleanAttr(value);

        this._reflectAttribute('required', this.required);

        this.classList.toggle('is-required', this.required);

        this._setElementState();
      }
      /**
       Whether this field is readOnly or not. Indicating that the user cannot modify the value of the control.
       @type {Boolean}
       @default false
       @htmlattribute readonly
       @htmlattributereflected
       */

    }, {
      key: "readOnly",
      get: function get() {
        return this._readOnly || false;
      },
      set: function set(value) {
        this._readOnly = transform.booleanAttr(value);

        this._reflectAttribute('readonly', this._readOnly);

        this._setElementState();
      }
      /**
       The names of the currently selected files.
       When {@link Coral.FileUpload#multiple} is <code>false</code>, this will be an array of length 1.
        @type {Array.<String>}
       */

    }, {
      key: "values",
      get: function get() {
        var values = this._uploadQueue.map(function (item) {
          return "C:\\fakepath\\".concat(item.file.name);
        });

        if (values.length && !this.multiple) {
          values = [values[0]];
        }

        return values;
      },
      set: function set(values) {
        if (Array.isArray(values)) {
          if (values.length) {
            this.value = values[0];
          } else {
            this.value = '';
          }
        }
      }
      /**
       Inherited from {@link BaseFormField#labelledBy}.
       */

    }, {
      key: "labelledBy",
      get: function get() {
        return _get(_getPrototypeOf(_class.prototype), "labelledBy", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(_class.prototype), "labelledBy", value, this, true); // The specified labelledBy property.


        var labelledBy = this.labelledBy; // An array of element ids to label control, the last being the select button element id.

        var ids = [];
        var button = this.querySelector('[coral-fileupload-select]');

        if (button) {
          ids.push(button.id);
        } // If a labelledBy property exists,


        if (labelledBy) {
          // prepend the labelledBy value to the ids array
          ids.unshift(labelledBy);
        } // Set aria-labelledby attribute on the labellable element joining ids array into space-delimited list of ids.


        this._elements.input.setAttribute('aria-labelledby', ids.join(' '));

        if (labelledBy) {
          // Set label for attribute
          var labelElement = document.getElementById(labelledBy);

          if (labelElement && labelElement.tagName === 'LABEL') {
            labelElement.setAttribute('for', this._elements.input.id);
            this._labelElement = labelElement;
          }
        } // Remove label for attribute
        else if (this._labelElement) {
            this._labelElement.removeAttribute('for');
          }
      }
      /**
       Array of additional parameters as key:value to send in addition of files.
       A parameter must contain a <code>name</code> key:value and optionally a <code>value</code> key:value.
        @type {Array.<Object>}
       @default []
       */

    }, {
      key: "parameters",
      get: function get() {
        return this._parameters || [];
      },
      set: function set(values) {
        var _this9 = this;

        // Verify that every item has a name
        var isValid = Array.isArray(values) && values.every(function (el) {
          return el && el.name;
        });

        if (isValid) {
          this._parameters = values;

          if (!this.async) {
            Array.prototype.forEach.call(this.querySelectorAll('input[type="hidden"]'), function (input) {
              input.parentNode.removeChild(input);
            }); // Add extra parameters

            this.parameters.forEach(function (param) {
              var input = document.createElement('input');
              input.type = 'hidden';
              input.name = param.name;
              input.value = param.value;

              _this9.appendChild(input);
            });
          }
        }
      }
      /**
       Whether files should be uploaded asynchronously via XHR or synchronously e.g. within a
       <code>&lt;form&gt;</code> tag. One option excludes the other. Setting a new <code>async</code> value removes all
       files from the queue.
        @type {Boolean}
       @default false
       @htmlattribute async
       @htmlattributereflected
       */

    }, {
      key: "async",
      get: function get() {
        return this._async || false;
      },
      set: function set(value) {
        this._async = transform.booleanAttr(value);

        this._reflectAttribute('async', this._async); // Sync extra parameters in case of form submission


        if (!this._async) {
          this.parameters = this.parameters;
        } // Clear file selection


        if (this._uploadQueue) {
          this._clearQueue();

          this._clearFileInputValue();
        }
      }
      /**
       The URL where the upload request should be sent. When used within a <code>&lt;form&gt;</code> tag to upload
       synchronously, the action of the form is used. If an element is clicked that has a
       <code>[coral-fileupload-submit]</code> attribute as well as a <code>[formaction]</code> attribute, the action of
       the clicked element will be used. Set this property before calling {@link Coral.FileUpload#upload} to reset the
       action set by a click.
        @type {String}
       @default ""
       @htmlattribute action
       @htmlattributereflected
       */

    }, {
      key: "action",
      get: function get() {
        return this._action || '';
      },
      set: function set(value) {
        this._action = transform.string(value);

        this._reflectAttribute('action', this._action); // Reset button action as action was set explicitly


        this._buttonAction = null;
      }
      /**
       The HTTP method to use when uploading files asynchronously. When used within a <code>&lt;form&gt;</code> tag to
       upload synchronously, the method of the form is used. If an element is clicked that has a
       <code>[coral-fileupload-submit]</code> attribute as well as a <code>[formmethod]</code> attribute, the method of
       the clicked element will be used. Set this property before calling {@link FileUpload#upload} to reset the
       method set by a click.
       See {@link FileUploadMethodEnum}.
        @type {String}
       @default FileUploadMethodEnum.POST
       @htmlattribute method
       @htmlattributereflected
       */

    }, {
      key: "method",
      get: function get() {
        return this._method || method.POST;
      },
      set: function set(value) {
        value = transform.string(value).toUpperCase();
        this._method = validate.enumeration(method)(value) && value || method.POST;

        this._reflectAttribute('method', this._method); // Reset button method as method was set explcitly


        this._buttonMethod = null;
      }
      /**
       Whether more than one file can be chosen at the same time to upload.
        @type {Boolean}
       @default false
       @htmlattribute multiple
       @htmlattributereflected
       */

    }, {
      key: "multiple",
      get: function get() {
        return this._elements.input.multiple;
      },
      set: function set(value) {
        this._elements.input.multiple = transform.booleanAttr(value);

        this._reflectAttribute('multiple', this.multiple);
      }
      /**
       File size limit in bytes for one file. The value of 0 indicates unlimited, which is also the default.
        @type {Number}
       @htmlattribute sizelimit
       @htmlattributereflected
       @default 0
       */

    }, {
      key: "sizeLimit",
      get: function get() {
        return this._sizeLimit || 0;
      },
      set: function set(value) {
        this._sizeLimit = transform.number(value);

        this._reflectAttribute('sizelimit', this._sizeLimit);
      }
      /**
       MIME types allowed for uploading (proper MIME types, wildcard '*' and file extensions are supported). To specify
       more than one value, separate the values with a comma (e.g.
       <code>&lt;input accept="audio/*,video/*,image/*" /&gt;</code>.
        @type {String}
       @default ""
       @htmlattribute accept
       @htmlattributereflected
       */

    }, {
      key: "accept",
      get: function get() {
        return this._elements.input.accept;
      },
      set: function set(value) {
        this._elements.input.accept = value;

        this._reflectAttribute('accept', this.accept);
      }
      /**
       Whether the upload should start immediately after file selection.
        @type {Boolean}
       @default false
       @htmlattribute autostart
       @htmlattributereflected
       */

    }, {
      key: "autoStart",
      get: function get() {
        return this._autoStart || false;
      },
      set: function set(value) {
        this._autoStart = transform.booleanAttr(value);

        this._reflectAttribute('autostart', this._autoStart);
      }
      /**
       Files to be uploaded.
        @readonly
       @default []
       @type {Array.<Object>}
       */

    }, {
      key: "uploadQueue",
      get: function get() {
        return this._uploadQueue;
      }
    }], [{
      key: "_attributePropertyMap",
      get: function get() {
        return commons.extend(_get(_getPrototypeOf(_class), "_attributePropertyMap", this), {
          sizelimit: 'sizeLimit',
          autostart: 'autoStart'
        });
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['async', 'action', 'method', 'multiple', 'sizelimit', 'accept', 'autostart']);
      }
    }]);

    return _class;
  }(BaseFormField(BaseComponent(HTMLElement))));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons._define('coral-fileupload', FileUpload);

  FileUpload.Item = FileUploadItem;

  var template$I = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["quickactions"] = document.createElement("div");
    el0.setAttribute("handle", "quickactions");
    el0.className += " _coral-Masonry-item-quickActions";
    var el1 = document.createTextNode("\n  ");
    el0.appendChild(el1);
    var el2 = this["check"] = document.createElement("coral-checkbox");
    el2.setAttribute("handle", "check");
    el0.appendChild(el2);
    var el3 = document.createTextNode("\n");
    el0.appendChild(el3);
    frag.appendChild(el0);
    var el4 = document.createTextNode("\n");
    frag.appendChild(el4);
    return frag;
  };

  /**
   * Copyright 2021 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   * @class Coral.Masonry.Item.AccessibilityState
   * @classdesc The Masonry Item Accessibility State
   * @htmltag coral-masonry-item-accessibilitystate
   * @extends HTMLElement
  */
  var MasonryItemAccessibilityState = (function () {
    var element = document.createElement('coral-masonry-item-accessibilitystate');
    element.className = 'u-coral-screenReaderOnly';
    return element;
  });

  var SCOPE_SELECTOR$1 = ':scope > ';
  /**
   * Messenger will used to pass the messages from child component to its parent. Currently we are relying on
   * events to do the job. When a large DOM is connected, these events as a bulk leads to delays.
   * With the use of messenger we will directly call the parent method provided in the observed messages list.
   * The current implmentation only supports one to many mapping i.e. one parent and many children and any
   * in child property will result in execution of only one parent method. This should be used purely for
   * coral internal events and not any DOM based or public events.
   *
   * Limitations :
   * - This doesnot support the case where any change in child property, needs to be notified
   *   to two or more parents. This is achievable, but not currently supported.
   * - Use this to post message only coral internal events.
   * - Do not use for DOM events or public events.
   * @private
   */

  var Messenger = /*#__PURE__*/function () {
    /** @ignore */
    function Messenger(element) {
      _classCallCheck(this, Messenger);

      this._element = element;
      this._connected = false;

      this._clearQueue();

      this._clearListeners();
    }
    /**
     * checks whether Messenger is connected or not.
     * @returns {Boolean} true if connected
     * @private
     */


    _createClass(Messenger, [{
      key: "_addMessageToQueue",

      /**
       * add a message to the queue only if messenger is not connected
       * message will be added only if element is not connected.
       * @private
       */
      value: function _addMessageToQueue(message, detail) {
        if (!this.isConnected) {
          this._queue.push({
            message: message,
            detail: detail
          });
        }
      }
      /**
       * executes the stored queue messages.
       * It will be executed when element is connected.
       * @private
       */

    }, {
      key: "_executeQueue",
      value: function _executeQueue() {
        var _this = this;

        this._queue.forEach(function (options) {
          _this._postMessage(options.message, options.detail);
        });

        this._clearQueue();
      }
      /**
       * empty the stored queue message
       * @private
       */

    }, {
      key: "_clearQueue",
      value: function _clearQueue() {
        this._queue = [];
      }
      /**
       * clears the listeners
       * @private
       */

    }, {
      key: "_clearListeners",
      value: function _clearListeners() {
        this._listeners = [];
      }
      /**
       * element should call this method when they are connected in DOM.
       * its the responsibility of the element to call this hook
       * @triggers `${element.tagName.toLowerCase()}:_messengerconnected`
       * @private
       */

    }, {
      key: "connect",
      value: function connect() {
        if (!this.isConnected) {
          var element = this._element;
          this._connected = true;
          element.trigger("".concat(element.tagName.toLowerCase(), ":_messengerconnected"), {
            handler: this.registerListener.bind(this)
          }); // post all stored messages

          this._executeQueue();
        }
      }
      /**
       * add the listener to messenger
       * this handler will be passed when messengerconnect event is trigger
       * the handler needs to be executed by listeners.
       * @private
       */

    }, {
      key: "registerListener",
      value: function registerListener(listener) {
        if (listener) {
          this._listeners.push(listener);
        }
      }
      /**
       * post the provided message to all listener.
       * @param {String} message which should be posted
       * @param {Object} additional detail which needs to be posted.
       * @private
       */

    }, {
      key: "_postMessage",
      value: function _postMessage(message, detail) {
        var element = this._element;
        this.listeners.forEach(function (listener) {
          var observedMessages = listener.observedMessages;
          var messageInfo = observedMessages[message];

          if (messageInfo) {
            var selector;
            var handler;

            if (typeof messageInfo === 'string') {
              selector = "*";
              handler = messageInfo;
            } else if (_typeof(messageInfo) === 'object') {
              selector = messageInfo.selector || "*";
              handler = messageInfo.handler;
            }

            if (selector.indexOf(SCOPE_SELECTOR$1) === 0) {
              if (!listener.id) {
                listener.id = commons.getUID();
              }

              selector = selector.replace(SCOPE_SELECTOR$1, "#".concat(listener.id, " > "));
            }

            if (element.matches(selector)) {
              listener[handler].call(listener, new Event$1({
                target: element,
                detail: detail,
                type: message,
                currentTarget: listener
              }));
            }
          }
        });
      }
      /**
        * post the provided message to all listener,
        * along with validating silencing and storing in queue
        * @param {String} message which should be posted
        * @param {Object} additional detail which needs to be posted.
        * @private
       */

    }, {
      key: "postMessage",
      value: function postMessage(message, detail) {
        if (this.isSilenced) {
          return;
        }

        if (!this.isConnected) {
          this._addMessageToQueue(message, detail);

          return;
        } // element got disconnect and messenger not notified.


        if (!this._element.isConnected) {
          // disconnect messenger and again post the same message,
          // message will get store in queue.
          this.disconnect();
          this.postMessage(message, detail);
          return;
        }

        this._postMessage(message, detail);
      }
      /**
        * element should call this method when they are disconnected from DOM.
        * Its the responsibility of the element to call this hook
        * @private
       */

    }, {
      key: "disconnect",
      value: function disconnect() {
        if (this.isConnected) {
          this._connected = false;

          this._clearListeners();

          this._clearQueue();
        }
      }
    }, {
      key: "isConnected",
      get: function get() {
        return this._connected === true;
      }
      /**
       * checks whether the event is silenced or not
       * @returns {Boolean} true if silenced
       * @private
       */

    }, {
      key: "isSilenced",
      get: function get() {
        return this._element._silenced === true;
      }
      /**
       * specifies the list of listener attached to messenger.
       * @returns {Array} array of listeners
       * @private
       */

    }, {
      key: "listeners",
      get: function get() {
        return this._listeners;
      }
    }]);

    return Messenger;
  }();
  /**
   * This Event class is just a bogus class, current message callback aspects
   * actual event as a parameter, since we are directly calling the method instead
   * of triggering event, will pass an instance of this disguised object,
   * to avoid breaks.
   * This just disguise the  most used functionality of event object
   * @private
   */


  var Event$1 = /*#__PURE__*/function () {
    function Event(options) {
      _classCallCheck(this, Event);

      this._detail = options.detail;
      this._target = options.target;
      this._type = options.type;
      this._currentTarget = options.currentTarget;
      this._defaultPrevented = false;
      this._propagationStopped = false;
      this._immediatePropagationStopped = false;
    }

    _createClass(Event, [{
      key: "preventDefault",
      value: function preventDefault() {
        this._defaultPrevented = true;
      }
    }, {
      key: "stopPropagation",
      value: function stopPropagation() {
        this._propagationStopped = true;
      }
    }, {
      key: "stopImmediatePropagation",
      value: function stopImmediatePropagation() {
        this._immediatePropagationStopped = true;
      }
    }, {
      key: "detail",
      get: function get() {
        return this._detail;
      }
    }, {
      key: "type",
      get: function get() {
        return this._type;
      }
    }, {
      key: "target",
      get: function get() {
        return this._target;
      }
    }, {
      key: "currentTarget",
      get: function get() {
        return this._currentTarget;
      }
    }]);

    return Event;
  }();

  var CLASSNAME$10 = '_coral-Masonry-item';
  /** @ignore */

  var isMacLike = /(Mac|iPhone|iPod|iPad)/i.test(window.navigator.platform);
  /**
   @class Coral.Masonry.Item
   @classdesc A Masonry Item component
   @htmltag coral-masonry-item
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var MasonryItem = Decorator( /*#__PURE__*/function (_BaseComponent) {
    _inherits(_class, _BaseComponent);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this); // messenger

      _this._messenger = new Messenger(_assertThisInitialized(_this)); // Represents ownership (necessary when the item is moved which triggers callbacks)

      _this._masonry = null; // Default value

      _this._dragAction = null; // Template

      _this._elements = {};
      template$I.call(_this._elements);
      return _this;
    } // @compat


    _createClass(_class, [{
      key: "_insert",

      /**
       Animates the insertion of the item.
        @private
       */
      value: function _insert() {
        var _this2 = this;

        if (this.classList.contains('is-beforeInserting')) {
          this.classList.remove('is-beforeInserting');
          this.classList.add('is-inserting');
          commons.transitionEnd(this, function () {
            _this2.classList.remove('is-inserting');
          });
        }
      }
      /** @private */

    }, {
      key: "_setTabbable",
      value: function _setTabbable(tabbable) {
        this.setAttribute('tabindex', tabbable ? 0 : -1);
      }
      /** @private */

    }, {
      key: "_updateDragAction",
      value: function _updateDragAction(enabled) {
        var handle;

        if (enabled) {
          // Find handle
          if (this.getAttribute('coral-masonry-draghandle') !== null) {
            handle = this;
          } else {
            handle = this.querySelector('[coral-masonry-draghandle]');

            if (!handle) {
              // Disable drag&drop if handle wasn't found
              enabled = false;
            }
          }
        }

        if (enabled) {
          if (!this._dragAction) {
            this._dragAction = new DragAction(this);
            this._dragAction.dropZone = this.parentNode;
          }

          this._dragAction.handle = handle;
        } else if (this._dragAction) {
          this._dragAction.destroy();

          this._dragAction = null;
        }
      }
      /** @ignore */

    }, {
      key: "attributeChangedCallback",

      /** @ignore */
      value: function attributeChangedCallback(name, oldValue, value) {
        var _this3 = this;

        if (name === '_removing') {
          // Do it in the next frame so that the removing animation is visible
          window.requestAnimationFrame(function () {
            _this3.classList.toggle('is-removing', value !== null);
          });
        } else if (name === '_orderable') {
          this._updateDragAction(value !== null);
        } else {
          _get(_getPrototypeOf(_class.prototype), "attributeChangedCallback", this).call(this, name, oldValue, value);
        }
      }
      /** @ignore */

    }, {
      key: "_suspendCallback",
      value: function _suspendCallback() {
        _get(_getPrototypeOf(_class.prototype), "_suspendCallback", this).call(this);

        this._messenger.disconnect();
      }
      /** @ignore */

    }, {
      key: "_resumeCallback",
      value: function _resumeCallback() {
        this._messenger.connect();

        _get(_getPrototypeOf(_class.prototype), "_resumeCallback", this).call(this); // In case an already connected element is switched to new parent,
        // we would be ignoring the connected callback,
        // as the item will be connected to new parent, the new parent should be informed immediately


        this._messenger.postMessage('coral-masonry-item:_connected');
      }
      /** @ignore */

    }, {
      key: "connectedCallback",
      value: function connectedCallback() {
        this._messenger.connect();

        _get(_getPrototypeOf(_class.prototype), "connectedCallback", this).call(this); // Inform masonry immediately


        this._messenger.postMessage('coral-masonry-item:_connected');
      }
      /** @ignore */

    }, {
      key: "render",
      value: function render() {
        var _this4 = this;

        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$10); // @a11y

        this.setAttribute('tabindex', '-1'); // @a11y Add live region element to ensure announcement of selected state

        var accessibilityState = this._elements.accessibilityState || this.querySelector('coral-masonry-item-accessibilitystate') || new MasonryItemAccessibilityState(); // @a11y Style to be visually hidden yet accessible to screen readers

        if (!accessibilityState.classList.contains('u-coral-screenReaderOnly')) {
          accessibilityState.classList.add('u-coral-screenReaderOnly');
        } // @a11y accessibility state string should announce in document lang, rather than item lang.


        accessibilityState.setAttribute('lang', i18n.locale); // @a11y accessibility state has role="status" to announce as a live region

        accessibilityState.setAttribute('role', 'status');
        accessibilityState.setAttribute('aria-live', 'off');
        accessibilityState.hidden = true;
        accessibilityState.id = accessibilityState.id || commons.getUID(); // @a11y Wait a frame and append live region content element so that it is the last child within item.
        // wait for next macrotask to avoid appending the accessibility state element before quickactions.

        setTimeout(function () {
          if (!accessibilityState.parentNode) {
            _this4.appendChild(accessibilityState);
          } // @a11y Item should be labelled by accessibility state.


          if (isMacLike) {
            var ariaLabelledby = _this4.getAttribute('aria-labelledby');

            if (ariaLabelledby) {
              _this4.setAttribute('aria-labelledby', ariaLabelledby + ' ' + accessibilityState.id);
            }
          }
        });
        this._elements.accessibilityState = accessibilityState; // Support cloneNode

        var template = this.querySelector('._coral-Masonry-item-quickActions');

        if (template) {
          template.remove();
        }

        this.insertBefore(this._elements.quickactions, this.firstChild); // todo workaround to not give user possibility to tab into checkbox

        this._elements.check._labellableElement.tabIndex = -1;

        this._elements.check.setAttribute('aria-hidden', 'true');
      }
      /** @ignore */

    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        _get(_getPrototypeOf(_class.prototype), "disconnectedCallback", this).call(this); // disconnect messenger before calling masonry._onItemDisconnected


        this._messenger.disconnect(); // Handle it in masonry immediately


        var masonry = this._masonry;

        if (masonry) {
          masonry._onItemDisconnected(this);
        }
      }
    }, {
      key: "content",
      get: function get() {
        return this;
      },
      set: function set(value) {
        // Support configs
        if (_typeof(value) === 'object') {
          for (var prop in value) {
            /** @ignore */
            this[prop] = value[prop];
          }
        }
      }
      /**
       Specify while disconnecting the item, should it show transition or not.
       This is useful when replacing large items, this result in delay.
        @type {Boolean}
       @default true
       @private No need to update in public document.
       */

    }, {
      key: "showRemoveTransition",
      get: function get() {
        return !(this._showRemoveTransition === false);
      },
      set: function set(value) {
        this._showRemoveTransition = transform.boolean(value);
      }
      /**
       Specify whether the item is in removing state or not.
       @type {Boolean}
       */

    }, {
      key: "removing",
      get: function get() {
        return this.hasAttribute('_removing');
      }
      /**
       Whether the item is selected.
        @type {Boolean}
       @default false
       @htmlattribute selected
       @htmlattributereflected
       */

    }, {
      key: "selected",
      get: function get() {
        return this._selected || false;
      },
      set: function set(value) {
        value = transform.booleanAttr(value);

        if (validate.valueMustChange(this._selected, value)) {
          this._selected = value;

          this._reflectAttribute('selected', value);

          this.trigger('coral-masonry-item:_selecteditemchanged');
          this.setAttribute('aria-selected', value);
          this.classList.toggle('is-selected', value);

          this._elements.check[value ? 'setAttribute' : 'removeAttribute']('checked', '');

          this._messenger.postMessage('coral-masonry-item:_selectedchanged');
        }
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['selected', '_removing', '_orderable']);
      }
    }]);

    return _class;
  }(BaseComponent(HTMLElement)));

  var CLASSNAME$11 = '_coral-Masonry';
  /** @ignore */

  var isMacLike$1 = /(Mac|iPhone|iPod|iPad)/i.test(window.navigator.platform);
  /**
   Enumeration for {@link Masonry} selection options.

   @typedef {Object} MasonrySelectionModeEnum

   @property {String} NONE
   None is default, selection of Masonry items doesn't happen based on click.
   @property {String} SINGLE
   Single selection mode, Masonry behaves like radio input elements.
   @property {String} MULTIPLE
   Multiple selection mode, Masonry behaves like checkbox input elements.
   */

  var selectionMode$2 = {
    NONE: 'none',
    SINGLE: 'single',
    MULTIPLE: 'multiple'
  };
  /**
   Enumeration for {@link Masonry} layouts.

   @typedef {Object} MasonryLayoutsEnum

   @property {String} FIXED_CENTERED
   A Layout with fixed width centered items.
   @property {String} FIXED_SPREAD
   A layout with fixed width and evenly spread items.
   @property {String} VARIABLE
   A layout with variable width items.
   @property {String} DASHBOARD
   A layout with variable width items which are expanded in their height to fill gaps.
   */

  var layouts = {
    FIXED_CENTERED: 'fixed-centered',
    FIXED_SPREAD: 'fixed-spread',
    VARIABLE: 'variable',
    DASHBOARD: 'dashboard'
  };
  /**
   Enumeration values to enable/disable aria grid support for {@link Masonry}.

   @typedef {Object} MasonryAriaGridEnum

   @property {String} ON
   Turn on auto aria grid roles.
   @property {String} OFF
   OFF is default. Turn off auto aria grid roles.
   */

  var ariaGrid = {
    ON: 'on',
    OFF: 'off'
  }; // IE does not set the complete property to true if an image cannot be loaded. This code must be outside of the
  // masonry to make sure that the listener catches images which fail loading before the masonry is initalized.
  // @polyfill ie11

  document.addEventListener('error', function (event) {
    var target = event.target;

    if (target && target.tagName === 'IMG') {
      target._loadError = true;
    }
  }, true); // Ignore children which are being removed

  var itemFilter = function itemFilter(element) {
    return element && element.tagName === 'CORAL-MASONRY-ITEM' && !element.hasAttribute('_removing');
  }; // Filter out items being removed


  var isRemovingOrRemoved = function isRemovingOrRemoved(item) {
    return item.hasAttribute('_removing') || !item.parentNode;
  };
  /**
   * Returns the position of the second element relative to the first element.
   */


  var relativePosition = function relativePosition(el1, el2) {
    var rect1 = el1.getBoundingClientRect();
    var rect2 = el2.getBoundingClientRect();
    return {
      left: rect2.left - rect1.left,
      top: rect2.top - rect1.top
    };
  };

  var weightedDistance = function weightedDistance(x1, y1, x2, y2, unitWidth, unitHeight) {
    return Math.sqrt(Math.pow((x2 - x1) / unitWidth, 2) + Math.pow((y2 - y1) / unitHeight, 2));
  };

  var getPreviousItem = function getPreviousItem(item) {
    var previousItem = item.previousElementSibling;
    return itemFilter(previousItem) ? previousItem : null;
  };
  /**
   @class Coral.Masonry
   @classdesc A Masonry component that allows to lay out items in a masonry grid.
   @htmltag coral-masonry
   @extends {HTMLElement}
   @extends {BaseComponent}
   */


  var Masonry = Decorator( /*#__PURE__*/function (_BaseComponent) {
    _inherits(_class, _BaseComponent);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this); // Defaults

      _this._loaded = false;
      _this._layouted = false;
      _this._layoutScheduled = false;
      _this._forceDebounce = false;
      _this._debounceId = null;
      _this._newItems = [];
      _this._tabbableItem = null; //a11y

      _this._defaultAriaRole = "group";
      _this._ariaGrid = ariaGrid.OFF;
      _this._preservedAriaRole = _this._defaultAriaRole;
      _this._preservedParentAriaRole = null;
      _this._elements = {
        accessibilityState: _this.querySelector('coral-masonry-item-accessibilitystate') || new MasonryItemAccessibilityState()
      };

      _this._delegateEvents({
        'global:resize': '_onWindowResize',
        // Loaded
        'global:load': '_updateLoaded',
        'capture:load img': '_updateLoaded',
        'capture:error img': '_updateLoaded',
        // Drag and drop
        'coral-dragaction:dragstart coral-masonry-item': '_onItemDragStart',
        'coral-dragaction:dragover coral-masonry-item': '_onItemDragMove',
        'coral-dragaction:dragend coral-masonry-item': '_onItemDragEnd',
        'coral-masonry-item:_selecteditemchanged': '_onMasonrySelectedItemChanged',
        // Keyboard
        'capture:focus coral-masonry-item': '_onItemFocus',
        // Selection
        'click coral-masonry-item': '_onItemClick',
        'key:space coral-masonry-item': '_onItemClick',
        // Messenger
        'coral-masonry-item:_messengerconnected': '_onMessengerConnected'
      }); // Relayout when child elements change or are added/removed
      // Should this mutation observer become a bottleneck, it could be replaced with a resize listener


      _this._observer = new MutationObserver(_this._scheduleLayout.bind(_assertThisInitialized(_this), 'mutation'));

      _this._observer.observe(_assertThisInitialized(_this), {
        childList: true,
        subtree: true,
        characterData: true,
        attributes: true
      }); // Used for eventing


      _this._oldSelection = []; // Init the collection mutation observer

      _this.items._startHandlingItems(true);

      return _this;
    }
    /**
     Allows to interact with the masonry items.
      @type {SelectableCollection}
     @readonly
     */


    _createClass(_class, [{
      key: "_onItemSelectedChanged",
      value: function _onItemSelectedChanged(event) {
        event.stopImmediatePropagation();

        this._validateSelection(event.target);
      }
      /** @private */

    }, {
      key: "_onMasonrySelectedItemChanged",
      value: function _onMasonrySelectedItemChanged(event) {
        // this is a private event and should not leave the column view
        event.stopImmediatePropagation(); // announce the selection state for the focused item

        this._announceActiveElementState.call(event.target, event);
      }
    }, {
      key: "_announceActiveElementState",
      value: function _announceActiveElementState() {
        var accessibilityState = this._elements.accessibilityState;
        var self = this;
        var parentElement = this.parentElement;

        if (this._addTimeout || this._removeTimeout) {
          clearTimeout(this._addTimeout);
          clearTimeout(this._removeTimeout);
        } // we use setTimeout instead of nextFrame to give screen reader more time to respond to live region update in order to announce complete text content when the state changes.


        this._addTimeout = setTimeout(function () {
          var activeElement = document.activeElement;

          if (!self.contains(activeElement) || activeElement.tagName !== 'CORAL-MASONRY-ITEM') {
            return;
          }

          var span = document.createElement('span');
          span.appendChild(document.createTextNode(i18n.get(activeElement.selected ? 'checked' : 'not checked')));
          accessibilityState.innerHTML = '';
          accessibilityState.hidden = false;
          accessibilityState.removeAttribute('aria-live');
          setTimeout(function () {
            accessibilityState.appendChild(span); // give screen reader 1.6 secs before clearing the live region, to provide enough time for announcement

            self._removeTimeout = setTimeout(parentElement._resetAccessibilityState, 1600, accessibilityState, self);
          }, 100);
        }, 100);
      } // utility method to clean up accessibility state

    }, {
      key: "_resetAccessibilityState",
      value: function _resetAccessibilityState(accessibilityState, self) {
        accessibilityState.setAttribute('aria-live', 'off'); // @a11y only persist the checked state on macOS,
        // where VoiceOver does not announce the selected state for a gridcell.

        accessibilityState.hidden = !isMacLike$1 || !self.selected;

        if (!isMacLike$1 || !self.selected) {
          accessibilityState.innerHTML = '';
        }
      }
      /**
       Allows to interact with the masonry layout instance.
        @type {MasonryLayout}
       @readonly
       */

    }, {
      key: "_updateAriaRoleForParent",

      /** @private */
      value: function _updateAriaRoleForParent(activateAriaGrid) {
        if (!this.parentElement) {
          return;
        }

        if (activateAriaGrid === ariaGrid.ON) {
          // Save/set role for the parent as grid
          this._preservedParentAriaRole = this.parentElement.getAttribute('role');
          this.parentElement.setAttribute('role', 'grid'); // parent grid should be labelled the same as coral-masonry

          if (this.ariaLabel && this.parentElement.getAttribute('aria-label') !== this.ariaLabel) {
            this._preservedParentAriaLabel = this.parentElement.getAttribute('aria-label');
            this.parentElement.setAttribute('aria-label', this.ariaLabel);
          }

          if (this.ariaLabelledby && this.parentElement.getAttribute('aria-labelledby') !== this.ariaLabelledby) {
            this._preservedParentAriaLabelledby = this.parentElement.getAttribute('aria-labelledby');
            this.parentElement.setAttribute('aria-labelledby', this.ariaLabelledby);
          }

          if (this._selectionMode === selectionMode$2.NONE) {
            this.parentElement.removeAttribute('aria-multiselectable');
          } else {
            this.parentElement.setAttribute('aria-multiselectable', this._selectionMode === selectionMode$2.MULTIPLE);
          }
        } else {
          // Restore/remove role of the parent element
          if (this._preservedParentAriaRole) {
            this.parentElement.setAttribute('role', this._preservedParentAriaRole);
          } else {
            this.parentElement.removeAttribute('role');
          } // restore the aria-label or aria-labelledby values as well


          if (this._preservedParentAriaLabel) {
            this.parentElement.setAttribute('aria-label', this._preservedParentAriaLabel);
            this._preservedParentAriaLabel = undefined;
          } else {
            this.parentElement.removeAttribute('aria-label');
          }

          if (this._preservedParentAriaLabelledby !== undefined) {
            this.parentElement.setAttribute('aria-labelledby', this._preservedParentAriaLabelledby);
          } else {
            this.parentElement.removeAttribute('aria-labelledby');
          } // Remove aria-colcount


          this.parentElement.removeAttribute('aria-colcount'); // Remove aria-multiselectable

          this.parentElement.removeAttribute('aria-multiselectable');
        }
      }
      /** @private */

    }, {
      key: "_updateAriaRoleForItems",
      value: function _updateAriaRoleForItems(activateAriaGrid) {
        var _this2 = this;

        var columnIndex = 1;
        this.items.getAll().forEach(function (item) {
          _this2._updateAriaRoleForItem(item, columnIndex++, activateAriaGrid);
        });
      }
      /** @private */

    }, {
      key: "_updateAriaRoleForItem",
      value: function _updateAriaRoleForItem(item, columnIndex, activateAriaGrid) {
        if (activateAriaGrid === ariaGrid.ON) {
          item.setAttribute('role', 'gridcell');
          item.setAttribute('aria-colindex', columnIndex); // communicate aria-selected state of all cells

          if (this.selectionMode !== selectionMode$2.NONE || this.parentElement.hasAttribute('aria-multiselectable')) {
            item.setAttribute('aria-selected', item.selected);
          }
        } else {
          item.removeAttribute('role');
          item.removeAttribute('aria-colindex');
          item.removeAttribute('aria-selected');
        }
      }
      /** @private */

    }, {
      key: "_updateAriaColumnCountForParent",
      value: function _updateAriaColumnCountForParent(activateAriaGrid) {
        if (!this.parentElement) {
          return;
        }

        if (activateAriaGrid === ariaGrid.ON) {
          this.parentElement.setAttribute('aria-colcount', this.items.length);
        } else {
          this.parentElement.removeAttribute('aria-colcount');
        }
      }
    }, {
      key: "_validateSelection",
      value: function _validateSelection(item) {
        var _this3 = this;

        var selectedItems = this.selectedItems;

        if (this.selectionMode === selectionMode$2.NONE) {
          this.items.getAll().forEach(function (item) {
            // Don't trigger change events
            _this3._preventTriggeringEvents = true;

            if (item.selected) {
              item.removeAttribute('selected');
            }

            item.removeAttribute('aria-selected');
          });
        } else if (this.selectionMode === selectionMode$2.SINGLE) {
          // Last selected item wins if multiple selection while not allowed
          item = item || selectedItems[selectedItems.length - 1];

          if (item && item.hasAttribute('selected') && selectedItems.length > 1) {
            selectedItems.forEach(function (selectedItem) {
              if (selectedItem !== item) {
                // Don't trigger change events
                _this3._preventTriggeringEvents = true;
                selectedItem.removeAttribute('selected');
              }
            }); // We can trigger change events again

            this._preventTriggeringEvents = false;
          }
        }

        this._triggerChangeEvent();
      }
    }, {
      key: "_triggerChangeEvent",
      value: function _triggerChangeEvent() {
        var selectedItems = this.selectedItems;
        var oldSelection = this._oldSelection;

        if (!this._preventTriggeringEvents && this._arraysAreDifferent(selectedItems, oldSelection)) {
          if (this.selectionMode === selectionMode$2.MULTIPLE) {
            this.trigger('coral-masonry:change', {
              oldSelection: oldSelection,
              selection: selectedItems
            });
          } else {
            this.trigger('coral-masonry:change', {
              oldSelection: oldSelection.length > 1 ? oldSelection : oldSelection[0] || null,
              selection: selectedItems[0] || null
            });
          }

          this._oldSelection = selectedItems;
        }
      }
    }, {
      key: "_arraysAreDifferent",
      value: function _arraysAreDifferent(selection, oldSelection) {
        var diff = [];

        if (oldSelection.length === selection.length) {
          diff = oldSelection.filter(function (item) {
            return selection.indexOf(item) === -1;
          });
        } // since we guarantee that they are arrays, we can start by comparing their size


        return oldSelection.length !== selection.length || diff.length !== 0;
      }
    }, {
      key: "_onItemClick",
      value: function _onItemClick(event) {
        if (this.selectionMode !== selectionMode$2.NONE) {
          event.preventDefault();
          var item = event.matchedTarget;
          item[item.hasAttribute('selected') ? 'removeAttribute' : 'setAttribute']('selected', '');
        }
      }
      /** @private */

    }, {
      key: "_setAllSelected",
      value: function _setAllSelected(selected) {
        var items = this.items.getAll();

        for (var i = 0; i < items.length; i++) {
          var item = items[i];

          if (item.hasAttribute('selected') !== selected) {
            item[selected ? 'setAttribute' : 'removeAttribute']('selected', '');
          }
        }
      }
      /**
       Schedules a layout for the next animation frame. Even if called many times, the layout happens still just once.
        @private
       */

    }, {
      key: "_scheduleLayout",
      value: function _scheduleLayout() {
        var _this4 = this;

        if (!this._forceDebounce && !this._layoutScheduled) {
          window.requestAnimationFrame(function () {
            // Skip layout if a layout was forced in between
            if (_this4._layoutScheduled) {
              _this4._doLayout(); // Cancel potentially scheduled layout if the current layout was enforced by calling doLayout directly


              _this4._layoutScheduled = false;
            }
          });
          this._layoutScheduled = true;
        }
      }
      /** @private */

    }, {
      key: "_scheduleDebouncedLayout",
      value: function _scheduleDebouncedLayout(force) {
        var _this5 = this;

        // Do not force debounce if the masonry isn't layouted yet. Safari sometimes triggers resize events while loading.
        if (force && this._layouted) {
          this._forceDebounce = true;
        }

        window.clearTimeout(this._debounceId);
        this._debounceId = window.setTimeout(function () {
          _this5._forceDebounce = false;

          _this5._scheduleLayout('window resize');
        }, 500);
      }
      /**
       Callback which has to be called when the dimensions have changed or the masonry turned visible.
        @private
       */

    }, {
      key: "_onResize",
      value: function _onResize() {
        if (!this._layouted) {
          // The masonry was first invisible, render it now immediately
          this._doLayout('became visible');
        } else {
          this._scheduleDebouncedLayout(false);
        }
      }
      /** @private */

    }, {
      key: "_onWindowResize",
      value: function _onWindowResize() {
        this._scheduleDebouncedLayout(true);
      }
      /**
       Performs a layout. Should only be called by {@link #_scheduleLayout} if possible.
        @private
       */

    }, {
      key: "_doLayout",
      value: function _doLayout() {
        var visible = !!this.offsetParent;
        var LayoutClass = this.constructor._layouts[this.layout];

        if (this._forceDebounce || !LayoutClass || !visible) {
          return;
        }

        if (!this._layoutInstance) {
          this._layoutInstance = new LayoutClass(this);
        } // Check if the layout has changed
        else if (this._layoutInstance.name !== this.layout) {
            this._layoutInstance.destroy();

            this._layoutInstance = new LayoutClass(this);
          } // Animate insertion. In the attachedCallback of the item, the is-beforeInserting class was already added. This
        // class is now removed again which allows to transition between the is-beforeInserting and is-inserting class.
        // By separating the code and batching the changes, the overhead is reduced significantly.


        var i;
        var newItems = this._newItems;

        for (i = 0; i < newItems.length; i++) {
          newItems[i]._insert();
        } // Position the items


        this._layoutInstance.layout();

        this._layouted = true; // Mark newly added items as managed. Before this class is added, the items are invisible. The reason why this is
        // done here after positioning the items is that it seems to be the only way to ensure that the items are never
        // shown at the wrong position. There used to be two cases when this happened:
        // - When the masonry is first invisible and later shown because the resize event is triggered too late.
        // - In some browsers (e.g. Safari) always when items are added dynamically

        for (i = 0; i < newItems.length; i++) {
          newItems[i].classList.add('is-managed');
        } // clear


        newItems.length = 0; // Update loaded class. Cannot be done in _updateLoaded because it has to happen after the positioning.

        this.classList.toggle('is-loaded', this._loaded); // Ensure that the tabbable item is set & still valid

        var tabbableItem = this._tabbableItem;

        if (!tabbableItem || isRemovingOrRemoved(tabbableItem)) {
          this._setTabbableItem(this.items.first());
        } // Focus the next item if the previously focused item has been removed


        var focusedItem = this._focusedItem;

        if (focusedItem) {
          if (isRemovingOrRemoved(focusedItem) && this._focusedItemNext) {
            this._focusedItemNext.focus();
          } else if (focusedItem !== document.activeElement) {
            this._focusedItem = null;
            this._focusedItemNext = null;
          }
        } // Update items, so that column indexes are correctly set


        this._updateAriaRoleForItems(this.ariaGrid);

        this._updateAriaColumnCountForParent(this.ariaGrid); // Prevent endless observation loop (skip mutations which have been caused by the layout)


        this._observer.takeRecords();
      }
      /** @ignore */

    }, {
      key: "_updateLoaded",
      value: function _updateLoaded() {
        // Wait until complete because fonts might be loaded after interactive
        if (!this._loaded && document.readyState === 'complete') {
          var loaded = true;
          var images = this.querySelectorAll('img');

          for (var i = 0; i < images.length; i++) {
            var image = images[i]; // _loadError is set in a listener at the top of this file

            if (image.src && !image.complete && !image._loadError) {
              loaded = false;
              break;
            }
          }

          this._loaded = loaded;
        } // A loaded image might have made an item bigger


        this._scheduleLayout();
      }
      /** @private */

    }, {
      key: "_onItemConnected",
      value: function _onItemConnected(event) {
        event.stopImmediatePropagation();
        var item = event.target;

        this._prepareItem(item);
      }
    }, {
      key: "_prepareItem",
      value: function _prepareItem(item) {
        var _this6 = this;

        // We don't care about transitions if the masonry is not in the body
        if (!document.body.contains(this)) {
          return;
        } // check if just moving


        if (!item.hasAttribute('_removing') && this !== item._masonry && !item.hasAttribute('_placeholder')) {
          item._masonry = this; // Insert animation start style. This is separated from _insert because otherwise we would have to enforce a
          // reflow between changing the classes for every item (which is slow).

          item.classList.add('is-beforeInserting'); // Do it in the next frame so that the inserting animation is visible

          window.requestAnimationFrame(function () {
            _this6._onItemAdded(item);
          });
        }
      }
    }, {
      key: "_removeItem",
      value: function _removeItem(item) {
        item.removeAttribute('_removing');
        item._masonry = null;

        this._onItemRemoved(item);
      }
      /** @private */

    }, {
      key: "_onItemDisconnected",
      value: function _onItemDisconnected(item) {
        var _this7 = this;

        // We don't care about transitions if the masonry is not in the body
        if (!document.body.contains(this)) {
          return;
        } // Ignore the item being dropped after ordering


        if (item._dropping) {
          return;
        }

        if (!item.hasAttribute('_removing') && item.showRemoveTransition) {
          // Attach again for remove transition
          item.setAttribute('_removing', '');
          item._ignoreConnectedCallback = true;
          this.appendChild(item);
          item._ignoreConnectedCallback = false;
          commons.transitionEnd(item, function () {
            item.remove();

            _this7._removeItem(item);
          });
        } // remove transition completed
        else {
            this._removeItem(item);
          }
      }
      /** @private */

    }, {
      key: "_onItemAdded",
      value: function _onItemAdded(item) {
        item._updateDragAction(this.orderable);

        this._newItems.push(item); // Hack to prevent flickering in some browsers which don't support custom elements natively (e.g. Safari)


        if (this._attaching && item.nextElementSibling === null) {
          this._doLayout('last item attached');
        }
      }
      /** @private */

    }, {
      key: "_onItemRemoved",
      value: function _onItemRemoved(item) {
        item._updateDragAction(false);

        item.classList.remove('is-managed');
      }
      /** @private */

    }, {
      key: "_onItemFocus",
      value: function _onItemFocus(e) {
        var item = e.target;

        if (item === e.matchedTarget) {
          this._setTabbableItem(item); // Remember the focused item and a sibling for the case when the currently focused item is removed and another
          // item has to be selected in _doLayout


          this._focusedItem = item;
          this._focusedItemNext = [item.nextElementSibling, item.previousElementSibling].filter(itemFilter)[0];
        }
      }
      /** @private */

    }, {
      key: "_setTabbableItem",
      value: function _setTabbableItem(item) {
        if (this._tabbableItem) {
          this._tabbableItem._setTabbable(false);
        }

        if (item) {
          item._setTabbable(true);
        }

        this._tabbableItem = item;
      }
      /**
       @return {Boolean} true if the new position isn't further away from the center of the placeholder than the
       previous position.
        @private
       */

    }, {
      key: "_isApproachingPlaceholder",
      value: function _isApproachingPlaceholder(pos, prevPos, placeholder) {
        var placeholderPos = relativePosition(this, placeholder);
        var placeholderWidth = placeholder.offsetWidth;
        var placeholderHeight = placeholder.offsetHeight;
        var placeholderX = placeholderPos.left + placeholderWidth / 2;
        var placeholderY = placeholderPos.top + placeholderHeight / 2; // A weighted distance is used to improve the user experience with rather long/high cards

        return weightedDistance(placeholderX, placeholderY, pos.left, pos.top, placeholderWidth, placeholderHeight) <= weightedDistance(placeholderX, placeholderY, prevPos.left, prevPos.top, placeholderWidth, placeholderHeight);
      }
      /** @private */

    }, {
      key: "_onItemDragStart",
      value: function _onItemDragStart(e) {
        var item = e.target;

        if (item === e.matchedTarget) {
          this._layoutInstance.detach(item);

          item._oldBefore = getPreviousItem(item);
          var placeholder = item._dropPlaceholder = new MasonryItem();
          placeholder.setAttribute('_placeholder', ''); // Add a content div with the right dimension instead of setting the dimension on the item directly. This is
          // necessary because some layouts modify the dimensions as well.

          var contentDiv = document.createElement('div');
          contentDiv.style.width = "".concat(item.clientWidth, "px");
          contentDiv.style.height = "".concat(item.clientHeight, "px");
          placeholder.appendChild(contentDiv); // Insert placeholder before dragged item

          placeholder.classList.add('_coral-Masonry-item--placeholder');
          this.insertBefore(placeholder, item);
        }
      }
      /** @private */

    }, {
      key: "_onItemDragMove",
      value: function _onItemDragMove(e) {
        var item = e.target;
        var placeholder = item._dropPlaceholder;

        if (item === e.matchedTarget && placeholder) {
          var prevPos = item._prevDragPos;
          var pos = relativePosition(this, item); // If the current move is approaching the previous placeholder target, then it must not move the placeholder
          // again. Otherwise it can happen with multi-column items that the items jump around hectically while dragging
          // an item.

          if (!prevPos || !this._isApproachingPlaceholder(pos, prevPos, placeholder)) {
            // Find item below cursor
            var itemBelow = this._layoutInstance.itemAt(pos.left, pos.top);

            if (itemBelow && itemBelow !== placeholder) {
              // If the item below (the dragged item) is preceding the placeholder, then it has to insert the placeholder
              // before the item below (the dragged item)
              if (placeholder.compareDocumentPosition(itemBelow) & document.DOCUMENT_POSITION_PRECEDING) {
                itemBelow.parentNode.insertBefore(placeholder, itemBelow);
              } else {
                itemBelow.parentNode.insertBefore(placeholder, itemBelow.nextSibling);
              }
            }
          }

          item._prevDragPos = pos;
        }
      }
      /** @private */

    }, {
      key: "_onItemDragEnd",
      value: function _onItemDragEnd(e) {
        var item = e.target;
        var placeholder = item._dropPlaceholder;

        if (item === e.matchedTarget && placeholder) {
          item._dropping = true; // Replace the drop placeholder with this item

          this.replaceChild(item, placeholder);
          item._dropping = false; // Trigger order event

          item.trigger('coral-masonry:order', {
            item: item,
            oldBefore: item._oldBefore,
            before: getPreviousItem(item)
          }, true, false); // // Drop transition

          this._layoutInstance.reattach(item);

          item.classList.add('is-dropping');
          commons.transitionEnd(item, function () {
            item.classList.remove('is-dropping');
          }); // Update items, so that column indexes are correctly set

          this._updateAriaRoleForItems(this.ariaGrid);
        }

        item._oldBefore = null;
        item._dropPlaceholder = null;
        item._prevDragPos = null;
      }
    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        var _this8 = this;

        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$11); // Keep the default behavior when ariaGrid is not enabled

        if (this._ariaGrid === ariaGrid.OFF) {
          // a11y
          this.setAttribute('role', this._defaultAriaRole);
        } // Default reflected attributes


        if (!this._layout) {
          this.layout = layouts.FIXED_CENTERED;
        }

        if (!this._selectionMode) {
          this.selectionMode = selectionMode$2.NONE;
        } // Don't trigger events once connected


        this._preventTriggeringEvents = true;

        this._validateSelection();

        this._preventTriggeringEvents = false;
        this._oldSelection = this.selectedItems; // Handles the resizing of the masonry

        commons.addResizeListener(this, this._onResize.bind(this)); // Prepare items

        this.items.getAll().forEach(function (item) {
          _this8._prepareItem(item);
        }); // This indicates that the initial items are being attached

        this._attaching = true;
        window.requestAnimationFrame(function () {
          _this8._attaching = false; // Update loaded after all items have been attached

          _this8._updateLoaded();
        });
      }
      /**
       Triggered when a {@link Masonry} item is reordered.
        @typedef {CustomEvent} coral-masonry:order
        @property {MasonryItem} detail.item
       The reordered item
       @property {?MasonryItem} detail.oldBefore
       The previous item before the reordering.
       @property {?MasonryItem} detail.before
       The previous item after the reordering.
       */

      /**
       Triggered when {@link Masonry} selected item has changed.
        @typedef {CustomEvent} coral-masonry:change
        @property {MasonryItem} detail.oldSelection
       The prior selected item(s).
       @property {MasonryItem} detail.selection
       The newly selected item(s).
       */

    }, {
      key: "items",
      get: function get() {
        if (!this._items) {
          this._items = new SelectableCollection({
            host: this,
            itemTagName: 'coral-masonry-item',
            // allows masonry to be nested
            itemSelector: ':scope > coral-masonry-item:not([_removing]):not([_placeholder])',
            onlyHandleChildren: true,
            onItemAdded: this._validateSelection,
            onItemRemoved: this._validateSelection
          });
        }

        return this._items;
      }
      /**
       Selection mode of Masonry
        @type {String}
       @default MasonrySelectionModeEnum.NONE
       @htmlattribute selectionmode
       @htmlattributereflected
       */

    }, {
      key: "selectionMode",
      get: function get() {
        return this._selectionMode || selectionMode$2.NONE;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        this._selectionMode = validate.enumeration(selectionMode$2)(value) && value || selectionMode$2.NONE;

        this._reflectAttribute('selectionmode', this._selectionMode);

        var isGrid = this.ariaGrid === ariaGrid.ON && this.parentElement;

        if (this._selectionMode === selectionMode$2.NONE) {
          this.classList.remove('is-selectable');

          if (isGrid) {
            this.parentElement.removeAttribute('aria-multiselectable');
          }
        } else {
          this.classList.add('is-selectable');

          if (isGrid) {
            this.parentElement.setAttribute('aria-multiselectable', this._selectionMode === selectionMode$2.MULTIPLE);
          }
        }

        this._validateSelection();
      }
    }, {
      key: "layoutInstance",
      get: function get() {
        return this._layoutInstance;
      }
      /**
       The layout name for this masonry. Must be one of {@link Coral.Masonry.layouts}.
       See {@link MasonryLayoutsEnum}.
        @type {String}
       @default MasonryLayoutsEnum.FIXED_CENTERED
       @htmlattribute layout
       @htmlattributereflected
       */

    }, {
      key: "layout",
      get: function get() {
        return this._layout || layouts.FIXED_CENTERED;
      },
      set: function set(value) {
        value = transform.string(value);
        var layoutEnum = this.constructor._layouts;

        if (value === '') {
          // Default is first registered layout which is "fixed-centered"
          value = Object.keys(layoutEnum)[0];
        }

        if (value !== this._layout) {
          if (layoutEnum[value]) {
            this._layout = value;

            this._reflectAttribute('layout', this._layout);

            this._scheduleLayout('new layout');
          } else {
            commons._log('Coral.Masonry: Unknown layout:', value);
          }
        }
      }
      /**
       The first selected item or <code>null</code> if no item is selected.
        @type {MasonryItem}
       @readonly
       */

    }, {
      key: "selectedItem",
      get: function get() {
        return this.items._getFirstSelected();
      }
      /**
       An array of all selected items.
        @type {Array.<MasonryItem>}
       @readonly
       */

    }, {
      key: "selectedItems",
      get: function get() {
        return this.items._getAllSelected();
      } // TODO this is layout specific. move to layout?

      /**
       The spacing between the items and the masonry container in pixel. If this property is not set, then it falls
       back to the CSS padding of the masonry and margin of the items.
        @type {?Number}
       @default null
       @htmlattribute spacing
       */

    }, {
      key: "spacing",
      get: function get() {
        return this._spacing || null;
      },
      set: function set(value) {
        value = transform.number(value);
        this._spacing = value !== null ? Math.max(0, value) : null;

        this._scheduleLayout('spacing');
      }
      /**
       Whether or not it is possible to order items with drag & drop.
        @type {Boolean}
       @default false
       @htmlattribute orderable
       */

    }, {
      key: "orderable",
      get: function get() {
        return this._orderable || false;
      },
      set: function set(value) {
        this._orderable = transform.booleanAttr(value);
        var items = this.items.getAll();

        for (var i = 0; i < items.length; i++) {
          items[i][this._orderable ? 'setAttribute' : 'removeAttribute']('_orderable', '');
        }
      }
      /**
       Attribute to enable/disable auto aria grid role assignment. Value must be one of {@link MasonryAriaGridEnum}.
       Setting this property to {@link MasonryAriaGridEnum.ON} will do following to enable support for accessibility:
       - Preserve current role attribute of the parent element of {@link Masonry}, and set new role as grid.
       - Preserve current role attribute of the {@link Masonry}, and set new role as row.
       - Set role attribute of all child {@link MasonryItem} to gridcell.
        Setting the property to {@link MasonryAriaGridEnum.OFF} will do following:
       - Restore preserved (if any) role attribute of the parent element of {@link Masonry}.
       - Restore preserved role attribute of the {@link Masonry}.
       - Remove role attribute of all child {@link MasonryItem}.
        Setting the attribute to other than allowed values will fallback to {@link MasonryAriaGridEnum.OFF}.
        @type {String}
       @default {@link MasonryAriaGridEnum.OFF}
       @htmlattribute ariagrid
       @htmlattributereflected
       */

    }, {
      key: "ariaGrid",
      get: function get() {
        return this._ariaGrid || ariaGrid.OFF;
      },
      set: function set(value) {
        value = transform.string(value); // Ensure correct values

        if (value !== ariaGrid.ON && value !== ariaGrid.OFF) {
          console.warn('Coral.Masonry: Unsupported ariaGrid value: ', value, '. Will fallback to ', ariaGrid.OFF);
          value = ariaGrid.OFF;
        } //update current state


        this._ariaGrid = value;

        this._reflectAttribute('ariagrid', this._ariaGrid); // Update role for this masonry


        if (this._ariaGrid === ariaGrid.ON) {
          // Preserve existing role and set new role
          this._preservedAriaRole = this.getAttribute('role');
          this.setAttribute('role', 'row');
        } else if (this._ariaGrid == ariaGrid.OFF) {
          // Restore or remove role
          if (this._preservedAriaRole) {
            this.setAttribute('role', this._preservedAriaRole);
          } else {
            this.removeAttribute('role');
          }
        } // Update parent and child item roles based on current state


        this._updateAriaRoleForParent(this._ariaGrid);

        this._updateAriaColumnCountForParent(this._ariaGrid);

        this._updateAriaRoleForItems(this._ariaGrid);
      }
      /**
       Specifies aria-label value
        @type {?String}
       @htmlattribute aria-label
       @htmlattributereflected
       */

    }, {
      key: "ariaLabel",
      get: function get() {
        return this.getAttribute('aria-label');
      },
      set: function set(value) {
        value = transform.string(value);

        if (value === '') {
          this.removeAttribute('aria-label');
        } else {
          this._reflectAttribute('aria-label', value);
        }

        if (!this.parentElement || this._ariaGrid === ariaGrid.OFF) {
          return;
        }

        if (this.ariaLabel) {
          this.parentElement.setAttribute('aria-label', this.ariaLabel);
        } else {
          this.parentElement.removeAttribute('aria-label');
        }
      }
      /**
       Specifies aria-labelledby value
        @type {?String}
       @htmlattribute aria-labelledby
       @htmlattributereflected
       */

    }, {
      key: "ariaLabelledby",
      get: function get() {
        return this.getAttribute('aria-labelledby');
      },
      set: function set(value) {
        value = transform.string(value);

        if (value === '') {
          this.removeAttribute('aria-labelledby');
        } else {
          this._reflectAttribute('aria-labelledby', value);
        }

        if (!this.parentElement || this._ariaGrid === ariaGrid.OFF) {
          return;
        }

        if (this.ariaLabelledby) {
          this.parentElement.setAttribute('aria-labelledby', this.ariaLabelledby);
        } else {
          this.parentElement.removeAttribute('aria-labelledby');
        }
      }
    }, {
      key: "observedMessages",
      get: function get() {
        return {
          'coral-masonry-item:_connected': '_onItemConnected',
          'coral-masonry-item:_selectedchanged': '_onItemSelectedChanged'
        };
      }
      /**
       Registry for masonry layouts.
        @type {Object.<string,Layout>}
       @private
       @readonly
       */

    }], [{
      key: "registerLayout",

      /**
       Registers a layout with the given name.
       The name can then be set at {@link Coral.Masonry.layout} to render a masonry with the this registered layout.
        @param {String} name of the layout
       @param {Layout} Layout class which extends {@link Coral.Masonry.Layout}
       */
      value: function registerLayout(name, Layout) {
        Layout.defineName(name);
        this._layouts[name] = Layout;
      }
      /**
       Returns {@link Masonry} layouts.
        @return {MasonryLayoutsEnum}
       */

    }, {
      key: "_layouts",
      get: function get() {
        if (!this.__layouts) {
          this.__layouts = {};
        }

        return this.__layouts;
      }
    }, {
      key: "layouts",
      get: function get() {
        return layouts;
      }
      /**
       Returns {@link Masonry} selection mode options.
        @return {MasonrySelectionModeEnum}
       */

    }, {
      key: "selectionMode",
      get: function get() {
        return selectionMode$2;
      }
    }, {
      key: "_attributePropertyMap",
      get: function get() {
        return commons.extend(_get(_getPrototypeOf(_class), "_attributePropertyMap", this), {
          selectionmode: 'selectionMode',
          ariagrid: 'ariaGrid',
          'aria-label': 'ariaLabel',
          'aria-labelledby': 'ariaLabelledby'
        });
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['selectionmode', 'layout', 'spacing', 'orderable', 'ariagrid', 'aria-label', 'aria-labelledby']);
      }
    }]);

    return _class;
  }(BaseComponent(HTMLElement)));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   Base class for masonry layouts.

   Whenever a change is detected, the {@link Coral.Masonry.Layout#layout} method is called. This method must then
   ensure that all the items are positioned correctly.

   Layout-specific keyboard support must be handled by adding event listeners to the masonry in the constructor. Such
   event listeners must be removed in the {@link Coral.Masonry.Layout#destroy} method.

   @param masonry
   @class Coral.Masonry.Layout
   */
  var MasonryLayout = /*#__PURE__*/function () {
    /**
     * this is constructor description.
     * @param {number} arg1 this is arg1 description.
     * @param {string[]} arg2 this is arg2 description.
     */
    function MasonryLayout(masonry) {
      _classCallCheck(this, MasonryLayout);

      this._masonry = masonry;
    }
    /**
     Layout name. Uses the constructor given name by default if defined.
      @type {String}
     */


    _createClass(MasonryLayout, [{
      key: "layout",

      /**
       Lays out the masonry items according to the implementation.
       */
      value: function layout() {} // To override

      /**
       Removes all layout-specific attributes, style, data and event listeners from the masonry and its items.
       */

    }, {
      key: "destroy",
      value: function destroy() {} // To override

      /**
       Removes the item from the control of the layout. This can be used to position the item differently,
       for example for drag&drop.
        @param {MasonryItem} item
       */
      // eslint-disable-next-line no-unused-vars

    }, {
      key: "detach",
      value: function detach(item) {} // To override

      /**
       Adds the item to the control of the layout again. The layout has to ensure that the item will be transitioned to
       its normal position flawlessly.
        @param {MasonryItem} item
       */
      // eslint-disable-next-line no-unused-vars

    }, {
      key: "reattach",
      value: function reattach(item) {} // To override

      /**
       Returns the item at the given position. The position coordinates are relative to the masonry.
        If an item is being transitioned when this method is called, then it must choose the item based on the final
       instead of the current position.
        @param {number} x
       @param {number} y
       @return {?Coral.Masonry.Item}
       */
      // eslint-disable-next-line no-unused-vars

    }, {
      key: "itemAt",
      value: function itemAt(x, y) {} // To override

      /**
       Defines the name of the Layout
        @param {String} name
       */

    }, {
      key: "name",
      get: function get() {
        return this._name || this.constructor._name;
      },
      set: function set(value) {
        this._name = value;
      }
    }], [{
      key: "defineName",
      value: function defineName(name) {
        this._name = name;
      }
    }]);

    return MasonryLayout;
  }();

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /** @ignore */
  var setTransform = function setTransform(el, value) {
    el.style.setProperty('-webkit-transform', value);
    el.style.setProperty('-ms-transform', value);
    el.style.transform = value;
  };
  /** @ignore */


  var setTransition = function setTransition(el, value) {
    el.style.setProperty('-webkit-transition', value);
    el.style.setProperty('-ms-transition', value);
    el.style.transition = value;
  };
  /** @ignore */


  var getFirstRowFilledColumns = function getFirstRowFilledColumns(columns, items) {
    var filledColumns = 0;

    for (var i = 0; i < items.length; i++) {
      var item = items[i];
      filledColumns += item._layoutData.colspan;

      if (filledColumns >= columns.length) {
        return columns.length;
      }
    }

    return filledColumns;
  };
  /** @ignore */


  var csspx = function csspx(el, property) {
    return parseFloat(window.getComputedStyle(el)[property], 10);
  }; // TODO if the property changes, it will not automatically relayout the masonry
  // TODO test columnWidth and colspan property and default values

  /** @ignore */


  var getPositiveNumberProperty = function getPositiveNumberProperty(element, property, attribute, defaultValue) {
    var value = element[property];

    if (value === undefined) {
      value = element.getAttribute(attribute);
    }

    value = parseInt(value, 10);

    if (value <= 0 || isNaN(value)) {
      value = defaultValue;
    }

    return value;
  };

  /**
   Base class for column-based masonry layouts.

   @class Coral.Masonry.ColumnLayout
   @classdesc A Masonry Column layout
   @extends {MasonryLayout}
   */

  var MasonryColumnLayout = /*#__PURE__*/function (_MasonryLayout) {
    _inherits(MasonryColumnLayout, _MasonryLayout);

    var _super = _createSuper(MasonryColumnLayout);

    /**
     Takes a {Masonry} instance as argument.
      @param {Masonry} masonry
     */
    function MasonryColumnLayout(masonry) {
      var _this;

      _classCallCheck(this, MasonryColumnLayout);

      _this = _super.call(this, masonry);
      _this._columns = [];

      var up = _this._moveFocusVertically.bind(_assertThisInitialized(_this), true);

      var down = _this._moveFocusVertically.bind(_assertThisInitialized(_this), false);

      var left = _this._moveFocusHorizontally.bind(_assertThisInitialized(_this), true);

      var right = _this._moveFocusHorizontally.bind(_assertThisInitialized(_this), false);

      var home = _this._moveFocusHomeEnd.bind(_assertThisInitialized(_this), true);

      var end = _this._moveFocusHomeEnd.bind(_assertThisInitialized(_this), false);

      var keys = _this._keys = new Keys(masonry, {
        context: _assertThisInitialized(_this)
      });
      keys.on('up', up).on('k', up);
      keys.on('down', down).on('j', down);
      keys.on('left', left).on('h', left);
      keys.on('right', right).on('l', right);
      keys.on('home', home);
      keys.on('end', end);
      return _this;
    }
    /**
     Hook to remove layout specific style and data from the item.
      @param item
     @private
     */
    // eslint-disable-next-line no-unused-vars


    _createClass(MasonryColumnLayout, [{
      key: "_resetItem",
      value: function _resetItem(item) {} // To override

      /**
       Initialize layout variables.
        @private
       */

    }, {
      key: "_init",
      value: function _init(items) {
        var firstItem = items[0];
        var masonry = this._masonry;
        this._columnWidth = getPositiveNumberProperty(masonry, 'columnWidth', 'columnwidth', 200);
        this._zeroOffsetLeft = -csspx(firstItem, 'marginLeft'); // with padding

        this._masonryInnerWidth = masonry.clientWidth;
        var spacing = this._masonry.spacing;

        if (typeof spacing === 'number') {
          this._horSpacing = spacing;
          this._verSpacing = spacing;
          this._offsetLeft = spacing + this._zeroOffsetLeft;
          this._offsetTop = spacing - csspx(firstItem, 'marginTop');
          this._verPadding = 2 * spacing;
          this._masonryAvailableWidth = masonry.clientWidth - spacing;
        } else {
          this._horSpacing = csspx(firstItem, 'marginLeft') + csspx(firstItem, 'marginRight');
          this._verSpacing = csspx(firstItem, 'marginTop') + csspx(firstItem, 'marginBottom');
          this._offsetLeft = csspx(masonry, 'paddingLeft');
          this._offsetTop = csspx(masonry, 'paddingTop');
          this._verPadding = this._offsetTop + this._verSpacing + csspx(masonry, 'paddingBottom');
          this._masonryAvailableWidth = masonry.clientWidth - this._offsetLeft - csspx(masonry, 'paddingRight');
        } // Initialize column objects


        var columnCount = Math.max(1, Math.floor(this._masonryAvailableWidth / (this._columnWidth + this._horSpacing)));
        this._columns.length = columnCount;

        for (var ci = 0; ci < columnCount; ci++) {
          this._columns[ci] = {
            height: this._offsetTop,
            items: []
          };
        } // Prepare layout data


        for (var ii = 0; ii < items.length; ii++) {
          var item = items[ii];
          var layoutData = item._layoutData;

          if (!layoutData) {
            item._layoutData = layoutData = {};
          } // Read colspan


          layoutData.colspan = Math.min(getPositiveNumberProperty(item, 'colspan', 'colspan', 1), this._columns.length);
        }
      }
      /**
       Updates the width of all items.
        @param items
       @private
       */

    }, {
      key: "_writeStyles",
      value: function _writeStyles(items) {
        for (var i = 0; i < items.length; i++) {
          var item = items[i];
          var layoutData = item._layoutData; // Update width

          var itemWidth = Math.round(this._getItemWidth(layoutData.colspan));

          if (layoutData.width !== itemWidth) {
            item.style.width = "".concat(itemWidth, "px");
            layoutData.width = itemWidth;
          }

          this._writeItemStyle(item);
        }
      }
      /**
       @param colspan column span of the item
       @return the width of the item for the given colspan
       @private
       */
      // eslint-disable-next-line no-unused-vars

    }, {
      key: "_getItemWidth",
      value: function _getItemWidth(colspan) {} // To override

      /**
       Hook to execute layout specific item preparation.
        @param item
       @private
       */
      // eslint-disable-next-line no-unused-vars

    }, {
      key: "_writeItemStyle",
      value: function _writeItemStyle(item) {} // To override

      /**
       Reads the dimension of all items.
        @param items
       @private
       */

    }, {
      key: "_readStyles",
      value: function _readStyles(items) {
        // Record size of items in a separate loop to avoid unneccessary reflows
        for (var i = 0; i < items.length; i++) {
          var item = items[i];
          var layoutData = item._layoutData;
          layoutData.height = Math.round(item.getBoundingClientRect().height);
          layoutData.ignored = layoutData.detached || !item.offsetParent;
        }
      }
      /**
       Update the position of all items.
        @param items
       @private
       */

    }, {
      key: "_positionItems",
      value: function _positionItems(items) {
        var j;

        for (var i = 0; i < items.length; i++) {
          var item = items[i];
          var layoutData = item._layoutData; // Skip ignored items

          if (layoutData.ignored) {
            continue;
          } // Search for column with the least height


          var maxLength = this._columns.length - (layoutData.colspan - 1);
          var minColumnIndex = -1;
          var minColumnHeight = void 0;

          for (j = 0; j < maxLength; j++) {
            // can be negative if set spacing < item css margin
            var columnHeight = this._offsetTop;

            for (var y = 0; y < layoutData.colspan; y++) {
              columnHeight = Math.max(columnHeight, this._columns[j + y].height);
            }

            if (minColumnIndex === -1 || columnHeight < minColumnHeight) {
              minColumnIndex = j;
              minColumnHeight = columnHeight;
            }
          }

          var top = minColumnHeight;
          var left = Math.round(this._getItemLeft(minColumnIndex)); // Check if position has changed

          if (layoutData.left !== left || layoutData.top !== top) {
            layoutData.columnIndex = minColumnIndex;
            layoutData.itemIndex = this._columns[minColumnIndex].items.length;
            layoutData.left = left;
            layoutData.top = top;
            setTransform(item, "translate(".concat(left, "px, ").concat(top, "px)"));
          } // Remember new column height to position all other items


          var newColumnHeight = top + layoutData.height + this._verSpacing;

          for (j = 0; j < layoutData.colspan; j++) {
            var column = this._columns[minColumnIndex + j];
            column.height = newColumnHeight;
            column.items.push(item);
          }
        }
      }
      /**
       @param columnIndex
       @return the left position for the given column index
       @private
       */
      // eslint-disable-next-line no-unused-vars

    }, {
      key: "_getItemLeft",
      value: function _getItemLeft(columnIndex) {} // To override

      /**
       @returns {number} the height of the content (independent of the current gird container height)
       @private
       */

    }, {
      key: "_getContentHeight",
      value: function _getContentHeight() {
        return this._columns.reduce(function (height, column) {
          return Math.max(height, column.height);
        }, 0) - this._offsetTop;
      }
      /**
       Hook which is called after the positioning is done.
        @param contentHeight
       @private
       */
      // eslint-disable-next-line no-unused-vars

    }, {
      key: "_postLayout",
      value: function _postLayout(contentHeight) {} // To override

      /**
       Moves the focus vertically.
        @private
       */

    }, {
      key: "_moveFocusVertically",
      value: function _moveFocusVertically(up, event) {
        var currentLayoutData = event.target._layoutData;

        if (!currentLayoutData) {
          return;
        } // Choose item above or below


        var nextItemIndex = currentLayoutData.itemIndex + (up ? -1 : 1);
        var nextItem = this._columns[currentLayoutData.columnIndex].items[nextItemIndex];

        if (nextItem) {
          nextItem.focus(); // prevent scrolling at the same time

          event.preventDefault();
        } else {
          // in case there is no item in the same column, we should move to first item in next column for down
          // and last item of previous column for up key
          var columnIndex = currentLayoutData.columnIndex;

          if (up) {
            if (columnIndex > 0) {
              // move to last item of previous column
              var prevColumn = this._columns[columnIndex - 1];

              if (prevColumn) {
                nextItem = prevColumn.items[prevColumn.items.length - 1]; // last item of previous column
              }
            }
          } else {
            // down key is pressed, go to first item of next column if exists
            var columnCount = this._columns.length;
            var nextColumnIndex = columnIndex + currentLayoutData.colspan;

            if (nextColumnIndex < columnCount) {
              nextItem = this._columns[nextColumnIndex].items[0]; // first item of next column
            }
          }

          if (nextItem) {
            nextItem.focus();
            event.preventDefault(); // prevent scrolling at the same time
          }
        }
      }
      /**
       Moves the focus horizontally.
        @private
       */

    }, {
      key: "_moveFocusHorizontally",
      value: function _moveFocusHorizontally(left, event) {
        var currentLayoutData = event.target._layoutData;

        if (!currentLayoutData) {
          return;
        }

        var nextItem;

        var items = this._masonry.items.getAll();

        var collectionItemIndex = items.indexOf(event.target);

        if (left) {
          if (collectionItemIndex > 0) {
            nextItem = items[collectionItemIndex - 1];
          }
        } else if (collectionItemIndex < items.length - 1) {
          nextItem = items[collectionItemIndex + 1];
        }

        if (nextItem) {
          nextItem.focus();
          event.preventDefault(); // prevent scrolling at the same time
        }
      }
      /**
       Moves the focus to first or last item based on the visual order.
        @private
       */

    }, {
      key: "_moveFocusHomeEnd",
      value: function _moveFocusHomeEnd(home, event) {
        var currentLayoutData = event.target._layoutData;

        if (!currentLayoutData) {
          return;
        }

        var nextItem;
        var columns = this._columns; // when home is pressed, we take the first item of the first column

        if (home) {
          nextItem = columns[0] && columns[0].items[0];
        } else {
          // when end is pressed, we take the last item of the last column; since some columns are empty, we need to
          // iterate backwards to find the first column that has items
          for (var i = columns.length - 1; i > -1; i--) {
            // since we found a column with items, we take the last item as the next one
            if (columns[i].items.length > 0) {
              nextItem = columns[i].items[columns[i].items.length - 1];
              break;
            }
          }
        }

        if (nextItem) {
          nextItem.focus(); // we prevent the scrolling

          event.preventDefault();
        }
      }
      /** @inheritdoc */

    }, {
      key: "layout",
      value: function layout(secondTry) {
        var masonry = this._masonry;
        var items = masonry.items.getAll();

        if (items.length > 0) {
          // For best possible performance none of these function calls must both read and write attributes in a loop to
          // avoid unnecessary reflows.
          this._init(items);

          this._writeStyles(items);

          this._readStyles(items);

          this._positionItems(items);
        } else {
          this._columns.length = 0;
        } // Update the height of the masonry (otherwise it has a height of 0px due to the absolutely positioned items)


        var contentHeight = this._getContentHeight();

        masonry.style.height = "".concat(contentHeight - this._verSpacing + this._verPadding, "px"); // Check if the masonry has changed its width due to the changed height (can happen because of appearing/disappearing scrollbars)

        if (!secondTry && this._masonryInnerWidth !== masonry.clientWidth) {
          this.layout(true);
        } else {
          // Post layout hook for sub classes
          this._postLayout(contentHeight);
        }
      }
      /** @inheritdoc */

    }, {
      key: "destroy",
      value: function destroy() {
        this._keys.destroy();

        var items = this._masonry.items.getAll();

        for (var i = 0; i < items.length; i++) {
          var item = items[i];
          item._layoutData = undefined;
          setTransform(item, '');

          this._resetItem(item);
        }
      }
      /** @inheritdoc */

    }, {
      key: "detach",
      value: function detach(item) {
        item._layoutData.detached = true;
      }
      /** @inheritdoc */

    }, {
      key: "reattach",
      value: function reattach(item) {
        var layoutData = item._layoutData;
        layoutData.detached = false;
        var rect = item.getBoundingClientRect(); // Disable transition while repositioning

        setTransition(item, 'none');
        item.style.left = '';
        item.style.top = '';
        setTransform(item, '');
        var nullRect = item.getBoundingClientRect();
        layoutData.left = rect.left - nullRect.left;
        layoutData.top = rect.top - nullRect.top;
        setTransform(item, "translate(".concat(layoutData.left, "px, ").concat(layoutData.top, "px)")); // Enforce position

        item.getBoundingClientRect(); // Enable transition again

        setTransition(item, '');
      }
      /** @inheritdoc */

    }, {
      key: "itemAt",
      value: function itemAt(x, y) {
        // TODO it would be more efficient to pick first the right column
        var items = this._masonry.items.getAll();

        for (var i = 0; i < items.length; i++) {
          var item = items[i];
          var layoutData = item._layoutData;

          if (layoutData && !layoutData.ignored && layoutData.left <= x && layoutData.left + layoutData.width >= x && layoutData.top <= y && layoutData.top + layoutData.height >= y) {
            return item;
          }
        }

        return null;
      }
    }]);

    return MasonryColumnLayout;
  }(MasonryLayout);

  /**
   Layout with fixed width centered items. The width of the items is defined with the <code>columnwidth</code>
   attribute.

   @example
   <coral-masonry layout="fixed-centered" columnwidth="300">

   @class Coral.Masonry.FixedCenteredLayout
   @extends {MasonryColumnLayout}
   */

  var MasonryFixedCenteredLayout = /*#__PURE__*/function (_MasonryColumnLayout) {
    _inherits(MasonryFixedCenteredLayout, _MasonryColumnLayout);

    var _super = _createSuper(MasonryFixedCenteredLayout);

    function MasonryFixedCenteredLayout() {
      _classCallCheck(this, MasonryFixedCenteredLayout);

      return _super.apply(this, arguments);
    }

    _createClass(MasonryFixedCenteredLayout, [{
      key: "_writeStyles",

      /** @inheritdoc */
      value: function _writeStyles(items) {
        this._outerColumnWidth = this._columnWidth + this._horSpacing; // If the first row isn't filled, then the items will be centered

        var filledColumns = getFirstRowFilledColumns(this._columns, items);
        this._offsetLeft += (this._masonryAvailableWidth - filledColumns * this._outerColumnWidth) / 2;

        _get(_getPrototypeOf(MasonryFixedCenteredLayout.prototype), "_writeStyles", this).call(this, items);
      }
      /** @inheritdoc */

    }, {
      key: "_getItemWidth",
      value: function _getItemWidth(colspan) {
        return this._columnWidth * colspan + this._horSpacing * (colspan - 1);
      }
      /** @inheritdoc */

    }, {
      key: "_getItemLeft",
      value: function _getItemLeft(columnIndex) {
        return this._offsetLeft + this._outerColumnWidth * columnIndex;
      }
    }]);

    return MasonryFixedCenteredLayout;
  }(MasonryColumnLayout);

  /**
   Layout with fixed width and evenly spread items. The width of the items is defined with the <code>columnwidth</code>
   attribute.

   @example
   <coral-masonry layout="fixed-spread" columnwidth="300">

   @class Coral.Masonry.FixedSpreadLayout
   @extends {MasonryColumnLayout}
   */

  var MasonryFixedSpreadLayout = /*#__PURE__*/function (_MasonryColumnLayout) {
    _inherits(MasonryFixedSpreadLayout, _MasonryColumnLayout);

    var _super = _createSuper(MasonryFixedSpreadLayout);

    function MasonryFixedSpreadLayout() {
      _classCallCheck(this, MasonryFixedSpreadLayout);

      return _super.apply(this, arguments);
    }

    _createClass(MasonryFixedSpreadLayout, [{
      key: "_writeStyles",

      /** @inheritdoc */
      value: function _writeStyles(items) {
        var columns = this._columns; // If the first row is not filled, then the items should be aligned left

        this._alignLeft = getFirstRowFilledColumns(columns, items) < columns.length;

        if (!this._alignLeft) {
          var remainingWidth = this._masonryInnerWidth - this._columnWidth * columns.length;
          this._horSpacing = remainingWidth / (columns.length + 1);
        }

        _get(_getPrototypeOf(MasonryFixedSpreadLayout.prototype), "_writeStyles", this).call(this, items);
      }
      /** @inheritdoc */

    }, {
      key: "_getItemWidth",
      value: function _getItemWidth(colspan) {
        return this._columnWidth * colspan + this._horSpacing * (colspan - 1);
      }
      /** @inheritdoc */

    }, {
      key: "_getItemLeft",
      value: function _getItemLeft(columnIndex) {
        return this._zeroOffsetLeft + this._columnWidth * columnIndex + this._horSpacing * (columnIndex + 1);
      }
    }]);

    return MasonryFixedSpreadLayout;
  }(MasonryColumnLayout);

  /**
   Layout with variable width items. The minimal width of the items is defined with the <code>columnwidth</code>
   attribute.

   @example
   <coral-masonry layout="dashboard" columnwidth="300">

   @class Coral.Masonry.VariableLayout
   @extends {MasonryColumnLayout}
   */

  var MasonryVariableLayout = /*#__PURE__*/function (_MasonryColumnLayout) {
    _inherits(MasonryVariableLayout, _MasonryColumnLayout);

    var _super = _createSuper(MasonryVariableLayout);

    function MasonryVariableLayout() {
      _classCallCheck(this, MasonryVariableLayout);

      return _super.apply(this, arguments);
    }

    _createClass(MasonryVariableLayout, [{
      key: "_getItemWidth",

      /** @inheritdoc */
      value: function _getItemWidth(colspan) {
        return this._masonryAvailableWidth / this._columns.length * colspan - this._horSpacing;
      }
      /** @inheritdoc */

    }, {
      key: "_getItemLeft",
      value: function _getItemLeft(columnIndex) {
        return this._offsetLeft + this._masonryAvailableWidth * columnIndex / this._columns.length;
      }
    }]);

    return MasonryVariableLayout;
  }(MasonryColumnLayout);

  /**
   Layout with variable width items which are expanded in their height to fill gaps (which are common with colspan).
   The minimal width of the items is defined with the <code>columnwidth</code> attribute.

   @example
   <coral-masonry layout="dashboard" columnwidth="300">

   @class Coral.Masonry.DashboardLayout
   @extends {MasonryVariableLayout}
   */

  var MasonryDashboardLayout = /*#__PURE__*/function (_MasonryVariableLayou) {
    _inherits(MasonryDashboardLayout, _MasonryVariableLayou);

    var _super = _createSuper(MasonryDashboardLayout);

    function MasonryDashboardLayout() {
      _classCallCheck(this, MasonryDashboardLayout);

      return _super.apply(this, arguments);
    }

    _createClass(MasonryDashboardLayout, [{
      key: "_writeItemStyle",

      /** @inheritdoc */
      value: function _writeItemStyle(item) {
        // Reset height because otherwise getBoundingClientRect() will not return the real height
        this._resetItem(item);
      }
      /** @inheritdoc */

    }, {
      key: "_postLayout",
      value: function _postLayout(contentHeight) {
        for (var columnIndex = 0; columnIndex < this._columns.length; columnIndex++) {
          var column = this._columns[columnIndex];
          var nextItemTop = contentHeight + this._offsetTop; // Fill gaps by expanding the height of the items

          for (var itemIndex = column.items.length - 1; itemIndex >= 0; itemIndex--) {
            var item = column.items[itemIndex];
            var layoutData = item._layoutData;

            if (layoutData.columnIndex === columnIndex) {
              var expandedHeight = nextItemTop - layoutData.top - this._verSpacing;
              item.style.height = "".concat(expandedHeight, "px");
            }

            nextItemTop = layoutData.top;
          }
        }
      }
      /** @inheritdoc */

    }, {
      key: "_resetItem",
      value: function _resetItem(item) {
        item.style.height = '';
      }
    }]);

    return MasonryDashboardLayout;
  }(MasonryVariableLayout);

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  Masonry.registerLayout(Masonry.layouts.FIXED_CENTERED, MasonryFixedCenteredLayout);
  Masonry.registerLayout(Masonry.layouts.FIXED_SPREAD, MasonryFixedSpreadLayout);
  Masonry.registerLayout(Masonry.layouts.VARIABLE, MasonryVariableLayout);
  Masonry.registerLayout(Masonry.layouts.DASHBOARD, MasonryDashboardLayout); // Expose component on the Coral namespace

  commons._define('coral-masonry-item', MasonryItem);

  commons._define('coral-masonry', Masonry);

  Masonry.Item = MasonryItem;
  Masonry.Item.AccessibilityState = MasonryItemAccessibilityState;
  Masonry.Layout = MasonryLayout;

  /**
   * Copyright 2020 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var translations$i = {
    "en-US": {
      "({0} of {1})": "({0} of {1})",
      "Remove": "Remove",
      "Reorder": "Reorder",
      "reorder_drag_handle": "move handle",
      "reorder_hint": "Drag and drop or use the up and down arrow keys to reorder.",
      "Reorder up": "Reorder up",
      "Reorder down": "Reorder down"
    },
    "fr-FR": {
      "({0} of {1})": "({0} sur {1})",
      "Remove": "Supprimer",
      "Reorder": "Réorganiser",
      "reorder_drag_handle": "déplacer la poignée",
      "reorder_hint": "Réorganisez en utilisant le glisser-déposer ou les touches fléchées haut et bas.",
      "Reorder up": "Réorganiser",
      "Reorder down": "Réorganiser vers le bas"
    },
    "de-DE": {
      "({0} of {1})": "({0} von {1})",
      "Remove": "Entfernen",
      "Reorder": "Neu sortieren",
      "reorder_drag_handle": "Verschiebepunkt",
      "reorder_hint": "Neu anordnen mit Drag & Drop oder den Aufwärts- und Abwärtspfeiltasten.",
      "Reorder up": "Neu anordnen",
      "Reorder down": "Nach unten neu anordnen"
    },
    "it-IT": {
      "({0} of {1})": "({0} di {1})",
      "Remove": "Rimuovi",
      "Reorder": "Riordina",
      "reorder_drag_handle": "maniglia di spostamento",
      "reorder_hint": "Trascina e rilascia o usa i tasti freccia su e giù per riordinare.",
      "Reorder up": "Riordina",
      "Reorder down": "Riordina verso il basso"
    },
    "es-ES": {
      "({0} of {1})": "({0} de {1})",
      "Remove": "Eliminar",
      "Reorder": "Reordenar",
      "reorder_drag_handle": "mover controlador",
      "reorder_hint": "Arrastre y suelte o use las teclas de flecha arriba y abajo para reordenar.",
      "Reorder up": "Reordenar",
      "Reorder down": "Reordenar hacia abajo"
    },
    "pt-BR": {
      "({0} of {1})": "({0} de {1})",
      "Remove": "Remover",
      "Reorder": "Reorganizar",
      "reorder_drag_handle": "mover a alça",
      "reorder_hint": "Arraste e solte ou use as teclas de seta para cima e para baixo para reordenar.",
      "Reorder up": "reordenar para cima",
      "Reorder down": "reordenar para baixo"
    },
    "ja-JP": {
      "({0} of {1})": "({0}/{1})",
      "Remove": "削除",
      "Reorder": "並べ替え",
      "reorder_drag_handle": "ハンドルを移動",
      "reorder_hint": "ドラッグアンドドロップするか、上下の矢印キーを使用して並べ替えます。",
      "Reorder up": "並べ替え",
      "Reorder down": "下に並べ替え"
    },
    "ko-KR": {
      "({0} of {1})": "({0}/{1})",
      "Remove": "제거",
      "Reorder": "재정렬",
      "reorder_drag_handle": "핸들 이동",
      "reorder_hint": "드래그 앤 드롭하거나 위 / 아래 화살표 키를 사용하여 순서를 변경하십시오.",
      "Reorder up": "재정렬",
      "Reorder down": "아래로 재정렬"
    },
    "zh-CN": {
      "({0} of {1})": "({0}/{1})",
      "Remove": "删除",
      "Reorder": "重新排序",
      "reorder_drag_handle": "移动手抦",
      "reorder_hint": "拖放或使用向上和向下箭头键重新排序。",
      "Reorder up": "重新订购",
      "Reorder down": "重新订购"
    },
    "zh-TW": {
      "({0} of {1})": "({0}/{1})",
      "Remove": "移除",
      "Reorder": "重新排序",
      "reorder_drag_handle": "移動控制點",
      "reorder_hint": "拖放或使用向上和向下箭頭鍵重新排序。",
      "Reorder up": "向上重新排列",
      "Reorder down": "向下重新排列"
    },
    "nl-NL": {
      "({0} of {1})": "({0} van {1})",
      "Remove": "Verwijderen",
      "Reorder": "Opnieuw ordenen",
      "reorder_drag_handle": "ingang verplaatsen",
      "reorder_hint": "Sleep en zet neer of gebruik de pijltoetsen omhoog en omlaag om opnieuw te ordenen.",
      "Reorder up": "Opnieuw ordenen",
      "Reorder down": "Opnieuw ordenen naar beneden"
    },
    "da-DK": {
      "({0} of {1})": "({0} af {1})",
      "Remove": "Fjern",
      "Reorder": "Omarranger",
      "reorder_drag_handle": "flyt håndtag",
      "reorder_hint": "Træk og slip eller brug piletasterne op og ned til at sortere igen.",
      "Reorder up": "Omarranger op",
      "Reorder down": "Omarranger ned"
    },
    "fi-FI": {
      "({0} of {1})": "({0}/{1})",
      "Remove": "Poista",
      "Reorder": "Järjestä uudelleen",
      "reorder_drag_handle": "siirtokahva",
      "reorder_hint": "Vedä ja pudota tai käytä ylä- ja alanuolinäppäimiä järjestyksen muuttamiseksi.",
      "Reorder up": "Järjestä uudelleen",
      "Reorder down": "Järjestä uudelleen alas"
    },
    "nb-NO": {
      "({0} of {1})": "({0} av {1})",
      "Remove": "Fjern",
      "Reorder": "Endre rekkefølge",
      "reorder_drag_handle": "flytt håndtak",
      "reorder_hint": "Dra og slipp eller bruk piltastene opp og ned for å ordne på nytt.",
      "Reorder up": "Endre rekkefølgen på nytt",
      "Reoder down": "Endre rekkefølgen nedover"
    },
    "sv-SE": {
      "({0} of {1})": "({0} av {1})",
      "Remove": "Ta bort",
      "Reorder": "Ändra ordning",
      "reorder_drag_handle": "flytta handtag",
      "reorder_hint": "Dra och släpp eller använd upp- och nedpiltangenterna för att ordna om.",
      "Reorder up": "Ändra ordning upp",
      "Reorder down": "Ändra ordning ner"
    },
    "cs-CZ": {
      "({0} of {1})": "({0} z {1})",
      "Remove": "Odebrat",
      "Reorder": "Změnit pořadí",
      "reorder_drag_handle": "táhlo přesunu",
      "reorder_hint": "Chcete-li změnit pořadí, přetáhněte nebo přetáhněte nebo použijte klávesy se šipkami nahoru a dolů.",
      "Reorder up": "Změňte pořadí směrem nahoru",
      "Reorder down": "Změňte pořadí směrem dolů"
    },
    "pl-PL": {
      "({0} of {1})": "({0} z {1})",
      "Remove": "Usuń",
      "Reorder": "Zmień kolejność",
      "reorder_drag_handle": "przeciągnij uchwyt",
      "reorder_hint": "Przeciągnij i upuść lub użyj klawiszy strzałek w górę iw dół, aby zmienić kolejność.",
      "Reorder up": "Zmień kolejność w górę",
      "Reorder down": "Zmień kolejność w dół"
    },
    "ru-RU": {
      "({0} of {1})": ", {0} из {1})",
      "Remove": "Удалить",
      "Reorder": "Переупорядочить",
      "reorder_drag_handle": "переместить манипулятор",
      "reorder_hint": "Перетащите или используйте клавиши со стрелками вверх и вниз, чтобы изменить порядок.",
      "Reorder up": "изменить порядок вверх",
      "Reorder down": "изменить порядок вниз"
    },
    "tr-TR": {
      "({0} of {1})": "({0}/{1})",
      "Remove": "Kaldır",
      "Reorder": "Yeniden Sırala",
      "reorder_drag_handle": "move handle",
      "reorder_hint": "Yeniden sıralamak için sürükleyip bırakın veya yukarı ve aşağı ok tuşlarını kullanın.",
      "Reorder up": "yukarı doğru yeniden sırala",
      "Reorder down": "Aşağı doğru yeniden sırala"
    }
  };

  var MultifieldCollection = /*#__PURE__*/function (_Collection) {
    _inherits(MultifieldCollection, _Collection);

    var _super = _createSuper(MultifieldCollection);

    function MultifieldCollection() {
      _classCallCheck(this, MultifieldCollection);

      return _super.apply(this, arguments);
    }

    _createClass(MultifieldCollection, [{
      key: "add",
      value: function add(item, insertBefore) {
        // _container and _itemTagName are the minimum options that need to be provided to automatically handle this function
        if (this._container && this._itemTagName) {
          if (!(item instanceof HTMLElement)) {
            // creates an instance of an item from the object
            item = document.createElement(this._itemTagName).set(item);
          }

          if (!insertBefore) {
            insertBefore = this.last();

            if (insertBefore) {
              // Insert before the last item
              insertBefore = insertBefore.nextElementSibling;
            }
          } // inserts the element in the specified container


          this._container.insertBefore(item, insertBefore || this._container.firstChild);

          return item;
        }
      }
    }]);

    return MultifieldCollection;
  }(Collection$1);

  var CLASSNAME$12 = '_coral-Multifield';
  var IS_DRAGGING_CLASS$1 = 'is-dragging';
  var IS_AFTER_CLASS = 'is-after';
  var IS_BEFORE_CLASS = 'is-before';
  var TEMPLATE_SUPPORT = ('content' in document.createElement('template'));
  /**
   @class Coral.Multifield
   @classdesc A Multifield component that enables adding, reordering, and removing multiple instances of a component.
   Multifield partially supports the <code>template</code> element in IE 11. If adding/removing items in the template
   is required, <code>template.content</code> should be used.
   Child elements can be given a special attribute to enable functionality:
   - <code>[coral-multifield-add]</code>. Click to add an item.
   @htmltag coral-multifield
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var Multifield = Decorator( /*#__PURE__*/function (_BaseComponent) {
    _inherits(_class, _BaseComponent);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this);

      _this.setAttribute('id', _this.id || commons.getUID()); // Attach events


      var events = {
        'coral-dragaction:dragstart coral-multifield-item': '_onDragStart',
        'coral-dragaction:drag coral-multifield-item': '_onDrag',
        'coral-dragaction:dragend coral-multifield-item': '_onDragEnd',
        'click [coral-multifield-add]': '_onAddItemClick',
        'click ._coral-Multifield-remove': '_onRemoveItemClick',
        'click [coral-multifield-move]': '_onClickDragHandle',
        'key:up [coral-multifield-move]': '_onMoveItemUp',
        'key:pageup [coral-multifield-move]': '_onMoveItemUp',
        'key:down [coral-multifield-move]': '_onMoveItemDown',
        'key:pagedown [coral-multifield-move]': '_onMoveItemDown',
        'key:home [coral-multifield-move]': '_onMoveItemHome',
        'key:end [coral-multifield-move]': '_onMoveItemEnd',
        'key:esc [coral-multifield-move]': '_onMoveItemEsc',
        'click [coral-multifield-up]': '_onUpClick',
        'click [coral-multifield-down]': '_onDownClick',
        'capture:blur [coral-multifield-move]': '_onBlurDragHandle',
        'change coral-multifield-item-content > input': '_onInputChange'
      };
      events["global:key:escape #".concat(_this.id, " > [coral-multifield-move]")] = '_onMoveItemEsc';

      _this._delegateEvents(events); // Templates


      _this._elements = {
        template: _this.querySelector("#".concat(_this.id, " > template[coral-multifield-template]")) || document.createElement('template')
      };

      _this._elements.template.setAttribute('coral-multifield-template', ''); // In case <template> is not supported


      _this._handleTemplateSupport(_this._elements.template); // Template support: move nodes added to the <template> to its content fragment


      _this._observer = new MutationObserver(function (mutations) {
        mutations.forEach(function (mutation) {
          for (var i = 0; i < mutation.addedNodes.length; i++) {
            var addedNode = mutation.addedNodes[i];
            var template = _this.template;

            if (template.contains(addedNode) && template !== addedNode) {
              // Move the node to the template content
              template.content.appendChild(addedNode); // Update all items content with the template content

              _this.items.getAll().forEach(function (item) {
                _this._renderTemplate(item);
              });

              _this._updatePosInSet();
            }
          }
        });
      }); // Watch for changes to the template element

      _this._observer.observe(_assertThisInitialized(_this), {
        childList: true,
        subtree: true
      }); // Init the collection mutation observer


      _this.items._startHandlingItems(true);

      return _this;
    }
    /**
     The Collection Interface that allows interacting with the Coral.Multifield items that the component contains.
      @type {MultifieldCollection}
     @readonly
     */


    _createClass(_class, [{
      key: "_validateMinItems",

      /**
       * Validates minimum items required. will add items, if validation fails.
       * @param schedule schedule validation in next frame
       * @ignore
       */
      value: function _validateMinItems(schedule) {
        // only validate when multifield is connected
        if (this._disconnected === false) {
          var self = this;
          var items = self.items;
          var currentLength = items.length;
          var currentMin = self.min;
          var deletable = true;

          if (currentLength <= currentMin) {
            var itemsToBeAdded = currentMin - currentLength;

            for (var i = 0; i < itemsToBeAdded; i++) {
              var item = document.createElement('coral-multifield-item');
              items.add(item);
              item._readOnly = this.readOnly;
            }

            deletable = !deletable;
          }

          if (!schedule) {
            window.cancelAnimationFrame(self._updateItemsDeletableId);
            delete self._updateItemsDeletableId;

            self._updateItemsDeletable(items.getAll(), deletable);
          } else if (!self._updateItemsDeletableId) {
            self._updateItemsDeletableId = window.requestAnimationFrame(function () {
              delete self._updateItemsDeletableId;

              self._updateItemsDeletable(items.getAll(), deletable);
            });
          }
        }
      }
      /**
       * Change the deletable property of passed items to the specified deletable value
       * @ignore
       */

    }, {
      key: "_updateItemsDeletable",
      value: function _updateItemsDeletable(items, deletable) {
        deletable = transform.boolean(deletable);
        items = !Array.isArray(items) ? [items] : items;
        items.forEach(function (item) {
          item._deletable = deletable;
        });
      }
      /** @ignore */

    }, {
      key: "_handleTemplateSupport",
      value: function _handleTemplateSupport(template) {
        // @polyfill IE
        if (!TEMPLATE_SUPPORT && !template.content) {
          var frag = document.createDocumentFragment();

          while (template.firstChild) {
            frag.appendChild(template.firstChild);
          }

          template.content = frag;
        }
      }
      /** @ignore */

    }, {
      key: "_onAddItemClick",
      value: function _onAddItemClick(event) {
        var _this2 = this;

        if (event.matchedTarget.closest('coral-multifield') === this) {
          this.items.add(document.createElement('coral-multifield-item')); // Wait for MO to render item template

          window.requestAnimationFrame(function () {
            _this2.trigger('change');

            _this2._trackEvent('click', 'add item button', event); // Focus the newly created input if it can receive focus


            var addBtn = event.target;

            var items = _this2.items.getAll();

            var setsize = items.length;
            var itemToFocus = items[setsize - 1];
            var focusableItem = itemToFocus.querySelector(commons.TABBABLE_ELEMENT_SELECTOR);

            if (focusableItem.hasAttribute('disabled')) {
              addBtn.focus();
            } else {
              focusableItem.focus();
            }
          });
        }
      }
      /** @ignore */

    }, {
      key: "_onRemoveItemClick",
      value: function _onRemoveItemClick(event) {
        if (event.matchedTarget.closest('coral-multifield') === this) {
          var item = event.matchedTarget.closest('coral-multifield-item');

          if (item) {
            // manage focus when item is removed
            var itemToFocus;
            var items = this.items.getAll();
            var setsize = items.length;

            if (setsize > 1) {
              var itemIndex = items.indexOf(item);

              if (itemIndex === setsize - 1) {
                itemToFocus = items[itemIndex - 1];
              } else {
                itemToFocus = items[itemIndex + 1];
              }
            }

            item.remove();

            if (itemToFocus) {
              itemToFocus._elements.remove.focus();
            } else {
              itemToFocus = this.querySelector('[coral-multifield-add]');

              if (itemToFocus) {
                itemToFocus.focus();
              }
            }
          }

          this.trigger('change');

          this._trackEvent('click', 'remove item button', event);
        }
      }
      /**
       * Toggles keyboard accessible dragging of the current multifield item.
       * @ignore
       */

    }, {
      key: "_toggleItemDragging",
      value: function _toggleItemDragging(multiFieldItem) {
        var dragging = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        if (multiFieldItem._dragging === dragging) {
          return;
        }

        multiFieldItem._dragging = dragging;

        if (dragging) {
          this._oldBefore = multiFieldItem.previousElementSibling;
          this._before = multiFieldItem.nextElementSibling;
        } else {
          this.trigger('coral-multifield:beforeitemorder', {
            item: multiFieldItem,
            oldBefore: this._oldBefore,
            before: this._before
          });
          this.trigger('coral-multifield:itemorder', {
            item: multiFieldItem,
            oldBefore: this._oldBefore,
            before: multiFieldItem.nextElementSibling
          });
          this.trigger('change');
          this._oldBefore = null;
          this._before = null;
        }
      }
      /**
       * Clicking dragHandle toggles keyboard accessible dragging of the current multifield item.
       * @ignore
       */

    }, {
      key: "_onClickDragHandle",
      value: function _onClickDragHandle(event) {
        event.preventDefault();
        event.stopPropagation();
        var multiFieldItem = event.matchedTarget.closest('coral-multifield-item');

        this._toggleItemDragging(multiFieldItem, !multiFieldItem._dragging);
      }
      /**
       * When the drag handle blurs, cancel dragging, leaving item where it is.
       * @ignore
       */

    }, {
      key: "_onBlurDragHandle",
      value: function _onBlurDragHandle(event) {
        var _this3 = this;

        var dragHandle = event.matchedTarget;
        var multiFieldItem = dragHandle.closest('coral-multifield-item');
        commons.nextFrame(function () {
          if (document.activeElement !== dragHandle) {
            _this3._toggleItemDragging(multiFieldItem, false);
          }
        });
      }
      /**
       * Moves multiField item selected for dragging up one index position in the multifield collection.
       * @ignore
       */

    }, {
      key: "_onMoveItemUp",
      value: function _onMoveItemUp(event) {
        var dragHandle = event.matchedTarget;
        var dragElement = dragHandle.closest('coral-multifield-item');

        if (!dragElement._dragging) {
          return;
        }

        event.preventDefault();
        event.stopPropagation();
        var items = this.items.getAll();
        var dragElementIndex = items.indexOf(dragElement);

        if (dragElementIndex > 0) {
          this.insertBefore(dragElement, dragElement.previousElementSibling);
        }

        dragElement._dragging = true;
        dragHandle.focus();
      }
      /**
       * Moves multiField item selected for dragging down one index position in the multifield collection.
       * @ignore
       */

    }, {
      key: "_onMoveItemDown",
      value: function _onMoveItemDown(event) {
        var dragHandle = event.matchedTarget;
        var dragElement = dragHandle.closest('coral-multifield-item');

        if (!dragElement._dragging) {
          return;
        }

        event.preventDefault();
        event.stopPropagation();
        var items = this.items.getAll();
        var dragElementIndex = items.indexOf(dragElement);

        if (dragElementIndex < items.length - 1) {
          var nextElement = dragElement.nextElementSibling;
          this.insertBefore(dragElement, nextElement.nextElementSibling);
        }

        dragElement._dragging = true;
        dragHandle.focus();
      }
      /**
       * Moves multiField item selected for dragging to start of multifield collection.
       * @ignore
       */

    }, {
      key: "_onMoveItemHome",
      value: function _onMoveItemHome(event) {
        var dragHandle = event.matchedTarget;
        var dragElement = dragHandle.closest('coral-multifield-item');

        if (!dragElement._dragging) {
          return;
        }

        event.preventDefault();
        event.stopPropagation();
        var items = this.items.getAll();
        var dragElementIndex = items.indexOf(dragElement);

        if (dragElementIndex > 0) {
          this.insertBefore(dragElement, this.items.first());
        }

        dragElement._dragging = true;
        dragHandle.focus();
      }
      /**
       * Moves multiField item selected for dragging to end of multifield collection.
       * @ignore
       */

    }, {
      key: "_onMoveItemEnd",
      value: function _onMoveItemEnd(event) {
        var dragHandle = event.matchedTarget;
        var dragElement = dragHandle.closest('coral-multifield-item');

        if (!dragElement._dragging) {
          return;
        }

        event.preventDefault();
        event.stopPropagation();
        var items = this.items.getAll();
        var dragElementIndex = items.indexOf(dragElement);

        if (dragElementIndex < items.length - 1) {
          this.insertBefore(dragElement, this.items.last().nextElementSibling);
        }

        dragElement._dragging = true;
        dragHandle.focus();
      }
      /**
       * Cancels keyboard drag and drop operation, restoring item to its previous location.
       * @ignore
       */

    }, {
      key: "_onMoveItemEsc",
      value: function _onMoveItemEsc(event) {
        var dragHandle = event.matchedTarget;
        var multiFieldItem = dragHandle.closest('coral-multifield-item');

        if (multiFieldItem._dragging && this._oldBefore && this._before) {
          event.stopPropagation();
          this.insertBefore(multiFieldItem, this._before);
          dragHandle.focus();
        }

        this._toggleItemDragging(multiFieldItem, false);
      }
    }, {
      key: "_onInputChange",
      value: function _onInputChange(event) {
        this._trackEvent('change', 'input', event);
      }
      /** @ignore */

    }, {
      key: "_onDragStart",
      value: function _onDragStart(event) {
        if (event.target.closest('coral-multifield') === this) {
          document.body.classList.add('u-coral-closedHand');
          var dragElement = event.detail.dragElement;
          var items = this.items.getAll();
          var dragElementIndex = items.indexOf(dragElement); // Toggle dragging state on multifield item.

          dragElement._dragging = true;
          dragElement.classList.add(IS_DRAGGING_CLASS$1);
          items.forEach(function (item, i) {
            if (i < dragElementIndex) {
              item.classList.add(IS_BEFORE_CLASS);
            } else if (i > dragElementIndex) {
              item.classList.add(IS_AFTER_CLASS);
            }
          });
        }
      }
      /** @ignore */

    }, {
      key: "_onDrag",
      value: function _onDrag(event) {
        if (event.target.closest('coral-multifield') === this) {
          var items = this.items.getAll();
          var marginBottom = 0;

          if (items.length) {
            marginBottom = parseFloat(window.getComputedStyle(items[0]).marginBottom);
          }

          items.forEach(function (item) {
            if (!item.classList.contains(IS_DRAGGING_CLASS$1)) {
              var dragElement = event.detail.dragElement;
              var dragElementBoundingClientRect = dragElement.getBoundingClientRect();
              var itemBoundingClientRect = item.getBoundingClientRect();
              var dragElementOffsetTop = dragElementBoundingClientRect.top;
              var itemOffsetTop = itemBoundingClientRect.top;
              var isAfter = dragElementOffsetTop < itemOffsetTop;
              var itemReorderedTop = "".concat(dragElementBoundingClientRect.height + marginBottom, "px");
              item.classList.toggle(IS_AFTER_CLASS, isAfter);
              item.classList.toggle(IS_BEFORE_CLASS, !isAfter);

              if (item.classList.contains(IS_AFTER_CLASS)) {
                item.style.top = items.indexOf(item) < items.indexOf(dragElement) ? itemReorderedTop : '';
              }

              if (item.classList.contains(IS_BEFORE_CLASS)) {
                var afterDragElement = items.indexOf(item) > items.indexOf(dragElement);
                item.style.top = afterDragElement ? "-".concat(itemReorderedTop) : '';
              }
            }
          });
        }
      }
      /** @ignore */

    }, {
      key: "_onDragEnd",
      value: function _onDragEnd(event) {
        if (event.target.closest('coral-multifield') === this) {
          document.body.classList.remove('u-coral-closedHand');
          var dragElement = event.detail.dragElement;
          var items = this.items.getAll();
          var beforeArr = [];
          var afterArr = [];
          items.forEach(function (item) {
            if (item.classList.contains(IS_AFTER_CLASS)) {
              afterArr.push(item);
            } else if (item.classList.contains(IS_BEFORE_CLASS)) {
              beforeArr.push(item);
            }

            item.classList.remove(IS_DRAGGING_CLASS$1, IS_AFTER_CLASS, IS_BEFORE_CLASS);
            item.style.top = '';
            item.style.position = '';
          });
          var oldBefore = dragElement.previousElementSibling;
          var before = afterArr.shift();
          var after = beforeArr.pop();
          var beforeEvent = this.trigger('coral-multifield:beforeitemorder', {
            item: dragElement,
            oldBefore: oldBefore,
            before: before
          });

          if (!beforeEvent.defaultPrevented) {
            if (before) {
              this.insertBefore(dragElement, before);
            }

            if (after) {
              this.insertBefore(dragElement, after.nextElementSibling);
            } // Toggle dragging state on multifield item.


            dragElement._dragging = false;
            this.trigger('coral-multifield:itemorder', {
              item: dragElement,
              oldBefore: oldBefore,
              before: before
            });
            this.trigger('change');

            dragElement._elements.move.focus();
          }
        }
      }
      /** @ignore */

    }, {
      key: "_onUpClick",
      value: function _onUpClick(event) {
        var upHandle = event.matchedTarget;
        var shiftElement = upHandle.closest('coral-multifield-item');

        if (shiftElement.previousElementSibling.tagName === 'CORAL-MULTIFIELD-ITEM') {
          this.insertBefore(shiftElement, shiftElement.previousElementSibling);
        }
      }
      /** @ignore */

    }, {
      key: "_onDownClick",
      value: function _onDownClick(event) {
        var upHandle = event.matchedTarget;
        var shiftElement = upHandle.closest('coral-multifield-item');

        if (shiftElement.nextElementSibling.tagName === 'CORAL-MULTIFIELD-ITEM') {
          this.insertBefore(shiftElement.nextElementSibling, shiftElement);
        }
      }
      /** @private */

    }, {
      key: "_onItemAdded",
      value: function _onItemAdded(item) {
        var self = this; // Update the item content with the template content

        if (item.parentNode === self) {
          self._renderTemplate(item);

          self._updatePosInSet();
        }

        if (self.items.length === self.min + 1) {
          self._validateMinItems();
        } // a11y


        self._handleRoleList();
      }
      /** @private */

    }, {
      key: "_onItemRemoved",
      value: function _onItemRemoved() {
        var self = this;

        self._updatePosInSet(); // only validate when required


        if (self.items.length <= self.min) {
          self._validateMinItems();
        } // a11y


        self._handleRoleList();
      }
      /**
       * handle role list of the multifield based on number of items
       * @private
       */

    }, {
      key: "_handleRoleList",
      value: function _handleRoleList() {
        var self = this;

        if (self.items.length > 0 && self.getAttribute('role') !== 'list') {
          self.setAttribute('role', 'list');
        } else if (self.items.length === 0 && self.getAttribute('role') === 'list') {
          self.removeAttribute('role');
        }
      }
      /**
       * update aria-posinset and aria-setsize for each item in the collection
       * @private
       */

    }, {
      key: "_updatePosInSet",
      value: function _updatePosInSet() {
        var items = this.items.getAll();
        var setsize = items.length;
        items.forEach(function (item, i) {
          item.setAttribute('aria-posinset', i + 1);
          item.setAttribute('aria-setsize', setsize);
          item.setAttribute('aria-label', i18n.get('({0} of {1})', i + 1, setsize)); // so long as item content is not another multifield,
          // add aria-labelledby so that the item is labelled by its content and itself.

          if (!item.querySelector('coral-multifield')) {
            item.setAttribute('aria-labelledby', "".concat(item.id, "-content ").concat(item.id));
          }
        });
      }
      /** @private */

    }, {
      key: "_renderTemplate",
      value: function _renderTemplate(item) {
        var content = item.content || item.querySelector('coral-multifield-item-content') || item; // Insert the template if item content is empty

        if (!content.firstChild) {
          // @polyfill IE
          if (!TEMPLATE_SUPPORT) {
            // Before cloning, put the nested templates content back in the DOM
            var nestedTemplates = this.template.content.querySelectorAll('template[coral-multifield-template]');
            Array.prototype.forEach.call(nestedTemplates, function (template) {
              while (template.content.firstChild) {
                template.appendChild(template.content.firstChild);
              }
            });
          } // Clone the template and append it to the item content


          content.appendChild(document.importNode(this.template.content, true));
        }
      }
    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        var _this4 = this;

        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$12, 'coral-Well'); // a11y

        this._handleRoleList(); // a11y Add aria-label to the add button if exists to give context to screen reader users


        var coralMultifieldAddBtn = this.querySelector('[coral-multifield-add]');

        if (coralMultifieldAddBtn) {
          coralMultifieldAddBtn.setAttribute("aria-label", "Add");
        } // Assign the content zones, moving them into place in the process


        this.template = this._elements.template; // Prepare items content based on the given template

        this.items.getAll().forEach(function (item) {
          _this4._renderTemplate(item);
        }); // update aria-posinset and aria-setsize for each item in the collection

        this._updatePosInSet();

        this._validateMinItems(true);
      }
      /**
       Triggered when the {@link Multifield} item are reordered.
        @typedef {CustomEvent} coral-multifield:beforeitemorder
        @property {MultifieldItem} detail.item
       The item to be ordered.
       @property {MultifieldItem} detail.oldBefore
       Ordered item next sibling before the swap. If <code>null</code>, the item was the last item.
       @property {MultifieldItem} detail.before
       Ordered item will be inserted before this sibling item. If <code>null</code>, the item is inserted at the end.
       */

      /**
       Triggered when the {@link Multifield} item are reordered.
        @typedef {CustomEvent} coral-multifield:itemorder
        @property {MultifieldItem} detail.item
       The ordered item.
       @property {MultifieldItem} detail.oldBefore
       Ordered item next sibling before the swap. If <code>null</code>, the item was the last item.
       @property {MultifieldItem} detail.before
       Ordered item was inserted before this sibling item. If <code>null</code>, the item was inserted at the end.
       */

    }, {
      key: "items",
      get: function get() {
        // just init on demand
        if (!this._items) {
          this._items = new MultifieldCollection({
            host: this,
            itemTagName: 'coral-multifield-item',
            // allows multifields to be nested
            itemSelector: ':scope > coral-multifield-item',
            onlyHandleChildren: true,
            onItemAdded: this._onItemAdded,
            onItemRemoved: this._onItemRemoved
          });
        }

        return this._items;
      }
      /**
       The Multifield template element. It will be used to render a new item once the element with the attribute
       <code>coral-multifield-add</code> is clicked. It supports the <code>template</code> tag. While specifying the
       template from markup, it should include the <code>coral-multifield-template</code> attribute.
       NOTE: On IE11, only <code>template.content</code> is supported to add/remove elements to the template.
        @type {HTMLElement}
       @contentzone
       */

    }, {
      key: "template",
      get: function get() {
        return this._getContentZone(this._elements.template);
      },
      set: function set(value) {
        this._setContentZone('template', value, {
          handle: 'template',
          tagName: 'template',
          insert: function insert(template) {
            this.appendChild(template);
          },
          set: function set(content) {
            // Additionally add support for template
            this._handleTemplateSupport(content);
          }
        });
      }
      /**
       Whether this multifield is readOnly or not. Indicating that the user cannot modify the value of the multifield fields.
       @type {Boolean}
       @default false
       @htmlattribute readonly
       @htmlattributereflected
       */

    }, {
      key: "readOnly",
      get: function get() {
        return this._readOnly || false;
      },
      set: function set(value) {
        value = transform.booleanAttr(value);
        this._readOnly = value;

        this._reflectAttribute('readonly', value);

        this.items.getAll().forEach(function (item) {
          item[value ? 'setAttribute' : 'removeAttribute']('_readonly', '');
        });
        var addBtn = this.querySelector('[coral-multifield-add]');

        if (addBtn) {
          addBtn.disabled = value;
        }
      }
      /**
        Specifies the minimum number of items multifield should render.
        If component contains less items, remaining items will be added.
         @type {Number}
        @default 0
        @htmlattribute min
        @htmlattributereflected
        */

    }, {
      key: "min",
      get: function get() {
        return this._min || 0;
      },
      set: function set(value) {
        var self = this;
        value = transform.number(value);

        if (value && validate.valueMustChange(self._min, value)) {
          self._min = value;

          self._reflectAttribute('min', value);

          self._validateMinItems();
        }
      }
    }, {
      key: "reorderUpDown",

      /**
       Whether this multifield require up and down buttons.
       @type {Boolean}
       @default false
       @htmlattribute reorderupdown
       @htmlattributereflected
       */
      get: function get() {
        return this._reorderUpDown || false;
      },
      set: function set(value) {
        value = transform.booleanAttr(value);
        this._reorderUpDown = value;

        this._reflectAttribute('reorderupdown', value);
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          template: 'template'
        };
      }
      /** @ignore */

    }], [{
      key: "_attributePropertyMap",
      get: function get() {
        return commons.extend(_get(_getPrototypeOf(_class), "_attributePropertyMap", this), {
          reorderupdown: 'reorderUpDown',
          readonly: 'readOnly'
        });
      }
    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['min', 'readonly', 'reorderupdown']);
      }
    }]);

    return _class;
  }(BaseComponent(HTMLElement)));

  var template$J = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["remove"] = document.createElement("button", "coral-button");
    el0.id = data_0["uid"] + "-remove";
    el0.setAttribute("aria-labelledby", data_0["uid"] + "-remove " + data_0["uid"] + "-content " + data_0["uid"]);
    el0.setAttribute("aria-label", data_0["i18n"]["get"]('Remove'));
    el0.setAttribute("title", data_0["i18n"]["get"]('Remove'));
    el0.setAttribute("tracking", "off");
    el0.setAttribute("type", "button");
    el0.setAttribute("is", "coral-button");
    el0.setAttribute("handle", "remove");
    el0.setAttribute("variant", "quietaction");
    el0.setAttribute("icon", "delete");
    el0.setAttribute("iconsize", "S");
    el0.setAttribute("iconautoarialabel", "on");
    el0.className += " _coral-Multifield-remove";
    el0.setAttribute("coral-multifield-remove", "");
    frag.appendChild(el0);
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    var el2 = this["move"] = document.createElement("button", "coral-button");
    el2.id = data_0["uid"] + "-reorder";
    el2.setAttribute("aria-labelledby", data_0["uid"] + "-reorder " + data_0["uid"] + "-content " + data_0["uid"]);
    el2.setAttribute("aria-label", data_0["i18n"]["get"]('Reorder'));
    el2.setAttribute("aria-roledescription", data_0["i18n"]["get"]('reorder_drag_handle'));
    el2.setAttribute("aria-grabbed", "false");
    el2.setAttribute("aria-pressed", "false");
    el2.setAttribute("title", data_0["i18n"]["get"]('reorder_hint'));
    el2.setAttribute("tracking", "off");
    el2.setAttribute("type", "button");
    el2.setAttribute("is", "coral-button");
    el2.setAttribute("handle", "move");
    el2.setAttribute("variant", "quietaction");
    el2.setAttribute("icon", "moveUpDown");
    el2.setAttribute("iconsize", "S");
    el2.setAttribute("iconautoarialabel", "on");
    el2.className += " _coral-Multifield-move u-coral-openHand";
    el2.setAttribute("coral-multifield-move", "");
    frag.appendChild(el2);
    var el3 = document.createTextNode("\n");
    frag.appendChild(el3);
    var el4 = this["reorderup"] = document.createElement("button", "coral-button");
    el4.id = data_0["uid"] + "-up";
    el4.setAttribute("aria-labelledby", data_0["uid"] + "-up " + data_0["uid"] + "-content " + data_0["uid"]);
    el4.setAttribute("aria-label", data_0["i18n"]["get"]('Reorder up'));
    el4.setAttribute("aria-grabbed", "false");
    el4.setAttribute("aria-pressed", "false");
    el4.setAttribute("title", data_0["i18n"]["get"]('reorder_hint'));
    el4.setAttribute("tracking", "off");
    el4.setAttribute("type", "button");
    el4.setAttribute("is", "coral-button");
    el4.setAttribute("handle", "reorderup");
    el4.setAttribute("variant", "quietaction");
    el4.setAttribute("icon", "ChevronUp");
    el4.setAttribute("iconsize", "S");
    el4.setAttribute("iconautoarialabel", "on");
    el4.className += " _coral-Multifield-up u-coral-openHand";
    el4.setAttribute("coral-multifield-up", "");
    frag.appendChild(el4);
    var el5 = document.createTextNode("\n");
    frag.appendChild(el5);
    var el6 = this["reorderdown"] = document.createElement("button", "coral-button");
    el6.id = data_0["uid"] + "-down";
    el6.setAttribute("aria-labelledby", data_0["uid"] + "-down " + data_0["uid"] + "-content " + data_0["uid"]);
    el6.setAttribute("aria-label", data_0["i18n"]["get"]('Reorder down'));
    el6.setAttribute("aria-grabbed", "false");
    el6.setAttribute("aria-pressed", "false");
    el6.setAttribute("title", data_0["i18n"]["get"]('reorder_hint'));
    el6.setAttribute("tracking", "off");
    el6.setAttribute("type", "button");
    el6.setAttribute("is", "coral-button");
    el6.setAttribute("handle", "reorderdown");
    el6.setAttribute("variant", "quietaction");
    el6.setAttribute("icon", "ChevronDown");
    el6.setAttribute("iconsize", "S");
    el6.setAttribute("iconautoarialabel", "on");
    el6.className += " _coral-Multifield-down u-coral-openHand";
    el6.setAttribute("coral-multifield-down", "");
    frag.appendChild(el6);
    var el7 = document.createTextNode("\n");
    frag.appendChild(el7);
    return frag;
  };

  var CLASSNAME$13 = '_coral-Multifield-item';
  /**
   @class Coral.Multifield.Item
   @classdesc A Multifield item component. It can have a pre-filled content different from the Multifield template but
   added items will always be rendered based on the template.
   @htmltag coral-multifield-item
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var MultifieldItem = Decorator( /*#__PURE__*/function (_BaseComponent) {
    _inherits(_class, _BaseComponent);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this); // Prepare templates

      _this._elements = {
        // Create or fetch the content zones
        content: _this.querySelector('coral-multifield-item-content') || document.createElement('coral-multifield-item-content')
      };
      var uid = _this.id || commons.getUID();

      _this.setAttribute('id', uid);

      _this._elements.content.setAttribute('id', "".concat(uid, "-content"));

      template$J.call(_this._elements, {
        i18n: i18n,
        uid: uid
      });
      return _this;
    }
    /**
     The item content.
      @type {MultifieldItemContent}
     @contentzone
     */


    _createClass(_class, [{
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$13); // a11y

        this.setAttribute('role', 'listitem'); // Create a fragment

        var fragment = document.createDocumentFragment();
        var templateHandleNames = ['move', 'remove', 'reorderup', 'reorderdown']; // Render the main template

        fragment.appendChild(this._elements.remove);
        fragment.appendChild(this._elements.move);
        fragment.appendChild(this._elements.reorderup);
        fragment.appendChild(this._elements.reorderdown);
        var content = this._elements.content; // Remove it so we can process children

        if (content.parentNode) {
          this.removeChild(content);
        } // Process remaining elements as necessary


        while (this.firstChild) {
          var child = this.firstChild;

          if (child.nodeType === Node.TEXT_NODE || child.nodeType === Node.ELEMENT_NODE && templateHandleNames.indexOf(child.getAttribute('handle')) === -1) {
            // Add non-template elements to the label
            content.appendChild(child);
          } else {
            // Remove anything else
            this.removeChild(child);
          }
        } // Add the frag to the component


        this.appendChild(fragment); // Assign the content zones, moving them into place in the process

        this.content = content; // Attach drag events

        var dragAction = new DragAction(this);
        dragAction.axis = 'vertical';
        dragAction.handle = this._elements.move;
      }
    }, {
      key: "content",
      get: function get() {
        return this._getContentZone(this._elements.content);
      },
      set: function set(value) {
        this._setContentZone('content', value, {
          handle: 'content',
          tagName: 'coral-multifield-item-content',
          insert: function insert(content) {
            // Insert the content zone before the move and remove buttons
            this.insertBefore(content, this.firstChild);
          }
        });
      }
      /**
        Specify whether the remove button is in disabled state or not.
         @type {Boolean}
        @default false
        @private
        */

    }, {
      key: "_deletable",
      get: function get() {
        return typeof this.__deletable === 'boolean' ? this.__deletable : true;
      },
      set: function set(value) {
        value = transform.boolean(value);
        this.__deletable = value;

        if (!this._readOnly) {
          this._elements.remove.disabled = !value;
        }
      }
      /**
       Whether the item is set to be reorder using the keyboard
        @type {boolean}
       @private
       */

    }, {
      key: "_dragging",
      get: function get() {
        return this.__dragging || false;
      },
      set: function set(value) {
        this.__dragging = transform.boolean(value);

        if (this.__dragging) {
          // Setting role="application" to the move button forces
          // NVDA and JAWS screen readers into forms mode,
          // so arrow keys can be used to reorder.
          this._elements.move.setAttribute('role', 'application');
        } else {
          // when reordering stops, restore the default role for the move button
          this._elements.move.removeAttribute('role');
        } // aria-grabbed, may be deprecated in WAI-ARIA 1.1, but it is still reported by NVDA as "draggable" or "dragging"


        this._elements.move.setAttribute('aria-grabbed', this.__dragging);

        this._elements.move.setAttribute('aria-pressed', this.__dragging);

        this._elements.move.selected = this.__dragging;
      }
      /**
       Whether this multifieldItem is readOnly or not. Indicating that the user cannot modify the value of the multifieldItem fields.
       @type {Boolean}
       @default false
       @private
       */

    }, {
      key: "_readOnly",
      get: function get() {
        return this.__readOnly || false;
      },
      set: function set(value) {
        value = transform.booleanAttr(value);
        this.__readOnly = value;

        this._reflectAttribute('_readonly', value); // get all fields and set readonly to those whose has this property


        var allFields = this.querySelectorAll("*");
        Array.prototype.forEach.call(allFields, function (field) {
          if (typeof field.readOnly === "boolean") {
            field.readOnly = value;
          }
        });
        this._elements.move.disabled = value;
        this._elements.remove.disabled = value;
        this._elements.reorderup.disabled = value;
        this._elements.reorderdown.disabled = value;
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-multifield-item-content': 'content'
        };
      }
      /** @ignore */

    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['_readonly']);
      }
      /** @ignore */

    }, {
      key: "_attributePropertyMap",
      get: function get() {
        return commons.extend(_get(_getPrototypeOf(_class), "_attributePropertyMap", this), {
          _readonly: '_readOnly'
        });
      }
    }]);

    return _class;
  }(BaseComponent(HTMLElement)));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Multifield.Item.Content
   @classdesc The Multifield item content
   @htmltag coral-multifield-item-content
   @return {HTMLElement}
   */
  var MultifieldItemContent = (function () {
    return document.createElement('coral-multifield-item-content');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons.extend(strings, {
    'coral-component-multifield': translations$i
  }); // Expose component on the Coral namespace

  commons._define('coral-multifield-item', MultifieldItem);

  commons._define('coral-multifield', Multifield);

  Multifield.Item = MultifieldItem;
  Multifield.Item.Content = MultifieldItemContent;

  var CLASSNAME$14 = '_coral-PanelStack';
  /**
   @class Coral.PanelStack
   @classdesc A PanelStack component holding a collection of panels. It wraps content, keeping only the selected panel in view.
   @htmltag coral-panelstack
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var PanelStack = Decorator( /*#__PURE__*/function (_BaseComponent) {
    _inherits(_class, _BaseComponent);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this); // Attach events

      _this._delegateEvents({
        // private
        'coral-panel:_selectedchanged': '_onItemSelectedChanged'
      }); // Used for eventing


      _this._oldSelection = null; // Init the collection mutation observer

      _this.items._startHandlingItems(true);

      return _this;
    }
    /**
     The Collection Interface that allows interacting with the items that the component contains.
      @type {SelectableCollection}
     @readonly
     */


    _createClass(_class, [{
      key: "_onItemSelectedChanged",

      /** @private */
      value: function _onItemSelectedChanged(event) {
        event.stopImmediatePropagation();

        this._validateSelection(event.target);
      }
      /** @private */

    }, {
      key: "_validateSelection",
      value: function _validateSelection(item) {
        var _this2 = this;

        var selectedItems = this.items._getAllSelected(); // Last selected item wins if multiple selection while not allowed


        item = item || selectedItems[selectedItems.length - 1];

        if (item && item.hasAttribute('selected') && selectedItems.length > 1) {
          selectedItems.forEach(function (selectedItem) {
            if (selectedItem !== item) {
              // Don't trigger change events
              _this2._preventTriggeringEvents = true;
              selectedItem.removeAttribute('selected');
            }
          }); // We can trigger change events again

          this._preventTriggeringEvents = false;
        }

        this._triggerChangeEvent();
      }
      /** @private */

    }, {
      key: "_triggerChangeEvent",
      value: function _triggerChangeEvent() {
        var selectedItem = this.selectedItem;
        var oldSelection = this._oldSelection;

        if (!this._preventTriggeringEvents && selectedItem !== oldSelection) {
          this.trigger('coral-panelstack:change', {
            oldSelection: oldSelection,
            selection: selectedItem
          });
          this._oldSelection = selectedItem;
        }
      }
      /** @ignore */

    }, {
      key: "render",
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$14);
        this.setAttribute('role', 'presentation'); // Don't trigger events once connected

        this._preventTriggeringEvents = true;

        this._validateSelection();

        this._preventTriggeringEvents = false;
        this._oldSelection = this.selectedItem;
      }
      /**
       Triggered when {@link PanelStack} selected panel has changed.
        @typedef {CustomEvent} coral-panelstack:change
        @property {Panel} detail.selection
       The new selected panel.
       @property {Panel} detail.oldSelection
       The prior selected panel.
       */

    }, {
      key: "items",
      get: function get() {
        // just init on demand
        if (!this._items) {
          this._items = new SelectableCollection({
            host: this,
            itemTagName: 'coral-panel',
            // allows panels to be nested
            itemSelector: ':scope > coral-panel',
            onlyHandleChildren: true,
            onItemAdded: this._validateSelection,
            onItemRemoved: this._validateSelection
          });
        }

        return this._items;
      }
      /**
       The selected item of the PanelStack.
        @type {HTMLElement}
       @readonly
       */

    }, {
      key: "selectedItem",
      get: function get() {
        return this.items._getLastSelected();
      }
    }]);

    return _class;
  }(BaseComponent(HTMLElement)));

  var CLASSNAME$15 = '_coral-Panel';
  /**
   @class Coral.Panel
   @classdesc A Panel component
   @htmltag coral-panel
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var Panel = Decorator( /*#__PURE__*/function (_BaseComponent) {
    _inherits(_class, _BaseComponent);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this); // Templates

      _this._elements = {
        content: _this.querySelector('coral-panel-content') || document.createElement('coral-panel-content')
      };
      return _this;
    }
    /**
     The content of the panel.
      @type {PanelContent}
     @contentzone
     */


    _createClass(_class, [{
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$15); // Adds the role to support accessibility when role is not already defined.

        if (!this.hasAttribute('role')) {
          this.setAttribute('role', 'region');
        } // Fetch the content zone elements


        var content = this._elements.content; // Move the content into the content zone if none specified

        if (!content.parentNode) {
          while (this.firstChild) {
            content.appendChild(this.firstChild);
          }
        } // Assign the content zone so the insert function will be called


        this.content = content;
      }
    }, {
      key: "content",
      get: function get() {
        return this._getContentZone(this._elements.content);
      },
      set: function set(value) {
        this._setContentZone('content', value, {
          handle: 'content',
          tagName: 'coral-panel-content',
          insert: function insert(content) {
            this.appendChild(content);
          }
        });
      }
      /**
       Whether the item is selected. When true, the item will appear as the active element in the PanelStack. The item
       must be a child of a PanelStack before this property is set to true. This property cannot be programmatically set
       to false.
        @type {Boolean}
       @default false
       @htmlattribute selected
       @htmlattributereflected
       */

    }, {
      key: "selected",
      get: function get() {
        return this._selected || false;
      },
      set: function set(value) {
        var _selected = transform.booleanAttr(value);

        if (this._selected === _selected) {
          return;
        }

        this._selected = _selected;

        this._reflectAttribute('selected', this._selected);

        this.classList.toggle('is-selected', this._selected);
        this.setAttribute('aria-hidden', !this.selected);
        this.trigger('coral-panel:_selectedchanged');
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-panel-content': 'content'
        };
      }
      /** @ignore */

    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['selected']);
      }
    }]);

    return _class;
  }(BaseComponent(HTMLElement)));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Panel.Content
   @classdesc A PanelStack Item Content component
   @htmltag coral-panel-content
   @return {HTMLElement}
   */
  var PanelContent = (function () {
    return document.createElement('coral-panel-content');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons._define('coral-panelstack', PanelStack);

  commons._define('coral-panel', Panel);

  Panel.Content = PanelContent;

  var template$K = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["percentage"] = document.createElement("div");
    el0.className += " _coral-BarLoader-percentage";
    el0.setAttribute("handle", "percentage");
    el0.setAttribute("aria-hidden", "true");
    el0.setAttribute("style", "visibility: hidden");
    frag.appendChild(el0);
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    var el2 = this["bar"] = document.createElement("div");
    el2.setAttribute("handle", "bar");
    el2.className += " _coral-BarLoader-track";
    var el3 = document.createTextNode("\n  ");
    el2.appendChild(el3);
    var el4 = this["status"] = document.createElement("div");
    el4.className += " _coral-BarLoader-fill";
    el4.setAttribute("handle", "status");
    el2.appendChild(el4);
    var el5 = document.createTextNode("\n");
    el2.appendChild(el5);
    frag.appendChild(el2);
    var el6 = document.createTextNode("\n");
    frag.appendChild(el6);
    return frag;
  };

  /**
   Enumeration for {@link Progress} sizes.

   @typedef {Object} ProgressSizeEnum

   @property {String} SMALL
   A small progress bar.
   @property {String} MEDIUM
   A default medium progress bar.
   @property {String} LARGE
   Not supported. Falls back to MEDIUM.
   */

  var size$6 = {
    SMALL: 'S',
    MEDIUM: 'M',
    LARGE: 'L'
  };
  /**
   Enumeration for {@link Progress} label positions.

   @typedef {Object} ProgressLabelPositionEnum

   @property {String} LEFT
   Show the label to the left of the bar.
   @property {String} SIDE
   Show the label to the side of the bar.
   @property {String} RIGHT
   Not supported. Falls back to LEFT.
   @property {String} BOTTOM
   Not supported. Falls back to LEFT.
   */

  var labelPosition = {
    LEFT: 'left',
    RIGHT: 'right',
    SIDE: 'side',
    BOTTOM: 'bottom'
  }; // Base classname

  var CLASSNAME$16 = '_coral-BarLoader';
  /**
   @class Coral.Progress
   @classdesc A Progress component to indicate progress of processes.
   @htmltag coral-progress
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var Progress = Decorator( /*#__PURE__*/function (_BaseComponent) {
    _inherits(_class, _BaseComponent);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this); // Prepare templates

      _this._elements = {
        // Fetch or create the content content zone element
        label: _this.querySelector('coral-progress-label') || document.createElement('coral-progress-label')
      };
      template$K.call(_this._elements); // Watch for label changes

      _this._observer = new MutationObserver(_this._toggleLabelVisibility.bind(_assertThisInitialized(_this)));

      _this._observer.observe(_this._elements.label, {
        characterData: true,
        childList: true,
        subtree: true
      });

      return _this;
    }
    /**
     The current progress in percent.
      @type {Number}
     @default 0
     @emits {coral-progress:change}
     @htmlattribute value
     @htmlattributereflected
     */


    _createClass(_class, [{
      key: "_toggleLabelVisibility",

      /** @ignore */
      value: function _toggleLabelVisibility() {
        var percentage = this._elements.percentage;
        var label = this._elements.label;
        var isSidePositioned = this.labelPosition === labelPosition.SIDE; // Handle percentage

        if (this.showPercent) {
          percentage.style.visibility = 'visible';
          percentage.setAttribute('aria-hidden', 'false');

          if (isSidePositioned) {
            percentage.hidden = false;
          }
        } else {
          percentage.style.visibility = 'hidden';
          percentage.setAttribute('aria-hidden', 'true');

          if (isSidePositioned) {
            percentage.hidden = true;
          }
        } // Handle label


        if (label.textContent.length > 0) {
          label.style.visibility = 'visible';
          label.setAttribute('aria-hidden', 'false');

          if (isSidePositioned) {
            label.hidden = false;
          }

          if (!this.showPercent) {
            // Update the value for accessibility as it was cleared when the label was hidden
            this.setAttribute('aria-valuetext', label.textContent);
          }
        } else {
          label.style.visibility = 'hidden';
          label.setAttribute('aria-hidden', 'true');

          if (isSidePositioned) {
            label.hidden = true;
          } // Remove the value for accessibility so the screenreader knows we're unlabelled


          this.removeAttribute('aria-valuetext');
        }
      }
      /** @ignore */

    }, {
      key: "_setPercentage",
      value: function _setPercentage(content) {
        this._elements.percentage.textContent = content; // ARIA

        this[this.showPercent ? 'removeAttribute' : 'setAttribute']('aria-valuetext', content);
      }
    }, {
      key: "attributeChangedCallback",

      /** @ignore */
      value: function attributeChangedCallback(name, oldValue, value) {
        if (name === 'indeterminate' && transform.booleanAttr(value)) {
          // Remember current value in case indeterminate is toggled
          this._oldValue = this._value || 0;
        }

        _get(_getPrototypeOf(_class.prototype), "attributeChangedCallback", this).call(this, name, oldValue, value);
      }
      /** @ignore */

    }, {
      key: "render",
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$16); // Default reflected attributes

        if (!this._value) {
          this.value = this.value;
        }

        if (!this._size) {
          this.size = size$6.MEDIUM;
        }

        if (!this._labelPosition) {
          this.labelPosition = labelPosition.LEFT;
        } // Create a fragment


        var fragment = document.createDocumentFragment();
        var templateHandleNames = ['bar', 'percentage']; // Render the template

        fragment.appendChild(this._elements.percentage);
        fragment.appendChild(this._elements.bar);
        var label = this._elements.label; // Remove it so we can process children

        if (label.parentNode) {
          label.parentNode.removeChild(label);
        } // Move any remaining elements into the content sub-component


        while (this.firstChild) {
          var child = this.firstChild;

          if (child.nodeType === Node.TEXT_NODE || child.nodeType === Node.ELEMENT_NODE && templateHandleNames.indexOf(child.getAttribute('handle')) === -1) {
            // Add non-template elements to the label
            label.appendChild(child);
          } else {
            // Remove anything else
            this.removeChild(child);
          }
        } // Add the frag to the component


        this.appendChild(fragment); // Assign the content zone

        this.label = label; // Toggle label based on content

        this._toggleLabelVisibility(); // ARIA


        this.setAttribute('role', 'progressbar');
        this.setAttribute('aria-valuenow', '0');
        this.setAttribute('aria-valuemin', '0');
        this.setAttribute('aria-valuemax', '100');
      }
      /**
       Triggered when the {@link Progress} value is changed.
        @typedef {CustomEvent} coral-progress:change
       */

    }, {
      key: "value",
      get: function get() {
        return this.indeterminate ? 0 : this._value || 0;
      },
      set: function set(value) {
        value = transform.number(value) || 0; // Stay within bounds

        if (value > 100) {
          value = 100;
        } else if (value < 0) {
          value = 0;
        }

        this._value = value;

        this._reflectAttribute('value', this._value);

        if (!this.indeterminate) {
          this._elements.status.style.width = "".concat(this.value, "%"); // ARIA: Reflect value for screenreaders

          this.setAttribute('aria-valuenow', this._value);

          if (this.showPercent) {
            // Only update label text in percent mode
            this._setPercentage("".concat(this._value, "%"));
          }
        } else {
          this._elements.status.style.width = '';
        }

        this.trigger('coral-progress:change');
      }
      /**
       Whether to hide the current value and show an animation. Set to true for operations whose progress cannot be
       determined.
        @type {Boolean}
       @default false
       @htmlattribute indeterminate
       @htmlattributereflected
       */

    }, {
      key: "indeterminate",
      get: function get() {
        return this._indeterminate || false;
      },
      set: function set(value) {
        this._indeterminate = transform.booleanAttr(value);

        this._reflectAttribute('indeterminate', this._indeterminate);

        if (this._indeterminate) {
          this.classList.add("".concat(CLASSNAME$16, "--indeterminate")); // ARIA: Remove attributes

          this.removeAttribute('aria-valuenow');
          this.removeAttribute('aria-valuemin');
          this.removeAttribute('aria-valuemax');
          this.value = 0;
        } else {
          this.classList.remove("".concat(CLASSNAME$16, "--indeterminate")); // ARIA: Add attributes

          this.setAttribute('aria-valuemin', '0');
          this.setAttribute('aria-valuemax', '100');
          this.value = this._oldValue;
        }
      }
      /**
       The vertical and text size of this progress bar. To adjust the width, simply set the CSS width property.
       See {@link ProgressSizeEnum}.
        @type {String}
       @default ProgressSizeEnum.MEDIUM
       @htmlattribute size
       @htmlattributereflected size
       */

    }, {
      key: "size",
      get: function get() {
        return this._size || size$6.MEDIUM;
      },
      set: function set(value) {
        value = transform.string(value).toUpperCase();
        this._size = validate.enumeration(size$6)(value) && value || size$6.MEDIUM;

        this._reflectAttribute('size', this._size);

        this.classList.toggle("".concat(CLASSNAME$16, "--small"), this._size === size$6.SMALL);
      }
      /**
       Boolean attribute to toggle showing progress percent as the label content.
       Default is true.
        @type {Boolean}
       @default false
       @htmlattribute showpercent
       */

    }, {
      key: "showPercent",
      get: function get() {
        return this._showPercent || false;
      },
      set: function set(value) {
        this._showPercent = transform.booleanAttr(value);

        this._reflectAttribute('showpercent', this._showPercent);

        if (this._showPercent) {
          var content = this.indeterminate ? '' : "".concat(this.value, "%");

          this._setPercentage(content);
        }

        this._toggleLabelVisibility();
      }
      /**
       Used to access to the {@link Coral.Progress.Label} element. Keep in mind that the width of a custom label is
       limited for {@link Coral.Progress.labelPosition.LEFT} and {@link Coral.Progress.labelPosition.RIGHT}.
        @type {ProgressLabel}
       @contentzone
       */

    }, {
      key: "label",
      get: function get() {
        return this._getContentZone(this._elements.label);
      },
      set: function set(value) {
        this._setContentZone('label', value, {
          handle: 'label',
          tagName: 'coral-progress-label',
          insert: function insert(label) {
            label.classList.add("".concat(CLASSNAME$16, "-label"));
            this.appendChild(label);
          }
        });
      }
      /**
       Label position. See {@link ProgressLabelPositionEnum}.
        @type {String}
       @default ProgressLabelPositionEnum.LEFT
       @htmlattribute labelposition
       @htmlattributereflected
       */

    }, {
      key: "labelPosition",
      get: function get() {
        return this._labelPosition || labelPosition.LEFT;
      },
      set: function set(value) {
        var _this2 = this;

        value = transform.string(value).toLowerCase();
        this._labelPosition = validate.enumeration(labelPosition)(value) && value || labelPosition.LEFT;

        this._reflectAttribute('labelposition', this._labelPosition);

        this.classList.toggle('_coral-BarLoader--sideLabel', this._labelPosition === labelPosition.SIDE);
        var elements = this.labelPosition === labelPosition.SIDE ? ['label', 'bar', 'percentage'] : ['label', 'percentage', 'bar']; // @spectrum should be supported with classes

        elements.forEach(function (el, i) {
          _this2._elements[el].style.order = i;
        });

        this._toggleLabelVisibility();
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-progress-label': 'label'
        };
      }
      /**
       Returns {@link Progress} label position options.
        @return {ProgressLabelPositionEnum}
       */

    }], [{
      key: "labelPosition",
      get: function get() {
        return labelPosition;
      }
      /**
       Returns {@link Progress} sizes.
        @return {ProgressSizeEnum}
       */

    }, {
      key: "size",
      get: function get() {
        return size$6;
      }
    }, {
      key: "_attributePropertyMap",
      get: function get() {
        return commons.extend(_get(_getPrototypeOf(_class), "_attributePropertyMap", this), {
          showpercent: 'showPercent',
          labelposition: 'labelPosition'
        });
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['value', 'indeterminate', 'size', 'showpercent', 'labelposition']);
      }
    }]);

    return _class;
  }(BaseComponent(HTMLElement)));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Progress.Label
   @classdesc The Progress label content
   @htmltag coral-progress-label
   @return {HTMLElement}
   */
  var ProgressLabel = (function () {
    return document.createElement('coral-progress-label');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons._define('coral-progress', Progress);

  Progress.Label = ProgressLabel;

  /**
   Enumeration for {@link QuickActionsItem} type values.

   @typedef {Object} QuickActionsItemTypeEnum

   @property {String} BUTTON
   Default button type
   @property {String} ANCHOR
   Anchor button type
   */

  var type$1 = {
    BUTTON: 'button',
    ANCHOR: 'anchor'
  };
  /**
   @class Coral.QuickActions.Item
   @classdesc A QuickActions item component
   @htmltag coral-quickactions-item
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var QuickActionsItem = Decorator( /*#__PURE__*/function (_BaseComponent) {
    _inherits(_class, _BaseComponent);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this); // QuickActions will add button/anchorbutton references to it

      _this._elements = {}; // messenger

      _this._messenger = new Messenger(_assertThisInitialized(_this));
      _this._observer = new MutationObserver(_this._onMutation.bind(_assertThisInitialized(_this)));

      _this._observer.observe(_assertThisInitialized(_this), {
        characterData: true,
        childList: true,
        subtree: true
      });

      return _this;
    } // @compat


    _createClass(_class, [{
      key: "_onMutation",

      /**
       Handles mutations on the Item.
        @emits {coral-quickactions-item:_contentchanged}
        @private
       */
      value: function _onMutation() {
        this._messenger.postMessage('coral-quickactions-item:_contentchanged');
      }
      /**
       Returns {@link QuickActionsItem} type options.
        @return {QuickActionsItemTypeEnum}
       */

    }, {
      key: "_suspendCallback",

      /** @ignore */
      value: function _suspendCallback() {
        _get(_getPrototypeOf(_class.prototype), "_suspendCallback", this).call(this);

        this._messenger.disconnect();
      }
      /** @ignore */

    }, {
      key: "_resumeCallback",
      value: function _resumeCallback() {
        this._messenger.connect();

        _get(_getPrototypeOf(_class.prototype), "_resumeCallback", this).call(this);
      }
      /** @ignore */

    }, {
      key: "connectedCallback",
      value: function connectedCallback() {
        this._messenger.connect();

        _get(_getPrototypeOf(_class.prototype), "connectedCallback", this).call(this);
      }
      /** @ignore */

    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        _get(_getPrototypeOf(_class.prototype), "disconnectedCallback", this).call(this);

        this._messenger.disconnect();
      }
      /** @ignore */

    }, {
      key: "render",
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this); // Default reflected attributes


        if (!this._type) {
          this.type = type$1.BUTTON;
        }
      }
      /**
       Triggered when an icon of a {@link QuickActionsItem} was changed.
        @typedef {CustomEvent} coral-quickactions-item:_iconchanged
        @private
       */

      /**
       Triggered when the content of a {@link QuickActionsItem} was changed.
        @typedef {CustomEvent} coral-quickactions-item:_contentchanged
        @private
       */

      /**
       Triggered when the href of a {@link QuickActionsItem} was changed.
        @typedef {CustomEvent} coral-quickactions-item:_hrefchanged
        @private
       */

      /**
       Triggered when the type of a {@link QuickActionsItem} was changed.
        @typedef {CustomEvent} coral-quickactions-item:_typechanged
        @private
       */

    }, {
      key: "content",
      get: function get() {
        return this;
      },
      set: function set(value) {
        // Support configs
        if (_typeof(value) === 'object') {
          for (var prop in value) {
            /** @ignore */
            this[prop] = value[prop];
          }
        }
      }
      /**
       When <code>type</code> is {@link Coral.QuickActions.Item.type.ANCHOR}, the href will be used for the anchor.
        @type {String}
       @default ""
       @htmlattribute href
       @htmlattributereflected
       @emits {coral-quickactions-item:_hrefchanged}
       */

    }, {
      key: "href",
      get: function get() {
        return this._href || '';
      },
      set: function set(value) {
        value = transform.string(value);

        if (validate.valueMustChange(this._href, value)) {
          this._href = value;

          this._reflectAttribute('href', value);

          this._messenger.postMessage('coral-quickactions-item:_hrefchanged');
        }
      }
      /**
       Specifies the name of the icon to be shown in the QuickActions Item. See {@link Icon} for valid icon
       names.
        @type {String}
       @default ""
       @htmlattribute icon
       @htmlattributereflected
       @emits {coral-quickactions-item:_iconchanged}
       */

    }, {
      key: "icon",
      get: function get() {
        return this._icon || '';
      },
      set: function set(value) {
        value = transform.string(value);

        if (validate.valueMustChange(this._icon, value)) {
          this._icon = value;

          this._reflectAttribute('icon', value);

          this._messenger.postMessage('coral-quickactions-item:_iconchanged');
        }
      }
      /**
       The type of item that will be used. Setting {@link QuickActionsItemTypeEnum}.ANCHOR will allow users to
       navigate using the quickactions proving the correct hypermedia to the users.
        @type {String}
       @default QuickActionsItemTypeEnum.BUTTON
       @htmlattribute type
       @htmlattributereflected
       */

    }, {
      key: "type",
      get: function get() {
        return this._type || type$1.BUTTON;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        value = validate.enumeration(type$1)(value) && value || type$1.BUTTON;

        if (validate.valueMustChange(this._type, value)) {
          this._type = value;

          this._reflectAttribute('type', value);

          this._messenger.postMessage('coral-quickactions-item:_typechanged');
        }
      }
      /**
       Inherited from {@link BaseComponent#trackingElement}.
       */

    }, {
      key: "trackingElement",
      get: function get() {
        return typeof this._trackingElement === 'undefined' ? // keep spaces to only 1 max and trim. this mimics native html behaviors
        this.textContent && this.textContent.replace(/\s{2,}/g, ' ').trim() || this.icon : this._trackingElement;
      },
      set: function set(value) {
        _set(_getPrototypeOf(_class.prototype), "trackingElement", value, this, true);
      }
    }], [{
      key: "type",
      get: function get() {
        return type$1;
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['href', 'icon', 'type']);
      }
    }]);

    return _class;
  }(BaseComponent(HTMLElement)));

  var template$L = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["moreButton"] = document.createElement("button", "coral-button");
    el0.setAttribute("tracking", "off");
    el0.className += " _coral-QuickActions-item _coral-QuickActions-item-more";
    el0.setAttribute("variant", "quietaction");
    el0.setAttribute("is", "coral-button");
    el0.setAttribute("type", "button");
    el0.setAttribute("icon", "more");
    el0.setAttribute("iconsize", "S");
    el0.setAttribute("handle", "moreButton");
    el0.setAttribute("title", data_0["i18n"]["get"]('More actions'));
    el0.setAttribute("role", "menuitem");
    el0.setAttribute("aria-haspopup", "menu");
    el0.setAttribute("aria-expanded", "false");
    el0.setAttribute("aria-label", data_0["i18n"]["get"]('More actions'));
    frag.appendChild(el0);
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    var el2 = this["overlay"] = document.createElement("coral-popover");
    el2.className += " _coral-QuickActions-moreOverlay";
    el2.setAttribute("tracking", "off");
    el2.setAttribute("smart", "");
    el2.id = data_0["commons"]["getUID"]();
    el2.setAttribute("breadthoffset", "50%p - 50%");
    el2.setAttribute("placement", "bottom");
    el2.setAttribute("handle", "overlay");
    el2.setAttribute("role", "presentation");
    var el3 = document.createTextNode("\n  ");
    el2.appendChild(el3);
    var el4 = this["buttonList"] = document.createElement("coral-buttonlist");
    el4.setAttribute("tracking", "off");
    el4.id = data_0["commons"]["getUID"]();
    el4.className += " _coral-QuickActions-buttonList";
    el4.setAttribute("handle", "buttonList");
    el4.setAttribute("role", "menu");
    el4.setAttribute("tabindex", "-1");
    el2.appendChild(el4);
    var el5 = document.createTextNode("\n");
    el2.appendChild(el5);
    frag.appendChild(el2);
    var el6 = document.createTextNode("\n");
    frag.appendChild(el6);
    return frag;
  };

  var BUTTON_FOCUSABLE_SELECTOR = '._coral-QuickActions-item:not([disabled]):not([hidden])';
  /**
   Enumeration for {@link QuickActions} interaction options.

   @typedef {Object} QuickActionsInteractionEnum

   @property {String} ON
   Show when the target is hovered or focused and hide when the mouse is moved out or focus is lost.
   @property {String} OFF
   Do not show or hide automatically.
   */

  var interaction$3 = {
    ON: 'on',
    OFF: 'off'
  };
  /**
   Enumeration for {@link QuickActions} anchored overlay target options.

   @typedef {Object} QuickActionsTargetEnum

   @property {String} PARENT
   Use the parent element in the DOM.
   @property {String} PREVIOUS
   Use the previous sibling element in the DOM.
   @property {String} NEXT
   Use the next sibling element in the DOM.
   */

  var target$2 = {
    PARENT: '_parent',
    PREVIOUS: '_prev',
    NEXT: '_next'
  };
  /**
   Enumeration for {@link QuickActions} placement options.

   @typedef {Object} QuickActionsPlacementEnum

   @property {String} TOP
   QuickActions inset to the top of the target.
   @property {String} CENTER
   QuickActions inset to the center of the target.
   @property {String} BOTTOM
   QuickActions inset to the bottom the target.
   */

  var placement$2 = {
    TOP: 'top',
    CENTER: 'center',
    BOTTOM: 'bottom'
  };
  var OFFSET$2 = 10;
  var CLASSNAME$17 = '_coral-QuickActions';
  /**
   @class Coral.QuickActions
   @classdesc A QuickActions component is an overlay component that reveals actions when interacting with a container.
   Hovering the target will display the QuickActions. They can also be launched by pressing the shift + F10 key combination
   when the target is focused.
   @htmltag coral-quickactions
   @extends {Overlay}
   */

  var QuickActions = Decorator( /*#__PURE__*/function (_ExtensibleOverlay) {
    _inherits(_class, _ExtensibleOverlay);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this); // Override defaults

      _this._overlayAnimationTime = Overlay.FADETIME;
      _this._alignMy = Overlay.align.CENTER_TOP;
      _this._alignAt = Overlay.align.CENTER_TOP;
      _this._lengthOffset = OFFSET$2;
      _this._inner = true;
      _this._target = target$2.PREVIOUS;
      _this._placement = placement$2.TOP;
      _this._focusOnShow = Overlay.focusOnShow.OFF;
      _this._scrollOnFocus = Overlay.scrollOnFocus.OFF;

      if (!_this.id) {
        _this.id = commons.getUID();
      } // Flag


      _this._openedBefore = false; // Debounce timer

      _this._timeout = null; // Template

      template$L.call(_this._elements, {
        commons: commons,
        i18n: i18n
      });
      var events = {
        'global:resize': '_onWindowResize',
        'mouseout': '_onMouseOut',
        // Keyboard interaction
        'key:home': '_onHomeKeypress',
        'key:end': '_onEndKeypress',
        'key:pagedown': '_onButtonKeypressNext',
        'key:right': '_onButtonKeypressNext',
        'key:down': '_onButtonKeypressNext',
        'key:pageup': '_onButtonKeypressPrevious',
        'key:left': '_onButtonKeypressPrevious',
        'key:up': '_onButtonKeypressPrevious',
        'capture:focus': '_onFocus',
        'capture:blur': '_onBlur',
        // Buttons
        'click > ._coral-QuickActions-item:not([handle="moreButton"])': '_onButtonClick',
        'click > ._coral-QuickActions-item[handle="moreButton"]': '_onMoreButtonClick',
        //Messenger
        'coral-quickactions-item:_messengerconnected': '_onMessengerConnected'
      };
      var overlayId = _this._elements.overlay.id; // Overlay

      events["global:capture:coral-overlay:beforeopen #".concat(overlayId)] = '_onOverlayBeforeOpen';
      events["global:capture:coral-overlay:beforeclose #".concat(overlayId)] = '_onOverlayBeforeClose';
      events["global:capture:coral-overlay:open #".concat(overlayId)] = '_onOverlayOpen';
      events['global:capture:coral-overlay:close'] = '_onOverlayClose';
      events["global:capture:coral-overlay:positioned #".concat(overlayId)] = '_onOverlayPositioned';
      events["global:capture:coral-overlay:_animate #".concat(overlayId)] = '_onAnimate';
      events["global:capture:mouseout #".concat(overlayId)] = '_onMouseOut';
      events["global:capture:click #".concat(overlayId, " [coral-list-item]")] = '_onButtonListItemClick'; // Cache bound event handler functions

      _this._onTargetMouseEnter = _this._onTargetMouseEnter.bind(_assertThisInitialized(_this));
      _this._onTargetKeyUp = _this._onTargetKeyUp.bind(_assertThisInitialized(_this));
      _this._onTargetMouseLeave = _this._onTargetMouseLeave.bind(_assertThisInitialized(_this)); // Events

      _this._delegateEvents(events); // delegates the item handling to the collection


      _this.items._startHandlingItems(true);

      return _this;
    }
    /**
     Returns the inner overlay to allow customization.
      @type {Popover}
     @readonly
     */


    _createClass(_class, [{
      key: "_getButtonWidth",
      value: function _getButtonWidth() {
        if (this.closest('.coral--large')) {
          // 40px button width + 10px left margin
          return 50;
        } else {
          // 32px button width + 8px left margin
          return 40;
        }
      }
      /** @ignore */

    }, {
      key: "_getTarget",
      value: function _getTarget(targetValue) {
        // Use passed target
        targetValue = targetValue || this.target;

        if (targetValue instanceof Node) {
          // Just return the provided Node
          return targetValue;
        } // Dynamically get the target node based on target


        var newTarget = null;

        if (typeof targetValue === 'string') {
          if (targetValue === target$2.PARENT) {
            newTarget = this.parentNode;
          } else {
            // Delegate to Coral.Overlay for _prev, _next and general selector
            newTarget = _get(_getPrototypeOf(_class.prototype), "_getTarget", this).call(this, targetValue);
          }
        }

        return newTarget;
      }
      /** @ignore */

    }, {
      key: "_addTargetEventListeners",
      value: function _addTargetEventListeners(targetElement) {
        targetElement = targetElement || this._getTarget();

        if (!targetElement) {
          return;
        } // Interaction-sensitive listeners


        if (this.interaction === interaction$3.ON) {
          // We do not have to worry about the EventListener being called twice as duplicates are discarded
          targetElement.addEventListener('mouseenter', this._onTargetMouseEnter);
          targetElement.addEventListener('keyup', this._onTargetKeyUp);
          targetElement.addEventListener('keydown', this._onTargetKeyDown);
          targetElement.addEventListener('mouseleave', this._onTargetMouseLeave);
        }
      }
      /** @ignore */

    }, {
      key: "_removeTargetEventListeners",
      value: function _removeTargetEventListeners(targetElement) {
        targetElement = targetElement || this._getTarget();

        if (!targetElement) {
          return;
        }

        targetElement.removeEventListener('mouseenter', this._onTargetMouseEnter);
        targetElement.removeEventListener('keyup', this._onTargetKeyUp);
        targetElement.removeEventListener('keydown', this._onTargetKeyDown);
        targetElement.removeEventListener('mouseleave', this._onTargetMouseLeave);
      }
      /**
       Toggles whether or not an item is tabbable.
        @param {HTMLElement} item
       The item to process.
        @param {Boolean} tabbable
       Whether the item should be marked tabbable.
       @ignore
       */

    }, {
      key: "_toggleTabbable",
      value: function _toggleTabbable(item, tabbable) {
        if (item) {
          if (tabbable) {
            if (item.hasAttribute('tabIndex')) {
              item.removeAttribute('tabIndex');
            }
          } else {
            item.setAttribute('tabIndex', '-1');
          }
        }
      }
      /**
       Gets the subsequent or previous focusable neighbour relative to an Item button.
        @param {HTMLElement} current
       The current button element from which to find the next selectable neighbour.
       @param {Boolean} [previous]
       Whether to look for a previous neighbour rather than a subsequent one.
        @returns {HTMLElement|undefined} The focusable neighbour. Undefined if no suitable neighbour found.
        @private
       */

    }, {
      key: "_getFocusableNeighbour",
      value: function _getFocusableNeighbour(current, previous) {
        // we need to convert the result to an array in order to use .indexOf()
        var focusableButtons = Array.prototype.slice.call(this._getFocusableButtons());
        var index = focusableButtons.indexOf(current);

        if (index >= 0) {
          if (!previous) {
            // Pick the next focusable button
            if (index < focusableButtons.length - 1) {
              return focusableButtons[index + 1];
            }
          } // Pick the previous focusable button
          else if (index !== 0) {
              return focusableButtons[index - 1];
            }
        }
      }
      /**
       Gets the buttons, optionally excluding the more button.
        @param {Boolean} excludeMore
       Whether to exclude the more button.
        @returns {NodeList} The NodeList containing all the buttons.
        @private
       */

    }, {
      key: "_getButtons",
      value: function _getButtons(excludeMore) {
        var buttonSelector = '._coral-QuickActions-item';
        buttonSelector = excludeMore ? "".concat(buttonSelector, ":not([handle=\"moreButton\"])") : buttonSelector;
        return this.querySelectorAll(buttonSelector);
      }
      /**
       An element is focusable if it is visible and not disabled.
        @returns {NodeList} A NodeList containing the focusable buttons.
        @private
       */

    }, {
      key: "_getFocusableButtons",
      value: function _getFocusableButtons() {
        // since we use the hidden attribute to hide the items, we can rely on this attribute to determine if the button
        // is hidden, instead of using a more expensive :focusable selector
        return this.querySelectorAll(BUTTON_FOCUSABLE_SELECTOR);
      }
      /**
       Gets the first focusable button.
        @returns {HTMLElement|undefined}
       The first focusable button, undefined if none found.
       @ignore
       */

    }, {
      key: "_getFirstFocusableButton",
      value: function _getFirstFocusableButton() {
        return this.querySelector(BUTTON_FOCUSABLE_SELECTOR);
      }
      /**
       Gets the last focusable button.
        @returns {HTMLElement|undefined}
       The last focusable button, undefined if none found.
       @ignore
       */

    }, {
      key: "_getLastFocusableButton",
      value: function _getLastFocusableButton() {
        var focusableButtons = this._getFocusableButtons();

        return focusableButtons[focusableButtons.length - 1];
      }
      /** @ignore */

    }, {
      key: "_proxyClick",
      value: function _proxyClick(item) {
        var event = item.trigger('click');

        if (!event.defaultPrevented && this.interaction === interaction$3.ON) {
          this._hideAll();
        }
      }
      /**
       Gets data from an Item.
        @param {HTMLElement} item
       The Item to get the data from.
       @returns {Object}
       The Item data.
       @ignore
       */

    }, {
      key: "_getItemData",
      value: function _getItemData(item) {
        return {
          htmlContent: item.innerHTML,
          textContent: item.textContent,
          // fallback to empty string in case it has no icon
          icon: item.getAttribute('icon') || ''
        };
      }
      /** @ignore */

    }, {
      key: "_attachItem",
      value: function _attachItem(item, index) {
        // since the button has already been initialized we make sure it is up to date
        if (item._elements && item._elements.button) {
          this._updateItem(item);

          return;
        } // if the index was not provided, we need to calculate it


        if (typeof index === 'undefined') {
          index = Array.prototype.indexOf.call(this.items.getAll(), item);
        }

        var itemData = this._getItemData(item);

        var type = QuickActionsItem.type;
        var button;

        if (item.type === type.BUTTON) {
          button = new Button().set({
            icon: itemData.icon,
            iconsize: Icon.size.SMALL,
            type: 'button',
            tracking: 'off'
          }, true);
        } else if (item.type === type.ANCHOR) {
          button = new AnchorButton().set({
            icon: itemData.icon,
            iconsize: Icon.size.SMALL,
            href: item.href,
            tracking: 'off'
          }, true);
        }

        button.variant = Button.variant.QUIET_ACTION;
        button.classList.add('_coral-QuickActions-item');
        button.setAttribute('tabindex', '-1');
        button.setAttribute('title', itemData.textContent.trim());
        button.setAttribute('aria-label', itemData.textContent.trim());
        button.setAttribute('role', 'menuitem');
        this.insertBefore(button, this.children[index]); // ButtonList Item

        var buttonListItem;

        if (item.type === type.BUTTON) {
          buttonListItem = new ButtonList.Item();
        } else if (item.type === type.ANCHOR) {
          buttonListItem = new AnchorList.Item();
          buttonListItem.href = item.href;
        }

        var buttonListItemParent = this._elements.buttonList;
        buttonListItem.tabIndex = -1;
        buttonListItem.content.innerHTML = itemData.htmlContent;
        buttonListItem.icon = itemData.icon;
        buttonListItem.setAttribute('role', 'menuitem');
        buttonListItemParent.insertBefore(buttonListItem, buttonListItemParent.children[index]);
        item._elements.button = button;
        item._elements.buttonListItem = buttonListItem;
        buttonListItem._elements.quickActionsItem = item;
        button._elements.quickActionsItem = item;
      }
      /**
       Layout calculation; collapses QuickActions as necessary.
       */

    }, {
      key: "_layout",
      value: function _layout() {
        // Set the width of the QuickActions to match that of the target
        this._setWidth();

        var buttons = this._getButtons(true);

        if (!buttons.length) {
          return;
        }

        var buttonListItems = this._elements.buttonList.items.getAll(); // Temporarily display the QuickActions so we can do the calculation


        var display = this.style.display;
        var temporarilyShown = false;

        if (!this.open) {
          this.style.left -= 10000;
          this.style.top -= 10000;
          this.style.display = 'block';
          temporarilyShown = true;
        }

        var totalAvailableWidth = this.offsetWidth;
        var totalFittingButtons = 0;
        var widthUsed = 0;

        var buttonWidth = this._getButtonWidth();

        while (totalAvailableWidth > widthUsed) {
          widthUsed += buttonWidth;

          if (totalAvailableWidth > widthUsed) {
            totalFittingButtons++;
          }
        } // Remove one to avoid taking full width space


        totalFittingButtons--;
        var threshold = this.threshold;
        var handleThreshold = threshold > 0;
        var moreButtonsThanThreshold = handleThreshold && buttons.length > threshold;
        var collapse = buttons.length > totalFittingButtons || moreButtonsThanThreshold; // +1 to account for the more button

        var collapseToThreshold = collapse && handleThreshold && threshold + 1 < totalFittingButtons;
        var totalButtons;

        if (collapse) {
          if (collapseToThreshold) {
            totalButtons = threshold + 1;
          } else {
            totalButtons = totalFittingButtons;
          }
        } else {
          totalButtons = buttons.length;
        } // Show all Buttons and ButtonList Items


        for (var i = 0; i < buttons.length; i++) {
          this._toggleTabbable(buttons[i], false);

          buttons[i].hidden = false;

          if (buttonListItems[i]) {
            buttonListItems[i].hidden = false;
          }
        }

        this._toggleTabbable(this._elements.moreButton, false);

        if (collapse) {
          if (totalButtons > 0) {
            // Hide the buttons we're collapsing
            for (var j = totalButtons - 1; j < buttons.length; j++) {
              buttons[j].hide();
            } // Hide the ButtonList items


            for (var k = 0; k < totalButtons - 1; k++) {
              buttonListItems[k].hide();
            } // Mark the first button as tabbable


            this._toggleTabbable(buttons[0], true);
          } else {
            this._toggleTabbable(this._elements.moreButton, true);
          }

          this._elements.moreButton.show();
        } else {
          // Mark the first button as tabbable
          this._toggleTabbable(buttons[0], true);

          this._elements.moreButton.hide();
        }

        this._setWidth(true); // Reset the QuickActions display


        if (temporarilyShown) {
          this.style.left += 10000;
          this.style.top += 10000;
          this.style.display = display;
        } // Do a reposition of the overlay


        this.reposition();
      }
      /**
       Sets the width of QuickActions from the target.
        @ignore
       */

    }, {
      key: "_setWidth",
      value: function _setWidth(buttonWidthBased) {
        var width = 0;

        var targetElement = this._getTarget();

        if (targetElement) {
          var maxWidth = targetElement.offsetWidth;

          if (buttonWidthBased) {
            var visibleButtons = this.querySelectorAll('._coral-QuickActions-item:not([hidden])');

            var buttonWidth = this._getButtonWidth();

            if (visibleButtons.length) {
              for (var i = 0; i < visibleButtons.length && width <= maxWidth; i++) {
                width += buttonWidth;
              }

              this.style.width = "".concat(width, "px");
            }
          } else {
            this.style.width = "".concat(maxWidth, "px");
          }
        }
      }
      /** @ignore */

    }, {
      key: "_setButtonListHeight",
      value: function _setButtonListHeight() {
        // Set height of ButtonList
        this._elements.buttonList.style.height = ''; // Measure actual height

        var style = window.getComputedStyle(this._elements.buttonList);
        var height = parseInt(style.height, 10);
        var maxHeight = parseInt(style.maxHeight, 10);

        if (height < maxHeight) {
          // Make it scrollable
          this._elements.buttonList.style.height = "".concat(height - 1, "px");
        }
      }
      /** @ignore */

    }, {
      key: "_isInternalToComponent",
      value: function _isInternalToComponent(element) {
        var targetElement = this._getTarget();

        return element && (this.contains(element) || this._elements.overlay.contains(element) || targetElement && targetElement.contains(element));
      }
      /** @ignore */

    }, {
      key: "_onWindowResize",
      value: function _onWindowResize() {
        this._layout();
      }
    }, {
      key: "_handleEscape",
      value: function _handleEscape(event) {
        var _this2 = this;

        if (typeof this._isTop === 'undefined') {
          this._isTop = this._isTopOverlay();
        } // Debounce


        if (this._timeout !== null) {
          window.clearTimeout(this._timeout);
        }

        this._timeout = window.setTimeout(function () {
          if (_this2._isTop) {
            _get(_getPrototypeOf(_class.prototype), "_handleEscape", _this2).call(_this2, event);
          }

          _this2._isTop = undefined;
        });
      }
      /** @ignore */

    }, {
      key: "_onMouseOut",
      value: function _onMouseOut(event) {
        var toElement = event.toElement || event.relatedTarget; // Hide if we mouse leave to any element external to the component and its target

        if (!this._isInternalToComponent(toElement) && this.interaction === interaction$3.ON) {
          this._hideAll();
        }
      }
    }, {
      key: "_hideAll",
      value: function _hideAll() {
        this.hide();

        this._elements.overlay.hide();
      }
      /** @ignore */

    }, {
      key: "_onTargetMouseEnter",
      value: function _onTargetMouseEnter(event) {
        var fromElement = event.fromElement || event.relatedTarget; // Open if we aren't already

        if (!this.open && !this._isInternalToComponent(fromElement)) {
          this.show();

          this._trackEvent('display', 'coral-quickactions', event);
        }
      }
      /** @ignore */

    }, {
      key: "_onTargetKeyUp",
      value: function _onTargetKeyUp(event) {
        var keyCode = event.keyCode; // shift + F10 or ctrl + space (http://www.w3.org/WAI/PF/aria-practices/#popupmenu)

        if (event.shiftKey && keyCode === 121 || event.ctrlKey && keyCode === 32) {
          if (!this.open) {
            if (this.interaction === interaction$3.ON) {
              // Launched via keyboard and interaction enabled implies a focus trap and return focus.
              // Remember the relevant properties and return their values on hide.
              this._previousTrapFocus = this.trapFocus;
              this._previousReturnFocus = this.returnFocus;
              this._previousFocusOnShow = this.focusOnShow;
              this.trapFocus = this.constructor.trapFocus.ON;
              this.returnFocus = this.constructor.returnFocus.ON;
              this.focusOnShow = this.constructor.focusOnShow.ON;
            }

            this.show();
          }
        }
      }
    }, {
      key: "_onTargetKeyDown",
      value: function _onTargetKeyDown(event) {
        var keyCode = event.keyCode; // shift + F10 or ctrl + space (http://www.w3.org/WAI/PF/aria-practices/#popupmenu)

        if (event.shiftKey && keyCode === 121 || event.ctrlKey && keyCode === 32) {
          // Prevent default context menu show or page scroll behaviour
          event.preventDefault();
        }
      }
      /** @ignore */

    }, {
      key: "_onTargetMouseLeave",
      value: function _onTargetMouseLeave(event) {
        var toElement = event.toElement || event.relatedTarget; // Do not hide if we entered the quick actions

        if (!this._isInternalToComponent(toElement)) {
          this._hideAll();
        }
      }
      /** @ignore */

    }, {
      key: "_onHomeKeypress",
      value: function _onHomeKeypress(event) {
        // prevents the page from scrolling
        event.preventDefault();

        var firstFocusableButton = this._getFirstFocusableButton(); // Jump focus to the first focusable button


        if (firstFocusableButton) {
          firstFocusableButton.focus();
        }
      }
      /** @ignore */

    }, {
      key: "_onEndKeypress",
      value: function _onEndKeypress(event) {
        // prevents the page from scrolling
        event.preventDefault();

        var lastFocusableButton = this._getLastFocusableButton(); // Jump focus to the last focusable button


        if (lastFocusableButton) {
          lastFocusableButton.focus();
        }
      }
      /** @ignore */

    }, {
      key: "_onButtonKeypressNext",
      value: function _onButtonKeypressNext(event) {
        event.preventDefault();

        if (document.activeElement === this) {
          var firstFocusableButton = this._getFirstFocusableButton();

          if (firstFocusableButton) {
            firstFocusableButton.focus();
          }
        } else {
          // Handle key presses that imply focus of the next focusable button
          var nextButton = this._getFocusableNeighbour(event.matchedTarget);

          if (nextButton) {
            nextButton.focus();
          } else if (event.key === 'ArrowDown' && document.activeElement === this._elements.moreButton) {
            this._elements.moreButton.click();
          }
        }
      }
      /** @ignore */

    }, {
      key: "_onButtonKeypressPrevious",
      value: function _onButtonKeypressPrevious(event) {
        event.preventDefault();

        if (document.activeElement === this) {
          var lastFocusableButton = this._getLastFocusableButton();

          if (lastFocusableButton) {
            lastFocusableButton.focus();
          }
        } else {
          // Handle key presses that imply focus of the previous focusable button
          var previousButton = this._getFocusableNeighbour(event.matchedTarget, true);

          if (previousButton) {
            previousButton.focus();
          }
        }
      }
      /** @ignore */

    }, {
      key: "_onButtonClick",
      value: function _onButtonClick(event) {
        var _this3 = this;

        event.stopPropagation();

        if (this._preventClick) {
          return;
        }

        var button = event.matchedTarget;
        var item = button._elements.quickActionsItem;

        this._proxyClick(item); // Prevent double click or alternate selection during animation


        window.setTimeout(function () {
          _this3._preventClick = false;
        }, this._overlayAnimationTime);
        this._preventClick = true;

        this._trackEvent('click', 'coral-quickactions-item', event, item);
      }
    }, {
      key: "_onMoreButtonClick",
      value: function _onMoreButtonClick(event) {
        var button = event.matchedTarget;
        var item = button._elements.quickActionsItem;

        this._trackEvent('click', 'coral-quickactions-more', event, item);
      }
    }, {
      key: "_onFocus",
      value: function _onFocus() {
        if (this._focusOnShow === this.constructor.focusOnShow.OFF && this._returnFocus !== this.constructor.returnFocus.ON) {
          var targetElement = this._getTarget();

          if (targetElement) {
            if (!this._previousReturnFocus) {
              this._previousReturnFocus = this._returnFocus;
              this.returnFocus = this.constructor.returnFocus.ON;
            }

            if (!this._previousElementToFocusWhenHidden) {
              this._previousElementToFocusWhenHidden = this._elementToFocusWhenHidden;
              this._elementToFocusWhenHidden = targetElement;
            }
          }
        }
      }
    }, {
      key: "_onBlur",
      value: function _onBlur() {
        if (this._focusOnShow === this.constructor.focusOnShow.OFF) {
          if (this._previousReturnFocus) {
            this.returnFocus = this._previousReturnFocus;
            this._previousReturnFocus = undefined;
          }

          if (this._previousElementToFocusWhenHidden) {
            this._elementToFocusWhenHidden = this._previousElementToFocusWhenHidden;
            this._previousElementToFocusWhenHidden = undefined;
          }
        }
      }
      /** @ignore */

    }, {
      key: "_onOverlayBeforeOpen",
      value: function _onOverlayBeforeOpen(event) {
        if (event.target === this) {
          // Reset double-click prevention flag
          this._preventClick = false;

          this._layout();
        } else if (event.target === this._elements.overlay) {
          // do not allow internal Overlay events to escape QuickActions
          event.stopImmediatePropagation();

          this._setButtonListHeight();
        }
      }
      /** @ignore */

    }, {
      key: "_onOverlayBeforeClose",
      value: function _onOverlayBeforeClose(event) {
        if (event.target === this._elements.overlay) {
          // do not allow internal Overlay events to escape QuickActions
          event.stopImmediatePropagation();
        }
      }
      /** @ignore */

    }, {
      key: "_onOverlayOpen",
      value: function _onOverlayOpen(event) {
        if (event.target === this._elements.overlay) {
          // do not allow internal Overlay events to escape QuickActions
          event.stopImmediatePropagation();

          this._elements.moreButton.setAttribute('aria-expanded', 'true');
        }
      }
      /** @ignore */

    }, {
      key: "_onOverlayClose",
      value: function _onOverlayClose(event) {
        var _this4 = this;

        if (event.target === this) {
          this._elements.overlay.open = false; // Return the trapFocus and returnFocus properties to their state before open.
          // Handles the keyboard launch and interaction enabled case, which implies focus trap and focus return.
          // Wait a frame as this is called before the 'open' property sync. Otherwise, returnFocus is set prematurely.

          window.requestAnimationFrame(function () {
            if (_this4._previousTrapFocus) {
              _this4.trapFocus = _this4._previousTrapFocus;

              if (_this4.trapFocus !== _this4.constructor.trapFocus.ON) {
                _this4.removeAttribute('tabindex');
              }

              _this4._previousTrapFocus = undefined;
            }

            if (_this4._previousReturnFocus) {
              _this4.returnFocus = _this4._previousReturnFocus;
              _this4._previousReturnFocus = undefined;
            }

            if (_this4._previousFocusOnShow) {
              _this4.focusOnShow = _this4._previousFocusOnShow;
              _this4._previousFocusOnShow = undefined;
            }
          });
        } else if (event.target === this._elements.overlay) {
          // do not allow internal Overlay events to escape QuickActions
          event.stopImmediatePropagation();

          this._elements.moreButton.setAttribute('aria-expanded', 'false');
        }
      }
      /** @ignore */

    }, {
      key: "_onOverlayPositioned",
      value: function _onOverlayPositioned(event) {
        if (event.target === this._elements.overlay) {
          // do not allow internal Overlay events to escape QuickActions
          event.stopImmediatePropagation();
        }
      }
    }, {
      key: "_onAnimate",
      value: function _onAnimate(event) {
        if (event.target === this) {
          if (this.placement === placement$2.BOTTOM) {
            this.style.marginTop = "".concat(-parseFloat(this.lengthOffset) + 8, "px");
          } else {
            this.style.marginTop = "".concat(parseFloat(this.lengthOffset) - 8, "px");
          }
        }
      }
      /** @ignore */

    }, {
      key: "_onButtonListItemClick",
      value: function _onButtonListItemClick(event) {
        // stops propagation so that this event remains internal to the component
        event.stopImmediatePropagation();
        var buttonListItem = event.matchedTarget;

        if (!buttonListItem) {
          return;
        }

        var item = buttonListItem._elements.quickActionsItem;

        this._proxyClick(item);

        this._trackEvent('click', 'coral-quickactions-item', event, item);
      }
      /** @ignore */

    }, {
      key: "_onItemRemoved",
      value: function _onItemRemoved(item) {
        this._removeItemElements(item);
      }
      /** @ignore */

    }, {
      key: "_onCollectionChange",
      value: function _onCollectionChange(addedNodes) {
        // Delay the item initialization if the component has not been opened before
        if (!this._openedBefore) {
          return;
        } // we use the items to be able to find out the index of the added item in reference to the whole collection


        var items = this.items.getAll();
        var index;

        for (var i = 0, addedNodesCount = addedNodes.length; i < addedNodesCount; i++) {
          // we need to know the item's position in relation to the others
          index = Array.prototype.indexOf.call(items, addedNodes[i]);

          this._attachItem(addedNodes[i], index);
        }

        this._layout();
      }
      /** @ignore */

    }, {
      key: "_onItemChange",
      value: function _onItemChange(event) {
        // stops propagation so that this event remains internal to the component
        event.stopImmediatePropagation();

        this._updateItem(event.target);
      }
      /** @ignore */

    }, {
      key: "_onItemTypeChange",
      value: function _onItemTypeChange(event) {
        // stops propagation so that this event remains internal to the component
        event.stopImmediatePropagation(); // delay this execution while opening quickaction to avoid performance delay

        if (this._openedBefore || this.open) {
          var item = event.target;

          this._removeItemElements(item);

          this._attachItem(item);

          this._layout();
        }
      }
      /** @ignore */

    }, {
      key: "_removeItemElements",
      value: function _removeItemElements(item) {
        // Remove the associated Button and ButtonList elements
        if (item._elements.button) {
          item._elements.button.remove();

          item._elements.button._elements.quickActionsItem = undefined;
          item._elements.button = undefined;
        }

        if (item._elements.buttonListItem) {
          item._elements.buttonListItem.remove();

          item._elements.buttonListItem._elements.quickActionsItem = null;
          item._elements.buttonListItem = undefined;
        }
      }
      /** @ignore */

    }, {
      key: "_updateItem",
      value: function _updateItem(item) {
        var itemData = this._getItemData(item);

        var type = QuickActionsItem.type;
        var button = item._elements.button;

        if (button) {
          button.icon = itemData.icon;
          button.setAttribute('title', itemData.textContent.trim());
          button.setAttribute('aria-label', itemData.textContent.trim());
          button[item.type === type.ANCHOR ? 'setAttribute' : 'removeAttribute']('href', item.href);
        }

        var buttonListItem = item._elements.buttonListItem;

        if (buttonListItem) {
          buttonListItem.content.innerHTML = itemData.htmlContent;
          buttonListItem[item.type === type.ANCHOR ? 'setAttribute' : 'removeAttribute']('href', item.href);
          buttonListItem.icon = itemData.icon;
        }
      } // Maps placement CENTER with RIGHT

    }, {
      key: "_toggleCenterPlacement",
      value: function _toggleCenterPlacement(toggle) {
        if (toggle) {
          if (this.placement === placement$2.CENTER) {
            this._placement = Overlay.placement.RIGHT;
            this._oldInner = this._inner;
            this._inner = false;
            this._oldLengthOffset = this._lengthOffset;
            this._lengthOffset = '-50%r - 50%p';
          }
        } else if (this._placement === Overlay.placement.RIGHT) {
          this._placement = placement$2.CENTER; // Restore

          this._inner = this._oldInner;
          this._lengthOffset = this._oldLengthOffset;
        }
      }
      /** @ignore */

    }, {
      key: "reposition",
      value: function reposition(forceReposition) {
        // Override to support placement.CENTER
        this._toggleCenterPlacement(true);

        _get(_getPrototypeOf(_class.prototype), "reposition", this).call(this, forceReposition);

        this._toggleCenterPlacement(false);

        if (this._openedOnce) {
          // PopperJS inner property issue https://github.com/FezVrasta/popper.js/issues/400
          if (this.placement === placement$2.BOTTOM) {
            this.style.marginTop = "-".concat(parseFloat(this.lengthOffset), "px");
          } else if (this.placement === placement$2.TOP) {
            this.style.marginTop = "".concat(parseFloat(this.lengthOffset), "px");
          } else if (this.placement === placement$2.CENTER) {
            this.style.marginTop = "".concat(parseFloat(this.lengthOffset) - 4, "px");
          }
        }
      } // Override placement and target

      /**
       Returns {@link QuickActions} placement options.
        @return {QuickActionsPlacementEnum}
       */

    }, {
      key: "connectedCallback",

      /** @ignore */
      value: function connectedCallback() {
        _get(_getPrototypeOf(_class.prototype), "connectedCallback", this).call(this);

        var overlay = this._elements.overlay; // Cannot be open by default when rendered

        overlay.removeAttribute('open'); // Restore in DOM

        if (overlay._parent) {
          overlay._parent.appendChild(overlay);
        }
      }
      /** @ignore */

    }, {
      key: "render",
      value: function render() {
        var _this5 = this;

        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$17); // Define QuickActions as a menu

        this.setAttribute('role', 'menu'); // Support cloneNode

        ['moreButton', 'overlay'].forEach(function (handleName) {
          var handle = _this5.querySelector("[handle=\"".concat(handleName, "\"]"));

          if (handle) {
            handle.remove();
          }
        }); // Render template

        var frag = document.createDocumentFragment();
        frag.appendChild(this._elements.moreButton);
        frag.appendChild(this._elements.overlay); // avoid popper initialisation if popper neither exist nor overlay opened.

        this._elements.overlay._avoidPopperInit = this._elements.overlay.open || this._elements.overlay._popper ? false : true; // Link target

        this._elements.overlay.target = this._elements.moreButton;
        this.appendChild(frag); // set this to false after overlay has been connected to avoid connected callback target setting

        delete this._elements.overlay._avoidPopperInit;
      }
      /** @ignore */

    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        _get(_getPrototypeOf(_class.prototype), "disconnectedCallback", this).call(this);

        var overlay = this._elements.overlay; // In case it was moved out don't forget to remove it

        if (!this.contains(overlay)) {
          overlay._parent = overlay._repositioned ? document.body : this;
          overlay.remove();
        }
      }
    }, {
      key: "overlay",
      get: function get() {
        return this._elements.overlay;
      }
      /**
       The Item collection.
        @type {Collection}
       @readonly
       */

    }, {
      key: "items",
      get: function get() {
        // we do lazy initialization of the collection
        if (!this._items) {
          this._items = new Collection$1({
            host: this,
            itemTagName: 'coral-quickactions-item',
            onItemRemoved: this._onItemRemoved,
            onCollectionChange: this._onCollectionChange
          });
        }

        return this._items;
      }
      /**
       The number of items that are visible in QuickActions (excluding the show more actions button) before a collapse
       is enforced. A value <= 0 disables this feature and shows as many items as possible. Regardless of this
       property, the QuickActions will still fit within their target's width.
        @type {Number}
       @default 4
       @htmlattribute threshold
       @htmlattributereflected
       */

    }, {
      key: "threshold",
      get: function get() {
        return typeof this._threshold === 'number' ? this._threshold : 4;
      },
      set: function set(value) {
        this._threshold = transform.number(value);

        this._reflectAttribute('threshold', this._threshold);
      }
      /**
       The placement of the QuickActions. The value may be one of 'top', 'center' and 'bottom' and indicates the vertical
       alignment of the QuickActions relative to their container.
       See {@link OverlayPlacementEnum}.
        @type {String}
       @default OverlayPlacementEnum.TOP
       @htmlattribute placement
       */

    }, {
      key: "placement",
      get: function get() {
        return _get(_getPrototypeOf(_class.prototype), "placement", this);
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        this._placement = validate.enumeration(placement$2)(value) && value || placement$2.TOP;
        this.reposition();
      }
      /**
       Whether the QuickActions should show when the target is interacted with. See {@link QuickActionsInteractionEnum}.
        @type {String}
       @default QuickActionsInteractionEnum.ON
       @name interaction
       @htmlattribute interaction
       */

    }, {
      key: "interaction",
      get: function get() {
        return _get(_getPrototypeOf(_class.prototype), "interaction", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(_class.prototype), "interaction", value, this, true);

        if (this.interaction === interaction$3.ON) {
          this._addTargetEventListeners();
        } else {
          this._removeTargetEventListeners();
        }
      }
      /**
       Inherited from {@link Overlay#target}.
       */

    }, {
      key: "target",
      get: function get() {
        return _get(_getPrototypeOf(_class.prototype), "target", this);
      },
      set: function set(value) {
        // avoid popper initialization while connecting for first time and not opened.
        this._avoidPopperInit = this.open || this._popper ? false : true;

        _set(_getPrototypeOf(_class.prototype), "target", value, this, true);

        var targetElement = this._getTarget(value);

        var prevTargetElement = this._previousTarget;
        var targetHasChanged = targetElement !== prevTargetElement;

        if (targetElement && targetHasChanged) {
          // Remove listeners from the previous target
          if (prevTargetElement) {
            var previousTarget = this._getTarget(prevTargetElement);

            if (previousTarget) {
              this._removeTargetEventListeners(previousTarget);

              targetElement.removeAttribute('aria-haspopup');
              targetElement.removeAttribute('aria-owns');
            }
          } // Set up listeners for the new target


          this._addTargetEventListeners();

          var ariaOwns = targetElement.getAttribute('aria-owns');
          ariaOwns = ariaOwns && ariaOwns.length ? "".concat(ariaOwns.trim(), "  ").concat(this.id) : this.id;
          targetElement.setAttribute('aria-owns', ariaOwns); // Mark the target as owning a popup

          targetElement.setAttribute('aria-haspopup', 'true'); // Cache for use as previous target

          this._previousTarget = targetElement;
        }

        delete this._avoidPopperInit;
      }
    }, {
      key: "observedMessages",
      get: function get() {
        return {
          'coral-quickactions-item:_contentchanged': '_onItemChange',
          'coral-quickactions-item:_iconchanged': '_onItemChange',
          'coral-quickactions-item:_hrefchanged': '_onItemChange',
          'coral-quickactions-item:_typechanged': '_onItemTypeChange'
        };
      }
      /**
       Inherited from {@link Overlay#open}.
       */

    }, {
      key: "open",
      get: function get() {
        return _get(_getPrototypeOf(_class.prototype), "open", this);
      },
      set: function set(value) {
        var _this6 = this;

        // If opening and stealing focus, on close, focus should be returned
        // to the element that had focus before QuickActions were opened.
        if (value && this._focusOnShow !== this.constructor.focusOnShow.OFF) {
          this.returnFocusTo(document.activeElement);
        }

        _set(_getPrototypeOf(_class.prototype), "open", value, this, true);

        this._openedOnce = true; // Position once we can read items layout in the next frame

        window.requestAnimationFrame(function () {
          if (_this6.open && !_this6._openedBefore) {
            // we iterate over all the items initializing them in the correct order
            var items = _this6.items.getAll();

            for (var i = 0, itemCount = items.length; i < itemCount; i++) {
              _this6._attachItem(items[i], i);
            }

            _this6._openedBefore = true;
          }

          if (_this6.open) {
            _this6._layout();
          } // we toggle "is-selected" on the target to indicate that the over is open


          var targetElement = _this6._getTarget();

          if (targetElement) {
            targetElement.classList.toggle('is-selected', _this6.open);
          }
        });
      }
    }], [{
      key: "placement",
      get: function get() {
        return placement$2;
      }
      /**
       Returns {@link QuickActions} target options.
        @return {QuickActionsTargetEnum}
       */

    }, {
      key: "target",
      get: function get() {
        return target$2;
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['threshold']);
      }
    }]);

    return _class;
  }(ExtensibleOverlay));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var translations$j = {
    "en-US": {
      "More actions": "More actions"
    },
    "fr-FR": {
      "More actions": "Autres actions"
    },
    "de-DE": {
      "More actions": "Weitere Aktionen"
    },
    "it-IT": {
      "More actions": "Altre azioni"
    },
    "es-ES": {
      "More actions": "Más acciones"
    },
    "pt-BR": {
      "More actions": "Mais ações"
    },
    "ja-JP": {
      "More actions": "その他のアクション"
    },
    "ko-KR": {
      "More actions": "추가 작업"
    },
    "zh-CN": {
      "More actions": "更多操作"
    },
    "zh-TW": {
      "More actions": "更多動作"
    },
    "nl-NL": {
      "More actions": "Meer acties"
    },
    "da-DK": {
      "More actions": "Flere handlinger"
    },
    "fi-FI": {
      "More actions": "Lisää toimintoja"
    },
    "nb-NO": {
      "More actions": "Flere handlinger"
    },
    "sv-SE": {
      "More actions": "Fler åtgärder"
    },
    "cs-CZ": {
      "More actions": "Další akce"
    },
    "pl-PL": {
      "More actions": "Więcej czynności"
    },
    "ru-RU": {
      "More actions": "Другие действия"
    },
    "tr-TR": {
      "More actions": "Daha fazla işlem"
    }
  };

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons.extend(strings, {
    'coral-component-quickactions': translations$j
  }); // Expose component on the Coral namespace

  commons._define('coral-quickactions-item', QuickActionsItem);

  commons._define('coral-quickactions', QuickActions);

  QuickActions.Item = QuickActionsItem;

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var helpTranslations = {
    "en-US": {
      "Search for Help": "Search for Help",
      "Searching Help…": "Searching Help…",
      "Error fetching results": "Error fetching results",
      "No results found": "No results found",
      "See all {0} results": "See all {0} results"
    },
    "fr-FR": {
      "Search for Help": "Rechercher de l’aide",
      "Searching Help…": "Recherche dans l’aide…",
      "Error fetching results": "Erreur lors de la récupération des résultats",
      "No results found": "Aucun résultat trouvé",
      "See all {0} results": "Voir les {0} résultats"
    },
    "de-DE": {
      "Search for Help": "Nach Hilfe suchen",
      "Searching Help…": "Suche nach Hilfe …",
      "Error fetching results": "Fehler beim Abruf von Ergebnissen",
      "No results found": "Keine Ergebnisse gefunden",
      "See all {0} results": "Alle {0} Ergebnisse anzeigen"
    },
    "it-IT": {
      "Search for Help": "Cerca informazioni nell'Aiuto",
      "Searching Help…": "Ricerca aiuto…",
      "Error fetching results": "Errore durante il recupero dei risultati",
      "No results found": "Nessun risultato trovato",
      "See all {0} results": "Visualizza tutti i {0} risultati"
    },
    "es-ES": {
      "Search for Help": "Buscar ayuda",
      "Searching Help…": "Buscando ayuda…",
      "Error fetching results": "Error al obtener los resultados",
      "No results found": "No se han encontrado resultados",
      "See all {0} results": "Ver los {0} resultados"
    },
    "pt-BR": {
      "Search for Help": "Procurar nas seções de Ajuda",
      "Searching Help…": "Procurando ajuda…",
      "Error fetching results": "Erro ao obter resultados",
      "No results found": "Nenhum resultado encontrado",
      "See all {0} results": "Ver todos os resultados de {0}"
    },
    "ja-JP": {
      "Search for Help": "ヘルプを検索",
      "Searching Help…": "ヘルプを検索中…",
      "Error fetching results": "結果を取得中にエラーが発生しました",
      "No results found": "結果が見つかりませんでした",
      "See all {0} results": "すべての {0} 結果を確認"
    },
    "ko-KR": {
      "Search for Help": "도움말 검색",
      "Searching Help…": "도움말 검색 중…",
      "Error fetching results": "결과를 가져오는 중 오류 발생",
      "No results found": "결과를 찾을 수 없습니다",
      "See all {0} results": "총 {0}개 결과 보기"
    },
    "zh-CN": {
      "Search for Help": "搜索帮助",
      "Searching Help…": "正在搜索帮助…",
      "Error fetching results": "获取结果时出错",
      "No results found": "找不到任何结果",
      "See all {0} results": "查看全部 {0} 个结果"
    },
    "zh-TW": {
      "Search for Help": "搜尋說明",
      "Searching Help…": "正在搜尋說明…",
      "Error fetching results": "擷取結果時發生錯誤",
      "No results found": "找不到結果",
      "See all {0} results": "查看全部 {0} 個結果"
    },
    "nl-NL": {
      "Search for Help": "Zoeken naar hulp",
      "Searching Help…": "Hulp zoeken…",
      "Error fetching results": "Fout bij ophalen resultaten",
      "No results found": "Geen resultaten gevonden",
      "See all {0} results": "Alle {0} resultaten bekijken"
    },
    "da-DK": {
      "Search for Help": "Søg efter Hjælp...",
      "Searching Help…": "Søger i Hjælp...",
      "Error fetching results": "Fejl ved hentning af resultater",
      "No results found": "Ingen resultater fundet",
      "See all {0} results": "Se alle {0} resultater"
    },
    "fi-FI": {
      "Search for Help": "Hae ohjeita",
      "Searching Help…": "Haun ohje…",
      "Error fetching results": "Tuloksia haettaessa tapahtui virhe.",
      "No results found": "Tuloksia ei löytynyt.",
      "See all {0} results": "Näytä kaikki {0} tulosta"
    },
    "nb-NO": {
      "Search for Help": "Søk etter hjelp",
      "Searching Help…": "Søker i Hjelp …",
      "Error fetching results": "Kan ikke hente resultater",
      "No results found": "Finner ingen resultater",
      "See all {0} results": "Vis alle de {0} resultatene"
    },
    "sv-SE": {
      "Search for Help": "Sök efter hjälp",
      "Searching Help…": "Sökhjälp…",
      "Error fetching results": "Det gick inte att hämta resultat",
      "No results found": "Inga resultat funna",
      "See all {0} results": "Se alla {0} resultat"
    },
    "cs-CZ": {
      "Search for Help": "Vyhledat nápovědu",
      "Searching Help…": "Nápověda hledání…",
      "Error fetching results": "Při shromažďování výsledků došlo k chybě",
      "No results found": "Nebyly nalezeny žádné výsledky",
      "See all {0} results": "Zobrazit všechny výsledky: {0}"
    },
    "pl-PL": {
      "Search for Help": "Szukaj pomocy",
      "Searching Help…": "Trwa przeszukiwanie Pomocy...",
      "Error fetching results": "Błąd pobierania wyników",
      "No results found": "Nie znaleziono żadnych wyników",
      "See all {0} results": "Zobacz wszystkie {0} wyników"
    },
    "ru-RU": {
      "Search for Help": "Поиск справки",
      "Searching Help…": "Поиск по справке…",
      "Error fetching results": "Ошибка получения результатов",
      "No results found": "Результаты не найдены",
      "See all {0} results": "Посмотреть все результаты ({0})"
    },
    "tr-TR": {
      "Search for Help": "Yardım Ara",
      "Searching Help…": "Yardım Aranıyor...",
      "Error fetching results": "Sonuçlar alınırken hata oluştu",
      "No results found": "Sonuç bulunamadı",
      "See all {0} results": "Tüm {0} sonuçlarını gör"
    }
  };

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var orgSwitcherTranslations = {
    "en-US": {
      "Search Organizations": "Search Organizations",
      "No organizations found&period;": "No organizations found."
    },
    "fr-FR": {
      "Search Organizations": "Rechercher des organisations",
      "No organizations found&period;": "Aucune organisation trouvée."
    },
    "de-DE": {
      "Search Organizations": "Organisationen durchsuchen",
      "No organizations found&period;": "Keine Organisationen gefunden."
    },
    "it-IT": {
      "Search Organizations": "Cerca organizzazioni",
      "No organizations found&period;": "Nessuna organizzazione trovata."
    },
    "es-ES": {
      "Search Organizations": "Buscar organizaciones",
      "No organizations found&period;": "No se ha encontrado ninguna organización."
    },
    "pt-BR": {
      "Search Organizations": "Procurar organizações",
      "No organizations found&period;": "Nenhuma organização encontrada."
    },
    "ja-JP": {
      "Search Organizations": "組織を検索",
      "No organizations found&period;": "組織が見つかりませんでした。"
    },
    "ko-KR": {
      "Search Organizations": "조직 검색",
      "No organizations found&period;": "조직을 찾을 수 없습니다."
    },
    "zh-CN": {
      "Search Organizations": "搜索组织",
      "No organizations found&period;": "找不到任何组织。"
    },
    "zh-TW": {
      "Search Organizations": "搜尋組織",
      "No organizations found&period;": "找不到組織。"
    },
    "nl-NL": {
      "Search Organizations": "Organisaties zoeken",
      "No organizations found&period;": "Geen organisaties gevonden."
    },
    "da-DK": {
      "Search Organizations": "Søg i virksomheder",
      "No organizations found&period;": "Ingen virksomheder fundet."
    },
    "fi-FI": {
      "Search Organizations": "Hae organisaatioita",
      "No organizations found&period;": "Organisaatioita ei löytynyt."
    },
    "nb-NO": {
      "Search Organizations": "Søk etter organisasjoner",
      "No organizations found&period;": "Finner ingen organisasjoner."
    },
    "sv-SE": {
      "Search Organizations": "Sökorganisationer",
      "No organizations found&period;": "Inga organisationer funna."
    },
    "cs-CZ": {
      "Search Organizations": "Hledat ve společnostech",
      "No organizations found&period;": "Nebyly nalezeny žádné společnosti."
    },
    "pl-PL": {
      "Search Organizations": "Wyszukaj organizacje",
      "No organizations found&period;": "Nie znaleziono żadnych organizacji."
    },
    "ru-RU": {
      "Search Organizations": "Искать организации",
      "No organizations found&period;": "Организации не найдены."
    },
    "tr-TR": {
      "Search Organizations": "Kuruluşları ara",
      "No organizations found&period;": "Kuruluş bulunamadı."
    }
  };

  var CLASSNAME$18 = '_coral-Shell';
  /**
   @class Coral.Shell
   @classdesc The Shell base component to be used with its family for console like applications. See examples for how to
   integrate all Shell sub components.
   @htmltag coral-shell
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var Shell = /*#__PURE__*/function (_BaseComponent) {
    _inherits(Shell, _BaseComponent);

    var _super = _createSuper(Shell);

    /** @ignore */
    function Shell() {
      var _this;

      _classCallCheck(this, Shell);

      _this = _super.call(this); // Prepare templates

      _this._elements = {
        // Fetch or create the content zone elements
        header: _this.querySelector('coral-shell-header') || document.createElement('coral-shell-header'),
        content: _this.querySelector('coral-shell-content') || document.createElement('coral-shell-content')
      };
      return _this;
    }
    /**
     The menu collection.
      @type {Collection}
     @readonly
     */


    _createClass(Shell, [{
      key: "render",

      /** @ignore */
      value: function render() {
        var _this2 = this;

        _get(_getPrototypeOf(Shell.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$18);
        var header = this._elements.header;
        var menus = this.menus.getAll();
        var content = this._elements.content; // If the the content zone is not provided, we need to make sure that it holds all children

        if (!content.parentNode) {
          // Remove header
          if (header.parentNode) {
            header.parentNode.removeChild(header);
          } // Remove menus


          this.menus.clear(); // Move the rest into content

          while (this.firstChild) {
            content.appendChild(this.firstChild);
          }
        } // Call the content zone insert


        this.header = header;
        menus.forEach(function (menu) {
          return _this2.menus.add(menu);
        });
        this.content = content;
      }
    }, {
      key: "menus",
      get: function get() {
        // Construct the collection on first request:
        if (!this._menus) {
          this._menus = new Collection$1({
            host: this,
            itemTagName: 'coral-shell-menu'
          });
        }

        return this._menus;
      }
      /**
       The shell header zone.
        @type {ShellHeader}
       @contentzone
       */

    }, {
      key: "header",
      get: function get() {
        return this._getContentZone(this._elements.header);
      },
      set: function set(value) {
        this._setContentZone('header', value, {
          handle: 'header',
          tagName: 'coral-shell-header',
          insert: function insert(header) {
            this.insertBefore(header, this.firstChild);
          }
        });
      }
      /**
       The shell content zone.
        @type {ShellContent}
       @contentzone
       */

    }, {
      key: "content",
      get: function get() {
        return this._getContentZone(this._elements.content);
      },
      set: function set(value) {
        this._setContentZone('content', value, {
          handle: 'content',
          tagName: 'coral-shell-content',
          insert: function insert(content) {
            this.appendChild(content);
          }
        });
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-shell-header': 'header',
          'coral-shell-content': 'content'
        };
      }
    }]);

    return Shell;
  }(BaseComponent(HTMLElement));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Shell.Content
   @classdesc Shell's content component
   @htmltag coral-shell-content
   @return {HTMLElement}
   */
  var ShellContent = (function () {
    return document.createElement('coral-shell-content');
  });

  var CLASSNAME$19 = '_coral-Shell-header';
  /**
   @class Coral.Shell.Header
   @classdesc A Shell Header component
   @htmltag coral-shell-header
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var ShellHeader = /*#__PURE__*/function (_BaseComponent) {
    _inherits(ShellHeader, _BaseComponent);

    var _super = _createSuper(ShellHeader);

    /** @ignore */
    function ShellHeader() {
      var _this;

      _classCallCheck(this, ShellHeader);

      _this = _super.call(this); // Prepare templates

      _this._elements = {
        // Fetch or create the content zone elements
        home: _this.querySelector('coral-shell-header-home') || document.createElement('coral-shell-header-home'),
        actions: _this.querySelector('coral-shell-header-actions') || document.createElement('coral-shell-header-actions'),
        content: _this.querySelector('coral-shell-header-content') || document.createElement('coral-shell-header-content')
      };

      Overlay._OverlayManager.push(_assertThisInitialized(_this));

      return _this;
    }
    /**
     The label of the panel.
      @type {HTMLElement}
     @contentzone
     */


    _createClass(ShellHeader, [{
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(ShellHeader.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$19); // appheader only exists on darkest theme

        this.classList.add('coral--darkest', 'u-coral-clearFix');
        var home = this._elements.home;
        var actions = this._elements.actions;
        var content = this._elements.content; // Remove them so we can process children

        if (home.parentNode) {
          home.remove();
        }

        if (actions.parentNode) {
          actions.remove();
        }

        if (content.parentNode) {
          content.remove();
        } // moves everything to the main content zone


        while (this.firstChild) {
          content.appendChild(this.firstChild);
        } // // Call the content zone insert


        this.home = home;
        this.actions = actions;
        this.content = content;
      }
    }, {
      key: "home",
      get: function get() {
        return this._getContentZone(this._elements.home);
      },
      set: function set(value) {
        this._setContentZone('home', value, {
          handle: 'home',
          tagName: 'coral-shell-header-home',
          insert: function insert(content) {
            this.appendChild(content);
          }
        });
      }
      /**
       The main content zone of the panel.
        @type {HTMLElement}
       @contentzone
       */

    }, {
      key: "content",
      get: function get() {
        return this._getContentZone(this._elements.content);
      },
      set: function set(value) {
        this._setContentZone('content', value, {
          handle: 'content',
          tagName: 'coral-shell-header-content',
          insert: function insert(content) {
            this.appendChild(content);
          }
        });
      }
      /**
       The content zone where the actions are placed.
        @type {HTMLElement}
       @contentzone
       */

    }, {
      key: "actions",
      get: function get() {
        return this._getContentZone(this._elements.actions);
      },
      set: function set(value) {
        this._setContentZone('actions', value, {
          handle: 'actions',
          tagName: 'coral-shell-header-actions',
          insert: function insert(content) {
            this.appendChild(content);
          }
        });
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-shell-header-home': 'home',
          'coral-shell-header-content': 'content',
          'coral-shell-header-actions': 'actions'
        };
      }
    }]);

    return ShellHeader;
  }(BaseComponent(HTMLElement));

  var template$M = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["icon"] = document.createElement("coral-icon");
    el0.setAttribute("handle", "icon");
    el0.className += " _coral-Shell-homeAnchor-icon";
    el0.setAttribute("size", "M");
    el0.setAttribute("alt", "");
    frag.appendChild(el0);
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    return frag;
  };

  var CLASSNAME$1a = '_coral-Shell-homeAnchor';
  /**
   @class Coral.Shell.HomeAnchor
   @classdesc A Shell Home Anchor component
   @htmltag coral-shell-homeanchor
   @htmlbasetag a
   @extends {HTMLAnchorElement}
   @extends {BaseComponent}
   */

  var ShellHomeAnchor = /*#__PURE__*/function (_BaseComponent) {
    _inherits(ShellHomeAnchor, _BaseComponent);

    var _super = _createSuper(ShellHomeAnchor);

    /** @ignore */
    function ShellHomeAnchor() {
      var _this;

      _classCallCheck(this, ShellHomeAnchor);

      _this = _super.call(this); // Prepare templates

      _this._elements = {
        // Fetch or create the content zone elements
        label: _this.querySelector('coral-shell-homeanchor-label') || document.createElement('coral-shell-homeanchor-label')
      }; // Create icon by default

      template$M.call(_this._elements);
      return _this;
    }
    /**
     The label of the anchor.
      @type {ShellHomeAnchorLabel}
     @contentzone
     */


    _createClass(ShellHomeAnchor, [{
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(ShellHomeAnchor.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1a); // Create doc fragment

        var fragment = document.createDocumentFragment();
        var label = this._elements.label; // Remove it so we can process children

        if (label.parentNode) {
          this.removeChild(label);
        } // Move any remaining elements into the label


        while (this.firstChild) {
          var child = this.firstChild;

          if (child.nodeType === Node.TEXT_NODE) {
            // Move text elements to the label
            label.appendChild(child);
          } else if (child.nodeName === 'CORAL-ICON') {
            if (!fragment.childNodes.length) {
              // Conserve existing icon element to content
              this._elements.icon = child;
              fragment.appendChild(child);
            } else {
              // Remove cloned icon
              this.removeChild(child);
            }
          } else {
            // Remove anything else
            this.removeChild(child);
          }
        } // Add fragment back


        this.appendChild(fragment); // Insert icon and label insert

        this.icon = this.icon;
        this.label = label;
      }
    }, {
      key: "label",
      get: function get() {
        return this._getContentZone(this._elements.label);
      },
      set: function set(value) {
        this._setContentZone('label', value, {
          handle: 'label',
          tagName: 'coral-shell-homeanchor-label',
          insert: function insert(content) {
            this.appendChild(content);
          }
        });
      }
      /**
       Specifies the icon name used in the anchor. See {@link Coral.Icon} for valid icon names.
        @type {String}
       @default ""
       @htmlattribute icon
       */

    }, {
      key: "icon",
      get: function get() {
        return this._elements.icon.icon;
      },
      set: function set(value) {
        this._elements.icon.icon = value; // removes the icon element from the DOM.

        if (this.icon === '') {
          this._elements.icon.remove();
        } // adds the icon back since it was blown away by textContent
        else if (!this.contains(this._elements.icon)) {
            this.insertBefore(this._elements.icon, this.firstChild);
          }
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-shell-homeanchor-label': 'label'
        };
      }
      /** @ignore */

    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(ShellHomeAnchor), "observedAttributes", this).concat(['icon']);
      }
    }]);

    return ShellHomeAnchor;
  }(BaseComponent(HTMLAnchorElement));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Shell.HomeAnchor.Label
   @classdesc Shell HomeAnchor's label component
   @htmltag coral-shell-homeanchor-label
   @return {HTMLElement}
   */
  var ShellHomeAnchorLabel = (function () {
    return document.createElement('coral-shell-homeanchor-label');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var translations$k = {
    "it-IT": {
      "Clear search": "Azzera ricerca"
    },
    "ja-JP": {
      "Clear search": "検索をクリア"
    },
    "es-ES": {
      "Clear search": "Borrar búsqueda"
    },
    "ko-KR": {
      "Clear search": "검색 지우기"
    },
    "zh-CN": {
      "Clear search": "清除搜索"
    },
    "zh-TW": {
      "Clear search": "清除搜尋"
    },
    "pt-BR": {
      "Clear search": "Limpar busca"
    },
    "nl-NL": {
      "Clear search": "Zoekopdracht wissen"
    },
    "en-US": {
      "Clear search": "Clear search"
    },
    "de-DE": {
      "Clear search": "Suche löschen"
    },
    "fr-FR": {
      "Clear search": "Effacer la recherche"
    },
    "da-DK": {
      "Clear search": "Slet søgning"
    },
    "fi-FI": {
      "Clear search": "Tyhjennä haku"
    },
    "nb-NO": {
      "Clear search": "Fjern søk"
    },
    "sv-SE": {
      "Clear search": "Rensa sökningen"
    },
    "cs-CZ": {
      "Clear search": "Vymazat hledání"
    },
    "pl-PL": {
      "Clear search": "Wyczyść wyniki wyszukiwania"
    },
    "ru-RU": {
      "Clear search": "Очистить поиск"
    },
    "tr-TR": {
      "Clear search": "Aramayı temizle"
    }
  };

  var template$N = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var data = data_0 = typeof data_0 === "undefined" ? {} : data_0;
    var el0 = this["input"] = document.createElement("input", "coral-textfield");
    el0.setAttribute("type", "search");
    el0.className += " _coral-Search-input";
    el0.setAttribute("is", "coral-textfield");
    el0.setAttribute("handle", "input");
    frag.appendChild(el0);
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    var el2 = this["clearButton"] = document.createElement("button", "coral-button");
    el2.setAttribute("type", "button");
    el2.setAttribute("aria-label", data_0["i18n"]["get"]('Clear search'));
    el2.setAttribute("is", "coral-button");
    el2.setAttribute("variant", "_custom");
    el2.className += " _coral-Search-clear _coral-ClearButton";
    el2.setAttribute("handle", "clearButton");
    var el3 = document.createTextNode("\n  ");
    el2.appendChild(el3);
    var el4 = this["clearButtonLabel"] = document.createElement("coral-button-label");
    el4.setAttribute("handle", "clearButtonLabel");
    el2.appendChild(el4);
    var el5 = document.createTextNode("\n  ");
    el2.appendChild(el5);
    data = data_0; // Don't wait for button MO to pick up the label

    this.clearButton._elements.label = this.clearButtonLabel; // Render icon

    this.clearButton.insertAdjacentHTML('beforeend', data.Icon._renderSVG('spectrum-css-icon-CrossSmall', ['_coral-UIIcon-CrossSmall']));
    data_0 = data;
    var el7 = document.createTextNode("\n");
    el2.appendChild(el7);
    frag.appendChild(el2);
    var el8 = document.createTextNode("\n");
    frag.appendChild(el8);
    return frag;
  };

  var CLASSNAME$1b = '_coral-Search';
  /**
   Enumeration for {@link Search} variants.

   @typedef {Object} SearchVariantEnum

   @property {String} DEFAULT
   A default, gray search input.
   @property {String} QUIET
   A search with no border, no background, no glow.
   */

  var variant$i = {
    DEFAULT: 'default',
    QUIET: 'quiet'
  };
  /**
   @class Coral.Search
   @classdesc A Search component is a search styled form field.
   @htmltag coral-search
   @extends {HTMLElement}
   @extends {BaseComponent}
   @extends {BaseFormField}
   */

  var Search = Decorator( /*#__PURE__*/function (_BaseFormField) {
    _inherits(_class, _BaseFormField);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this);

      _this._delegateEvents(commons.extend(_this._events, {
        // @todo use Coral.keys when key combos don't interfere with single key execution
        'keydown [handle=input]': '_onEnterKey',
        'keyup [handle=input]': '_onKeyUp',
        // @todo use coralinternalinput from Autocomplete
        'input [handle=input]': '_triggerInputEvent',
        'key:escape [handle=input]': '_clearInput',
        'click [handle=clearButton]:not(:disabled)': '_clearInput'
      })); // Prepare templates


      _this._elements = {};
      template$N.call(_this._elements, {
        i18n: i18n,
        Icon: Icon
      }); // Pre-define labellable element

      _this._labellableElement = _this._elements.input;
      return _this;
    }
    /**
     Name used to submit the data in a form.
     @type {String}
     @default ""
     @htmlattribute name
     @htmlattributereflected
     */


    _createClass(_class, [{
      key: "_triggerInputEvent",

      /** @ignore */
      value: function _triggerInputEvent() {
        this.trigger('coral-search:input');
      }
      /**
       Handles the up action by steping up the Search. It prevents the default action.
        @ignore
       */

    }, {
      key: "_onEnterKey",
      value: function _onEnterKey(event) {
        if (event.which === 13) {
          event.preventDefault(); // stops interaction if the search is disabled

          if (this.disabled) {
            return;
          }

          this.trigger('coral-search:submit');
        }
      }
      /**
       Handles the keydown action.
        @ignore
       */

    }, {
      key: "_onKeyUp",
      value: function _onKeyUp() {
        this._updateClearButton();
      }
      /**
       Updates the clear button's display status.
        @ignore
       */

    }, {
      key: "_updateClearButton",
      value: function _updateClearButton() {
        this._elements.clearButton.style.display = this._elements.input.value === '' ? 'none' : '';
      }
      /**
       Clears the text in the input box.
        @ignore
       */

    }, {
      key: "_clearInput",
      value: function _clearInput() {
        this._elements.input.value = '';

        this._updateClearButton();

        this._elements.input.focus(); // If we've been cleared, trigger the event


        this.trigger('coral-search:clear');
      } // overrides the behavior from BaseFormField

    }, {
      key: "reset",
      value: function reset() {
        // since there is an internal value, this one handles the reset
        this._elements.input.reset();

        this._updateClearButton();
      } // overrides the behavior from BaseFormField

    }, {
      key: "clear",
      value: function clear() {
        // since there is an internal value, this one handles the clear
        this._elements.input.clear();

        this._updateClearButton();
      }
      /**
       Returns {@link Search} variants.
        @return {SearchVariantEnum}
       */

    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1b); // Default reflected attributes

        if (!this._icon) {
          this.icon = 'search';
        }

        if (!this._variant) {
          this.variant = variant$i.DEFAULT;
        } // Support cloneNode


        var templates = this.querySelectorAll('._coral-Search-input, ._coral-Search-icon, ._coral-Search-clear');

        for (var i = 0; i < templates.length; i++) {
          templates[i].remove();
        } // Create a fragment


        var fragment = document.createDocumentFragment(); // Render the main template

        fragment.appendChild(this._elements.input);
        fragment.appendChild(this._elements.clearButton); // Add the frag to the component

        this.appendChild(fragment); // Insert search icon

        this._elements.input.insertAdjacentHTML('afterend', Icon._renderSVG('spectrum-css-icon-Magnifier', ['_coral-Search-icon', '_coral-UIIcon-Magnifier']));

        this._updateClearButton();
      }
      /**
       Triggered when {@link Search} input is given.
        @typedef {CustomEvent} coral-search:input
       */

      /**
       Triggered when the user presses {@link Search} enter.
        @typedef {CustomEvent} coral-search:submit
       */

      /**
       Triggered when the {@link Search} is cleared.
        @typedef {CustomEvent} coral-search:clear
       */

    }, {
      key: "name",
      get: function get() {
        return this._elements.input.name;
      },
      set: function set(value) {
        this._reflectAttribute('name', value);

        this._elements.input.name = value;
      }
      /**
       The submitted input value. Changing this value will not trigger an event.
        @type {String}
       @default ""
       @htmlattribute value
       */

    }, {
      key: "value",
      get: function get() {
        return this._elements.input.value || '';
      },
      set: function set(value) {
        this._elements.input.value = value;

        this._updateClearButton();
      }
      /**
       Whether this field is disabled or not.
       @type {Boolean}
       @default false
       @htmlattribute disabled
       @htmlattributereflected
       */

    }, {
      key: "disabled",
      get: function get() {
        return this._disabled || false;
      },
      set: function set(value) {
        this._disabled = transform.booleanAttr(value);

        this._reflectAttribute('disabled', this._disabled);

        this[this._disabled ? 'setAttribute' : 'removeAttribute']('aria-disabled', this._disabled);
        this.classList.toggle('is-disabled', this._disabled);
        this._elements.input.disabled = this._disabled;
        this._elements.clearButton.disabled = this._disabled;
      }
      /**
       Whether this field is required or not.
       @type {Boolean}
       @default false
       @htmlattribute required
       @htmlattributereflected
       */

    }, {
      key: "required",
      get: function get() {
        return this._required || false;
      },
      set: function set(value) {
        this._required = transform.booleanAttr(value);

        this._reflectAttribute('required', this._required);

        this._elements.input.required = this._required;
      }
      /**
       Whether this field is readOnly or not. Indicating that the user cannot modify the value of the control.
       @type {Boolean}
       @default false
       @htmlattribute readonly
       @htmlattributereflected
       */

    }, {
      key: "readOnly",
      get: function get() {
        return this._readOnly || false;
      },
      set: function set(value) {
        this._readOnly = transform.booleanAttr(value);

        this._reflectAttribute('readonly', this._readOnly);

        this._elements.input.readOnly = this._readOnly;
        this._elements.clearButton.disabled = this._readOnly;
      }
      /**
       Inherited from {@link BaseFormField#labelledBy}.
       */

    }, {
      key: "labelledBy",
      get: function get() {
        return _get(_getPrototypeOf(_class.prototype), "labelledBy", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(_class.prototype), "labelledBy", value, this, true); // in case the user focuses the buttons, he will still get a notion of the usage of the component


        this[this.labelledBy ? 'setAttribute' : 'removeAttribute']('aria-labelledby', this.labelledBy);
      }
      /**
       Short hint that describes the expected value of the Search. It is displayed when the Search is empty.
        @type {String}
       @default ""
       @htmlattribute placeholder
       @htmlattributereflected
       */

    }, {
      key: "placeholder",
      get: function get() {
        return this._elements.input.placeholder || '';
      },
      set: function set(value) {
        value = transform.string(value);

        this._reflectAttribute('placeholder', value);

        this._elements.input.placeholder = value;
      }
      /**
       Max length for the Input field.
       @type {Number}
       @htmlattribute maxlength
       @htmlattributereflected
       */

    }, {
      key: "maxLength",
      get: function get() {
        return this._elements.input.maxLength;
      },
      set: function set(value) {
        this._elements.input.maxLength = value;

        this._reflectAttribute('maxlength', this.maxLength);
      }
      /**
       The search's variant. See {@link SearchVariantEnum}.
        @type {String}
       @default SearchVariantEnum.DEFAULT
       @htmlattribute variant
       @htmlattributereflected
       */

    }, {
      key: "variant",
      get: function get() {
        return this._variant || variant$i.DEFAULT;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        this._variant = validate.enumeration(variant$i)(value) && value || variant$i.DEFAULT;

        this._reflectAttribute('variant', this._variant);

        this._elements.input.variant = value;
      }
      /**
       @ignore
        Not supported anymore.
       */

    }, {
      key: "icon",
      get: function get() {
        return this._icon || 'search';
      },
      set: function set(value) {
        this._icon = transform.string(value);

        this._reflectAttribute('icon', this._icon);
      }
      /**
       Inherited from {@link BaseFormField#invalid}.
       */

    }, {
      key: "invalid",
      get: function get() {
        return _get(_getPrototypeOf(_class.prototype), "invalid", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(_class.prototype), "invalid", value, this, true);
      }
    }], [{
      key: "variant",
      get: function get() {
        return variant$i;
      }
    }, {
      key: "_attributePropertyMap",
      get: function get() {
        return commons.extend(_get(_getPrototypeOf(_class), "_attributePropertyMap", this), {
          maxlength: 'maxLength'
        });
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['placeholder', 'icon', 'variant', 'maxlength']);
      }
    }]);

    return _class;
  }(BaseFormField(BaseComponent(HTMLElement))));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons.extend(strings, {
    'coral-component-search': translations$k
  }); // Expose component on the Coral namespace

  commons._define('coral-search', Search);

  var template$O = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var data = data_0 = typeof data_0 === "undefined" ? {} : data_0;
    data = data_0;
    var labelId = data.commons.getUID();
    data_0 = data;
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    var el2 = this["contentWrapper"] = document.createElement("div");
    el2.setAttribute("handle", "contentWrapper");
    var el3 = document.createTextNode("\n  ");
    el2.appendChild(el3);
    var el4 = document.createElement("label");
    el4.className += " u-coral-screenReaderOnly";
    el4.id = labelId;
    el4.textContent = data_0["i18n"]["get"]('Search for Help');
    el2.appendChild(el4);
    var el5 = document.createTextNode("\n  ");
    el2.appendChild(el5);
    var el6 = this["search"] = document.createElement("coral-search");
    el6.className += " _coral-Shell-help-search";
    el6.setAttribute("handle", "search");
    el6.setAttribute("placeholder", data_0["i18n"]["get"]('Search for Help'));
    el6.setAttribute("labelledby", labelId);
    el2.appendChild(el6);
    var el7 = document.createTextNode("\n  ");
    el2.appendChild(el7);
    var el8 = this["items"] = document.createElement("div");
    el8.className += " _coral-Shell-help-items";
    el8.setAttribute("handle", "items");
    el2.appendChild(el8);
    var el9 = document.createTextNode("\n  ");
    el2.appendChild(el9);
    var el10 = this["results"] = document.createElement("coral-anchorlist");
    el10.className += " _coral-Shell-help-results";
    el10.setAttribute("handle", "results");
    el10.setAttribute("hidden", "");
    el2.appendChild(el10);
    var el11 = document.createTextNode("\n  ");
    el2.appendChild(el11);
    var el12 = this["resultMessage"] = document.createElement("div");
    el12.className += " _coral-Shell-help-resultMessage";
    el12.setAttribute("handle", "resultMessage");
    el12.setAttribute("role", "status");
    el12.setAttribute("hidden", "");
    el2.appendChild(el12);
    var el13 = document.createTextNode("\n  ");
    el2.appendChild(el13);
    var el14 = this["loading"] = document.createElement("div");
    el14.className += " _coral-Shell-help-loading";
    el14.setAttribute("handle", "loading");
    el14.setAttribute("role", "status");
    el14.setAttribute("hidden", "");
    var el15 = document.createTextNode("\n    ");
    el14.appendChild(el15);
    var el16 = document.createElement("coral-wait");
    el16.setAttribute("size", "M");
    el16.className += " _coral-Shell-help-loading-wait";
    el14.appendChild(el16);
    var el17 = document.createTextNode("\n    ");
    el14.appendChild(el17);
    var el18 = this["loadingMessage"] = document.createElement("span");
    el18.className += " coral-Heading--2 _coral-Shell-help-loading-info";
    el18.setAttribute("handle", "loadingMessage");
    el18.textContent = data_0["i18n"]["get"]('Searching Help…');
    el14.appendChild(el18);
    var el19 = document.createTextNode("\n  ");
    el14.appendChild(el19);
    el2.appendChild(el14);
    var el20 = document.createTextNode("\n");
    el2.appendChild(el20);
    frag.appendChild(el2);
    var el21 = document.createTextNode("\n");
    frag.appendChild(el21);
    return frag;
  };

  var template$P = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = document.createElement("coral-list-item-content");
    var el1 = document.createTextNode(data_0["title"] + "\n  ");
    el0.appendChild(el1);
    var el2 = document.createElement("div");
    el2.className += " _coral-Shell-help-result-description";
    el2.textContent = data_0["description"];
    el0.appendChild(el2);
    var el3 = document.createTextNode("\n");
    el0.appendChild(el3);
    frag.appendChild(el0);
    var el4 = document.createTextNode("\n");
    frag.appendChild(el4);
    return frag;
  };

  var template$Q = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = document.createElement("div");
    el0.className += " _coral-Shell-help-resultMessage-container";
    var el1 = document.createTextNode("\n  ");
    el0.appendChild(el1);
    var el2 = document.createElement("div");
    el2.className += " coral-Heading--1 _coral-Shell-help-resultMessage-heading";
    el2.textContent = data_0["i18n"]["get"]('Error fetching results');
    el0.appendChild(el2);
    var el3 = document.createTextNode("\n");
    el0.appendChild(el3);
    frag.appendChild(el0);
    var el4 = document.createTextNode("\n");
    frag.appendChild(el4);
    return frag;
  };

  var template$R = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = document.createElement("div");
    el0.className += " _coral-Shell-help-resultMessage-container";
    var el1 = document.createTextNode("\n  ");
    el0.appendChild(el1);
    var el2 = document.createElement("h2");
    el2.className += " coral-heading coral-Heading--2 _coral-Shell-help-resultMessage-heading";
    el2.textContent = data_0["i18n"]["get"]('No results found');
    el0.appendChild(el2);
    frag.appendChild(el0);
    var el3 = document.createTextNode("\n");
    frag.appendChild(el3);
    return frag;
  };

  var CLASSNAMES$2 = ['_coral-Menu', '_coral-AnchorList', '_coral-Shell-help'];
  /**
   @class Coral.Shell.Help
   @classdesc A Shell Help component
   @htmltag coral-shell-help
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var ShellHelp = /*#__PURE__*/function (_BaseComponent) {
    _inherits(ShellHelp, _BaseComponent);

    var _super = _createSuper(ShellHelp);

    /** @ignore */
    function ShellHelp() {
      var _this;

      _classCallCheck(this, ShellHelp);

      _this = _super.call(this); // Prepare templates

      _this._elements = {};
      template$O.call(_this._elements, {
        commons: commons,
        i18n: i18n
      }); // Events

      _this._delegateEvents({
        'coral-search:clear': '_showItems',
        'coral-search:submit': '_performSearch'
      }); // Item handling


      _this.items._startHandlingItems(true);

      return _this;
    }
    /**
     The item collection.
      @type {Collection}
     @readonly
     */


    _createClass(ShellHelp, [{
      key: "_moveItems",

      /** @private */
      value: function _moveItems() {
        var _this2 = this;

        this.setAttribute('id', this.id || commons.getUID());
        var selector = "#".concat(this.id, " > a[is=\"coral-shell-help-item\"], coral-shell-help-separator");
        Array.prototype.forEach.call(this.querySelectorAll(selector), function (item) {
          _this2._elements.items.appendChild(item);
        });
      }
      /** @private */

    }, {
      key: "_performSearch",
      value: function _performSearch(event) {
        event.stopPropagation(); // Show loading

        this._elements.items.hidden = true;

        this._showLoading();

        this._elements.resultMessage.hidden = true;
        this._elements.results.hidden = true; // Trigger event

        var searchTerm = this._elements.search.value;
        this.trigger('coral-shell-help:search', {
          value: searchTerm
        });
      }
      /** @private */

    }, {
      key: "_showItems",
      value: function _showItems(event) {
        event.stopPropagation(); // Hide search results

        this._elements.results.hidden = true; // Hide loading

        this._hideLoading(); // Hide no-results


        this._elements.resultMessage.hidden = true; // Show items

        this._elements.items.hidden = false;
      }
      /** @private */

    }, {
      key: "_clearTimeout",
      value: function _clearTimeout(timeoutName) {
        if (this[timeoutName]) {
          window.clearTimeout(this[timeoutName]);
          this[timeoutName] = undefined;
        }
      }
      /** @private */

    }, {
      key: "_showMessage",
      value: function _showMessage(elementName, message) {
        var el = this._elements[elementName];
        var timeoutName = "_".concat(elementName, "Timeout"); // Show message element

        el.hidden = false; // Add message text after 150ms delay to give screen readers enough
        // time to recognize the live region and respond to the text update

        this._clearTimeout(timeoutName);

        this[timeoutName] = window.setTimeout(function () {
          return el.appendChild(message);
        }, 150);
      }
      /** @private */

    }, {
      key: "_showLoading",
      value: function _showLoading() {
        if (!this._elements.loading.hidden) {
          return;
        }

        if (this._elements.loading.contains(this._elements.loadingMessage)) {
          this._elements.loadingMessage = this._elements.loading.removeChild(this._elements.loadingMessage);
        }

        this._showMessage('loading', this._elements.loadingMessage);
      }
      /** @private */

    }, {
      key: "_hideLoading",
      value: function _hideLoading() {
        if (this._elements.loading.hidden) {
          return;
        }

        this._elements.loading.hidden = true; // clear the timeout

        this._clearTimeout('_loadingTimeout');

        if (this._elements.loading.contains(this._elements.loadingMessage)) {
          this._elements.loadingMessage = this._elements.loading.removeChild(this._elements.loadingMessage);
        }
      }
      /**
       Indicate to the user that an error has occurred
       */

    }, {
      key: "showError",
      value: function showError() {
        // Hide loading
        this._hideLoading();

        this._elements.resultMessage.innerHTML = ''; // Show the error message

        this._showMessage('resultMessage', template$Q.call(this._elements, {
          i18n: i18n
        }));
      }
      /**
       Show a set of search results.
        @param {Array.<ShellHelpResult>} results
       A set of search result objects.
       @param {Number} total
       The total number of results.
       @param {String} allResultsURL
       The URL at which all results will be displayed.
       */

    }, {
      key: "showResults",
      value: function showResults(results, total, allResultsURL) {
        var _this3 = this;

        // Hide loading
        this._hideLoading(); // clear setTimeout


        if (this._showResultsTimeout) {
          window.clearTimeout(this._showResultsTimeout);
          this._showResultsTimeout = undefined;
        }

        if (!results || total === 0) {
          // Clear existing result message
          this._elements.resultMessage.innerHTML = ''; // Indicate to the user that no results were found

          this._showMessage('resultMessage', template$R.call(this._elements, {
            i18n: i18n
          }));
        } else {
          // Clear existing results
          this._elements.results.innerHTML = ''; // Populate results

          results.forEach(function (result) {
            // Tweak: make the space between bullets larger with a non-breaking space
            var separator = ' & ';
            var description = result.tags.join(separator);
            var item = new AnchorList.Item().set({
              href: result.href,
              target: result.target
            });
            item.classList.add('_coral-Shell-help-result-item');
            item.content = template$P.call(_this3._elements, {
              title: result.title,
              description: description
            }).firstElementChild;

            _this3._elements.results.appendChild(item);
          }); // Show results

          this._elements.results.hidden = false; // Show total

          if (total > 1) {
            var seeAllItem = new AnchorList.Item().set({
              href: allResultsURL,
              content: {
                innerHTML: i18n.get('See all {0} results', total)
              },
              target: '_blank'
            }); // Look like a link

            seeAllItem.content.classList.add('coral-Link');

            this._elements.results.appendChild(seeAllItem);
          }
        }
      }
      /** @ignore */

    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        var _this$classList,
            _this4 = this;

        _get(_getPrototypeOf(ShellHelp.prototype), "render", this).call(this);

        (_this$classList = this.classList).add.apply(_this$classList, CLASSNAMES$2); // Move the items into the right place


        this._moveItems();

        var contentWrapper = this.querySelector('[handle="contentWrapper"]'); // Support cloneNode

        if (contentWrapper) {
          this._elements.contentWrapper = contentWrapper;
          ['search', 'result', 'items', 'results', 'resultMessage', 'loading'].forEach(function (handle) {
            _this4._elements[handle] = _this4.querySelector("[handle=\"".concat(handle, "\"]"));
          });
          this._items._container = this._elements.items;
        } else {
          this.appendChild(this._elements.contentWrapper);
        }
      }
      /**
       A search result object.
        @typedef {Object} ShellHelpResult
        @property {String} title
       The title of the search result.
       @property {String} href
       The URL of the search result.
       @property {String} target
       This property specifies where to display the search result. Use this property only if the href property is present.
       @property {Array.<String>} tags
       A set of tags associated with the search result.
       */

      /**
       Triggered when the user submits a search term
        @event Coral.Shell.Help#coral-shell-help:search
        @param {Object} event
       Event object.
       @param {HTMLElement} event.detail.value
       The user-provided input value aka the search-term
       */

    }, {
      key: "items",
      get: function get() {
        // Construct the collection on first request:
        if (!this._items) {
          this._items = new Collection$1({
            host: this,
            itemTagName: 'coral-shell-help-item',
            itemBaseTagName: 'a',
            container: this._elements.items
          });
        }

        return this._items;
      }
      /**
       The search field placeholder.
        @type {String}
       @default ""
       @htmlattribute placeholder
       */

    }, {
      key: "placeholder",
      get: function get() {
        return this._elements.search.placeholder;
      },
      set: function set(value) {
        this._elements.search.placeholder = value;
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(ShellHelp), "observedAttributes", this).concat(['placeholder']);
      }
    }]);

    return ShellHelp;
  }(BaseComponent(HTMLElement));

  var CLASSNAME$1c = '_coral-Shell-help-item';
  /**
   @class Coral.Shell.Help.Item
   @classdesc A Shell Help item component
   @htmltag coral-shell-help-item
   @extends {AnchorListItem}
   */

  var ShellHelpItem = /*#__PURE__*/function (_AnchorList$Item) {
    _inherits(ShellHelpItem, _AnchorList$Item);

    var _super = _createSuper(ShellHelpItem);

    function ShellHelpItem() {
      _classCallCheck(this, ShellHelpItem);

      return _super.apply(this, arguments);
    }

    _createClass(ShellHelpItem, [{
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(ShellHelpItem.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1c);
      }
    }]);

    return ShellHelpItem;
  }(AnchorList.Item);

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Shell.Help.Separator
   @classdesc Shell's help separator
   @htmltag coral-shell-help-separator
   @return {HTMLElement}

   @deprecated
   */
  var ShellHelpSeparator = (function () {
    return document.createElement('coral-shell-help-separator');
  });

  var CLASSNAME$1d = '_coral-Shell-menu';
  /**
   @class Coral.Shell.Menu
   @classdesc A Shell Menu component
   @htmltag coral-shell-menu
   @extends {Popover}
   */

  var ShellMenu = /*#__PURE__*/function (_Popover) {
    _inherits(ShellMenu, _Popover);

    var _super = _createSuper(ShellMenu);

    function ShellMenu() {
      _classCallCheck(this, ShellMenu);

      return _super.apply(this, arguments);
    }

    _createClass(ShellMenu, [{
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(ShellMenu.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1d);
        this.trigger('coral-shell-menu:_connected');
      }
    }, {
      key: "within",

      /**
       Inherited from {@link Popover#within}.
       */
      get: function get() {
        // Force 'coral-shell'
        return document.querySelector('coral-shell') || 'coral-shell';
      },
      set: function set(value) {
        _set(_getPrototypeOf(ShellMenu.prototype), "within", value, this, true);
      }
      /**
       Inherited from {@link Popover#placement}.
       */

    }, {
      key: "placement",
      get: function get() {
        // Force bottom placement
        return this.constructor.placement.BOTTOM;
      },
      set: function set(value) {
        _set(_getPrototypeOf(ShellMenu.prototype), "placement", value, this, true);
      }
      /**
       Whether the overlay should use all available space.
        @type {Boolean}
       @default false
       @htmlattribute full
       @htmlattributereflected
       */

    }, {
      key: "full",
      get: function get() {
        return this._full || false;
      },
      set: function set(value) {
        this._full = transform.booleanAttr(value);

        this._reflectAttribute('full', this._full);

        this.classList.toggle("".concat(CLASSNAME$1d, "--full"), this._full);
      }
      /** @ignore */

    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(ShellMenu), "observedAttributes", this).concat(['full']);
      }
    }]);

    return ShellMenu;
  }(Popover);

  var CLASSNAME$1e = '_coral-Shell-menubar';
  /**
   @class Coral.Shell.MenuBar
   @classdesc A Shell MenuBar component
   @htmltag coral-shell-menubar
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var ShellMenuBar = /*#__PURE__*/function (_BaseComponent) {
    _inherits(ShellMenuBar, _BaseComponent);

    var _super = _createSuper(ShellMenuBar);

    /** @ignore */
    function ShellMenuBar() {
      var _this;

      _classCallCheck(this, ShellMenuBar);

      _this = _super.call(this);

      _this.setAttribute('role', 'list');

      _this.items._startHandlingItems(true);

      return _this;
    }
    /**
     The item collection.
      @type {Collection}
     @readonly
     */


    _createClass(ShellMenuBar, [{
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(ShellMenuBar.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1e);
      }
    }, {
      key: "items",
      get: function get() {
        // Construct the collection on first request:
        if (!this._items) {
          this._items = new Collection$1({
            host: this,
            itemTagName: 'coral-shell-menubar-item'
          });
        }

        return this._items;
      }
    }]);

    return ShellMenuBar;
  }(BaseComponent(HTMLElement));

  var template$S = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["shellMenuButton"] = document.createElement("button", "coral-button");
    el0.setAttribute("is", "coral-button");
    el0.setAttribute("variant", "quietaction");
    el0.setAttribute("iconsize", "S");
    el0.className += " _coral-Shell-menu-button";
    el0.setAttribute("handle", "shellMenuButton");
    el0.setAttribute("type", "button");
    var el1 = document.createTextNode("\n  ");
    el0.appendChild(el1);
    var el2 = this["shellMenuButtonLabel"] = document.createElement("coral-button-label");
    el2.setAttribute("handle", "shellMenuButtonLabel");
    el0.appendChild(el2);
    var el3 = document.createTextNode("\n");
    el0.appendChild(el3);
    frag.appendChild(el0);
    var el4 = document.createTextNode("\n");
    frag.appendChild(el4);
    return frag;
  };

  /**
   Enumeration for {@link ShellMenuBarItem} icon variants.

   @typedef {Object} ShellMenuBarItemIconVariantEnum

   @property {String} DEFAULT
   A default menubar item.
   @property {String} CIRCLE
   A round image as menubar item.
   */

  var iconVariant = {
    DEFAULT: 'default',
    CIRCLE: 'circle'
  };
  /**
   Enumeration for valid aria-haspopup values.

   @typedef {Object} ShellMenuBarItemHasPopupRoleEnum
   @property {String} MENU
   ShellMenuBarItem opens a menu.
   @property {String} LISTBOX
   ShellMenuBarItem opens a list box.
   @property {String} TREE
   ShellMenuBarItem opens a tree.
   @property {String} GRID
   ShellMenuBarItem opens a grid.
   @property {String} DIALOG
   ShellMenuBarItem opens a dialog.
   @property {Null} DEFAULT
   Defaults to null.

   */

  var hasPopupRole = {
    MENU: 'menu',
    LISTBOX: 'listbox',
    TREE: 'tree',
    GRID: 'grid',
    DIALOG: 'dialog',
    DEFAULT: null
  }; // the Menubar Item's base classname

  var CLASSNAME$1f = '_coral-Shell-menubar-item'; // Builds a string containing all possible iconVariant classnames. This will be used to remove classnames when the variant
  // changes

  var ALL_ICON_VARIANT_CLASSES = [];

  for (var variantValue$8 in iconVariant) {
    ALL_ICON_VARIANT_CLASSES.push("".concat(CLASSNAME$1f, "--").concat(iconVariant[variantValue$8]));
  }
  /**
   @class Coral.Shell.MenuBar.Item
   @classdesc A Shell MenuBar Item component
   @htmltag coral-shell-menubar-item
   @extends {HTMLElement}
   @extends {BaseComponent}
   */


  var ShellMenuBarItem = /*#__PURE__*/function (_BaseComponent) {
    _inherits(ShellMenuBarItem, _BaseComponent);

    var _super = _createSuper(ShellMenuBarItem);

    /** @ignore */
    function ShellMenuBarItem() {
      var _this;

      _classCallCheck(this, ShellMenuBarItem);

      _this = _super.call(this); // Templates

      _this._elements = {};
      template$S.call(_this._elements); // Events

      _this._delegateEvents({
        'click [handle="shellMenuButton"]': '_handleButtonClick',
        // it has to be global because the menus are not direct children
        'global:coral-overlay:close': '_handleOverlayEvent',
        'global:coral-overlay:beforeclose': '_handleOverlayBeforeEvent',
        'global:coral-overlay:open': '_handleOverlayEvent',
        'global:coral-overlay:beforeopen': '_handleOverlayBeforeEvent'
      });

      return _this;
    }
    /**
     Specifies the icon name used inside the menu item.
     See {@link Icon} for valid icon names.
      @type {String}
     @default ""
     @htmlattribute icon
     */


    _createClass(ShellMenuBarItem, [{
      key: "_handleOverlayBeforeEvent",
      value: function _handleOverlayBeforeEvent(event) {
        var target = event.target;

        if (target === this._getMenu()) {
          // Mark button as selected
          this._elements.shellMenuButton.classList.toggle('is-selected', !target.open);
        }
      }
      /** @private */

    }, {
      key: "_handleOverlayEvent",
      value: function _handleOverlayEvent(event) {
        var target = event.target; // matches the open state of the target in case it was open separately

        if (target === this._getMenu()) {
          var shellMenuButton = this._elements.shellMenuButton;

          if (this.open !== target.open) {
            this.open = target.open;
          } else if (shellMenuButton.getAttribute('aria-expanded') !== target.open) {
            shellMenuButton.setAttribute('aria-expanded', target.open);
          }
        }
      }
      /** @ignore */

    }, {
      key: "_handleButtonClick",
      value: function _handleButtonClick() {
        this.open = !this.open;
      }
      /** @ignore */

    }, {
      key: "_getMenu",
      value: function _getMenu(targetValue) {
        // Use passed target
        targetValue = targetValue || this.menu;

        if (targetValue instanceof Node) {
          // Just return the provided Node
          return targetValue;
        } // Dynamically get the target node based on target


        var newTarget = null;

        if (typeof targetValue === 'string') {
          newTarget = document.querySelector(targetValue);
        }

        return newTarget;
      }
    }, {
      key: "focus",

      /** @ignore */
      value: function focus() {
        this._elements.shellMenuButton.focus();
      }
      /**
       Returns {@link ShellMenuBarItem} icon variants.
        @return {ShellMenuBarItemIconVariantEnum}
       */

    }, {
      key: "attributeChangedCallback",

      /** @ignore */
      value: function attributeChangedCallback(name, oldValue, value) {
        // a11y When user doesn't supply a button label (for an icon-only button),
        // providing aria-label will correctly pass it on to the shell menu button child element.
        if (name === 'aria-label') {
          if (value && this._elements.shellMenuButton.textContent.trim() === '') {
            this._elements.shellMenuButton.setAttribute('aria-label', value);
          }
        } else {
          _get(_getPrototypeOf(ShellMenuBarItem.prototype), "attributeChangedCallback", this).call(this, name, oldValue, value);
        }
      }
      /** @ignore */

    }, {
      key: "render",
      value: function render() {
        _get(_getPrototypeOf(ShellMenuBarItem.prototype), "render", this).call(this);

        this.setAttribute('role', 'listitem');
        this.classList.add(CLASSNAME$1f);
        var button = this.querySelector('._coral-Shell-menu-button');

        if (button) {
          this._elements.shellMenuButton = button;
          this._elements.shellMenuButtonLabel = this.querySelector('coral-button-label');
        } else {
          while (this.firstChild) {
            this._elements.shellMenuButtonLabel.appendChild(this.firstChild);
          }

          this.appendChild(this._elements.shellMenuButton);
        }

        this.label = this._elements.shellMenuButtonLabel; // Sync menu

        if (this.menu !== null) {
          this.menu = this.menu;
        }
      }
      /**
       Triggered after the {@link ShellMenuBarItem} is opened with <code>show()</code> or <code>instance.open = true</code>
        @typedef {CustomEvent} coral-shell-menubar-item:open
       */

      /**
       Triggered after the {@link ShellMenuBarItem} is closed with <code>hide()</code> or <code>instance.open = false</code>
        @typedef {CustomEvent} coral-shell-menubar-item:close
       */

    }, {
      key: "icon",
      get: function get() {
        return this._elements.shellMenuButton.icon;
      },
      set: function set(value) {
        this._elements.shellMenuButton.icon = value;
      }
      /**
       Size of the icon. It accepts both lower and upper case sizes. See {@link ButtonIconSizeEnum}.
        @type {String}
       @default ButtonIconSizeEnum.SMALL
       @htmlattribute iconsize
       @htmlattributereflected
       */

    }, {
      key: "iconSize",
      get: function get() {
        return this._elements.shellMenuButton.iconSize;
      },
      set: function set(value) {
        this._elements.shellMenuButton.iconSize = value; // Required for styling

        this._reflectAttribute('iconsize', this.iconSize);
      }
      /**
       The menubar item's iconVariant. See {@link ShellMenuBarItemIconVariantEnum}.
        @type {String}
       @default ShellMenuBarItemIconVariantEnum.DEFAULT
       @htmlattribute iconvariant
       */

    }, {
      key: "iconVariant",
      get: function get() {
        return this._iconVariant || iconVariant.DEFAULT;
      },
      set: function set(value) {
        var _this$classList;

        value = transform.string(value).toLowerCase();
        this._iconVariant = validate.enumeration(iconVariant)(value) && value || iconVariant.DEFAULT; // removes all the existing variants

        (_this$classList = this.classList).remove.apply(_this$classList, ALL_ICON_VARIANT_CLASSES); // adds the new variant


        if (this.variant !== iconVariant.DEFAULT) {
          this.classList.add("".concat(CLASSNAME$1f, "--").concat(this._iconVariant));
        }
      }
      /**
       The notification badge content.
        @type {String}
       @default ""
       @htmlattribute badge
       */

    }, {
      key: "badge",
      get: function get() {
        return this._elements.shellMenuButton.getAttribute('badge') || '';
      },
      set: function set(value) {
        // Non-truthy values shouldn't show
        // null, empty string, 0, etc
        this._elements.shellMenuButton[!value || value === '0' ? 'removeAttribute' : 'setAttribute']('badge', value);
      }
      /**
       Whether the menu is open or not.
        @type {Boolean}
       @default false
       @htmlattribute open
       @htmlattributereflected
        @emits {coral-shell-menubar-item:open}
       @emits {coral-shell-menubar-item:close}
       */

    }, {
      key: "open",
      get: function get() {
        return this._open || false;
      },
      set: function set(value) {
        var menu = this._getMenu(); // if we want to open the dialog we need to make sure there is a valid menu or hasPopup


        if (menu === null && this.hasPopup === hasPopupRole.DEFAULT) {
          return;
        }

        this._open = transform.booleanAttr(value);

        this._reflectAttribute('open', this._open); // if the menu is valid, toggle the menu and trigger the appropriate event


        if (menu !== null) {
          // Toggle the target menu
          if (menu.open !== this._open) {
            menu.open = this._open;
          }

          this.trigger("coral-shell-menubar-item:".concat(this._open ? 'open' : 'close'));
        }

        this._elements.shellMenuButton.setAttribute('aria-expanded', this._open);
      }
      /**
       The menubar item's label content zone.
        @type {ButtonLabel}
       @contentzone
       */

    }, {
      key: "label",
      get: function get() {
        return this._getContentZone(this._elements.shellMenuButtonLabel);
      },
      set: function set(value) {
        this._setContentZone('label', value, {
          handle: 'shellMenuButtonLabel',
          tagName: 'coral-button-label',
          insert: function insert(label) {
            this._elements.shellMenuButton.label = label;
          }
        });
      }
      /**
       The menu that this menu item should show. If a CSS selector is provided, the first matching element will be
       used.
        @type {?HTMLElement|String}
       @default null
       @htmlattribute menu
       */

    }, {
      key: "menu",
      get: function get() {
        return this._menu || null;
      },
      set: function set(value) {
        var menu;

        if (value instanceof HTMLElement) {
          this._menu = value;
          menu = this._menu;
        } else {
          this._menu = String(value);
          menu = document.querySelector(this._menu);
        } // Link menu with item


        if (menu !== null) {
          this.id = this.id || commons.getUID();
          menu.setAttribute('target', "#".concat(this.id));

          if (this.hasPopup === hasPopupRole.DEFAULT) {
            this.hasPopup = menu.getAttribute('role') || hasPopupRole.DIALOG;
          }
        } else if (this._menu && this.hasPopup !== hasPopupRole.DEFAULT) {
          this.hasPopup = hasPopupRole.DEFAULT;
        }
      }
      /**
       Whether the item opens a popup dialog or menu. Accepts either "menu", "listbox", "tree", "grid", or "dialog".
       @type {?String}
       @default ShellMenuBarItemHasPopupRoleEnum.DEFAULT
       @htmlattribute haspopup
       */

    }, {
      key: "hasPopup",
      get: function get() {
        return this._hasPopup || null;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        this._hasPopup = validate.enumeration(hasPopupRole)(value) && value || hasPopupRole.DEFAULT;
        var shellMenuButton = this._elements.shellMenuButton;
        var ariaHaspopup = this._hasPopup;

        if (ariaHaspopup) {
          shellMenuButton.setAttribute('aria-haspopup', ariaHaspopup);
          shellMenuButton.setAttribute('aria-expanded', this.open);
        } else {
          shellMenuButton.removeAttribute('aria-haspopup');
          shellMenuButton.removeAttribute('aria-expanded');
        }
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-button-label': 'label'
        };
      }
    }], [{
      key: "iconVariant",
      get: function get() {
        return iconVariant;
      }
    }, {
      key: "_attributePropertyMap",
      get: function get() {
        return commons.extend(_get(_getPrototypeOf(ShellMenuBarItem), "_attributePropertyMap", this), {
          haspopup: 'hasPopup',
          iconsize: 'iconSize',
          iconvariant: 'iconVariant'
        });
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(ShellMenuBarItem), "observedAttributes", this).concat(['haspopup', 'icon', 'iconsize', 'iconvariant', 'badge', 'open', 'menu', 'aria-label']);
      }
    }]);

    return ShellMenuBarItem;
  }(BaseComponent(HTMLElement));

  var template$T = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["container"] = document.createElement("div");
    el0.className += " _coral-Shell-user-container";
    el0.setAttribute("handle", "container");
    var el1 = document.createTextNode("\n  ");
    el0.appendChild(el1);
    var el2 = this["image"] = document.createElement("div");
    el2.className += " _coral-Shell-user-image";
    el2.setAttribute("handle", "image");
    var el3 = document.createTextNode("\n    ");
    el2.appendChild(el3);
    var el4 = this["avatar"] = document.createElement("coral-icon");
    el4.setAttribute("icon", data_0["icon"]);
    el4.className += " _coral-Shell-user-avatar";
    el4.setAttribute("alt", "");
    el4.setAttribute("size", "XL");
    el4.setAttribute("handle", "avatar");
    el2.appendChild(el4);
    var el5 = document.createTextNode("\n  ");
    el2.appendChild(el5);
    el0.appendChild(el2);
    var el6 = document.createTextNode("\n");
    el0.appendChild(el6);
    frag.appendChild(el0);
    var el7 = document.createTextNode("\n");
    frag.appendChild(el7);
    return frag;
  };

  var CLASSNAME$1g = '_coral-Shell-user';
  /**
   Enumeration for {@link ShellUser} avatar options. Avatar assets should use one of those provided, when no asset is set

   @typedef {Object} ShellUserAvatarEnum

   @property {String} DEFAULT
   Default avatar, show user icon from icon font.
   */

  var avatar = {
    DEFAULT: 'UserCircleColor_Light'
  };
  /**
   @class Coral.Shell.User
   @classdesc A Shell User component
   @htmltag coral-shell-user
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var ShellUser = /*#__PURE__*/function (_BaseComponent) {
    _inherits(ShellUser, _BaseComponent);

    var _super = _createSuper(ShellUser);

    /** @ignore */
    function ShellUser() {
      var _this;

      _classCallCheck(this, ShellUser);

      _this = _super.call(this); // Prepare templates

      _this._elements = {
        // Fetch or create the content zone elements
        name: _this.querySelector('coral-shell-user-name') || document.createElement('coral-shell-user-name'),
        heading: _this.querySelector('coral-shell-user-heading') || document.createElement('coral-shell-user-heading'),
        subheading: _this.querySelector('coral-shell-user-subheading') || document.createElement('coral-shell-user-subheading'),
        content: _this.querySelector('coral-shell-user-content') || document.createElement('coral-shell-user-content'),
        footer: _this.querySelector('coral-shell-user-footer') || document.createElement('coral-shell-user-footer')
      };
      template$T.call(_this._elements, {
        icon: avatar.DEFAULT
      });
      return _this;
    }
    /**
     Specifies the asset used inside the avatar view.
     See {@link Icon} for valid usage and icon names.
      @type {String}
     @default ShellUserAvatarEnum.DEFAULT
     @htmlattribute avatar
     */


    _createClass(ShellUser, [{
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(ShellUser.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1g);
        var frag = document.createDocumentFragment(); // Render template

        frag.appendChild(this._elements.container);

        for (var contentZone in this._contentZones) {
          var element = this._elements[this._contentZones[contentZone]]; // Remove it so we can process children

          if (element.parentNode) {
            element.parentNode.removeChild(element);
          }
        }

        while (this.firstChild) {
          var child = this.firstChild;

          if (child.nodeType === Node.TEXT_NODE || child.nodeType === Node.ELEMENT_NODE && child.getAttribute('handle') !== 'container') {
            // Add non-template elements to the content
            this._elements.content.appendChild(child);
          } else {
            // Remove anything else element
            this.removeChild(child);
          }
        }

        this.appendChild(frag); // Assign the content zones so the insert functions will be called

        for (var _contentZone in this._contentZones) {
          var contentZoneName = this._contentZones[_contentZone];
          var _element = this._elements[this._contentZones[_contentZone]];
          /** @ignore */

          this[contentZoneName] = _element;
        }
      }
    }, {
      key: "avatar",
      get: function get() {
        return this._elements.avatar.icon;
      },
      set: function set(value) {
        this._elements.avatar.icon = value;
      }
      /**
       The name content zone of the user-menu.
        @type {ShellUserName}
       @contentzone
       */

    }, {
      key: "name",
      get: function get() {
        return this._getContentZone(this._elements.name);
      },
      set: function set(value) {
        this._setContentZone('content', value, {
          handle: 'name',
          tagName: 'coral-shell-user-name',
          insert: function insert(content) {
            this._elements.container.appendChild(content);
          }
        });
      }
      /**
       The heading content zone of the user-menu.
        @type {ShellUserHeading}
       @contentzone
       */

    }, {
      key: "heading",
      get: function get() {
        return this._getContentZone(this._elements.heading);
      },
      set: function set(value) {
        this._setContentZone('heading', value, {
          handle: 'heading',
          tagName: 'coral-shell-user-heading',
          insert: function insert(content) {
            this._elements.container.appendChild(content);
          }
        });
      }
      /**
       The subheading content zone of the user-menu.
        @type {ShellUserSubheading}
       @contentzone
       */

    }, {
      key: "subheading",
      get: function get() {
        return this._getContentZone(this._elements.subheading);
      },
      set: function set(value) {
        this._setContentZone('subheading', value, {
          handle: 'subheading',
          tagName: 'coral-shell-user-subheading',
          insert: function insert(content) {
            this._elements.container.appendChild(content);
          }
        });
      }
      /**
       The main content zone of the user-menu.
        @type {ShellUserContent}
       @contentzone
       */

    }, {
      key: "content",
      get: function get() {
        return this._getContentZone(this._elements.content);
      },
      set: function set(value) {
        this._setContentZone('content', value, {
          handle: 'content',
          tagName: 'coral-shell-user-content',
          insert: function insert(content) {
            // Empty content to hide it
            if (content.innerHTML.trim() === '') {
              content.innerHTML = '';
            }

            this.appendChild(content);
          }
        });
      }
      /**
       The footer content zone of the user-menu.
        @type {ShellUserFooter}
       @contentzone
       */

    }, {
      key: "footer",
      get: function get() {
        return this._getContentZone(this._elements.footer);
      },
      set: function set(value) {
        this._setContentZone('footer', value, {
          handle: 'footer',
          tagName: 'coral-shell-user-footer',
          insert: function insert(content) {
            this.appendChild(content);
          }
        });
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-shell-user-name': 'name',
          'coral-shell-user-heading': 'heading',
          'coral-shell-user-subheading': 'subheading',
          'coral-shell-user-content': 'content',
          'coral-shell-user-footer': 'footer'
        };
      }
      /** @ignore */

    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(ShellUser), "observedAttributes", this).concat(['avatar']);
      }
      /**
       Returns {@link ShellUser} avatar options.
        @return {ShellUserAvatarEnum}
       */

    }, {
      key: "avatar",
      get: function get() {
        return avatar;
      }
    }]);

    return ShellUser;
  }(BaseComponent(HTMLElement));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Shell.User.Content
   @classdesc Shell's User content component
   @htmltag coral-shell-user-content
   @return {HTMLElement}
   */
  var ShellUserContent = (function () {
    return document.createElement('coral-shell-user-content');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Shell.User.Footer
   @classdesc Shell's User footer component
   @htmltag coral-shell-user-footer
   @return {HTMLElement}
   */
  var ShellUserFooter = (function () {
    return document.createElement('coral-shell-user-footer');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Shell.User.Heading
   @classdesc Shell's User heading component
   @htmltag coral-shell-user-heading
   @return {HTMLElement}
   */
  var ShellUserHeading = (function () {
    return document.createElement('coral-shell-user-heading');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Shell.User.Name
   @classdesc Shell's User name component
   @htmltag coral-shell-user-name
   @return {HTMLElement}
   */
  var ShellUserName = (function () {
    return document.createElement('coral-shell-user-name');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Shell.User.Subheading
   @classdesc Shell's User subheading component
   @htmltag coral-shell-user-subheading
   @return {HTMLElement}
   */
  var ShellUserSubheading = (function () {
    return document.createElement('coral-shell-user-subheading');
  });

  var CLASSNAME$1h = '_coral-Shell-workspaces';
  /**
   @class Coral.Shell.Workspaces
   @classdesc A Shell Workspaces component
   @htmltag coral-shell-workspaces
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var ShellWorkspaces = /*#__PURE__*/function (_BaseComponent) {
    _inherits(ShellWorkspaces, _BaseComponent);

    var _super = _createSuper(ShellWorkspaces);

    /** @ignore */
    function ShellWorkspaces() {
      var _this;

      _classCallCheck(this, ShellWorkspaces);

      _this = _super.call(this); // Events

      _this._delegateEvents({
        'key:down [is="coral-shell-workspace"]': '_focusNextItem',
        'key:right [is="coral-shell-workspace"]': '_focusNextItem',
        'key:left [is="coral-shell-workspace"]': '_focusPreviousItem',
        'key:up [is="coral-shell-workspace"]': '_focusPreviousItem',
        'key:pageup [is="coral-shell-workspace"]': '_focusPreviousItem',
        'key:pagedown [is="coral-shell-workspace"]': '_focusNextItem',
        'key:home [is="coral-shell-workspace"]': '_focusFirstItem',
        'key:end [is="coral-shell-workspace"]': '_focusLastItem',
        // private
        'coral-shell-workspace:_selectedchanged': '_onItemSelectedChanged',
        'change ._coral-Shell-workspaces-select': '_onSelectChanged'
      }); // Template


      _this._elements = {
        select: new Select().set({
          variant: 'quiet'
        })
      };

      _this._elements.select.classList.add('_coral-Shell-workspaces-select'); // Used for eventing


      _this._oldSelection = null; // Init the collection mutation observer

      _this.items._startHandlingItems(true);

      return _this;
    }
    /**
     The item collection.
      @type {SelectableCollection}
     @readonly
     */


    _createClass(ShellWorkspaces, [{
      key: "_validateSelection",

      /** @private */
      value: function _validateSelection(item) {
        // gets the current selection
        var selection = this.items._getAllSelected();

        var selectionCount = selection.length; // if no item is currently selected, we need to find a candidate

        if (selectionCount === 0) {
          // gets the first candidate for selection
          var selectable = this.items._getFirstSelectable();

          if (selectable) {
            selectable.setAttribute('selected', '');
          }
        } // more items are selected, so we find a single item and deselect everything else
        else if (selectionCount > 1) {
            // By default, the last one stays selected
            item = item || selection[selection.length - 1];

            for (var i = 0; i < selectionCount; i++) {
              if (selection[i] !== item) {
                // Don't trigger change events
                this._preventTriggeringEvents = true;
                selection[i].removeAttribute('selected');
              }
            } // We can trigger change events again


            this._preventTriggeringEvents = false;
          } // Sync select items under the hood


        this._renderSelectItems();

        this._triggerChangeEvent();
      }
    }, {
      key: "_renderSelectItems",
      value: function _renderSelectItems() {
        var _this2 = this;

        this._elements.select.items.clear();

        this.items.getAll().forEach(function (item) {
          _this2._elements.select.items.add({
            content: {
              innerHTML: item.innerHTML
            },
            selected: item.hasAttribute('selected'),
            _workspace: item
          });
        });
      }
    }, {
      key: "_onSelectChanged",
      value: function _onSelectChanged(event) {
        event.stopImmediatePropagation();
        this._elements.select.selectedItem._workspace.selected = true;
      }
      /** @private */

    }, {
      key: "_triggerChangeEvent",
      value: function _triggerChangeEvent() {
        var selectedItem = this.selectedItem;
        var oldSelection = this._oldSelection;

        if (!this._preventTriggeringEvents && selectedItem !== oldSelection) {
          this.trigger('coral-shell-workspaces:change', {
            oldSelection: oldSelection,
            selection: selectedItem
          });
          this._oldSelection = selectedItem;
        }
      }
      /** @private */

    }, {
      key: "_onItemSelectedChanged",
      value: function _onItemSelectedChanged(event) {
        event.stopImmediatePropagation();
        var item = event.target;

        this._validateSelection(item);
      }
      /**
       Returns true if the event is at the matched target.
        @private
       */

    }, {
      key: "_eventIsAtTarget",
      value: function _eventIsAtTarget(event) {
        var target = event.target;
        var listItem = event.matchedTarget;
        var isAtTarget = target === listItem;

        if (isAtTarget) {
          // Don't let arrow keys etc scroll the page
          event.preventDefault();
          event.stopPropagation();
        }

        return isAtTarget;
      }
      /** @private */

    }, {
      key: "_focusNextItem",
      value: function _focusNextItem(event) {
        if (!this._eventIsAtTarget(event)) {
          return;
        }

        var target = event.matchedTarget;

        if (target.nextElementSibling) {
          target.nextElementSibling.focus();
        } else {
          this.items.first().focus();
        }
      }
      /** @private */

    }, {
      key: "_focusPreviousItem",
      value: function _focusPreviousItem(event) {
        if (!this._eventIsAtTarget(event)) {
          return;
        }

        var target = event.matchedTarget;

        if (target.previousElementSibling) {
          target.previousElementSibling.focus();
        } else {
          this.items.last().focus();
        }
      }
      /** @private */

    }, {
      key: "_focusFirstItem",
      value: function _focusFirstItem(event) {
        if (!this._eventIsAtTarget(event)) {
          return;
        }

        this.items.first().focus();
      }
      /** @private */

    }, {
      key: "_focusLastItem",
      value: function _focusLastItem(event) {
        if (!this._eventIsAtTarget(event)) {
          return;
        }

        this.items.last().focus();
      }
      /** @ignore */

    }, {
      key: "render",
      value: function render() {
        _get(_getPrototypeOf(ShellWorkspaces.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1h); // Don't trigger events once connected

        this._preventTriggeringEvents = true;

        this._validateSelection();

        this._preventTriggeringEvents = false;
        this._oldSelection = this.selectedItem; // Support cloneNode

        var template = this.querySelector('._coral-Shell-workspaces-select');

        if (template) {
          template.remove();
        }

        this.appendChild(this._elements.select);
      }
    }, {
      key: "items",
      get: function get() {
        // Construct the collection on first request:
        if (!this._items) {
          this._items = new SelectableCollection({
            host: this,
            itemTagName: 'coral-shell-workspace',
            itemBaseTagName: 'a',
            onItemAdded: this._validateSelection,
            onItemRemoved: this._validateSelection
          });
        }

        return this._items;
      }
      /**
       Returns the selected workspace.
        @type {HTMLElement}
       @readonly
       */

    }, {
      key: "selectedItem",
      get: function get() {
        return this.items._getLastSelected();
      }
    }]);

    return ShellWorkspaces;
  }(BaseComponent(HTMLElement));

  var CLASSNAME$1i = '_coral-Shell-workspaces-workspace';
  /**
   @class Coral.Shell.Workspace
   @classdesc A Shell Workspace component
   @htmltag coral-shell-workspace
   @htmlbasetag a
   @extends {HTMLAnchorElement}
   @extends {BaseComponent}
   */

  var ShellWorkspace = /*#__PURE__*/function (_BaseComponent) {
    _inherits(ShellWorkspace, _BaseComponent);

    var _super = _createSuper(ShellWorkspace);

    /** @ignore */
    function ShellWorkspace() {
      var _this;

      _classCallCheck(this, ShellWorkspace);

      _this = _super.call(this); // Events

      _this._delegateEvents({
        click: '_onClick'
      });

      return _this;
    }
    /**
     Whether this workspace is selected.
      @type {Boolean}
     @default false
     @htmlattribute selected
     @htmlattributereflected
     */


    _createClass(ShellWorkspace, [{
      key: "_onClick",

      /** @private */
      value: function _onClick() {
        if (!this.selected) {
          this.selected = true;
        }
      }
      /** @ignore */

    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(ShellWorkspace.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1i);
      }
      /**
       Triggered when a {@link ShellWorkspace} selection changed.
        @typedef {CustomEvent} coral-shell-workspace:_selectedchanged
        @private
       */

    }, {
      key: "selected",
      get: function get() {
        return this._selected || false;
      },
      set: function set(value) {
        this._selected = transform.booleanAttr(value);

        this._reflectAttribute('selected', this._selected);

        this.setAttribute('aria-selected', this._selected);
        this.classList.toggle('is-selected', this._selected);
        this.trigger('coral-shell-workspace:_selectedchanged');
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(ShellWorkspace), "observedAttributes", this).concat(['selected']);
      }
    }]);

    return ShellWorkspace;
  }(BaseComponent(HTMLAnchorElement));

  var template$U = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["container"] = document.createElement("div");
    el0.setAttribute("handle", "container");
    el0.className += " _coral-Shell-solutions-container";
    frag.appendChild(el0);
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    return frag;
  };

  var CLASSNAME$1j = '_coral-Shell-solutionSwitcher';
  /**
   @class Coral.Shell.SolutionSwitcher
   @classdesc A Shell Solution Switcher component
   @htmltag coral-shell-solutionswitcher
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var ShellSolutionSwitcher = /*#__PURE__*/function (_BaseComponent) {
    _inherits(ShellSolutionSwitcher, _BaseComponent);

    var _super = _createSuper(ShellSolutionSwitcher);

    /** @ignore */
    function ShellSolutionSwitcher() {
      var _this;

      _classCallCheck(this, ShellSolutionSwitcher);

      _this = _super.call(this); // Template

      _this._elements = {};
      template$U.call(_this._elements); // Listen for mutations

      var observer = new MutationObserver(function (mutations) {
        mutations.forEach(function (mutation) {
          for (var i = 0; i < mutation.addedNodes.length; i++) {
            var addedNode = mutation.addedNodes[i]; // Move non secondary solutions to the container

            if (addedNode.nodeName === 'CORAL-SHELL-SOLUTIONS' && !addedNode.hasAttribute('secondary')) {
              _this._elements.container.appendChild(addedNode);
            }
          }
        });
      });
      observer.observe(_assertThisInitialized(_this), {
        // Only care about direct children
        childList: true
      });
      return _this;
    }
    /**
     The item collection.
      @type {Collection}
     @readonly
     */


    _createClass(ShellSolutionSwitcher, [{
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(ShellSolutionSwitcher.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1j); // force darkest theme

        this.classList.add('coral--darkest');

        var container = this.querySelector('._coral-Shell-solutions-container') || this._elements.container; // Remove it so we can process solutions


        if (container.parentNode) {
          container.remove();
        } // Move non secondary solutions to the container


        Array.prototype.forEach.call(this.querySelectorAll('coral-shell-solutions:not([secondary])'), function (item) {
          container.appendChild(item);
        }); // Put the container as first child

        this.insertBefore(container, this.firstChild);
      }
    }, {
      key: "items",
      get: function get() {
        // Construct the collection on first request
        if (!this._items) {
          this._items = new Collection$1({
            host: this,
            itemTagName: 'coral-shell-solutions'
          });
        }

        return this._items;
      }
    }]);

    return ShellSolutionSwitcher;
  }(BaseComponent(HTMLElement));

  var CLASSNAME$1k = '_coral-Shell-solutions';
  /**
   @class Coral.Shell.Solutions
   @classdesc A Shell Solutions component
   @htmltag coral-shell-solutions
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var ShellSolutions = /*#__PURE__*/function (_BaseComponent) {
    _inherits(ShellSolutions, _BaseComponent);

    var _super = _createSuper(ShellSolutions);

    function ShellSolutions() {
      _classCallCheck(this, ShellSolutions);

      return _super.apply(this, arguments);
    }

    _createClass(ShellSolutions, [{
      key: "_sortSolutions",
      value: function _sortSolutions() {
        var _this = this;

        if (this.items.length > 1) {
          var linked = [];
          var nonLinked = [];
          var isSecondary = this.hasAttribute('secondary');
          this.items.getAll().forEach(function (item, i) {
            // Exclude the first secondary item
            if (!(isSecondary && i === 0)) {
              if (item.hasAttribute('linked')) {
                linked.push(item);
              } else {
                nonLinked.push(item);
              }
            }
          });

          var alphabeticalSort = function alphabeticalSort(a, b) {
            var aText = a.textContent.trim().toLowerCase();
            var bText = b.textContent.trim().toLowerCase();

            if (aText < bText) {
              return -1;
            }

            if (aText > bText) {
              return 1;
            }

            return 0;
          };

          linked.sort(alphabeticalSort);
          nonLinked.sort(alphabeticalSort);
          linked.forEach(function (item) {
            _this.appendChild(item);
          });
          nonLinked.forEach(function (item) {
            _this.appendChild(item);
          });
        }
      }
      /** @ignore */

    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(ShellSolutions.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1k); // Sort linked solutions then non linked solutions alphabetically

        this._sortSolutions();
      }
    }, {
      key: "items",

      /**
       The item collection.
        @type {Collection}
       @readonly
       */
      get: function get() {
        // Construct the collection on first request:
        if (!this._items) {
          this._items = new Collection$1({
            host: this,
            itemTagName: 'coral-shell-solution',
            itemBaseTagName: 'a'
          });
        }

        return this._items;
      }
      /**
       Whether the solution list is secondary.
        @type {Boolean}
       @default false
       @htmlattribute secondary
       @htmlattributereflected
       */

    }, {
      key: "secondary",
      get: function get() {
        return this._secondary || false;
      },
      set: function set(value) {
        this._secondary = transform.booleanAttr(value);

        this._reflectAttribute('secondary', this._secondary);

        this.classList.toggle("".concat(CLASSNAME$1k, "--secondary"), this._secondary);
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(ShellSolutions), "observedAttributes", this).concat(['secondary']);
      }
    }]);

    return ShellSolutions;
  }(BaseComponent(HTMLElement));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  /**
   @class Coral.Shell.Solutions.Header
   @classdesc Shell's solution sub-cloud name
   @htmltag coral-shell-solutions-header
   @return {HTMLElement}

   @deprecated
   */

  var ShellSolutionsHeader = (function () {
    commons._log('warn', 'Coral.Shell.Solutions.Header: coral-shell-solutions-header is deprecated.');

    return document.createElement('coral-shell-solutions-header');
  });

  var template$V = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["icon"] = document.createElement("coral-icon");
    el0.setAttribute("size", "XL");
    el0.setAttribute("handle", "icon");
    el0.className += " _coral-Shell-solution-icon";
    el0.setAttribute("alt", "");
    frag.appendChild(el0);
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    return frag;
  };

  var CLASSNAME$1l = '_coral-Shell-solution';
  /**
   @class Coral.Shell.Solution
   @classdesc A Shell Solution component
   @htmltag coral-shell-solution
   @extends {HTMLAnchorElement}
   @extends {BaseComponent}
   */

  var ShellSolution = /*#__PURE__*/function (_BaseComponent) {
    _inherits(ShellSolution, _BaseComponent);

    var _super = _createSuper(ShellSolution);

    /** @ignore */
    function ShellSolution() {
      var _this;

      _classCallCheck(this, ShellSolution);

      _this = _super.call(this); // Prepare templates

      _this._elements = {
        // Fetch or create the content zone elements
        label: _this.querySelector('coral-shell-solution-label') || document.createElement('coral-shell-solution-label')
      };
      template$V.call(_this._elements);
      return _this;
    }
    /**
     Specifies the icon name used inside the button. See {@link Icon} for valid icon names.
      @type {String}
     @default ""
     @htmlattribute icon
     */


    _createClass(ShellSolution, [{
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(ShellSolution.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1l);
        var fragment = document.createDocumentFragment(); // Render template

        fragment.appendChild(this._elements.icon);
        var label = this._elements.label; // Remove it so we can process children

        if (label) {
          label.remove();
        } // Move any remaining elements into the content sub-component


        while (this.firstChild) {
          var child = this.firstChild;

          if (child.nodeType === Node.TEXT_NODE || child.nodeType === Node.ELEMENT_NODE && child.getAttribute('handle') !== 'icon') {
            label.appendChild(child);
          } else {
            this.removeChild(child);
          }
        } // Add template to component


        this.appendChild(fragment); // Call the content zone insert

        this.label = label;
      }
    }, {
      key: "icon",
      get: function get() {
        return this._elements.icon.icon;
      },
      set: function set(value) {
        this._elements.icon.icon = value;
      }
      /**
       The solution's label content zone.
        @type {ShellSolutionLabel}
       @contentzone
       */

    }, {
      key: "label",
      get: function get() {
        return this._getContentZone(this._elements.label);
      },
      set: function set(value) {
        this._setContentZone('label', value, {
          handle: 'label',
          tagName: 'coral-shell-solution-label',
          insert: function insert(content) {
            this.appendChild(content);
          }
        });
      }
      /**
       Whether a solution is linked or not
        @type {Boolean}
       @default false
       @htmlattribute linked
       @htmlattributereflected
       */

    }, {
      key: "linked",
      get: function get() {
        return this._linked || false;
      },
      set: function set(value) {
        this._linked = transform.booleanAttr(value);

        this._reflectAttribute('linked', this._linked);

        this.classList.toggle("".concat(CLASSNAME$1l, "--linked"), this._linked);
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-shell-solution-label': 'label'
        };
      }
      /** @ignore */

    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(ShellSolution), "observedAttributes", this).concat(['icon', 'linked']);
      }
    }]);

    return ShellSolution;
  }(BaseComponent(HTMLAnchorElement));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Shell.Solution.Label
   @classdesc Shell's Solution label component
   @htmltag coral-shell-solution-label
   @return {HTMLElement}
   */
  var ShellSolutionLabel = (function () {
    return document.createElement('coral-shell-solution-label');
  });

  var template$W = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["container"] = document.createElement("coral-selectlist");
    el0.setAttribute("handle", "container");
    el0.className += " _coral-Shell-selectList-container";
    frag.appendChild(el0);
    var el1 = document.createTextNode("\n\n");
    frag.appendChild(el1);
    return frag;
  };

  var CLASSNAME$1m = '_coral-Shell-selectListSwitcher';
  /**
   @class Coral.Shell.SelectListSwitcher
   @classdesc A Shell SelectList Switcher component
   @htmltag coral-shell-selectlistswitcher
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var ShellSelectListSwitcher = /*#__PURE__*/function (_BaseComponent) {
    _inherits(ShellSelectListSwitcher, _BaseComponent);

    var _super = _createSuper(ShellSelectListSwitcher);

    /** @ignore */
    function ShellSelectListSwitcher() {
      var _this;

      _classCallCheck(this, ShellSelectListSwitcher);

      _this = _super.call(this); // Template

      _this._elements = {};
      template$W.call(_this._elements);

      _this._delegateEvents({
        'coral-selectlist:change': '_onSelectListChange',
        'coral-shell-selectlistswitcher-item:change': '_onUpdateHref'
      });

      return _this;
    }
    /**
     The item collection.
     @type {Collection}
     @readonly
     */


    _createClass(ShellSelectListSwitcher, [{
      key: "_onItemAdded",
      value: function _onItemAdded(item) {
        item.id = item.id || commons.getUID();
        var selectListItem = document.createElement('coral-selectlist-item');

        if (item.href) {
          selectListItem.setAttribute("href", item.href);
        }

        selectListItem.textContent = item.textContent;
        selectListItem.id = item.id + "-selectlist-item";

        this._elements.container.items.add(selectListItem);
      }
    }, {
      key: "_onItemRemoved",
      value: function _onItemRemoved(item) {
        var selectListItemId = item.id + "-selectlist-item";

        var selectListItem = this._elements.container.querySelector('#' + selectListItemId);

        this._elements.container.items.remove(selectListItem);
      }
    }, {
      key: "_onSelectListChange",
      value: function _onSelectListChange(event) {
        var selectList = event.target;
        var selectListItem = selectList.selectedItem;

        if (selectListItem.hasAttribute("href")) {
          var href = selectListItem.getAttribute("href");
          window.open(href, '_self');
        }
      }
    }, {
      key: "_onUpdateHref",
      value: function _onUpdateHref(event) {
        var switcherListItem = event.target;
        var selectListItemId = switcherListItem.id + "-selectlist-item";

        var selectListItem = this._elements.container.querySelector('#' + selectListItemId);

        if (switcherListItem.href) {
          selectListItem.setAttribute("href", switcherListItem.getAttribute("href"));
        }
      }
      /** @ignore */

    }, {
      key: "render",
      value: function render() {
        _get(_getPrototypeOf(ShellSelectListSwitcher.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1m);

        var container = this.querySelector('._coral-Shell-selectList-container') || this._elements.container; // Put the container as first child


        this.insertBefore(container, this.firstChild);

        this.items._startHandlingItems();
      }
    }, {
      key: "items",
      get: function get() {
        // Construct the collection on first request
        if (!this._items) {
          this._items = new SelectableCollection({
            host: this,
            itemTagName: 'coral-shell-selectlistswitcher-item',
            onItemAdded: this._onItemAdded,
            onItemRemoved: this._onItemRemoved
          });
        }

        return this._items;
      }
    }]);

    return ShellSelectListSwitcher;
  }(BaseComponent(HTMLElement));

  var CLASSNAME$1n = '_coral-Shell-selectlistswitcher-item';
  /**
   @class Coral.Shell.SelectListSwitcherItem
   @classdesc A Shell SelectListSwitcherItem component
   @htmltag coral-shell-selectlistswitcher-item
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var ShellSelectListSwitcherItem = /*#__PURE__*/function (_BaseComponent) {
    _inherits(ShellSelectListSwitcherItem, _BaseComponent);

    var _super = _createSuper(ShellSelectListSwitcherItem);

    function ShellSelectListSwitcherItem() {
      _classCallCheck(this, ShellSelectListSwitcherItem);

      return _super.apply(this, arguments);
    }

    _createClass(ShellSelectListSwitcherItem, [{
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(ShellSelectListSwitcherItem.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1n);
      }
    }, {
      key: "href",

      /**
         href property of item
         @type {String}
         @htmlattribute href
         @htmlattributereflected
         */
      get: function get() {
        return this._href;
      },
      set: function set(value) {
        var href = transform.string(value);
        var update = false;

        if (this._href) {
          update = true;
        }

        this._href = href;

        this._reflectAttribute('href', this._href);

        if (update) {
          this.trigger('coral-shell-selectlistswitcher-item:change');
        }
      }
      /** @ignore */

    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(ShellSelectListSwitcherItem), "observedAttributes", this).concat(['href']);
      }
    }]);

    return ShellSelectListSwitcherItem;
  }(BaseComponent(HTMLElement));

  var template$X = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var data = data_0 = typeof data_0 === "undefined" ? {} : data_0;
    data = data_0;
    var labelId = data.commons.getUID();
    data_0 = data;
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    var el2 = this["container"] = document.createElement("div");
    el2.setAttribute("handle", "container");
    var el3 = document.createTextNode("\n  ");
    el2.appendChild(el3);
    var el4 = document.createElement("label");
    el4.className += " u-coral-screenReaderOnly";
    el4.id = labelId;
    el4.textContent = data_0["i18n"]["get"]('Search Organizations');
    el2.appendChild(el4);
    var el5 = document.createTextNode("\n  ");
    el2.appendChild(el5);
    var el6 = this["search"] = document.createElement("coral-search");
    el6.className += " _coral-Shell-orgSwitcher-search";
    el6.setAttribute("handle", "search");
    el6.setAttribute("placeholder", data_0["i18n"]["get"]('Search Organizations'));
    el6.setAttribute("labelledby", labelId);
    el2.appendChild(el6);
    var el7 = document.createTextNode("\n  ");
    el2.appendChild(el7);
    var el8 = this["items"] = document.createElement("div");
    el8.className += " _coral-Shell-orgSwitcher-items";
    el8.setAttribute("handle", "items");
    el2.appendChild(el8);
    var el9 = document.createTextNode("\n  ");
    el2.appendChild(el9);
    var el10 = this["resultMessage"] = document.createElement("div");
    el10.className += " _coral-Shell-orgSwitcher-resultMessage";
    el10.setAttribute("handle", "resultMessage");
    el10.setAttribute("hidden", "");
    var el11 = document.createTextNode("\n    ");
    el10.appendChild(el11);
    var el12 = document.createElement("div");
    el12.className += " _coral-Shell-orgSwitcher-resultMessage-container";
    var el13 = document.createTextNode("\n      ");
    el12.appendChild(el13);
    var el14 = document.createElement("h2");
    el14.className += " coral-Heading coral-Heading--2";
    el14.textContent = data_0["i18n"]["get"]('No organizations found.');
    el12.appendChild(el14);
    var el15 = document.createTextNode("\n    ");
    el12.appendChild(el15);
    el10.appendChild(el12);
    var el16 = document.createTextNode("\n  ");
    el10.appendChild(el16);
    el2.appendChild(el10);
    var el17 = document.createTextNode("\n");
    el2.appendChild(el17);
    frag.appendChild(el2);
    var el18 = document.createTextNode("\n");
    frag.appendChild(el18);
    return frag;
  };

  var CLASSNAME$1o = '_coral-Shell-orgSwitcher';
  /**
   Minimum number of entries required to show search control.

   @type {Number}
   @ignore
   */

  var SEARCH_VISIBILITY_THRESHOLD = 6;
  /**
   @class Coral.Shell.OrgSwitcher
   @classdesc A Shell OrgSwitcher component
   @htmltag coral-shell-orgswitcher
   @extends {List}
   */

  var ShellOrgSwitcher = /*#__PURE__*/function (_List) {
    _inherits(ShellOrgSwitcher, _List);

    var _super = _createSuper(ShellOrgSwitcher);

    /** @ignore */
    function ShellOrgSwitcher() {
      var _this;

      _classCallCheck(this, ShellOrgSwitcher);

      _this = _super.call(this); // Events

      _this._delegateEvents({
        'coral-search:clear': '_showAll',
        'coral-search:input': '_performSearch',
        'coral-search:submit': '_selectFirst',
        'coral-shell-organization:change': '_onOrganizationChange',
        // private
        'coral-shell-organization:_selectedchanged': '_onItemSelectedChanged',
        'coral-shell-suborganization:_selectedchanged': '_onSubItemSelectedChanged'
      }); // Templates


      _this._elements = {
        footer: _this.querySelector('coral-shell-orgswitcher-footer') || document.createElement('coral-shell-orgswitcher-footer')
      };
      template$X.call(_this._elements, {
        commons: commons,
        i18n: i18n
      }); // Used for eventing

      _this._oldSelection = null; // Item handling

      _this.items._startHandlingItems(true);

      return _this;
    }
    /**
     The item collection.
      @type {SelectableCollection}
     @readonly
     */


    _createClass(ShellOrgSwitcher, [{
      key: "_onItemSelectedChanged",

      /** @private */
      value: function _onItemSelectedChanged(event) {
        event.stopImmediatePropagation();
        var item = event.target;

        this._validateSelection(item);
      }
      /** @private */

    }, {
      key: "_onSubItemSelectedChanged",
      value: function _onSubItemSelectedChanged(event) {
        var _this2 = this;

        event.stopImmediatePropagation();
        var item = event.target; // If a sub organization is selected, deselect all selected organization items

        if (item.hasAttribute('selected')) {
          this.items._getAllSelected().forEach(function (itemElement) {
            if (itemElement.tagName === 'CORAL-SHELL-ORGANIZATION') {
              _this2._preventTriggeringEvents = true;
              itemElement.removeAttribute('selected');
            }
          });

          this._preventTriggeringEvents = false;
        }
      }
      /** @private */

    }, {
      key: "_onOrganizationChange",
      value: function _onOrganizationChange() {
        this._triggerChangeEvent();
      }
      /**
       Returns the selected workspace.
        @type {HTMLElement}
       @readonly
       */

    }, {
      key: "_selectFirst",

      /** @private */
      value: function _selectFirst(event) {
        event.stopPropagation();
        var first = this.items.first();

        if (first) {
          first.setAttribute('selected', '');
        }
      }
      /** @private */

    }, {
      key: "_validateSelection",
      value: function _validateSelection(item) {
        // gets the current selection
        var selection = this.items._getAllSelected();

        var selectionCount = selection.length;

        if (selectionCount > 1) {
          for (var i = 0; i < selectionCount; i++) {
            if (selection[i] !== item) {
              // Don't trigger change events
              this._preventTriggeringEvents = true;
              selection[i].removeAttribute('selected');
            }
          } // We can trigger change events again


          this._preventTriggeringEvents = false;
        }

        this._triggerChangeEvent();
      }
      /** @private */

    }, {
      key: "_triggerChangeEvent",
      value: function _triggerChangeEvent() {
        var selectedItem = this.selectedItem;
        var oldSelection = this._oldSelection;

        if (!this._preventTriggeringEvents && selectedItem !== oldSelection) {
          this.trigger('coral-shell-orgswitcher:change', {
            oldSelection: oldSelection,
            selection: selectedItem
          });
          this._oldSelection = selectedItem;
        }
      }
      /** @private */

    }, {
      key: "_showAll",
      value: function _showAll(event) {
        event.stopPropagation();
        this._elements.resultMessage.hidden = true; // Show all items

        this.items.getAll().forEach(function (item) {
          item.hidden = false;

          if (item.items) {
            // Show all sub-items
            item.items.getAll().forEach(function (itemElement) {
              itemElement.hidden = false;
            });
          }
        });
      }
      /** @private */

    }, {
      key: "_performSearch",
      value: function _performSearch(event) {
        event.stopPropagation();

        var searchTerm = this._elements.search.value.toLowerCase();

        this._elements.resultMessage.hidden = true; // Hide items that don't match

        var resultCount = 0;
        this.items.getAll().forEach(function (item) {
          var matched = item.content.textContent.toLowerCase().indexOf(searchTerm) !== -1;
          var childMatched = false;

          if (item.items) {
            item.items.getAll().forEach(function (itemElement) {
              var elementMatch = itemElement.content.textContent.toLowerCase().indexOf(searchTerm) !== -1;
              childMatched = childMatched || elementMatch;
              itemElement.hidden = !elementMatch;
            });
          }

          matched = matched || childMatched;
          item.hidden = !matched;

          if (matched) {
            resultCount++;
          }
        });

        if (resultCount === 0) {
          this._elements.resultMessage.hidden = false;
        }
      }
      /** @private */

    }, {
      key: "_moveItems",
      value: function _moveItems() {
        var _this3 = this;

        this.setAttribute('id', this.id || commons.getUID());
        Array.prototype.forEach.call(this.querySelectorAll("#".concat(this.id, " > coral-shell-organization")), function (item) {
          _this3._elements.items.appendChild(item);
        });
      }
      /** @private */

    }, {
      key: "_onCollectionChange",
      value: function _onCollectionChange(item) {
        // Move all items into the right place
        this._moveItems(); // Select the last selected item


        this._validateSelection(item); // if mincountforsearch is set and number of organizations are less than or equal to it, hide the search


        if (this.items.length <= SEARCH_VISIBILITY_THRESHOLD) {
          this._elements.search.hide();
        } else {
          this._elements.search.show();
        }
      }
    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(ShellOrgSwitcher.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1o); // Move the items into the right place

        this._moveItems();

        var container = this.querySelector('[handle="container"]'); // Support cloneNode

        if (container) {
          this._elements.container = container;
          this._elements.items = this.querySelector('._coral-Shell-orgSwitcher-items');
          this._elements.search = this.querySelector('._coral-Shell-orgSwitcher-search');
          this._elements.resultMessage = this.querySelector('._coral-Shell-orgSwitcher-resultMessage');
          this._items._container = this._elements.items;
        } else {
          this.appendChild(this._elements.container);
        } // Call content zone insert


        this.footer = this._elements.footer; // Don't trigger events once connected

        this._preventTriggeringEvents = true;

        this._validateSelection();

        this._preventTriggeringEvents = false;
        this._oldSelection = this.selectedItem;
      }
      /**
       Triggered when the {@link ShellOrgSwitcher} selected organization has changed.
        @typedef {CustomEvent} coral-shell-orgswitcher:change
        @property {HTMLElement} detail.oldSelection
       The prior selected organization item.
       @property {HTMLElement} detail.selection
       The newly selected organization item.
       */

    }, {
      key: "items",
      get: function get() {
        // Construct the collection on first request:
        if (!this._items) {
          this._items = new SelectableCollection({
            host: this,
            itemTagName: 'coral-shell-organization',
            itemSelector: 'coral-shell-organization, coral-shell-suborganization',
            container: this._elements.items,
            onItemAdded: this._onCollectionChange,
            onItemRemoved: this._onCollectionChange
          });
        }

        return this._items;
      }
      /**
       The search field placeholder.
        @default ''
       @type {String}
       @htmlattribute placeholder
       */

    }, {
      key: "placeholder",
      get: function get() {
        return this._elements.search.placeholder;
      },
      set: function set(value) {
        this._elements.search.placeholder = value;
      }
      /**
       Content zone where the buttons are located.
        @type {ShellOrgSwitcherFooter}
       @contentzone
       */

    }, {
      key: "footer",
      get: function get() {
        return this._getContentZone(this._elements.footer);
      },
      set: function set(value) {
        this._setContentZone('content', value, {
          handle: 'footer',
          tagName: 'coral-shell-orgswitcher-footer',
          insert: function insert(content) {
            this.appendChild(content);
          }
        });
      }
      /** @private */

    }, {
      key: "_itemTagName",
      get: function get() {
        // Used for Collection
        return 'coral-shell-organization';
      }
    }, {
      key: "selectedItem",
      get: function get() {
        return this.items._getLastSelected();
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-shell-orgswitcher-footer': 'footer'
        };
      }
      /** @ignore */

    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(ShellOrgSwitcher), "observedAttributes", this).concat(['placeholder']);
      }
    }]);

    return ShellOrgSwitcher;
  }(List);

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Shell.OrgSwitcher.Footer
   @classdesc Shell's OrgSwitcher footer component
   @htmltag coral-shell-orgswitcher-footer
   @return {HTMLElement}
   */
  var ShellOrgSwitcherFooter = (function () {
    return document.createElement('coral-shell-orgswitcher-footer');
  });

  var template$Y = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var data = data_0 = typeof data_0 === "undefined" ? {} : data_0;
    var el0 = this["checkmark"] = document.createElement("span");
    el0.setAttribute("handle", "checkmark");
    el0.setAttribute("hidden", "");
    el0.className += " _coral-Shell-orgSwitcher-checkmark";
    var el1 = document.createTextNode("\n  ");
    el0.appendChild(el1);
    data = data_0;
    this.checkmark.innerHTML = data.Icon._renderSVG('spectrum-css-icon-CheckmarkMedium', ['_coral-UIIcon-CheckmarkMedium', '_coral-Menu-checkmark']);
    data_0 = data;
    var el3 = document.createTextNode("\n");
    el0.appendChild(el3);
    frag.appendChild(el0);
    var el4 = document.createTextNode("\n");
    frag.appendChild(el4);
    var el5 = this["items"] = document.createElement("div");
    el5.setAttribute("handle", "items");
    el5.className += " _coral-Shell-orgSwitcher-subitems";
    frag.appendChild(el5);
    var el6 = document.createTextNode("\n\n");
    frag.appendChild(el6);
    return frag;
  };

  var CLASSNAME$1p = '_coral-Shell-orgSwitcher-item';
  /**
   @class Coral.Shell.Organization
   @classdesc A Shell Organization component
   @htmltag coral-shell-organization
   @extends {ListItem}
   */

  var ShellOrganization = /*#__PURE__*/function (_List$Item) {
    _inherits(ShellOrganization, _List$Item);

    var _super = _createSuper(ShellOrganization);

    /** @ignore */
    function ShellOrganization() {
      var _this;

      _classCallCheck(this, ShellOrganization);

      _this = _super.call(this); // Events

      _this._delegateEvents({
        'click': '_onClick',
        'key:enter': '_onClick',
        'key:space': '_onClick',
        // Private
        'coral-shell-suborganization:_selectedchanged': '_onItemSelectedChanged'
      });

      var template = {};
      template$Y.call(template, {
        Icon: Icon
      });
      commons.extend(_this._elements, template); // Used for eventing

      _this._oldSelection = null; // Item handling

      _this.items._startHandlingItems(true);

      return _this;
    }
    /**
     The item collection.
      @type {SelectableCollection}
     @readonly
     */


    _createClass(ShellOrganization, [{
      key: "_onItemSelectedChanged",

      /** @private */
      value: function _onItemSelectedChanged(event) {
        // Validate the selection only if we're an organization
        if (this.tagName === 'CORAL-SHELL-ORGANIZATION') {
          // Don't stop propagation here as the orgSwitcher listens to the event too
          var item = event.target;

          this._validateSelection(item);
        }
      }
      /** @private */

    }, {
      key: "_onItemAdded",
      value: function _onItemAdded(item) {
        // Move all items into the right place
        this._moveItems();

        this._validateSelection(item);
      }
      /** @private */

    }, {
      key: "_onItemRemoved",
      value: function _onItemRemoved(item) {
        this._setParent();

        this._validateSelection(item);
      }
      /** @private */

    }, {
      key: "_validateSelection",
      value: function _validateSelection(item) {
        // gets the current selection
        var selection = this.items._getAllSelected();

        var selectionCount = selection.length;

        if (selectionCount > 1) {
          for (var i = 0; i < selectionCount; i++) {
            if (selection[i] !== item) {
              // Don't trigger change events
              this._preventTriggeringEvents = true;
              selection[i].removeAttribute('selected');
            }
          } // We can trigger change events again


          this._preventTriggeringEvents = false;
        }

        this._triggerChangeEvent();
      }
      /** @private */

    }, {
      key: "_triggerChangeEvent",
      value: function _triggerChangeEvent() {
        var selectedItem = this.selectedItem;
        var oldSelection = this._oldSelection;

        if (!this._preventTriggeringEvents && selectedItem !== oldSelection) {
          this.trigger("".concat(this.tagName.toLowerCase(), ":change"), {
            oldSelection: oldSelection,
            selection: selectedItem
          });
          this._oldSelection = selectedItem;
        }
      }
      /** @private */

    }, {
      key: "_moveItems",
      value: function _moveItems() {
        var _this2 = this;

        Array.prototype.forEach.call(this.querySelectorAll('coral-shell-suborganization'), function (item) {
          if (!_this2._elements.items.contains(item)) {
            _this2._elements.items.appendChild(item);
          }
        });
      }
      /** @private */

    }, {
      key: "_setParent",
      value: function _setParent() {
        var hasChildren = this.items.length !== 0;

        if (hasChildren) {
          this.removeAttribute('role');
          this.removeAttribute('tabindex');
        } else {
          // Be accessible
          this.setAttribute('role', 'button');
          this.setAttribute('tabindex', 0);
        }

        this.classList.toggle('is-parent', hasChildren);
      }
      /** @private */

    }, {
      key: "_onClick",
      value: function _onClick() {
        if (this.items.length !== 0) {
          // You can't be selected if you have sub-organizations
          return;
        }

        this.selected = true;
      }
      /** @ignore */

    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(ShellOrganization.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1p); // Move items into the right place

        this._moveItems();

        this.setAttribute('id', this.id || commons.getUID()); // Support cloneNode

        var items = this.querySelector("#".concat(this.id, " > ._coral-Shell-orgSwitcher-subitems"));

        if (items) {
          items.remove();
        }

        var checkmark = this.querySelector("#".concat(this.id, " > ._coral-Shell-orgSwitcher-checkmark"));

        if (checkmark) {
          checkmark.remove();
        } // Render template


        var frag = document.createDocumentFragment();
        frag.appendChild(this._elements.checkmark);
        frag.appendChild(this._elements.items);
        this.appendChild(frag); // Don't trigger events once connected

        this._preventTriggeringEvents = true;

        this._validateSelection();

        this._preventTriggeringEvents = false;
        this._oldSelection = this.selectedItem;

        this._setParent();
      }
      /**
       Triggered when a {@link ShellOrganization} selection changed.
        @typedef {CustomEvent} coral-shell-organization:_selectedchanged
        @private
       */

    }, {
      key: "items",
      get: function get() {
        // Construct the collection on first request:
        if (!this._items) {
          this._items = new SelectableCollection({
            host: this,
            itemTagName: 'coral-shell-suborganization',
            container: this._elements.items,
            onItemAdded: this._onItemAdded,
            onItemRemoved: this._onItemRemoved
          });
        }

        return this._items;
      }
      /**
       Returns the selected workspace.
        @type {HTMLElement}
       @readonly
       */

    }, {
      key: "selectedItem",
      get: function get() {
        return this.items._getLastSelected();
      }
      /**
       Whether this organization is selected.
        @type {Boolean}
       @default false
       @htmlattribute selected
       @htmlattributereflected
       */

    }, {
      key: "selected",
      get: function get() {
        return this._selected || false;
      },
      set: function set(value) {
        this._selected = transform.booleanAttr(value);

        this._reflectAttribute('selected', this._selected);

        this.setAttribute('aria-selected', this._selected);
        this.classList.toggle('is-selected', this._selected);
        this._elements.checkmark.hidden = !this._selected;

        if (this.items) {
          var selectedItem = this.selectedItem;
          this.classList.toggle('is-child-selected', selectedItem);

          if (!this._selected && selectedItem) {
            // Always de-select children when de-selected
            selectedItem.removeAttribute('selected');
          }
        }

        this.trigger("".concat(this.tagName.toLowerCase(), ":_selectedchanged"));
      }
      /**
       The name of this organization.
        @type {String}
       @default ""
       @htmlattribute name
       @htmlattributereflected
       */

    }, {
      key: "name",
      get: function get() {
        return this._name || '';
      },
      set: function set(value) {
        this._name = transform.string(value);

        this._reflectAttribute('name', this._name);
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(ShellOrganization), "observedAttributes", this).concat(['name', 'selected']);
      }
    }]);

    return ShellOrganization;
  }(List.Item);

  var CLASSNAME$1q = '_coral-Shell-orgSwitcher-subitem';
  /**
   @class Coral.Shell.Suborganization
   @classdesc A Shell Sub organization component
   @htmltag coral-shell-suborganization
   @extends {ShellOrganization}
   */

  var ShellSuborganization = /*#__PURE__*/function (_ShellOrganization) {
    _inherits(ShellSuborganization, _ShellOrganization);

    var _super = _createSuper(ShellSuborganization);

    function ShellSuborganization() {
      _classCallCheck(this, ShellSuborganization);

      return _super.apply(this, arguments);
    }

    _createClass(ShellSuborganization, [{
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(ShellSuborganization.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1q); // Set the icon size

        this._elements.icon.size = Icon.size.SMALL; // Be accessible

        this.setAttribute('role', 'button');
        this.setAttribute('tabindex', 0);
      }
    }]);

    return ShellSuborganization;
  }(ShellOrganization);

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons.extend(strings, {
    'coral-component-shell-help': helpTranslations,
    'coral-component-shell-orgswitcher': orgSwitcherTranslations
  }); // Expose component on the Coral namespace

  commons._define('coral-shell-header', ShellHeader);

  commons._define('coral-shell-homeanchor', ShellHomeAnchor, {
    extends: 'a'
  });

  commons._define('coral-shell-help-item', ShellHelpItem, {
    extends: 'a'
  });

  commons._define('coral-shell-help', ShellHelp);

  commons._define('coral-shell-menubar-item', ShellMenuBarItem);

  commons._define('coral-shell-menubar', ShellMenuBar);

  commons._define('coral-shell-menu', ShellMenu);

  commons._define('coral-shell-user', ShellUser);

  commons._define('coral-shell-workspace', ShellWorkspace, {
    extends: 'a'
  });

  commons._define('coral-shell-workspaces', ShellWorkspaces);

  commons._define('coral-shell-solution', ShellSolution, {
    extends: 'a'
  });

  commons._define('coral-shell-solutions', ShellSolutions);

  commons._define('coral-shell-solutionswitcher', ShellSolutionSwitcher);

  commons._define('coral-shell-suborganization', ShellSuborganization);

  commons._define('coral-shell-organization', ShellOrganization);

  commons._define('coral-shell-orgswitcher', ShellOrgSwitcher);

  commons._define('coral-shell', Shell);

  commons._define('coral-shell-selectlistswitcher', ShellSelectListSwitcher);

  commons._define('coral-shell-selectlistswitcher-item', ShellSelectListSwitcherItem);

  Shell.Content = ShellContent;
  Shell.Header = ShellHeader;
  Shell.HomeAnchor = ShellHomeAnchor;
  Shell.HomeAnchor.Label = ShellHomeAnchorLabel;
  Shell.Help = ShellHelp;
  Shell.Help.Item = ShellHelpItem;
  Shell.Help.Separator = ShellHelpSeparator;
  Shell.Menu = ShellMenu;
  Shell.MenuBar = ShellMenuBar;
  Shell.MenuBar.Item = ShellMenuBarItem;
  Shell.User = ShellUser;
  Shell.User.Content = ShellUserContent;
  Shell.User.Footer = ShellUserFooter;
  Shell.User.Heading = ShellUserHeading;
  Shell.User.Name = ShellUserName;
  Shell.User.Subheading = ShellUserSubheading;
  Shell.Workspaces = ShellWorkspaces;
  Shell.Workspace = ShellWorkspace;
  Shell.SolutionSwitcher = ShellSolutionSwitcher;
  Shell.Solutions = ShellSolutions;
  Shell.Solutions.Header = ShellSolutionsHeader;
  Shell.Solution = ShellSolution;
  Shell.Solution.Label = ShellSolutionLabel;
  Shell.OrgSwitcher = ShellOrgSwitcher;
  Shell.OrgSwitcher.Footer = ShellOrgSwitcherFooter;
  Shell.Organization = ShellOrganization;
  Shell.Suborganization = ShellSuborganization;
  Shell.SelectListSwitcher = ShellSelectListSwitcher;
  Shell.SelectListSwitcherItem = ShellSelectListSwitcherItem;

  var CLASSNAME$1r = '_coral-SideNav';

  var isLevel = function isLevel(node) {
    return node.nodeName === 'CORAL-SIDENAV-LEVEL';
  };

  var isHeading = function isHeading(node) {
    return node.nodeName === 'CORAL-SIDENAV-HEADING';
  };

  var isItem = function isItem(node) {
    return node.nodeName === 'A' && node.getAttribute('is') === 'coral-sidenav-item';
  };
  /**
   Enumeration for {@link SideNav} variants.

   @typedef {Object} SideNavVariantEnum

   @property {String} DEFAULT
   A default sidenav.
   @property {String} MULTI_LEVEL
   A sidenav with multiple levels of indentation.
   */


  var variant$j = {
    DEFAULT: 'default',
    MULTI_LEVEL: 'multilevel'
  };
  /**
   @class Coral.SideNav
   @classdesc A Side Navigation component to navigate the entire content of a product or a section.
   These can be used for a single level or a multi-level navigation.
   @htmltag coral-sidenav
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var SideNav = Decorator( /*#__PURE__*/function (_BaseComponent) {
    _inherits(_class, _BaseComponent);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this); // Attach events

      _this._delegateEvents({
        // Interaction
        'click a[is="coral-sidenav-item"]': '_onItemClick',
        // Accessibility
        'capture:focus a[is="coral-sidenav-item"].focus-ring': '_onItemFocusIn',
        'capture:blur a[is="coral-sidenav-item"]': '_onItemFocusOut',
        // Private
        'coral-sidenav-item:_selectedchanged': '_onItemSelectedChanged'
      }); // Used for eventing


      _this._oldSelection = null; // Level Collection

      _this._levels = _this.getElementsByTagName('coral-sidenav-level'); // Heading Collection

      _this._headings = _this.getElementsByTagName('coral-sidenav-heading'); // Init the collection mutation observer

      _this.items._startHandlingItems(true); // Initialize content MO


      _this._observer = new MutationObserver(_this._handleMutations.bind(_assertThisInitialized(_this)));

      _this._observer.observe(_assertThisInitialized(_this), {
        childList: true,
        subtree: true
      });

      return _this;
    }
    /**
     The Collection Interface that allows interacting with the items that the component contains.
      @type {Collection}
     @readonly
     */


    _createClass(_class, [{
      key: "_onItemClick",
      value: function _onItemClick(event) {
        var item = event.matchedTarget;

        if (!item.selected) {
          item.selected = true;
        }
      }
    }, {
      key: "_onItemFocusIn",
      value: function _onItemFocusIn(event) {
        var item = event.matchedTarget;

        item._elements.container.classList.add('focus-ring');
      }
    }, {
      key: "_onItemFocusOut",
      value: function _onItemFocusOut(event) {
        var item = event.matchedTarget;

        item._elements.container.classList.remove('focus-ring');
      }
    }, {
      key: "_onItemSelectedChanged",
      value: function _onItemSelectedChanged(event) {
        event.stopImmediatePropagation();

        this._validateSelection(event.target);
      }
    }, {
      key: "_validateSelection",
      value: function _validateSelection(item) {
        var _this2 = this;

        var selectedItems = this.items._getAllSelected(); // Last selected item wins if multiple selection while not allowed


        item = item || selectedItems[selectedItems.length - 1]; // Deselect other selected items

        if (item && item.hasAttribute('selected') && selectedItems.length > 1) {
          selectedItems.forEach(function (selectedItem) {
            if (selectedItem !== item) {
              // Don't trigger change events
              _this2._preventTriggeringEvents = true;
              selectedItem.removeAttribute('selected');
            }
          }); // We can trigger change events again

          this._preventTriggeringEvents = false;
        } // Expand multi level


        this._expandLevels(); // Notify of change


        this._triggerChangeEvent();
      }
    }, {
      key: "_expandLevels",
      value: function _expandLevels() {
        var selectedItem = this.selectedItem;

        if (selectedItem) {
          var level = selectedItem.closest('coral-sidenav-level'); // Expand until root

          while (level) {
            level.setAttribute('_expanded', 'on');
            var prev = level.previousElementSibling;

            if (prev && prev.matches('a[is="coral-sidenav-item"]')) {
              prev.setAttribute('aria-expanded', 'true');
            }

            level = level.parentNode && level.parentNode.closest('coral-sidenav-level');
          } // Expand corresponding item level


          level = selectedItem.nextElementSibling;

          if (level && level.tagName === 'CORAL-SIDENAV-LEVEL') {
            level.setAttribute('_expanded', 'on');
            selectedItem.setAttribute('aria-expanded', 'true');
          }
        }
      }
    }, {
      key: "_triggerChangeEvent",
      value: function _triggerChangeEvent() {
        var selectedItem = this.selectedItem;
        var oldSelection = this._oldSelection;

        if (!this._preventTriggeringEvents && selectedItem !== oldSelection) {
          this.trigger('coral-sidenav:change', {
            oldSelection: oldSelection,
            selection: selectedItem
          });
          this._oldSelection = selectedItem;
        }
      }
    }, {
      key: "_syncLevel",
      value: function _syncLevel(el, isRemoved) {
        if (isRemoved) {
          if (el.id && isLevel(el)) {
            var item = this.querySelector("a[is=\"coral-sidenav-item\"][aria-controls=\"".concat(el.id, "\"]"));
            item && item.removeAttribute('aria-controls');
          } else if (el.id && (isHeading(el) || isItem(el))) {
            var level = this.querySelector("coral-sidenav-level[aria-labelledby=\"".concat(el.id, "\"]"));
            level && level.removeAttribute('aria-labelledby');

            this._syncLevel(level);
          }
        } else if (isLevel(el)) {
          var prev = el.previousElementSibling;

          if (prev && (isHeading(prev) || isItem(prev))) {
            prev.id = prev.id || commons.getUID();
            el.setAttribute('aria-labelledby', prev.id);

            if (isItem(prev)) {
              el.id = el.id || commons.getUID();
              prev.setAttribute('aria-controls', el.id);
            }
          }
        } else if (isHeading(el) || isItem(el)) {
          var next = el.nextElementSibling;

          if (next && isLevel(next)) {
            el.id = el.id || commons.getUID();
            next.setAttribute('aria-labelledby', el.id);

            if (isItem(el)) {
              next.id = next.id || commons.getUID();
              el.setAttribute('aria-controls', next.id);
            }
          }
        }
      }
    }, {
      key: "_syncHeading",
      value: function _syncHeading(heading) {
        heading.classList.add("".concat(CLASSNAME$1r, "-heading"));
        heading.setAttribute('role', 'heading');
      }
    }, {
      key: "_handleMutations",
      value: function _handleMutations(mutations) {
        var _this3 = this;

        mutations.forEach(function (mutation) {
          // Sync added levels and headings
          for (var i = 0; i < mutation.addedNodes.length; i++) {
            var addedNode = mutation.addedNodes[i]; // a11y

            _this3._syncLevel(addedNode); // a11y


            if (isHeading(addedNode)) {
              _this3._syncHeading(addedNode);
            }

            if (isLevel(addedNode)) {
              _this3._validateSelection(addedNode.querySelector('a[is="coral-sidenav-item"][selected]'));
            }
          } // Sync removed levels


          for (var k = 0; k < mutation.removedNodes.length; k++) {
            var removedNode = mutation.removedNodes[k];

            _this3._syncLevel(removedNode, true);

            if (isLevel(removedNode)) {
              _this3._validateSelection();
            }
          }
        });
      }
      /**
       Returns {@link SideNav} variants.
        @return {SideNavVariantEnum}
       */

    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1r); // Default reflected attributes

        if (!this._variant) {
          this.variant = variant$j.DEFAULT;
        } // a11y


        for (var i = 0; i < this._levels.length; i++) {
          this._syncLevel(this._levels[i]);
        } // a11y


        for (var _i = 0; _i < this._headings.length; _i++) {
          this._syncHeading(this._headings[_i]);
        } // Don't trigger events once connected


        this._preventTriggeringEvents = true;

        this._validateSelection();

        this._preventTriggeringEvents = false;
        this._oldSelection = this.selectedItem;
      }
      /**
       Triggered when {@link SideNav} selected item has changed.
        @typedef {CustomEvent} coral-sidenav:change
        @property {SideNavItem} detail.oldSelection
       The prior selected item.
       @property {SideNavItem} detail.selection
       The newly selected item.
       */

    }, {
      key: "items",
      get: function get() {
        // just init on demand
        if (!this._items) {
          this._items = new SelectableCollection({
            host: this,
            itemTagName: 'coral-sidenav-item',
            itemBaseTagName: 'a',
            onItemAdded: this._validateSelection,
            onItemRemoved: this._validateSelection
          });
        }

        return this._items;
      }
      /**
       Returns the first selected item in the sidenav. The value <code>null</code> is returned if no element is
       selected.
        @type {SideNavItem}
       @readonly
       */

    }, {
      key: "selectedItem",
      get: function get() {
        return this.items._getFirstSelected();
      }
      /**
       The sidenav's variant. See {@link SideNavVariantEnum}.
        @type {String}
       @default SideNavVariantEnum.DEFAULT
       @htmlattribute variant
       @htmlattributereflected
       */

    }, {
      key: "variant",
      get: function get() {
        return this._variant || variant$j.DEFAULT;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        this._variant = validate.enumeration(variant$j)(value) && value || variant$j.DEFAULT;

        this._reflectAttribute('variant', this._variant);

        this.classList.toggle("".concat(CLASSNAME$1r, "--multiLevel"), this._variant === variant$j.MULTI_LEVEL);

        if (this.variant === variant$j.MULTI_LEVEL) {
          // Don't hide the selected item level
          var selectedItem = this.selectedItem;
          var ignoreLevel = selectedItem && selectedItem.parentNode; // Hide every other level that doesn't contain the selected item

          for (var i = 0; i < this._levels.length; i++) {
            if (this._levels[i] !== ignoreLevel) {
              this._levels[i].setAttribute('_expanded', 'off');
            }
          }
        }
      }
    }], [{
      key: "variant",
      get: function get() {
        return variant$j;
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['variant']);
      }
    }]);

    return _class;
  }(BaseComponent(HTMLElement)));

  var template$Z = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["container"] = document.createElement("div");
    el0.className += " _coral-SideNav-itemLink";
    el0.setAttribute("handle", "container");
    var el1 = document.createTextNode("\n  ");
    el0.appendChild(el1);
    var el2 = this["icon"] = document.createElement("coral-icon");
    el2.setAttribute("hidden", "");
    el2.className += " _coral-UIIcon-Star _coral-SideNav-itemIcon";
    el2.setAttribute("handle", "icon");
    el0.appendChild(el2);
    var el3 = document.createTextNode("\n");
    el0.appendChild(el3);
    frag.appendChild(el0);
    var el4 = document.createTextNode("\n");
    frag.appendChild(el4);
    return frag;
  };

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var CLASSNAME$1s = '_coral-SideNav-item';
  /**
   @class Coral.SideNav.Item
   @classdesc A SideNav Item component.
   @htmltag coral-sidenav-item
   @extends {HTMLAnchorElement}
   @extends {BaseComponent}
   */

  var SideNavItem = Decorator( /*#__PURE__*/function (_BaseLabellable) {
    _inherits(_class, _BaseLabellable);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _thisSuper, _this;

      _classCallCheck(this, _class);

      _this = _super.call(this); // Prepare templates

      _this._elements = {
        content: _this.querySelector('coral-sidenav-item-content') || document.createElement('coral-sidenav-item-content')
      };
      template$Z.call(_this._elements);

      _get((_thisSuper = _assertThisInitialized(_this), _getPrototypeOf(_class.prototype)), "_observeLabel", _thisSuper).call(_thisSuper);

      return _this;
    }
    /**
     The content of the sidenav item.
      @type {SideNavItemContent}
     @contentzone
     */


    _createClass(_class, [{
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1s); // Create a fragment

        var fragment = document.createDocumentFragment(); // Render the main template

        fragment.appendChild(this._elements.container);
        var content = this._elements.content; // Remove it so we can process children

        if (content.parentNode) {
          content.parentNode.removeChild(content);
        } // Process remaining elements as necessary


        while (this.firstChild) {
          var child = this.firstChild;

          if (child.nodeType === Node.TEXT_NODE || child.nodeType === Node.ELEMENT_NODE && child.getAttribute('handle') !== 'container') {
            // Add non-template elements to the content
            content.appendChild(child);
          } else {
            // Remove anything else
            this.removeChild(child);
          }
        } // Add the frag to the component


        this.appendChild(fragment); // Assign the content zones, moving them into place in the process

        this.content = content;
      }
    }, {
      key: "content",
      get: function get() {
        return this._getContentZone(this._elements.content);
      },
      set: function set(value) {
        this._setContentZone('content', value, {
          handle: 'content',
          tagName: 'coral-sidenav-item-content',
          insert: function insert(content) {
            this._elements.container.appendChild(content);
          }
        });
      }
      /**
       Specifies the icon name used inside the item. See {@link Icon} for valid icon names.
        @type {String}
       @default ""
       @htmlattribute icon
       */

    }, {
      key: "icon",
      get: function get() {
        return this._elements.icon.icon;
      },
      set: function set(value) {
        this._elements.icon.icon = value;
        this._elements.icon.hidden = this._elements.icon.icon === '';

        _get(_getPrototypeOf(_class.prototype), "_toggleIconAriaHidden", this).call(this);
      }
      /**
       Whether the item is selected.
        @type {Boolean}
       @default false
       @htmlattribute selected
       @htmlattributereflected
       */

    }, {
      key: "selected",
      get: function get() {
        return this._selected || false;
      },
      set: function set(value) {
        this._selected = transform.booleanAttr(value);

        this._reflectAttribute('selected', this._selected);

        this.classList.toggle('is-selected', this._selected);
        this.trigger('coral-sidenav-item:_selectedchanged');
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-sidenav-item-label': 'content'
        };
      }
      /** @ignore */

    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['selected', 'icon']);
      }
    }]);

    return _class;
  }(BaseLabellable(BaseComponent(HTMLAnchorElement))));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.SideNav.Item.Content
   @classdesc The SideNav Item Content
   @htmltag coral-sidenav-item-content
   @return {HTMLElement}
   */
  var SideNavItemContent = (function () {
    return document.createElement('coral-sidenav-item-content');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.SideNav.Heading
   @classdesc The SideNav Heading
   @htmltag coral-sidenav-heading
   @return {HTMLElement}
   */
  var SideNavHeading = (function () {
    return document.createElement('coral-sidenav-heading');
  });

  var CLASSNAME$1t = '_coral-SideNav';
  /**
   @class Coral.SideNav.Level
   @classdesc A SideNav Level component
   @htmltag coral-sidenav-level
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var SideNavLevel = Decorator( /*#__PURE__*/function (_BaseComponent) {
    _inherits(_class, _BaseComponent);

    var _super = _createSuper(_class);

    function _class() {
      _classCallCheck(this, _class);

      return _super.apply(this, arguments);
    }

    _createClass(_class, [{
      key: "attributeChangedCallback",

      /** @ignore */
      value: function attributeChangedCallback(name, oldValue, value) {
        var _this = this;

        if (name === '_expanded') {
          var isExpanded = value === 'on';

          if (oldValue !== value) {
            this.classList.toggle('is-expanded', isExpanded); // Do animation in next frame to avoid a forced reflow

            window.requestAnimationFrame(function () {
              // Don't animate on initialization
              if (_this._animate) {
                // Remove height as we want the level to naturally grow if content is added later
                commons.transitionEnd(_this, function () {
                  if (isExpanded) {
                    _this.style.height = '';
                  } else {
                    _this.hidden = true;
                  }
                }); // Force height to enable transition

                if (!isExpanded) {
                  _this.style.height = "".concat(_this.scrollHeight, "px");
                } else {
                  _this.hidden = false;
                } // We read the offset height to force a reflow, this is needed to start the transition between absolute values
                // https://blog.alexmaccaw.com/css-transitions under Redrawing
                // eslint-disable-next-line no-unused-vars


                var offsetHeight = _this.offsetHeight;
                _this.style.height = isExpanded ? "".concat(_this.scrollHeight, "px") : 0;
              } else {
                // Make sure it's animated next time
                _this._animate = true; // Hide it on initialization if closed

                if (!isExpanded) {
                  _this.style.height = 0;
                  _this.hidden = true;
                }
              }
            });
          }
        } else {
          _get(_getPrototypeOf(_class.prototype), "attributeChangedCallback", this).call(this, name, oldValue, value);
        }
      }
      /** @ignore */

    }, {
      key: "render",
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1t); // a11y

        this.setAttribute('role', 'region');
      }
    }], [{
      key: "observedAttributes",

      /** @ignore */
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['_expanded']);
      }
    }]);

    return _class;
  }(BaseComponent(HTMLElement)));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons._define('coral-sidenav-level', SideNavLevel);

  commons._define('coral-sidenav-item', SideNavItem, {
    extends: 'a'
  });

  commons._define('coral-sidenav', SideNav, {
    extends: 'nav'
  });

  SideNav.Item = SideNavItem;
  SideNav.Item.Content = SideNavItemContent;
  SideNav.Heading = SideNavHeading;
  SideNav.Level = SideNavLevel;

  /**
   Enumeration for {@link SplitButton} variants.

   @typedef {Object} SplitButtonVariantEnum

   @property {String} DEFAULT
   The default button look and feel.
   @property {String} CTA
   A button that is meant to grab the user's attention.
   @property {String} SECONDARY
   A button that indicates that the button's action is the secondary action.
   */

  var variant$k = {
    DEFAULT: 'default',
    CTA: 'cta',
    SECONDARY: 'secondary'
  };
  var CLASSNAME$1u = '_coral-SplitButton';
  /**
   @class Coral.SplitButton
   @classdesc A Split Button component composed of an action and a trigger {@link AnchorButton} or {@link Button}.
   These elements should be marked with following attributes:
   - <code>[coral-splitbutton-action]</code> for the main action button.
   - <code>[coral-splitbutton-trigger]</code> for the trigger button.

   @htmltag coral-splitbutton
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var SplitButton = Decorator( /*#__PURE__*/function (_BaseComponent) {
    _inherits(_class, _BaseComponent);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this); // Watch for inner button changes

      _this._observer = new MutationObserver(function () {
        _this._updateLeftVariant();

        _this._updateInnerButtons();

        _this._updateInnerButtonsVariant(_this.variant);
      });

      _this._observer.observe(_assertThisInitialized(_this), {
        subtree: true,
        childList: true
      });

      return _this;
    }
    /**
     The button's variant. See {@link SplitButtonVariantEnum}.
      @type {String}
     @default SplitButtonVariantEnum.DEFAULT
     @htmlattribute variant
     @htmlattributereflected
     */


    _createClass(_class, [{
      key: "_getInnerButtons",
      value: function _getInnerButtons() {
        var action = this.querySelector('[coral-splitbutton-action]');
        var trigger = this.querySelector('[coral-splitbutton-trigger]');
        return {
          action: action,
          trigger: trigger
        };
      }
    }, {
      key: "_updateLeftVariant",
      value: function _updateLeftVariant() {
        for (var i = 0; i < this.children.length; i++) {
          var child = this.children[i];

          if (child.hasAttribute('coral-splitbutton-trigger')) {
            this.classList.add('_coral-SplitButton--left');
            return;
          } else if (child.hasAttribute('coral-splitbutton-action')) {
            this.classList.remove('_coral-SplitButton--left');
            return;
          }
        }
      }
    }, {
      key: "_updateInnerButtonsVariant",
      value: function _updateInnerButtonsVariant(variant) {
        var _this$_getInnerButton = this._getInnerButtons(),
            action = _this$_getInnerButton.action,
            trigger = _this$_getInnerButton.trigger;

        if (action) {
          action.setAttribute('variant', variant);
        }

        if (trigger) {
          trigger.setAttribute('variant', variant);
        }
      }
    }, {
      key: "_updateInnerButtons",
      value: function _updateInnerButtons() {
        var _this$_getInnerButton2 = this._getInnerButtons(),
            action = _this$_getInnerButton2.action,
            trigger = _this$_getInnerButton2.trigger;

        if (action) {
          action.classList.add('_coral-SplitButton-action');
        }

        if (trigger) {
          trigger.classList.add('_coral-SplitButton-trigger'); // a11y assume a popover is targeting the trigger

          trigger.setAttribute('aria-haspopup', 'true');

          if (action) {
            action.id = action.id || commons.getUID();
            trigger.setAttribute('aria-labelledby', action.id);
          }
        }
      }
      /**
       Returns {@link SplitButton} variants.
        @return {SplitButtonVariantEnum}
       */

    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1u); // a11y

        this.setAttribute('role', 'group'); // Default reflected attributes

        if (!this._variant) {
          this.variant = variant$k.DEFAULT;
        } // Update styles


        this._updateLeftVariant();

        this._updateInnerButtons();
      }
    }, {
      key: "variant",
      get: function get() {
        return this._variant || variant$k.DEFAULT;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        this._variant = validate.enumeration(variant$k)(value) && value || variant$k.DEFAULT;

        this._reflectAttribute('variant', this._variant);

        this._updateInnerButtonsVariant(this._variant);
      }
    }], [{
      key: "variant",
      get: function get() {
        return variant$k;
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['variant']);
      }
    }]);

    return _class;
  }(BaseComponent(HTMLElement)));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons._define('coral-splitbutton', SplitButton);

  /**
   Enumeration for {@link Status} variants.

   @typedef {Object} StatusVariantEnum

   @property {String} NEUTRAL
   A default semantic neutral status.
   @property {String} WARNING
   A notice semantic status.
   @property {String} SUCCESS
   A positive semantic status.
   @property {String} ERROR
   A negative semantic status.
   @property {String} INFO
   An informative semantic status.
   */

  var variant$l = {
    NEUTRAL: 'neutral',
    ERROR: 'error',
    WARNING: 'warning',
    SUCCESS: 'success',
    INFO: 'info'
  };
  /**
   Enumeration for {@link Status} colors.

   @typedef {Object} StatusColorEnum

   @property {String} DEFAULT
   @property {String} CELERY
   @property {String} YELLOW
   @property {String} FUCHSIA
   @property {String} INDIGO
   @property {String} SEA_FOAM
   @property {String} CHARTREUSE
   @property {String} MAGENTA
   @property {String} PURPLE
   */

  var color$1 = {
    DEFAULT: '',
    CELERY: 'celery',
    YELLOW: 'yellow',
    FUCHSIA: 'fuchsia',
    INDIGO: 'indigo',
    SEA_FOAM: 'seafoam',
    CHARTREUSE: 'chartreuse',
    MAGENTA: 'magenta',
    PURPLE: 'purple'
  };
  var CLASSNAME$1v = '_coral-StatusLight';
  var variantMapping = {
    SUCCESS: 'positive',
    ERROR: 'negative',
    WARNING: 'notice'
  };
  var ALL_VARIANT_CLASSES$b = [];

  for (var variantValue$9 in variant$l) {
    ALL_VARIANT_CLASSES$b.push("".concat(CLASSNAME$1v, "--").concat(variantMapping[variantValue$9] || variant$l[variantValue$9]));
  }

  var ALL_COLOR_CLASSES$1 = [];

  for (var colorValue$1 in color$1) {
    ALL_COLOR_CLASSES$1.push("".concat(CLASSNAME$1v, "--").concat(color$1[colorValue$1]));
  }
  /**
   @class Coral.Status
   @classdesc A Status component to describe the condition of another entity. They can be used to convey semantic meaning
   such as statuses and categories.

   @htmltag coral-status
   @extends {HTMLElement}
   @extends {BaseComponent}
   */


  var Status = Decorator( /*#__PURE__*/function (_BaseComponent) {
    _inherits(_class, _BaseComponent);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this); // Prepare templates

      _this._elements = {
        // Fetch or create the content zone element
        label: _this.querySelector('coral-status-label') || document.createElement('coral-status-label')
      };
      return _this;
    }
    /**
     Whether the status is disabled or not.
      @type {Boolean}
     @default false
     @htmlattribute disabled
     @htmlattributereflected
     */


    _createClass(_class, [{
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1v); // Default reflected attributes

        if (!this._variant) {
          this.variant = variant$l.NEUTRAL;
        }

        if (!this._color) {
          this.color = color$1.DEFAULT;
        } // Fetch or create the content content zone element


        var label = this._elements.label; // This stops the content zone from being voracious

        if (!label.parentNode) {
          // move the contents into the content zone
          while (this.firstChild) {
            label.appendChild(this.firstChild);
          }
        } // Assign the content zone moving it into place


        this.label = label;
      }
    }, {
      key: "disabled",
      get: function get() {
        return this._disabled || false;
      },
      set: function set(value) {
        this._disabled = transform.booleanAttr(value);

        this._reflectAttribute('disabled', this._disabled);

        this[this._disabled ? 'setAttribute' : 'removeAttribute']('aria-disabled', this._disabled);
      }
      /**
       The status variant. See {@link StatusVariantEnum}.
       When a status has a semantic meaning, it should use semantic colors.
        @type {String}
       @default StatusVariantEnum.NEUTRAL
       @htmlattribute variant
       @htmlattributereflected
       */

    }, {
      key: "variant",
      get: function get() {
        return this._variant || variant$l.NEUTRAL;
      },
      set: function set(value) {
        var _this$classList;

        value = transform.string(value).toLowerCase();
        this._variant = validate.enumeration(variant$l)(value) && value || variant$l.NEUTRAL;

        this._reflectAttribute('variant', this._variant);

        (_this$classList = this.classList).remove.apply(_this$classList, ALL_VARIANT_CLASSES$b);

        this.classList.add("".concat(CLASSNAME$1v, "--").concat(variantMapping[this._variant.toUpperCase()] || this._variant));
      }
      /**
       The status color. See {@link StatusColorEnum}.
       When a status is used to color code categories and labels commonly found in data visualization, they should use
       colors.
        The ideal usage for colors is when there are 8 or fewer categories or labels being color coded.
       Use them in the following order to ensure the greatest possible color differences for multiple forms of color
       blindness:
       - Indigo
       - Celery
       - Magenta
       - Yellow
       - Fuchsia
       - Seafoam
       - Chartreuse
       - Purple
        If a color is set, it'll override any semantic variant.
        @type {String}
       @default StatusColorEnum.DEFAULT
       @htmlattribute color
       @htmlattributereflected
       */

    }, {
      key: "color",
      get: function get() {
        return this._color || color$1.DEFAULT;
      },
      set: function set(value) {
        var _this$classList2;

        value = transform.string(value).toLowerCase();
        this._color = validate.enumeration(color$1)(value) && value || color$1.DEFAULT;

        this._reflectAttribute('color', this._color);

        (_this$classList2 = this.classList).remove.apply(_this$classList2, ALL_COLOR_CLASSES$1);

        if (this._color !== color$1.DEFAULT) {
          this.classList.add("".concat(CLASSNAME$1v, "--").concat(this._color));
        }
      }
      /**
       The status label element.
        @type {StatusLabel}
       @contentzone
       */

    }, {
      key: "label",
      get: function get() {
        return this._getContentZone(this._elements.label);
      },
      set: function set(value) {
        this._setContentZone('label', value, {
          handle: 'label',
          tagName: 'coral-status-label',
          insert: function insert(label) {
            this.appendChild(label);
          }
        });
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-status-label': 'label'
        };
      }
      /**
       Returns {@link Status} variants.
        @return {StatusVariantEnum}
       */

    }], [{
      key: "variant",
      get: function get() {
        return variant$l;
      }
      /**
       Returns {@link Status} colors.
        @return {StatusColorEnum}
       */

    }, {
      key: "color",
      get: function get() {
        return color$1;
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['variant', 'color', 'disabled']);
      }
    }]);

    return _class;
  }(BaseComponent(HTMLElement)));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Status.Label
   @classdesc The Status Label
   @htmltag coral-status-label
   @return {HTMLElement}
   */
  var StatusLabel = (function () {
    return document.createElement('coral-status-label');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons._define('coral-status', Status);

  Status.Label = StatusLabel;

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   Gets the target panel of the item.

   @private
   @param {HTMLElement|String} [targetValue]
   A specific target value to use.
   @returns {?HTMLElement}
   */
  function getTarget(targetValue) {
    if (targetValue instanceof Node) {
      // Just return the provided Node
      return targetValue;
    } // Dynamically get the target node based on the target


    var newTarget = null;

    if (typeof targetValue === 'string' && targetValue.trim() !== '') {
      newTarget = document.querySelector(targetValue);
    }

    return newTarget;
  }

  /**
   Enumeration for {@link StepList} interaction options.

   @todo support "click only past steps" mode

   @typedef {Object} StepListInteractionEnum

   @property {String} ON
   Steps can be clicked to visit them.
   @property {String} OFF
   Steps cannot be clicked.
   */

  var interaction$4 = {
    ON: 'on',
    OFF: 'off'
  };
  /**
   Enumeration for {@link StepList} sizes.

   @typedef {Object} StepListSizeEnum

   @property {String} SMALL
   A small-sized StepList.
   @property {String} LARGE
   A large-sized StepList.
   */

  var size$7 = {
    SMALL: 'S',
    LARGE: 'L'
  }; // the StepList's base classname

  var CLASSNAME$1w = '_coral-Steplist';
  /**
   @class Coral.StepList
   @classdesc A StepList component that holds a collection of steps.
   @htmltag coral-steplist
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var StepList = Decorator( /*#__PURE__*/function (_BaseComponent) {
    _inherits(_class, _BaseComponent);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this);

      _this._delegateEvents({
        'click > coral-step > [handle="link"]': '_onStepClick',
        'capture:focus > coral-step': '_onStepMouseEnter',
        'capture:mouseenter > coral-step > [handle="link"]': '_onStepMouseEnter',
        'capture:blur > coral-step': '_onStepMouseLeave',
        'capture:mouseleave > coral-step > [handle="link"]': '_onStepMouseLeave',
        'key:enter > coral-step > [handle="link"]': '_onStepKeyboardSelect',
        'key:space > coral-step > [handle="link"]': '_onStepKeyboardSelect',
        'key:home > coral-step > [handle="link"]': '_onHomeKey',
        'key:end > coral-step > [handle="link"]': '_onEndKey',
        'key:pagedown > coral-step > [handle="link"]': '_selectNextItem',
        'key:right > coral-step > [handle="link"]': '_selectNextItem',
        'key:down > coral-step > [handle="link"]': '_selectNextItem',
        'key:pageup > coral-step > [handle="link"]': '_selectPreviousItem',
        'key:left > coral-step > [handle="link"]': '_selectPreviousItem',
        'key:up > coral-step > [handle="link"]': '_selectPreviousItem',
        // private
        'coral-step:_selectedchanged': '_onItemSelectedChanged'
      }); // Used for eventing


      _this._oldSelection = null; // Init the collection mutation observer

      _this.items._startHandlingItems(true);

      return _this;
    }
    /**
     The Collection Interface that allows interacting with the items that the component contains.
      @type {SelectableCollection}
     @readonly
     */


    _createClass(_class, [{
      key: "_syncItemTabIndex",

      /** @private */
      value: function _syncItemTabIndex(item) {
        item._syncTabIndex(this.interaction === interaction$4.ON);
      }
      /** @private */

    }, {
      key: "_onItemSelectedChanged",
      value: function _onItemSelectedChanged(event) {
        event.stopImmediatePropagation();
        var item = event.target;

        this._syncItemTabIndex(item);

        this._validateSelection(item);
      }
      /** @private */

    }, {
      key: "_validateSelection",
      value: function _validateSelection(item) {
        // gets the current selection
        var selection = this.items._getAllSelected();

        var selectionCount = selection.length; // if no item is currently selected, we need to find a candidate

        if (selectionCount === 0) {
          // gets the first candidate for selection
          var selectable = this.items._getFirstSelectable();

          if (selectable) {
            selectable.setAttribute('selected', '');
          }
        } // more items are selected, so we find a single item and deselect everything else
        else if (selectionCount > 1) {
            // By default, the last one stays selected
            item = item || selection[selection.length - 1];

            for (var i = 0; i < selectionCount; i++) {
              if (selection[i] !== item) {
                // Don't trigger change events
                this._preventTriggeringEvents = true;
                selection[i].removeAttribute('selected');
              }
            } // We can trigger change events again


            this._preventTriggeringEvents = false;
          } // sets the state-related classes every time the selection changes


        this._setStateClasses();

        this._triggerChangeEvent();
      }
      /** @private */

    }, {
      key: "_triggerChangeEvent",
      value: function _triggerChangeEvent() {
        var selectedItem = this.selectedItem;
        var oldSelection = this._oldSelection;

        if (!this._preventTriggeringEvents && selectedItem !== oldSelection) {
          this.trigger('coral-steplist:change', {
            oldSelection: oldSelection,
            selection: selectedItem
          });
          this._oldSelection = selectedItem;
        }
      }
      /** @private */

    }, {
      key: "_setStateClasses",
      value: function _setStateClasses() {
        var selectedItemIndex = Infinity;
        this.items.getAll().forEach(function (item, index) {
          // Use attribute instead of property as items might not be initialized
          if (item.hasAttribute('selected')) {
            // Mark which one is selected
            selectedItemIndex = index;
          } // Add/remove classes based on index


          item.classList.toggle('is-complete', index < selectedItemIndex);

          if (!item._elements) {
            return;
          } // Set accessibilityState text label


          var accessibilityLabel = i18n.get('not completed: ');

          if (index < selectedItemIndex) {
            accessibilityLabel = i18n.get('completed: ');
          } else if (index === selectedItemIndex) {
            accessibilityLabel = i18n.get('current: ');
          }

          item._elements.accessibilityLabel.innerHTML = accessibilityLabel;
        });
      }
      /** @private */

    }, {
      key: "_onStepKeyboardSelect",
      value: function _onStepKeyboardSelect(event) {
        if (this.interaction === interaction$4.ON) {
          event.preventDefault();
          event.stopPropagation();
          var item = event.matchedTarget.closest('coral-step');

          this._selectAndFocusItem(item);

          this._trackEvent('click', 'coral-steplist-item', event, item);
        }
      }
      /** @private */

    }, {
      key: "_onStepClick",
      value: function _onStepClick(event) {
        if (this.interaction === interaction$4.ON) {
          event.preventDefault();
          event.stopPropagation();
          var item = event.matchedTarget.closest('coral-step'); // Disabled item should not get selected

          if (item.disabled) {
            return;
          }

          this._selectAndFocusItem(item);

          this._trackEvent('click', 'coral-steplist-item', event, item);
        }
      }
      /** @private */

    }, {
      key: "_onStepMouseEnter",
      value: function _onStepMouseEnter() {
        if (this.size === size$7.SMALL) {
          var step = event.target.closest('coral-step'); // we only show the tooltip if we have a label to show

          if (step._elements.label.innerHTML.trim() !== '') {
            step._elements.overlay.content.innerHTML = step._elements.label.innerHTML;
            step._elements.overlay.open = true;
          }
        }
      }
      /** @private */

    }, {
      key: "_onStepMouseLeave",
      value: function _onStepMouseLeave(event) {
        if (this.size === size$7.SMALL) {
          var step = event.target.closest('coral-step');
          step._elements.overlay.open = false;
        }
      }
      /** @private */

    }, {
      key: "_onHomeKey",
      value: function _onHomeKey(event) {
        if (this.interaction === interaction$4.ON) {
          event.preventDefault();

          var item = this.items._getFirstSelectable();

          this._selectAndFocusItem(item);
        }
      }
      /** @private */

    }, {
      key: "_onEndKey",
      value: function _onEndKey(event) {
        if (this.interaction === interaction$4.ON) {
          event.preventDefault();

          var item = this.items._getLastSelectable();

          this._selectAndFocusItem(item);
        }
      }
      /** @private */

    }, {
      key: "_selectNextItem",
      value: function _selectNextItem(event) {
        if (this.interaction === interaction$4.ON) {
          event.preventDefault();
          this.next();
        }
      }
      /** @private */

    }, {
      key: "_selectPreviousItem",
      value: function _selectPreviousItem(event) {
        if (this.interaction === interaction$4.ON) {
          event.preventDefault();
          this.previous();
        }
      }
      /** @private */

    }, {
      key: "_selectAndFocusItem",
      value: function _selectAndFocusItem(item) {
        if (item) {
          item.setAttribute('selected', '');
          item.focus();
        }
      }
      /**
       Show the next Step.
        @emits {coral-steplist:change}
       */

    }, {
      key: "next",
      value: function next() {
        var item = this.selectedItem;

        if (item) {
          item = this.items._getNextSelectable(item);

          this._selectAndFocusItem(item);
        }
      }
      /**
       Show the previous Step.
        @emits {coral-steplist:change}
       */

    }, {
      key: "previous",
      value: function previous() {
        var item = this.selectedItem;

        if (item) {
          item = this.items._getPreviousSelectable(item);

          this._selectAndFocusItem(item);
        }
      }
      /**
       Returns {@link StepList} sizes.
        @return {StepListSizeEnum}
       */

    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1w); // Default reflected attributes

        if (!this._interaction) {
          this.interaction = interaction$4.OFF;
        }

        if (!this._size) {
          this.size = size$7.LARGE;
        } // A11y


        this.setAttribute('role', 'list'); // provide accessibility label for the list

        if (!this.hasAttribute('aria-label') && !this.hasAttribute('aria-labelledby')) {
          this.setAttribute('aria-label', i18n.get('Step List'));
        } // the screen reader should not navigate to hidden element
        // the element is hidden if has only one child


        if (this.items.length === 1) {
          this.setAttribute('aria-hidden', 'true');
          this.interaction = StepList.interaction.OFF;
        } // Don't trigger events once connected


        this._preventTriggeringEvents = true;

        this._validateSelection();

        this._preventTriggeringEvents = false;
        this._oldSelection = this.selectedItem;
      }
      /**
       Triggered when the {@link StepList} selected {@link Step} has changed.
        @typedef {CustomEvent} coral-steplist:change
        @property {Step} detail.selection
       The newly selected Step.
       @property {Step} detail.oldSelection
       The previously selected Step.
       */

    }, {
      key: "items",
      get: function get() {
        // we do lazy initialization of the collection
        if (!this._items) {
          this._items = new SelectableCollection({
            host: this,
            itemTagName: 'coral-step',
            onItemAdded: this._validateSelection,
            onItemRemoved: this._validateSelection
          });
        }

        return this._items;
      }
      /**
       Returns the selected step.
        @type {HTMLElement}
       @readonly
       */

    }, {
      key: "selectedItem",
      get: function get() {
        return this.items._getLastSelected();
      }
      /**
       The target component that will be linked to the StepList. It accepts either a CSS selector or a DOM element. If
       a CSS Selector is provided, the first matching element will be used. Items will be selected based on the index.
       If both target and {@link Coral.Step#target} are set, the second will have higher priority.
        @type {?HTMLElement|String}
       @default null
       @htmlattribute target
       */

    }, {
      key: "target",
      get: function get() {
        return this._target || null;
      },
      set: function set(value) {
        var _this2 = this;

        if (value === null || typeof value === 'string' || value instanceof Node) {
          this._target = value; // we do this in the sync in case the target was not yet in the DOM

          window.requestAnimationFrame(function () {
            var realTarget = getTarget(_this2._target); // we add proper accessibility if available

            if (realTarget) {
              var stepItems = _this2.items.getAll();

              var panelItems = realTarget.items ? realTarget.items.getAll() : realTarget.children; // we need to add a11y to all components, regardless of whether they can be perfectly paired

              var maxItems = Math.max(stepItems.length, panelItems.length);
              var step;
              var panel;

              for (var i = 0; i < maxItems; i++) {
                step = stepItems[i];
                panel = panelItems[i]; // if the step has its own target, we assume the target component will handle its own accessibility.
                // if the target is an empty string we simply ignore it

                if (step && step.target && step.target.trim() !== '') {
                  continue;
                }

                if (panel) {
                  panel.setAttribute('role', 'region');
                }

                if (step && panel) {
                  // sets the required ids
                  step.id = step.id || commons.getUID();
                  panel.id = panel.id || commons.getUID(); // creates a 2 way binding for accessibility

                  step.setAttribute('aria-controls', panel.id);
                  panel.setAttribute('aria-labelledby', step.id);
                } else if (step) {
                  // cleans the aria since there is no matching panel
                  step.removeAttribute('aria-controls');
                } else {
                  // cleans the aria since there is no matching Step
                  panel.removeAttribute('aria-labelledby');
                }
              }
            }
          });
        }
      }
      /**
       The size of the StepList. It accepts both lower and upper case sizes. Currently only "S" and "L" (the default)
       are available.
       See {@link StepListSizeEnum}.
        @type {String}
       @default StepListSizeEnum.LARGE
       @htmlattribute size
       @htmlattributereflected
       */

    }, {
      key: "size",
      get: function get() {
        return this._size || size$7.LARGE;
      },
      set: function set(value) {
        var _this3 = this;

        value = transform.string(value).toUpperCase();
        this._size = validate.enumeration(size$7)(value) && value || size$7.LARGE;

        this._reflectAttribute('size', this._size);

        this.classList.toggle("".concat(CLASSNAME$1w, "--small"), this._size === size$7.SMALL);

        if (!this.items.length) {
          return;
        } // update aria-label for all children


        var _syncItemLabelled = function _syncItemLabelled() {
          var isSmall = _this3.size === size$7.SMALL;

          var steps = _this3.items.getAll();

          var stepsCount = steps.length;

          for (var i = 0; i < stepsCount; i++) {
            var step = steps[i];
            var label = step._elements.label;

            if (!step.labelled && label.textContent.length) {
              label.classList.toggle('u-coral-screenReaderOnly', isSmall);
              label.style.display = isSmall ? 'block' : '';
            }
          }
        };

        var lastItem = this.items.last();

        if (typeof lastItem._syncTabIndex === 'function') {
          _syncItemLabelled();
        } else {
          commons.ready(lastItem, _syncItemLabelled);
        }
      }
      /**
       Whether Steps should be interactive or not. When interactive, a Step can be clicked to jump to it.
       See {@link StepListInteractionEnum}.
        @type {String}
       @default StepListInteractionEnum.OFF
       @htmlattribute interaction
       @htmlattributereflected
       */

    }, {
      key: "interaction",
      get: function get() {
        return this._interaction || interaction$4.OFF;
      },
      set: function set(value) {
        var _this4 = this;

        value = transform.string(value).toLowerCase();
        this._interaction = validate.enumeration(interaction$4)(value) && value || interaction$4.OFF;

        this._reflectAttribute('interaction', this._interaction);

        var isInteractive = this._interaction === interaction$4.ON;
        this.classList.toggle("".concat(CLASSNAME$1w, "--interactive"), isInteractive);

        if (!this.items.length) {
          return;
        } // update tab index for all children


        var _syncItemProps = function _syncItemProps() {
          var steps = _this4.items.getAll();

          var stepsCount = steps.length;

          for (var i = 0; i < stepsCount; i++) {
            // update tab index for all children
            steps[i]._syncTabIndex(isInteractive); //update posin set and total size for all steps


            steps[i]._syncSizeAndCurrentIndex(i + 1, stepsCount);
          }
        };

        var lastItem = this.items.last();

        if (typeof lastItem._syncTabIndex === 'function') {
          _syncItemProps();
        } else {
          commons.ready(lastItem, _syncItemProps);
        }
      }
    }], [{
      key: "size",
      get: function get() {
        return size$7;
      }
      /**
       Returns {@link StepList} interaction options.
        @return {StepListInteractionEnum}
       */

    }, {
      key: "interaction",
      get: function get() {
        return interaction$4;
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['target', 'size', 'interaction']);
      }
    }]);

    return _class;
  }(BaseComponent(HTMLElement)));

  var template$_ = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["link"] = document.createElement("a");
    el0.className += " _coral-Steplist-link";
    el0.setAttribute("handle", "link");
    var el1 = document.createTextNode("\n  ");
    el0.appendChild(el1);
    var el2 = this["accessibilityLabel"] = document.createElement("span");
    el2.className += " u-coral-screenReaderOnly _coral-Steplist-accessibilityLabel";
    el2.setAttribute("handle", "accessibilityLabel");
    el0.appendChild(el2);
    var el3 = document.createTextNode("\n  ");
    el0.appendChild(el3);
    var el4 = this["stepMarkerContainer"] = document.createElement("span");
    el4.className += " _coral-Steplist-markerContainer";
    el4.setAttribute("handle", "stepMarkerContainer");
    el4.setAttribute("role", "img");
    el4.setAttribute("aria-hidden", "true");
    var el5 = document.createTextNode("\n    ");
    el4.appendChild(el5);
    var el6 = document.createElement("span");
    el6.className += " _coral-Steplist-marker";
    el4.appendChild(el6);
    var el7 = document.createTextNode("\n  ");
    el4.appendChild(el7);
    el0.appendChild(el4);
    var el8 = document.createTextNode("\n  ");
    el0.appendChild(el8);
    var el9 = this["overlay"] = document.createElement("coral-tooltip");
    el9.setAttribute("tracking", "off");
    el9.setAttribute("smart", "");
    el9.setAttribute("focusonshow", "off");
    el9.setAttribute("handle", "overlay");
    el9.setAttribute("placement", "top");
    el9.setAttribute("variant", "inspect");
    el9.setAttribute("interaction", "off");
    el9.setAttribute("breadthoffset", "1");
    el0.appendChild(el9);
    var el10 = document.createTextNode("\n");
    el0.appendChild(el10);
    frag.appendChild(el0);
    var el11 = document.createTextNode("\n");
    frag.appendChild(el11);
    var el12 = this["line"] = document.createElement("span");
    el12.className += " _coral-Steplist-segment";
    el12.setAttribute("handle", "line");
    frag.appendChild(el12);
    var el13 = document.createTextNode("\n");
    frag.appendChild(el13);
    return frag;
  };

  var CLASSNAME$1x = '_coral-Steplist-item';
  /**
   @class Coral.Step
   @classdesc A Step component
   @htmltag coral-step
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var Step = Decorator( /*#__PURE__*/function (_BaseComponent) {
    _inherits(_class, _BaseComponent);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this); // Fetch or create content zone

      _this._elements = {
        label: _this.querySelector('coral-step-label') || document.createElement('coral-step-label')
      };
      template$_.call(_this._elements);
      return _this;
    }
    /**
     The label of the step.
      @type {StepLabel}
     @contentzone
     */


    _createClass(_class, [{
      key: "_isHybrid",
      value: function _isHybrid() {
        var label = this.label;
        var maxWidth = this.label.clientWidth; // Required to be able to measure full width

        label.style.position = 'relative';
        label.style.whiteSpace = 'inherit';
        label.style.display = 'inline'; // Mark it for hybrid mode

        this._labelIsHidden = label.getBoundingClientRect().width > maxWidth; // Restore defaults

        label.style.position = '';
        label.style.whiteSpace = '';
        label.style.display = '';
      }
    }, {
      key: "focus",
      value: function focus() {
        this._elements.link.focus();
      }
    }, {
      key: "blur",
      value: function blur() {
        this._elements.link.blur();
      }
      /** @private */

    }, {
      key: "_syncTabIndex",
      value: function _syncTabIndex(isInteractive) {
        // the list item itself should never include a tabindex
        this.removeAttribute('tabindex'); // when interaction is on, we enable the tabindex so users can tab into the items

        if (isInteractive) {
          this._elements.link.setAttribute('role', 'link');

          if (this.disabled) {
            this._elements.link.removeAttribute('tabindex');

            this._elements.link.setAttribute('aria-disabled', true);
          } else {
            this._elements.link.removeAttribute('aria-disabled');

            this._elements.link.setAttribute('tabindex', this.selected ? '0' : '-1');
          }
        } else {
          // when off, removing the tabindex allows the component to never get focus
          this._elements.link.removeAttribute('tabindex');

          this._elements.link.removeAttribute('role');
        }
      }
      /** @private */

    }, {
      key: "_syncSizeAndCurrentIndex",
      value: function _syncSizeAndCurrentIndex(currentStep, totalSteps) {
        this.setAttribute('aria-setsize', totalSteps);
        this.setAttribute('aria-posinset', currentStep);
      }
    }, {
      key: "connectedCallback",

      /** @ignore */
      value: function connectedCallback() {
        _get(_getPrototypeOf(_class.prototype), "connectedCallback", this).call(this);

        var overlay = this._elements.overlay; // Cannot be open by default when rendered

        overlay.removeAttribute('open'); // Restore in DOM

        if (overlay._parent) {
          overlay._parent.appendChild(overlay);
        }
      }
      /** @ignore */

    }, {
      key: "render",
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1x); // Generate a unique ID for the Step panel if one isn't already present
        // This will be used for accessibility purposes

        this.setAttribute('id', this.id || commons.getUID()); // A11y

        this.setAttribute('role', 'listitem');
        var frag = document.createDocumentFragment(); // Discard the template-created link, accessibilityLabel, stepMarkerContainer, and line if one is provided by markup

        this._elements.link = this.querySelector('[handle="link"]') || this._elements.link;
        this._elements.accessibilityLabel = this.querySelector('[handle="accessibilityLabel"]') || this._elements.accessibilityLabel;
        this._elements.stepMarkerContainer = this.querySelector('[handle="stepMarkerContainer"]') || this._elements.stepMarkerContainer;
        this._elements.line = this.querySelector('[handle="line"]') || this._elements.line; // Discard the template-created tooltip if one is provided by markup

        this._elements.overlay = this.querySelector('coral-tooltip') || this._elements.overlay; // Render main template

        frag.appendChild(this._elements.link);

        this._elements.link.appendChild(this._elements.stepMarkerContainer);

        this._elements.link.appendChild(this._elements.overlay);

        frag.appendChild(this._elements.line);
        var templateHandleNames = ['link', 'accessibilityLabel', 'stepMarkerContainer', 'overlay', 'line'];
        var label = this._elements.label; // Remove it so we can process children

        if (label.parentNode) {
          label.remove();
        }

        while (this.firstChild) {
          var child = this.firstChild;

          if (child.nodeType === Node.TEXT_NODE || child.nodeType === Node.ELEMENT_NODE && templateHandleNames.indexOf(child.getAttribute('handle')) === -1) {
            label.appendChild(child);
          } else {
            this.removeChild(child);
          }
        } // Link tooltip target


        this._elements.overlay.target = this._elements.stepMarkerContainer;
        this.appendChild(frag); // Assign the content zone so the insert function will be called

        this.label = label; // Measure hybrid potential

        this._isHybrid(); // Sync the tabIndex value an role depending on whether interaction is on.


        var stepList = this.parentElement;

        if (stepList) {
          this._syncTabIndex(stepList.interaction === StepList.interaction.ON);
        }
      }
      /** @ignore */

    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        _get(_getPrototypeOf(_class.prototype), "disconnectedCallback", this).call(this);

        var overlay = this._elements.overlay; // In case it was moved out don't forget to remove it

        if (!this.contains(overlay)) {
          overlay._parent = overlay._repositioned ? document.body : this;
          overlay.remove();
        }
      }
    }, {
      key: "label",
      get: function get() {
        return this._getContentZone(this._elements.label);
      },
      set: function set(value) {
        this._setContentZone('label', value, {
          handle: 'label',
          tagName: 'coral-step-label',
          insert: function insert(label) {
            label.classList.add('_coral-Steplist-label');

            this._elements.link.insertBefore(label, this._elements.stepMarkerContainer);
          }
        });
      }
      /**
       Whether the item is selected. When <code>true</code>, the item will appear as the active element in the
       StepList. The item must be a child of a StepList before this property is set to <code>true</code>.
        @type {Boolean}
       @default false
       @htmlattribute selected
       @htmlattributereflected
       */

    }, {
      key: "selected",
      get: function get() {
        return this._selected || false;
      },
      set: function set(value) {
        this._selected = transform.booleanAttr(value);

        this._reflectAttribute('selected', this._selected);

        this.classList.toggle('is-selected', this.selected);
        this.removeAttribute('aria-selected');

        if (this.selected) {
          this._elements.link.setAttribute('aria-current', 'step');
        } else {
          this._elements.link.removeAttribute('aria-current');
        }

        var stepList = this.parentElement;
        var realTarget; // in case the Step is selected, we need to communicate it to the panels

        if (this._selected) {
          realTarget = getTarget(this.target); // if the target was defined at the Step level, it has precedence over everything

          if (realTarget) {
            realTarget.setAttribute('selected', '');
          } // we use the target defined at the StepList level
          else if (stepList && stepList.target) {
              realTarget = getTarget(stepList.target);

              if (realTarget) {
                // we get the position of this step inside the steplist
                var currentIndex = stepList.items.getAll().indexOf(this); // we select the item with the same index

                var targetItem = (realTarget.items ? realTarget.items.getAll() : realTarget.children)[currentIndex]; // we select the item if it exists

                if (targetItem) {
                  targetItem.setAttribute('selected', '');
                }
              }
            }
        }

        this.trigger('coral-step:_selectedchanged');
      }
      /**
       Whether the item is disabled
        @type {Boolean}
       @default false
       @htmlattribute disabled
       @htmlattributereflected
       */

    }, {
      key: "disabled",
      get: function get() {
        return this._disabled || false;
      },
      set: function set(value) {
        this._disabled = transform.booleanAttr(value);

        this._reflectAttribute('disabled', this._disabled);

        this.classList.toggle('is-disabled', this.disabled);
        var stepList = this.parentElement;

        if (stepList) {
          this._syncTabIndex(stepList.interaction === StepList.interaction.ON);
        }
      }
      /**
       Reflects the <code>aria-label</code> attribute to the marker dot for cases where no visible label is provided for the Step.
       @type {?String}
       @default ''
       @htmlattribute labelled
       @htmlattributereflected
       @memberof Coral.Step#
       */

    }, {
      key: "labelled",
      get: function get() {
        return this._labelled || this.getAttribute('labelled') || this._elements.stepMarkerContainer.getAttribute('aria-label') || '';
      },
      set: function set(value) {
        this._labelled = transform.string(value);

        this._reflectAttribute('labelled', value || false);

        if (this._labelled !== '') {
          this._elements.stepMarkerContainer.setAttribute('aria-label', this._labelled);

          this._elements.stepMarkerContainer.removeAttribute('aria-hidden');
        } else {
          this._elements.stepMarkerContainer.removeAttribute('aria-label');

          if (!this.labelledBy) {
            this._elements.stepMarkerContainer.setAttribute('aria-hidden', 'true');
          }
        }
      }
      /**
       Reflects the <code>aria-labelledby</code> attribute to the marker dot for cases where no visible label is provided for the Step,
       and the Step is labelled by an external element.
       @type {?String}
       @default ''
       @htmlattribute labelledby
       @htmlattributereflected
       @memberof Coral.Step#
       */

    }, {
      key: "labelledBy",
      get: function get() {
        return this._labelledBy || this.getAttribute('labelledby') || this._elements.stepMarkerContainer.getAttribute('aria-labelledby') || '';
      },
      set: function set(value) {
        this._labelledBy = transform.string(value);

        this._reflectAttribute('labelledby', value || false);

        if (this._labelledBy !== '') {
          this._elements.stepMarkerContainer.setAttribute('aria-labelledby', this._labelledBy);

          this._elements.stepMarkerContainer.removeAttribute('aria-hidden');
        } else {
          this._elements.stepMarkerContainer.removeAttribute('aria-labelledby');

          if (!this.labelled) {
            this._elements.stepMarkerContainer.setAttribute('aria-hidden', 'true');
          }
        }
      }
      /**
       Reflects the <code>aria-describedby</code> attribute to the link element.
       @type {?String}
       @default ''
       @htmlattribute describedby
       @htmlattributereflected
       @memberof Coral.Step#
       */

    }, {
      key: "describedBy",
      get: function get() {
        return this._describedBy || this.getAttribute('describedby') || this._elements.link.getAttribute('aria-describedby') || '';
      },
      set: function set(value) {
        this._describedBy = transform.string(value);

        this._reflectAttribute('describedby', value || false);

        if (this._describedBy !== '') {
          this._elements.link.setAttribute('aria-describedby', this._describedBy);
        } else {
          this._elements.link.removeAttribute('aria-describedby');
        }
      }
      /**
       The target element that will be selected when this Step is selected. It accepts a CSS selector or a DOM element.
       If a CSS Selector is provided, the first matching element will be used.
        @type {?HTMLElement|String}
       @default null
       @htmlattribute target
       */

    }, {
      key: "target",
      get: function get() {
        return this._target || null;
      },
      set: function set(value) {
        if (value === null || typeof value === 'string' || value instanceof Node) {
          this._target = value;
          var realTarget = getTarget(this._target); // we add proper accessibility if available

          if (realTarget) {
            // creates a 2 way binding for accessibility
            this.setAttribute('aria-controls', realTarget.id);
            realTarget.setAttribute('aria-labelledby', this.id);
          }
        }
      }
      /**
       Inherited from {@link BaseComponent#trackingElement}.
       */

    }, {
      key: "trackingElement",
      get: function get() {
        return typeof this._trackingElement === 'undefined' ? // keep spaces to only 1 max and trim. this mimics native html behaviors
        (this.label || this).textContent.replace(/\s{2,}/g, ' ').trim() : this._trackingElement;
      },
      set: function set(value) {
        _set(_getPrototypeOf(_class.prototype), "trackingElement", value, this, true);
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-step-label': 'label'
        };
      }
      /** @ignore */

    }], [{
      key: "_attributePropertyMap",
      get: function get() {
        return commons.extend(_get(_getPrototypeOf(_class), "_attributePropertyMap", this), {
          labelledby: 'labelledBy',
          describedby: 'describedBy'
        });
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['selected', 'target', 'disabled', 'labelled', 'labelledby', 'describedby']);
      }
    }]);

    return _class;
  }(BaseComponent(HTMLElement)));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Step.Label
   @classdesc A Step Label
   @htmltag coral-step-label
   @return {HTMLElement}
   */
  var StepLabel = (function () {
    return document.createElement('coral-step-label');
  });

  /**
   * Copyright 2020 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var translations$l = {
    "en-US": {
      "Step List": "Step List",
      "completed: ": "completed: ",
      "current: ": "current: ",
      "not completed: ": "not completed: "
    },
    "de-DE": {
      "Step List": "Schrittliste",
      "completed: ": "abgeschlossen: ",
      "current: ": "aktuell: ",
      "not completed: ": "nicht abgeschlossen: "
    },
    "fr-FR": {
      "Step List": "Liste des étapes",
      "completed: ": "terminé : ",
      "current: ": "actuel : ",
      "not completed: ": "non terminé : "
    },
    "it-IT": {
      "Step List": "Elenco passi",
      "completed: ": "completato: ",
      "current: ": "corrente: ",
      "not completed: ": "non completato: "
    },
    "ja-JP": {
      "Step List": "手順リスト",
      "completed: ": "完了: ",
      "current: ": "現在: ",
      "not completed: ": "未完了: "
    },
    "es-ES": {
      "Step List": "Lista de pasos",
      "completed: ": "completado: ",
      "current: ": "actual: ",
      "not completed: ": "no completado: "
    },
    "ko-KR": {
      "Step List": "단계 목록",
      "completed: ": "완료됨: ",
      "current: ": "현재: ",
      "not completed: ": "미완료: "
    },
    "zh-CN": {
      "Step List": "步骤列表",
      "completed: ": "已完成: ",
      "current: ": "当前: ",
      "not completed: ": "未完成: "
    },
    "zh-TW": {
      "Step List": "步驟清單",
      "completed: ": "已完成: ",
      "current: ": "目前: ",
      "not completed: ": "未完成: "
    },
    "pt-BR": {
      "Step List": "Lista de passos",
      "completed: ": "concluído: ",
      "current: ": "atual: ",
      "not completed: ": "não concluído: "
    },
    "nl-NL": {
      "Step List": "Stappenlijst",
      "completed: ": "voltooid: ",
      "current: ": "huidige: ",
      "not completed: ": "niet voltooid: "
    },
    "da-DK": {
      "Step List": "Trin liste",
      "completed: ": "Afsluttet: ",
      "current: ": "aktuelt: ",
      "not completed: ": "Ikke afsluttet: "
    },
    "fi-FI": {
      "Step List": "Vaihe luettelo",
      "completed: ": "Valmis: ",
      "current: ": "nykyinen: ",
      "not completed: ": "Ei valmis: "
    },
    "nb-NO": {
      "Step List": "Trinn liste",
      "completed: ": "fullført: ",
      "current: ": "gjeldende: ",
      "not completed: ": "ikke fullført: "
    },
    "sv-SE": {
      "Step List": "Steg lista",
      "completed: ": "slutförd: ",
      "current: ": "aktuell: ",
      "not completed: ": "inte slutförd: "
    },
    "cs-CZ": {
      "Step List": "Seznam kroků",
      "completed: ": "dokončeno: ",
      "current: ": "aktuální: ",
      "not completed: ": "nedokončeno: "
    },
    "pl-PL": {
      "Step List": "Lista kroków",
      "completed: ": "zakończone: ",
      "current: ": "bieżący: ",
      "not completed: ": "nieukończone: "
    },
    "ru-RU": {
      "Step List": "Список шагов",
      "completed: ": "завершено: ",
      "current: ": "текущий: ",
      "not completed: ": "не завершено: "
    },
    "tr-TR": {
      "Step List": "Adım listesi",
      "completed: ": "tamamlandı: ",
      "current: ": "geçerli: ",
      "not completed: ": "tamamlanmadı: "
    }
  };

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons.extend(strings, {
    'coral-component-steplist': translations$l
  }); // Expose component on the Coral namespace

  commons._define('coral-step', Step);

  commons._define('coral-steplist', StepList);

  Step.Label = StepLabel;

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var translations$m = {
    "en-US": {
      "Select": "Select"
    },
    "fr-FR": {
      "Select": "Sélectionner"
    },
    "de-DE": {
      "Select": "Auswählen"
    },
    "it-IT": {
      "Select": "Seleziona"
    },
    "es-ES": {
      "Select": "Seleccionar"
    },
    "pt-BR": {
      "Select": "Selecionar"
    },
    "ja-JP": {
      "Select": "選択"
    },
    "ko-KR": {
      "Select": "선택"
    },
    "zh-CN": {
      "Select": "选择"
    },
    "zh-TW": {
      "Select": "選取"
    },
    "nl-NL": {
      "Select": "Selecteren"
    },
    "da-DK": {
      "Select": "Vælg"
    },
    "fi-FI": {
      "Select": "Valitse"
    },
    "nb-NO": {
      "Select": "Velg"
    },
    "sv-SE": {
      "Select": "Välj"
    },
    "cs-CZ": {
      "Select": "Vybrat"
    },
    "pl-PL": {
      "Select": "Wybierz"
    },
    "ru-RU": {
      "Select": "Выберите"
    },
    "tr-TR": {
      "Select": "Seç"
    }
  };

  var template$$ = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["input"] = document.createElement("input");
    el0.setAttribute("type", "checkbox");
    el0.setAttribute("handle", "input");
    el0.className += " _coral-ToggleSwitch-input";
    el0.id = data_0["commons"]["getUID"]();
    frag.appendChild(el0);
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    var el2 = this["switch"] = document.createElement("span");
    el2.setAttribute("handle", "switch");
    el2.className += " _coral-ToggleSwitch-switch";
    frag.appendChild(el2);
    var el3 = document.createTextNode("\n");
    frag.appendChild(el3);
    var el4 = this["labelWrapper"] = document.createElement("label");
    el4.className += " _coral-ToggleSwitch-label";
    el4.setAttribute("for", this["input"]["id"]);
    el4.setAttribute("handle", "labelWrapper");
    var el5 = document.createTextNode("\n  ");
    el4.appendChild(el5);
    var el6 = this["screenReaderOnly"] = document.createElement("span");
    el6.className += " u-coral-screenReaderOnly";
    el6.setAttribute("handle", "screenReaderOnly");
    el6.textContent = data_0["i18n"]["get"]('Select');
    el4.appendChild(el6);
    var el7 = document.createTextNode("\n");
    el4.appendChild(el7);
    frag.appendChild(el4);
    var el8 = document.createTextNode("\n");
    frag.appendChild(el8);
    return frag;
  };

  var CLASSNAME$1y = '_coral-ToggleSwitch';
  /**
   @class Coral.Switch
   @classdesc A Switch component is a toggle form field similar to a Checkbox component.
   @htmltag coral-switch
   @extends {HTMLElement}
   @extends {BaseComponent}
   @extends {BaseFormField}
   */

  var Switch = Decorator( /*#__PURE__*/function (_BaseFormField) {
    _inherits(_class, _BaseFormField);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this); // Make sure the events from the FormField are attached

      _this._delegateEvents(commons.extend(_this._events, {
        'capture:focus ._coral-ToggleSwitch-input': '_onFocus',
        'capture:blur ._coral-ToggleSwitch-input': '_onBlur'
      })); // Prepare templates


      _this._elements = {
        // Try to find the label content zone
        label: _this.querySelector('coral-switch-label') || document.createElement('coral-switch-label')
      };
      template$$.call(_this._elements, {
        commons: commons,
        i18n: i18n
      }); // Pre-define labellable element

      _this._labellableElement = _this._elements.input; // Check if the label is empty whenever we get a mutation

      _this._observer = new MutationObserver(_this._hideLabelIfEmpty.bind(_assertThisInitialized(_this))); // Watch for changes to the label element's children

      _this._observer.observe(_this._elements.labelWrapper, {
        // Catch changes to childList
        childList: true,
        // Catch changes to textContent
        characterData: true,
        // Monitor any child node
        subtree: true
      });

      return _this;
    }
    /**
     Whether the switch is on or off.
      @type {Boolean}
     @default false
     @htmlattribute checked
     @htmlattributereflected
     @emits {change}
     */


    _createClass(_class, [{
      key: "_hideLabelIfEmpty",

      /**
       Hide the label if it's empty.
        @ignore
       */
      value: function _hideLabelIfEmpty() {
        var label = this._elements.label; // If it's empty and has no non-textnode children, hide the label

        var hiddenValue = !(label.children.length === 0 && label.textContent.replace(/\s*/g, '') === ''); // Toggle the screen reader text

        this._elements.labelWrapper.style.margin = !hiddenValue ? '0' : '';
        this._elements.screenReaderOnly.hidden = hiddenValue || this.labelled;
      }
    }, {
      key: "_onFocus",
      value: function _onFocus() {
        this._elements.input.classList.add('focus-ring');
      }
    }, {
      key: "_onBlur",
      value: function _onBlur() {
        this._elements.input.classList.remove('focus-ring');
      }
    }, {
      key: "clear",

      /**
       Inherited from {@link BaseFormField#clear}.
       */
      value: function clear() {
        this.checked = false;
      }
      /**
       Inherited from {@link BaseFormField#reset}.
       */

    }, {
      key: "reset",
      value: function reset() {
        this.checked = this._initialCheckedState;
      }
      /** @ignore */

    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1y); // Create a fragment

        var frag = document.createDocumentFragment();
        var templateHandleNames = ['input', 'switch', 'labelWrapper']; // Render the template

        frag.appendChild(this._elements.input);
        frag.appendChild(this._elements.switch);
        frag.appendChild(this._elements.labelWrapper);
        var label = this._elements.label; // Remove it so we can process children

        if (label && label.parentNode) {
          label.parentNode.removeChild(label);
        } // Clean up


        while (this.firstChild) {
          var child = this.firstChild; // Only works if all root template elements have a handle attribute

          if (child.nodeType === Node.TEXT_NODE || child.nodeType === Node.ELEMENT_NODE && templateHandleNames.indexOf(child.getAttribute('handle')) === -1) {
            // Add non-template elements to the content
            label.appendChild(child);
          } else {
            // Remove anything else
            this.removeChild(child);
          }
        } // Append the fragment to the component


        this.appendChild(frag); // Assign the content zones, moving them into place in the process

        this.label = label; // Cache the initial checked state of the switch (in order to implement reset)

        this._initialCheckedState = this.checked; // Check if we need to hide the label
        // We must do this because IE does not catch mutations when nodes are not in the DOM

        this._hideLabelIfEmpty();
      }
    }, {
      key: "checked",
      get: function get() {
        return this._checked || false;
      },
      set: function set(value) {
        this._checked = transform.booleanAttr(value);

        this._reflectAttribute('checked', this._checked);

        this._elements.input.checked = this._checked;
      }
      /**
       The switch's label element.
        @type {SwitchLabel}
       @contentzone
       */

    }, {
      key: "label",
      get: function get() {
        return this._getContentZone(this._elements.label);
      },
      set: function set(value) {
        this._setContentZone('label', value, {
          handle: 'label',
          tagName: 'coral-switch-label',
          insert: function insert(label) {
            this._elements.labelWrapper.appendChild(label);
          }
        });
      }
      /**
       Name used to submit the data in a form.
       @type {String}
       @default ""
       @htmlattribute name
       @htmlattributereflected
       */

    }, {
      key: "name",
      get: function get() {
        return this._elements.input.name;
      },
      set: function set(value) {
        this._reflectAttribute('name', value);

        this._elements.input.name = value;
      }
      /**
       The value that will be submitted when the checkbox is checked. Changing this value will not trigger an event.
        @type {String}
       @default "on"
       @htmlattribute value
       */

    }, {
      key: "value",
      get: function get() {
        return this._elements.input.value || 'on';
      },
      set: function set(value) {
        this._elements.input.value = value;
      }
      /**
       Whether this field is disabled or not.
       @type {Boolean}
       @default false
       @htmlattribute disabled
       @htmlattributereflected
       */

    }, {
      key: "disabled",
      get: function get() {
        return this._disabled || false;
      },
      set: function set(value) {
        this._disabled = transform.booleanAttr(value);

        this._reflectAttribute('disabled', this._disabled);

        this[this._disabled ? 'setAttribute' : 'removeAttribute']('aria-disabled', this._disabled);
        this.classList.toggle('is-disabled', this._disabled);
        this._elements.input.disabled = this._disabled;
      }
      /**
       Whether this field is required or not.
       @type {Boolean}
       @default false
       @htmlattribute required
       @htmlattributereflected
       */

    }, {
      key: "required",
      get: function get() {
        return this._required || false;
      },
      set: function set(value) {
        this._required = transform.booleanAttr(value);

        this._reflectAttribute('required', this._required);

        this._elements.input.required = this._required;
      }
      /**
       Whether this field is readOnly or not. Indicating that the user cannot modify the value of the control.
       @type {Boolean}
       @default false
       @htmlattribute readonly
       @htmlattributereflected
       */

    }, {
      key: "readOnly",
      get: function get() {
        return this._readOnly || false;
      },
      set: function set(value) {
        this._readOnly = transform.booleanAttr(value);

        this._reflectAttribute('readonly', this._readOnly);

        this.classList.toggle('is-readOnly', this._readOnly);
        this._elements.input.tabIndex = this._readOnly ? -1 : 0;
      }
      /**
       Inherited from {@link BaseFormField#labelled}.
       */

    }, {
      key: "labelled",
      get: function get() {
        return _get(_getPrototypeOf(_class.prototype), "labelled", this);
      },
      set: function set(value) {
        _set(_getPrototypeOf(_class.prototype), "labelled", value, this, true);

        this._hideLabelIfEmpty();
      }
      /*
       Indicates to the formField that the 'checked' property needs to be set in this component.
        @protected
       */

    }, {
      key: "_componentTargetProperty",
      get: function get() {
        return 'checked';
      }
      /*
       Indicates to the formField that the 'checked' property has to be extracted from the event.
        @protected
       */

    }, {
      key: "_eventTargetProperty",
      get: function get() {
        return 'checked';
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-switch-label': 'label'
        };
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['checked']);
      }
    }]);

    return _class;
  }(BaseFormField(BaseComponent(HTMLElement))));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Switch.Label
   @classdesc The Switch label
   @htmltag coral-switch-label
   @return {HTMLElement}
   */
  var SwitchLabel = (function () {
    return document.createElement('coral-switch-label');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons.extend(strings, {
    'coral-component-switch': translations$m
  }); // Expose component on the Coral namespace

  commons._define('coral-switch', Switch);

  Switch.Label = SwitchLabel;

  /**
   * Copyright 2020 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  var translations$n = {
    "en-US": {
      "Select": "Select",
      "Select All": "Select All",
      "sorted by column {0}, in ascending order": "sorted by column {0} in ascending order",
      "sorted by column {0}, in descending order": "sorted by column {0} in descending order",
      ", checked": ", checked",
      ", unchecked": ", unchecked"
    },
    "de-DE": {
      "Select": "Auswählen",
      "Select All": "Alles auswählen",
      "sorted by column {0}, in ascending order": "Sortiert nach Spalte {0} in aufsteigender Reihenfolge",
      "sorted by column {0}, in descending order": "Sortiert nach Spalte {0} in absteigender Reihenfolge",
      ", checked": ", markiert",
      ", unchecked": ", nicht markiert"
    },
    "fr-FR": {
      "Select": "Sélectionner",
      "Select All": "Sélectionner tout",
      "sorted by column {0}, in ascending order": "Trié par colonne {0} dans l’ordre ascendant",
      "sorted by column {0}, in descending order": "Trié par colonne {0} dans l’ordre décroissant",
      ", checked": ", cochée",
      ", unchecked": ", pas cochée"
    },
    "it-IT": {
      "Select": "Seleziona",
      "Select All": "Seleziona tutto",
      "sorted by column {0}, in ascending order": "Ordinato per colonna {0} in ordine crescente",
      "sorted by column {0}, in descending order": "Ordinato per colonna {0} in ordine decrescente",
      ", checked": ", selezionata",
      ", unchecked": ", non selezionata"
    },
    "ja-JP": {
      "Select": "選択",
      "Select All": "すべてを選択",
      "sorted by column {0}, in ascending order": "列 {0} で昇順で並べ替え",
      "sorted by column {0}, in descending order": "列 {0} で降順に並べ替え",
      ", checked": "、チェック",
      ", unchecked": "、未チェック"
    },
    "es-ES": {
      "Select": "Seleccionar",
      "Select All": "Seleccionar todos",
      "sorted by column {0}, in ascending order": "Ordenado por columna {0} en orden ascendente",
      "sorted by column {0}, in descending order": "Ordenado por columna {0} en orden descendente",
      ", checked": ", marcada",
      ", unchecked": ", desmarcada"
    },
    "ko-KR": {
      "Select": "선택",
      "Select All": "모두 선택",
      "sorted by column {0}, in ascending order": "오름차순으로 열 {0} 정렬",
      "sorted by column {0}, in descending order": "내림차순으로 {0} 열별로 정렬",
      ", checked": ", 선택됨",
      ", unchecked": ", 선택되지 않은"
    },
    "zh-CN": {
      "Select": "选择",
      "Select All": "全选",
      "sorted by column {0}, in ascending order": "按列{0}按升序排序r",
      "sorted by column {0}, in descending order": "按列{0}按降序排序",
      ", checked": "，选中",
      ", unchecked": "，未选中"
    },
    "zh-TW": {
      "Select": "選取",
      "Select All": "全選",
      "sorted by column {0}, in ascending order": "按列{0}按昇冪排序",
      "sorted by column {0}, in descending order": "按列{0}按降冪排序",
      ", checked": "，選中",
      ", unchecked": "，未選中"
    },
    "pt-BR": {
      "Select": "Selecionar",
      "Select All": "Selecionar tudo",
      "sorted by column {0}, in ascending order": "Classificado por coluna {0} em ordem ascendente",
      "sorted by column {0}, in descending order": "Classificado por coluna {0} em ordem descendente",
      ", checked": ", marcada",
      ", unchecked": ", desmarcada"
    },
    "nl-NL": {
      "Select": "Selecteren",
      "Select All": "Alles selecteren",
      "sorted by column {0}, in ascending order": "Gesorteerd op kolom {0} in oplopende volgorde",
      "sorted by column {0}, in descending order": "Gesorteerd op kolom {0} in aflopende volgorde",
      ", checked": ", geselecteerd",
      ", unchecked": ", neit geselecteerd"
    },
    "da-DK": {
      "Select": "Vælg",
      "Select All": "Vælg alle",
      "sorted by column {0}, in ascending order": "Sorteret efter kolonne {0} i stigende rækkefølge",
      "sorted by column {0}, in descending order": "Sorteret efter kolonne {0} i faldende rækkefølge",
      ", checked": ", valgte",
      ", unchecked": ", ikke valgt"
    },
    "fi-FI": {
      "Select": "Valitse",
      "Select All": "Valitse kaikki",
      "sorted by column {0}, in ascending order": "Lajiteltu sarakkeen mukaan {0} nousevaan järjestykseen",
      "sorted by column {0}, in descending order": "Lajiteltu sarakkeen mukaan {0} laskevassa järjestyksessä",
      ", checked": ", valittu",
      ", unchecked": ", valittuna"
    },
    "nb-NO": {
      "Select": "Velg",
      "Select All": "Velg alle",
      "sorted by column {0}, in ascending order": "Sortert etter kolonne {0} i stigende rekkefølge",
      "sorted by column {0}, in descending order": "Sortert etter kolonne {0} i synkende rekkefølge",
      ", checked": ", valgt",
      ", unchecked": ", ikke valgt"
    },
    "sv-SE": {
      "Select": "Markera",
      "Select All": "Markera allt",
      "sorted by column {0}, in ascending order": "Sorterat efter kolumn {0} i stigande ordning",
      "sorted by column {0}, in descending order": "Sorterat efter kolumn {0} i fallande ordning",
      ", checked": ", markerad",
      ", unchecked": ", avmarkerad"
    },
    "cs-CZ": {
      "Select": "Vybrat",
      "Select All": "Vybrat vše",
      "sorted by column {0}, in ascending order": "Seřazeno podle sloupcových {0} ve vzestupném pořadí",
      "sorted by column {0}, in descending order": "Seřazeno podle sloupcových {0} v sestupném pořadí",
      ", checked": ", vybráno",
      ", unchecked": ", není vybráno"
    },
    "pl-PL": {
      "Select": "Zaznacz",
      "Select All": "Zaznacz wszystko",
      "sorted by column {0}, in ascending order": "Posortowane według kolumny {0} w porządku rosnącym",
      "sorted by column {0}, in descending order": "Posortowane według kolumny {0} w porządku malejącym",
      ", checked": ", zaznaczone",
      ", unchecked": ", nie zaznaczone"
    },
    "ru-RU": {
      "Select": "Выбрать",
      "Select All": "Выбрать все",
      "sorted by column {0}, in ascending order": "Сортировка по столбе {0} в порядке возрастания",
      "sorted by column {0}, in descending order": "Сортировка по колонке {0} в порядке убывания",
      ", checked": ", выбранный",
      ", unchecked": ", неотобранный"
    },
    "tr-TR": {
      "Select": "Seç",
      "Select All": "Tümünü Seç",
      "sorted by column {0}, in ascending order": "Artan sırada {0} sütununa göre sıralanmış",
      "sorted by column {0}, in descending order": "Azalan sırada {0} sütununa göre sıralanmış",
      ", checked": ", seçilmiş",
      ", unchecked": ", seçilmemiş"
    }
  };

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /** @ignore */
  var isTableHeaderCell = function isTableHeaderCell(node) {
    return node.nodeName === 'TH' && node.getAttribute('is') === 'coral-table-headercell';
  };
  /** @ignore */


  var isTableCell = function isTableCell(node) {
    return node.nodeName === 'TD' && node.getAttribute('is') === 'coral-table-cell';
  };
  /** @ignore */


  var isTableRow = function isTableRow(node) {
    return node.nodeName === 'TR' && node.getAttribute('is') === 'coral-table-row';
  };
  /** @ignore */


  var isTableBody = function isTableBody(node) {
    return node.nodeName === 'TBODY' && node.getAttribute('is') === 'coral-table-body';
  };
  /** @ignore */


  var getIndexOf = function getIndexOf(el) {
    var parent = el.parentNode;

    if (!parent) {
      return -1;
    }

    return Array.prototype.indexOf.call(parent.children, el);
  };
  /** @ignore */


  var getSiblingsOf = function getSiblingsOf(el, selector, type) {
    var stack = []; // Returns siblings of el

    if (!type) {
      ['previousElementSibling', 'nextElementSibling'].forEach(function (direction) {
        var sibling = el;

        while (sibling[direction]) {
          sibling = sibling[direction];

          if (sibling.matches(selector)) {
            stack.push(sibling);
          }
        }
      });
    } else {
      var direction = type.indexOf('next') === 0 ? 'nextElementSibling' : 'previousElementSibling'; // All following siblings of el up to but not including the element matched by the selector

      if (type.indexOf('Until') !== -1) {
        var matches = function matches() {
          if (typeof selector === 'string') {
            return el[direction].matches(selector);
          }

          return el[direction] === selector;
        };

        while (el[direction] && !matches()) {
          stack.push(el = el[direction]);
        }
      } // All following siblings of el filtered by a selector.
      else if (type.indexOf('All') !== -1) {
          while (el[direction]) {
            el = el[direction];

            if (el.matches(selector)) {
              stack.push(el);
            }
          }
        } // Returns the sibling only if it matches that selector.
        else {
            var sibling = el[direction];
            return sibling && sibling.matches(selector) ? sibling : null;
          }
    }

    return stack;
  };
  /** @ignore */


  var listToArray$1 = function listToArray(list) {
    var res = [];

    for (var i = 0, listCount = res.length = list.length; i < listCount; i++) {
      res[i] = list[i];
    }

    return res;
  };
  /** @ignore */


  var getColumns = function getColumns(colgroup) {
    return listToArray$1(colgroup.querySelectorAll('col[is="coral-table-column"]'));
  };
  /** @ignore */


  var getRows = function getRows(sections) {
    var rows = [];
    sections.forEach(function (section) {
      if (section) {
        rows = rows.concat(listToArray$1(section.querySelectorAll('tr[is="coral-table-row"]')));
      }
    });
    return rows;
  };
  /** @ignore */


  var getCells = function getCells(row) {
    return listToArray$1(row.querySelectorAll('td[is="coral-table-cell"], th[is="coral-table-headercell"]'));
  };
  /** @ignore */


  var getContentCells = function getContentCells(row) {
    return listToArray$1(row.querySelectorAll('td[is="coral-table-cell"]'));
  };
  /** @ignore */


  var getHeaderCells = function getHeaderCells(row) {
    return listToArray$1(row.querySelectorAll('th[is="coral-table-headercell"]'));
  };
  /** @ignore */


  var getCellByIndex = function getCellByIndex(row, index) {
    return getCells(row).filter(function (cell) {
      return getIndexOf(cell) === index;
    })[0] || null;
  };
  /**
   Enumeration for {@link TableHead}, {@link TableBody} and {@link TableFoot} divider values.

   @typedef {Object} TableSectionDividerEnum

   @property {String} NONE
   No divider.
   @property {String} ROW
   Row divider.
   @property {String} COLUMN
   Column divider.
   @property {String} CELL
   Row and Column divider.
   */


  var divider = {
    NONE: 'none',
    ROW: 'row',
    COLUMN: 'column',
    CELL: 'cell'
  };
  /**
   Enumeration for {@link TableColumn} alignment options.

   @typedef {Object} TableColumnAlignmentEnum

   @property {String} LEFT
   Left alignment.
   @property {String} CENTER
   Center alignment.
   @property {String} RIGHT
   Right alignment.
   */

  var alignment = {
    LEFT: 'left',
    CENTER: 'center',
    RIGHT: 'right'
  };

  var CLASSNAME$1z = '_coral-Table-column';
  /**
   Enumeration for {@link TableColumn} sortable direction options.

   @typedef {Object} TableColumnSortableDirectionEnum

   @property {String} DEFAULT
   Default. No sorting applied.
   @property {String} ASCENDING
   Ascending sort.
   @property {String} DESCENDING
   Descending sort.
   */

  var sortableDirection = {
    DEFAULT: 'default',
    ASCENDING: 'ascending',
    DESCENDING: 'descending'
  };
  /**
   Enumeration for {@link TableColumn} sortable type options.

   @typedef {Object} TableColumnSortableTypeEnum

   @property {String} ALPHANUMERIC
   Alphanumeric type. If sorting is based on {@link TableCell#value}, use {String}.
   @property {String} NUMBER
   Number type. If sorting is based on {@link TableCell#value}, use {Number}.
   @property {String} DATE
   Date type. If sorting is based on {@link TableCell#value}, use {Date} in milliseconds.
   @property {String} CUSTOM
   Custom type. Sorting is based on user defined sorting.
   */

  var sortableType = {
    ALPHANUMERIC: 'alphanumeric',
    NUMBER: 'number',
    DATE: 'date',
    CUSTOM: 'custom'
  };
  /**
   @class Coral.Table.Column
   @classdesc A Table column component
   @htmltag coral-table-column
   @htmlbasetag col
   @extends {HTMLTableColElement}
   @extends {BaseComponent}
   */

  var TableColumn = Decorator( /*#__PURE__*/function (_BaseComponent) {
    _inherits(_class, _BaseComponent);

    var _super = _createSuper(_class);

    function _class() {
      _classCallCheck(this, _class);

      return _super.apply(this, arguments);
    }

    _createClass(_class, [{
      key: "_sort",

      /** @private */
      value: function _sort() {
        var newSortableDirection;

        if (this.sortableDirection === sortableDirection.DEFAULT) {
          newSortableDirection = sortableDirection.ASCENDING;
        } else if (this.sortableDirection === sortableDirection.ASCENDING) {
          newSortableDirection = sortableDirection.DESCENDING;
        } else if (this.sortableDirection === sortableDirection.DESCENDING) {
          newSortableDirection = sortableDirection.DEFAULT;
        }

        this.trigger('coral-table-column:_beforecolumnsort', {
          newSortableDirection: newSortableDirection
        });
      }
      /** @private */

    }, {
      key: "_doSort",
      value: function _doSort(onInitialization) {
        this.trigger('coral-table-column:_sort', {
          onInitialization: onInitialization,
          sortableDirection: sortableDirection,
          sortableType: sortableType
        });
      }
      /**
       Returns {@link TableColumn} sortable direction options.
        @return {TableColumnSortableDirectionEnum}
       */

    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1z); // Default reflected attributes

        if (!this._sortableType) {
          this.sortableType = sortableType.ALPHANUMERIC;
        }

        if (!this._sortableDirection) {
          this.sortableDirection = sortableDirection.DEFAULT;
        }

        if (!this._alignment) {
          this.alignment = alignment.LEFT;
        }
      }
      /**
       Triggered when {@link TableColumn#alignment} changed.
        @typedef {CustomEvent} coral-table-column:_alignmentchanged
        @private
       */

      /**
       Triggered when {@link TableColumn#fixedWidth} changed.
        @typedef {CustomEvent} coral-table-column:_fixedwidthchanged
        @private
       */

      /**
       Triggered when {@link TableColumn#orderable} changed.
        @typedef {CustomEvent} coral-table-column:_orderablechanged
        @private
       */

      /**
       Triggered when {@link TableColumn#sortable} changed.
        @typedef {CustomEvent} coral-table-column:_sortablechanged
        @private
       */

      /**
       Triggered when {@link TableColumn#sortableDirection} changed.
        @typedef {CustomEvent} coral-table-column:_sortabledirectionchanged
        @private
       */

      /**
       Triggered when {@link TableColumn#hidden} changed.
        @typedef {CustomEvent} coral-table-column:_hiddenchanged
        @private
       */

      /**
       Triggered before {@link TableColumn#sortableDirection} changed.
        @typedef {CustomEvent} coral-table-column:_beforecolumnsort
        @private
       */

      /**
       Triggered when {@link TableColumn#sortableDirection} changed.
        @typedef {CustomEvent} coral-table-column:_sort
        @private
       */

    }, {
      key: "alignment",

      /**
       The column cells alignment. The alignment should take the {@link i18n} configuration into account.
        @type {String}
       @default TableColumnAlignmentEnum.LEFT
       @htmlattribute alignment
       @htmlattributereflected
       */
      get: function get() {
        return this._alignment || alignment.LEFT;
      },
      set: function set(value) {
        var _this = this;

        var oldValue = this._alignment;
        value = transform.string(value).toLowerCase();
        this._alignment = validate.enumeration(alignment)(value) && value || alignment.LEFT;

        this._reflectAttribute('alignment', this._alignment); // Don't trigger on initialization if alignment is LEFT to improve performance


        if (!(typeof oldValue === 'undefined' && this._alignment === alignment.LEFT)) {
          window.requestAnimationFrame(function () {
            _this.trigger('coral-table-column:_alignmentchanged');
          });
        }
      }
      /**
       Whether the column has a fixed width.
        @type {Boolean}
       @default false
       @htmlattribute fixedwidth
       @htmlattributereflected
       */

    }, {
      key: "fixedWidth",
      get: function get() {
        return this._fixedWidth || false;
      },
      set: function set(value) {
        var _this2 = this;

        this._fixedWidth = transform.booleanAttr(value);

        this._reflectAttribute('fixedwidth', this._fixedWidth);

        window.requestAnimationFrame(function () {
          _this2.trigger('coral-table-column:_fixedwidthchanged');
        });
      }
      /**
       Whether the column is hidden.
        @type {Boolean}
       @default false
       @htmlattribute hidden
       @htmlattributereflected
       */

    }, {
      key: "hidden",
      get: function get() {
        return this._hidden || false;
      },
      set: function set(value) {
        var _this3 = this;

        this._hidden = transform.booleanAttr(value);

        this._reflectAttribute('hidden', this._hidden);

        window.requestAnimationFrame(function () {
          _this3.trigger('coral-table-column:_hiddenchanged');
        });
      }
      /**
       Whether the table column is orderable.
       Note that this does not affect the underlying data, only presentation.
        @type {Boolean}
       @default false
       @htmlattribute orderable
       @htmlattributereflected
       */

    }, {
      key: "orderable",
      get: function get() {
        return this._orderable || false;
      },
      set: function set(value) {
        var _this4 = this;

        this._orderable = transform.booleanAttr(value);

        this._reflectAttribute('orderable', this._orderable);

        window.requestAnimationFrame(function () {
          _this4.trigger('coral-table-column:_orderablechanged');
        });
      }
      /**
       Whether the column is sortable by user interaction.
        @type {Boolean}
       @default false
       @htmlattribute sortable
       @htmlattributereflected
       */

    }, {
      key: "sortable",
      get: function get() {
        return this._sortable || false;
      },
      set: function set(value) {
        var _this5 = this;

        this._sortable = transform.booleanAttr(value);

        this._reflectAttribute('sortable', this._sortable);

        window.requestAnimationFrame(function () {
          _this5.trigger('coral-table-column:_sortablechanged');
        });
      }
      /**
       The sorting type. See {@link TableColumnSortableTypeEnum}. If setting to <code>custom</code>, columns won't sort
       based on the default table sorting.
       Instead, a custom sorting can be performed when triggered by user interaction. This can be defined by listening to
       the {@link coral-table:beforecolumnsort} event.
        @type {String}
       @default TableColumnSortableTypeEnum.ALPHANUMERIC
       @htmlattribute sortabletype
       @htmlattributereflected
       */

    }, {
      key: "sortableType",
      get: function get() {
        return this._sortableType || sortableType.ALPHANUMERIC;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        this._sortableType = validate.enumeration(sortableType)(value) && value || sortableType.ALPHANUMERIC;

        this._reflectAttribute('sortabletype', this._sortableType);
      }
      /**
       The sorting direction. Sorts the column cells based on {@link TableCell#value}.
       If not present, the sort is based on the cell text content. See {@link TableColumnSortableDirectionEnum}.
        @type {String}
       @default TableColumnSortableDirectionEnum.DEFAULT
       @htmlattribute sortabledirection
       @htmlattributereflected
       */

    }, {
      key: "sortableDirection",
      get: function get() {
        return this._sortableDirection || sortableDirection.DEFAULT;
      },
      set: function set(value) {
        var _this6 = this;

        value = transform.string(value).toLowerCase();
        this._sortableDirection = validate.enumeration(sortableDirection)(value) && value || sortableDirection.DEFAULT;

        this._reflectAttribute('sortabledirection', this._sortableDirection); // Prevent sorting if unnecessary


        if (!this._preventSort) {
          this._doSort();

          window.requestAnimationFrame(function () {
            _this6.trigger('coral-table-column:_sortabledirectionchanged');
          });
        }
      }
    }], [{
      key: "sortableDirection",
      get: function get() {
        return sortableDirection;
      }
      /**
       Returns {@link TableColumn} sortable type options.
        @return {TableColumnSortableTypeEnum}
       */

    }, {
      key: "sortableType",
      get: function get() {
        return sortableType;
      }
      /**
       Returns {@link TableColumn} alignment options.
        @return {TableColumnAlignmentEnum}
       */

    }, {
      key: "alignment",
      get: function get() {
        return alignment;
      }
    }, {
      key: "_attributePropertyMap",
      get: function get() {
        return commons.extend(_get(_getPrototypeOf(_class), "_attributePropertyMap", this), {
          fixedwidth: 'fixedWidth',
          sortabletype: 'sortableType',
          sortabledirection: 'sortableDirection'
        });
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['fixedwidth', 'hidden', 'alignment', 'orderable', 'sortable', 'sortabletype', 'sortabledirection']);
      }
    }]);

    return _class;
  }(BaseComponent(HTMLTableColElement)));

  var CLASSNAME$1A = '_coral-Table-cell';
  /**
   @class Coral.Table.Cell
   @classdesc A Table cell component
   @htmltag coral-table-cell
   @htmlbasetag td
   @extends {HTMLTableCellElement}
   @extends {BaseComponent}
   */

  var TableCell = Decorator( /*#__PURE__*/function (_BaseComponent) {
    _inherits(_class, _BaseComponent);

    var _super = _createSuper(_class);

    function _class() {
      _classCallCheck(this, _class);

      return _super.apply(this, arguments);
    }

    _createClass(_class, [{
      key: "_setHandle",

      /** @private */
      value: function _setHandle(handle) {
        var _this = this;

        requestAnimationFrame(function () {
          // Specify handle directly on the cell if none found
          if (!_this.querySelector("[".concat(handle, "]"))) {
            _this.setAttribute(handle, '');
          }

          _this._syncAriaSelectedState();

          _this._syncSelectHandle();
        });
      }
      /** @private */

    }, {
      key: "_getHandle",
      value: function _getHandle(handle) {
        return this.hasAttribute(handle) ? this : this.querySelector("[".concat(handle, "]"));
      }
      /** @private */

    }, {
      key: "_toggleSelectable",
      value: function _toggleSelectable(selectable) {
        if (selectable) {
          this._setHandle('coral-table-cellselect');
        } else {
          // Remove the handle
          this.removeAttribute('coral-table-cellselect'); // Clear selection

          this.selected = false;
        }

        this._syncAriaSelectedState();
      }
      /** @private */

    }, {
      key: "_syncAriaSelectedState",
      value: function _syncAriaSelectedState() {
        this.classList.toggle('is-selected', this.selected);

        if (this._getHandle('coral-table-cellselect')) {
          this.setAttribute('aria-selected', this.selected);
        } else {
          this.removeAttribute('aria-selected');
        }
      }
      /** @private */

    }, {
      key: "_syncSelectHandle",
      value: function _syncSelectHandle() {
        // Check/uncheck the select handle
        var selectHandle = this.querySelector('coral-checkbox');

        if (selectHandle) {
          selectHandle[this.selected ? 'setAttribute' : 'removeAttribute']('checked', '');
        }
      }
      /** @ignore */

    }, {
      key: "attributeChangedCallback",

      /** @ignore */
      value: function attributeChangedCallback(name, oldValue, value) {
        if (name === '_selectable') {
          this._toggleSelectable(value !== null);
        } else {
          _get(_getPrototypeOf(_class.prototype), "attributeChangedCallback", this).call(this, name, oldValue, value);
        }
      }
      /** @ignore */

    }, {
      key: "render",
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1A);
        this.id = this.id || commons.getUID();
      }
      /**
       Triggered before {@link TableCell#selected} is changed.
        @typedef {CustomEvent} coral-table-cell:_beforeselectedchanged
        @private
       */

      /**
       Triggered when {@link TableCell#selected} changed.
        @typedef {CustomEvent} coral-table-cell:_selectedchanged
        @private
       */

    }, {
      key: "content",
      // @compat
      get: function get() {
        return this;
      },
      set: function set(value) {
        // Support configs
        if (_typeof(value) === 'object') {
          for (var prop in value) {
            /** @ignore */
            this[prop] = value[prop];
          }
        }
      }
      /**
       Whether the table cell is selected.
        @type {Boolean}
       @default false
       @htmlattribute selected
       @htmlattributereflected
       */

    }, {
      key: "selected",
      get: function get() {
        return this._selected || false;
      },
      set: function set(value) {
        // Prevent selection if disabled
        if (this.hasAttribute('coral-table-cellselect') && this.hasAttribute('disabled') || this.querySelector('[coral-table-cellselect][disabled]')) {
          return;
        }

        this.trigger('coral-table-cell:_beforeselectedchanged');
        this._selected = transform.booleanAttr(value);

        this._reflectAttribute('selected', this._selected);

        this.trigger('coral-table-cell:_selectedchanged');

        this._syncAriaSelectedState();

        this._syncSelectHandle();
      }
      /**
       The cell's value. It is used to compare cells during a column sort. If not set, the sorting will be performed on the
       cell content. The content will be parse accordingly based on the column's <code>sortabletype</code> property.
        @type {String}
       @default ""
       @htmlattribute value
       @htmlattributereflected
       */

    }, {
      key: "value",
      get: function get() {
        return this.getAttribute('value') || '';
      },
      set: function set(value) {
        this.setAttribute('value', transform.string(value));
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['selected', '_selectable']);
      }
    }]);

    return _class;
  }(BaseComponent(HTMLTableCellElement)));

  var template$10 = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["accessibilityState"] = document.createElement("div");
    el0.setAttribute("handle", "accessibilityState");
    el0.className += " u-coral-screenReaderOnly _coral-Table-row-accessibilityState";
    el0.setAttribute("aria-hidden", "true");
    el0.id = data_0["commons"]["getUID"]();
    frag.appendChild(el0);
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    return frag;
  };

  var CLASSNAME$1B = '_coral-Table-row';
  /**
   @class Coral.Table.Row
   @classdesc A Table row component
   @htmltag coral-table-row
   @htmlbasetag tr
   @extends {HTMLTableRowElement}
   @extends {BaseComponent}
   */

  var TableRow = Decorator( /*#__PURE__*/function (_BaseComponent) {
    _inherits(_class, _BaseComponent);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this); // Templates

      _this._elements = {};
      template$10.call(_this._elements, {
        commons: commons
      }); // Required for coral-table-row:change event

      _this._oldSelection = []; // Events

      _this._delegateEvents({
        // Private
        'coral-table-cell:_beforeselectedchanged': '_onBeforeCellSelectionChanged',
        'coral-table-cell:_selectedchanged': '_onCellSelectionChanged'
      }); // Initialize content MO


      _this._observer = new MutationObserver(_this._handleMutations.bind(_assertThisInitialized(_this)));

      _this._observer.observe(_assertThisInitialized(_this), {
        childList: true
      });

      return _this;
    }
    /**
     Whether the table row is locked.
      @type {Boolean}
     @default false
     @htmlattribute locked
     @htmlattributereflected
     */


    _createClass(_class, [{
      key: "_triggerChangeEvent",
      value: function _triggerChangeEvent() {
        var selectedItems = this.selectedItems;
        this.trigger('coral-table-row:_change', {
          oldSelection: this._oldSelection,
          selection: selectedItems
        });
        this._oldSelection = selectedItems;
      }
      /** @private */

    }, {
      key: "_onCellSelectionChanged",
      value: function _onCellSelectionChanged(event) {
        event.stopImmediatePropagation();

        this._triggerChangeEvent();
      }
      /** @private */

    }, {
      key: "_onBeforeCellSelectionChanged",
      value: function _onBeforeCellSelectionChanged(event) {
        event.stopImmediatePropagation(); // In single selection, if the added item is selected, the rest should be deselected

        var selectedItem = this.selectedItem;

        if (!this.multiple && selectedItem && !event.target.selected) {
          selectedItem.set('selected', false, true);
        }
      }
      /** @private */

    }, {
      key: "_syncAriaSelectedState",
      value: function _syncAriaSelectedState() {
        var _this2 = this;

        this.classList.toggle('is-selected', this.selected);
        var selectHandle = this.querySelector('[coral-table-rowselect]'); // @a11y Only update aria-selected if the table row can be selected

        if (!(this.hasAttribute('coral-table-rowselect') || selectHandle)) {
          this.removeAttribute('aria-selected');
          return;
        }

        var rowOrderHandle = this.querySelector('[coral-table-roworder]');
        var rowLockHandle = this.querySelector('[coral-table-rowlock]');
        var rowRemoveHandle = this.querySelector('[coral-row-remove]');
        var accessibilityState = this._elements.accessibilityState;

        var resetAccessibilityState = function resetAccessibilityState() {
          // @a11y remove aria-live
          _this2.removeAttribute('aria-live');

          _this2.removeAttribute('aria-atomic');

          _this2.removeAttribute('aria-relevant'); // @a11y Unhide the selectHandle, so that it will be resume being announced by assistive
          // technology


          if (selectHandle && selectHandle.tagName === 'CORAL-CHECKBOX') {
            selectHandle.removeAttribute('aria-hidden');
          } // @a11y Unhide the coral-table-roworder handle, so that it will be resume being announced by
          // assistive technology


          if (rowOrderHandle) {
            rowOrderHandle.removeAttribute('aria-hidden');
          } // @a11y Unhide the coral-table-rowlock handle, so that it will be resume being announced by
          // assistive technology


          if (rowLockHandle) {
            rowLockHandle.removeAttribute('aria-hidden');
          } // @a11y Unhide the coral-row-remove handle, so that it will be resume being announced by
          // assistive technology


          if (rowRemoveHandle) {
            rowRemoveHandle.removeAttribute('aria-hidden');
          }

          if (accessibilityState) {
            // @a11y Hide the _accessibilityState from assistive technology, so that it can not be read
            // using a screen reader separately from the row it helps label
            accessibilityState.setAttribute('aria-hidden', 'true'); // @a11y If the item is not selected, remove ', unchecked' to decrease verbosity.

            if (!_this2.selected) {
              accessibilityState.innerHTML = '';
            }
          }
        }; // @a11y set aria-selected


        this.setAttribute('aria-selected', this.selected);

        if (this._ariaLiveOnTimeout || this._ariaLiveOffTimeout) {
          clearTimeout(this._ariaLiveOnTimeout);
          clearTimeout(this._ariaLiveOffTimeout);
        } // @ally If _accessibilityState has been added to a cell within the row,


        if (accessibilityState) {
          resetAccessibilityState();
          this._ariaLiveOnTimeout = setTimeout(function () {
            // @a11y and the row or one of its descendants has focus,
            if (_this2 === document.activeElement || _this2.contains(document.activeElement)) {
              // @a11y Hide the "Select" checkbox so that it does not get announced with the state change.
              if (selectHandle && selectHandle.tagName === 'CORAL-CHECKBOX') {
                selectHandle.setAttribute('aria-hidden', 'true');
              } // @a11y Hide the coral-table-roworder handle so that it does not get announced with the
              // state change.


              if (rowOrderHandle) {
                rowOrderHandle.setAttribute('aria-hidden', 'true');
              } // @a11y Hide the coral-table-rowlock handle so that it does not get announced with the state
              // change.


              if (rowLockHandle) {
                rowLockHandle.setAttribute('aria-hidden', 'true');
              } // @a11y Hide the coral-row-remove handle so that it does not get announced with the state
              // change.


              if (rowRemoveHandle) {
                rowRemoveHandle.setAttribute('aria-hidden', 'true');
              } // @a11y The ChromeVox screenreader, used on Chromebook, announces the state change and
              // should not need aria-live, otherwise it double-voices the row.


              if (!window.cvox) {
                // @a11y Unhide the _accessibilityState so that it will get announced with the state change.
                accessibilityState.removeAttribute('aria-hidden'); // @ally use aria-live to announce the state change

                _this2.setAttribute('aria-live', 'assertive'); // @ally use aria-atomic="true" to announce the entire row


                _this2.setAttribute('aria-atomic', 'true');
              }

              _this2._ariaLiveOnTimeout = setTimeout(function () {
                // @ally Set the _accessibilityState text to read either ", checked" or ", unchecked",
                // which should trigger a live region announcement.
                accessibilityState.innerHTML = i18n.get(_this2.selected ? ', checked' : ', unchecked'); // @ally wait 250ms for row to announce

                _this2._ariaLiveOffTimeout = setTimeout(resetAccessibilityState, 250);
              }, 20);
            }
          }, 20);

          if (!(this === document.activeElement || this.contains(document.activeElement))) {
            accessibilityState.innerHTML = i18n.get(this.selected ? ', checked' : '');
          }
        }
      }
      /** @private */

    }, {
      key: "_syncAriaLabelledby",
      value: function _syncAriaLabelledby() {
        var _this3 = this;

        // @a11y if the row is not selectable, remove accessibilityState
        if (!(this.hasAttribute('coral-table-rowselect') || this.querySelector('[coral-table-rowselect]'))) {
          if (this._elements.accessibilityState.parentNode) {
            this.removeAttribute('aria-labelledby');
            this._elements.accessibilityState = this._elements.accessibilityState.parentNode.removeChild(this._elements.accessibilityState);
          }

          return;
        } // @a11y get a list of ids for cells


        var cells = this.items.getAll().filter(function (cell) {
          // @a11y exclude cells for coral-table-roworder, coral-table-rowlock or coral-row-remove
          return cell.id && !(cell.hasAttribute('coral-table-roworder') || cell.querySelector('[coral-table-roworder]') || cell.hasAttribute('coral-table-rowlock') || cell.querySelector('[coral-table-rowlock]') || cell.hasAttribute('coral-row-remove') || cell.querySelector('[coral-table-remove]'));
        });
        var rowHeaders = cells.filter(function (cell) {
          return cell.getAttribute('role') === 'rowheader' || cell.tagName === 'TH' && cell.getAttribute('scope') === 'row';
        });
        var cellForAccessibilityState;
        var ids = cells.map(function (cell) {
          var handle = cell.querySelector('[coral-table-rowselect]');

          if (handle) {
            cellForAccessibilityState = cell; // @a11y otherwise, if the selectHandle is a coral-checkbox,

            if (handle && handle.tagName === 'CORAL-CHECKBOX' && handle._elements) {
              // @a11y if the row is selected, don't add the coral-table-rowselect to accessibility name
              if (_this3.selected) {
                return;
              } // otherwise, include the checkbox input labelled "Select" in the accessibility name


              return handle._elements.input && handle._elements.input.id;
            }
          } // @a11y include row headers, or if no row header is defined,
          // all other cells in the row, in the accessibility name


          if (rowHeaders.length === 0 || rowHeaders.indexOf(cell) !== -1) {
            return cell.id;
          }
        }); // @a11y If an _accessibilityState has not been defined within one of the cells, add to the last
        // cell

        if (!cellForAccessibilityState && cells.length) {
          cellForAccessibilityState = cells[cells.length - 1];
        }

        if (cellForAccessibilityState) {
          cellForAccessibilityState.appendChild(this._elements.accessibilityState);
        } // @a11y Once defined,


        if (this._elements.accessibilityState.parentNode) {
          // @a11y add the _accessibilityState ", checked" or ", unchecked" as the last item in the
          // accessibility name
          ids.push(this._elements.accessibilityState.id);
        } // @a11y Update the aria-labelledby attribute for the row.


        this.setAttribute('aria-labelledby', ids.join(' '));
      }
      /** @private */

    }, {
      key: "_syncSelectHandle",
      value: function _syncSelectHandle() {
        var _this4 = this;

        // Check/uncheck the select handle
        var selectHandle = this.querySelector('[coral-table-rowselect]');

        if (selectHandle) {
          if (typeof selectHandle.indeterminate !== 'undefined') {
            selectHandle.indeterminate = false;
          }

          selectHandle[this.selected ? 'setAttribute' : 'removeAttribute']('checked', ''); // @a11y If the handle is a checkbox but lacks a label, label it with "Select".

          if (selectHandle.tagName === 'CORAL-CHECKBOX') {
            if (!selectHandle.labelled) {
              selectHandle.labelled = i18n.get('Select');
            } // @a11y provide a more explicit label for the checkbox than just "Select"


            if (this.hasAttribute('aria-labelledby')) {
              var ids = this.getAttribute('aria-labelledby').split(' ').filter(function (id) {
                return selectHandle._elements.input.id !== id && _this4._elements.accessibilityState.id !== id;
              }).join(' ');
              selectHandle.labelledBy = selectHandle._elements.input.id + ' ' + ids;
            }
          }
        }
      }
      /** @private */

    }, {
      key: "_toggleSelectable",
      value: function _toggleSelectable(selectable) {
        if (selectable) {
          this._setHandle('coral-table-rowselect');
        } else {
          // Clear selection but leave the handle if any
          this.set('selected', false, true);
        } // Sync the aria-labelledby attribute to include the _accessibilityState


        this._syncAriaLabelledby();
      }
      /** @private */

    }, {
      key: "_toggleOrderable",
      value: function _toggleOrderable(orderable) {
        if (orderable) {
          this._setHandle('coral-table-roworder', 0);
        } // Remove DragAction instance
        else if (this.dragAction) {
            this.dragAction.destroy();
          }
      }
      /** @private */

    }, {
      key: "_toggleLockable",
      value: function _toggleLockable(lockable) {
        if (lockable) {
          this._setHandle('coral-table-rowlock');
        }
      }
    }, {
      key: "_setHandleAndSync",
      value: function _setHandleAndSync(handle) {
        // Specify handle directly on the row if none found
        if (!this.querySelector("[".concat(handle, "]"))) {
          this.setAttribute(handle, '');
        }

        this._syncSelectHandle();

        this._syncAriaLabelledby();

        this._syncAriaSelectedState();
      }
      /** @private */

    }, {
      key: "_setHandle",
      value: function _setHandle(handle, timeout) {
        var _this5 = this;

        if (typeof timeout === "number") {
          setTimeout(function () {
            _this5._setHandleAndSync(handle);
          }, timeout);
        } else {
          requestAnimationFrame(function () {
            _this5._setHandleAndSync(handle);
          });
        }
      }
      /** @private */

    }, {
      key: "_handleMutations",
      value: function _handleMutations(mutations) {
        var _this6 = this;

        mutations.forEach(function (mutation) {
          // Sync added nodes
          _this6.trigger('coral-table-row:_contentchanged', {
            addedNodes: mutation.addedNodes,
            removedNodes: mutation.removedNodes
          });

          _this6._syncAriaLabelledby();
        });
      }
      /** @ignore */

    }, {
      key: "attributeChangedCallback",

      /** @ignore */
      value: function attributeChangedCallback(name, oldValue, value) {
        if (name === '_selectable') {
          this._toggleSelectable(value !== null);
        } else if (name === '_orderable') {
          this._toggleOrderable(value !== null);
        } else if (name === '_lockable') {
          this._toggleLockable(value !== null);
        } else {
          _get(_getPrototypeOf(_class.prototype), "attributeChangedCallback", this).call(this, name, oldValue, value);
        }
      }
      /** @ignore */

    }, {
      key: "render",
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1B);

        this._syncAriaLabelledby();
      }
      /**
       Triggered before {@link TableRow#selected} is changed.
        @typedef {CustomEvent} coral-table-row:_beforeselectedchanged
        @private
       */

      /**
       Triggered when {@link TableRow#selected} changed.
        @typedef {CustomEvent} coral-table-row:_selectedchanged
        @private
       */

      /**
       Triggered when {@link TableRow#locked} changed.
        @typedef {CustomEvent} coral-table-row:_lockedchanged
        @private
       */

      /**
       Triggered when {@link TableRow#multiple} changed.
        @typedef {CustomEvent} coral-table-row:_multiplechanged
        @private
       */

      /**
       Triggered when the {@link TableRow} selection changed.
        @typedef {CustomEvent} coral-table-row:_change
        @property {Array.<TableCell>} detail.oldSelection
       The old item selection. When {@link TableRow#multiple}, it includes an Array.
       @property {Array.<TableCell>} event.detail.selection
       The item selection. When {@link TableRow#multiple}, it includes an Array.
        @private
       */

    }, {
      key: "locked",
      get: function get() {
        return this._locked || false;
      },
      set: function set(value) {
        this._locked = transform.booleanAttr(value);

        this._reflectAttribute('locked', this._locked);

        this.trigger('coral-table-row:_lockedchanged');
      }
      /**
       Whether the table row is selected.
        @type {Boolean}
       @default false
       @htmlattribute selected
       @htmlattributereflected
       */

    }, {
      key: "selected",
      get: function get() {
        return this._selected || false;
      },
      set: function set(value) {
        // Prevent selection if disabled
        if (this.hasAttribute('coral-table-rowselect') && this.hasAttribute('disabled') || this.querySelector('[coral-table-rowselect][disabled]')) {
          return;
        }

        this.trigger('coral-table-row:_beforeselectedchanged');
        this._selected = transform.booleanAttr(value);

        this._reflectAttribute('selected', this._selected);

        this.trigger('coral-table-row:_selectedchanged');

        this._syncSelectHandle();

        this._syncAriaLabelledby();

        this._syncAriaSelectedState();
      }
      /**
       Whether the items are selectable.
        @type {Boolean}
       @default false
       @htmlattribute selectable
       @htmlattributereflected
       */

    }, {
      key: "selectable",
      get: function get() {
        return this._selectable || false;
      },
      set: function set(value) {
        var _this7 = this;

        this._selectable = transform.booleanAttr(value);

        this._reflectAttribute('selectable', this._selectable);

        this.items.getAll().forEach(function (cell) {
          cell[_this7._selectable ? 'setAttribute' : 'removeAttribute']('_selectable', '');
        });
      }
      /**
       Whether multiple items can be selected.
        @type {Boolean}
       @default false
       @htmlattribute multiple
       @htmlattributereflected
       */

    }, {
      key: "multiple",
      get: function get() {
        return this._multiple || false;
      },
      set: function set(value) {
        this._multiple = transform.booleanAttr(value);

        this._reflectAttribute('multiple', this._multiple);

        this.trigger('coral-table-row:_multiplechanged');
      }
      /**
       Returns an Array containing the selected items.
        @type {Array.<HTMLElement>}
       @readonly
       */

    }, {
      key: "selectedItems",
      get: function get() {
        return this.items._getAllSelected();
      }
      /**
       Returns the first selected item of the row. The value <code>null</code> is returned if no element is
       selected.
        @type {HTMLElement}
       @readonly
       */

    }, {
      key: "selectedItem",
      get: function get() {
        return this.items._getFirstSelected();
      }
      /**
       The Collection Interface that allows interacting with the items that the component contains.
        @type {SelectableCollection}
       @readonly
       */

    }, {
      key: "items",
      get: function get() {
        // Construct the collection on first request
        if (!this._items) {
          this._items = new SelectableCollection({
            host: this,
            itemBaseTagName: 'td',
            itemTagName: 'coral-table-cell'
          });
        }

        return this._items;
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['locked', 'selected', 'multiple', 'selectable', '_selectable', '_orderable', '_lockable']);
      }
    }]);

    return _class;
  }(BaseComponent(HTMLTableRowElement)));

  // divider changes

  var ALL_DIVIDER_CLASSES = [];

  for (var dividerValue in divider) {
    ALL_DIVIDER_CLASSES.push("_coral-Table-divider--".concat(divider[dividerValue]));
  }
  /**
   @base BaseTableSection
   @classdesc The base element for table sections
   */


  var BaseTableSection = function BaseTableSection(superClass) {
    return /*#__PURE__*/function (_superClass) {
      _inherits(_class, _superClass);

      var _super = _createSuper(_class);

      /** @ignore */
      function _class() {
        var _this;

        _classCallCheck(this, _class);

        _this = _super.call(this);
        _this._tagName = _this.getAttribute('is').toLowerCase();
        return _this;
      }
      /**
       The table section divider. See {@link TableSectionDividerEnum}.
        @type {String}
       @default TableSectionDividerEnum.ROW
       @htmlattributereflected
       @htmlattribute divider
       */


      _createClass(_class, [{
        key: "_toggleObserver",
        value: function _toggleObserver(enable) {
          this._observer = this._observer || new MutationObserver(this._handleMutations.bind(this));

          if (enable) {
            // Initialize content MO
            this._observer.observe(this, {
              childList: true,
              subtree: true
            });
          } else {
            this._observer.disconnect();
          }
        }
      }, {
        key: "_handleMutations",
        value: function _handleMutations(mutations) {
          var _this2 = this;

          mutations.forEach(function (mutation) {
            _this2.trigger("".concat(_this2._tagName, ":_contentchanged"), {
              addedNodes: mutation.addedNodes,
              removedNodes: mutation.removedNodes
            });
          });
        }
        /** @ignore */

      }, {
        key: "attributeChangedCallback",

        /** @ignore */
        value: function attributeChangedCallback(name, oldValue, value) {
          if (name === '_observe') {
            this._toggleObserver(value !== 'off');
          } else {
            _get(_getPrototypeOf(_class.prototype), "attributeChangedCallback", this).call(this, name, oldValue, value);
          }
        }
        /** @ignore */

      }, {
        key: "render",
        value: function render() {
          _get(_getPrototypeOf(_class.prototype), "render", this).call(this); // Default reflected attributes


          if (!this._divider) {
            this.divider = divider.ROW;
          }
        }
      }, {
        key: "divider",
        get: function get() {
          return this._divider || divider.ROW;
        },
        set: function set(value) {
          var _this$classList;

          value = transform.string(value).toLowerCase();
          this._divider = validate.enumeration(divider)(value) && value || divider.ROW;

          this._reflectAttribute('divider', this._divider);

          (_this$classList = this.classList).remove.apply(_this$classList, ALL_DIVIDER_CLASSES);

          this.classList.add("_coral-Table-divider--".concat(this.divider));
        }
      }], [{
        key: "observedAttributes",
        get: function get() {
          return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['divider', '_observe']);
        }
      }]);

      return _class;
    }(superClass);
  };

  var CLASSNAME$1C = '_coral-Table-head';
  /**
   @class Coral.Table.Head
   @classdesc A Table head component
   @htmltag coral-table-head
   @htmlbasetag thead
   @extends {HTMLTableSectionElement}
   @extends {BaseComponent}
   @extends {BaseTableSection}
   */

  var TableHead = Decorator( /*#__PURE__*/function (_BaseTableSection) {
    _inherits(_class, _BaseTableSection);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this);

      _this._toggleObserver(true);

      return _this;
    }
    /**
     Whether the table head is sticky. The table content becomes automatically scrollable if the table wrapper height
     is smaller than its content.
     Table exposes the <code>coral-table-scroll</code> attribute that allows in sticky mode to define the table
     scrolling container max-height. This is particularly useful if the table contains dynamic content.
      @type {Boolean}
     @default false
     @htmlattribute sticky
     @htmlattributereflected
     */


    _createClass(_class, [{
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1C);
      }
      /**
       Triggered when the {@link TableHead} content changed.
        @typedef {CustomEvent} coral-table-head:_contentchanged
        @private
       */

      /**
       Triggered when {@link TableHead#sticky} changed.
        @typedef {CustomEvent} coral-table-head:_stickychanged
        @private
       */

    }, {
      key: "sticky",
      get: function get() {
        return this._sticky || false;
      },
      set: function set(value) {
        var _this2 = this;

        this._sticky = transform.booleanAttr(value);

        this._reflectAttribute('sticky', this._sticky); // Delay execution for better performance


        window.requestAnimationFrame(function () {
          _this2.trigger('coral-table-head:_stickychanged');
        });
      }
      /** @ignore */

    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['sticky']);
      }
    }]);

    return _class;
  }(BaseTableSection(BaseComponent(HTMLTableSectionElement))));

  var CLASSNAME$1D = '_coral-Table-body';
  /**
   @class Coral.Table.Body
   @classdesc A Table body component
   @htmltag coral-table-body
   @htmlbasetag tbody
   @extends {HTMLTableSectionElement}
   @extends {BaseComponent}
   @extends {BaseTableSection}
   */

  var TableBody = Decorator( /*#__PURE__*/function (_BaseTableSection) {
    _inherits(_class, _BaseTableSection);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this);

      _this._toggleObserver(true);

      return _this;
    }
    /** @ignore */


    _createClass(_class, [{
      key: "render",
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1D);

        if (getRows([this]).length === 0) {
          this.trigger('coral-table-body:_empty');
        }
      }
      /**
       Triggered when the {@link TableBody} content changed.
        @typedef {CustomEvent} coral-table-body:_contentchanged
        @private
       */

      /**
       Triggered when the {@link TableBody} is initialized without rows.
        @typedef {CustomEvent} coral-table-body:_empty
        @private
       */

    }]);

    return _class;
  }(BaseTableSection(BaseComponent(HTMLTableSectionElement))));

  var CLASSNAME$1E = '_coral-Table-foot';
  /**
   @class Coral.Table.Foot
   @classdesc A Table foot component
   @htmltag coral-table-foot
   @htmlbasetag tfoot
   @extends {HTMLTableSectionElement}
   @extends {BaseComponent}
   @extends {BaseTableSection}
   */

  var TableFoot = Decorator( /*#__PURE__*/function (_BaseTableSection) {
    _inherits(_class, _BaseTableSection);

    var _super = _createSuper(_class);

    function _class() {
      _classCallCheck(this, _class);

      return _super.apply(this, arguments);
    }

    _createClass(_class, [{
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1E);
      }
    }]);

    return _class;
  }(BaseTableSection(BaseComponent(HTMLTableSectionElement))));

  var template$11 = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["liveRegion"] = document.createElement("div");
    el0.setAttribute("handle", "liveRegion");
    el0.className += " u-coral-screenReaderOnly _coral-Table-liveRegion";
    el0.setAttribute("aria-hidden", "true");
    el0.setAttribute("aria-live", "off");
    el0.id = data_0["commons"]["getUID"]();
    frag.appendChild(el0);
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    var el2 = this["container"] = document.createElement("div");
    el2.setAttribute("handle", "container");
    el2.className += " _coral-Table-wrapper-container";
    el2.setAttribute("role", "presentation");
    el2.setAttribute("coral-table-scroll", "");
    var el3 = document.createTextNode("\n  ");
    el2.appendChild(el3);
    var el4 = this["hiddenStyle"] = document.createElement("style");
    el4.setAttribute("handle", "hiddenStyle");
    el2.appendChild(el4);
    var el5 = document.createTextNode("\n  ");
    el2.appendChild(el5);
    var el6 = this["alignmentStyle"] = document.createElement("style");
    el6.setAttribute("handle", "alignmentStyle");
    el2.appendChild(el6);
    var el7 = document.createTextNode("\n  ");
    el2.appendChild(el7);
    var el8 = this["table"] = document.createElement("table");
    el8.setAttribute("handle", "table");
    el8.className += " _coral-Table";
    el8.setAttribute("role", "grid");
    el8.setAttribute("aria-describedby", this["liveRegion"]["id"]);
    el2.appendChild(el8);
    var el9 = document.createTextNode("\n");
    el2.appendChild(el9);
    frag.appendChild(el2);
    var el10 = document.createTextNode("\n\n");
    frag.appendChild(el10);
    return frag;
  };

  var CLASSNAME$1F = '_coral-Table-wrapper';
  /**
   Enumeration for {@link Table} variants

   @typedef {Object} TableVariantEnum

   @property {String} DEFAULT
   A default table.
   @property {String} QUIET
   A quiet table with transparent borders and background.
   @property {String} LIST
   Not supported. Falls back to DEFAULT.
   */

  var variant$m = {
    DEFAULT: 'default',
    QUIET: 'quiet',
    LIST: 'list'
  };
  var ALL_VARIANT_CLASSES$c = [];

  for (var variantValue$a in variant$m) {
    ALL_VARIANT_CLASSES$c.push("".concat(CLASSNAME$1F, "--").concat(variant$m[variantValue$a]));
  }

  var IS_DISABLED = 'is-disabled';
  var IS_SORTED = 'is-sorted';
  var IS_UNSELECTABLE = 'is-unselectable';
  var IS_FIRST_ITEM_DRAGGED = 'is-draggedFirstItem';
  var IS_LAST_ITEM_DRAGGED = 'is-draggedLastItem';
  var IS_DRAGGING_CLASS$2 = 'is-dragging';
  var IS_BEFORE_CLASS$1 = 'is-before';
  var IS_AFTER_CLASS$1 = 'is-after';
  var IS_LAYOUTING = 'is-layouting';
  var IS_READY = 'is-ready';
  var KEY_SPACE = Keys.keyToCode('space');
  /**
   @class Coral.Table
   @classdesc A Table component is a container component to display and manipulate data in two dimensions.
   To define table actions on specific elements, handles can be used.
   A handle is given a special attribute :
   - <code>[coral-table-select]</code>. Select/unselect all table items.
   - <code>[coral-table-rowselect]</code>. Select/unselect the table item.
   - <code>[coral-table-roworder]</code>. Drag to order the table item.
   - <code>[coral-table-rowlock]</code>. Lock/unlock the table item.
   @htmltag coral-table
   @htmlbasetag table
   @extends {HTMLTableElement}
   @extends {BaseComponent}
   */

  var Table = Decorator( /*#__PURE__*/function (_BaseComponent) {
    _inherits(_class, _BaseComponent);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this); // Templates

      _this._elements = {
        head: _this.querySelector('thead[is="coral-table-head"]') || new TableHead(),
        body: _this.querySelector('tbody[is="coral-table-body"]') || new TableBody(),
        foot: _this.querySelector('tfoot[is="coral-table-foot"]') || new TableFoot(),
        columns: _this.querySelector('colgroup') || document.createElement('colgroup')
      };
      template$11.call(_this._elements, {
        commons: commons
      }); // Events

      _this._delegateEvents({
        // Table specific
        'global:coral-commons:_webfontactive': '_resetLayout',
        'change [coral-table-select]': '_onSelectAll',
        'capture:scroll [handle="container"]': '_onScroll',
        // Head specific
        'click thead[is="coral-table-head"] th[is="coral-table-headercell"]': '_onHeaderCellSort',
        'coral-dragaction:dragstart thead[is="coral-table-head"] th[is="coral-table-headercell"]': '_onHeaderCellDragStart',
        'coral-dragaction:drag thead[is="coral-table-head"] tr[is="coral-table-row"] > th[is="coral-table-headercell"]': '_onHeaderCellDrag',
        'coral-dragaction:dragend thead[is="coral-table-head"] tr[is="coral-table-row"] > th[is="coral-table-headercell"]': '_onHeaderCellDragEnd',
        // a11y
        'key:enter th[is="coral-table-headercell"]': '_onHeaderCellSort',
        'key:enter th[is="coral-table-headercell"] coral-table-headercell-content': '_onHeaderCellSort',
        'key:space th[is="coral-table-headercell"]': '_onHeaderCellSort',
        'key:space th[is="coral-table-headercell"] coral-table-headercell-content': '_onHeaderCellSort',
        // Body specific
        'click tbody[is="coral-table-body"] [coral-table-rowlock]': '_onRowLock',
        'click tbody[is="coral-table-body"] [coral-table-rowselect]': '_onRowSelect',
        'click tbody[is="coral-table-body"] tr[is="coral-table-row"][selectable] [coral-table-cellselect]': '_onCellSelect',
        'capture:mousedown tbody[is="coral-table-body"] [coral-table-roworder]:not([disabled])': '_onRowOrder',
        'capture:touchstart tbody[is="coral-table-body"] [coral-table-roworder]:not([disabled])': '_onRowOrder',
        'coral-dragaction:dragstart tbody[is="coral-table-body"] tr[is="coral-table-row"]': '_onRowDragStart',
        'coral-dragaction:drag tbody[is="coral-table-body"] tr[is="coral-table-row"]': '_onRowDrag',
        'coral-dragaction:dragover tbody[is="coral-table-body"] tr[is="coral-table-row"]': '_onRowDragOver',
        'coral-dragaction:dragend tbody[is="coral-table-body"] tr[is="coral-table-row"]': '_onRowDragEnd',
        // a11y
        'mousedown tbody[is="coral-table-body"] [coral-table-rowselect]': '_onRowDown',
        'key:enter tbody[is="coral-table-body"] tr[is="coral-table-row"]': '_onRowSelect',
        'key:space tbody[is="coral-table-body"] tr[is="coral-table-row"]': '_onRowSelect',
        'key:pageup tbody[is="coral-table-body"] tr[is="coral-table-row"]': '_onFocusPreviousItem',
        'key:pagedown tbody[is="coral-table-body"] tr[is="coral-table-row"]': '_onFocusNextItem',
        'key:left tbody[is="coral-table-body"] tr[is="coral-table-row"]': '_onFocusPreviousItem',
        'key:right tbody[is="coral-table-body"] tr[is="coral-table-row"]': '_onFocusNextItem',
        'key:up tbody[is="coral-table-body"] tr[is="coral-table-row"]': '_onFocusPreviousItem',
        'key:down tbody[is="coral-table-body"] tr[is="coral-table-row"]': '_onFocusNextItem',
        'key:home tbody[is="coral-table-body"] tr[is="coral-table-row"]': '_onFocusFirstItem',
        'key:end tbody[is="coral-table-body"] tr[is="coral-table-row"]': '_onFocusLastItem',
        'key:shift+pageup tbody[is="coral-table-body"] tr[is="coral-table-row"]': '_onSelectPreviousItem',
        'key:shift+pagedown tbody[is="coral-table-body"] tr[is="coral-table-row"]': '_onSelectNextItem',
        'key:shift+left tbody[is="coral-table-body"] tr[is="coral-table-row"]': '_onSelectPreviousItem',
        'key:shift+right tbody[is="coral-table-body"] tr[is="coral-table-row"]': '_onSelectNextItem',
        'key:shift+up tbody[is="coral-table-body"] tr[is="coral-table-row"]': '_onSelectPreviousItem',
        'key:shift+down tbody[is="coral-table-body"] tr[is="coral-table-row"]': '_onSelectNextItem',
        // Private
        'coral-table-row:_multiplechanged': '_onRowMultipleChanged',
        'coral-table-row:_beforeselectedchanged': '_onBeforeRowSelectionChanged',
        'coral-table-row:_selectedchanged': '_onRowSelectionChanged',
        'coral-table-row:_lockedchanged': '_onRowLockedChanged',
        'coral-table-row:_change': '_onRowChange',
        'coral-table-row:_contentchanged': '_onRowContentChanged',
        'coral-table-headercell:_contentchanged': '_resetLayout',
        'coral-table-head:_contentchanged': '_onHeadContentChanged',
        'coral-table-body:_contentchanged': '_onBodyContentChanged',
        'coral-table-body:_empty': '_onBodyEmpty',
        'coral-table-column:_alignmentchanged': '_onAlignmentChanged',
        'coral-table-column:_fixedwidthchanged': '_onFixedWidthChanged',
        'coral-table-column:_orderablechanged': '_onColumnOrderableChanged',
        'coral-table-column:_sortablechanged': '_onColumnSortableChanged',
        'coral-table-column:_sortabledirectionchanged': '_onColumnSortableDirectionChanged',
        'coral-table-column:_hiddenchanged': '_onColumnHiddenChanged',
        'coral-table-column:_beforecolumnsort': '_onBeforeColumnSort',
        'coral-table-column:_sort': '_onColumnSort',
        'coral-table-head:_stickychanged': '_onHeadStickyChanged'
      }); // Required for coral-table:change event


      _this._oldSelection = []; // References selected items in their selection order and is only used for keyboard selection

      _this._lastSelectedItems = {
        items: [],
        direction: null
      }; // Don't sort by default

      _this._allowSorting = false; // Debounce timer

      _this._timeout = null; // Debounce wait in milliseconds

      _this._wait = 50; // Used by resizing detector

      _this._resetLayout = _this._resetLayout.bind(_assertThisInitialized(_this)); // Init observer

      _this._toggleObserver(true);

      return _this;
    }
    /**
     The head of the table.
      @type {TableHead}
     @contentzone
     */


    _createClass(_class, [{
      key: "_onSelectAll",

      /** @private */
      value: function _onSelectAll(event) {
        if (this.selectable) {
          var rows = this._getSelectableItems();

          if (rows.length) {
            if (this.multiple) {
              var selected = event.target.checked;
              rows.forEach(function (row) {
                // Don't trigger too many events
                row.set('selected', selected, true);
              });
              rows = selected ? rows : []; // Synchronise the table select handle

              this._setSelectAllHandleState(selected ? 'checked' : 'unchecked');

              this.trigger('coral-table:change', {
                selection: rows,
                oldSelection: this._oldSelection
              }); // Sync used collection

              this._oldSelection = rows;
              this._lastSelectedItems.items = rows;
            } else {
              // Only select last item
              var lastItem = rows[rows.length - 1];
              lastItem.selected = !lastItem.selected;
            }
          }
        }
      }
    }, {
      key: "_triggerChangeEvent",
      value: function _triggerChangeEvent() {
        if (!this._preventTriggeringEvents) {
          var selectedItems = this.selectedItems;
          this.trigger('coral-table:change', {
            oldSelection: this._oldSelection,
            selection: selectedItems
          });
          this._oldSelection = selectedItems;
        }
      }
      /** @private */

    }, {
      key: "_onRowOrder",
      value: function _onRowOrder(event) {
        var table = this;
        var row = event.target.closest('tr[is="coral-table-row"]');

        if (row && table.orderable) {
          var head = table.head;
          var body = table.body;
          var sticky = head && head.sticky;
          var style = row.getAttribute('style');
          var index = getIndexOf(row);
          var oldBefore = row.nextElementSibling;
          var dragAction = new DragAction(row);
          var items = getRows([body]);
          var tableBoundingClientRect = table.getBoundingClientRect();
          var rowBoundingClientRect = row.getBoundingClientRect();

          if (row === items[0]) {
            table.classList.add(IS_FIRST_ITEM_DRAGGED);
          } else if (row === items[items.length - 1]) {
            table.classList.add(IS_LAST_ITEM_DRAGGED);
          }

          dragAction.axis = 'vertical'; // Handle the scroll in table

          dragAction.scroll = false; // Specify selection handle directly on the row if none found

          dragAction.handle = row.querySelector('[coral-table-roworder]'); // The row placeholder indicating where the dragged element will be dropped

          var placeholder = row.cloneNode(true);
          placeholder.classList.add('_coral-Table-row--placeholder'); // Prepare the row position before inserting its placeholder

          row.style.top = "".concat(rowBoundingClientRect.top - tableBoundingClientRect.top, "px"); // Prevent change event from triggering if the cloned node is selected

          table._preventTriggeringEvents = true;
          body.insertBefore(placeholder, row.nextElementSibling);
          window.requestAnimationFrame(function () {
            table._preventTriggeringEvents = false;
          }); // Store the data to avoid re-reading the layout on drag events

          var dragData = {
            placeholder: placeholder,
            index: index,
            oldBefore: oldBefore,
            // Backup styles to restore them later
            style: {
              row: style
            }
          }; // Required to handle the scrolling of the sticky table on drag events

          if (sticky) {
            dragData.sticky = sticky;
            dragData.tableTop = tableBoundingClientRect.top;
            dragData.tableSize = tableBoundingClientRect.height;
            dragData.headSize = parseFloat(table._elements.container.style.marginTop);
            dragData.dragElementSize = rowBoundingClientRect.height;
          }

          row.dragAction._dragData = dragData;
        }
      }
      /** @private */

    }, {
      key: "_onHeaderCellSort",
      value: function _onHeaderCellSort(event) {
        var table = this;
        var matchedTarget = event.matchedTarget.closest('th'); // Don't sort if the column was dragged

        if (!matchedTarget._isDragging) {
          var column = table._getColumn(matchedTarget); // Only sort if actually sortable and event not defaultPrevented


          if (column && column.sortable) {
            event.preventDefault();

            column._sort(); // Restore focus on the header cell in any case


            matchedTarget.focus();
          }
        }
      }
      /** @private */

    }, {
      key: "_onHeaderCellDragStart",
      value: function _onHeaderCellDragStart(event) {
        var table = this;
        var matchedTarget = event.matchedTarget;
        var dragElement = event.detail.dragElement;
        var siblingHeaderCellSelector = matchedTarget === dragElement ? 'th[is="coral-table-headercell"]' : 'th[is="coral-table-headercell"] coral-table-headercell-content';
        var tableBoundingClientRect = table.getBoundingClientRect(); // Store the data to be used on drag events

        dragElement.dragAction._dragData = {
          draggedColumnIndex: getIndexOf(matchedTarget),
          tableLeft: tableBoundingClientRect.left,
          tableSize: tableBoundingClientRect.width,
          dragElementSize: matchedTarget.getBoundingClientRect().width,
          tableScrollWidth: table._elements.container.scrollWidth
        };
        getSiblingsOf(matchedTarget, siblingHeaderCellSelector, 'prevAll').forEach(function (item) {
          item.classList.add(IS_BEFORE_CLASS$1);
        });
        getSiblingsOf(matchedTarget, siblingHeaderCellSelector, 'nextAll').forEach(function (item) {
          item.classList.add(IS_AFTER_CLASS$1);
        });
      }
      /** @private */

    }, {
      key: "_onHeaderCellDrag",
      value: function _onHeaderCellDrag(event) {
        var table = this;
        var container = table._elements.container;
        var matchedTarget = event.matchedTarget;
        var dragElement = event.detail.dragElement;
        var dragData = dragElement.dragAction._dragData;
        var row = matchedTarget.parentElement;
        var isHeaderCellDragged = matchedTarget === dragElement;
        var containerScrollLeft = container.scrollLeft;
        var documentScrollLeft = document.body.scrollLeft; // Prevent sorting on header cell click if the header cell is being dragged

        matchedTarget._isDragging = true; // Scroll left/right if table edge is reached

        var position = dragElement.getBoundingClientRect().left - dragData.tableLeft;
        var leftScrollLimit = 0;
        var rightScrollLimit = dragData.tableSize - dragData.dragElementSize;
        var scrollOffset = 10;

        if (position < leftScrollLimit) {
          container.scrollLeft -= scrollOffset;
        } // 2nd condition is required to avoid increasing the container scroll width
        else if (position > rightScrollLimit && containerScrollLeft + dragData.tableSize < dragData.tableScrollWidth) {
            container.scrollLeft += scrollOffset;
          } // Position sibling header cells based on the dragged element


        getHeaderCells(row).forEach(function (headerCell) {
          var draggedHeaderCell = isHeaderCellDragged ? headerCell : headerCell.content;

          if (!draggedHeaderCell.classList.contains(IS_DRAGGING_CLASS$2)) {
            var offsetLeft = draggedHeaderCell.getBoundingClientRect().left + documentScrollLeft;
            var isAfter = event.detail.pageX < offsetLeft + draggedHeaderCell.offsetWidth / 3;
            draggedHeaderCell.classList.toggle(IS_AFTER_CLASS$1, isAfter);
            draggedHeaderCell.classList.toggle(IS_BEFORE_CLASS$1, !isAfter);
            var columnIndex = getIndexOf(headerCell);
            var dragElementIndex = getIndexOf(matchedTarget); // Place headercell after

            if (draggedHeaderCell.classList.contains(IS_AFTER_CLASS$1)) {
              if (columnIndex < dragElementIndex) {
                // Position the header cells based on their siblings position
                if (isHeaderCellDragged) {
                  var nextHeaderCellWidth = draggedHeaderCell.clientWidth;
                  draggedHeaderCell.style.left = "".concat(nextHeaderCellWidth, "px");
                } else {
                  var nextHeaderCell = getSiblingsOf(headerCell, 'th[is="coral-table-headercell"]', 'next');
                  var nextHeaderCellLeftOffset = nextHeaderCell.getBoundingClientRect().left + documentScrollLeft;
                  draggedHeaderCell.style.left = "".concat(nextHeaderCellLeftOffset + containerScrollLeft, "px");
                }
              } else {
                draggedHeaderCell.style.left = '';
              }
            } // Place headerCell before


            if (draggedHeaderCell.classList.contains(IS_BEFORE_CLASS$1)) {
              if (columnIndex > dragElementIndex) {
                var prev = getSiblingsOf(headerCell, 'th[is="coral-table-headercell"]', 'prev'); // Position the header cells based on their siblings position

                if (isHeaderCellDragged) {
                  var beforeHeaderCellWidth = prev.clientWidth;
                  draggedHeaderCell.style.left = "".concat(-1 * beforeHeaderCellWidth, "px");
                } else {
                  var beforeHeaderCellLeftOffset = prev.getBoundingClientRect().left + documentScrollLeft;
                  draggedHeaderCell.style.left = "".concat(beforeHeaderCellLeftOffset + containerScrollLeft, "px");
                }
              } else {
                draggedHeaderCell.style.left = '';
              }
            }
          }
        });
      }
      /** @private */

    }, {
      key: "_onHeaderCellDragEnd",
      value: function _onHeaderCellDragEnd(event) {
        var table = this;
        var matchedTarget = event.matchedTarget;
        var dragElement = event.detail.dragElement;
        var dragData = dragElement.dragAction._dragData;

        var column = table._getColumn(matchedTarget);

        var headRows = getRows([table.head]);
        var isHeaderCellDragged = matchedTarget === dragElement;
        var row = matchedTarget.parentElement; // Select all cells in table body and foot given the index

        var getCellsByIndex = function getCellsByIndex(cellIndex) {
          var cellElements = [];
          var rows = getRows([table.body, table.foot]);
          rows.forEach(function (rowElement) {
            var cell = getCellByIndex(rowElement, cellIndex);

            if (cell) {
              cellElements.push(cell);
            }
          });
          return cellElements;
        };

        var cells = getCellsByIndex(getIndexOf(matchedTarget));
        var before = null;
        var after = null; // Siblings are either header cell or header cell content based on the current sticky state

        if (isHeaderCellDragged) {
          before = row.querySelector("th[is=\"coral-table-headercell\"].".concat(IS_AFTER_CLASS$1));
          after = row.querySelectorAll("th[is=\"coral-table-headercell\"].".concat(IS_BEFORE_CLASS$1));
          after = after.length ? after[after.length - 1] : null;
        } else {
          before = row.querySelector("th[is=\"coral-table-headercell\"] > coral-table-headercell-content.".concat(IS_AFTER_CLASS$1));
          before = before ? before.parentNode : null;
          after = row.querySelectorAll("th[is=\"coral-table-headercell\"] > coral-table-headercell-content.".concat(IS_BEFORE_CLASS$1));
          after = after.length ? after[after.length - 1].parentNode : null;
        } // Did header cell order change ?


        var swapped = !(before && before.previousElementSibling === matchedTarget || after && after.nextElementSibling === matchedTarget); // Switch whole columns based on the new position of the dragged element

        if (swapped) {
          var beforeColumn = before ? table._getColumn(before) : null; // Trigger the event on table

          var beforeEvent = table.trigger('coral-table:beforecolumndrag', {
            column: column,
            before: beforeColumn
          });
          var oldBefore = column.nextElementSibling;

          if (!beforeEvent.defaultPrevented) {
            // Insert the headercell at the new position
            if (before) {
              var beforeIndex = getIndexOf(before);
              var beforeCells = getCellsByIndex(beforeIndex);
              cells.forEach(function (cell, i) {
                cell.parentNode.insertBefore(cell, beforeCells[i]);
              }); // Sync <coral-table-column> by reordering it too

              var beforeCol = getColumns(table.columns)[beforeIndex];

              if (beforeCol && column) {
                table.columns.insertBefore(column, beforeCol);
              }

              row.insertBefore(matchedTarget, before);
            }

            if (after) {
              var afterIndex = getIndexOf(after);
              var afterCells = getCellsByIndex(afterIndex);
              cells.forEach(function (cell, i) {
                cell.parentNode.insertBefore(cell, afterCells[i].nextElementSibling);
              }); // Sync <coral-table-column> by reordering it too

              var afterCol = getColumns(table.columns)[afterIndex];

              if (afterCol && column) {
                table.columns.insertBefore(column, afterCol.nextElementSibling);
              }

              row.insertBefore(matchedTarget, after.nextElementSibling);
            } // Trigger the order event if the column position changed


            if (dragData.draggedColumnIndex !== getIndexOf(matchedTarget)) {
              var newBefore = getColumns(table.columns)[getIndexOf(column) + 1];
              table.trigger('coral-table:columndrag', {
                column: column,
                oldBefore: oldBefore,
                before: newBefore || null
              });
            }
          }
        } // Restoring default header cells styling


        headRows.forEach(function (rowElement) {
          getHeaderCells(rowElement).forEach(function (headerCell) {
            headerCell = isHeaderCellDragged ? headerCell : headerCell.content;
            headerCell.classList.remove(IS_AFTER_CLASS$1);
            headerCell.classList.remove(IS_BEFORE_CLASS$1);
            headerCell.style.left = '';
          });
        }); // Trigger a relayout

        table._resetLayout();

        window.requestAnimationFrame(function () {
          // Allows sorting again after dragging completed
          matchedTarget._isDragging = undefined; // Refocus the dragged element manually

          table._toggleElementTabIndex(dragElement, null, true);
        });
      }
      /** @private */

    }, {
      key: "_onCellSelect",
      value: function _onCellSelect(event) {
        var cell = event.target.closest('td[is="coral-table-cell"]');

        if (cell) {
          cell.selected = !cell.selected;
        }
      }
      /** @private */

    }, {
      key: "_onRowSelect",
      value: function _onRowSelect(event) {
        var table = this;
        var row = event.target.closest('tr[is="coral-table-row"]');

        if (row) {
          // Ignore selection if the row is locked
          if (table.lockable && row.locked) {
            return;
          } // Restore text-selection


          table.classList.remove(IS_UNSELECTABLE); // Prevent row selection when it's the selection handle and the target is an input

          if (table.selectable && (Keys.filterInputs(event) || !row.hasAttribute('coral-table-rowselect'))) {
            // Pressing space scrolls the sticky table to the bottom if scrollable
            if (event.keyCode === KEY_SPACE) {
              event.preventDefault();
            }

            if (event.shiftKey) {
              var lastSelectedItem = table._lastSelectedItems.items[table._lastSelectedItems.items.length - 1];
              var lastSelectedDirection = table._lastSelectedItems.direction; // If no selected items, by default set the first item as last selected item

              if (!table.selectedItem) {
                var rows = table._getSelectableItems();

                if (rows.length) {
                  lastSelectedItem = rows[0];
                  lastSelectedItem.set('selected', true, true);
                }
              } // Don't continue if table has no items or if the last selected item is the clicked item


              if (lastSelectedItem && getIndexOf(row) !== getIndexOf(lastSelectedItem)) {
                // Range selection direction
                var before = getIndexOf(row) < getIndexOf(lastSelectedItem);
                var rangeQuery = before ? 'prevUntil' : 'nextUntil'; // Store direction

                table._lastSelectedItems.direction = before ? 'up' : 'down';

                if (!row.selected) {
                  // Store selection range
                  var selectionRange = getSiblingsOf(lastSelectedItem, 'tr[is="coral-table-row"]:not([selected])', rangeQuery);
                  selectionRange[before ? 'push' : 'unshift'](lastSelectedItem); // Direction change

                  if (!before && lastSelectedDirection === 'up' || before && lastSelectedDirection === 'down') {
                    selectionRange.forEach(function (item) {
                      item.set('selected', false, true);
                    });
                  } // Select item


                  var selectionRangeRow = selectionRange[before ? 0 : selectionRange.length - 1];
                  selectionRangeRow.set('selected', true, true);
                  getSiblingsOf(selectionRangeRow, row, rangeQuery).forEach(function (item) {
                    item.set('selected', true, true);
                  });
                } else {
                  var selection = getSiblingsOf(lastSelectedItem, row, rangeQuery); // If some items are not selected

                  if (selection.some(function (item) {
                    return !item.hasAttribute('selected');
                  })) {
                    // Select all items in between
                    selection.forEach(function (item) {
                      item.set('selected', true, true);
                    }); // Deselect selected item right before/after the selection range

                    getSiblingsOf(row, 'tr[is="coral-table-row"]:not([selected])', rangeQuery).forEach(function (item) {
                      item.set('selected', false, true);
                    });
                  } else {
                    // Deselect items
                    selection[before ? 'push' : 'unshift'](lastSelectedItem);
                    selection.forEach(function (item) {
                      item.set('selected', false, true);
                    });
                  }
                }
              }
            } else {
              // Remove direction if simple click without shift key pressed
              table._lastSelectedItems.direction = null;
            } // Select the row that was clicked and keep the row selected if shift key was pressed


            row.selected = event.shiftKey ? true : !row.selected; // Don't focus the row if the target isn't the row and focusable

            table._focusItem(row, event.target === event.matchedTarget || event.target.tabIndex < 0);
          }
        }
      }
      /** @private */

    }, {
      key: "_onRowLock",
      value: function _onRowLock(event) {
        var table = this;

        if (table.lockable) {
          var row = event.target.closest('tr[is="coral-table-row"]');

          if (row) {
            event.preventDefault();
            event.stopPropagation();
            row.locked = !row.locked; // Refocus the locked/unlocked item manually

            window.requestAnimationFrame(function () {
              table._focusItem(row, true);
            });
          }
        }
      }
      /** @private */

    }, {
      key: "_onRowDown",
      value: function _onRowDown(event) {
        var table = this; // Prevent text-selection

        if (table.selectedItem && event.shiftKey) {
          table.classList.add(IS_UNSELECTABLE); // @polyfill IE
          // Store text selection feature

          var onSelectStart = document.onselectstart; // Kill text selection feature

          document.onselectstart = function () {
            return false;
          }; // Restore text selection feature


          window.requestAnimationFrame(function () {
            document.onselectstart = onSelectStart;
          });
        }
      }
      /** @private */

    }, {
      key: "_onRowDragStart",
      value: function _onRowDragStart(event) {
        var table = this;
        var head = table.head;
        var body = table.body;
        var dragElement = event.detail.dragElement;
        var dragData = dragElement.dragAction._dragData;
        dragData.style.cells = [];
        getCells(dragElement).forEach(function (cell) {
          // Backup styles to restore them later
          dragData.style.cells.push(cell.getAttribute('style')); // Cells will shrink otherwise

          cell.style.width = window.getComputedStyle(cell).width;
        });

        if (head && !head.sticky) {
          // @polyfill ie11
          // Element that scrolls the document.
          var scrollingElement = document.scrollingElement || document.documentElement;
          dragElement.style.top = "".concat(dragElement.getBoundingClientRect().top + scrollingElement.scrollTop, "px");
        }

        dragElement.style.position = 'absolute'; // Setting drop zones allows to listen for coral-dragaction:dragover event

        dragElement.dragAction.dropZone = body.querySelectorAll("tr[is=\"coral-table-row\"]:not(.".concat(IS_DRAGGING_CLASS$2, ")")); // We cannot rely on :focus since the row is being moved in the dom while dnd

        dragElement.classList.add('is-focused');
      }
      /** @private */

    }, {
      key: "_onRowDrag",
      value: function _onRowDrag(event) {
        var table = this;
        var body = table.body;
        var dragElement = event.detail.dragElement;
        var dragData = dragElement.dragAction._dragData;
        var firstRow = getRows([body])[0]; // Insert the placeholder at the top

        if (dragElement.getBoundingClientRect().top <= firstRow.getBoundingClientRect().top) {
          table._preventTriggeringEvents = true;
          body.insertBefore(dragData.placeholder, firstRow);
          window.requestAnimationFrame(function () {
            table._preventTriggeringEvents = false;
          });
        } // Scroll up/down if table edge is reached


        if (dragData.sticky) {
          var dragElementTop = dragElement.getBoundingClientRect().top;
          var position = dragElementTop - dragData.tableTop - dragData.headSize;
          var topScrollLimit = 0;
          var bottomScrollLimit = dragData.tableSize - dragData.dragElementSize - dragData.headSize;
          var scrollOffset = 10; // Handle the scrollbar position based on the dragged element position.
          // nextFrame is required else Chrome wouldn't take scrollTop changes in account when dragging the first row down

          window.requestAnimationFrame(function () {
            if (position < topScrollLimit) {
              table._elements.container.scrollTop -= scrollOffset;
            } else if (position > bottomScrollLimit) {
              table._elements.container.scrollTop += scrollOffset;
            }
          });
        }
      }
      /** @private */

    }, {
      key: "_onRowDragOver",
      value: function _onRowDragOver(event) {
        var table = this;
        var body = table.body;
        var dragElement = event.detail.dragElement;
        var dropElement = event.detail.dropElement;
        var dragData = dragElement.dragAction._dragData; // Swap the placeholder

        if (dragElement.getBoundingClientRect().top >= dropElement.getBoundingClientRect().top) {
          table._preventTriggeringEvents = true;
          body.insertBefore(dragData.placeholder, dropElement.nextElementSibling);
          window.requestAnimationFrame(function () {
            table._preventTriggeringEvents = false;
          });
        }
      }
      /** @private */

    }, {
      key: "_onRowDragEnd",
      value: function _onRowDragEnd(event) {
        var table = this;
        var body = table.body;
        var dragElement = event.detail.dragElement;
        var dragData = dragElement.dragAction._dragData;
        var before = dragData.placeholder.nextElementSibling; // Clean up

        table.classList.remove(IS_FIRST_ITEM_DRAGGED);
        table.classList.remove(IS_LAST_ITEM_DRAGGED);
        body.removeChild(dragData.placeholder);
        dragElement.dragAction.destroy(); // Restore specific styling

        dragElement.setAttribute('style', dragData.style.row || '');
        getCells(dragElement).forEach(function (cell, i) {
          cell.setAttribute('style', dragData.style.cells[i] || '');
        }); // Trigger the event on table

        var beforeEvent = table.trigger('coral-table:beforeroworder', {
          row: dragElement,
          before: before
        });

        if (!beforeEvent.defaultPrevented) {
          // Did row order change ?
          var rows = getRows([body]).filter(function (item) {
            return item !== dragElement;
          });

          if (dragData.index !== rows.indexOf(dragData.placeholder)) {
            // Insert the row at the new position and prevent change event from triggering
            table._preventTriggeringEvents = true;
            body.insertBefore(dragElement, before);
            window.requestAnimationFrame(function () {
              table._preventTriggeringEvents = false;
            }); // Trigger the order event if the row position changed

            table.trigger('coral-table:roworder', {
              row: dragElement,
              oldBefore: dragData.oldBefore,
              before: before
            });
          }
        } // Refocus the dragged element manually


        window.requestAnimationFrame(function () {
          dragElement.classList.remove('is-focused');

          table._focusItem(dragElement, true);
        });
      }
      /** @private */

    }, {
      key: "_onRowMultipleChanged",
      value: function _onRowMultipleChanged(event) {
        event.stopImmediatePropagation();
        var table = this;
        var row = event.target; // Deselect all except last

        if (!row.multiple) {
          var selectedItems = row.selectedItems;
          table._preventTriggeringEvents = true;
          selectedItems.forEach(function (cell, i) {
            cell.selected = i === selectedItems.length - 1;
          });
          window.requestAnimationFrame(function () {
            table._preventTriggeringEvents = false;
            table.trigger('coral-table:rowchange', {
              oldSelection: selectedItems,
              selection: row.selectedItems,
              row: row
            });
          });
        }
      }
      /** @private */

    }, {
      key: "_onBeforeRowSelectionChanged",
      value: function _onBeforeRowSelectionChanged(event) {
        event.stopImmediatePropagation(); // In single selection, if the added item is selected, the rest should be deselected

        var selectedItem = this.selectedItem;

        if (!this.multiple && selectedItem && !event.target.selected) {
          selectedItem.set('selected', false, true);

          this._removeLastSelectedItem(selectedItem);
        }
      }
      /** @private */

    }, {
      key: "_syncSelectAllHandle",
      value: function _syncSelectAllHandle(selectedItems, items) {
        if (items.length && selectedItems.length === items.length) {
          this._setSelectAllHandleState('checked');
        } else if (!selectedItems.length) {
          this._setSelectAllHandleState('unchecked');
        } else {
          this._setSelectAllHandleState('indeterminate');
        }
      }
      /** @private */

    }, {
      key: "_setSelectAllHandleState",
      value: function _setSelectAllHandleState(state) {
        var handle = this.querySelector('[coral-table-select]');

        if (handle) {
          // If the handle is a checkbox but lacks a label, label it with "Select All".
          if (handle.tagName === 'CORAL-CHECKBOX') {
            if (!handle.labelled) {
              handle.setAttribute('labelled', i18n.get('Select All'));
            }

            if (!handle.title) {
              handle.setAttribute('title', i18n.get('Select All'));
            }
          }

          if (state === 'checked') {
            handle.removeAttribute('indeterminate');
            handle.setAttribute('checked', '');
          } else if (state === 'unchecked') {
            handle.removeAttribute('indeterminate');
            handle.removeAttribute('checked');
          } else if (state === 'indeterminate') {
            handle.setAttribute('indeterminate', '');
          }
        }
      }
      /** @private */

    }, {
      key: "_onRowSelectionChanged",
      value: function _onRowSelectionChanged(event) {
        event.stopImmediatePropagation();

        this._triggerChangeEvent();

        var table = this;
        var body = table.body;
        var row = event.target; // Synchronise the table select handle

        if (body && body.contains(row)) {
          var selection = table.selectedItems;

          var rows = table._getSelectableItems(); // Sync select all handle


          table._syncSelectAllHandle(selection, rows); // Store or remove the row reference


          table[row.selected ? '_addLastSelectedItem' : '_removeLastSelectedItem'](row); // Store selected items range

          var lastSelectedItem = table._lastSelectedItems.items[table._lastSelectedItems.items.length - 1];
          var next = table._lastSelectedItems.direction === 'down';

          if (row.selected && lastSelectedItem && lastSelectedItem.selected && getSiblingsOf(lastSelectedItem, 'tr[is="coral-table-row"][selected]', next ? 'next' : 'prev')) {
            getSiblingsOf(lastSelectedItem, 'tr[is="coral-table-row"]:not([selected])', next ? 'nextUntil' : 'prevUntil').forEach(function (item) {
              table._addLastSelectedItem(item);
            });
          }
        }
      }
    }, {
      key: "_onRowLockedChanged",
      value: function _onRowLockedChanged(event) {
        event.stopImmediatePropagation();
        var table = this;
        var body = this.body;
        var row = event.target;

        if (body && body.contains(row)) {
          if (row.locked) {
            // Store the row index as reference to place it back if unlocked and its selection state
            row._rowIndex = getIndexOf(row); // Insert row at first position of its tbody

            table._preventTriggeringEvents = true;
            body.insertBefore(row, getRows([body])[0]);
            window.requestAnimationFrame(function () {
              table._preventTriggeringEvents = false;
            }); // Trigger event on table

            table.trigger('coral-table:rowlock', {
              row: row
            });
          } else {
            // Put the row back to its initial position
            if (row._rowIndex >= 0) {
              var beforeRow = getRows([body])[row._rowIndex];

              if (beforeRow) {
                // Insert row at its initial position
                table._preventTriggeringEvents = true;
                body.insertBefore(row, beforeRow.nextElementSibling);
                window.requestAnimationFrame(function () {
                  table._preventTriggeringEvents = false;
                });
              }
            } // Trigger event on table


            table.trigger('coral-table:rowunlock', {
              row: row
            });
          }
        }
      }
    }, {
      key: "_onHeadContentChanged",
      value: function _onHeadContentChanged(event) {
        event.stopImmediatePropagation();
        var table = this;
        var head = table.head;
        var addedNodes = event.detail.addedNodes;

        for (var i = 0; i < addedNodes.length; i++) {
          var node = addedNodes[i]; // Sync header cell whether sticky or not

          if (isTableHeaderCell(node)) {
            table._toggleStickyHeaderCell(node, head.sticky);
          }
        }
      }
      /** @private */

    }, {
      key: "_onBodyContentChanged",
      value: function _onBodyContentChanged(event) {
        if (event.stopImmediatePropagation) {
          event.stopImmediatePropagation();
        }

        var table = this;
        var addedNodes = event.detail.addedNodes;
        var removedNodes = event.detail.removedNodes;
        var addedNode = null;

        var selectItem = function selectItem(item) {
          item.selected = item === addedNode;
        };

        var changed = false; // Sync added nodes

        for (var i = 0; i < addedNodes.length; i++) {
          addedNode = addedNodes[i]; // Sync row state with table properties

          if (isTableRow(addedNode)) {
            changed = true;

            addedNode._toggleSelectable(table.selectable);

            addedNode._toggleOrderable(table.orderable);

            addedNode._toggleLockable(table.lockable); // @compat


            this._toggleSelectionCheckbox(addedNode);

            var selectedItems = table.selectedItems;

            if (addedNode.selected) {
              // In single selection, if the added item is selected, the rest should be deselected
              if (!table.multiple && selectedItems.length > 1) {
                selectedItems.forEach(selectItem);
              }

              table._triggerChangeEvent();
            } // Cells are selectable too


            if (addedNode.selectable) {
              addedNode.trigger('coral-table-row:_contentchanged', {
                addedNodes: getContentCells(addedNode),
                removedNodes: []
              });
            } // Trigger collection event


            if (!table._preventTriggeringEvents) {
              table.trigger('coral-collection:add', {
                item: addedNode
              });
            } // a11y


            table._toggleFocusable();
          }
        } // Sync removed nodes


        for (var k = 0; k < removedNodes.length; k++) {
          var removedNode = removedNodes[k];

          if (isTableRow(removedNode)) {
            changed = true; // If the focusable item is removed, the first item becomes the new focusable item

            if (removedNode.getAttribute('tabindex') === '0') {
              var firstItem = getRows([table.body])[0];

              if (firstItem) {
                table._focusItem(firstItem);
              }
            }

            if (removedNode.selected) {
              table._triggerChangeEvent();
            } // Sync _lastSelectedItems array


            var removedItemIndex = table._lastSelectedItems.items.indexOf(removedNode);

            if (removedItemIndex !== -1) {
              table._lastSelectedItems.items = table._lastSelectedItems.items.splice(removedItemIndex, 1);
            } // Trigger collection event


            if (!table._preventTriggeringEvents) {
              table.trigger('coral-collection:remove', {
                item: removedNode
              });
            }
          }
        }

        if (changed) {
          var items = this._getSelectableItems(); // Sync select all handle if any.


          table._syncSelectAllHandle(table.selectedItems, items); // Disable table features if no items.


          table._toggleInteractivity(items.length === 0);
        }
      }
      /** @private */

    }, {
      key: "_onBodyEmpty",
      value: function _onBodyEmpty(event) {
        event.stopImmediatePropagation();

        this._toggleInteractivity(true);
      }
      /** @private */

    }, {
      key: "_onRowChange",
      value: function _onRowChange(event) {
        event.stopImmediatePropagation();

        if (!this._preventTriggeringEvents) {
          this.trigger('coral-table:rowchange', {
            oldSelection: event.detail.oldSelection,
            selection: event.detail.selection,
            row: event.target
          });
        }
      }
      /** @private */

    }, {
      key: "_onRowContentChanged",
      value: function _onRowContentChanged(event) {
        event.stopImmediatePropagation();
        var table = this;
        var row = event.target;
        var addedNodes = event.detail.addedNodes;
        var addedNode = null;
        var removedNodes = event.detail.removedNodes;

        var selectItem = function selectItem(item) {
          item.selected = item === addedNode;
        }; // Sync added nodes


        for (var i = 0; i < addedNodes.length; i++) {
          addedNode = addedNodes[i]; // Sync row state with table properties

          if (isTableCell(addedNode)) {
            addedNode._toggleSelectable(row.selectable);

            var selectedItems = row.selectedItems;

            if (addedNode.selected) {
              // In single selection, if the added item is selected, the rest should be deselected
              if (!row.multiple && selectedItems.length > 1) {
                selectedItems.forEach(selectItem);
              }

              row._triggerChangeEvent();
            } // Trigger collection event


            if (!table._preventTriggeringEvents) {
              row.trigger('coral-collection:add', {
                item: addedNode
              });
            }
          } // Add appropriate scope depending on whether headercell is in THEAD or TBODY
          else if (isTableHeaderCell(addedNode)) {
              table._setHeaderCellScope(addedNode, row.parentNode);
            }
        } // Sync removed nodes


        for (var k = 0; k < removedNodes.length; k++) {
          var removedNode = removedNodes[k];

          if (isTableCell(removedNode)) {
            if (removedNode.selected) {
              row._triggerChangeEvent();
            } // Trigger collection event


            if (!table._preventTriggeringEvents) {
              row.trigger('coral-collection:remove', {
                item: removedNode
              });
            }
          }
        }
      }
      /** @private */

    }, {
      key: "_toggleInteractivity",
      value: function _toggleInteractivity(disable) {
        var table = this;
        var selectAll = table.querySelector('[coral-table-select]');

        if (selectAll) {
          selectAll.disabled = disable;
        }

        table.classList.toggle(IS_DISABLED, disable);
      }
    }, {
      key: "_onAlignmentChanged",
      value: function _onAlignmentChanged(event) {
        event.stopImmediatePropagation();

        this._resetAlignmentColumns();
      }
      /** @private */

    }, {
      key: "_onFixedWidthChanged",
      value: function _onFixedWidthChanged(event) {
        event.stopImmediatePropagation();
        var table = this;
        var head = table.head;
        var column = event.target;

        if (head) {
          var headRows = getRows([head]);
          var columnIndex = getIndexOf(event.target);
          headRows.forEach(function (row) {
            var headerCell = getCellByIndex(row, columnIndex);

            if (headerCell && headerCell.tagName === 'TH') {
              headerCell[column.fixedWidth ? 'setAttribute' : 'removeAttribute']('fixedwidth', '');
            }
          });
        }

        table._resetLayout();
      }
      /** @private */

    }, {
      key: "_onColumnOrderableChanged",
      value: function _onColumnOrderableChanged(event) {
        event.stopImmediatePropagation();
        var table = this;
        var head = this.head;
        var column = event.target;

        var headerCell = table._getColumnHeaderCell(column);

        if (headerCell) {
          // Move the drag handle
          table._toggleDragActionHandle(headerCell, head && head.sticky);

          table._resetLayout();
        }
      }
      /** @private */

    }, {
      key: "_onColumnSortableChanged",
      value: function _onColumnSortableChanged(event) {
        event.stopImmediatePropagation();
        var table = this;
        var head = this.head;
        var column = event.target;

        var headerCell = table._getColumnHeaderCell(column);

        if (headerCell) {
          // For icons (chevron up/down) styling
          headerCell[column.sortable ? 'setAttribute' : 'removeAttribute']('sortable', ''); // Toggle tab index. Sortable headercells are focusable.

          table._toggleHeaderCellTabIndex(headerCell, head && head.sticky);

          table._resetLayout();
        }
      }
    }, {
      key: "_onColumnSortableDirectionChanged",
      value: function _onColumnSortableDirectionChanged(event) {
        var _this2 = this;

        event.stopImmediatePropagation();
        var table = this;
        var column = event.target;
        var sortableDirection = TableColumn.sortableDirection; // Hide coral-table-roworder handles if table is sorted

        table.classList.toggle(IS_SORTED, table._isSorted());

        var headerCell = table._getColumnHeaderCell(column);

        if (headerCell) {
          // For icons (chevron up/down) styling
          headerCell.setAttribute('sortabledirection', column.sortableDirection);
          (table.head.sticky ? headerCell.content : headerCell).setAttribute('aria-sort', column.sortableDirection === sortableDirection.DEFAULT ? 'none' : column.sortableDirection);

          if (column.sortableDirection === sortableDirection.DEFAULT) {
            this._elements.liveRegion.innerText = '';
          } else {
            var textContent = headerCell.content.textContent.trim();

            if (textContent.length) {
              // Set live region to true so that sort description string will be announced.
              this._elements.liveRegion.setAttribute('aria-live', 'polite');

              this._elements.liveRegion.removeAttribute('aria-hidden');

              this._elements.liveRegion.innerText = i18n.get("sorted by column {0} in ".concat(column.sortableDirection, " order"), textContent); // @a11y wait 2.5 seconds to give screen reader enough time to announce the live region before silencing the it.

              window.setTimeout(function () {
                _this2._elements.liveRegion.setAttribute('aria-live', 'off');

                _this2._elements.liveRegion.setAttribute('aria-hidden', 'true');
              }, 2500);
            }
          }
        }
      }
    }, {
      key: "_onColumnHiddenChanged",
      value: function _onColumnHiddenChanged(event) {
        event.stopImmediatePropagation();

        this._resetHiddenColumns(true);
      }
    }, {
      key: "_onBeforeColumnSort",
      value: function _onBeforeColumnSort(event) {
        event.stopImmediatePropagation();
        var table = this;
        var column = event.target;
        var newSortableDirection = event.detail.newSortableDirection;
        var beforeEvent = table.trigger('coral-table:beforecolumnsort', {
          column: column,
          direction: newSortableDirection
        });

        if (!beforeEvent.defaultPrevented) {
          column.sortableDirection = newSortableDirection;
        }
      }
    }, {
      key: "_onColumnSort",
      value: function _onColumnSort(event) {
        var _this3 = this;

        event.stopImmediatePropagation(); // Don't sort yet

        if (!this._allowSorting) {
          return;
        }

        var table = this;
        var body = table.body;
        var column = event.target;
        var columnIndex = getIndexOf(column);

        var colHeaderCell = table._getColumnHeaderCell(column);

        var onInitialization = event.detail.onInitialization;
        var sortableDirection = event.detail.sortableDirection;
        var sortableType = event.detail.sortableType;
        var rows = getRows([body]);
        var cells = []; // Prevent change event from triggering when sorting

        if (table) {
          table._preventTriggeringEvents = true;
        } // Store a reference of the default row index for default sortable direction


        rows.forEach(function (row, i) {
          if (typeof row._defaultRowIndex === 'undefined') {
            row._defaultRowIndex = i;
          }

          var cell = getCellByIndex(row, columnIndex);

          if (cell) {
            cells.push(cell);
          }
        });

        if (column.sortableDirection === sortableDirection.ASCENDING) {
          // Remove sortable direction on sibling columns
          getSiblingsOf(column, 'col[is="coral-table-column"]').forEach(function (col) {
            col._preventSort = true;
            col.setAttribute('sortabledirection', sortableDirection.DEFAULT);
            col._preventSort = false;
          });

          if (colHeaderCell) {
            // For icons (chevron up/down) styling
            getSiblingsOf(colHeaderCell, 'th[is="coral-table-headercell"]').forEach(function (headerCell) {
              headerCell.setAttribute('sortabledirection', sortableDirection.DEFAULT);
              (table.head.sticky ? headerCell.content : headerCell).setAttribute('aria-sort', 'none');
            });
          } // Use cell value to sort and fallback if not specified


          cells.sort(function (a, b) {
            if (column.sortableType === sortableType.ALPHANUMERIC) {
              var aText = a.value ? a.value : a.textContent;
              var bText = b.value ? b.value : b.textContent;
              return aText.localeCompare(bText);
            } else if (column.sortableType === sortableType.NUMBER) {
              // Remove all spaces and replace commas with dots for decimal values
              var aNumber = parseFloat(a.value ? a.value : a.textContent.replace(/\s+/g, '').replace(/,/g, '.'));
              var bNumber = parseFloat(b.value ? b.value : b.textContent.replace(/\s+/g, '').replace(/,/g, '.'));
              return aNumber > bNumber ? 1 : -1;
            } else if (column.sortableType === sortableType.DATE) {
              var aDate = a.value ? new Date(parseInt(a.value, 10)) : new Date(a.textContent);
              var bDate = b.value ? new Date(parseInt(b.value, 10)) : new Date(b.textContent);
              return aDate > bDate ? 1 : -1;
            }
          }); // Only sort if not custom sorting

          if (column.sortableType !== sortableType.CUSTOM) {
            if (body) {
              // Insert the row at the new position if actually sorted
              cells.forEach(function (cell) {
                var row = cell.parentElement; // Prevent locked row to be sorted

                if (!row.locked) {
                  body.appendChild(row);
                }
              });
            } // Trigger on table


            table.trigger('coral-table:columnsort', {
              column: column
            });
          } // Table is in a sorted state. Disable orderable actions


          rows.forEach(function (row) {
            if (row.dragAction) {
              row.dragAction.destroy();
            }
          });
        } else if (column.sortableDirection === sortableDirection.DESCENDING) {
          getSiblingsOf(column, 'col[is="coral-table-column"]').forEach(function (col) {
            col._preventSort = true;
            col.setAttribute('sortabledirection', sortableDirection.DEFAULT);
            col._preventSort = false;
          });

          if (colHeaderCell) {
            getSiblingsOf(colHeaderCell, 'th[is="coral-table-headercell"]').forEach(function (headerCell) {
              headerCell.setAttribute('sortabledirection', sortableDirection.DEFAULT);
              (table.head.sticky ? headerCell.content : headerCell).setAttribute('aria-sort', 'none');
            });
          }

          cells.sort(function (a, b) {
            if (column.sortableType === sortableType.ALPHANUMERIC) {
              var aText = a.value ? a.value : a.textContent;
              var bText = b.value ? b.value : b.textContent;
              return bText.localeCompare(aText);
            } else if (column.sortableType === sortableType.NUMBER) {
              // Remove all spaces and replace commas with dots for decimal values
              var aNumber = parseFloat(a.value ? a.value : a.textContent.replace(/\s+/g, '').replace(/,/g, '.'));
              var bNumber = parseFloat(b.value ? b.value : b.textContent.replace(/\s+/g, '').replace(/,/g, '.'));
              return aNumber < bNumber ? 1 : -1;
            } else if (column.sortableType === sortableType.DATE) {
              var aDate = a.value ? new Date(parseInt(a.value, 10)) : new Date(a.textContent);
              var bDate = b.value ? new Date(parseInt(b.value, 10)) : new Date(b.textContent);
              return aDate < bDate ? 1 : -1;
            }
          }); // Only sort if not custom sorting

          if (column.sortableType !== sortableType.CUSTOM) {
            if (body) {
              // Insert the row at the new position if actually sorted
              cells.forEach(function (cell) {
                var row = cell.parentElement; // Prevent locked row to be sorted

                if (!row.locked) {
                  body.appendChild(row);
                }
              });
            } // Trigger on table


            table.trigger('coral-table:columnsort', {
              column: column
            });
          } // Table is in a sorted state. Disable orderable actions


          rows.forEach(function (row) {
            if (row.dragAction) {
              row.dragAction.destroy();
            }
          });
        } else if (column.sortableDirection === sortableDirection.DEFAULT && !onInitialization) {
          // Only sort if not custom sorting
          if (column.sortableType !== sortableType.CUSTOM) {
            // Put rows back to their initial position
            rows.sort(function (a, b) {
              return a._defaultRowIndex > b._defaultRowIndex ? 1 : -1;
            });
            rows.forEach(function (row) {
              // Prevent locked row to be sorted
              if (body && !row.locked) {
                body.appendChild(row);
              }
            }); // Trigger on table

            table.trigger('coral-table:columnsort', {
              column: column
            });
          }
        } // Allow triggering change events again after sorting


        window.requestAnimationFrame(function () {
          // a11y initialize column sort aria-describedby
          if (onInitialization && column.sortableDirection !== sortableDirection.DEFAULT) {
            var textContent = colHeaderCell.content.textContent.trim();

            if (textContent.length) {
              _this3._elements.liveRegion.innerText = i18n.get("sorted by column {0} in ".concat(column.sortableDirection, " order"), textContent);
            }
          }

          table._preventTriggeringEvents = false;
        });
      }
    }, {
      key: "_onHeadStickyChanged",
      value: function _onHeadStickyChanged(event) {
        event.stopImmediatePropagation(); // a11y

        this._toggleFocusable();

        var table = this;
        var head = event.target; // Wait next frame before reading and changing header cell layout

        window.requestAnimationFrame(function () {
          // Defines the head height
          var tableHeight = head.sticky ? "".concat(head.getBoundingClientRect().height, "px") : null;

          table._resetContainerLayout(tableHeight, table._elements.container.style.height);

          getRows([head]).forEach(function (row) {
            getHeaderCells(row).forEach(function (headerCell) {
              table._toggleStickyHeaderCell(headerCell, head.sticky);
            });
          }); // Make sure sticky styling is applied

          table.classList.toggle("".concat(CLASSNAME$1F, "--sticky"), head.sticky); // Layout sticky head

          table._preventResetLayout = false;

          table._resetLayout();
        });
      }
      /** @private */

    }, {
      key: "_getColumnHeaderCell",
      value: function _getColumnHeaderCell(column) {
        var table = this;
        var head = table.head;
        var headerCell = null;

        if (head) {
          var headRows = getRows([head]);
          var columnIndex = getIndexOf(column);

          if (headRows.length) {
            headerCell = getCellByIndex(headRows[headRows.length - 1], columnIndex);
            headerCell = headerCell && headerCell.tagName === 'TH' ? headerCell : null;
          }
        }

        return headerCell;
      }
      /** @private */

    }, {
      key: "_getColumn",
      value: function _getColumn(headerCell) {
        // Get the corresponding column
        return getColumns(this.columns)[getIndexOf(headerCell)] || null;
      }
      /** @private */

    }, {
      key: "_toggleStickyHeaderCell",
      value: function _toggleStickyHeaderCell(headerCell, sticky) {
        // Set the size
        this._layoutStickyCell(headerCell, sticky); // Define DragAction on the sticky cell instead of the headercell


        this._toggleDragActionHandle(headerCell, sticky); // Toggle tab index. Sortable headercells are focusable.


        this._toggleHeaderCellTabIndex(headerCell, sticky);
      }
    }, {
      key: "_layoutStickyCell",
      value: function _layoutStickyCell(headerCell, sticky) {
        if (sticky) {
          var computedStyle = window.getComputedStyle(headerCell); // Don't allow the column to shrink less than its minimum allowed

          if (!headerCell.style.minWidth) {
            var hasVisibleChildNodes = false; // In most cases, there's text content

            if (headerCell.textContent.trim().length) {
              hasVisibleChildNodes = true;
            } // Verify if there are any visible nodes without text content which could take layout space
            else {
                var headerCellChildren = headerCell.content.children;

                for (var i = 0; i < headerCellChildren.length && !hasVisibleChildNodes; i++) {
                  if (headerCellChildren[0].offsetParent) {
                    hasVisibleChildNodes = true;
                  }
                }
              }

            if (hasVisibleChildNodes) {
              var width = headerCell.content.getBoundingClientRect().width; // Don't set the width if the header cell is hidden

              if (width > 0) {
                headerCell.style.minWidth = "".concat(width, "px");
              }
            }
          }

          var cellWidth = parseFloat(computedStyle.width);
          var cellPadding = parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);
          var borderRightWidth = parseFloat(computedStyle.borderRightWidth); // Reflect headercell size on sticky cell

          headerCell.content.style.width = "".concat(cellWidth + cellPadding + borderRightWidth, "px");
        } else {
          // Restore headercell style
          headerCell.style.minWidth = '';
          headerCell.content.style.width = '';
          headerCell.content.style.height = '';
          headerCell.content.style.top = '';
          headerCell.content.style.marginLeft = '';
          headerCell.content.style.paddingTop = '';
        }
      }
      /** @private */

    }, {
      key: "_toggleDragActionHandle",
      value: function _toggleDragActionHandle(headerCell, sticky) {
        var column = this._getColumn(headerCell);

        if (headerCell.dragAction) {
          headerCell.dragAction.destroy();
        }

        if (headerCell.content.dragAction) {
          headerCell.content.dragAction.destroy();
        }

        if (column && column.orderable) {
          var dragAction = new DragAction(sticky ? headerCell.content : headerCell);
          dragAction.axis = 'horizontal'; // Handle the scroll in table

          dragAction.scroll = false;
          headerCell.setAttribute('orderable', '');
        } else {
          headerCell.removeAttribute('orderable');
        }
      }
      /** @private */

    }, {
      key: "_toggleFocusable",
      value: function _toggleFocusable() {
        var firstItem = getRows([this.body])[0];

        if (!firstItem) {
          return;
        }

        var focusableItem = this._getFocusableItem();

        if (this.selectable || this.lockable || this.orderable || this.head && this.head.sticky) {
          // First item is focusable by default but don't remove the tabindex of the existing focusable item
          if (!focusableItem) {
            this._toggleElementTabIndex(firstItem);
          }
        } else if (focusableItem) {
          // Basic table is not focusable
          focusableItem.removeAttribute('tabindex');
        }
      }
      /** @private */

    }, {
      key: "_toggleElementTabIndex",
      value: function _toggleElementTabIndex(element, oldFocusable, forceFocus) {
        if (oldFocusable) {
          oldFocusable.removeAttribute('tabindex');
        }

        element.setAttribute('tabindex', '0');

        if (forceFocus) {
          element.focus();
        }
      }
      /** @private */

    }, {
      key: "_toggleHeaderCellTabIndex",
      value: function _toggleHeaderCellTabIndex(headerCell, sticky) {
        var column = this._getColumn(headerCell);

        var sortable = column && (column.sortable || column.orderable);
        headerCell[sortable && !sticky ? 'setAttribute' : 'removeAttribute']('tabindex', '0');
        headerCell.content[sortable && sticky ? 'setAttribute' : 'removeAttribute']('tabindex', '0');
      }
      /** @private */

    }, {
      key: "_isSorted",
      value: function _isSorted() {
        var column = null;
        var isSorted = getColumns(this.columns).some(function (col) {
          column = col;
          return col.sortableDirection !== TableColumn.sortableDirection.DEFAULT;
        });
        return isSorted ? column : false;
      }
      /** @private */

    }, {
      key: "_focusEdgeItem",
      value: function _focusEdgeItem(event, first) {
        var items = getRows([this.body]);

        if (items.length) {
          event.preventDefault();

          var item = this._getFocusableItem();

          if (item) {
            item.removeAttribute('tabindex');
          }

          item = items[first ? 0 : items.length - 1];
          item.setAttribute('tabindex', '0');
          item.focus();
        }
      }
      /** @private */

    }, {
      key: "_focusSiblingItem",
      value: function _focusSiblingItem(event, next) {
        var item = this._getFocusableItem();

        if (item) {
          event.preventDefault();
          var siblingItem = getSiblingsOf(item, 'tr[is="coral-table-row"]', next ? 'next' : 'prev');

          if (siblingItem) {
            item.removeAttribute('tabindex');
            siblingItem.setAttribute('tabindex', '0');
            siblingItem.focus();
          }
        }
      }
      /** @private */

    }, {
      key: "_selectSiblingItem",
      value: function _selectSiblingItem(next) {
        var _this4 = this;

        if (this.selectable && this.multiple) {
          var selectedItems = this.selectedItems;
          var lastSelectedItem = this._lastSelectedItems.items[this._lastSelectedItems.items.length - 1];

          if (selectedItems.length) {
            // Prevent selection if we reached the edge
            if (next && lastSelectedItem.matches(':last-of-type') || !next && lastSelectedItem.matches(':first-of-type')) {
              return;
            } // Target sibling item


            var sibling = getSiblingsOf(lastSelectedItem, 'tr[is="coral-table-row"]', next ? 'next' : 'prev');

            if (!sibling.hasAttribute('selected')) {
              lastSelectedItem = sibling;
            } // Store last selection


            this._lastSelectedItems.direction = next ? 'down' : 'up'; // Toggle selection

            lastSelectedItem.selected = !lastSelectedItem.selected;
          } else if (getRows([this.body]).length) {
            var focusableItem = this._getFocusableItem(); // Store last selection


            this._lastSelectedItems.direction = next ? 'down' : 'up'; // Select focusable item by default if no items selected

            focusableItem.selected = true;
          }
        } // Focus last selected item


        window.requestAnimationFrame(function () {
          var itemToFocus = _this4._lastSelectedItems.items[_this4._lastSelectedItems.items.length - 1];

          if (itemToFocus) {
            _this4._focusItem(itemToFocus, true);
          }
        });
      }
      /** @private */

    }, {
      key: "_getFocusableItem",
      value: function _getFocusableItem() {
        return this.body && this.body.querySelector('tr[is="coral-table-row"][tabindex="0"]');
      }
      /** @private */

    }, {
      key: "_getFocusableHeaderCell",
      value: function _getFocusableHeaderCell() {
        return this.head && this.head.querySelector('th[is="coral-table-headercell"][tabindex="0"], coral-table-headercell-label[tabindex="0"]');
      }
      /** @private */

    }, {
      key: "_addLastSelectedItem",
      value: function _addLastSelectedItem(item) {
        if (this._lastSelectedItems.items.indexOf(item) === -1) {
          this._lastSelectedItems.items.push(item);
        } else {
          // Push it at the end
          this._removeLastSelectedItem(item);

          this._addLastSelectedItem(item);
        }
      }
      /** @private */

    }, {
      key: "_removeLastSelectedItem",
      value: function _removeLastSelectedItem(item) {
        this._lastSelectedItems.items.splice(this._lastSelectedItems.items.indexOf(item), 1);
      }
      /** @private */

    }, {
      key: "_focusItem",
      value: function _focusItem(item, forceFocus) {
        this._toggleElementTabIndex(item, this._getFocusableItem(), forceFocus);
      }
      /** @private */

    }, {
      key: "_onFocusFirstItem",
      value: function _onFocusFirstItem(event) {
        this._focusEdgeItem(event, true);
      }
      /** @private */

    }, {
      key: "_onFocusLastItem",
      value: function _onFocusLastItem(event) {
        this._focusEdgeItem(event, false);
      }
      /** @private */

    }, {
      key: "_onFocusNextItem",
      value: function _onFocusNextItem(event) {
        this._focusSiblingItem(event, true);
      }
      /** @private */

    }, {
      key: "_onFocusPreviousItem",
      value: function _onFocusPreviousItem(event) {
        this._focusSiblingItem(event, false);
      }
      /** @private */

    }, {
      key: "_onSelectNextItem",
      value: function _onSelectNextItem() {
        this._selectSiblingItem(true);
      }
      /** @private */

    }, {
      key: "_onSelectPreviousItem",
      value: function _onSelectPreviousItem() {
        this._selectSiblingItem(false);
      }
      /**
       * Call the layout method of table component
       *
       * @param {Boolean} forced
       * If true call the layout method immediately, else wait for timeout
       */

    }, {
      key: "resetLayout",
      value: function resetLayout(forced) {
        forced = transform.boolean(forced);

        if (forced === true) {
          this._doResetLayout();

          this._preventResetLayout = false;
        } else {
          this._resetLayout();
        }
      }
      /** @private */

    }, {
      key: "_doResetLayout",
      value: function _doResetLayout() {
        this.classList.add(IS_LAYOUTING);

        this._resizeStickyHead();

        this._resizeContainer();

        this.classList.remove(IS_LAYOUTING);
      }
      /** @private */

    }, {
      key: "_resetLayout",
      value: function _resetLayout() {
        var _this5 = this;

        if (this._preventResetLayout) {
          return;
        } // Debounce


        if (this._timeout !== null) {
          window.clearTimeout(this._timeout);
        }

        this._timeout = window.setTimeout(function () {
          _this5._timeout = null;

          _this5._doResetLayout(); // Mark table as ready


          _this5.classList.add(IS_READY);
        }, this._wait);
      }
      /** @private */

    }, {
      key: "_resizeStickyHead",
      value: function _resizeStickyHead() {
        var table = this;
        var head = table.head;

        if (head && head.sticky) {
          getRows([head]).forEach(function (row) {
            getHeaderCells(row).forEach(function (headerCell) {
              table._layoutStickyCell(headerCell, true);
            });
          });
        }
      }
      /** @private */

    }, {
      key: "_resizeContainer",
      value: function _resizeContainer() {
        var table = this;
        var head = table.head;

        if (head && head.sticky) {
          var calculatedHeadSize = 0;
          var previousRowHeight = 0; // Reset head layout

          getRows([head]).forEach(function (row, i) {
            var headerCells = getHeaderCells(row);

            if (headerCells.length) {
              var computedStyle = window.getComputedStyle(headerCells[0].content);
              var rowHeight = 0;
              var stickyHeaderCellMinHeight = parseFloat(computedStyle.minHeight); // Divider 'row' or 'cell'  adds a border top

              var borderTop = parseFloat(computedStyle.borderTopWidth);
              headerCells.forEach(function (headerCell) {
                // Reset to default
                headerCell.content.style.height = ''; // The highest header cell defines the row height

                rowHeight = Math.max(rowHeight, headerCell.content.getBoundingClientRect().height);
              }); // Add the row height to the table head height

              calculatedHeadSize += rowHeight;
              headerCells.forEach(function (headerCell) {
                // Expand the header cell height to the row height
                if (rowHeight - borderTop !== stickyHeaderCellMinHeight) {
                  headerCell.content.style.height = "".concat(rowHeight, "px");
                } // Vertically align text in sticky cell by getting the label height


                if (headerCell.content.textContent.trim().length && !headerCell.content.querySelector('coral-checkbox[coral-table-select]')) {
                  var stickyHeaderCellHeight = headerCell.content.getBoundingClientRect().height;
                  var span = document.createElement('span'); // Prevents a recursive table relayout that is triggered from changing the header cell content

                  table._preventResetLayout = true;

                  while (headerCell.content.firstChild) {
                    span.appendChild(headerCell.content.firstChild);
                  }

                  headerCell.content.appendChild(span);
                  var labelHeight = span.getBoundingClientRect().height;
                  var paddingTop = (stickyHeaderCellHeight - labelHeight) / 2;

                  while (span.firstChild) {
                    headerCell.content.appendChild(span.firstChild);
                  }

                  headerCell.content.removeChild(span);
                  headerCell.content.style.paddingTop = "".concat(paddingTop, "px");
                  window.requestAnimationFrame(function () {
                    table._preventResetLayout = false;
                  });
                } // Position the sticky cell


                previousRowHeight = previousRowHeight || rowHeight;
                headerCell.content.style.top = "".concat(i > 0 ? previousRowHeight * i + borderTop * (i - 1) : 0, "px");
              });
            }
          });
          var containerComputedStyle = window.getComputedStyle(this._elements.container);
          var borderTopWidth = parseFloat(containerComputedStyle.borderTopWidth);
          var borderBottomWidth = parseFloat(containerComputedStyle.borderBottomWidth);
          var containerBorderSize = borderTopWidth + borderBottomWidth;
          var containerMarginTop = "".concat(calculatedHeadSize, "px");
          var containerHeight = "calc(100% - ".concat(calculatedHeadSize + containerBorderSize, "px)");

          this._resetContainerLayout(containerMarginTop, containerHeight);
        } else {
          this._resetContainerLayout();
        }
      }
      /** @private */

    }, {
      key: "_resetContainerLayout",
      value: function _resetContainerLayout(marginTop, height) {
        this._elements.container.style.marginTop = marginTop || '';
        this._elements.container.style.height = height || '';
      }
      /** @private */

    }, {
      key: "_resetHiddenColumns",
      value: function _resetHiddenColumns(resetLayout) {
        var _this6 = this;

        this.id = this.id || commons.getUID(); // Delete styles

        this._elements.hiddenStyle.innerHTML = ''; // Render styles for each column

        getColumns(this.columns).forEach(function (column) {
          if (column.hidden) {
            var columnIndex = getIndexOf(column) + 1;
            _this6._elements.hiddenStyle.innerHTML += "\n           #".concat(_this6.id, " ._coral-Table-cell:nth-child(").concat(columnIndex, "),\n           #").concat(_this6.id, " ._coral-Table-headerCell:nth-child(").concat(columnIndex, ") {\n             display: none;\n           }\n        ");
          }
        });

        if (resetLayout) {
          this._resetLayout();
        }
      }
    }, {
      key: "_resetAlignmentColumns",
      value: function _resetAlignmentColumns() {
        var _this7 = this;

        this.id = this.id || commons.getUID(); // Delete styles

        this._elements.alignmentStyle.innerHTML = '';
        getColumns(this.columns).forEach(function (column) {
          var columnAlignment = column.alignment;
          var columnIndex = getIndexOf(column) + 1;
          _this7._elements.alignmentStyle.innerHTML += "\n         #".concat(_this7.id, " ._coral-Table-cell:nth-child(").concat(columnIndex, "),\n         #").concat(_this7.id, " ._coral-Table-headerCell:nth-child(").concat(columnIndex, ") {\n           text-align: ").concat(columnAlignment, ";\n         }\n      ");
        });
      }
      /** @private */

    }, {
      key: "_onScroll",
      value: function _onScroll() {
        var table = this;
        var head = table.head; // Ignore if only vertical scroll

        var scrollLeft = table._elements.container.scrollLeft;

        if (table._lastScrollLeft === scrollLeft) {
          return;
        }

        table._lastScrollLeft = scrollLeft;

        if (head && head.sticky) {
          // Trigger a reflow that will reposition the sticky cells for FF only.
          head.style.margin = '1px';
          window.requestAnimationFrame(function () {
            head.style.margin = ''; // In other browsers e.g Chrome or IE, we need to adjust the position of the sticky cells manually

            if (!table._preventLayoutStickyCellOnScroll) {
              var firstHeaderCell = head.querySelector('tr[is="coral-table-row"] th[is="coral-table-headercell"]');

              if (firstHeaderCell) {
                // Verify if the sticky cells need to be adjusted. If the first one didn't move, we can assume that they
                // all need to be adjusted. By default, the left offset is 1px because of the table border.
                if (table._layoutStickyCellOnScroll || firstHeaderCell.content.offsetLeft === 1) {
                  table._layoutStickyCellOnScroll = true;
                  getRows([head]).forEach(function (row) {
                    getHeaderCells(row).forEach(function (headerCell) {
                      var paddingLeft = parseFloat(window.getComputedStyle(headerCell).paddingLeft);
                      headerCell.content.style.marginLeft = "-".concat(scrollLeft + paddingLeft, "px");
                    });
                  });
                } else {
                  // We don't need to layout the sticky cells manually
                  table._preventLayoutStickyCellOnScroll = true;
                }
              }
            }
          });
        }
      } // @compat

    }, {
      key: "_toggleSelectionCheckbox",
      value: function _toggleSelectionCheckbox(row) {
        var cells = getContentCells(row);

        var renderCheckbox = function renderCheckbox(cell, process) {
          // Support cloneNode
          cell._checkbox = cell._checkbox || cell.querySelector('coral-checkbox'); // Render checkbox if none

          if (!cell._checkbox) {
            cell._checkbox = new Checkbox();
          }

          process(cell._checkbox); // Add checkbox

          cell.insertBefore(cell._checkbox, cell.firstChild);
        };

        cells.forEach(function (cell, i) {
          var isRowSelect = i === 0 && cell.hasAttribute('coral-table-rowselect');
          var isCellSelect = cell.hasAttribute('coral-table-cellselect') || cell.querySelector('coral-checkbox[coral-table-cellselect]');

          if (isRowSelect || isCellSelect) {
            var handle;

            if (isRowSelect) {
              handle = 'coral-table-rowselect';
            }

            if (isCellSelect) {
              handle = 'coral-table-cellselect';
            }

            renderCheckbox(cell, function (checkbox) {
              // Define selection handle
              if (isRowSelect) {
                cell.classList.add('_coral-Table-cell--check');
                cell.removeAttribute(handle);
                checkbox.setAttribute(handle, '');
              } else {
                cell.setAttribute(handle, '');
                checkbox.removeAttribute(handle);
              } // Sync selection


              var isSelected = (isRowSelect ? row : cell).hasAttribute('selected');
              checkbox[isSelected ? 'setAttribute' : 'removeAttribute']('checked', '');
            });
          }
        });
      }
      /** @private */

    }, {
      key: "_setHeaderCellScope",
      value: function _setHeaderCellScope(headerCell, tableSection) {
        // Add appropriate scope depending on whether header cell is in THEAD or TBODY
        var scope = tableSection.nodeName === 'THEAD' || tableSection.nodeName === 'TFOOT' ? 'col' : 'row';

        if (scope === 'col') {
          if (this.head && this.head.sticky) {
            headerCell.setAttribute('role', 'presentation');

            headerCell._elements.content.setAttribute('role', 'columnheader');
          } else {
            headerCell.setAttribute('role', 'columnheader');
          }
        } else {
          headerCell.setAttribute('role', 'rowheader');
        }

        headerCell.setAttribute('scope', scope);
      }
      /**  @private */

    }, {
      key: "_handleMutations",
      value: function _handleMutations(mutations) {
        var _this8 = this;

        mutations.forEach(function (mutation) {
          // Sync added nodes
          for (var k = 0; k < mutation.addedNodes.length; k++) {
            var addedNode = mutation.addedNodes[k];

            if (isTableBody(addedNode)) {
              _this8._onBodyContentChanged({
                target: addedNode,
                detail: {
                  addedNodes: getRows([addedNode]),
                  removedNodes: []
                }
              });
            }
          } // Sync removed nodes


          for (var _k = 0; _k < mutation.removedNodes.length; _k++) {
            var removedNode = mutation.removedNodes[_k];

            if (isTableBody(removedNode)) {
              // Always make sure there's a body content zone
              if (!_this8.body) {
                _this8.body = new TableBody();
              }

              _this8._onBodyContentChanged({
                target: removedNode,
                detail: {
                  addedNodes: [],
                  removedNodes: getRows([removedNode])
                }
              });
            }
          }
        });

        this._resetLayout();
      }
    }, {
      key: "_getSelectableItems",
      value: function _getSelectableItems() {
        return this.items._getSelectableItems().filter(function (item) {
          return !item.querySelector('[coral-table-rowselect][disabled]');
        });
      }
    }, {
      key: "_toggleObserver",
      value: function _toggleObserver(enable) {
        this._observer = this._observer || new MutationObserver(this._handleMutations.bind(this));

        if (enable) {
          this._observer.observe(this, {
            childList: true,
            subtree: true
          });
        } else {
          this._observer.disconnect();
        }
      }
    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        var _this9 = this;

        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1F); // Wrapper should have role="presentation" because it wraps another table

        this.setAttribute('role', 'presentation'); // Default reflected attribute

        if (!this._variant) {
          this.variant = variant$m.DEFAULT;
        }

        var head = this._elements.head;
        var body = this._elements.body;
        var foot = this._elements.foot;
        var columns = this._elements.columns; // Disable observer while rendering template

        this._toggleObserver(false);

        this._elements.head.setAttribute('_observe', 'off');

        this._elements.body.setAttribute('_observe', 'off'); // Render template


        var frag = document.createDocumentFragment();
        frag.appendChild(this._elements.container);
        frag.appendChild(this._elements.liveRegion); // cloneNode support

        var wrapper = this.querySelector('._coral-Table-wrapper-container');

        if (wrapper) {
          wrapper.remove();
        }

        var liveRegion = this.querySelector('._coral-Table-liveRegion');

        if (liveRegion) {
          liveRegion.remove();
        } // Append frag


        this.appendChild(frag); // Call content zone inserts

        this.head = head;
        this.body = body;
        this.foot = foot;
        this.columns = columns; // Set header cell scope

        getRows([this._elements.table]).forEach(function (row) {
          getHeaderCells(row).forEach(function (headerCell) {
            _this9._setHeaderCellScope(headerCell, row.parentNode);
          });
        }); // With a thead and tfoot,

        if (this.head && this.foot) {
          var headRows = getRows([this.head]);
          var footRows = getRows([this.foot]); // if the number of rows in the thead and tfoot match

          if (headRows.length === footRows.length) {
            var redundantFooter = true; // and the textContent of each thead header cell matches the textContent of each tfoot header cell in the same column

            headRows.forEach(function (row, rowIndex) {
              return getHeaderCells(row).forEach(function (headerCell, cellIndex) {
                var footerCell = getHeaderCells(footRows[rowIndex])[cellIndex];

                if (!footerCell || headerCell.textContent.trim() !== footerCell.textContent.trim()) {
                  redundantFooter = false;
                }
              });
            }); // the tfoot is redundant and should be hidden to prevent double or triple voicing of table headers.

            if (redundantFooter) {
              this.foot.setAttribute('aria-hidden', 'true');
            }
          }
        } // Detect table size changes


        commons.addResizeListener(this, this._resetLayout); // Disable table features if no items.

        var items = this._getSelectableItems();

        this._toggleInteractivity(items.length === 0); // Sync selection state


        if (this.selectable) {
          var selectedItems = this.selectedItems; // Sync select all handle if any

          this._syncSelectAllHandle(selectedItems, items); // Sync used collections


          if (selectedItems.length) {
            this._oldSelection = selectedItems;
            this._lastSelectedItems.items = selectedItems;
          }
        } // Sync sorted


        this._allowSorting = true;

        var column = this._isSorted();

        if (column) {
          column._doSort && column._doSort(true);
        } // @compat


        if (this.body) {
          var rows = getRows([this.body]); // Use the first column as selection column

          rows.forEach(function (row) {
            return _this9._toggleSelectionCheckbox(row);
          });
        } // Enable observer again


        this._toggleObserver(true); // Mark table as ready


        if (!this.head || this.head && !this.head.hasAttribute('sticky')) {
          this.classList.add(IS_READY);
        }
      }
      /**
       Triggered before a {@link Table} column gets sorted by user interaction. Can be used to cancel column sorting and define
       custom sorting.
        @typedef {CustomEvent} coral-table:beforecolumnsort
        @property {TableColumn} detail.column
       The column to be sorted.
       @property {String} detail.direction
       The requested sorting direction for the column.
       */

      /**
       Triggered when a {@link Table} column is sorted.
        @typedef {CustomEvent} coral-table:columnsort
        @param {TableColumn} detail.column
       The sorted column.
       */

      /**
       Triggered before a {@link Table} column is dragged. Can be used to cancel column dragging.
        @typedef {CustomEvent} coral-table:beforecolumndrag
        @property {TableColumn} detail.column
       The dragged column.
       @property {TableColumn} detail.before
       The column will be inserted before this sibling column.
       If <code>null</code>, the column is inserted at the end.
       */

      /**
       Triggered when a {@link Table} column is dragged.
        @typedef {CustomEvent} coral-table:columndrag
        @property {TableColumn} detail.column
       The dragged column.
       @property {TableColumn} detail.oldBefore
       The column next sibling before the swap.
       If <code>null</code>, the column was the last item.
       @property {TableColumn} detail.before
       The column is inserted before this sibling column.
       If <code>null</code>, the column is inserted at the end.
       */

      /**
       Triggered before a {@link Table} row is ordered. Can be used to cancel row ordering.
        @typedef {CustomEvent} coral-table:beforeroworder
        @property {TableRow} detail.row
       The row to be ordered.
       @property {TableRow} detail.before
       The row will be inserted before this sibling row.
       If <code>null</code>, the row is inserted at the end.
       */

      /**
       Triggered when a {@link Table} row is ordered.
        @typedef {CustomEvent} coral-table:roworder
        @property {TableRow} detail.row
       The ordered row.
       @property {TableRow} detail.oldBefore
       The row next sibling before the swap.
       If <code>null</code>, the row was the last item.
       @param {TableRow} detail.before
       The row is inserted before this sibling row.
       If <code>null</code>, the row is inserted at the end.
       */

      /**
       Triggered when a {@linked Table} row is locked.
        @typedef {CustomEvent} coral-table:rowlock
        @property {TableRow} detail.row
       The locked row.
       */

      /**
       Triggered when {@link Table} a row is locked.
        @typedef {CustomEvent} coral-table:rowunlock
        @property {TableRow} detail.row
       The unlocked row.
       */

      /**
       Triggered when a {@link Table} row selection changed.
        @typedef {CustomEvent} coral-table:rowchange
        @property {Array.<TableCell>} detail.oldSelection
       The old item selection. When {@link TableRow#multiple}, it includes an Array.
       @property {Array.<TableCell>} detail.selection
       The item selection. When {@link Coral.Table.Row#multiple}, it includes an Array.
       @property {TableRow} detail.row
       The targeted row.
       */

      /**
       Triggered when the {@link Table} selection changed.
        @typedef {CustomEvent} coral-table:change
        @property {Array.<TableRow>} detail.oldSelection
       The old item selection. When {@link Table#multiple}, it includes an Array.
       @property {Array.<TableRow>} detail.selection
       The item selection. When {@link Table#multiple}, it includes an Array.
       */

    }, {
      key: "head",
      get: function get() {
        return this._getContentZone(this._elements.head);
      },
      set: function set(value) {
        this._setContentZone('head', value, {
          handle: 'head',
          tagName: 'thead',
          insert: function insert(head) {
            // Using the native table API allows to position the head element at the correct position.
            this._elements.table.tHead = head; // To init the head observer

            head.setAttribute('_observe', 'on');
          }
        });
      }
      /**
       The body of the table. Multiple bodies are not supported.
        @type {TableBody}
       @contentzone
       */

    }, {
      key: "body",
      get: function get() {
        return this._getContentZone(this._elements.body);
      },
      set: function set(value) {
        this._setContentZone('body', value, {
          handle: 'body',
          tagName: 'tbody',
          insert: function insert(body) {
            this._elements.table.appendChild(body);

            this.items._container = body; // To init the body observer

            body.setAttribute('_observe', 'on');
          }
        });
      }
      /**
       The foot of the table.
        @type {TableFoot}
       @contentzone
       */

    }, {
      key: "foot",
      get: function get() {
        return this._getContentZone(this._elements.foot);
      },
      set: function set(value) {
        this._setContentZone('foot', value, {
          handle: 'foot',
          tagName: 'tfoot',
          insert: function insert(foot) {
            // Using the native table API allows to position the foot element at the correct position.
            this._elements.table.tFoot = foot;
          }
        });
      }
      /**
       The columns of the table.
        @type {TableColumn}
       @contentzone
       */

    }, {
      key: "columns",
      get: function get() {
        return this._getContentZone(this._elements.columns);
      },
      set: function set(value) {
        this._setContentZone('columns', value, {
          handle: 'columns',
          tagName: 'colgroup',
          insert: function insert(content) {
            this._elements.table.appendChild(content);
          }
        });
      }
      /**
       The table's variant. See {@link TableVariantEnum}.
        @type {String}
       @default TableVariantEnum.DEFAULT
       @htmlattribute variant
       @htmlattributereflected
       */

    }, {
      key: "variant",
      get: function get() {
        return this._variant || variant$m.DEFAULT;
      },
      set: function set(value) {
        var _this$classList;

        value = transform.string(value).toLowerCase();
        this._variant = validate.enumeration(variant$m)(value) && value || variant$m.DEFAULT;

        this._reflectAttribute('variant', this._variant);

        (_this$classList = this.classList).remove.apply(_this$classList, ALL_VARIANT_CLASSES$c);

        this.classList.add("".concat(CLASSNAME$1F, "--").concat(this._variant));
      }
      /**
       Whether the items are selectable.
        @type {Boolean}
       @default false
       @htmlattribute selectable
       @htmlattributereflected
       */

    }, {
      key: "selectable",
      get: function get() {
        return this._selectable || false;
      },
      set: function set(value) {
        this._selectable = transform.booleanAttr(value);

        this._reflectAttribute('selectable', this._selectable);

        var rows = getRows([this.body]);

        if (this._selectable) {
          rows.forEach(function (row) {
            row.setAttribute('_selectable', '');
          });
        } else {
          // Clear selection
          rows.forEach(function (row) {
            row.removeAttribute('_selectable');
          });
          this.trigger('coral-table:change', {
            selection: [],
            oldSelection: this._oldSelection
          }); // Sync used collection

          this._oldSelection = [];
          this._lastSelectedItems.items = [];
        } // a11y


        this._toggleFocusable();
      }
      /**
       Whether the table is orderable. If the table is sorted, ordering handles are hidden.
        @type {Boolean}
       @default false
       @htmlattribute orderable
       @htmlattributereflected
       */

    }, {
      key: "orderable",
      get: function get() {
        return this._orderable || false;
      },
      set: function set(value) {
        var _this10 = this;

        this._orderable = transform.booleanAttr(value);

        this._reflectAttribute('orderable', this._orderable);

        getRows([this.body]).forEach(function (row) {
          row[_this10._orderable ? 'setAttribute' : 'removeAttribute']('_orderable', '');
        }); // a11y

        this._toggleFocusable();
      }
      /**
       Whether multiple items can be selected.
        @type {Boolean}
       @default false
       @htmlattribute multiple
       @htmlattributereflected
       */

    }, {
      key: "multiple",
      get: function get() {
        return this._multiple || false;
      },
      set: function set(value) {
        this._multiple = transform.booleanAttr(value);

        this._reflectAttribute('multiple', this._multiple);

        this._elements.table.setAttribute('aria-multiselectable', this._multiple); // Deselect all except last


        if (!this.multiple) {
          var selection = this.selectedItems;

          if (selection.length > 1) {
            selection.forEach(function (row, i) {
              // Don't trigger too many events
              row.set('selected', i === selection.length - 1, true);
            }); // Synchronise the table select handle

            var newSelection = this.selectedItems;

            if (newSelection.length) {
              this._setSelectAllHandleState('indeterminate');
            } else {
              this._setSelectAllHandleState('unchecked');
            }

            this.trigger('coral-table:change', {
              selection: newSelection,
              oldSelection: selection
            }); // Sync used collection

            this._oldSelection = newSelection;
            this._lastSelectedItems.items = newSelection;
          }
        }
      }
      /**
       Whether the table rows can be locked/unlocked. If rows are locked, they float to the top of the table and aren't
       affected by column sorting.
        @type {Boolean}
       @default false
       @htmlattribute lockable
       @htmlattributereflected
       */

    }, {
      key: "lockable",
      get: function get() {
        return this._lockable || false;
      },
      set: function set(value) {
        var _this11 = this;

        this._lockable = transform.booleanAttr(value);

        this._reflectAttribute('lockable', this._lockable);

        getRows([this.body]).forEach(function (row) {
          row[_this11._lockable ? 'setAttribute' : 'removeAttribute']('_lockable', '');
        }); // a11y

        this._toggleFocusable();
      }
      /**
       Specifies <code>aria-labelledby</code> value.
        @type {?String}
       @default null
       @htmlattribute labelledby
       */

    }, {
      key: "labelledBy",
      get: function get() {
        return this._elements.table.getAttribute('aria-labelledby');
      },
      set: function set(value) {
        value = transform.string(value);

        this._elements.table[value ? 'setAttribute' : 'removeAttribute']('aria-labelledby', value);
      }
      /**
       Specifies <code>aria-label</code> value.
        @type {String}
       @default null
       @htmlattribute labelled
       */

    }, {
      key: "labelled",
      get: function get() {
        return this._elements.table.getAttribute('aria-label');
      },
      set: function set(value) {
        value = transform.string(value);

        this._elements.table[value ? 'setAttribute' : 'removeAttribute']('aria-label', value);
      }
      /**
       Returns an Array containing the selected items.
        @type {Array.<HTMLElement>}
       @readonly
       */

    }, {
      key: "selectedItems",
      get: function get() {
        return this.items._getAllSelected();
      }
      /**
       Returns the first selected item of the table. The value <code>null</code> is returned if no element is
       selected.
        @type {HTMLElement}
       @readonly
       */

    }, {
      key: "selectedItem",
      get: function get() {
        return this.items._getFirstSelected();
      }
      /**
       The Collection Interface that allows interacting with the items that the component contains.
        @type {SelectableCollection}
       @readonly
       */

    }, {
      key: "items",
      get: function get() {
        // Construct the collection on first request
        if (!this._items) {
          this._items = new SelectableCollection({
            host: this,
            container: this.body,
            itemBaseTagName: 'tr',
            itemTagName: 'coral-table-row'
          });
        }

        return this._items;
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          tbody: 'body',
          thead: 'head',
          tfoot: 'foot',
          colgroup: 'columns'
        };
      }
      /**
       Returns {@link Table} variants.
        @return {TableVariantEnum}
       */

    }], [{
      key: "variant",
      get: function get() {
        return variant$m;
      }
      /**
       Returns divider options for {@link TableHead}, {@link TableBody} and {@link TableFoot}.
        @return {TableSectionDividerEnum}
       */

    }, {
      key: "divider",
      get: function get() {
        return divider;
      }
    }, {
      key: "_attributePropertyMap",
      get: function get() {
        return commons.extend(_get(_getPrototypeOf(_class), "_attributePropertyMap", this), {
          labelledby: 'labelledBy'
        });
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['variant', 'selectable', 'orderable', 'labelled', 'labelledby', 'multiple', 'lockable']);
      }
    }]);

    return _class;
  }(BaseComponent(HTMLTableElement)));

  var CLASSNAME$1G = '_coral-Table-headerCell';
  /**
   @class Coral.Table.HeaderCell
   @classdesc A Table header cell component
   @htmltag coral-table-headercell
   @htmlbasetag th
   @extends {HTMLTableCellElement}
   @extends {BaseComponent}
   */

  var TableHeaderCell = Decorator( /*#__PURE__*/function (_BaseComponent) {
    _inherits(_class, _BaseComponent);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this); // Templates

      _this._elements = {
        content: _this.querySelector('coral-table-headercell-content') || document.createElement('coral-table-headercell-content')
      }; // Watch for content changes in sticky header cell

      _this._stickyCellObserver = new MutationObserver(_this._handleMutations.bind(_assertThisInitialized(_this)));

      _this._stickyCellObserver.observe(_this._elements.content, {
        childList: true,
        subtree: true
      });

      return _this;
    }
    /**
     The header cell's content.
      @type {TableHeaderCellContent}
     @contentzone
     */


    _createClass(_class, [{
      key: "_handleMutations",

      /** @private */
      value: function _handleMutations() {
        this.trigger('coral-table-headercell:_contentchanged');
      }
    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1G); // Fetch or create the content zone element

        var content = this._elements.content;

        if (!content.parentNode) {
          // Move component children into the content
          while (this.firstChild) {
            content.appendChild(this.firstChild);
          }
        } // Assign the content zone so the insert function will be called


        this.content = content;
      }
      /**
       Triggered when the {@link TableHeaderCell} content changed.
        @typedef {CustomEvent} coral-table-headercell:_contentchanged
        @private
       */

    }, {
      key: "content",
      get: function get() {
        return this._getContentZone(this._elements.content);
      },
      set: function set(value) {
        this._setContentZone('content', value, {
          handle: 'content',
          tagName: 'coral-table-headercell-content',
          insert: function insert(content) {
            this.appendChild(content);
          }
        });
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-table-headercell-content': 'content'
        };
      }
    }]);

    return _class;
  }(BaseComponent(HTMLTableCellElement)));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Table.HeaderCell.Content
   @classdesc The Table HeaderCell content
   @htmltag coral-table-headercell-content
   @return {HTMLElement}
   */
  var TableHeaderCellContent = (function () {
    return document.createElement('coral-table-headercell-content');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons.extend(strings, {
    'coral-component-table': translations$n
  }); // Expose component on the Coral namespace

  commons._define('coral-table-column', TableColumn, {
    extends: 'col'
  });

  commons._define('coral-table-cell', TableCell, {
    extends: 'td'
  });

  commons._define('coral-table-headercell', TableHeaderCell, {
    extends: 'th'
  });

  commons._define('coral-table-row', TableRow, {
    extends: 'tr'
  });

  commons._define('coral-table-head', TableHead, {
    extends: 'thead'
  });

  commons._define('coral-table-body', TableBody, {
    extends: 'tbody'
  });

  commons._define('coral-table-foot', TableFoot, {
    extends: 'tfoot'
  });

  commons._define('coral-table', Table, {
    extends: 'table'
  });

  Table.Column = TableColumn;
  Table.Cell = TableCell;
  Table.HeaderCell = TableHeaderCell;
  Table.HeaderCell.Content = TableHeaderCellContent;
  Table.Row = TableRow;
  Table.Head = TableHead;
  Table.Body = TableBody;
  Table.Foot = TableFoot;

  var template$12 = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["icon"] = document.createElement("coral-icon");
    el0.setAttribute("handle", "icon");
    el0.setAttribute("size", "XS");
    el0.className += " _coral-Tabs-item-icon";
    el0.setAttribute("alt", "");
    frag.appendChild(el0);
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    return frag;
  };

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   Gets the target panel of the item.

   @private
   @param {HTMLElement|String} [targetValue]
   A specific target value to use.

   @returns {?HTMLElement}
   */
  function getTarget$1(targetValue) {
    if (targetValue instanceof Node) {
      // Just return the provided Node
      return targetValue;
    } // Dynamically get the target node based on target


    var newTarget = null;

    if (typeof targetValue === 'string' && targetValue.trim() !== '') {
      newTarget = document.querySelector(targetValue);
    }

    return newTarget;
  }

  var CLASSNAME$1H = '_coral-Tabs-item';
  /**
   @class Coral.Tab
   @classdesc A Tab component
   @htmltag coral-tab
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var Tab = Decorator( /*#__PURE__*/function (_BaseLabellable) {
    _inherits(_class, _BaseLabellable);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _thisSuper, _this;

      _classCallCheck(this, _class);

      _this = _super.call(this); // Templates

      _this._elements = {
        label: _this.querySelector('coral-tab-label') || document.createElement('coral-tab-label'),
        invalidIcon: _this.querySelector('._coral-Tabs-itemInvalidIcon') || _this._createInvalidIcon()
      };
      template$12.call(_this._elements); // Listen for mutations

      _this._observer = new MutationObserver(function () {
        // Change icon size if the label is empty
        var icon = _this._elements.icon;

        if (icon) {
          icon.size = _this._elements.label.textContent.trim().length ? Icon.size.EXTRA_SMALL : Icon.size.SMALL;
        }

        _get((_thisSuper = _assertThisInitialized(_this), _getPrototypeOf(_class.prototype)), "_toggleIconAriaHidden", _thisSuper).call(_thisSuper);

        _this.trigger('coral-tab:_sizechanged');
      }); // Watch for changes to the label element

      _this._observer.observe(_this._elements.label, {
        childList: true,
        characterData: true,
        subtree: true
      });

      return _this;
    }
    /**
     The label of the tab.
      @type {TabLabel}
     @contentzone
     */


    _createClass(_class, [{
      key: "_toggleEllipsis",
      value: function _toggleEllipsis() {
        var _this2 = this;

        requestAnimationFrame(function () {
          _this2.classList.toggle('is-overflowing', _this2._elements.label.clientWidth > _this2.clientWidth);
        });
      }
      /**
       Selects the target item
        @ignore
       */

    }, {
      key: "_selectTarget",
      value: function _selectTarget() {
        var realTarget = getTarget$1(this.target); // if the target was define at the tab level, it has precedence over everything

        if (realTarget) {
          realTarget.setAttribute('selected', '');
        } // otherwise, we use the target defined at the tablist level
        else {
            var tabList = this.parentNode;

            if (tabList && tabList.target) {
              realTarget = getTarget$1(tabList.target);

              if (realTarget) {
                // we get the position of this tab inside the tablist
                var currentIndex = tabList.items.getAll().indexOf(this); // we select the item with the same index

                var targetItem = (realTarget.items ? realTarget.items.getAll() : realTarget.children)[currentIndex]; // we select the item if it exists

                if (targetItem) {
                  targetItem.setAttribute('selected', '');
                }
              }
            }
          }
      }
    }, {
      key: "_createInvalidIcon",
      value: function _createInvalidIcon() {
        var iconElement = document.createElement('coral-icon');
        iconElement.icon = 'alert';
        iconElement.size = Icon.size.EXTRA_SMALL;
        iconElement.setAttribute('aria-hidden', 'true');
        iconElement.classList.add('_coral-Tabs-itemInvalidIcon');

        if (!this._invalid) {
          iconElement.setAttribute('hidden', 'true');
        }

        return iconElement;
      }
    }, {
      key: "connectedCallback",

      /** @ignore */
      value: function connectedCallback() {
        _get(_getPrototypeOf(_class.prototype), "connectedCallback", this).call(this); // Query the tab target once the tab item is inserted in the DOM


        if (this.selected) {
          this._selectTarget();
        }
      }
      /** @ignore */

    }, {
      key: "render",
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1H); // adds the role to support accessibility

        this.setAttribute('role', 'tab'); // Generate a unique ID for the tab panel if one isn't already present
        // This will be used for accessibility purposes

        this.setAttribute('id', this.id || commons.getUID()); // Create a fragment

        var frag = document.createDocumentFragment(); // Render the main template

        if (this.icon) {
          frag.appendChild(this._elements.icon);
        }

        if (this._elements.invalidIcon) {
          frag.append(this._elements.invalidIcon);
        }

        var label = this._elements.label; // Remove it so we can process children

        if (label.parentNode) {
          label.parentNode.removeChild(label);
        }

        while (this.firstChild) {
          var child = this.firstChild;

          if (child.nodeType === Node.TEXT_NODE || child.nodeType === Node.ELEMENT_NODE && child.getAttribute('handle') !== 'icon') {
            // Add non-template elements to the label
            label.appendChild(child);
          } else {
            this.removeChild(child);
          }
        } // Add the frag to the component


        this.appendChild(frag); // Assign the content zones, moving them into place in the process

        this.label = label;
      }
    }, {
      key: "label",
      get: function get() {
        return this._getContentZone(this._elements.label);
      },
      set: function set(value) {
        this._setContentZone('label', value, {
          handle: 'label',
          tagName: 'coral-tab-label',
          insert: function insert(label) {
            label.classList.add("".concat(CLASSNAME$1H, "Label"));
            this.appendChild(label);

            this._toggleEllipsis();
          }
        });
      }
      /**
       Specifies the name of the icon used inside the Tab. See {@link Icon} for valid icon names.
        @type {String}
       @default ""
       @htmlattribute icon
       */

    }, {
      key: "icon",
      get: function get() {
        var iconElement = this._elements.icon;
        return iconElement ? iconElement.icon : '';
      },
      set: function set(value) {
        var iconElement = this._elements.icon;
        iconElement.icon = value; // removes the icon element from the DOM.

        if (this.icon === '') {
          iconElement.remove();
          this.trigger('coral-tab:_sizechanged');
        } // adds the icon back since it was blown away by textContent
        else if (!iconElement.parentElement) {
            // Change icon size if the label is empty
            if (!this._elements.label.textContent.trim().length) {
              iconElement.size = Icon.size.SMALL;
            }

            _get(_getPrototypeOf(_class.prototype), "_toggleIconAriaHidden", this).call(this);

            this.insertBefore(iconElement, this.firstChild);
            this.trigger('coral-tab:_sizechanged');
          }
      }
      /**
       Whether the current Tab is invalid.
        @type {Boolean}
       @default false
       @htmlattribute invalid
       @htmlattributereflected
       */

    }, {
      key: "invalid",
      get: function get() {
        return this._invalid || false;
      },
      set: function set(value) {
        this._invalid = transform.booleanAttr(value);

        this._reflectAttribute('invalid', this._invalid);

        this.classList.toggle('is-invalid', this._invalid);
        this.setAttribute('aria-invalid', this._invalid);

        if (this._invalid) {
          this._elements.invalidIcon.removeAttribute('hidden');
        } else {
          this._elements.invalidIcon.setAttribute('hidden', 'true');
        }
      }
      /**
       Whether this Tab is disabled. When set to true, this will prevent every user interacting with the Tab. If
       disabled is set to true for a selected Tab it will be deselected.
        @type {Boolean}
       @default false
       @htmlattribute disabled
       @htmlattributereflected
       */

    }, {
      key: "disabled",
      get: function get() {
        return this._disabled || false;
      },
      set: function set(value) {
        this._disabled = transform.booleanAttr(value);

        this._reflectAttribute('disabled', this._disabled);

        this.classList.toggle('is-disabled', this._disabled);
        this[this._disabled ? 'setAttribute' : 'removeAttribute']('aria-disabled', this._disabled);

        if (this._disabled && this.selected) {
          this.selected = false;
        }

        if (!this._disabled && !this.selected) {
          // We inform the parent to verify if this item should be selected because it's the only one left
          this.trigger('coral-tab:_validateselection');
        }
      }
      /**
       Whether the tab is selected.
       @type {Boolean}
       @default false
       @htmlattribute selected
       @htmlattributereflected
       */

    }, {
      key: "selected",
      get: function get() {
        return this._selected || false;
      },
      set: function set(value) {
        value = transform.booleanAttr(value);

        if (!value || value && !this.disabled) {
          this._selected = value;

          this._reflectAttribute('selected', this.disabled ? false : this._selected);

          this.classList.toggle('is-selected', this._selected);
          this.setAttribute('tabindex', this._selected ? '0' : '-1');
          this.setAttribute('aria-selected', this._selected); // in case the tab is selected, we need to communicate it to the panels.

          if (this._selected) {
            this._selectTarget();
          }

          this.trigger('coral-tab:_selectedchanged');
        }
      }
      /**
       The target element that will be selected when this Tab is selected. It accepts a CSS selector or a DOM element.
       If a CSS Selector is provided, the first matching element will be used.
        @type {?HTMLElement|String}
       @default null
       @htmlattribute target
       */

    }, {
      key: "target",
      get: function get() {
        return typeof this._target === 'string' ? this._target : this._target || null;
      },
      set: function set(value) {
        if (value === null || typeof value === 'string' || value instanceof Node) {
          this._target = value;
          var realTarget = getTarget$1(this.target); // we add proper accessibility if available

          if (realTarget) {
            // creates a 2 way binding for accessibility
            this.setAttribute('aria-controls', realTarget.id);
            realTarget.setAttribute('aria-labelledby', this.id); // adds role to panel to support accessibility

            realTarget.setAttribute('role', 'tabpanel');
          }
        }
      }
      /**
       Inherited from {@link BaseComponent#trackingElement}.
       */

    }, {
      key: "trackingElement",
      get: function get() {
        return typeof this._trackingElement === 'undefined' ? // keep spaces to only 1 max and trim. this mimics native html behaviors
        (this.label || this).textContent.replace(/\s{2,}/g, ' ').trim() : this._trackingElement;
      },
      set: function set(value) {
        _set(_getPrototypeOf(_class.prototype), "trackingElement", value, this, true);
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-tab-label': 'label'
        };
      }
      /** @ignore */

    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['selected', 'disabled', 'icon', 'invalid', 'target']);
      }
    }]);

    return _class;
  }(BaseLabellable(BaseComponent(HTMLElement))));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Tab.Label
   @classdesc Tab's label component
   @htmltag coral-tab-label
   @return {HTMLElement}
   */
  var TabLabel = (function () {
    return document.createElement('coral-tab-label');
  });

  var template$13 = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["line"] = document.createElement("div");
    el0.setAttribute("handle", "line");
    el0.setAttribute("hidden", "");
    el0.className += " _coral-Tabs-selectionIndicator";
    frag.appendChild(el0);
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    return frag;
  };

  /**
   Enumeration for {@link TabList} sizes.

   @typedef {Object} TabListSizeEnum

   @property {String} SMALL
   A small-sized tablist.
   @property {String} MEDIUM
   A medium-sized tablist. This is the default.
   @property {String} LARGE
   A large-sized tablist.
   */

  var size$8 = {
    SMALL: 'S',
    MEDIUM: 'M',
    LARGE: 'L'
  };
  /**
   Enumeration for {@link TabList} orientations.

   @typedef {Object} TabListOrientationEnum

   @property {String} HORIZONTAL
   Horizontal TabList, this is the default value.
   @property {String} VERTICAL
   Vertical TabList.
   */

  var orientation$3 = {
    HORIZONTAL: 'horizontal',
    VERTICAL: 'vertical'
  }; // the tablist's base classname

  var CLASSNAME$1I = '_coral-Tabs';
  /**
   @class Coral.TabList
   @classdesc A TabList component holds a collection of tabs.
   @htmltag coral-tablist
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var TabList = /*#__PURE__*/function (_BaseComponent) {
    _inherits(TabList, _BaseComponent);

    var _super = _createSuper(TabList);

    /** @ignore */
    function TabList() {
      var _this;

      _classCallCheck(this, TabList);

      _this = _super.call(this); // Templates

      _this._elements = {};
      template$13.call(_this._elements); // Attach events

      _this._delegateEvents({
        'click > coral-tab': '_onTabClick',
        'key:home > coral-tab': '_onHomeKey',
        'key:end > coral-tab': '_onEndKey',
        'key:pagedown > coral-tab': '_selectNextItem',
        'key:right > coral-tab': '_selectNextItem',
        'key:down > coral-tab': '_selectNextItem',
        'key:pageup > coral-tab': '_selectPreviousItem',
        'key:left > coral-tab': '_selectPreviousItem',
        'key:up > coral-tab': '_selectPreviousItem',
        'global:coral-commons:_webfontactive': '_setLine',
        // private
        'coral-tab:_selectedchanged': '_onItemSelectedChanged',
        'coral-tab:_validateselection': '_onValidateSelection',
        'coral-tab:_sizechanged': '_setLine'
      }); // Used for eventing


      _this._oldSelection = null; // Debounce timer

      _this._timeout = null; // Debounce wait in milliseconds

      _this._wait = 50;
      _this._setLine = _this._setLine.bind(_assertThisInitialized(_this)); // Init the collection mutation observer

      _this.items._startHandlingItems(true);

      return _this;
    }
    /**
     The Collection Interface that allows interacting with the items that the component contains.
      @type {SelectableCollection}
     @readonly
     */


    _createClass(TabList, [{
      key: "_onItemAdded",

      /** @private */
      value: function _onItemAdded(item) {
        if (!this.selectedItem) {
          item.setAttribute('selected', '');
        } else {
          this._validateSelection(item);
        }
      }
      /** @private */

    }, {
      key: "_onItemRemoved",
      value: function _onItemRemoved() {
        if (!this.selectedItem) {
          this._selectFirstItem();
        }
      }
      /** @private */

    }, {
      key: "_onTabClick",
      value: function _onTabClick(event) {
        event.preventDefault();
        var item = event.matchedTarget;

        this._toggleItemSelectionAndFocus(item);

        this._trackEvent('click', 'coral-tab', event, item);
      }
      /** @private */

    }, {
      key: "_onHomeKey",
      value: function _onHomeKey(event) {
        event.preventDefault();

        var item = this.items._getFirstSelectable();

        this._toggleItemSelectionAndFocus(item);
      }
      /** @private */

    }, {
      key: "_onEndKey",
      value: function _onEndKey(event) {
        event.preventDefault();

        var item = this.items._getLastSelectable();

        this._toggleItemSelectionAndFocus(item);
      }
      /** @private */

    }, {
      key: "_selectNextItem",
      value: function _selectNextItem(event) {
        event.preventDefault();
        var item = this.selectedItem;

        this._toggleItemSelectionAndFocus(this.items._getNextSelectable(item));
      }
      /** @private */

    }, {
      key: "_selectPreviousItem",
      value: function _selectPreviousItem(event) {
        event.preventDefault();
        var item = this.selectedItem;

        this._toggleItemSelectionAndFocus(this.items._getPreviousSelectable(item));
      }
      /** @private */

    }, {
      key: "_toggleItemSelectionAndFocus",
      value: function _toggleItemSelectionAndFocus(item) {
        if (item && !item.hasAttribute('selected')) {
          item.setAttribute('selected', '');
          item.focus();
        }
      }
      /** @private */

    }, {
      key: "_onItemSelectedChanged",
      value: function _onItemSelectedChanged(event) {
        event.stopImmediatePropagation();

        this._validateSelection(event.target);
      }
      /** @private */

    }, {
      key: "_onValidateSelection",
      value: function _onValidateSelection(event) {
        event.stopImmediatePropagation();

        this._validateSelection();
      }
      /** @private */

    }, {
      key: "_selectFirstItem",
      value: function _selectFirstItem() {
        var item = this.items._getFirstSelectable();

        if (item) {
          item.setAttribute('selected', '');
        }
      }
      /** @private */

    }, {
      key: "_validateSelection",
      value: function _validateSelection(item) {
        var _this2 = this;

        var selectedItems = this.items._getAllSelected();

        if (item) {
          // Deselected item
          if (!item.hasAttribute('selected') && !selectedItems.length) {
            var siblingItem = this.items._getNextSelectable(item); // Next selectable item is forced to be selected if selection is cleared


            if (item !== siblingItem) {
              siblingItem.setAttribute('selected', '');
            }
          } // Selected item
          else if (item.hasAttribute('selected') && selectedItems.length > 1) {
              selectedItems.forEach(function (selectedItem) {
                if (selectedItem !== item) {
                  // Don't trigger change events
                  _this2._preventTriggeringEvents = true;
                  selectedItem.removeAttribute('selected');
                }
              }); // We can trigger change events again

              this._preventTriggeringEvents = false;
            }
        } else if (selectedItems.length > 1) {
          // If multiple items are selected, the last one wins
          item = selectedItems[selectedItems.length - 1];
          selectedItems.forEach(function (selectedItem) {
            if (selectedItem !== item) {
              // Don't trigger change events
              _this2._preventTriggeringEvents = true;
              selectedItem.removeAttribute('selected');
            }
          }); // We can trigger change events again

          this._preventTriggeringEvents = false;
        } // First selectable item is forced to be selected if no selection at all
        else if (!selectedItems.length) {
            this._selectFirstItem();
          }

        this._setLine();

        this._triggerChangeEvent();
      }
    }, {
      key: "_setLine",
      value: function _setLine() {
        var _this3 = this;

        window.requestAnimationFrame(function () {
          var selectedItem = _this3.selectedItem; // Position line under the selected item

          if (selectedItem) {
            if (_this3.orientation === orientation$3.HORIZONTAL) {
              var padding = window.parseInt(window.getComputedStyle(selectedItem).paddingLeft);
              var left = selectedItem.offsetLeft + padding;
              var width = selectedItem.clientWidth - padding * 2; // Orientation changed

              if (_this3._previousOrientation !== _this3.orientation) {
                _this3._elements.line.style.height = '';
              }

              _this3._elements.line.style.width = "".concat(width, "px");
              _this3._elements.line.style.transform = "translate(".concat(left, "px, 0)");
            } else if (_this3.orientation === orientation$3.VERTICAL) {
              var top = selectedItem.offsetTop;
              var height = selectedItem.clientHeight; // Orientation changed

              if (_this3._previousOrientation !== _this3.orientation) {
                _this3._elements.line.style.width = '';
              }

              _this3._elements.line.style.height = "".concat(height, "px");
              _this3._elements.line.style.transform = "translate(0, ".concat(top, "px)");
            }

            _this3._elements.line.hidden = false;
          } else {
            // Hide line if no selected item
            _this3._elements.line.hidden = true;
          }

          _this3._previousOrientation = _this3.orientation;
        });
      }
      /** @private */

    }, {
      key: "_triggerChangeEvent",
      value: function _triggerChangeEvent() {
        var selectedItem = this.selectedItem;
        var oldSelection = this._oldSelection;

        if (!this._preventTriggeringEvents && selectedItem !== oldSelection) {
          this.trigger('coral-tablist:change', {
            oldSelection: oldSelection,
            selection: selectedItem
          });
          this._oldSelection = selectedItem;
        }
      }
      /**
       Returns {@link TabList} sizes.
        @return {TabListSizeEnum}
       */

    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(TabList.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1I); // adds the role to support accessibility

        this.setAttribute('role', 'tablist');
        this.setAttribute('aria-multiselectable', 'false'); // Default reflected attributes

        if (!this._size) {
          this.size = size$8.MEDIUM;
        }

        if (!this._orientation) {
          this.orientation = orientation$3.HORIZONTAL;
        } // Support cloneNode


        var template = this.querySelector('._coral-Tabs-selectionIndicator');

        if (template) {
          template.remove();
        } // Insert tab line


        this.appendChild(this._elements.line); // Don't trigger events once connected

        this._preventTriggeringEvents = true;

        this._validateSelection();

        this._preventTriggeringEvents = false;
        this._oldSelection = this.selectedItem; // Display line once tabList is shown

        commons.addResizeListener(this, this._setLine);
      }
      /**
       Triggered when the {@link TabList} selected item has changed.
        @typedef {CustomEvent} coral-tablist:change
        @property {Tab} event.detail.oldSelection
       The prior selected item(s).
       @property {Tab} event.detail.selection
       The newly selected item(s).
       */

    }, {
      key: "items",
      get: function get() {
        // just init on demand
        if (!this._items) {
          this._items = new SelectableCollection({
            host: this,
            itemTagName: 'coral-tab',
            onItemAdded: this._onItemAdded,
            onItemRemoved: this._onItemRemoved
          });
        }

        return this._items;
      }
      /**
       The selected item in the TabList.
        @type {HTMLElement}
       @readonly
       */

    }, {
      key: "selectedItem",
      get: function get() {
        return this.items._getLastSelected();
      }
      /**
       The target component that will be linked to the TabList. It accepts either a CSS selector or a DOM element. If a
       CSS Selector is provided, the first matching element will be used. Items will be selected based on the index. If
       both target and {@link Coral.Tab#target} are set, the second will have higher priority.
        @type {?HTMLElement|String}
       @default null
       @htmlattribute target
       */

    }, {
      key: "target",
      get: function get() {
        return typeof this._target === 'string' ? this._target : this._target || null;
      },
      set: function set(value) {
        var _this4 = this;

        if (value === null || typeof value === 'string' || value instanceof Node) {
          this._target = value; // we do in case the target was not yet in the DOM

          window.requestAnimationFrame(function () {
            var realTarget = getTarget$1(_this4._target); // we add proper accessibility if available

            if (realTarget) {
              var tabItems = _this4.items.getAll();

              var panelItems = realTarget.items ? realTarget.items.getAll() : realTarget.children; // we need to add a11y to all component, no matter if they can be perfectly paired

              var maxItems = Math.max(tabItems.length, panelItems.length);
              var tab;
              var panel;

              for (var i = 0; i < maxItems; i++) {
                tab = tabItems[i];
                panel = panelItems[i]; // if the tab has its own target, we assume the target component will handle its own accessibility. if the
                // target is an empty string we simply ignore it

                if (tab && tab.target && tab.target.trim() !== '') {
                  continue;
                }

                if (tab && panel) {
                  // sets the required ids
                  tab.id = tab.id || commons.getUID();
                  panel.id = panel.id || commons.getUID(); // creates a 2 way binding for accessibility

                  tab.setAttribute('aria-controls', panel.id);
                  panel.setAttribute('aria-labelledby', tab.id); // adds role to panel to support accessibility

                  panel.setAttribute('role', 'tabpanel');
                } else if (tab) {
                  // cleans the aria since there is no matching panel
                  tab.removeAttribute('aria-controls');
                } else {
                  // cleans the aria since there is no matching tab
                  panel.removeAttribute('aria-labelledby');
                }
              }
            }
          });
        }
      }
      /**
       The size of the TabList. It accepts both lower and upper case sizes. Currently only "M" (the default) and "L"
       are available.
       See {@link TabListSizeEnum}.
        @type {String}
       @default TabListSizeEnum.MEDIUM
       @htmlattribute size
       @htmlattributereflected
       */

    }, {
      key: "size",
      get: function get() {
        return this._size || size$8.MEDIUM;
      },
      set: function set(value) {
        value = transform.string(value).toUpperCase();
        this._size = validate.enumeration(size$8)(value) && value || size$8.MEDIUM;

        this._reflectAttribute('size', this._size); // Remove all variant classes


        this.classList.remove("".concat(CLASSNAME$1I, "--compact"), "".concat(CLASSNAME$1I, "--quiet"));

        if (this._size === size$8.SMALL) {
          this.classList.add("".concat(CLASSNAME$1I, "--compact"));
        } else if (this._size === size$8.LARGE) {
          this.classList.add("".concat(CLASSNAME$1I, "--quiet"));
        }
      }
      /**
       Orientation of the TabList. See {@link TabListOrientationEnum}.
        @type {String}
       @default TabListOrientationEnum.HORIZONTAL
       @htmlattribute orientation
       @htmlattributereflected
       */

    }, {
      key: "orientation",
      get: function get() {
        return this._orientation || orientation$3.HORIZONTAL;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        var newValue = typeof this._orientation === 'undefined';
        this._orientation = validate.enumeration(orientation$3)(value) && value || orientation$3.HORIZONTAL;

        if (newValue) {
          this._previousOrientation = this._orientation;
        }

        this._reflectAttribute('orientation', this._orientation);

        this.classList.toggle("".concat(CLASSNAME$1I, "--vertical"), this._orientation === orientation$3.VERTICAL);
        this.classList.toggle("".concat(CLASSNAME$1I, "--horizontal"), this._orientation === orientation$3.HORIZONTAL);

        this._setLine();
      }
    }], [{
      key: "size",
      get: function get() {
        return size$8;
      }
      /**
       Returns {@link TabList} orientation options.
        @return {TabListOrientationEnum}
       */

    }, {
      key: "orientation",
      get: function get() {
        return orientation$3;
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(TabList), "observedAttributes", this).concat(['target', 'size', 'orientation']);
      }
    }]);

    return TabList;
  }(BaseComponent(HTMLElement));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons._define('coral-tab', Tab);

  commons._define('coral-tablist', TabList);

  Tab.Label = TabLabel;

  /**
   Enumeration for {@link TabView} orientations.

   @typedef {Object} TabViewOrientationEnum

   @property {String} HORIZONTAL
   Tabs on top of the panels. This is the default.
   @property {String} VERTICAL
   Tabs are rendered on the side and match the height of the panels.
   */

  var orientation$4 = {
    HORIZONTAL: 'horizontal',
    VERTICAL: 'vertical'
  }; // the tabview's base classname

  var CLASSNAME$1J = '_coral-TabView';
  /**
   @class Coral.TabView
   @classdesc A TabView component is the wrapping container used to create the typical Tabbed pattern.
   This is intended to be used with a {@link TabList} and {@link PanelStack}.
   @htmltag coral-tabview
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var TabView = Decorator( /*#__PURE__*/function (_BaseComponent) {
    _inherits(_class, _BaseComponent);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this); // Prepare templates

      _this._elements = {
        // Fetch or create the content zone elements
        tabList: _this.querySelector('coral-tablist') || document.createElement('coral-tablist'),
        panelStack: _this.querySelector('coral-panelstack') || document.createElement('coral-panelstack')
      }; // Events

      _this._delegateEvents({
        'coral-tablist:change > coral-tablist': '_onTabListChange',
        'coral-panelstack:change > coral-panelstack': '_onPanelStackChange',
        'coral-collection:add > coral-tablist': '_syncTabListAndPanelStack',
        'coral-collection:remove > coral-tablist': '_syncTabListAndPanelStack',
        'coral-collection:add > coral-panelstack': '_syncTabListAndPanelStack',
        'coral-collection:remove > coral-panelstack': '_syncTabListAndPanelStack'
      });

      return _this;
    }
    /**
     The TabView's orientation. See {@link TabViewOrientationEnum}.
      @type {String}
     @default TabViewOrientationEnum.HORIZONTAL
     @htmlattribute orientation
     @htmlattributereflected
     */


    _createClass(_class, [{
      key: "_onNewPanelStack",

      /**
       * This helps in syncing the tablist with new panelstack.
       * This helpful when panelstack is changed for tabview dynamically. 
       * @param {PanelStack} panels new/updated panelstack
       */
      value: function _onNewPanelStack(panels) {
        var tabs = this._elements.tabList; // Bind the tablist and panel stack together, using the panel id

        panels.id = panels.id || commons.getUID();
        tabs.setAttribute('target', "#".concat(panels.id));

        if (tabs.selectedItem) {
          tabs.selectedItem.selected = true;
        }
      }
      /**
       Detects a change in the TabList and triggers an event.
        @private
       */

    }, {
      key: "_onTabListChange",
      value: function _onTabListChange(event) {
        this.trigger('coral-tabview:change', {
          selection: event.detail.selection,
          oldSelection: event.detail.oldSelection
        });
      }
      /** @private */

    }, {
      key: "_onPanelStackChange",
      value: function _onPanelStackChange(event) {
        // everytime the panelstack changes, we verify that the tablist and panelstack are up to date
        if (event.detail.selection) {
          var tabSelector = event.detail.selection.getAttribute('aria-labelledby');
          var tab = document.getElementById(tabSelector); // we select the tab if this was not the case

          if (tab) {
            if (!tab.hasAttribute('selected')) {
              tab.setAttribute('selected', '');
            } else {
              this._trackEvent('display', 'coral-tab', event, event.detail.selection);
            }
          }
        }
      }
      /** @private */

    }, {
      key: "_syncTabListAndPanelStack",
      value: function _syncTabListAndPanelStack() {
        this._elements.tabList.target = this._elements.tabList.target;
      }
    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1J); // Default reflected attributes

        if (!this._orientation) {
          this.orientation = this.orientation;
        } // Fetch or create the content zone elements


        var tabs = this._elements.tabList;
        var panels = this._elements.panelStack; // Bind the tablist and panel stack together, using the panel id

        panels.id = panels.id || commons.getUID();
        tabs.setAttribute('target', "#".concat(panels.id)); // Assign the content zones.

        this.panelStack = panels;
        this.tabList = tabs;
      }
      /**
       Triggered when the {@link TabView} selected tab panel item has changed.
        @typedef {CustomEvent} coral-tabview:change
        @property {Tab} event.detail.selection
       The new selected tab panel item.
       @param {Tab} event.detail.oldSelection
       The prior selected tab panel item.
       */

    }, {
      key: "orientation",
      get: function get() {
        return this._elements.tabList.getAttribute('orientation') || orientation$4.HORIZONTAL;
      },
      set: function set(value) {
        // We rely on the tablist orientation enum so don't need to double check enums
        this._elements.tabList.setAttribute('orientation', value);

        this._reflectAttribute('orientation', this.orientation);

        this.classList[this.orientation === orientation$4.VERTICAL ? 'add' : 'remove']("".concat(CLASSNAME$1J, "--vertical"));
      }
      /**
       The TabList which handles all the tabs.
        @type {TabList}
       @contentzone
       */

    }, {
      key: "tabList",
      get: function get() {
        return this._getContentZone(this._elements.tabList);
      },
      set: function set(value) {
        // Support nested coral-tablist
        if (value instanceof HTMLElement && !value.parentNode || value.parentNode === this) {
          this._setContentZone('tabList', value, {
            handle: 'tabList',
            tagName: 'coral-tablist',
            insert: function insert(tabs) {
              tabs.setAttribute('tracking', 'off');
              this.insertBefore(tabs, this._elements.panelStack || null);
            }
          });
        }
      }
      /**
       The PanelStack which contains all the panels.
        @type {PanelStack}
       @contentzone
       */

    }, {
      key: "panelStack",
      get: function get() {
        return this._getContentZone(this._elements.panelStack);
      },
      set: function set(value) {
        // Support nested coral-panelstack
        if (value instanceof HTMLElement && !value.parentNode || value.parentNode === this) {
          this._setContentZone('panelStack', value, {
            handle: 'panelStack',
            tagName: 'coral-panelstack',
            insert: function insert(panels) {
              this.appendChild(panels);

              this._onNewPanelStack(panels);
            }
          });
        }
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-tablist': 'tabList',
          'coral-panelstack': 'panelStack'
        };
      }
      /**
       Returns {@link TabView} orientation options.
        @return {TabViewOrientationEnum}
       */

    }], [{
      key: "orientation",
      get: function get() {
        return orientation$4;
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['orientation']);
      }
    }]);

    return _class;
  }(BaseComponent(HTMLElement)));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons._define('coral-tabview', TabView);

  var template$14 = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["body"] = document.createElement("div");
    el0.className += " _coral-Toast-body";
    el0.setAttribute("handle", "body");
    frag.appendChild(el0);
    var el1 = document.createTextNode("\n");
    frag.appendChild(el1);
    var el2 = this["buttons"] = document.createElement("div");
    el2.className += " _coral-Toast-buttons";
    el2.setAttribute("handle", "buttons");
    var el3 = document.createTextNode("\n  ");
    el2.appendChild(el3);
    var el4 = document.createElement("button", "coral-button");
    el4.setAttribute("tracking", "off");
    el4.setAttribute("is", "coral-button");
    el4.setAttribute("type", "button");
    el4.setAttribute("variant", "_custom");
    el4.className += " _coral-ClearButton _coral-ClearButton--medium _coral-ClearButton--overBackground";
    el4.setAttribute("coral-close", "");
    var el5 = document.createTextNode("\n    ");
    el4.appendChild(el5);
    var el6 = document.createElement("coral-icon");
    el6.setAttribute("icon", "spectrum-css-icon-CrossMedium");
    el6.className += " _coral-UIIcon-CrossMedium";
    el4.appendChild(el6);
    var el7 = document.createTextNode("\n    ");
    el4.appendChild(el7);
    var el8 = this["buttonLabel"] = document.createElement("coral-button-label");
    el8.setAttribute("handle", "buttonLabel");
    el4.appendChild(el8);
    var el9 = document.createTextNode("\n  ");
    el4.appendChild(el9);
    el2.appendChild(el4);
    var el10 = document.createTextNode("\n");
    el2.appendChild(el10);
    frag.appendChild(el2);
    var el11 = document.createTextNode("\n");
    frag.appendChild(el11);
    return frag;
  };

  /**
   Enumeration for {@link Toast} variants.

   @typedef {Object} ToastVariantEnum

   @property {String} DEFAULT
   A neutral toast.
   @property {String} ERROR
   A toast to notify that an error has occurred or to warn the user of something important.
   @property {String} SUCCESS
   A toast to notify the user of a successful operation.
   @property {String} INFO
   A toast to notify the user of non-critical information.
   */

  var variant$n = {
    DEFAULT: 'default',
    ERROR: 'error',
    SUCCESS: 'success',
    INFO: 'info'
  };
  /**
   Enumeration for {@link Toast} placement values.

   @typedef {Object} ToastPlacementEnum

   @property {String} LEFT
   A toast anchored to the bottom left of screen.
   @property {String} CENTER
   A toast anchored to the bottom center of screen.
   @property {String} RIGHT
   A toast anchored to the bottom right of screen.
   */

  var placement$3 = {
    LEFT: 'left',
    CENTER: 'center',
    RIGHT: 'right'
  };
  var CLASSNAME$1K = '_coral-Toast'; // An array of all possible variant

  var ALL_VARIANT_CLASSES$d = [];

  for (var variantValue$b in variant$n) {
    ALL_VARIANT_CLASSES$d.push("".concat(CLASSNAME$1K, "--").concat(variant$n[variantValue$b]));
  }

  var PRIORITY_QUEUE = [];

  var queue$1 = function queue(el) {
    var priority;
    var type = transform.string(el.getAttribute('variant')).toLowerCase();

    if (type === variant$n.ERROR) {
      priority = el.action ? 1 : 2;
    } else if (type === variant$n.SUCCESS) {
      priority = el.action ? 3 : 6;
    } else if (type === variant$n.INFO) {
      priority = el.action ? 4 : 7;
    } else {
      priority = el.action ? 5 : 8;
    }

    PRIORITY_QUEUE.push({
      el: el,
      priority: priority
    });
  };

  var unqueue = function unqueue() {
    var next = null;
    [1, 2, 3, 4, 5, 6, 7, 8].some(function (priority) {
      return PRIORITY_QUEUE.some(function (item, index) {
        if (item.priority === priority) {
          next = {
            el: item.el,
            index: index
          };
          return true;
        }
      });
    });

    if (next !== null) {
      PRIORITY_QUEUE.splice(next.index, 1);
      next.el.open = true;
    }
  }; // Used to map icon with variant


  var capitalize$4 = function capitalize(s) {
    return s.charAt(0).toUpperCase() + s.slice(1);
  }; // Restriction filter for action button


  var isButton = function isButton(node) {
    return node.nodeName === 'BUTTON' && node.getAttribute('is') === 'coral-button' || node.nodeName === 'A' && node.getAttribute('is') === 'coral-anchorbutton';
  };
  /**
   @class Coral.Toast
   @classdesc Toasts display brief temporary notifications.
   They are noticeable but do not disrupt the user experience and do not require an action to be taken.
   @htmltag coral-toast
   @extends {HTMLElement}
   @extends {BaseComponent}
   @extends {BaseOverlay}
   */


  var Toast = Decorator( /*#__PURE__*/function (_BaseOverlay) {
    _inherits(_class, _BaseOverlay);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this); // Debounce wait time in milliseconds

      _this._wait = 50; // Override defaults from Overlay

      _this._overlayAnimationTime = _this.constructor.FADETIME;
      _this._focusOnShow = _this.constructor.focusOnShow.OFF;
      _this._returnFocus = _this.constructor.returnFocus.ON; // Prepare templates

      _this._elements = {
        // Fetch or create the content zone element
        content: _this.querySelector('coral-toast-content') || document.createElement('coral-toast-content')
      };
      template$14.call(_this._elements);

      _this._delegateEvents({
        'global:resize': '_debounceLayout',
        'global:key:escape': '_onEscape',
        'click [coral-close]': '_onCloseClick',
        'coral-overlay:close': '_onClose'
      }); // Layout any time the DOM changes


      _this._observer = new MutationObserver(function () {
        _this._debounceLayout();
      }); // Watch for changes

      _this._observer.observe(_assertThisInitialized(_this), {
        childList: true,
        subtree: true
      });

      return _this;
    }
    /**
     Whether the Toast will be dismissed automatically after a certain period. The minimum and default value is 5 seconds.
     The dismissible behavior can be disabled by setting the value to <code>0</code>.
     If an actionable toast is set to auto-dismiss, make sure that the action is still accessible elsewhere in the application.
      @type {?Number}
     @default 5000
     @htmlattribute autodismiss
     */


    _createClass(_class, [{
      key: "_renderVariantIcon",
      value: function _renderVariantIcon() {
        if (this._elements.icon) {
          this._elements.icon.remove();
        }

        var variantValue = this.variant; // Default variant has no icon

        if (variantValue === variant$n.DEFAULT) {
          return;
        } // Inject the SVG icon


        var iconName = variantValue === variant$n.ERROR ? 'Alert' : capitalize$4(variantValue);

        var icon = Icon._renderSVG("spectrum-css-icon-".concat(iconName, "Medium"), ['_coral-Toast-typeIcon', "_coral-UIIcon-".concat(iconName, "Medium")]);

        this.insertAdjacentHTML('afterbegin', icon);
        this._elements.icon = this.querySelector('._coral-Toast-typeIcon');
      }
    }, {
      key: "_moveToDocumentBody",
      value: function _moveToDocumentBody() {
        // Not in the DOM
        if (!document.body.contains(this)) {
          document.body.appendChild(this);
        } // In the DOM but not a direct child of body
        else if (this.parentNode !== document.body) {
            this._ignoreConnectedCallback = true;
            this._repositioned = true;
            document.body.appendChild(this);
            this._ignoreConnectedCallback = false;
          }
      }
    }, {
      key: "_debounceLayout",
      value: function _debounceLayout() {
        var _this2 = this;

        // Debounce
        if (this._layoutTimeout !== null) {
          clearTimeout(this._layoutTimeout);
        }

        this._layoutTimeout = window.setTimeout(function () {
          _this2._layoutTimeout = null;

          _this2._position();
        }, this._wait);
      }
    }, {
      key: "_position",
      value: function _position() {
        var _this3 = this;

        if (this.open) {
          requestAnimationFrame(function () {
            if (_this3.placement === placement$3.CENTER) {
              _this3.style.left = "".concat(document.body.clientWidth / 2 - _this3.clientWidth / 2, "px");
              _this3.style.right = '';
            } else if (_this3.placement === placement$3.LEFT) {
              _this3.style.left = 0;
              _this3.style.right = '';
            } else if (_this3.placement === placement$3.RIGHT) {
              _this3.style.left = '';
              _this3.style.right = 0;
            }
          });
        }
      }
    }, {
      key: "_onEscape",
      value: function _onEscape(event) {
        if (this.open && this.classList.contains('is-open') && this._isTopOverlay()) {
          event.stopPropagation();
          this.open = false;
        }
      }
    }, {
      key: "_onCloseClick",
      value: function _onCloseClick(event) {
        var dismissTarget = event.matchedTarget;
        var dismissValue = dismissTarget.getAttribute('coral-close');

        if (!dismissValue || this.matches(dismissValue)) {
          this.open = false;
          event.stopPropagation();
        }
      }
    }, {
      key: "_onClose",
      value: function _onClose() {
        // Unmark it
        this._queued = false; // Continue emptying the queue

        unqueue();
      }
    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1K); // Default reflected attributes

        if (!this._variant) {
          this.variant = variant$n.DEFAULT;
        } // Create a fragment


        var fragment = document.createDocumentFragment();
        var templateHandleNames = ['body', 'buttons']; // Render the template

        fragment.appendChild(this._elements.body);
        fragment.appendChild(this._elements.buttons);
        var content = this._elements.content;

        if (content.parentNode) {
          content.remove();
        }

        var action = this.action;

        if (action) {
          action.remove();
        }

        while (this.firstChild) {
          var child = this.firstChild;

          if (child.nodeType === Node.TEXT_NODE || child.nodeType === Node.ELEMENT_NODE && templateHandleNames.indexOf(child.getAttribute('handle')) === -1) {
            // Add non-template elements to the content
            content.appendChild(child);
          } else {
            // Remove anything else
            this.removeChild(child);
          }
        } // Insert template


        this.appendChild(fragment); // If default variant, does nothing

        this._renderVariantIcon(); // Assign the content zones


        this.content = this._elements.content;
        this.action = action;
      }
      /** @ignore */

    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        var _this4 = this;

        _get(_getPrototypeOf(_class.prototype), "disconnectedCallback", this).call(this);

        if (this._queued) {
          var el = null;
          PRIORITY_QUEUE.some(function (item, index) {
            if (item.el === _this4) {
              _this4._queued = false;
              el = index;
              return true;
            }
          });

          if (el !== null) {
            PRIORITY_QUEUE.splice(el, 1);
          }
        }
      }
    }, {
      key: "autoDismiss",
      get: function get() {
        return typeof this._autoDismiss === 'number' ? this._autoDismiss : 5000;
      },
      set: function set(value) {
        value = transform.number(value);

        if (value !== null) {
          value = Math.abs(value); // Value can't be set lower than 5secs. 0 is an exception.

          if (value !== 0 && value < 5000) {
            commons._log('warn', 'Coral.Toast: the value for autoDismiss has to be 5 seconds minimum.');

            value = 5000;
          }

          this._autoDismiss = value;
        }
      }
      /**
       The actionable item marked with <code>[coral-toast-action]</code>.
       Restricted to {@link Button} or {@link AnchorButton} elements.
       Actionable toasts should not have a button with a redundant action. For example “dismiss” would be redundant as all
       toasts already have a close button.
        @type {HTMLElement}
       @readonly
       */

    }, {
      key: "action",
      get: function get() {
        return this._elements.action || this.querySelector('[coral-toast-action]');
      },
      set: function set(el) {
        if (!el) {
          return;
        }

        if (isButton(el)) {
          this._elements.action = el;
          el.setAttribute('coral-toast-action', '');
          el.setAttribute('variant', Button.variant._CUSTOM);
          el.classList.add('_coral-Button', '_coral-Button--overBackground', '_coral-Button--quiet');

          this._elements.body.appendChild(el);
        } else {
          commons._log('warn', 'Coral.Toast: provided action is not a Coral.Button or Coral.AnchorButton.');
        }
      }
      /**
       Inherited from {@link BaseOverlay#open}.
       */

    }, {
      key: "open",
      get: function get() {
        return _get(_getPrototypeOf(_class.prototype), "open", this);
      },
      set: function set(value) {
        var _this5 = this;

        // Opening only if element is queued
        value = transform.booleanAttr(value);

        if (value && !this._queued) {
          this._open = value; // Mark it

          this._queued = true; // Clear timer

          if (this._dimissTimeout) {
            clearTimeout(this._dimissTimeout);
          } // Add it to the queue


          queue$1(this);
          requestAnimationFrame(function () {
            _this5._reflectAttribute('open', true); // If not child of document.body, we have to move it there


            _this5._moveToDocumentBody();

            requestAnimationFrame(function () {
              // Start emptying the queue
              if (document.querySelectorAll('coral-toast[open]').length === PRIORITY_QUEUE.length) {
                unqueue();
              }
            });
          });
          return;
        }

        _set(_getPrototypeOf(_class.prototype), "open", value, this, true); // Ensure we're in the DOM


        if (this.open) {
          // Position the element
          this._position(); // Handles what to focus based on focusOnShow


          this._handleFocus(); // Use raf to wait for autoDismiss value to be set


          requestAnimationFrame(function () {
            // Only dismiss if value is different than 0
            if (_this5.autoDismiss !== 0) {
              _this5._dimissTimeout = window.setTimeout(function () {
                if (_this5.open && !_this5.contains(document.activeElement)) {
                  _this5.open = false;
                }
              }, _this5.autoDismiss);
            }
          });
        }
      }
      /**
       The Toast variant. See {@link ToastVariantEnum}.
        @type {String}
       @default ToastVariantEnum.DEFAULT
       @htmlattribute variant
       @htmlattributereflected
       */

    }, {
      key: "variant",
      get: function get() {
        return this._variant || variant$n.DEFAULT;
      },
      set: function set(value) {
        var _this$classList;

        value = transform.string(value).toLowerCase();
        this._variant = validate.enumeration(variant$n)(value) && value || variant$n.DEFAULT;

        this._reflectAttribute('variant', this._variant);

        this._renderVariantIcon(); // Remove all variant classes


        (_this$classList = this.classList).remove.apply(_this$classList, ALL_VARIANT_CLASSES$d); // Set new variant class


        this.classList.add("".concat(CLASSNAME$1K, "--").concat(this._variant)); // Set the role attribute to alert or status depending on
        // the variant so that the element turns into a live region

        this.setAttribute('role', this._variant);
        this.setAttribute('aria-live', 'polite');
      }
      /**
       The Toast content element.
        @type {ToastContent}
       @contentzone
       */

    }, {
      key: "content",
      get: function get() {
        return this._getContentZone(this._elements.content);
      },
      set: function set(value) {
        this._setContentZone('content', value, {
          handle: 'content',
          tagName: 'coral-toast-content',
          insert: function insert(content) {
            content.classList.add("".concat(CLASSNAME$1K, "-content")); // After the header

            this._elements.body.insertBefore(content, this._elements.body.firstChild);
          }
        });
      }
      /**
       The Toast placement. See {@link ToastPlacementEnum}.
        @type {String}
       @default ToastPlacementEnum.CENTER
       @htmlattribute placement
       */

    }, {
      key: "placement",
      get: function get() {
        return this._placement || placement$3.CENTER;
      },
      set: function set(value) {
        value = transform.string(value).toLowerCase();
        this._placement = validate.enumeration(placement$3)(value) && value || placement$3.CENTER;

        this._debounceLayout();
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-toast-content': 'content'
        };
      }
    }], [{
      key: "_queue",
      get: function get() {
        return PRIORITY_QUEUE;
      }
      /**
       Returns {@link Toast} placement options.
        @return {ToastPlacementEnum}
       */

    }, {
      key: "placement",
      get: function get() {
        return placement$3;
      }
      /**
       Returns {@link Toast} variants.
        @return {ToastVariantEnum}
       */

    }, {
      key: "variant",
      get: function get() {
        return variant$n;
      }
    }, {
      key: "_attributePropertyMap",
      get: function get() {
        return commons.extend(_get(_getPrototypeOf(_class), "_attributePropertyMap", this), {
          autodismiss: 'autoDismiss'
        });
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['variant', 'placement', 'autodismiss']);
      }
    }]);

    return _class;
  }(BaseOverlay(BaseComponent(HTMLElement))));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Toast.Content
   @classdesc The Toast default content
   @htmltag coral-toast-content
   @return {HTMLElement}
   */
  var ToastContent = (function () {
    return document.createElement('coral-toast-content');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons._define('coral-toast', Toast);

  Toast.Content = ToastContent;

  var template$15 = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var data = data_0 = typeof data_0 === "undefined" ? {} : data_0;
    var el0 = this["header"] = document.createElement("div");
    el0.className += " _coral-TreeView-itemLink";
    el0.setAttribute("tabindex", "-1");
    el0.id = data_0["commons"]["getUID"]();
    el0.setAttribute("handle", "header");
    el0.setAttribute("role", "treeitem");
    var el1 = document.createTextNode("\n  ");
    el0.appendChild(el1);
    var el2 = this["selectedState"] = document.createElement("span");
    el2.className += " u-coral-screenReaderOnly";
    el2.setAttribute("handle", "selectedState");
    el2.setAttribute("role", "presentation");
    el2.id = data_0["commons"]["getUID"]();
    el0.appendChild(el2);
    var el3 = document.createTextNode("\n");
    el0.appendChild(el3);
    frag.appendChild(el0);
    var el4 = document.createTextNode("\n");
    frag.appendChild(el4);
    data = data_0;
    this.header.insertAdjacentHTML('afterbegin', data.Icon._renderSVG('spectrum-css-icon-ChevronRightMedium', ['_coral-TreeView-indicator', '_coral-UIIcon-ChevronRightMedium']));
    data_0 = data;
    var el6 = document.createTextNode("\n");
    frag.appendChild(el6);
    var el7 = this["subTreeContainer"] = document.createElement("div");
    el7.className += " _coral-TreeView";
    el7.setAttribute("handle", "subTreeContainer");
    el7.id = data_0["commons"]["getUID"]();
    el7.setAttribute("role", "group");
    frag.appendChild(el7);
    var el8 = document.createTextNode("\n");
    frag.appendChild(el8);
    return frag;
  };

  var CLASSNAME$1L = '_coral-TreeView-item';
  /**
   Enumeration for {@link TreeItem} variants.

   @typedef {Object} TreeItemVariantEnum

   @property {String} DRILLDOWN
   Default variant with icon to expand/collapse subtree.
   @property {String} LEAF
   Variant for leaf items. Icon to expand/collapse subtree is hidden.
   */

  var variant$o = {
    /* Default variant with icon to expand/collapse subtree. */
    DRILLDOWN: 'drilldown',

    /* Variant for leaf items. Icon to expand/collapse subtree is hidden. */
    LEAF: 'leaf'
  };
  var ALL_VARIANT_CLASSES$e = [];

  for (var variantValue$c in variant$o) {
    ALL_VARIANT_CLASSES$e.push("".concat(CLASSNAME$1L, "--").concat(variant$o[variantValue$c]));
  }

  var IS_TOUCH_DEVICE = 'ontouchstart' in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
  /**
   @class Coral.Tree.Item
   @classdesc A Tree item component
   @htmltag coral-tree-item
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var TreeItem = Decorator( /*#__PURE__*/function (_BaseComponent) {
    _inherits(_class, _BaseComponent);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this); // Prepare templates

      _this._elements = {
        // Create or fetch the content zones
        content: _this.querySelector('coral-tree-item-content') || document.createElement('coral-tree-item-content')
      };
      template$15.call(_this._elements, {
        Icon: Icon,
        commons: commons
      });

      if (!_this._elements.icon) {
        _this._elements.icon = _this._elements.header.querySelector('._coral-TreeView-indicator');
      } // Tells the collection to automatically detect the items and handle the events


      _this.items._startHandlingItems();

      return _this;
    }
    /**
     The parent tree. Returns <code>null</code> if item is the root.
      @type {HTMLElement}
     @readonly
     */


    _createClass(_class, [{
      key: "_filterItem",

      /** @private */
      value: function _filterItem(item) {
        // Handle nesting check for parent tree item
        // Use parentNode for added items
        // Use _parent for removed items
        return item.parentNode && item.parentNode.parentNode === this || item._parent === this;
      }
      /** @private */

    }, {
      key: "_onItemAdded",
      value: function _onItemAdded(item) {
        item._parent = this;
        var header = this._elements.header;
        var subTreeContainer = this._elements.subTreeContainer;

        if (!header.hasAttribute('aria-owns')) {
          header.setAttribute('aria-owns', subTreeContainer.id);
        }
      }
      /** @private */

    }, {
      key: "_onItemRemoved",
      value: function _onItemRemoved(item) {
        item._parent = undefined; // If there are no items the subTreeContainer

        if (!this.items.length) {
          this._elements.header.removeAttribute('aria-owns');
        }
      }
      /**
       Handles the focus of the item.
        @ignore
       */

    }, {
      key: "focus",
      value: function focus() {
        this._elements.header.setAttribute('tabindex', '0');

        this._elements.header.focus();
      }
      /**
       Returns {@link TreeItem} variants.
        @return {TreeItemVariantEnum}
       */

    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1L);
        var header = this._elements.header;
        var subTreeContainer = this._elements.subTreeContainer;
        var content = this._elements.content;
        var selectedState = this._elements.selectedState; // a11ys

        content.id = content.id || commons.getUID();
        this.setAttribute('role', 'presentation');
        header.setAttribute('aria-labelledby', "".concat(content.id, " ").concat(selectedState.id));
        header.setAttribute('aria-selected', this.selected);
        subTreeContainer.setAttribute('aria-labelledby', content.id);
        selectedState.textContent = i18n.get(this.selected ? 'selected' : 'not selected');

        if (IS_TOUCH_DEVICE) {
          var icon = this._elements.icon || header.querySelector('._coral-TreeView-indicator');

          if (icon && !icon.id) {
            icon.id = commons.getUID();
          }

          icon.setAttribute('role', 'button');
          icon.setAttribute('tabindex', '-1');
          icon.setAttribute('aria-labelledby', icon.id + ' ' + content.id);
          icon.setAttribute('aria-label', i18n.get(this.expanded ? 'Collapse' : 'Expand'));
          icon.setAttribute('style', 'outline: none !important');
          icon.removeAttribute('aria-hidden');
          selectedState.setAttribute('role', 'button');
          selectedState.setAttribute('tabindex', '-1');
          selectedState.setAttribute('aria-labelledby', content.id + ' ' + selectedState.id);
          selectedState.setAttribute('aria-pressed', this.selected);
          selectedState.setAttribute('style', 'outline: none !important');
        } // Default reflected attributes


        if (!this._variant) {
          this.variant = variant$o.DRILLDOWN;
        }

        this.expanded = this.expanded; // Render the template and set element references

        var frag = document.createDocumentFragment();
        var templateHandleNames = ['header', 'icon', 'subTreeContainer'];
        var subTree = this.querySelector('._coral-TreeView');

        if (subTree) {
          var items = subTree.querySelectorAll('coral-tree-item');

          for (var i = 0; i < items.length; i++) {
            subTreeContainer.appendChild(items[i]);
          }
        } // Add templates into the frag


        frag.appendChild(header);
        frag.appendChild(subTreeContainer); // Assign the content zones, moving them into place in the process

        this.content = content; // Move any remaining elements into the content sub-component

        while (this.firstChild) {
          var child = this.firstChild;

          if (child.nodeName === 'CORAL-TREE-ITEM') {
            // Adding parent attribute to access the parent directly
            child._parent = this; // Add tree items to the sub tree container

            subTreeContainer.appendChild(child);
          } else if (child.nodeType === Node.TEXT_NODE || child.nodeType === Node.ELEMENT_NODE && templateHandleNames.indexOf(child.getAttribute('handle')) === -1) {
            // Add non-template elements to the content
            content.appendChild(child);
          } else {
            // Remove anything else element
            this.removeChild(child);
          }
        }

        if (this.variant === variant$o.DRILLDOWN && this.items.length && !header.hasAttribute('aria-owns')) {
          header.setAttribute('aria-owns', subTreeContainer.id);
        } // Lastly, add the fragment into the container


        this.appendChild(frag);
      }
      /**
       Triggered when {@link TreeItem#selected} changed.
        @typedef {CustomEvent} coral-tree-item:_selectedchanged
        @private
       */

      /**
       Triggered when {@link TreeItem#expanded} changed.
        @typedef {CustomEvent} coral-tree-item:_expandedchanged
        @private
       */

      /**
       Triggered when {@link TreeItem#hidden} changed.
        @typedef {CustomEvent} coral-tree-item:_hiddenchanged
        @private
       */

      /**
       Triggered when {@link TreeItem#disabled} changed.
        @typedef {CustomEvent} coral-tree-item:_disabledchanged
        @private
       */

    }, {
      key: "parent",
      get: function get() {
        return this._parent || null;
      }
      /**
       The content of this tree item.
        @type {TreeItemContent}
       @contentzone
       */

    }, {
      key: "content",
      get: function get() {
        return this._getContentZone(this._elements.content);
      },
      set: function set(value) {
        this._setContentZone('content', value, {
          handle: 'content',
          tagName: 'coral-tree-item-content',
          insert: function insert(content) {
            this._elements.header.appendChild(content);
          }
        });
      }
      /**
       The Collection Interface that allows interacting with the items that the component contains.
        @type {Collection}
       @readonly
       */

    }, {
      key: "items",
      get: function get() {
        // Construct the collection on first request
        if (!this._items) {
          this._items = new Collection$1({
            host: this,
            itemTagName: 'coral-tree-item',
            itemSelector: ':scope > coral-tree-item',
            onlyHandleChildren: true,
            container: this._elements.subTreeContainer,
            filter: this._filterItem.bind(this),
            onItemAdded: this._onItemAdded,
            onItemRemoved: this._onItemRemoved
          });
        }

        return this._items;
      }
      /**
       Whether the item is expanded. Expanded cannot be set to <code>true</code> if the item is disabled.
        @type {Boolean}
       @default false
       @htmlattribute expanded
       @htmlattributereflected
       */

    }, {
      key: "expanded",
      get: function get() {
        return this._expanded || false;
      },
      set: function set(value) {
        var _this2 = this;

        value = transform.booleanAttr(value);
        var triggerEvent = this.expanded !== value;
        this._expanded = value;

        this._reflectAttribute('expanded', this._expanded);

        var header = this._elements.header;
        var subTreeContainer = this._elements.subTreeContainer;
        this.classList.toggle('is-open', this._expanded);
        this.classList.toggle('is-collapsed', !this._expanded);

        if (this.variant !== variant$o.DRILLDOWN) {
          header.removeAttribute('aria-expanded');
          header.removeAttribute('aria-owns');
        } else if (this.items.length > 0) {
          header.setAttribute('aria-expanded', this._expanded);
          header.setAttribute('aria-owns', subTreeContainer.id);
        }

        if (this._expanded) {
          subTreeContainer.removeAttribute('aria-hidden');
        } else {
          subTreeContainer.setAttribute('aria-hidden', !this._expanded);
        }

        if (IS_TOUCH_DEVICE) {
          var icon = header.querySelector('._coral-TreeView-indicator');
          icon.setAttribute('aria-label', i18n.get(this._expanded ? 'Collapse' : 'Expand'));
        }

        this.trigger('coral-tree-item:_expandedchanged'); // Do animation in next frame to avoid a forced reflow

        window.requestAnimationFrame(function () {
          // Don't animate on initialization
          if (_this2._animate) {
            // Remove height as we want the drawer to naturally grow if content is added later
            commons.transitionEnd(subTreeContainer, function () {
              if (_this2.expanded) {
                subTreeContainer.style.height = '';
              } else {
                subTreeContainer.hidden = true;
              } // Trigger once the animation is over to inform coral-tree


              if (triggerEvent) {
                _this2.trigger('coral-tree-item:_afterexpandedchanged');
              }
            }); // Force height to enable transition

            if (!_this2.expanded) {
              subTreeContainer.style.height = "".concat(subTreeContainer.scrollHeight, "px");
            } else {
              subTreeContainer.hidden = false;
            } // We read the offset height to force a reflow, this is needed to start the transition between absolute values
            // https://blog.alexmaccaw.com/css-transitions under Redrawing
            // eslint-disable-next-line no-unused-vars


            var offsetHeight = subTreeContainer.offsetHeight;
            subTreeContainer.style.height = _this2.expanded ? "".concat(subTreeContainer.scrollHeight, "px") : 0;
          } else {
            // Make sure it's animated next time
            _this2._animate = true; // Hide it on initialization if closed

            if (!_this2.expanded) {
              subTreeContainer.style.height = 0;
              subTreeContainer.hidden = true;
            }
          }
        });
      }
      /**
       The item's variant. See {@link TreeItemVariantEnum}.
        @type {String}
       @default TreeItemVariant.DRILLDOWN
       @htmlattribute variant
       @htmlattributereflected
       */

    }, {
      key: "variant",
      get: function get() {
        return this._variant || variant$o.DRILLDOWN;
      },
      set: function set(value) {
        var _this$classList;

        value = transform.string(value).toLowerCase();
        this._variant = validate.enumeration(variant$o, value) && value || variant$o.DRILLDOWN; // removes every existing variant

        (_this$classList = this.classList).remove.apply(_this$classList, ALL_VARIANT_CLASSES$e);

        this.classList.add("".concat(CLASSNAME$1L, "--").concat(this._variant));
      }
      /**
       Whether the item is selected.
        @type {Boolean}
       @default false
       @htmlattribute selected
       @htmlattributereflected
       */

    }, {
      key: "selected",
      get: function get() {
        return this._selected || false;
      },
      set: function set(value) {
        this._selected = transform.booleanAttr(value);

        this._reflectAttribute('selected', this._selected);

        this._elements.header.classList.toggle('is-selected', this._selected);

        this._elements.header.setAttribute('aria-selected', this._selected);

        var selectedState = this._elements.selectedState;
        selectedState.textContent = i18n.get(this._selected ? 'selected' : 'not selected');

        if (IS_TOUCH_DEVICE) {
          selectedState.setAttribute('aria-pressed', this._selected);
        }

        this.trigger('coral-tree-item:_selectedchanged');
      }
      /**
       Whether this item is disabled.
        @type {Boolean}
       @default false
       @htmlattribute disabled
       @htmlattributereflected
       */

    }, {
      key: "disabled",
      get: function get() {
        return this._disabled || false;
      },
      set: function set(value) {
        this._disabled = transform.booleanAttr(value);

        this._reflectAttribute('disabled', this._disabled);

        this._elements.header.classList.toggle('is-disabled', this._disabled);

        this._elements.header[this._disabled ? 'setAttribute' : 'removeAttribute']('aria-disabled', this._disabled);

        this.trigger('coral-tree-item:_disabledchanged');
      }
      /**
       @ignore
       */

    }, {
      key: "hidden",
      get: function get() {
        return this.hasAttribute('hidden');
      },
      set: function set(value) {
        this._reflectAttribute('hidden', transform.booleanAttr(value)); // We redefine hidden to trigger an event


        this.trigger('coral-tree-item:_hiddenchanged');
      }
    }, {
      key: "_contentZones",
      get: function get() {
        return {
          'coral-tree-item-content': 'content'
        };
      }
      /** @ignore */

    }], [{
      key: "variant",
      get: function get() {
        return variant$o;
      }
    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['selected', 'disabled', 'variant', 'expanded', 'hidden']);
      }
    }]);

    return _class;
  }(BaseComponent(HTMLElement)));

  var CLASSNAME$1M = '_coral-TreeView';
  /**
   @class Coral.Tree
   @classdesc A Tree component is a container component to display collapsible content.
   Tree items don't expand by default. It's the developer's responsibility to handle it by listening to the
   {@link coral-collection:add} and {@link coral-collection:remove} events.
   @htmltag coral-tree
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var Tree = Decorator( /*#__PURE__*/function (_BaseComponent) {
    _inherits(_class, _BaseComponent);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this); // Attach events

      _this._delegateEvents({
        'click ._coral-TreeView-itemLink': '_onItemClick',
        'click ._coral-TreeView-indicator': '_onExpandCollapseClick',
        'coral-collection:add coral-tree-item': '_onCollectionChange',
        'coral-collection:remove coral-tree-item': '_onCollectionChange',
        // a11y
        'key:space ._coral-TreeView-itemLink': '_onItemClick',
        'key:space ._coral-TreeView-indicator': '_onExpandCollapseClick',
        'key:return ._coral-TreeView-itemLink, ._coral-TreeView-indicator': '_onExpandCollapseClick',
        'key:pageup ._coral-TreeView-itemLink, ._coral-TreeView-indicator': '_onFocusPreviousItem',
        'key:left ._coral-TreeView-itemLink, ._coral-TreeView-indicator': '_onCollapseItem',
        'key:up ._coral-TreeView-itemLink, ._coral-TreeView-indicator': '_onFocusPreviousItem',
        'key:pagedown ._coral-TreeView-itemLink, ._coral-TreeView-indicator': '_onFocusNextItem',
        'key:right ._coral-TreeView-itemLink, ._coral-TreeView-indicator': '_onExpandItem',
        'key:down ._coral-TreeView-itemLink, ._coral-TreeView-indicator': '_onFocusNextItem',
        'key:home ._coral-TreeView-itemLink, ._coral-TreeView-indicator': '_onFocusFirstItem',
        'key:end ._coral-TreeView-itemLink, ._coral-TreeView-indicator': '_onFocusLastItem',
        'capture:blur ._coral-TreeView-itemLink[tabindex="0"]': '_onItemBlur',
        // private
        'coral-tree-item:_selectedchanged': '_onItemSelectedChanged',
        'coral-tree-item:_disabledchanged': '_onFocusableChanged',
        'coral-tree-item:_expandedchanged': '_onFocusableChanged',
        'coral-tree-item:_afterexpandedchanged': '_onExpandedChanged',
        'coral-tree-item:_hiddenchanged': '_onFocusableChanged'
      }); // Used for eventing


      _this._oldSelection = []; // Init the collection mutation observer

      _this.items._startHandlingItems(true); // Listen for mutations for Torq compatibility


      var observer = new MutationObserver(function (mutations) {
        mutations.forEach(function (mutation) {
          for (var i = 0; i < mutation.addedNodes.length; i++) {
            var addedNode = mutation.addedNodes[i];

            if (addedNode.tagName === 'CORAL-TREE-ITEM') {
              // Move tree items to their container
              if (addedNode.parentNode.tagName === addedNode.tagName) {
                addedNode.parentNode._elements.subTreeContainer.appendChild(addedNode);
              }
            }
          }
        });
      });
      observer.observe(_assertThisInitialized(_this), {
        childList: true,
        subtree: true
      });
      return _this;
    }
    /**
     The Collection Interface that allows interacting with the items that the component contains.
      @type {SelectableCollection}
     @readonly
     */


    _createClass(_class, [{
      key: "_onItemSelectedChanged",

      /** @private */
      value: function _onItemSelectedChanged(event) {
        event.stopImmediatePropagation();

        this._validateSelection(event.target);
      }
      /** @private */

    }, {
      key: "_validateSelection",
      value: function _validateSelection(item) {
        var _this2 = this;

        var selectedItems = this.selectedItems;

        if (!this.multiple) {
          // Last selected item wins if multiple selection while not allowed
          item = item || selectedItems[selectedItems.length - 1];

          if (item && item.hasAttribute('selected') && selectedItems.length > 1) {
            selectedItems.forEach(function (selectedItem) {
              if (selectedItem !== item) {
                // Don't trigger change events
                _this2._preventTriggeringEvents = true;
                selectedItem.removeAttribute('selected');
              }
            }); // We can trigger change events again

            this._preventTriggeringEvents = false;
          }
        }

        this._triggerChangeEvent();
      }
      /** @private */

    }, {
      key: "_triggerChangeEvent",
      value: function _triggerChangeEvent() {
        var selectedItems = this.selectedItems;
        var oldSelection = this._oldSelection;

        if (!this._preventTriggeringEvents && this._arraysAreDifferent(selectedItems, oldSelection)) {
          // We differentiate whether multiple is on or off and return an array or HTMLElement respectively
          if (this.multiple) {
            this.trigger('coral-tree:change', {
              oldSelection: oldSelection,
              selection: selectedItems
            });
          } else {
            // Return all items if we just switched from multiple=true to multiple=false and we had >1 selected items
            this.trigger('coral-tree:change', {
              oldSelection: oldSelection.length > 1 ? oldSelection : oldSelection[0] || null,
              selection: selectedItems[0] || null
            });
          }

          this._oldSelection = selectedItems;
        }
      }
      /** @private */

    }, {
      key: "_arraysAreDifferent",
      value: function _arraysAreDifferent(selection, oldSelection) {
        var diff = [];

        if (oldSelection.length === selection.length) {
          diff = oldSelection.filter(function (item) {
            return selection.indexOf(item) === -1;
          });
        } // since we guarantee that they are arrays, we can start by comparing their size


        return oldSelection.length !== selection.length || diff.length !== 0;
      }
      /** @private */

    }, {
      key: "_toggleItemAttribute",
      value: function _toggleItemAttribute(item, attributeName) {
        if (item) {
          item[item.hasAttribute(attributeName) ? 'removeAttribute' : 'setAttribute'](attributeName, '');
        }
      }
      /** @private */

    }, {
      key: "_onCollectionChange",
      value: function _onCollectionChange(event) {
        // Prevent triggering collection event twice. Only coral-tree collection events are propagated.
        event.stopImmediatePropagation();
      }
      /** @private */

    }, {
      key: "_onItemClick",
      value: function _onItemClick(event) {
        // Clickable item inside Tree Item should not trigger selection of item
        if (event.target.hasAttribute('coral-interactive') || event.target.closest('[coral-interactive]')) {
          return;
        } // If the indicator is clicked, expand/collapse the tree item


        if (event.target.closest('._coral-TreeView-indicator')) {
          this._onExpandCollapseClick(event);

          return;
        } // The click was performed on the header so we select the item (parentNode) the selection is toggled


        var item = event.target.closest('coral-tree-item');

        if (item && !item.hasAttribute('disabled')) {
          event.preventDefault();
          event.stopPropagation(); // We ignore the selection if the item is disabled

          this._toggleItemAttribute(item, 'selected');

          var focusable = this._getFocusable();

          if (focusable) {
            focusable.setAttribute('tabindex', '-1');
          }

          item._elements.header.setAttribute('tabindex', '0');

          item._elements.header.focus();
        }
      }
      /** @private */

    }, {
      key: "_onExpandCollapseClick",
      value: function _onExpandCollapseClick(event) {
        event.preventDefault();
        event.stopPropagation(); // The click was performed on the icon to expand/collapse  the sub tree

        var item = event.target.closest('coral-tree-item');

        if (item) {
          // We ignore the expand/collapse if the item is disabled
          if (item.hasAttribute('disabled')) {
            return;
          } // Toggle the expanded of the item:


          this._toggleItemAttribute(item, 'expanded');
        }
      }
      /** @private */

    }, {
      key: "_onExpandItem",
      value: function _onExpandItem(event) {
        event.preventDefault();
        event.stopPropagation(); // The click was performed on the icon to expand the sub tree

        var item = event.target.closest('coral-tree-item');

        if (item) {
          // We ignore the expand if the item is disabled
          if (item.hasAttribute('disabled')) {
            return;
          }

          if (!item.expanded && item.variant === TreeItem.variant.DRILLDOWN) {
            // If the item is not expanded, expand the item
            item.expanded = !item.expanded;

            item._elements.header.classList.add('focus-ring');
          } else if (item.items.length > 0) {
            // If the item is expanded, and contains items, focus the next item
            this._onFocusNextItem(event);
          }
        }
      }
      /** @private */

    }, {
      key: "_onCollapseItem",
      value: function _onCollapseItem(event) {
        event.preventDefault();
        event.stopPropagation(); // The click was performed on the icon to collapse the sub tree

        var item = event.target.closest('coral-tree-item');

        if (item) {
          // We ignore the expand if the item is disabled
          if (item.hasAttribute('disabled')) {
            return;
          }

          if (item.expanded && item.variant === TreeItem.variant.DRILLDOWN) {
            // If the item is not expanded, expand the item
            item.expanded = !item.expanded;

            item._elements.header.classList.add('focus-ring');
          } else if (item.parent) {
            item._elements.header.setAttribute('tabindex', '-1');

            item._elements.header.classList.remove('focus-ring');

            item.parent.focus();

            item.parent._elements.header.classList.add('focus-ring');
          }
        }
      }
      /** @private */

    }, {
      key: "_focusSiblingItem",
      value: function _focusSiblingItem(item, next) {
        var focusableItems = this._getFocusableItems(); // There's not enough items to change focus


        if (focusableItems.length < 2) {
          return;
        }

        var index = focusableItems.indexOf(item) + (next ? 1 : -1);
        var siblingItem = null; // If we reached the edge, target the other edge

        if (index > focusableItems.length - 1) {
          siblingItem = focusableItems[0];
        } else if (index < 0) {
          siblingItem = focusableItems[focusableItems.length - 1];
        } // Find the sibling item


        while (!siblingItem) {
          siblingItem = focusableItems[index]; // The item might be hidden because a parent is collapsed

          if (siblingItem.parentNode.closest('coral-tree-item.is-collapsed')) {
            if (next) {
              index++;
              siblingItem = index > focusableItems.length - 1 ? item : null;
            } else {
              index--;
              siblingItem = index < 0 ? item : null;
            }
          }
        } // Change focus


        if (siblingItem !== item) {
          item._elements.header.setAttribute('tabindex', '-1');

          item._elements.header.classList.remove('focus-ring');

          siblingItem._elements.header.setAttribute('tabindex', '0');

          siblingItem._elements.header.classList.add('focus-ring');

          siblingItem._elements.header.focus();
        }
      }
      /** @private */

    }, {
      key: "_focusEdgeItem",
      value: function _focusEdgeItem(last) {
        // Query the focusable item
        var focusable = this._getFocusable();

        if (focusable) {
          var focusableItems = this._getFocusableItems();

          var edgeItem = focusableItems[last ? focusableItems.length - 1 : 0]; // Change focus

          if (edgeItem !== focusable) {
            focusable.setAttribute('tabindex', '-1');

            edgeItem._elements.header.setAttribute('tabindex', '0');

            edgeItem._elements.header.focus();
          }
        }
      }
      /** @private */

    }, {
      key: "_onFocusNextItem",
      value: function _onFocusNextItem(event) {
        event.preventDefault();
        event.stopPropagation();
        var item = event.target.closest('coral-tree-item');

        if (item) {
          this._focusSiblingItem(item, true);
        }
      }
      /** @private */

    }, {
      key: "_onFocusPreviousItem",
      value: function _onFocusPreviousItem(event) {
        event.preventDefault();
        event.stopPropagation();
        var item = event.target.closest('coral-tree-item');

        if (item) {
          this._focusSiblingItem(item, false);
        }
      }
      /** @private */

    }, {
      key: "_onFocusFirstItem",
      value: function _onFocusFirstItem(event) {
        event.preventDefault();
        event.stopPropagation();

        this._focusEdgeItem(false);
      }
      /** @private */

    }, {
      key: "_onFocusLastItem",
      value: function _onFocusLastItem(event) {
        event.preventDefault();
        event.stopPropagation();

        this._focusEdgeItem(true);
      }
      /** @private */

    }, {
      key: "_onFocusableChanged",
      value: function _onFocusableChanged(event) {
        event.preventDefault();
        event.stopPropagation();

        if (event.target.contains(this._getFocusable())) {
          this._resetFocusableItem();
        }
      }
      /** @private */

    }, {
      key: "_onExpandedChanged",
      value: function _onExpandedChanged(event) {
        event.stopImmediatePropagation();
        var item = event.target;
        this.trigger("coral-tree:".concat(item.expanded ? 'expand' : 'collapse'), {
          item: item
        });
      }
      /** @private */

    }, {
      key: "_getFocusable",
      value: function _getFocusable() {
        return this.querySelector('coral-tree-item > ._coral-TreeView-itemLink[tabindex="0"]');
      }
      /** @private */

    }, {
      key: "_getFocusableItems",
      value: function _getFocusableItems() {
        return this.items.getAll().filter(function (item) {
          return !item.closest('coral-tree-item[disabled]') && !item.closest('coral-tree-item[hidden]');
        });
      }
      /** @private */

    }, {
      key: "_onItemBlur",
      value: function _onItemBlur() {
        var focused = this.querySelector('._coral-TreeView-itemLink.focus-ring');

        if (focused) {
          focused.classList.remove('focus-ring');
        }
      }
      /** @private */

    }, {
      key: "_resetFocusableItem",
      value: function _resetFocusableItem(item) {
        // Old focusable becomes unfocusable
        var focusable = this._getFocusable();

        if (focusable) {
          focusable.setAttribute('tabindex', '-1');
          focusable.classList.remove('focus-ring');
        } // Defined item or first item by default gets the focus


        item = item || this._getFocusableItems()[0];

        if (item) {
          item._elements.header.setAttribute('tabindex', '0');
        }
      }
      /** @private */

    }, {
      key: "_expandCollapseAll",
      value: function _expandCollapseAll(expand) {
        var coralTreeItems = this.querySelectorAll('coral-tree-item');

        if (coralTreeItems) {
          var item;
          var length = coralTreeItems.length;

          if (length > 0) {
            for (var index = 0; index < length; index++) {
              item = coralTreeItems[index];

              if (item) {
                item.expanded = expand;
              }
            }
          }
        }
      }
      /**
       Expand all the Tree Items
       */

    }, {
      key: "expandAll",
      value: function expandAll() {
        this._expandCollapseAll(true);
      }
      /**
       Collapse all the Tree Items
       */

    }, {
      key: "collapseAll",
      value: function collapseAll() {
        this._expandCollapseAll(false);
      }
      /** @ignore */

    }, {
      key: "render",

      /** @ignore */
      value: function render() {
        var _this3 = this;

        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1M); // a11y

        this.setAttribute('role', 'tree');
        this.setAttribute('aria-multiselectable', this.multiple); // Enable keyboard interaction

        requestAnimationFrame(function () {
          _this3._resetFocusableItem();
        }); // Don't trigger events once connected

        this._preventTriggeringEvents = true;

        this._validateSelection();

        this._preventTriggeringEvents = false;
        this._oldSelection = this.selectedItems;
      }
      /**
       Triggered when the {@link Tree} selection changed.
        @typedef {CustomEvent} coral-tree:change
        @property {Array.<TreeItem>} detail.oldSelection
       The old selected item.
       @property {Array.<TreeItem>} detail.selection
       The selected items.
       */

      /**
       Triggered when a {@link Tree} item expanded.
        @typedef {CustomEvent} coral-tree:expand
        @property {TreeItem} detail.item
       The expanded item.
       */

      /**
       Triggered when a {@link Tree} item collapsed.
        @typedef {CustomEvent} coral-tree:collapse
        @property {TreeItem} detail.item
       The collapsed item.
       */

    }, {
      key: "items",
      get: function get() {
        // just init on demand
        if (!this._items) {
          this._items = new SelectableCollection({
            host: this,
            itemTagName: 'coral-tree-item'
          });
        }

        return this._items;
      }
      /**
       Indicates whether the tree accepts multiple selected items.
       @type {Boolean}
       @default false
       @htmlattribute multiple
       @htmlattributereflected
       */

    }, {
      key: "multiple",
      get: function get() {
        return this._multiple || false;
      },
      set: function set(value) {
        this._multiple = transform.booleanAttr(value);

        this._reflectAttribute('multiple', this._multiple);

        this.setAttribute('aria-multiselectable', this._multiple);

        this._validateSelection();
      }
      /**
       Returns an Array containing the set selected items.
       @type {Array.<HTMLElement>}
       @readonly
       */

    }, {
      key: "selectedItems",
      get: function get() {
        return this.items._getAllSelected();
      }
      /**
       Returns the first selected item in the Tree. The value <code>null</code> is returned if no element is
       selected.
       @type {?HTMLElement}
       @readonly
       */

    }, {
      key: "selectedItem",
      get: function get() {
        return this.items._getAllSelected()[0] || null;
      }
    }], [{
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(_class), "observedAttributes", this).concat(['multiple']);
      }
    }]);

    return _class;
  }(BaseComponent(HTMLElement)));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  /**
   @class Coral.Tree.Item.Content
   @classdesc Tree item's content component
   @htmltag coral-tree-item-content
   @return {HTMLElement}
   */
  var TreeItemContent = (function () {
    return document.createElement('coral-tree-item-content');
  });

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons._define('coral-tree-item', TreeItem);

  commons._define('coral-tree', Tree);

  Tree.Item = TreeItem;
  Tree.Item.Content = TreeItemContent;

  var CLASSNAME$1N = '_coral-WizardView';
  /**
   @class Coral.WizardView
   @classdesc A WizardView component is the wrapping container used to create the typical Wizard pattern. This is intended
   to be used with a {@link StepList} and a {@link PanelStack}.
   @htmltag coral-wizardview
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var WizardView = Decorator( /*#__PURE__*/function (_BaseComponent) {
    _inherits(_class, _BaseComponent);

    var _super = _createSuper(_class);

    /** @ignore */
    function _class() {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this);

      _this._delegateEvents({
        'capture:click coral-steplist[coral-wizardview-steplist] > coral-step': '_onStepClick',
        'coral-steplist:change coral-steplist[coral-wizardview-steplist]': '_onStepListChange',
        'click [coral-wizardview-previous]': '_onPreviousClick',
        'click [coral-wizardview-next]': '_onNextClick'
      }); // Init the collection mutation observer


      _this.stepLists._startHandlingItems(true);

      _this.panelStacks._startHandlingItems(true); // Disable tracking for specific elements that are attached to the component.


      _this._observer = new MutationObserver(function (mutations) {
        mutations.forEach(function (mutation) {
          // Sync added nodes
          for (var i = 0; i < mutation.addedNodes.length; i++) {
            var addedNode = mutation.addedNodes[i];

            if (addedNode.setAttribute && (addedNode.hasAttribute('coral-wizardview-next') || addedNode.hasAttribute('coral-wizardview-previous') || addedNode.hasAttribute('coral-wizardview-steplist') || addedNode.hasAttribute('coral-wizardview-panelstack'))) {
              addedNode.setAttribute('tracking', 'off');
            }
          }
        });
      });

      _this._observer.observe(_assertThisInitialized(_this), {
        childList: true,
        subtree: true
      });

      return _this;
    }
    /**
     The set of controlled PanelStacks. Each PanelStack must have the <code>coral-wizardview-panelstack</code> attribute.
      @type {Collection}
     @readonly
     */


    _createClass(_class, [{
      key: "_onItemAdded",

      /**
       Called by the Collection when an item is added
        @private
       */
      value: function _onItemAdded(item) {
        this._selectItemByIndex(item, this._getSelectedIndex());
      }
    }, {
      key: "_onStepClick",
      value: function _onStepClick(event) {
        this._trackEvent('click', 'coral-wizardview-steplist-step', event, event.matchedTarget);
      }
      /**
       Handles the next button click.
        @private
       */

    }, {
      key: "_onNextClick",
      value: function _onNextClick(event) {
        // we stop propagation in case the wizard views are nested
        event.stopPropagation();
        this.next();
        var stepList = this.stepLists.first();

        var step = stepList.items.getAll()[this._getSelectedIndex()];

        this._trackEvent('click', 'coral-wizardview-next', event, step);
      }
      /**
       Handles the previous button click.
        @private
       */

    }, {
      key: "_onPreviousClick",
      value: function _onPreviousClick(event) {
        // we stop propagation in case the wizard views are nested
        event.stopPropagation();
        this.previous();
        var stepList = this.stepLists.first();

        var step = stepList.items.getAll()[this._getSelectedIndex()];

        this._trackEvent('click', 'coral-wizardview-previous', event, step);
      }
      /**
       Detects a change in the StepList and triggers an event.
        @private
       */

    }, {
      key: "_onStepListChange",
      value: function _onStepListChange(event) {
        // Stop propagation of the events to support nested panels
        event.stopPropagation(); // Get the step number

        var index = event.target.items.getAll().indexOf(event.detail.selection); // Sync the other StepLists

        this._selectStep(index);

        this.trigger('coral-wizardview:change', {
          selection: event.detail.selection,
          oldSelection: event.detail.oldSelection
        });

        this._trackEvent('change', 'coral-wizardview', event);
      }
      /** @private */

    }, {
      key: "_getSelectedIndex",
      value: function _getSelectedIndex() {
        var stepList = this.stepLists.first();

        if (!stepList) {
          return -1;
        }

        var stepIndex = -1;

        if (stepList.items) {
          stepIndex = stepList.items.getAll().indexOf(stepList.selectedItem);
        } else {
          // Manually get the selected step
          var steps = stepList.querySelectorAll('coral-step'); // Find the last selected step

          for (var i = steps.length - 1; i >= 0; i--) {
            if (steps[i].hasAttribute('selected')) {
              stepIndex = i;
              break;
            }
          }
        }

        return stepIndex;
      }
      /**
       Select the step according to the provided index.
        @param {*} component
       The StepList or PanelStack to select the step on.
       @param {Number} index
       The index of the step that should be selected.
        @private
       */

    }, {
      key: "_selectItemByIndex",
      value: function _selectItemByIndex(component, index) {
        var item = null; // we need to set an id to be able to find direct children

        component.id = component.id || commons.getUID(); // if collection api is available we use it to find the correct item

        if (component.items) {
          // Get the corresponding item
          item = component.items.getAll()[index];
        } // Resort to querying manually on immediately children
        else if (component.tagName === 'CORAL-STEPLIST') {
            // @polyfill IE - we use id since :scope is not supported
            item = component.querySelectorAll("#".concat(component.id, " > coral-step"))[index];
          } else if (component.tagName === 'CORAL-PANELSTACK') {
            // @polyfill IE - we use id since :scope is not supported
            item = component.querySelectorAll("#".concat(component.id, " > coral-panel"))[index];
          }

        if (item) {
          // we only select if not select to avoid mutations
          if (!item.hasAttribute('selected')) {
            item.setAttribute('selected', '');
          }
        } // if we did not find an item to select, it means that the "index" is not available in the component, therefore we
        // need to deselect all items
        else {
            // we use the component id to be able to find direct children
            if (component.tagName === 'CORAL-STEPLIST') {
              // @polyfill IE - we use id since :scope is not supported
              item = component.querySelector("#".concat(component.id, " > coral-step[selected]"));
            } else if (component.tagName === 'CORAL-PANELSTACK') {
              // @polyfill IE - we use id since :scope is not supported
              item = component.querySelector("#".concat(component.id, " > coral-panel[selected]"));
            }

            if (item) {
              item.removeAttribute('selected');
            }
          }
      }
      /** @private */

    }, {
      key: "_selectStep",
      value: function _selectStep(index) {
        var _this2 = this;

        // we apply the selection to all available steplists
        this.stepLists.getAll().forEach(function (stepList) {
          _this2._selectItemByIndex(stepList, index);
        }); // we apply the selection to all available panelstacks

        this.panelStacks.getAll().forEach(function (panelStack) {
          _this2._selectItemByIndex(panelStack, index);
        });
      }
      /**
       Sets the correct selected item in every PanelStack.
        @private
       */

    }, {
      key: "_syncPanelStackSelection",
      value: function _syncPanelStackSelection(defaultIndex) {
        var _this3 = this;

        // Find out which step we're on by checking the first StepList
        var index = this._getSelectedIndex();

        if (index === -1) {
          if (typeof defaultIndex !== 'undefined') {
            index = defaultIndex;
          } else {
            // No panel selected
            return;
          }
        }

        this.panelStacks.getAll().forEach(function (panelStack) {
          _this3._selectItemByIndex(panelStack, index);
        });
      }
      /**
       Selects the correct step in every StepList.
        @private
       */

    }, {
      key: "_syncStepListSelection",
      value: function _syncStepListSelection(defaultIndex) {
        var _this4 = this;

        // Find out which step we're on by checking the first StepList
        var index = this._getSelectedIndex();

        if (index === -1) {
          if (typeof defaultIndex !== 'undefined') {
            index = defaultIndex;
          } else {
            // No step selected
            return;
          }
        }

        this.stepLists.getAll().forEach(function (stepList) {
          _this4._selectItemByIndex(stepList, index);
        });
      }
      /**
       Shows the next step. If the WizardView is already in the last step nothing will happen.
        @emits {coral-wizardview:change}
       */

    }, {
      key: "next",
      value: function next() {
        var stepList = this.stepLists.first();

        if (!stepList) {
          return;
        } // Change to the next step


        stepList.next(); // Select the step everywhere

        this._selectStep(stepList.items.getAll().indexOf(stepList.selectedItem));
      }
      /**
       Shows the previous step. If the WizardView is already in the first step nothing will happen.
        @emits {coral-wizardview:change}
       */

    }, {
      key: "previous",
      value: function previous() {
        var stepList = this.stepLists.first();

        if (!stepList) {
          return;
        } // Change to the previous step


        stepList.previous(); // Select the step everywhere

        this._selectStep(stepList.items.getAll().indexOf(stepList.selectedItem));
      }
      /** @ignore */

    }, {
      key: "render",
      value: function render() {
        _get(_getPrototypeOf(_class.prototype), "render", this).call(this);

        this.classList.add(CLASSNAME$1N);

        this._syncStepListSelection(0);

        this._syncPanelStackSelection(0); // Disable tracking for specific elements that are attached to the component.


        var selector = '[coral-wizardview-next],[coral-wizardview-previous],[coral-wizardview-steplist],[coral-wizardview-panelstack]';
        var items = this.querySelectorAll(selector);

        for (var i = 0; i < items.length; i++) {
          items[i].setAttribute('tracking', 'off');
        }
      }
      /**
       Triggered when the {@link WizardView} selected step list item has changed.
        @typedef {CustomEvent} coral-wizardview:change
        @property {Step} event.detail.selection
       The new selected step list item.
       @property {Step} event.detail.oldSelection
       The prior selected step list item.
       */

    }, {
      key: "panelStacks",
      get: function get() {
        // Construct the collection on first request:
        if (!this._panelStacks) {
          this._panelStacks = new Collection$1({
            host: this,
            itemTagName: 'coral-panelstack',
            // allows panelstack to be nested
            itemSelector: ':scope > coral-panelstack[coral-wizardview-panelstack]',
            onlyHandleChildren: true,
            onItemAdded: this._onItemAdded
          });
        }

        return this._panelStacks;
      }
      /**
       The set of controlling StepLists. Each StepList must have the <code>coral-wizardview-steplist</code> attribute.
        @type {Collection}
       @readonly
       */

    }, {
      key: "stepLists",
      get: function get() {
        // Construct the collection on first request:
        if (!this._stepLists) {
          this._stepLists = new Collection$1({
            host: this,
            itemTagName: 'coral-steplist',
            // allows steplist to be nested
            itemSelector: ':scope > coral-steplist[coral-wizardview-steplist]',
            onlyHandleChildren: true,
            onItemAdded: this._onItemAdded
          });
        }

        return this._stepLists;
      }
    }]);

    return _class;
  }(BaseComponent(HTMLElement)));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  commons._define('coral-wizardview', WizardView);

  var name = "@adobe/coral-spectrum";
  var description = "Coral Spectrum is a JavaScript library of Web Components following Spectrum design patterns.";
  var version$1 = "4.15.16";
  var homepage = "https://github.com/adobe/coral-spectrum#readme";
  var license = "Apache-2.0";
  var repository = {
  	type: "git",
  	url: "https://github.com/adobe/coral-spectrum"
  };
  var author = {
  	name: "Stephan Ringel",
  	url: "https://github.com/icaraps"
  };
  var contributors = [
  	{
  		name: "Larry Davis",
  		url: "https://github.com/lazd"
  	},
  	{
  		name: "Oscar Bolanos",
  		url: "https://github.com/joekukish"
  	},
  	{
  		name: "Frank Karstens",
  		url: "https://github.com/karstens"
  	},
  	{
  		name: "Aaron Brownlee",
  		url: "https://github.com/misterbrownlee"
  	}
  ];
  var bugs = {
  	url: "https://github.com/adobe/coral-spectrum/issues"
  };
  var scripts = {
  	postinstall: "node scripts/spectrum-css.js",
  	build: "gulp build && gulp karma && gulp examples && gulp axe && gulp minify-css && gulp minify-js",
  	playground: "cd coral-component-playground && gulp build && cd .. && gulp playground",
  	docs: "gulp docs",
  	"semantic-release": "semantic-release"
  };
  var dependencies = {
  	"@adobe/focus-ring-polyfill": "0.1.5",
  	"@adobe/spectrum-css": "2.18.0",
  	"@adobe/vent": "1.0.0",
  	"@ctrl/tinycolor": "^3.3.3",
  	"core-js": "3.6.4",
  	"document-register-element": "1.14.3",
  	"normalize.css": "8.0.1",
  	"popper.js": "1.16.1",
  	"resize-observer-polyfill": "1.5.1"
  };
  var devDependencies = {
  	"@babel/core": "^7.10.2",
  	"@babel/preset-env": "^7.10.2",
  	"@semantic-release/changelog": "^5.0.1",
  	"@semantic-release/git": "^9.0.0",
  	"@semantic-release/github": "^7.0.7",
  	"babel-eslint": "^10.0.3",
  	browserslist: "^4.8.5",
  	chai: "^4.0.2",
  	codemirror: "^5.52.2",
  	commitizen: "^4.2.1",
  	"cz-conventional-changelog": "^3.3.0",
  	"deflate-js": "0.2.3",
  	del: "^4.1.1",
  	esdoc: "^1.0.3",
  	"esdoc-accessor-plugin": "^1.0.0",
  	"esdoc-importpath-plugin": "^1.0.1",
  	"esdoc-inject-script-plugin": "^1.0.0",
  	"esdoc-inject-style-plugin": "^1.0.0",
  	"esdoc-member-plugin": "^1.0.0",
  	"esdoc-standard-plugin": "^1.0.0",
  	"eslint-config-standard": "^12.0.0",
  	"eslint-plugin-babel": "^5.3.0",
  	"eslint-plugin-import": "^2.20.0",
  	"eslint-plugin-node": "^8.0.1",
  	"eslint-plugin-promise": "^4.2.1",
  	"eslint-plugin-standard": "^4.0.1",
  	"fancy-log": "^1.3.3",
  	"fs-extra": "^7.0.1",
  	"glob-all": "^3.2.1",
  	gulp: "^4.0.2",
  	"gulp-axe-webdriver": "^3.1.3",
  	"gulp-bump": "^3.1.3",
  	"gulp-clean-css": "^4.2.0",
  	"gulp-domly": "^0.1.0",
  	"gulp-eslint": "^6.0.0",
  	"gulp-gh-pages": "^0.6.0-6",
  	"gulp-git": "^2.10.0",
  	"gulp-merge-json": "^1.0.0",
  	"gulp-modify-file": "^1.0.0",
  	"gulp-plumber": "^1.1.0",
  	"gulp-postcss": "^8.0.0",
  	"gulp-rename": "^1.2.2",
  	"gulp-stylus": "^2.6.0",
  	"http-server": "^0.12.3",
  	inquirer: "^6.5.2",
  	karma: "^5.0.9",
  	"karma-chrome-launcher": "^2.2.0",
  	"karma-coverage-istanbul-reporter": "^2.1.1",
  	"karma-firefox-launcher": "^1.3.0",
  	"karma-html2js-preprocessor": "^1.1.0",
  	"karma-mocha": "^2.0.1",
  	"karma-mocha-reporter": "^2.2.5",
  	"karma-rollup-preprocessor": "^7.0.3",
  	"karma-sinon-chai": "^2.0.2",
  	minimist: "^1.2.0",
  	mocha: "^7.2.0",
  	moment: "^2.24.0",
  	"plugin-error": "^1.0.1",
  	"postcss-css-variables": "^0.13.0",
  	"postcss-merge-rules": "^4.0.3",
  	request: "^2.81.0",
  	rollup: "^1.29.1",
  	"rollup-plugin-babel": "^4.3.3",
  	"rollup-plugin-commonjs": "^9.3.4",
  	"rollup-plugin-istanbul": "^2.0.1",
  	"rollup-plugin-json": "^4.0.0",
  	"rollup-plugin-node-resolve": "^4.2.4",
  	"rollup-plugin-postcss": "^2.0.4",
  	"rollup-plugin-terser": "^5.2.0",
  	"rollup-pluginutils": "^2.8.2",
  	"semantic-release": "^17.1.1",
  	semver: "^6.3.0",
  	sinon: "^7.5.0",
  	"sinon-chai": "^3.4.0",
  	"stylus-svg": "^1.1.2",
  	through2: "^3.0.1"
  };
  var config$1 = {
  	commitizen: {
  		path: "./node_modules/cz-conventional-changelog"
  	}
  };
  var PACKAGE = {
  	name: name,
  	description: description,
  	version: version$1,
  	homepage: homepage,
  	license: license,
  	repository: repository,
  	author: author,
  	contributors: contributors,
  	bugs: bugs,
  	scripts: scripts,
  	dependencies: dependencies,
  	devDependencies: devDependencies,
  	config: config$1
  };

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  var version$2 = PACKAGE.version;

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */

  var components = /*#__PURE__*/Object.freeze({
    __proto__: null,
    commons: commons,
    events: events,
    i18n: i18n,
    keys: keys$1,
    Keys: Keys,
    strings: strings,
    transform: transform,
    validate: validate,
    tracking: tracking,
    Collection: Collection$1,
    SelectableCollection: SelectableCollection,
    DateTime: DateTime,
    DragAction: DragAction,
    Accordion: Accordion,
    ActionBar: ActionBar,
    Alert: Alert,
    AnchorButton: AnchorButton,
    Autocomplete: Autocomplete,
    Banner: Banner,
    Button: Button,
    ButtonGroup: ButtonGroup,
    Calendar: Calendar,
    Card: Card,
    CharacterCount: CharacterCount,
    Checkbox: Checkbox,
    CheckboxGroup: CheckboxGroup,
    Clock: Clock,
    CoachMark: CoachMark,
    Color: Color,
    ColorInput: ColorInput,
    ColorPicker: ColorPicker,
    ColumnView: ColumnView,
    CycleButton: CycleButton,
    Datepicker: Datepicker,
    Dialog: Dialog,
    Drawer: Drawer,
    FileUpload: FileUpload,
    Icon: Icon,
    List: List,
    AnchorList: AnchorList,
    ButtonList: ButtonList,
    SelectList: SelectList,
    Masonry: Masonry,
    Multifield: Multifield,
    NumberInput: NumberInput,
    Overlay: Overlay,
    Panel: Panel,
    PanelStack: PanelStack,
    Popover: Popover,
    Progress: Progress,
    QuickActions: QuickActions,
    Radio: Radio,
    RadioGroup: RadioGroup,
    Shell: Shell,
    Select: Select,
    Search: Search,
    SideNav: SideNav,
    Slider: Slider,
    RangedSlider: RangedSlider,
    SplitButton: SplitButton,
    Status: Status,
    StepList: StepList,
    Step: Step,
    Switch: Switch,
    Table: Table,
    Tab: Tab,
    TabList: TabList,
    TabView: TabView,
    Tag: Tag,
    TagList: TagList,
    Textarea: Textarea,
    Textfield: Textfield,
    Toast: Toast,
    Tooltip: Tooltip,
    Tree: Tree,
    TreeItem: TreeItem,
    Wait: Wait,
    WizardView: WizardView,
    register: register,
    property: property,
    Component: Component,
    version: version$2
  });

  var template$16 = function anonymous(data_0) {
    var frag = document.createDocumentFragment();
    var el0 = this["wrapper"] = document.createElement("div");
    el0.setAttribute("handle", "wrapper");
    var el1 = document.createTextNode("\n  ");
    el0.appendChild(el1);
    var el2 = this["copy"] = document.createElement("textarea");
    el2.setAttribute("handle", "copy");
    el0.appendChild(el2);
    var el3 = document.createTextNode("\n  ");
    el0.appendChild(el3);
    var el4 = this["preview"] = document.createElement("div");
    el4.setAttribute("handle", "preview");
    el4.className += " _coral-Playground-preview";
    var el5 = document.createTextNode("\n    ");
    el4.appendChild(el5);
    var el6 = this["loading"] = document.createElement("coral-wait");
    el6.setAttribute("hidden", "");
    el6.className += " _coral-Playground-loading";
    el6.setAttribute("handle", "loading");
    el6.setAttribute("size", "L");
    el6.setAttribute("variant", "dots");
    el4.appendChild(el6);
    var el7 = document.createTextNode("\n    ");
    el4.appendChild(el7);
    var el8 = this["frame"] = document.createElement("iframe");
    el8.setAttribute("sandbox", "allow-same-origin allow-scripts allow-modals");
    el8.setAttribute("handle", "frame");
    el8.className += " _coral-Playground-preview-frame";
    el4.appendChild(el8);
    var el9 = document.createTextNode("\n  ");
    el4.appendChild(el9);
    el0.appendChild(el4);
    var el10 = document.createTextNode("\n  ");
    el0.appendChild(el10);
    var el11 = document.createElement("div");
    el11.className += " _coral-Playground-settings";
    var el12 = document.createTextNode("\n    ");
    el11.appendChild(el12);
    var el13 = this["run"] = document.createElement("button", "coral-button");
    el13.setAttribute("handle", "run");
    el13.className += " _coral-Playground-settings-button";
    el13.setAttribute("type", "button");
    el13.setAttribute("is", "coral-button");
    el13.setAttribute("icon", "play");
    el13.setAttribute("variant", "minimal");
    el11.appendChild(el13);
    var el14 = document.createTextNode("\n    ");
    el11.appendChild(el14);
    var el15 = this["share"] = document.createElement("button", "coral-button");
    el15.setAttribute("handle", "share");
    el15.className += " _coral-Playground-settings-button";
    el15.setAttribute("type", "button");
    el15.setAttribute("is", "coral-button");
    el15.setAttribute("icon", "share");
    el15.setAttribute("variant", "minimal");
    el11.appendChild(el15);
    var el16 = document.createTextNode("\n    ");
    el11.appendChild(el16);
    var el17 = this["sharetip"] = document.createElement("coral-tooltip");
    el17.setAttribute("handle", "sharetip");
    el17.setAttribute("placement", "left");
    el17.setAttribute("interaction", "off");
    el17.setAttribute("target", "_prev");
    el17.textContent = "URL copied to your clipboard";
    el11.appendChild(el17);
    var el18 = document.createTextNode("\n    ");
    el11.appendChild(el18);
    var el19 = this["gear"] = document.createElement("button", "coral-button");
    el19.className += " _coral-Playground-settings-button _coral-Playground-settings-action";
    el19.setAttribute("variant", "minimal");
    el19.setAttribute("handle", "gear");
    el19.setAttribute("type", "button");
    el19.setAttribute("is", "coral-button");
    el19.setAttribute("role", "combobox");
    el19.setAttribute("aria-expanded", "false");
    el19.setAttribute("aria-haspopup", "true");
    el19.setAttribute("icon", "gear");
    el11.appendChild(el19);
    var el20 = document.createTextNode("\n    ");
    el11.appendChild(el20);
    var el21 = this["overlay"] = document.createElement("coral-popover");
    el21.id = data_0["commons"]["getUID"]();
    el21.setAttribute("handle", "overlay");
    el21.className += " _coral-Playground-overlay";
    el21.setAttribute("trapfocus", "on");
    el21.setAttribute("focusonshow", "on");
    el21.setAttribute("target", "._coral-Playground-settings-action");
    el21.setAttribute("role", "presentation");
    el21.setAttribute("placement", "bottom");
    el21.setAttribute("smart", "");
    var el22 = document.createTextNode("\n      ");
    el21.appendChild(el22);
    var el23 = document.createElement("coral-popover-content");
    el23.className += " u-coral-padding";
    var el24 = document.createTextNode("\n        ");
    el23.appendChild(el24);
    var el25 = document.createElement("div");
    el25.className += " _coral-Playground-field";
    var el26 = document.createTextNode("\n          ");
    el25.appendChild(el26);
    var el27 = document.createElement("div");
    el27.className += " _coral-Playground-field-label";
    el27.textContent = "Live reload";
    el25.appendChild(el27);
    var el28 = document.createTextNode("\n          ");
    el25.appendChild(el28);
    var el29 = this["livereload"] = document.createElement("coral-switch");
    el29.setAttribute("handle", "livereload");
    el25.appendChild(el29);
    var el30 = document.createTextNode("\n        ");
    el25.appendChild(el30);
    el23.appendChild(el25);
    var el31 = document.createTextNode("\n        ");
    el23.appendChild(el31);
    var el32 = document.createElement("div");
    el32.className += " _coral-Playground-field";
    var el33 = document.createTextNode("\n          ");
    el32.appendChild(el33);
    var el34 = document.createElement("div");
    el34.className += " _coral-Playground-field-label";
    el34.textContent = "Screen";
    el32.appendChild(el34);
    var el35 = document.createTextNode("\n          ");
    el32.appendChild(el35);
    var el36 = this["screen"] = document.createElement("coral-buttongroup");
    el36.setAttribute("handle", "screen");
    el36.setAttribute("selectionmode", "single");
    var el37 = document.createTextNode("\n            ");
    el36.appendChild(el37);
    var el38 = document.createElement("button", "coral-button");
    el38.setAttribute("is", "coral-button");
    el38.setAttribute("icon", "separator");
    el38.setAttribute("value", "vertical");
    el36.appendChild(el38);
    var el39 = document.createTextNode("\n            ");
    el36.appendChild(el39);
    var el40 = document.createElement("button", "coral-button");
    el40.setAttribute("is", "coral-button");
    el40.setAttribute("icon", "separator");
    el40.setAttribute("value", "horizontal");
    el36.appendChild(el40);
    var el41 = document.createTextNode("\n            ");
    el36.appendChild(el41);
    var el42 = document.createElement("button", "coral-button");
    el42.setAttribute("is", "coral-button");
    el42.setAttribute("icon", "fullScreen");
    el42.setAttribute("value", "fullscreen");
    el36.appendChild(el42);
    var el43 = document.createTextNode("\n          ");
    el36.appendChild(el43);
    el32.appendChild(el36);
    var el44 = document.createTextNode("\n        ");
    el32.appendChild(el44);
    el23.appendChild(el32);
    var el45 = document.createTextNode("\n      ");
    el23.appendChild(el45);
    el21.appendChild(el23);
    var el46 = document.createTextNode("\n    ");
    el21.appendChild(el46);
    el11.appendChild(el21);
    var el47 = document.createTextNode("\n  ");
    el11.appendChild(el47);
    el0.appendChild(el11);
    var el48 = document.createTextNode("\n  ");
    el0.appendChild(el48);
    var el49 = this["editor"] = document.createElement("div");
    el49.className += " _coral-Playground-editor";
    el49.setAttribute("handle", "editor");
    el0.appendChild(el49);
    var el50 = document.createTextNode("\n");
    el0.appendChild(el50);
    frag.appendChild(el0);
    var el51 = document.createTextNode("\n");
    frag.appendChild(el51);
    return frag;
  };

  var rawinflate = createCommonjsModule(function (module) {
    /*
     * $Id: rawinflate.js,v 0.2 2009/03/01 18:32:24 dankogai Exp $
     *
     * original:
     * http://www.onicos.com/staff/iz/amuse/javascript/expert/inflate.txt
     */

    /* Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>
     * Version: 1.0.0.1
     * LastModified: Dec 25 1999
     */

    /* Interface:
     * data = inflate(src);
     */
    (function () {
      /* constant parameters */
      var WSIZE = 32768,
          // Sliding Window size
      STORED_BLOCK = 0,
          STATIC_TREES = 1,
          DYN_TREES = 2,

      /* for inflate */
      lbits = 9,
          // bits in base literal/length lookup table
      dbits = 6,
          // bits in base distance lookup table

      /* variables (inflate) */
      slide,
          wp,
          // current position in slide
      fixed_tl = null,
          // inflate static
      fixed_td,
          // inflate static
      fixed_bl,
          // inflate static
      fixed_bd,
          // inflate static
      bit_buf,
          // bit buffer
      bit_len,
          // bits in bit buffer
      method,
          eof,
          copy_leng,
          copy_dist,
          tl,
          // literal length decoder table
      td,
          // literal distance decoder table
      bl,
          // number of bits decoded by tl
      bd,
          // number of bits decoded by td
      inflate_data,
          inflate_pos,

      /* constant tables (inflate) */
      MASK_BITS = [0x0000, 0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff, 0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff],
          // Tables for deflate from PKZIP's appnote.txt.
      // Copy lengths for literal codes 257..285
      cplens = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0],

      /* note: see note #13 above about the 258 in this list. */
      // Extra bits for literal codes 257..285
      cplext = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99 // 99==invalid
      ],
          // Copy offsets for distance codes 0..29
      cpdist = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577],
          // Extra bits for distance codes
      cpdext = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13],
          // Order of the bit length code lengths
      border = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
      /* objects (inflate) */

      function HuftList() {
        this.next = null;
        this.list = null;
      }

      function HuftNode() {
        this.e = 0; // number of extra bits or operation

        this.b = 0; // number of bits in this code or subcode
        // union

        this.n = 0; // literal, length base, or distance base

        this.t = null; // (HuftNode) pointer to next level of table
      }
      /*
       * @param b-  code lengths in bits (all assumed <= BMAX)
       * @param n- number of codes (assumed <= N_MAX)
       * @param s- number of simple-valued codes (0..s-1)
       * @param d- list of base values for non-simple codes
       * @param e- list of extra bits for non-simple codes
       * @param mm- maximum lookup bits
       */


      function HuftBuild(b, n, s, d, e, mm) {
        this.BMAX = 16; // maximum bit length of any code

        this.N_MAX = 288; // maximum number of codes in any set

        this.status = 0; // 0: success, 1: incomplete table, 2: bad input

        this.root = null; // (HuftList) starting table

        this.m = 0; // maximum lookup bits, returns actual

        /* Given a list of code lengths and a maximum table size, make a set of
           tables to decode that set of codes. Return zero on success, one if
           the given code set is incomplete (the tables are still built in this
           case), two if the input is invalid (all zero length codes or an
           oversubscribed set of lengths), and three if not enough memory.
           The code with value 256 is special, and the tables are constructed
           so that no bits beyond that code are fetched when that code is
           decoded. */

        var a; // counter for codes of length k

        var c = [];
        var el; // length of EOB code (value 256)

        var f; // i repeats in table every f entries

        var g; // maximum code length

        var h; // table level

        var i; // counter, current code

        var j; // counter

        var k; // number of bits in current code

        var lx = [];
        var p; // pointer into c[], b[], or v[]

        var pidx; // index of p

        var q; // (HuftNode) points to current table

        var r = new HuftNode(); // table entry for structure assignment

        var u = [];
        var v = [];
        var w;
        var x = [];
        var xp; // pointer into x or c

        var y; // number of dummy codes added

        var z; // number of entries in current table

        var o;
        var tail; // (HuftList)

        tail = this.root = null; // bit length count table

        for (i = 0; i < this.BMAX + 1; i++) {
          c[i] = 0;
        } // stack of bits per table


        for (i = 0; i < this.BMAX + 1; i++) {
          lx[i] = 0;
        } // HuftNode[BMAX][]  table stack


        for (i = 0; i < this.BMAX; i++) {
          u[i] = null;
        } // values in order of bit length


        for (i = 0; i < this.N_MAX; i++) {
          v[i] = 0;
        } // bit offsets, then code stack


        for (i = 0; i < this.BMAX + 1; i++) {
          x[i] = 0;
        } // Generate counts for each bit length


        el = n > 256 ? b[256] : this.BMAX; // set length of EOB code, if any

        p = b;
        pidx = 0;
        i = n;

        do {
          c[p[pidx]]++; // assume all entries <= BMAX

          pidx++;
        } while (--i > 0);

        if (c[0] === n) {
          // null input--all zero length codes
          this.root = null;
          this.m = 0;
          this.status = 0;
          return;
        } // Find minimum and maximum length, bound *m by those


        for (j = 1; j <= this.BMAX; j++) {
          if (c[j] !== 0) {
            break;
          }
        }

        k = j; // minimum code length

        if (mm < j) {
          mm = j;
        }

        for (i = this.BMAX; i !== 0; i--) {
          if (c[i] !== 0) {
            break;
          }
        }

        g = i; // maximum code length

        if (mm > i) {
          mm = i;
        } // Adjust last length count to fill out codes, if needed


        for (y = 1 << j; j < i; j++, y <<= 1) {
          if ((y -= c[j]) < 0) {
            this.status = 2; // bad input: more codes than bits

            this.m = mm;
            return;
          }
        }

        if ((y -= c[i]) < 0) {
          this.status = 2;
          this.m = mm;
          return;
        }

        c[i] += y; // Generate starting offsets into the value table for each length

        x[1] = j = 0;
        p = c;
        pidx = 1;
        xp = 2;

        while (--i > 0) {
          // note that i == g from above
          x[xp++] = j += p[pidx++];
        } // Make a table of values in order of bit lengths


        p = b;
        pidx = 0;
        i = 0;

        do {
          if ((j = p[pidx++]) !== 0) {
            v[x[j]++] = i;
          }
        } while (++i < n);

        n = x[g]; // set n to length of v
        // Generate the Huffman codes and for each, make the table entries

        x[0] = i = 0; // first Huffman code is zero

        p = v;
        pidx = 0; // grab values in bit order

        h = -1; // no tables yet--level -1

        w = lx[0] = 0; // no bits decoded yet

        q = null; // ditto

        z = 0; // ditto
        // go through the bit lengths (k already is bits in shortest code)

        for (null; k <= g; k++) {
          a = c[k];

          while (a-- > 0) {
            // here i is the Huffman code of length k bits for value p[pidx]
            // make tables up to required level
            while (k > w + lx[1 + h]) {
              w += lx[1 + h]; // add bits already decoded

              h++; // compute minimum size table less than or equal to *m bits

              z = (z = g - w) > mm ? mm : z; // upper limit

              if ((f = 1 << (j = k - w)) > a + 1) {
                // try a k-w bit table
                // too few codes for k-w bit table
                f -= a + 1; // deduct codes from patterns left

                xp = k;

                while (++j < z) {
                  // try smaller tables up to z bits
                  if ((f <<= 1) <= c[++xp]) {
                    break; // enough codes to use up j bits
                  }

                  f -= c[xp]; // else deduct codes from patterns
                }
              }

              if (w + j > el && w < el) {
                j = el - w; // make EOB code end at table
              }

              z = 1 << j; // table entries for j-bit table

              lx[1 + h] = j; // set table size in stack
              // allocate and link in new table

              q = [];

              for (o = 0; o < z; o++) {
                q[o] = new HuftNode();
              }

              if (!tail) {
                tail = this.root = new HuftList();
              } else {
                tail = tail.next = new HuftList();
              }

              tail.next = null;
              tail.list = q;
              u[h] = q; // table starts after link

              /* connect to last table, if there is one */

              if (h > 0) {
                x[h] = i; // save pattern for backing up

                r.b = lx[h]; // bits to dump before this table

                r.e = 16 + j; // bits in this table

                r.t = q; // pointer to this table

                j = (i & (1 << w) - 1) >> w - lx[h];
                u[h - 1][j].e = r.e;
                u[h - 1][j].b = r.b;
                u[h - 1][j].n = r.n;
                u[h - 1][j].t = r.t;
              }
            } // set up table entry in r


            r.b = k - w;

            if (pidx >= n) {
              r.e = 99; // out of values--invalid code
            } else if (p[pidx] < s) {
              r.e = p[pidx] < 256 ? 16 : 15; // 256 is end-of-block code

              r.n = p[pidx++]; // simple code is just the value
            } else {
              r.e = e[p[pidx] - s]; // non-simple--look up in lists

              r.n = d[p[pidx++] - s];
            } // fill code-like entries with r //


            f = 1 << k - w;

            for (j = i >> w; j < z; j += f) {
              q[j].e = r.e;
              q[j].b = r.b;
              q[j].n = r.n;
              q[j].t = r.t;
            } // backwards increment the k-bit code i


            for (j = 1 << k - 1; (i & j) !== 0; j >>= 1) {
              i ^= j;
            }

            i ^= j; // backup over finished tables

            while ((i & (1 << w) - 1) !== x[h]) {
              w -= lx[h]; // don't need to update q

              h--;
            }
          }
        }
        /* return actual size of base table */


        this.m = lx[1];
        /* Return true (1) if we were given an incomplete table */

        this.status = y !== 0 && g !== 1 ? 1 : 0;
      }
      /* routines (inflate) */


      function GET_BYTE() {
        if (inflate_data.length === inflate_pos) {
          return -1;
        }

        return inflate_data[inflate_pos++] & 0xff;
      }

      function NEEDBITS(n) {
        while (bit_len < n) {
          bit_buf |= GET_BYTE() << bit_len;
          bit_len += 8;
        }
      }

      function GETBITS(n) {
        return bit_buf & MASK_BITS[n];
      }

      function DUMPBITS(n) {
        bit_buf >>= n;
        bit_len -= n;
      }

      function inflate_codes(buff, off, size) {
        // inflate (decompress) the codes in a deflated (compressed) block.
        // Return an error code or zero if it all goes ok.
        var e; // table entry flag/number of extra bits

        var t; // (HuftNode) pointer to table entry

        var n;

        if (size === 0) {
          return 0;
        } // inflate the coded data


        n = 0;

        for (;;) {
          // do until end of block
          NEEDBITS(bl);
          t = tl.list[GETBITS(bl)];
          e = t.e;

          while (e > 16) {
            if (e === 99) {
              return -1;
            }

            DUMPBITS(t.b);
            e -= 16;
            NEEDBITS(e);
            t = t.t[GETBITS(e)];
            e = t.e;
          }

          DUMPBITS(t.b);

          if (e === 16) {
            // then it's a literal
            wp &= WSIZE - 1;
            buff[off + n++] = slide[wp++] = t.n;

            if (n === size) {
              return size;
            }

            continue;
          } // exit if end of block


          if (e === 15) {
            break;
          } // it's an EOB or a length
          // get length of block to copy


          NEEDBITS(e);
          copy_leng = t.n + GETBITS(e);
          DUMPBITS(e); // decode distance of block to copy

          NEEDBITS(bd);
          t = td.list[GETBITS(bd)];
          e = t.e;

          while (e > 16) {
            if (e === 99) {
              return -1;
            }

            DUMPBITS(t.b);
            e -= 16;
            NEEDBITS(e);
            t = t.t[GETBITS(e)];
            e = t.e;
          }

          DUMPBITS(t.b);
          NEEDBITS(e);
          copy_dist = wp - t.n - GETBITS(e);
          DUMPBITS(e); // do the copy

          while (copy_leng > 0 && n < size) {
            copy_leng--;
            copy_dist &= WSIZE - 1;
            wp &= WSIZE - 1;
            buff[off + n++] = slide[wp++] = slide[copy_dist++];
          }

          if (n === size) {
            return size;
          }
        }

        method = -1; // done

        return n;
      }

      function inflate_stored(buff, off, size) {
        /* "decompress" an inflated type 0 (stored) block. */
        var n; // go to byte boundary

        n = bit_len & 7;
        DUMPBITS(n); // get the length and its complement

        NEEDBITS(16);
        n = GETBITS(16);
        DUMPBITS(16);
        NEEDBITS(16);

        if (n !== (~bit_buf & 0xffff)) {
          return -1; // error in compressed data
        }

        DUMPBITS(16); // read and output the compressed data

        copy_leng = n;
        n = 0;

        while (copy_leng > 0 && n < size) {
          copy_leng--;
          wp &= WSIZE - 1;
          NEEDBITS(8);
          buff[off + n++] = slide[wp++] = GETBITS(8);
          DUMPBITS(8);
        }

        if (copy_leng === 0) {
          method = -1; // done
        }

        return n;
      }

      function inflate_fixed(buff, off, size) {
        // decompress an inflated type 1 (fixed Huffman codes) block.  We should
        // either replace this with a custom decoder, or at least precompute the
        // Huffman tables.
        // if first time, set up tables for fixed blocks
        if (!fixed_tl) {
          var i; // temporary variable

          var l = []; // 288 length list for huft_build (initialized below)

          var h; // HuftBuild
          // literal table

          for (i = 0; i < 144; i++) {
            l[i] = 8;
          }

          for (null; i < 256; i++) {
            l[i] = 9;
          }

          for (null; i < 280; i++) {
            l[i] = 7;
          }

          for (null; i < 288; i++) {
            // make a complete, but wrong code set
            l[i] = 8;
          }

          fixed_bl = 7;
          h = new HuftBuild(l, 288, 257, cplens, cplext, fixed_bl);

          if (h.status !== 0) {
            console.error("HufBuild error: " + h.status);
            return -1;
          }

          fixed_tl = h.root;
          fixed_bl = h.m; // distance table

          for (i = 0; i < 30; i++) {
            // make an incomplete code set
            l[i] = 5;
          }

          fixed_bd = 5;
          h = new HuftBuild(l, 30, 0, cpdist, cpdext, fixed_bd);

          if (h.status > 1) {
            fixed_tl = null;
            console.error("HufBuild error: " + h.status);
            return -1;
          }

          fixed_td = h.root;
          fixed_bd = h.m;
        }

        tl = fixed_tl;
        td = fixed_td;
        bl = fixed_bl;
        bd = fixed_bd;
        return inflate_codes(buff, off, size);
      }

      function inflate_dynamic(buff, off, size) {
        // decompress an inflated type 2 (dynamic Huffman codes) block.
        var i; // temporary variables

        var j;
        var l; // last length

        var n; // number of lengths to get

        var t; // (HuftNode) literal/length code table

        var nb; // number of bit length codes

        var nl; // number of literal/length codes

        var nd; // number of distance codes

        var ll = [];
        var h; // (HuftBuild)
        // literal/length and distance code lengths

        for (i = 0; i < 286 + 30; i++) {
          ll[i] = 0;
        } // read in table lengths


        NEEDBITS(5);
        nl = 257 + GETBITS(5); // number of literal/length codes

        DUMPBITS(5);
        NEEDBITS(5);
        nd = 1 + GETBITS(5); // number of distance codes

        DUMPBITS(5);
        NEEDBITS(4);
        nb = 4 + GETBITS(4); // number of bit length codes

        DUMPBITS(4);

        if (nl > 286 || nd > 30) {
          return -1; // bad lengths
        } // read in bit-length-code lengths


        for (j = 0; j < nb; j++) {
          NEEDBITS(3);
          ll[border[j]] = GETBITS(3);
          DUMPBITS(3);
        }

        for (null; j < 19; j++) {
          ll[border[j]] = 0;
        } // build decoding table for trees--single level, 7 bit lookup


        bl = 7;
        h = new HuftBuild(ll, 19, 19, null, null, bl);

        if (h.status !== 0) {
          return -1; // incomplete code set
        }

        tl = h.root;
        bl = h.m; // read in literal and distance code lengths

        n = nl + nd;
        i = l = 0;

        while (i < n) {
          NEEDBITS(bl);
          t = tl.list[GETBITS(bl)];
          j = t.b;
          DUMPBITS(j);
          j = t.n;

          if (j < 16) {
            // length of code in bits (0..15)
            ll[i++] = l = j; // save last length in l
          } else if (j === 16) {
            // repeat last length 3 to 6 times
            NEEDBITS(2);
            j = 3 + GETBITS(2);
            DUMPBITS(2);

            if (i + j > n) {
              return -1;
            }

            while (j-- > 0) {
              ll[i++] = l;
            }
          } else if (j === 17) {
            // 3 to 10 zero length codes
            NEEDBITS(3);
            j = 3 + GETBITS(3);
            DUMPBITS(3);

            if (i + j > n) {
              return -1;
            }

            while (j-- > 0) {
              ll[i++] = 0;
            }

            l = 0;
          } else {
            // j === 18: 11 to 138 zero length codes
            NEEDBITS(7);
            j = 11 + GETBITS(7);
            DUMPBITS(7);

            if (i + j > n) {
              return -1;
            }

            while (j-- > 0) {
              ll[i++] = 0;
            }

            l = 0;
          }
        } // build the decoding tables for literal/length and distance codes


        bl = lbits;
        h = new HuftBuild(ll, nl, 257, cplens, cplext, bl);

        if (bl === 0) {
          // no literals or lengths
          h.status = 1;
        }

        if (h.status !== 0) {
          if (h.status !== 1) {
            return -1; // incomplete code set
          } // **incomplete literal tree**

        }

        tl = h.root;
        bl = h.m;

        for (i = 0; i < nd; i++) {
          ll[i] = ll[i + nl];
        }

        bd = dbits;
        h = new HuftBuild(ll, nd, 0, cpdist, cpdext, bd);
        td = h.root;
        bd = h.m;

        if (bd === 0 && nl > 257) {
          // lengths but no distances
          // **incomplete distance tree**
          return -1;
        }
        /*
        		if (h.status === 1) {
        			// **incomplete distance tree**
        		}
        */


        if (h.status !== 0) {
          return -1;
        } // decompress until an end-of-block code


        return inflate_codes(buff, off, size);
      }

      function inflate_start() {
        if (!slide) {
          slide = []; // new Array(2 * WSIZE); // slide.length is never called
        }

        wp = 0;
        bit_buf = 0;
        bit_len = 0;
        method = -1;
        eof = false;
        copy_leng = copy_dist = 0;
        tl = null;
      }

      function inflate_internal(buff, off, size) {
        // decompress an inflated entry
        var n, i;
        n = 0;

        while (n < size) {
          if (eof && method === -1) {
            return n;
          }

          if (copy_leng > 0) {
            if (method !== STORED_BLOCK) {
              // STATIC_TREES or DYN_TREES
              while (copy_leng > 0 && n < size) {
                copy_leng--;
                copy_dist &= WSIZE - 1;
                wp &= WSIZE - 1;
                buff[off + n++] = slide[wp++] = slide[copy_dist++];
              }
            } else {
              while (copy_leng > 0 && n < size) {
                copy_leng--;
                wp &= WSIZE - 1;
                NEEDBITS(8);
                buff[off + n++] = slide[wp++] = GETBITS(8);
                DUMPBITS(8);
              }

              if (copy_leng === 0) {
                method = -1; // done
              }
            }

            if (n === size) {
              return n;
            }
          }

          if (method === -1) {
            if (eof) {
              break;
            } // read in last block bit


            NEEDBITS(1);

            if (GETBITS(1) !== 0) {
              eof = true;
            }

            DUMPBITS(1); // read in block type

            NEEDBITS(2);
            method = GETBITS(2);
            DUMPBITS(2);
            tl = null;
            copy_leng = 0;
          }

          switch (method) {
            case STORED_BLOCK:
              i = inflate_stored(buff, off + n, size - n);
              break;

            case STATIC_TREES:
              if (tl) {
                i = inflate_codes(buff, off + n, size - n);
              } else {
                i = inflate_fixed(buff, off + n, size - n);
              }

              break;

            case DYN_TREES:
              if (tl) {
                i = inflate_codes(buff, off + n, size - n);
              } else {
                i = inflate_dynamic(buff, off + n, size - n);
              }

              break;

            default:
              // error
              i = -1;
              break;
          }

          if (i === -1) {
            if (eof) {
              return 0;
            }

            return -1;
          }

          n += i;
        }

        return n;
      }

      function inflate(arr) {
        var buff = [],
            i;
        inflate_start();
        inflate_data = arr;
        inflate_pos = 0;

        do {
          i = inflate_internal(buff, buff.length, 1024);
        } while (i > 0);

        inflate_data = null; // G.C.

        return buff;
      }

      module.exports = inflate;
    })();
  });

  var rawdeflate = createCommonjsModule(function (module) {
    /*
     * $Id: rawdeflate.js,v 0.3 2009/03/01 19:05:05 dankogai Exp dankogai $
     *
     * Original:
     *   http://www.onicos.com/staff/iz/amuse/javascript/expert/deflate.txt
     */

    /* Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>
     * Version: 1.0.1
     * LastModified: Dec 25 1999
     */

    /* Interface:
     * data = deflate(src);
     */
    (function () {
      /* constant parameters */
      var WSIZE = 32768,
          // Sliding Window size
      STORED_BLOCK = 0,
          STATIC_TREES = 1,
          DYN_TREES = 2,

      /* for deflate */
      DEFAULT_LEVEL = 6,
          // Input buffer size
      //INBUF_EXTRA = 64, // Extra buffer
      OUTBUFSIZ = 1024 * 8,
          window_size = 2 * WSIZE,
          MIN_MATCH = 3,
          MAX_MATCH = 258,
          // for SMALL_MEM
      LIT_BUFSIZE = 0x2000,
          //		HASH_BITS = 13,
      //for MEDIUM_MEM
      //	LIT_BUFSIZE = 0x4000,
      //	HASH_BITS = 14,
      // for BIG_MEM
      //	LIT_BUFSIZE = 0x8000,
      HASH_BITS = 15,
          DIST_BUFSIZE = LIT_BUFSIZE,
          HASH_SIZE = 1 << HASH_BITS,
          HASH_MASK = HASH_SIZE - 1,
          WMASK = WSIZE - 1,
          NIL = 0,
          // Tail of hash chains
      TOO_FAR = 4096,
          MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1,
          MAX_DIST = WSIZE - MIN_LOOKAHEAD,
          SMALLEST = 1,
          MAX_BITS = 15,
          MAX_BL_BITS = 7,
          LENGTH_CODES = 29,
          LITERALS = 256,
          END_BLOCK = 256,
          L_CODES = LITERALS + 1 + LENGTH_CODES,
          D_CODES = 30,
          BL_CODES = 19,
          REP_3_6 = 16,
          REPZ_3_10 = 17,
          REPZ_11_138 = 18,
          HEAP_SIZE = 2 * L_CODES + 1,
          H_SHIFT = parseInt((HASH_BITS + MIN_MATCH - 1) / MIN_MATCH, 10),

      /* variables */
      free_queue,
          qhead,
          qtail,
          initflag,
          outbuf = null,
          outcnt,
          outoff,
          complete,
          window,
          d_buf,
          l_buf,
          prev,
          bi_buf,
          bi_valid,
          block_start,
          ins_h,
          hash_head,
          prev_match,
          match_available,
          match_length,
          prev_length,
          strstart,
          match_start,
          eofile,
          lookahead,
          max_chain_length,
          max_lazy_match,
          compr_level,
          good_match,
          nice_match,
          dyn_ltree,
          dyn_dtree,
          static_ltree,
          static_dtree,
          bl_tree,
          l_desc,
          d_desc,
          bl_desc,
          bl_count,
          heap,
          heap_len,
          heap_max,
          depth,
          length_code,
          dist_code,
          base_length,
          base_dist,
          flag_buf,
          last_lit,
          last_dist,
          last_flags,
          flags,
          flag_bit,
          opt_len,
          static_len,
          deflate_data,
          deflate_pos;
      /* objects (deflate) */


      function DeflateCT() {
        this.fc = 0; // frequency count or bit string

        this.dl = 0; // father node in Huffman tree or length of bit string
      }

      function DeflateTreeDesc() {
        this.dyn_tree = null; // the dynamic tree

        this.static_tree = null; // corresponding static tree or NULL

        this.extra_bits = null; // extra bits for each code or NULL

        this.extra_base = 0; // base index for extra_bits

        this.elems = 0; // max number of elements in the tree

        this.max_length = 0; // max bit length for the codes

        this.max_code = 0; // largest code with non zero frequency
      }
      /* Values for max_lazy_match, good_match and max_chain_length, depending on
       * the desired pack level (0..9). The values given below have been tuned to
       * exclude worst case performance for pathological files. Better values may be
       * found for specific files.
       */


      function DeflateConfiguration(a, b, c, d) {
        this.good_length = a; // reduce lazy search above this match length

        this.max_lazy = b; // do not perform lazy search above this match length

        this.nice_length = c; // quit search above this match length

        this.max_chain = d;
      }

      function DeflateBuffer() {
        this.next = null;
        this.len = 0;
        this.ptr = []; // new Array(OUTBUFSIZ); // ptr.length is never read

        this.off = 0;
      }
      /* constant tables */


      var extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];
      var extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
      var extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];
      var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
      var configuration_table = [new DeflateConfiguration(0, 0, 0, 0), new DeflateConfiguration(4, 4, 8, 4), new DeflateConfiguration(4, 5, 16, 8), new DeflateConfiguration(4, 6, 32, 32), new DeflateConfiguration(4, 4, 16, 16), new DeflateConfiguration(8, 16, 32, 32), new DeflateConfiguration(8, 16, 128, 128), new DeflateConfiguration(8, 32, 128, 256), new DeflateConfiguration(32, 128, 258, 1024), new DeflateConfiguration(32, 258, 258, 4096)];
      /* routines (deflate) */

      function deflate_start(level) {
        var i;

        if (!level) {
          level = DEFAULT_LEVEL;
        } else if (level < 1) {
          level = 1;
        } else if (level > 9) {
          level = 9;
        }

        compr_level = level;
        initflag = false;
        eofile = false;

        if (outbuf !== null) {
          return;
        }

        free_queue = qhead = qtail = null;
        outbuf = []; // new Array(OUTBUFSIZ); // outbuf.length never called

        window = []; // new Array(window_size); // window.length never called

        d_buf = []; // new Array(DIST_BUFSIZE); // d_buf.length never called

        l_buf = []; // new Array(INBUFSIZ + INBUF_EXTRA); // l_buf.length never called

        prev = []; // new Array(1 << BITS); // prev.length never called

        dyn_ltree = [];

        for (i = 0; i < HEAP_SIZE; i++) {
          dyn_ltree[i] = new DeflateCT();
        }

        dyn_dtree = [];

        for (i = 0; i < 2 * D_CODES + 1; i++) {
          dyn_dtree[i] = new DeflateCT();
        }

        static_ltree = [];

        for (i = 0; i < L_CODES + 2; i++) {
          static_ltree[i] = new DeflateCT();
        }

        static_dtree = [];

        for (i = 0; i < D_CODES; i++) {
          static_dtree[i] = new DeflateCT();
        }

        bl_tree = [];

        for (i = 0; i < 2 * BL_CODES + 1; i++) {
          bl_tree[i] = new DeflateCT();
        }

        l_desc = new DeflateTreeDesc();
        d_desc = new DeflateTreeDesc();
        bl_desc = new DeflateTreeDesc();
        bl_count = []; // new Array(MAX_BITS+1); // bl_count.length never called

        heap = []; // new Array(2*L_CODES+1); // heap.length never called

        depth = []; // new Array(2*L_CODES+1); // depth.length never called

        length_code = []; // new Array(MAX_MATCH-MIN_MATCH+1); // length_code.length never called

        dist_code = []; // new Array(512); // dist_code.length never called

        base_length = []; // new Array(LENGTH_CODES); // base_length.length never called

        base_dist = []; // new Array(D_CODES); // base_dist.length never called

        flag_buf = []; // new Array(parseInt(LIT_BUFSIZE / 8, 10)); // flag_buf.length never called
      }

      function reuse_queue(p) {
        p.next = free_queue;
        free_queue = p;
      }

      function new_queue() {
        var p;

        if (free_queue !== null) {
          p = free_queue;
          free_queue = free_queue.next;
        } else {
          p = new DeflateBuffer();
        }

        p.next = null;
        p.len = p.off = 0;
        return p;
      }

      function head1(i) {
        return prev[WSIZE + i];
      }

      function head2(i, val) {
        return prev[WSIZE + i] = val;
      }
      /* put_byte is used for the compressed output, put_ubyte for the
       * uncompressed output. However unlzw() uses window for its
       * suffix table instead of its output buffer, so it does not use put_ubyte
       * (to be cleaned up).
       */


      function put_byte(c) {
        outbuf[outoff + outcnt++] = c;

        if (outoff + outcnt === OUTBUFSIZ) {
          qoutbuf();
        }
      }
      /* Output a 16 bit value, lsb first */


      function put_short(w) {
        w &= 0xffff;

        if (outoff + outcnt < OUTBUFSIZ - 2) {
          outbuf[outoff + outcnt++] = w & 0xff;
          outbuf[outoff + outcnt++] = w >>> 8;
        } else {
          put_byte(w & 0xff);
          put_byte(w >>> 8);
        }
      }
      /* ==========================================================================
       * Insert string s in the dictionary and set match_head to the previous head
       * of the hash chain (the most recent string with same hash key). Return
       * the previous length of the hash chain.
       * IN  assertion: all calls to to INSERT_STRING are made with consecutive
       *    input characters and the first MIN_MATCH bytes of s are valid
       *    (except for the last MIN_MATCH-1 bytes of the input file).
       */


      function INSERT_STRING() {
        ins_h = (ins_h << H_SHIFT ^ window[strstart + MIN_MATCH - 1] & 0xff) & HASH_MASK;
        hash_head = head1(ins_h);
        prev[strstart & WMASK] = hash_head;
        head2(ins_h, strstart);
      }
      /* Send a code of the given tree. c and tree must not have side effects */


      function SEND_CODE(c, tree) {
        send_bits(tree[c].fc, tree[c].dl);
      }
      /* Mapping from a distance to a distance code. dist is the distance - 1 and
       * must not have side effects. dist_code[256] and dist_code[257] are never
       * used.
       */


      function D_CODE(dist) {
        return (dist < 256 ? dist_code[dist] : dist_code[256 + (dist >> 7)]) & 0xff;
      }
      /* ==========================================================================
       * Compares to subtrees, using the tree depth as tie breaker when
       * the subtrees have equal frequency. This minimizes the worst case length.
       */


      function SMALLER(tree, n, m) {
        return tree[n].fc < tree[m].fc || tree[n].fc === tree[m].fc && depth[n] <= depth[m];
      }
      /* ==========================================================================
       * read string data
       */


      function read_buff(buff, offset, n) {
        var i;

        for (i = 0; i < n && deflate_pos < deflate_data.length; i++) {
          buff[offset + i] = deflate_data[deflate_pos++] & 0xff;
        }

        return i;
      }
      /* ==========================================================================
       * Initialize the "longest match" routines for a new file
       */


      function lm_init() {
        var j; // Initialize the hash table. */

        for (j = 0; j < HASH_SIZE; j++) {
          // head2(j, NIL);
          prev[WSIZE + j] = 0;
        } // prev will be initialized on the fly */
        // Set the default configuration parameters:


        max_lazy_match = configuration_table[compr_level].max_lazy;
        good_match = configuration_table[compr_level].good_length;

        {
          nice_match = configuration_table[compr_level].nice_length;
        }

        max_chain_length = configuration_table[compr_level].max_chain;
        strstart = 0;
        block_start = 0;
        lookahead = read_buff(window, 0, 2 * WSIZE);

        if (lookahead <= 0) {
          eofile = true;
          lookahead = 0;
          return;
        }

        eofile = false; // Make sure that we always have enough lookahead. This is important
        // if input comes from a device such as a tty.

        while (lookahead < MIN_LOOKAHEAD && !eofile) {
          fill_window();
        } // If lookahead < MIN_MATCH, ins_h is garbage, but this is
        // not important since only literal bytes will be emitted.


        ins_h = 0;

        for (j = 0; j < MIN_MATCH - 1; j++) {
          // UPDATE_HASH(ins_h, window[j]);
          ins_h = (ins_h << H_SHIFT ^ window[j] & 0xff) & HASH_MASK;
        }
      }
      /* ==========================================================================
       * Set match_start to the longest match starting at the given string and
       * return its length. Matches shorter or equal to prev_length are discarded,
       * in which case the result is equal to prev_length and match_start is
       * garbage.
       * IN assertions: cur_match is the head of the hash chain for the current
       *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
       */


      function longest_match(cur_match) {
        var chain_length = max_chain_length; // max hash chain length

        var scanp = strstart; // current string

        var matchp; // matched string

        var len; // length of current match

        var best_len = prev_length; // best match length so far
        // Stop when cur_match becomes <= limit. To simplify the code,
        // we prevent matches with the string of window index 0.

        var limit = strstart > MAX_DIST ? strstart - MAX_DIST : NIL;
        var strendp = strstart + MAX_MATCH;
        var scan_end1 = window[scanp + best_len - 1];
        var scan_end = window[scanp + best_len];
        var i, broke; // Do not waste too much time if we already have a good match: */

        if (prev_length >= good_match) {
          chain_length >>= 2;
        } // Assert(encoder->strstart <= window_size-MIN_LOOKAHEAD, "insufficient lookahead");


        do {
          // Assert(cur_match < encoder->strstart, "no future");
          matchp = cur_match; // Skip to next match if the match length cannot increase
          // or if the match length is less than 2:

          if (window[matchp + best_len] !== scan_end || window[matchp + best_len - 1] !== scan_end1 || window[matchp] !== window[scanp] || window[++matchp] !== window[scanp + 1]) {
            continue;
          } // The check at best_len-1 can be removed because it will be made
          // again later. (This heuristic is not always a win.)
          // It is not necessary to compare scan[2] and match[2] since they
          // are always equal when the other bytes match, given that
          // the hash keys are equal and that HASH_BITS >= 8.


          scanp += 2;
          matchp++; // We check for insufficient lookahead only every 8th comparison;
          // the 256th check will be made at strstart+258.

          while (scanp < strendp) {
            broke = false;

            for (i = 0; i < 8; i += 1) {
              scanp += 1;
              matchp += 1;

              if (window[scanp] !== window[matchp]) {
                broke = true;
                break;
              }
            }

            if (broke) {
              break;
            }
          }

          len = MAX_MATCH - (strendp - scanp);
          scanp = strendp - MAX_MATCH;

          if (len > best_len) {
            match_start = cur_match;
            best_len = len;

            {
              if (len >= nice_match) {
                break;
              }
            }

            scan_end1 = window[scanp + best_len - 1];
            scan_end = window[scanp + best_len];
          }
        } while ((cur_match = prev[cur_match & WMASK]) > limit && --chain_length !== 0);

        return best_len;
      }
      /* ==========================================================================
       * Fill the window when the lookahead becomes insufficient.
       * Updates strstart and lookahead, and sets eofile if end of input file.
       * IN assertion: lookahead < MIN_LOOKAHEAD && strstart + lookahead > 0
       * OUT assertions: at least one byte has been read, or eofile is set;
       *    file reads are performed for at least two bytes (required for the
       *    translate_eol option).
       */


      function fill_window() {
        var n, m; // Amount of free space at the end of the window.

        var more = window_size - lookahead - strstart; // If the window is almost full and there is insufficient lookahead,
        // move the upper half to the lower one to make room in the upper half.

        if (more === -1) {
          // Very unlikely, but possible on 16 bit machine if strstart == 0
          // and lookahead == 1 (input done one byte at time)
          more--;
        } else if (strstart >= WSIZE + MAX_DIST) {
          // By the IN assertion, the window is not empty so we can't confuse
          // more == 0 with more == 64K on a 16 bit machine.
          // Assert(window_size == (ulg)2*WSIZE, "no sliding with BIG_MEM");
          // System.arraycopy(window, WSIZE, window, 0, WSIZE);
          for (n = 0; n < WSIZE; n++) {
            window[n] = window[n + WSIZE];
          }

          match_start -= WSIZE;
          strstart -= WSIZE;
          /* we now have strstart >= MAX_DIST: */

          block_start -= WSIZE;

          for (n = 0; n < HASH_SIZE; n++) {
            m = head1(n);
            head2(n, m >= WSIZE ? m - WSIZE : NIL);
          }

          for (n = 0; n < WSIZE; n++) {
            // If n is not on any hash chain, prev[n] is garbage but
            // its value will never be used.
            m = prev[n];
            prev[n] = m >= WSIZE ? m - WSIZE : NIL;
          }

          more += WSIZE;
        } // At this point, more >= 2


        if (!eofile) {
          n = read_buff(window, strstart + lookahead, more);

          if (n <= 0) {
            eofile = true;
          } else {
            lookahead += n;
          }
        }
      }
      /* ==========================================================================
       * Processes a new input file and return its compressed length. This
       * function does not perform lazy evaluationof matches and inserts
       * new strings in the dictionary only for unmatched strings or for short
       * matches. It is used only for the fast compression options.
       */


      function deflate_fast() {
        while (lookahead !== 0 && qhead === null) {
          var flush; // set if current block must be flushed
          // Insert the string window[strstart .. strstart+2] in the
          // dictionary, and set hash_head to the head of the hash chain:

          INSERT_STRING(); // Find the longest match, discarding those <= prev_length.
          // At this point we have always match_length < MIN_MATCH

          if (hash_head !== NIL && strstart - hash_head <= MAX_DIST) {
            // To simplify the code, we prevent matches with the string
            // of window index 0 (in particular we have to avoid a match
            // of the string with itself at the start of the input file).
            match_length = longest_match(hash_head); // longest_match() sets match_start */

            if (match_length > lookahead) {
              match_length = lookahead;
            }
          }

          if (match_length >= MIN_MATCH) {
            // check_match(strstart, match_start, match_length);
            flush = ct_tally(strstart - match_start, match_length - MIN_MATCH);
            lookahead -= match_length; // Insert new strings in the hash table only if the match length
            // is not too large. This saves time but degrades compression.

            if (match_length <= max_lazy_match) {
              match_length--; // string at strstart already in hash table

              do {
                strstart++;
                INSERT_STRING(); // strstart never exceeds WSIZE-MAX_MATCH, so there are
                // always MIN_MATCH bytes ahead. If lookahead < MIN_MATCH
                // these bytes are garbage, but it does not matter since
                // the next lookahead bytes will be emitted as literals.
              } while (--match_length !== 0);

              strstart++;
            } else {
              strstart += match_length;
              match_length = 0;
              ins_h = window[strstart] & 0xff; // UPDATE_HASH(ins_h, window[strstart + 1]);

              ins_h = (ins_h << H_SHIFT ^ window[strstart + 1] & 0xff) & HASH_MASK; //#if MIN_MATCH !== 3
              //		Call UPDATE_HASH() MIN_MATCH-3 more times
              //#endif
            }
          } else {
            // No match, output a literal byte */
            flush = ct_tally(0, window[strstart] & 0xff);
            lookahead--;
            strstart++;
          }

          if (flush) {
            flush_block(0);
            block_start = strstart;
          } // Make sure that we always have enough lookahead, except
          // at the end of the input file. We need MAX_MATCH bytes
          // for the next match, plus MIN_MATCH bytes to insert the
          // string following the next match.


          while (lookahead < MIN_LOOKAHEAD && !eofile) {
            fill_window();
          }
        }
      }

      function deflate_better() {
        // Process the input block. */
        while (lookahead !== 0 && qhead === null) {
          // Insert the string window[strstart .. strstart+2] in the
          // dictionary, and set hash_head to the head of the hash chain:
          INSERT_STRING(); // Find the longest match, discarding those <= prev_length.

          prev_length = match_length;
          prev_match = match_start;
          match_length = MIN_MATCH - 1;

          if (hash_head !== NIL && prev_length < max_lazy_match && strstart - hash_head <= MAX_DIST) {
            // To simplify the code, we prevent matches with the string
            // of window index 0 (in particular we have to avoid a match
            // of the string with itself at the start of the input file).
            match_length = longest_match(hash_head); // longest_match() sets match_start */

            if (match_length > lookahead) {
              match_length = lookahead;
            } // Ignore a length 3 match if it is too distant: */


            if (match_length === MIN_MATCH && strstart - match_start > TOO_FAR) {
              // If prev_match is also MIN_MATCH, match_start is garbage
              // but we will ignore the current match anyway.
              match_length--;
            }
          } // If there was a match at the previous step and the current
          // match is not better, output the previous match:


          if (prev_length >= MIN_MATCH && match_length <= prev_length) {
            var flush; // set if current block must be flushed
            // check_match(strstart - 1, prev_match, prev_length);

            flush = ct_tally(strstart - 1 - prev_match, prev_length - MIN_MATCH); // Insert in hash table all strings up to the end of the match.
            // strstart-1 and strstart are already inserted.

            lookahead -= prev_length - 1;
            prev_length -= 2;

            do {
              strstart++;
              INSERT_STRING(); // strstart never exceeds WSIZE-MAX_MATCH, so there are
              // always MIN_MATCH bytes ahead. If lookahead < MIN_MATCH
              // these bytes are garbage, but it does not matter since the
              // next lookahead bytes will always be emitted as literals.
            } while (--prev_length !== 0);

            match_available = false;
            match_length = MIN_MATCH - 1;
            strstart++;

            if (flush) {
              flush_block(0);
              block_start = strstart;
            }
          } else if (match_available) {
            // If there was no match at the previous position, output a
            // single literal. If there was a match but the current match
            // is longer, truncate the previous match to a single literal.
            if (ct_tally(0, window[strstart - 1] & 0xff)) {
              flush_block(0);
              block_start = strstart;
            }

            strstart++;
            lookahead--;
          } else {
            // There is no previous match to compare with, wait for
            // the next step to decide.
            match_available = true;
            strstart++;
            lookahead--;
          } // Make sure that we always have enough lookahead, except
          // at the end of the input file. We need MAX_MATCH bytes
          // for the next match, plus MIN_MATCH bytes to insert the
          // string following the next match.


          while (lookahead < MIN_LOOKAHEAD && !eofile) {
            fill_window();
          }
        }
      }

      function init_deflate() {
        if (eofile) {
          return;
        }

        bi_buf = 0;
        bi_valid = 0;
        ct_init();
        lm_init();
        qhead = null;
        outcnt = 0;
        outoff = 0;

        if (compr_level <= 3) {
          prev_length = MIN_MATCH - 1;
          match_length = 0;
        } else {
          match_length = MIN_MATCH - 1;
          match_available = false;
        }

        complete = false;
      }
      /* ==========================================================================
       * Same as above, but achieves better compression. We use a lazy
       * evaluation for matches: a match is finally adopted only if there is
       * no better match at the next window position.
       */


      function deflate_internal(buff, off, buff_size) {
        var n;

        if (!initflag) {
          init_deflate();
          initflag = true;

          if (lookahead === 0) {
            // empty
            complete = true;
            return 0;
          }
        }

        n = qcopy(buff, off, buff_size);

        if (n === buff_size) {
          return buff_size;
        }

        if (complete) {
          return n;
        }

        if (compr_level <= 3) {
          // optimized for speed
          deflate_fast();
        } else {
          deflate_better();
        }

        if (lookahead === 0) {
          if (match_available) {
            ct_tally(0, window[strstart - 1] & 0xff);
          }

          flush_block(1);
          complete = true;
        }

        return n + qcopy(buff, n + off, buff_size - n);
      }

      function qcopy(buff, off, buff_size) {
        var n, i, j;
        n = 0;

        while (qhead !== null && n < buff_size) {
          i = buff_size - n;

          if (i > qhead.len) {
            i = qhead.len;
          } // System.arraycopy(qhead.ptr, qhead.off, buff, off + n, i);


          for (j = 0; j < i; j++) {
            buff[off + n + j] = qhead.ptr[qhead.off + j];
          }

          qhead.off += i;
          qhead.len -= i;
          n += i;

          if (qhead.len === 0) {
            var p;
            p = qhead;
            qhead = qhead.next;
            reuse_queue(p);
          }
        }

        if (n === buff_size) {
          return n;
        }

        if (outoff < outcnt) {
          i = buff_size - n;

          if (i > outcnt - outoff) {
            i = outcnt - outoff;
          } // System.arraycopy(outbuf, outoff, buff, off + n, i);


          for (j = 0; j < i; j++) {
            buff[off + n + j] = outbuf[outoff + j];
          }

          outoff += i;
          n += i;

          if (outcnt === outoff) {
            outcnt = outoff = 0;
          }
        }

        return n;
      }
      /* ==========================================================================
       * Allocate the match buffer, initialize the various tables and save the
       * location of the internal file attribute (ascii/binary) and method
       * (DEFLATE/STORE).
       */


      function ct_init() {
        var n; // iterates over tree elements

        var bits; // bit counter

        var length; // length value

        var code; // code value

        var dist; // distance index

        if (static_dtree[0].dl !== 0) {
          return; // ct_init already called
        }

        l_desc.dyn_tree = dyn_ltree;
        l_desc.static_tree = static_ltree;
        l_desc.extra_bits = extra_lbits;
        l_desc.extra_base = LITERALS + 1;
        l_desc.elems = L_CODES;
        l_desc.max_length = MAX_BITS;
        l_desc.max_code = 0;
        d_desc.dyn_tree = dyn_dtree;
        d_desc.static_tree = static_dtree;
        d_desc.extra_bits = extra_dbits;
        d_desc.extra_base = 0;
        d_desc.elems = D_CODES;
        d_desc.max_length = MAX_BITS;
        d_desc.max_code = 0;
        bl_desc.dyn_tree = bl_tree;
        bl_desc.static_tree = null;
        bl_desc.extra_bits = extra_blbits;
        bl_desc.extra_base = 0;
        bl_desc.elems = BL_CODES;
        bl_desc.max_length = MAX_BL_BITS;
        bl_desc.max_code = 0; // Initialize the mapping length (0..255) -> length code (0..28)

        length = 0;

        for (code = 0; code < LENGTH_CODES - 1; code++) {
          base_length[code] = length;

          for (n = 0; n < 1 << extra_lbits[code]; n++) {
            length_code[length++] = code;
          }
        } // Assert (length === 256, "ct_init: length !== 256");
        // Note that the length 255 (match length 258) can be represented
        // in two different ways: code 284 + 5 bits or code 285, so we
        // overwrite length_code[255] to use the best encoding:


        length_code[length - 1] = code; // Initialize the mapping dist (0..32K) -> dist code (0..29) */

        dist = 0;

        for (code = 0; code < 16; code++) {
          base_dist[code] = dist;

          for (n = 0; n < 1 << extra_dbits[code]; n++) {
            dist_code[dist++] = code;
          }
        } // Assert (dist === 256, "ct_init: dist !== 256");
        // from now on, all distances are divided by 128


        for (dist >>= 7; code < D_CODES; code++) {
          base_dist[code] = dist << 7;

          for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
            dist_code[256 + dist++] = code;
          }
        } // Assert (dist === 256, "ct_init: 256+dist !== 512");
        // Construct the codes of the static literal tree


        for (bits = 0; bits <= MAX_BITS; bits++) {
          bl_count[bits] = 0;
        }

        n = 0;

        while (n <= 143) {
          static_ltree[n++].dl = 8;
          bl_count[8]++;
        }

        while (n <= 255) {
          static_ltree[n++].dl = 9;
          bl_count[9]++;
        }

        while (n <= 279) {
          static_ltree[n++].dl = 7;
          bl_count[7]++;
        }

        while (n <= 287) {
          static_ltree[n++].dl = 8;
          bl_count[8]++;
        } // Codes 286 and 287 do not exist, but we must include them in the
        // tree construction to get a canonical Huffman tree (longest code
        // all ones)


        gen_codes(static_ltree, L_CODES + 1); // The static distance tree is trivial: */

        for (n = 0; n < D_CODES; n++) {
          static_dtree[n].dl = 5;
          static_dtree[n].fc = bi_reverse(n, 5);
        } // Initialize the first block of the first file:


        init_block();
      }
      /* ==========================================================================
       * Initialize a new block.
       */


      function init_block() {
        var n; // iterates over tree elements
        // Initialize the trees.

        for (n = 0; n < L_CODES; n++) {
          dyn_ltree[n].fc = 0;
        }

        for (n = 0; n < D_CODES; n++) {
          dyn_dtree[n].fc = 0;
        }

        for (n = 0; n < BL_CODES; n++) {
          bl_tree[n].fc = 0;
        }

        dyn_ltree[END_BLOCK].fc = 1;
        opt_len = static_len = 0;
        last_lit = last_dist = last_flags = 0;
        flags = 0;
        flag_bit = 1;
      }
      /* ==========================================================================
       * Restore the heap property by moving down the tree starting at node k,
       * exchanging a node with the smallest of its two sons if necessary, stopping
       * when the heap property is re-established (each father smaller than its
       * two sons).
       *
       * @param tree- tree to restore
       * @param k- node to move down
       */


      function pqdownheap(tree, k) {
        var v = heap[k],
            j = k << 1; // left son of k

        while (j <= heap_len) {
          // Set j to the smallest of the two sons:
          if (j < heap_len && SMALLER(tree, heap[j + 1], heap[j])) {
            j++;
          } // Exit if v is smaller than both sons


          if (SMALLER(tree, v, heap[j])) {
            break;
          } // Exchange v with the smallest son


          heap[k] = heap[j];
          k = j; // And continue down the tree, setting j to the left son of k

          j <<= 1;
        }

        heap[k] = v;
      }
      /* ==========================================================================
       * Compute the optimal bit lengths for a tree and update the total bit length
       * for the current block.
       * IN assertion: the fields freq and dad are set, heap[heap_max] and
       *    above are the tree nodes sorted by increasing frequency.
       * OUT assertions: the field len is set to the optimal bit length, the
       *     array bl_count contains the frequencies for each bit length.
       *     The length opt_len is updated; static_len is also updated if stree is
       *     not null.
       */


      function gen_bitlen(desc) {
        // the tree descriptor
        var tree = desc.dyn_tree;
        var extra = desc.extra_bits;
        var base = desc.extra_base;
        var max_code = desc.max_code;
        var max_length = desc.max_length;
        var stree = desc.static_tree;
        var h; // heap index

        var n, m; // iterate over the tree elements

        var bits; // bit length

        var xbits; // extra bits

        var f; // frequency

        var overflow = 0; // number of elements with bit length too large

        for (bits = 0; bits <= MAX_BITS; bits++) {
          bl_count[bits] = 0;
        } // In a first pass, compute the optimal bit lengths (which may
        // overflow in the case of the bit length tree).


        tree[heap[heap_max]].dl = 0; // root of the heap

        for (h = heap_max + 1; h < HEAP_SIZE; h++) {
          n = heap[h];
          bits = tree[tree[n].dl].dl + 1;

          if (bits > max_length) {
            bits = max_length;
            overflow++;
          }

          tree[n].dl = bits; // We overwrite tree[n].dl which is no longer needed

          if (n > max_code) {
            continue; // not a leaf node
          }

          bl_count[bits]++;
          xbits = 0;

          if (n >= base) {
            xbits = extra[n - base];
          }

          f = tree[n].fc;
          opt_len += f * (bits + xbits);

          if (stree !== null) {
            static_len += f * (stree[n].dl + xbits);
          }
        }

        if (overflow === 0) {
          return;
        } // This happens for example on obj2 and pic of the Calgary corpus
        // Find the first bit length which could increase:


        do {
          bits = max_length - 1;

          while (bl_count[bits] === 0) {
            bits--;
          }

          bl_count[bits]--; // move one leaf down the tree

          bl_count[bits + 1] += 2; // move one overflow item as its brother

          bl_count[max_length]--; // The brother of the overflow item also moves one step up,
          // but this does not affect bl_count[max_length]

          overflow -= 2;
        } while (overflow > 0); // Now recompute all bit lengths, scanning in increasing frequency.
        // h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
        // lengths instead of fixing only the wrong ones. This idea is taken
        // from 'ar' written by Haruhiko Okumura.)


        for (bits = max_length; bits !== 0; bits--) {
          n = bl_count[bits];

          while (n !== 0) {
            m = heap[--h];

            if (m > max_code) {
              continue;
            }

            if (tree[m].dl !== bits) {
              opt_len += (bits - tree[m].dl) * tree[m].fc;
              tree[m].fc = bits;
            }

            n--;
          }
        }
      }
      /* ==========================================================================
       * Generate the codes for a given tree and bit counts (which need not be
       * optimal).
       * IN assertion: the array bl_count contains the bit length statistics for
       * the given tree and the field len is set for all tree elements.
       * OUT assertion: the field code is set for all tree elements of non
       *     zero code length.
       * @param tree- the tree to decorate
       * @param max_code- largest code with non-zero frequency
       */


      function gen_codes(tree, max_code) {
        var next_code = []; // new Array(MAX_BITS + 1); // next code value for each bit length

        var code = 0; // running code value

        var bits; // bit index

        var n; // code index
        // The distribution counts are first used to generate the code values
        // without bit reversal.

        for (bits = 1; bits <= MAX_BITS; bits++) {
          code = code + bl_count[bits - 1] << 1;
          next_code[bits] = code;
        } // Check that the bit counts in bl_count are consistent. The last code
        // must be all ones.
        // Assert (code + encoder->bl_count[MAX_BITS]-1 === (1<<MAX_BITS)-1, "inconsistent bit counts");
        // Tracev((stderr,"\ngen_codes: max_code %d ", max_code));


        for (n = 0; n <= max_code; n++) {
          var len = tree[n].dl;

          if (len === 0) {
            continue;
          } // Now reverse the bits


          tree[n].fc = bi_reverse(next_code[len]++, len); // Tracec(tree !== static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ", n, (isgraph(n) ? n : ' '), len, tree[n].fc, next_code[len]-1));
        }
      }
      /* ==========================================================================
       * Construct one Huffman tree and assigns the code bit strings and lengths.
       * Update the total bit length for the current block.
       * IN assertion: the field freq is set for all tree elements.
       * OUT assertions: the fields len and code are set to the optimal bit length
       *     and corresponding code. The length opt_len is updated; static_len is
       *     also updated if stree is not null. The field max_code is set.
       */


      function build_tree(desc) {
        // the tree descriptor
        var tree = desc.dyn_tree;
        var stree = desc.static_tree;
        var elems = desc.elems;
        var n, m; // iterate over heap elements

        var max_code = -1; // largest code with non zero frequency

        var node = elems; // next internal node of the tree
        // Construct the initial heap, with least frequent element in
        // heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
        // heap[0] is not used.

        heap_len = 0;
        heap_max = HEAP_SIZE;

        for (n = 0; n < elems; n++) {
          if (tree[n].fc !== 0) {
            heap[++heap_len] = max_code = n;
            depth[n] = 0;
          } else {
            tree[n].dl = 0;
          }
        } // The pkzip format requires that at least one distance code exists,
        // and that at least one bit should be sent even if there is only one
        // possible code. So to avoid special checks later on we force at least
        // two codes of non zero frequency.


        while (heap_len < 2) {
          var xnew = heap[++heap_len] = max_code < 2 ? ++max_code : 0;
          tree[xnew].fc = 1;
          depth[xnew] = 0;
          opt_len--;

          if (stree !== null) {
            static_len -= stree[xnew].dl;
          } // new is 0 or 1 so it does not have extra bits

        }

        desc.max_code = max_code; // The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
        // establish sub-heaps of increasing lengths:

        for (n = heap_len >> 1; n >= 1; n--) {
          pqdownheap(tree, n);
        } // Construct the Huffman tree by repeatedly combining the least two
        // frequent nodes.


        do {
          n = heap[SMALLEST];
          heap[SMALLEST] = heap[heap_len--];
          pqdownheap(tree, SMALLEST);
          m = heap[SMALLEST]; // m = node of next least frequency
          // keep the nodes sorted by frequency

          heap[--heap_max] = n;
          heap[--heap_max] = m; // Create a new node father of n and m

          tree[node].fc = tree[n].fc + tree[m].fc; //	depth[node] = (char)(MAX(depth[n], depth[m]) + 1);

          if (depth[n] > depth[m] + 1) {
            depth[node] = depth[n];
          } else {
            depth[node] = depth[m] + 1;
          }

          tree[n].dl = tree[m].dl = node; // and insert the new node in the heap

          heap[SMALLEST] = node++;
          pqdownheap(tree, SMALLEST);
        } while (heap_len >= 2);

        heap[--heap_max] = heap[SMALLEST]; // At this point, the fields freq and dad are set. We can now
        // generate the bit lengths.

        gen_bitlen(desc); // The field len is now set, we can generate the bit codes

        gen_codes(tree, max_code);
      }
      /* ==========================================================================
       * Scan a literal or distance tree to determine the frequencies of the codes
       * in the bit length tree. Updates opt_len to take into account the repeat
       * counts. (The contribution of the bit length codes will be added later
       * during the construction of bl_tree.)
       *
       * @param tree- the tree to be scanned
       * @param max_code- and its largest code of non zero frequency
       */


      function scan_tree(tree, max_code) {
        var n,
            // iterates over all tree elements
        prevlen = -1,
            // last emitted length
        curlen,
            // length of current code
        nextlen = tree[0].dl,
            // length of next code
        count = 0,
            // repeat count of the current code
        max_count = 7,
            // max repeat count
        min_count = 4; // min repeat count

        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        }

        tree[max_code + 1].dl = 0xffff; // guard

        for (n = 0; n <= max_code; n++) {
          curlen = nextlen;
          nextlen = tree[n + 1].dl;

          if (++count < max_count && curlen === nextlen) {
            continue;
          } else if (count < min_count) {
            bl_tree[curlen].fc += count;
          } else if (curlen !== 0) {
            if (curlen !== prevlen) {
              bl_tree[curlen].fc++;
            }

            bl_tree[REP_3_6].fc++;
          } else if (count <= 10) {
            bl_tree[REPZ_3_10].fc++;
          } else {
            bl_tree[REPZ_11_138].fc++;
          }

          count = 0;
          prevlen = curlen;

          if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
          } else if (curlen === nextlen) {
            max_count = 6;
            min_count = 3;
          } else {
            max_count = 7;
            min_count = 4;
          }
        }
      }
      /* ==========================================================================
       * Send a literal or distance tree in compressed form, using the codes in
       * bl_tree.
       *
       * @param tree- the tree to be scanned
       * @param max_code- and its largest code of non zero frequency
       */


      function send_tree(tree, max_code) {
        var n; // iterates over all tree elements

        var prevlen = -1; // last emitted length

        var curlen; // length of current code

        var nextlen = tree[0].dl; // length of next code

        var count = 0; // repeat count of the current code

        var max_count = 7; // max repeat count

        var min_count = 4; // min repeat count
        // tree[max_code+1].dl = -1; */  /* guard already set */

        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        }

        for (n = 0; n <= max_code; n++) {
          curlen = nextlen;
          nextlen = tree[n + 1].dl;

          if (++count < max_count && curlen === nextlen) {
            continue;
          } else if (count < min_count) {
            do {
              SEND_CODE(curlen, bl_tree);
            } while (--count !== 0);
          } else if (curlen !== 0) {
            if (curlen !== prevlen) {
              SEND_CODE(curlen, bl_tree);
              count--;
            } // Assert(count >= 3 && count <= 6, " 3_6?");


            SEND_CODE(REP_3_6, bl_tree);
            send_bits(count - 3, 2);
          } else if (count <= 10) {
            SEND_CODE(REPZ_3_10, bl_tree);
            send_bits(count - 3, 3);
          } else {
            SEND_CODE(REPZ_11_138, bl_tree);
            send_bits(count - 11, 7);
          }

          count = 0;
          prevlen = curlen;

          if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
          } else if (curlen === nextlen) {
            max_count = 6;
            min_count = 3;
          } else {
            max_count = 7;
            min_count = 4;
          }
        }
      }
      /* ==========================================================================
       * Construct the Huffman tree for the bit lengths and return the index in
       * bl_order of the last bit length code to send.
       */


      function build_bl_tree() {
        var max_blindex; // index of last bit length code of non zero freq
        // Determine the bit length frequencies for literal and distance trees

        scan_tree(dyn_ltree, l_desc.max_code);
        scan_tree(dyn_dtree, d_desc.max_code); // Build the bit length tree:

        build_tree(bl_desc); // opt_len now includes the length of the tree representations, except
        // the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
        // Determine the number of bit length codes to send. The pkzip format
        // requires that at least 4 bit length codes be sent. (appnote.txt says
        // 3 but the actual value used is 4.)

        for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
          if (bl_tree[bl_order[max_blindex]].dl !== 0) {
            break;
          }
        } // Update opt_len to include the bit length tree and counts */


        opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4; // Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
        // encoder->opt_len, encoder->static_len));

        return max_blindex;
      }
      /* ==========================================================================
       * Send the header for a block using dynamic Huffman trees: the counts, the
       * lengths of the bit length codes, the literal tree and the distance tree.
       * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
       */


      function send_all_trees(lcodes, dcodes, blcodes) {
        // number of codes for each tree
        var rank; // index in bl_order
        // Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
        // Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES, "too many codes");
        // Tracev((stderr, "\nbl counts: "));

        send_bits(lcodes - 257, 5); // not +255 as stated in appnote.txt

        send_bits(dcodes - 1, 5);
        send_bits(blcodes - 4, 4); // not -3 as stated in appnote.txt

        for (rank = 0; rank < blcodes; rank++) {
          // Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
          send_bits(bl_tree[bl_order[rank]].dl, 3);
        } // send the literal tree


        send_tree(dyn_ltree, lcodes - 1); // send the distance tree

        send_tree(dyn_dtree, dcodes - 1);
      }
      /* ==========================================================================
       * Determine the best encoding for the current block: dynamic trees, static
       * trees or store, and output the encoded block to the zip file.
       */


      function flush_block(eof) {
        // true if this is the last block for a file
        var opt_lenb, static_lenb, // opt_len and static_len in bytes
        max_blindex, // index of last bit length code of non zero freq
        stored_len, // length of input block
        i;
        stored_len = strstart - block_start;
        flag_buf[last_flags] = flags; // Save the flags for the last 8 items
        // Construct the literal and distance trees

        build_tree(l_desc); // Tracev((stderr, "\nlit data: dyn %ld, stat %ld",
        // encoder->opt_len, encoder->static_len));

        build_tree(d_desc); // Tracev((stderr, "\ndist data: dyn %ld, stat %ld",
        // encoder->opt_len, encoder->static_len));
        // At this point, opt_len and static_len are the total bit lengths of
        // the compressed block data, excluding the tree representations.
        // Build the bit length tree for the above two trees, and get the index
        // in bl_order of the last bit length code to send.

        max_blindex = build_bl_tree(); // Determine the best encoding. Compute first the block length in bytes

        opt_lenb = opt_len + 3 + 7 >> 3;
        static_lenb = static_len + 3 + 7 >> 3; //  Trace((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u dist %u ", opt_lenb, encoder->opt_len, static_lenb, encoder->static_len, stored_len, encoder->last_lit, encoder->last_dist));

        if (static_lenb <= opt_lenb) {
          opt_lenb = static_lenb;
        }

        if (stored_len + 4 <= opt_lenb && block_start >= 0) {
          // 4: two words for the lengths
          // The test buf !== NULL is only necessary if LIT_BUFSIZE > WSIZE.
          // Otherwise we can't have processed more than WSIZE input bytes since
          // the last block flush, because compression would have been
          // successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
          // transform a block into a stored block.
          send_bits((STORED_BLOCK << 1) + eof, 3);
          /* send block type */

          bi_windup();
          /* align on byte boundary */

          put_short(stored_len);
          put_short(~stored_len); // copy block

          /*
          	p = &window[block_start];
          	for (i = 0; i < stored_len; i++) {
          		put_byte(p[i]);
          	}
          */

          for (i = 0; i < stored_len; i++) {
            put_byte(window[block_start + i]);
          }
        } else if (static_lenb === opt_lenb) {
          send_bits((STATIC_TREES << 1) + eof, 3);
          compress_block(static_ltree, static_dtree);
        } else {
          send_bits((DYN_TREES << 1) + eof, 3);
          send_all_trees(l_desc.max_code + 1, d_desc.max_code + 1, max_blindex + 1);
          compress_block(dyn_ltree, dyn_dtree);
        }

        init_block();

        if (eof !== 0) {
          bi_windup();
        }
      }
      /* ==========================================================================
       * Save the match info and tally the frequency counts. Return true if
       * the current block must be flushed.
       *
       * @param dist- distance of matched string
       * @param lc- (match length - MIN_MATCH) or unmatched char (if dist === 0)
       */


      function ct_tally(dist, lc) {
        l_buf[last_lit++] = lc;

        if (dist === 0) {
          // lc is the unmatched char
          dyn_ltree[lc].fc++;
        } else {
          // Here, lc is the match length - MIN_MATCH
          dist--; // dist = match distance - 1
          // Assert((ush)dist < (ush)MAX_DIST && (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) && (ush)D_CODE(dist) < (ush)D_CODES,  "ct_tally: bad match");

          dyn_ltree[length_code[lc] + LITERALS + 1].fc++;
          dyn_dtree[D_CODE(dist)].fc++;
          d_buf[last_dist++] = dist;
          flags |= flag_bit;
        }

        flag_bit <<= 1; // Output the flags if they fill a byte

        if ((last_lit & 7) === 0) {
          flag_buf[last_flags++] = flags;
          flags = 0;
          flag_bit = 1;
        } // Try to guess if it is profitable to stop the current block here


        if (compr_level > 2 && (last_lit & 0xfff) === 0) {
          // Compute an upper bound for the compressed length
          var out_length = last_lit * 8;
          var in_length = strstart - block_start;
          var dcode;

          for (dcode = 0; dcode < D_CODES; dcode++) {
            out_length += dyn_dtree[dcode].fc * (5 + extra_dbits[dcode]);
          }

          out_length >>= 3; // Trace((stderr,"\nlast_lit %u, last_dist %u, in %ld, out ~%ld(%ld%%) ", encoder->last_lit, encoder->last_dist, in_length, out_length, 100L - out_length*100L/in_length));

          if (last_dist < parseInt(last_lit / 2, 10) && out_length < parseInt(in_length / 2, 10)) {
            return true;
          }
        }

        return last_lit === LIT_BUFSIZE - 1 || last_dist === DIST_BUFSIZE; // We avoid equality with LIT_BUFSIZE because of wraparound at 64K
        // on 16 bit machines and because stored blocks are restricted to
        // 64K-1 bytes.
      }
      /* ==========================================================================
       * Send the block data compressed using the given Huffman trees
       *
       * @param ltree- literal tree
       * @param dtree- distance tree
       */


      function compress_block(ltree, dtree) {
        var dist; // distance of matched string

        var lc; // match length or unmatched char (if dist === 0)

        var lx = 0; // running index in l_buf

        var dx = 0; // running index in d_buf

        var fx = 0; // running index in flag_buf

        var flag = 0; // current flags

        var code; // the code to send

        var extra; // number of extra bits to send

        if (last_lit !== 0) {
          do {
            if ((lx & 7) === 0) {
              flag = flag_buf[fx++];
            }

            lc = l_buf[lx++] & 0xff;

            if ((flag & 1) === 0) {
              SEND_CODE(lc, ltree);
              /* send a literal byte */
              //	Tracecv(isgraph(lc), (stderr," '%c' ", lc));
            } else {
              // Here, lc is the match length - MIN_MATCH
              code = length_code[lc];
              SEND_CODE(code + LITERALS + 1, ltree); // send the length code

              extra = extra_lbits[code];

              if (extra !== 0) {
                lc -= base_length[code];
                send_bits(lc, extra); // send the extra length bits
              }

              dist = d_buf[dx++]; // Here, dist is the match distance - 1

              code = D_CODE(dist); //	Assert (code < D_CODES, "bad d_code");

              SEND_CODE(code, dtree); // send the distance code

              extra = extra_dbits[code];

              if (extra !== 0) {
                dist -= base_dist[code];
                send_bits(dist, extra); // send the extra distance bits
              }
            } // literal or match pair ?


            flag >>= 1;
          } while (lx < last_lit);
        }

        SEND_CODE(END_BLOCK, ltree);
      }
      /* ==========================================================================
       * Send a value on a given number of bits.
       * IN assertion: length <= 16 and value fits in length bits.
       *
       * @param value- value to send
       * @param length- number of bits
       */


      var Buf_size = 16; // bit size of bi_buf

      function send_bits(value, length) {
        // If not enough room in bi_buf, use (valid) bits from bi_buf and
        // (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))
        // unused bits in value.
        if (bi_valid > Buf_size - length) {
          bi_buf |= value << bi_valid;
          put_short(bi_buf);
          bi_buf = value >> Buf_size - bi_valid;
          bi_valid += length - Buf_size;
        } else {
          bi_buf |= value << bi_valid;
          bi_valid += length;
        }
      }
      /* ==========================================================================
       * Reverse the first len bits of a code, using straightforward code (a faster
       * method would use a table)
       * IN assertion: 1 <= len <= 15
       *
       * @param code- the value to invert
       * @param len- its bit length
       */


      function bi_reverse(code, len) {
        var res = 0;

        do {
          res |= code & 1;
          code >>= 1;
          res <<= 1;
        } while (--len > 0);

        return res >> 1;
      }
      /* ==========================================================================
       * Write out any remaining bits in an incomplete byte.
       */


      function bi_windup() {
        if (bi_valid > 8) {
          put_short(bi_buf);
        } else if (bi_valid > 0) {
          put_byte(bi_buf);
        }

        bi_buf = 0;
        bi_valid = 0;
      }

      function qoutbuf() {
        var q, i;

        if (outcnt !== 0) {
          q = new_queue();

          if (qhead === null) {
            qhead = qtail = q;
          } else {
            qtail = qtail.next = q;
          }

          q.len = outcnt - outoff; // System.arraycopy(outbuf, outoff, q.ptr, 0, q.len);

          for (i = 0; i < q.len; i++) {
            q.ptr[i] = outbuf[outoff + i];
          }

          outcnt = outoff = 0;
        }
      }

      function deflate(arr, level) {
        var i, buff;
        deflate_data = arr;
        deflate_pos = 0;

        if (typeof level === "undefined") {
          level = DEFAULT_LEVEL;
        }

        deflate_start(level);
        buff = [];

        do {
          i = deflate_internal(buff, buff.length, 1024);
        } while (i > 0);

        deflate_data = null; // G.C.

        return buff;
      }

      module.exports = deflate;
      module.exports.DEFAULT_LEVEL = DEFAULT_LEVEL;
    })();
  });
  var rawdeflate_1 = rawdeflate.DEFAULT_LEVEL;

  var codemirror = createCommonjsModule(function (module, exports) {
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE
    // This is CodeMirror (https://codemirror.net), a code editor
    // implemented in JavaScript on top of the browser's DOM.
    //
    // You can find some technical background for some of the code below
    // at http://marijnhaverbeke.nl/blog/#cm-internals .
    (function (global, factory) {
       module.exports = factory() ;
    })(commonjsGlobal, function () {
      // detected are enabled based on userAgent etc sniffing.

      var userAgent = navigator.userAgent;
      var platform = navigator.platform;
      var gecko = /gecko\/\d/i.test(userAgent);
      var ie_upto10 = /MSIE \d/.test(userAgent);
      var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent);
      var edge = /Edge\/(\d+)/.exec(userAgent);
      var ie = ie_upto10 || ie_11up || edge;
      var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);
      var webkit = !edge && /WebKit\//.test(userAgent);
      var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent);
      var chrome = !edge && /Chrome\//.test(userAgent);
      var presto = /Opera\//.test(userAgent);
      var safari = /Apple Computer/.test(navigator.vendor);
      var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent);
      var phantom = /PhantomJS/.test(userAgent);
      var ios = !edge && /AppleWebKit/.test(userAgent) && /Mobile\/\w+/.test(userAgent);
      var android = /Android/.test(userAgent); // This is woefully incomplete. Suggestions for alternative methods welcome.

      var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);
      var mac = ios || /Mac/.test(platform);
      var chromeOS = /\bCrOS\b/.test(userAgent);
      var windows = /win/i.test(platform);
      var presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);

      if (presto_version) {
        presto_version = Number(presto_version[1]);
      }

      if (presto_version && presto_version >= 15) {
        presto = false;
        webkit = true;
      } // Some browsers use the wrong event properties to signal cmd/ctrl on OS X


      var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
      var captureRightClick = gecko || ie && ie_version >= 9;

      function classTest(cls) {
        return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*");
      }

      var rmClass = function rmClass(node, cls) {
        var current = node.className;
        var match = classTest(cls).exec(current);

        if (match) {
          var after = current.slice(match.index + match[0].length);
          node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
        }
      };

      function removeChildren(e) {
        for (var count = e.childNodes.length; count > 0; --count) {
          e.removeChild(e.firstChild);
        }

        return e;
      }

      function removeChildrenAndAdd(parent, e) {
        return removeChildren(parent).appendChild(e);
      }

      function elt(tag, content, className, style) {
        var e = document.createElement(tag);

        if (className) {
          e.className = className;
        }

        if (style) {
          e.style.cssText = style;
        }

        if (typeof content == "string") {
          e.appendChild(document.createTextNode(content));
        } else if (content) {
          for (var i = 0; i < content.length; ++i) {
            e.appendChild(content[i]);
          }
        }

        return e;
      } // wrapper for elt, which removes the elt from the accessibility tree


      function eltP(tag, content, className, style) {
        var e = elt(tag, content, className, style);
        e.setAttribute("role", "presentation");
        return e;
      }

      var range;

      if (document.createRange) {
        range = function range(node, start, end, endNode) {
          var r = document.createRange();
          r.setEnd(endNode || node, end);
          r.setStart(node, start);
          return r;
        };
      } else {
        range = function range(node, start, end) {
          var r = document.body.createTextRange();

          try {
            r.moveToElementText(node.parentNode);
          } catch (e) {
            return r;
          }

          r.collapse(true);
          r.moveEnd("character", end);
          r.moveStart("character", start);
          return r;
        };
      }

      function contains(parent, child) {
        if (child.nodeType == 3) // Android browser always returns false when child is a textnode
          {
            child = child.parentNode;
          }

        if (parent.contains) {
          return parent.contains(child);
        }

        do {
          if (child.nodeType == 11) {
            child = child.host;
          }

          if (child == parent) {
            return true;
          }
        } while (child = child.parentNode);
      }

      function activeElt() {
        // IE and Edge may throw an "Unspecified Error" when accessing document.activeElement.
        // IE < 10 will throw when accessed while the page is loading or in an iframe.
        // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.
        var activeElement;

        try {
          activeElement = document.activeElement;
        } catch (e) {
          activeElement = document.body || null;
        }

        while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement) {
          activeElement = activeElement.shadowRoot.activeElement;
        }

        return activeElement;
      }

      function addClass(node, cls) {
        var current = node.className;

        if (!classTest(cls).test(current)) {
          node.className += (current ? " " : "") + cls;
        }
      }

      function joinClasses(a, b) {
        var as = a.split(" ");

        for (var i = 0; i < as.length; i++) {
          if (as[i] && !classTest(as[i]).test(b)) {
            b += " " + as[i];
          }
        }

        return b;
      }

      var selectInput = function selectInput(node) {
        node.select();
      };

      if (ios) // Mobile Safari apparently has a bug where select() is broken.
        {
          selectInput = function selectInput(node) {
            node.selectionStart = 0;
            node.selectionEnd = node.value.length;
          };
        } else if (ie) // Suppress mysterious IE10 errors
        {
          selectInput = function selectInput(node) {
            try {
              node.select();
            } catch (_e) {}
          };
        }

      function bind(f) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function () {
          return f.apply(null, args);
        };
      }

      function copyObj(obj, target, overwrite) {
        if (!target) {
          target = {};
        }

        for (var prop in obj) {
          if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop))) {
            target[prop] = obj[prop];
          }
        }

        return target;
      } // Counts the column offset in a string, taking tabs into account.
      // Used mostly to find indentation.


      function countColumn(string, end, tabSize, startIndex, startValue) {
        if (end == null) {
          end = string.search(/[^\s\u00a0]/);

          if (end == -1) {
            end = string.length;
          }
        }

        for (var i = startIndex || 0, n = startValue || 0;;) {
          var nextTab = string.indexOf("\t", i);

          if (nextTab < 0 || nextTab >= end) {
            return n + (end - i);
          }

          n += nextTab - i;
          n += tabSize - n % tabSize;
          i = nextTab + 1;
        }
      }

      var Delayed = function Delayed() {
        this.id = null;
        this.f = null;
        this.time = 0;
        this.handler = bind(this.onTimeout, this);
      };

      Delayed.prototype.onTimeout = function (self) {
        self.id = 0;

        if (self.time <= +new Date()) {
          self.f();
        } else {
          setTimeout(self.handler, self.time - +new Date());
        }
      };

      Delayed.prototype.set = function (ms, f) {
        this.f = f;
        var time = +new Date() + ms;

        if (!this.id || time < this.time) {
          clearTimeout(this.id);
          this.id = setTimeout(this.handler, ms);
          this.time = time;
        }
      };

      function indexOf(array, elt) {
        for (var i = 0; i < array.length; ++i) {
          if (array[i] == elt) {
            return i;
          }
        }

        return -1;
      } // Number of pixels added to scroller and sizer to hide scrollbar


      var scrollerGap = 30; // Returned or thrown by various protocols to signal 'I'm not
      // handling this'.

      var Pass = {
        toString: function toString() {
          return "CodeMirror.Pass";
        }
      }; // Reused option objects for setSelection & friends

      var sel_dontScroll = {
        scroll: false
      },
          sel_mouse = {
        origin: "*mouse"
      },
          sel_move = {
        origin: "+move"
      }; // The inverse of countColumn -- find the offset that corresponds to
      // a particular column.

      function findColumn(string, goal, tabSize) {
        for (var pos = 0, col = 0;;) {
          var nextTab = string.indexOf("\t", pos);

          if (nextTab == -1) {
            nextTab = string.length;
          }

          var skipped = nextTab - pos;

          if (nextTab == string.length || col + skipped >= goal) {
            return pos + Math.min(skipped, goal - col);
          }

          col += nextTab - pos;
          col += tabSize - col % tabSize;
          pos = nextTab + 1;

          if (col >= goal) {
            return pos;
          }
        }
      }

      var spaceStrs = [""];

      function spaceStr(n) {
        while (spaceStrs.length <= n) {
          spaceStrs.push(lst(spaceStrs) + " ");
        }

        return spaceStrs[n];
      }

      function lst(arr) {
        return arr[arr.length - 1];
      }

      function map(array, f) {
        var out = [];

        for (var i = 0; i < array.length; i++) {
          out[i] = f(array[i], i);
        }

        return out;
      }

      function insertSorted(array, value, score) {
        var pos = 0,
            priority = score(value);

        while (pos < array.length && score(array[pos]) <= priority) {
          pos++;
        }

        array.splice(pos, 0, value);
      }

      function nothing() {}

      function createObj(base, props) {
        var inst;

        if (Object.create) {
          inst = Object.create(base);
        } else {
          nothing.prototype = base;
          inst = new nothing();
        }

        if (props) {
          copyObj(props, inst);
        }

        return inst;
      }

      var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;

      function isWordCharBasic(ch) {
        return /\w/.test(ch) || ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
      }

      function isWordChar(ch, helper) {
        if (!helper) {
          return isWordCharBasic(ch);
        }

        if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) {
          return true;
        }

        return helper.test(ch);
      }

      function isEmpty(obj) {
        for (var n in obj) {
          if (obj.hasOwnProperty(n) && obj[n]) {
            return false;
          }
        }

        return true;
      } // Extending unicode characters. A series of a non-extending char +
      // any number of extending chars is treated as a single unit as far
      // as editing and measuring is concerned. This is not fully correct,
      // since some scripts/fonts/browsers also treat other configurations
      // of code points as a group.


      var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;

      function isExtendingChar(ch) {
        return ch.charCodeAt(0) >= 768 && extendingChars.test(ch);
      } // Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.


      function skipExtendingChars(str, pos, dir) {
        while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) {
          pos += dir;
        }

        return pos;
      } // Returns the value from the range [`from`; `to`] that satisfies
      // `pred` and is closest to `from`. Assumes that at least `to`
      // satisfies `pred`. Supports `from` being greater than `to`.


      function findFirst(pred, from, to) {
        // At any point we are certain `to` satisfies `pred`, don't know
        // whether `from` does.
        var dir = from > to ? -1 : 1;

        for (;;) {
          if (from == to) {
            return from;
          }

          var midF = (from + to) / 2,
              mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);

          if (mid == from) {
            return pred(mid) ? from : to;
          }

          if (pred(mid)) {
            to = mid;
          } else {
            from = mid + dir;
          }
        }
      } // BIDI HELPERS


      function iterateBidiSections(order, from, to, f) {
        if (!order) {
          return f(from, to, "ltr", 0);
        }

        var found = false;

        for (var i = 0; i < order.length; ++i) {
          var part = order[i];

          if (part.from < to && part.to > from || from == to && part.to == from) {
            f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr", i);
            found = true;
          }
        }

        if (!found) {
          f(from, to, "ltr");
        }
      }

      var bidiOther = null;

      function getBidiPartAt(order, ch, sticky) {
        var found;
        bidiOther = null;

        for (var i = 0; i < order.length; ++i) {
          var cur = order[i];

          if (cur.from < ch && cur.to > ch) {
            return i;
          }

          if (cur.to == ch) {
            if (cur.from != cur.to && sticky == "before") {
              found = i;
            } else {
              bidiOther = i;
            }
          }

          if (cur.from == ch) {
            if (cur.from != cur.to && sticky != "before") {
              found = i;
            } else {
              bidiOther = i;
            }
          }
        }

        return found != null ? found : bidiOther;
      } // Bidirectional ordering algorithm
      // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
      // that this (partially) implements.
      // One-char codes used for character types:
      // L (L):   Left-to-Right
      // R (R):   Right-to-Left
      // r (AL):  Right-to-Left Arabic
      // 1 (EN):  European Number
      // + (ES):  European Number Separator
      // % (ET):  European Number Terminator
      // n (AN):  Arabic Number
      // , (CS):  Common Number Separator
      // m (NSM): Non-Spacing Mark
      // b (BN):  Boundary Neutral
      // s (B):   Paragraph Separator
      // t (S):   Segment Separator
      // w (WS):  Whitespace
      // N (ON):  Other Neutrals
      // Returns null if characters are ordered as they appear
      // (left-to-right), or an array of sections ({from, to, level}
      // objects) in the order in which they occur visually.


      var bidiOrdering = function () {
        // Character types for codepoints 0 to 0xff
        var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN"; // Character types for codepoints 0x600 to 0x6f9

        var arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";

        function charType(code) {
          if (code <= 0xf7) {
            return lowTypes.charAt(code);
          } else if (0x590 <= code && code <= 0x5f4) {
            return "R";
          } else if (0x600 <= code && code <= 0x6f9) {
            return arabicTypes.charAt(code - 0x600);
          } else if (0x6ee <= code && code <= 0x8ac) {
            return "r";
          } else if (0x2000 <= code && code <= 0x200b) {
            return "w";
          } else if (code == 0x200c) {
            return "b";
          } else {
            return "L";
          }
        }

        var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
        var isNeutral = /[stwN]/,
            isStrong = /[LRr]/,
            countsAsLeft = /[Lb1n]/,
            countsAsNum = /[1n]/;

        function BidiSpan(level, from, to) {
          this.level = level;
          this.from = from;
          this.to = to;
        }

        return function (str, direction) {
          var outerType = direction == "ltr" ? "L" : "R";

          if (str.length == 0 || direction == "ltr" && !bidiRE.test(str)) {
            return false;
          }

          var len = str.length,
              types = [];

          for (var i = 0; i < len; ++i) {
            types.push(charType(str.charCodeAt(i)));
          } // W1. Examine each non-spacing mark (NSM) in the level run, and
          // change the type of the NSM to the type of the previous
          // character. If the NSM is at the start of the level run, it will
          // get the type of sor.


          for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {
            var type = types[i$1];

            if (type == "m") {
              types[i$1] = prev;
            } else {
              prev = type;
            }
          } // W2. Search backwards from each instance of a European number
          // until the first strong type (R, L, AL, or sor) is found. If an
          // AL is found, change the type of the European number to Arabic
          // number.
          // W3. Change all ALs to R.


          for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {
            var type$1 = types[i$2];

            if (type$1 == "1" && cur == "r") {
              types[i$2] = "n";
            } else if (isStrong.test(type$1)) {
              cur = type$1;

              if (type$1 == "r") {
                types[i$2] = "R";
              }
            }
          } // W4. A single European separator between two European numbers
          // changes to a European number. A single common separator between
          // two numbers of the same type changes to that type.


          for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {
            var type$2 = types[i$3];

            if (type$2 == "+" && prev$1 == "1" && types[i$3 + 1] == "1") {
              types[i$3] = "1";
            } else if (type$2 == "," && prev$1 == types[i$3 + 1] && (prev$1 == "1" || prev$1 == "n")) {
              types[i$3] = prev$1;
            }

            prev$1 = type$2;
          } // W5. A sequence of European terminators adjacent to European
          // numbers changes to all European numbers.
          // W6. Otherwise, separators and terminators change to Other
          // Neutral.


          for (var i$4 = 0; i$4 < len; ++i$4) {
            var type$3 = types[i$4];

            if (type$3 == ",") {
              types[i$4] = "N";
            } else if (type$3 == "%") {
              var end = void 0;

              for (end = i$4 + 1; end < len && types[end] == "%"; ++end) {}

              var replace = i$4 && types[i$4 - 1] == "!" || end < len && types[end] == "1" ? "1" : "N";

              for (var j = i$4; j < end; ++j) {
                types[j] = replace;
              }

              i$4 = end - 1;
            }
          } // W7. Search backwards from each instance of a European number
          // until the first strong type (R, L, or sor) is found. If an L is
          // found, then change the type of the European number to L.


          for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {
            var type$4 = types[i$5];

            if (cur$1 == "L" && type$4 == "1") {
              types[i$5] = "L";
            } else if (isStrong.test(type$4)) {
              cur$1 = type$4;
            }
          } // N1. A sequence of neutrals takes the direction of the
          // surrounding strong text if the text on both sides has the same
          // direction. European and Arabic numbers act as if they were R in
          // terms of their influence on neutrals. Start-of-level-run (sor)
          // and end-of-level-run (eor) are used at level run boundaries.
          // N2. Any remaining neutrals take the embedding direction.


          for (var i$6 = 0; i$6 < len; ++i$6) {
            if (isNeutral.test(types[i$6])) {
              var end$1 = void 0;

              for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}

              var before = (i$6 ? types[i$6 - 1] : outerType) == "L";
              var after = (end$1 < len ? types[end$1] : outerType) == "L";
              var replace$1 = before == after ? before ? "L" : "R" : outerType;

              for (var j$1 = i$6; j$1 < end$1; ++j$1) {
                types[j$1] = replace$1;
              }

              i$6 = end$1 - 1;
            }
          } // Here we depart from the documented algorithm, in order to avoid
          // building up an actual levels array. Since there are only three
          // levels (0, 1, 2) in an implementation that doesn't take
          // explicit embedding into account, we can build up the order on
          // the fly, without following the level-based algorithm.


          var order = [],
              m;

          for (var i$7 = 0; i$7 < len;) {
            if (countsAsLeft.test(types[i$7])) {
              var start = i$7;

              for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}

              order.push(new BidiSpan(0, start, i$7));
            } else {
              var pos = i$7,
                  at = order.length,
                  isRTL = direction == "rtl" ? 1 : 0;

              for (++i$7; i$7 < len && types[i$7] != "L"; ++i$7) {}

              for (var j$2 = pos; j$2 < i$7;) {
                if (countsAsNum.test(types[j$2])) {
                  if (pos < j$2) {
                    order.splice(at, 0, new BidiSpan(1, pos, j$2));
                    at += isRTL;
                  }

                  var nstart = j$2;

                  for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}

                  order.splice(at, 0, new BidiSpan(2, nstart, j$2));
                  at += isRTL;
                  pos = j$2;
                } else {
                  ++j$2;
                }
              }

              if (pos < i$7) {
                order.splice(at, 0, new BidiSpan(1, pos, i$7));
              }
            }
          }

          if (direction == "ltr") {
            if (order[0].level == 1 && (m = str.match(/^\s+/))) {
              order[0].from = m[0].length;
              order.unshift(new BidiSpan(0, 0, m[0].length));
            }

            if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
              lst(order).to -= m[0].length;
              order.push(new BidiSpan(0, len - m[0].length, len));
            }
          }

          return direction == "rtl" ? order.reverse() : order;
        };
      }(); // Get the bidi ordering for the given line (and cache it). Returns
      // false for lines that are fully left-to-right, and an array of
      // BidiSpan objects otherwise.


      function getOrder(line, direction) {
        var order = line.order;

        if (order == null) {
          order = line.order = bidiOrdering(line.text, direction);
        }

        return order;
      } // EVENT HANDLING
      // Lightweight event framework. on/off also work on DOM nodes,
      // registering native DOM handlers.


      var noHandlers = [];

      var on = function on(emitter, type, f) {
        if (emitter.addEventListener) {
          emitter.addEventListener(type, f, false);
        } else if (emitter.attachEvent) {
          emitter.attachEvent("on" + type, f);
        } else {
          var map = emitter._handlers || (emitter._handlers = {});
          map[type] = (map[type] || noHandlers).concat(f);
        }
      };

      function getHandlers(emitter, type) {
        return emitter._handlers && emitter._handlers[type] || noHandlers;
      }

      function off(emitter, type, f) {
        if (emitter.removeEventListener) {
          emitter.removeEventListener(type, f, false);
        } else if (emitter.detachEvent) {
          emitter.detachEvent("on" + type, f);
        } else {
          var map = emitter._handlers,
              arr = map && map[type];

          if (arr) {
            var index = indexOf(arr, f);

            if (index > -1) {
              map[type] = arr.slice(0, index).concat(arr.slice(index + 1));
            }
          }
        }
      }

      function signal(emitter, type
      /*, values...*/
      ) {
        var handlers = getHandlers(emitter, type);

        if (!handlers.length) {
          return;
        }

        var args = Array.prototype.slice.call(arguments, 2);

        for (var i = 0; i < handlers.length; ++i) {
          handlers[i].apply(null, args);
        }
      } // The DOM events that CodeMirror handles can be overridden by
      // registering a (non-DOM) handler on the editor for the event name,
      // and preventDefault-ing the event in that handler.


      function signalDOMEvent(cm, e, override) {
        if (typeof e == "string") {
          e = {
            type: e,
            preventDefault: function preventDefault() {
              this.defaultPrevented = true;
            }
          };
        }

        signal(cm, override || e.type, cm, e);
        return e_defaultPrevented(e) || e.codemirrorIgnore;
      }

      function signalCursorActivity(cm) {
        var arr = cm._handlers && cm._handlers.cursorActivity;

        if (!arr) {
          return;
        }

        var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);

        for (var i = 0; i < arr.length; ++i) {
          if (indexOf(set, arr[i]) == -1) {
            set.push(arr[i]);
          }
        }
      }

      function hasHandler(emitter, type) {
        return getHandlers(emitter, type).length > 0;
      } // Add on and off methods to a constructor's prototype, to make
      // registering events on such objects more convenient.


      function eventMixin(ctor) {
        ctor.prototype.on = function (type, f) {
          on(this, type, f);
        };

        ctor.prototype.off = function (type, f) {
          off(this, type, f);
        };
      } // Due to the fact that we still support jurassic IE versions, some
      // compatibility wrappers are needed.


      function e_preventDefault(e) {
        if (e.preventDefault) {
          e.preventDefault();
        } else {
          e.returnValue = false;
        }
      }

      function e_stopPropagation(e) {
        if (e.stopPropagation) {
          e.stopPropagation();
        } else {
          e.cancelBubble = true;
        }
      }

      function e_defaultPrevented(e) {
        return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;
      }

      function e_stop(e) {
        e_preventDefault(e);
        e_stopPropagation(e);
      }

      function e_target(e) {
        return e.target || e.srcElement;
      }

      function e_button(e) {
        var b = e.which;

        if (b == null) {
          if (e.button & 1) {
            b = 1;
          } else if (e.button & 2) {
            b = 3;
          } else if (e.button & 4) {
            b = 2;
          }
        }

        if (mac && e.ctrlKey && b == 1) {
          b = 3;
        }

        return b;
      } // Detect drag-and-drop


      var dragAndDrop = function () {
        // There is *some* kind of drag-and-drop support in IE6-8, but I
        // couldn't get it to work yet.
        if (ie && ie_version < 9) {
          return false;
        }

        var div = elt('div');
        return "draggable" in div || "dragDrop" in div;
      }();

      var zwspSupported;

      function zeroWidthElement(measure) {
        if (zwspSupported == null) {
          var test = elt("span", "\u200B");
          removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));

          if (measure.firstChild.offsetHeight != 0) {
            zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);
          }
        }

        var node = zwspSupported ? elt("span", "\u200B") : elt("span", "\xA0", null, "display: inline-block; width: 1px; margin-right: -1px");
        node.setAttribute("cm-text", "");
        return node;
      } // Feature-detect IE's crummy client rect reporting for bidi text


      var badBidiRects;

      function hasBadBidiRects(measure) {
        if (badBidiRects != null) {
          return badBidiRects;
        }

        var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062EA"));
        var r0 = range(txt, 0, 1).getBoundingClientRect();
        var r1 = range(txt, 1, 2).getBoundingClientRect();
        removeChildren(measure);

        if (!r0 || r0.left == r0.right) {
          return false;
        } // Safari returns null in some cases (#2780)


        return badBidiRects = r1.right - r0.right < 3;
      } // See if "".split is the broken IE version, if so, provide an
      // alternative way to split lines.


      var splitLinesAuto = "\n\nb".split(/\n/).length != 3 ? function (string) {
        var pos = 0,
            result = [],
            l = string.length;

        while (pos <= l) {
          var nl = string.indexOf("\n", pos);

          if (nl == -1) {
            nl = string.length;
          }

          var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
          var rt = line.indexOf("\r");

          if (rt != -1) {
            result.push(line.slice(0, rt));
            pos += rt + 1;
          } else {
            result.push(line);
            pos = nl + 1;
          }
        }

        return result;
      } : function (string) {
        return string.split(/\r\n?|\n/);
      };
      var hasSelection = window.getSelection ? function (te) {
        try {
          return te.selectionStart != te.selectionEnd;
        } catch (e) {
          return false;
        }
      } : function (te) {
        var range;

        try {
          range = te.ownerDocument.selection.createRange();
        } catch (e) {}

        if (!range || range.parentElement() != te) {
          return false;
        }

        return range.compareEndPoints("StartToEnd", range) != 0;
      };

      var hasCopyEvent = function () {
        var e = elt("div");

        if ("oncopy" in e) {
          return true;
        }

        e.setAttribute("oncopy", "return;");
        return typeof e.oncopy == "function";
      }();

      var badZoomedRects = null;

      function hasBadZoomedRects(measure) {
        if (badZoomedRects != null) {
          return badZoomedRects;
        }

        var node = removeChildrenAndAdd(measure, elt("span", "x"));
        var normal = node.getBoundingClientRect();
        var fromRange = range(node, 0, 1).getBoundingClientRect();
        return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;
      } // Known modes, by name and by MIME


      var modes = {},
          mimeModes = {}; // Extra arguments are stored as the mode's dependencies, which is
      // used by (legacy) mechanisms like loadmode.js to automatically
      // load a mode. (Preferred mechanism is the require/define calls.)

      function defineMode(name, mode) {
        if (arguments.length > 2) {
          mode.dependencies = Array.prototype.slice.call(arguments, 2);
        }

        modes[name] = mode;
      }

      function defineMIME(mime, spec) {
        mimeModes[mime] = spec;
      } // Given a MIME type, a {name, ...options} config object, or a name
      // string, return a mode config object.


      function resolveMode(spec) {
        if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
          spec = mimeModes[spec];
        } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
          var found = mimeModes[spec.name];

          if (typeof found == "string") {
            found = {
              name: found
            };
          }

          spec = createObj(found, spec);
          spec.name = found.name;
        } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
          return resolveMode("application/xml");
        } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) {
          return resolveMode("application/json");
        }

        if (typeof spec == "string") {
          return {
            name: spec
          };
        } else {
          return spec || {
            name: "null"
          };
        }
      } // Given a mode spec (anything that resolveMode accepts), find and
      // initialize an actual mode object.


      function getMode(options, spec) {
        spec = resolveMode(spec);
        var mfactory = modes[spec.name];

        if (!mfactory) {
          return getMode(options, "text/plain");
        }

        var modeObj = mfactory(options, spec);

        if (modeExtensions.hasOwnProperty(spec.name)) {
          var exts = modeExtensions[spec.name];

          for (var prop in exts) {
            if (!exts.hasOwnProperty(prop)) {
              continue;
            }

            if (modeObj.hasOwnProperty(prop)) {
              modeObj["_" + prop] = modeObj[prop];
            }

            modeObj[prop] = exts[prop];
          }
        }

        modeObj.name = spec.name;

        if (spec.helperType) {
          modeObj.helperType = spec.helperType;
        }

        if (spec.modeProps) {
          for (var prop$1 in spec.modeProps) {
            modeObj[prop$1] = spec.modeProps[prop$1];
          }
        }

        return modeObj;
      } // This can be used to attach properties to mode objects from
      // outside the actual mode definition.


      var modeExtensions = {};

      function extendMode(mode, properties) {
        var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : modeExtensions[mode] = {};
        copyObj(properties, exts);
      }

      function copyState(mode, state) {
        if (state === true) {
          return state;
        }

        if (mode.copyState) {
          return mode.copyState(state);
        }

        var nstate = {};

        for (var n in state) {
          var val = state[n];

          if (val instanceof Array) {
            val = val.concat([]);
          }

          nstate[n] = val;
        }

        return nstate;
      } // Given a mode and a state (for that mode), find the inner mode and
      // state at the position that the state refers to.


      function innerMode(mode, state) {
        var info;

        while (mode.innerMode) {
          info = mode.innerMode(state);

          if (!info || info.mode == mode) {
            break;
          }

          state = info.state;
          mode = info.mode;
        }

        return info || {
          mode: mode,
          state: state
        };
      }

      function startState(mode, a1, a2) {
        return mode.startState ? mode.startState(a1, a2) : true;
      } // STRING STREAM
      // Fed to the mode parsers, provides helper functions to make
      // parsers more succinct.


      var StringStream = function StringStream(string, tabSize, lineOracle) {
        this.pos = this.start = 0;
        this.string = string;
        this.tabSize = tabSize || 8;
        this.lastColumnPos = this.lastColumnValue = 0;
        this.lineStart = 0;
        this.lineOracle = lineOracle;
      };

      StringStream.prototype.eol = function () {
        return this.pos >= this.string.length;
      };

      StringStream.prototype.sol = function () {
        return this.pos == this.lineStart;
      };

      StringStream.prototype.peek = function () {
        return this.string.charAt(this.pos) || undefined;
      };

      StringStream.prototype.next = function () {
        if (this.pos < this.string.length) {
          return this.string.charAt(this.pos++);
        }
      };

      StringStream.prototype.eat = function (match) {
        var ch = this.string.charAt(this.pos);
        var ok;

        if (typeof match == "string") {
          ok = ch == match;
        } else {
          ok = ch && (match.test ? match.test(ch) : match(ch));
        }

        if (ok) {
          ++this.pos;
          return ch;
        }
      };

      StringStream.prototype.eatWhile = function (match) {
        var start = this.pos;

        while (this.eat(match)) {}

        return this.pos > start;
      };

      StringStream.prototype.eatSpace = function () {
        var start = this.pos;

        while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) {
          ++this.pos;
        }

        return this.pos > start;
      };

      StringStream.prototype.skipToEnd = function () {
        this.pos = this.string.length;
      };

      StringStream.prototype.skipTo = function (ch) {
        var found = this.string.indexOf(ch, this.pos);

        if (found > -1) {
          this.pos = found;
          return true;
        }
      };

      StringStream.prototype.backUp = function (n) {
        this.pos -= n;
      };

      StringStream.prototype.column = function () {
        if (this.lastColumnPos < this.start) {
          this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
          this.lastColumnPos = this.start;
        }

        return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
      };

      StringStream.prototype.indentation = function () {
        return countColumn(this.string, null, this.tabSize) - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
      };

      StringStream.prototype.match = function (pattern, consume, caseInsensitive) {
        if (typeof pattern == "string") {
          var cased = function cased(str) {
            return caseInsensitive ? str.toLowerCase() : str;
          };

          var substr = this.string.substr(this.pos, pattern.length);

          if (cased(substr) == cased(pattern)) {
            if (consume !== false) {
              this.pos += pattern.length;
            }

            return true;
          }
        } else {
          var match = this.string.slice(this.pos).match(pattern);

          if (match && match.index > 0) {
            return null;
          }

          if (match && consume !== false) {
            this.pos += match[0].length;
          }

          return match;
        }
      };

      StringStream.prototype.current = function () {
        return this.string.slice(this.start, this.pos);
      };

      StringStream.prototype.hideFirstChars = function (n, inner) {
        this.lineStart += n;

        try {
          return inner();
        } finally {
          this.lineStart -= n;
        }
      };

      StringStream.prototype.lookAhead = function (n) {
        var oracle = this.lineOracle;
        return oracle && oracle.lookAhead(n);
      };

      StringStream.prototype.baseToken = function () {
        var oracle = this.lineOracle;
        return oracle && oracle.baseToken(this.pos);
      }; // Find the line object corresponding to the given line number.


      function getLine(doc, n) {
        n -= doc.first;

        if (n < 0 || n >= doc.size) {
          throw new Error("There is no line " + (n + doc.first) + " in the document.");
        }

        var chunk = doc;

        while (!chunk.lines) {
          for (var i = 0;; ++i) {
            var child = chunk.children[i],
                sz = child.chunkSize();

            if (n < sz) {
              chunk = child;
              break;
            }

            n -= sz;
          }
        }

        return chunk.lines[n];
      } // Get the part of a document between two positions, as an array of
      // strings.


      function getBetween(doc, start, end) {
        var out = [],
            n = start.line;
        doc.iter(start.line, end.line + 1, function (line) {
          var text = line.text;

          if (n == end.line) {
            text = text.slice(0, end.ch);
          }

          if (n == start.line) {
            text = text.slice(start.ch);
          }

          out.push(text);
          ++n;
        });
        return out;
      } // Get the lines between from and to, as array of strings.


      function getLines(doc, from, to) {
        var out = [];
        doc.iter(from, to, function (line) {
          out.push(line.text);
        }); // iter aborts when callback returns truthy value

        return out;
      } // Update the height of a line, propagating the height change
      // upwards to parent nodes.


      function updateLineHeight(line, height) {
        var diff = height - line.height;

        if (diff) {
          for (var n = line; n; n = n.parent) {
            n.height += diff;
          }
        }
      } // Given a line object, find its line number by walking up through
      // its parent links.


      function lineNo(line) {
        if (line.parent == null) {
          return null;
        }

        var cur = line.parent,
            no = indexOf(cur.lines, line);

        for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
          for (var i = 0;; ++i) {
            if (chunk.children[i] == cur) {
              break;
            }

            no += chunk.children[i].chunkSize();
          }
        }

        return no + cur.first;
      } // Find the line at the given vertical position, using the height
      // information in the document tree.


      function _lineAtHeight(chunk, h) {
        var n = chunk.first;

        outer: do {
          for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {
            var child = chunk.children[i$1],
                ch = child.height;

            if (h < ch) {
              chunk = child;
              continue outer;
            }

            h -= ch;
            n += child.chunkSize();
          }

          return n;
        } while (!chunk.lines);

        var i = 0;

        for (; i < chunk.lines.length; ++i) {
          var line = chunk.lines[i],
              lh = line.height;

          if (h < lh) {
            break;
          }

          h -= lh;
        }

        return n + i;
      }

      function isLine(doc, l) {
        return l >= doc.first && l < doc.first + doc.size;
      }

      function lineNumberFor(options, i) {
        return String(options.lineNumberFormatter(i + options.firstLineNumber));
      } // A Pos instance represents a position within the text.


      function Pos(line, ch, sticky) {
        if (sticky === void 0) sticky = null;

        if (!(this instanceof Pos)) {
          return new Pos(line, ch, sticky);
        }

        this.line = line;
        this.ch = ch;
        this.sticky = sticky;
      } // Compare two positions, return 0 if they are the same, a negative
      // number when a is less, and a positive number otherwise.


      function cmp(a, b) {
        return a.line - b.line || a.ch - b.ch;
      }

      function equalCursorPos(a, b) {
        return a.sticky == b.sticky && cmp(a, b) == 0;
      }

      function copyPos(x) {
        return Pos(x.line, x.ch);
      }

      function maxPos(a, b) {
        return cmp(a, b) < 0 ? b : a;
      }

      function minPos(a, b) {
        return cmp(a, b) < 0 ? a : b;
      } // Most of the external API clips given positions to make sure they
      // actually exist within the document.


      function clipLine(doc, n) {
        return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));
      }

      function _clipPos(doc, pos) {
        if (pos.line < doc.first) {
          return Pos(doc.first, 0);
        }

        var last = doc.first + doc.size - 1;

        if (pos.line > last) {
          return Pos(last, getLine(doc, last).text.length);
        }

        return clipToLen(pos, getLine(doc, pos.line).text.length);
      }

      function clipToLen(pos, linelen) {
        var ch = pos.ch;

        if (ch == null || ch > linelen) {
          return Pos(pos.line, linelen);
        } else if (ch < 0) {
          return Pos(pos.line, 0);
        } else {
          return pos;
        }
      }

      function clipPosArray(doc, array) {
        var out = [];

        for (var i = 0; i < array.length; i++) {
          out[i] = _clipPos(doc, array[i]);
        }

        return out;
      }

      var SavedContext = function SavedContext(state, lookAhead) {
        this.state = state;
        this.lookAhead = lookAhead;
      };

      var Context = function Context(doc, state, line, lookAhead) {
        this.state = state;
        this.doc = doc;
        this.line = line;
        this.maxLookAhead = lookAhead || 0;
        this.baseTokens = null;
        this.baseTokenPos = 1;
      };

      Context.prototype.lookAhead = function (n) {
        var line = this.doc.getLine(this.line + n);

        if (line != null && n > this.maxLookAhead) {
          this.maxLookAhead = n;
        }

        return line;
      };

      Context.prototype.baseToken = function (n) {
        if (!this.baseTokens) {
          return null;
        }

        while (this.baseTokens[this.baseTokenPos] <= n) {
          this.baseTokenPos += 2;
        }

        var type = this.baseTokens[this.baseTokenPos + 1];
        return {
          type: type && type.replace(/( |^)overlay .*/, ""),
          size: this.baseTokens[this.baseTokenPos] - n
        };
      };

      Context.prototype.nextLine = function () {
        this.line++;

        if (this.maxLookAhead > 0) {
          this.maxLookAhead--;
        }
      };

      Context.fromSaved = function (doc, saved, line) {
        if (saved instanceof SavedContext) {
          return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead);
        } else {
          return new Context(doc, copyState(doc.mode, saved), line);
        }
      };

      Context.prototype.save = function (copy) {
        var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;
        return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state;
      }; // Compute a style array (an array starting with a mode generation
      // -- for invalidation -- followed by pairs of end positions and
      // style strings), which is used to highlight the tokens on the
      // line.


      function highlightLine(cm, line, context, forceToEnd) {
        // A styles array always starts with a number identifying the
        // mode/overlays that it is based on (for easy invalidation).
        var st = [cm.state.modeGen],
            lineClasses = {}; // Compute the base array of styles

        runMode(cm, line.text, cm.doc.mode, context, function (end, style) {
          return st.push(end, style);
        }, lineClasses, forceToEnd);
        var state = context.state; // Run overlays, adjust style array.

        var loop = function loop(o) {
          context.baseTokens = st;
          var overlay = cm.state.overlays[o],
              i = 1,
              at = 0;
          context.state = true;
          runMode(cm, line.text, overlay.mode, context, function (end, style) {
            var start = i; // Ensure there's a token end at the current position, and that i points at it

            while (at < end) {
              var i_end = st[i];

              if (i_end > end) {
                st.splice(i, 1, end, st[i + 1], i_end);
              }

              i += 2;
              at = Math.min(end, i_end);
            }

            if (!style) {
              return;
            }

            if (overlay.opaque) {
              st.splice(start, i - start, end, "overlay " + style);
              i = start + 2;
            } else {
              for (; start < i; start += 2) {
                var cur = st[start + 1];
                st[start + 1] = (cur ? cur + " " : "") + "overlay " + style;
              }
            }
          }, lineClasses);
          context.state = state;
          context.baseTokens = null;
          context.baseTokenPos = 1;
        };

        for (var o = 0; o < cm.state.overlays.length; ++o) {
          loop(o);
        }

        return {
          styles: st,
          classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null
        };
      }

      function getLineStyles(cm, line, updateFrontier) {
        if (!line.styles || line.styles[0] != cm.state.modeGen) {
          var context = getContextBefore(cm, lineNo(line));
          var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);
          var result = highlightLine(cm, line, context);

          if (resetState) {
            context.state = resetState;
          }

          line.stateAfter = context.save(!resetState);
          line.styles = result.styles;

          if (result.classes) {
            line.styleClasses = result.classes;
          } else if (line.styleClasses) {
            line.styleClasses = null;
          }

          if (updateFrontier === cm.doc.highlightFrontier) {
            cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier);
          }
        }

        return line.styles;
      }

      function getContextBefore(cm, n, precise) {
        var doc = cm.doc,
            display = cm.display;

        if (!doc.mode.startState) {
          return new Context(doc, true, n);
        }

        var start = findStartLine(cm, n, precise);
        var saved = start > doc.first && getLine(doc, start - 1).stateAfter;
        var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);
        doc.iter(start, n, function (line) {
          processLine(cm, line.text, context);
          var pos = context.line;
          line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;
          context.nextLine();
        });

        if (precise) {
          doc.modeFrontier = context.line;
        }

        return context;
      } // Lightweight form of highlight -- proceed over this line and
      // update state, but don't save a style array. Used for lines that
      // aren't currently visible.


      function processLine(cm, text, context, startAt) {
        var mode = cm.doc.mode;
        var stream = new StringStream(text, cm.options.tabSize, context);
        stream.start = stream.pos = startAt || 0;

        if (text == "") {
          callBlankLine(mode, context.state);
        }

        while (!stream.eol()) {
          readToken(mode, stream, context.state);
          stream.start = stream.pos;
        }
      }

      function callBlankLine(mode, state) {
        if (mode.blankLine) {
          return mode.blankLine(state);
        }

        if (!mode.innerMode) {
          return;
        }

        var inner = innerMode(mode, state);

        if (inner.mode.blankLine) {
          return inner.mode.blankLine(inner.state);
        }
      }

      function readToken(mode, stream, state, inner) {
        for (var i = 0; i < 10; i++) {
          if (inner) {
            inner[0] = innerMode(mode, state).mode;
          }

          var style = mode.token(stream, state);

          if (stream.pos > stream.start) {
            return style;
          }
        }

        throw new Error("Mode " + mode.name + " failed to advance stream.");
      }

      var Token = function Token(stream, type, state) {
        this.start = stream.start;
        this.end = stream.pos;
        this.string = stream.current();
        this.type = type || null;
        this.state = state;
      }; // Utility for getTokenAt and getLineTokens


      function takeToken(cm, pos, precise, asArray) {
        var doc = cm.doc,
            mode = doc.mode,
            style;
        pos = _clipPos(doc, pos);
        var line = getLine(doc, pos.line),
            context = getContextBefore(cm, pos.line, precise);
        var stream = new StringStream(line.text, cm.options.tabSize, context),
            tokens;

        if (asArray) {
          tokens = [];
        }

        while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
          stream.start = stream.pos;
          style = readToken(mode, stream, context.state);

          if (asArray) {
            tokens.push(new Token(stream, style, copyState(doc.mode, context.state)));
          }
        }

        return asArray ? tokens : new Token(stream, style, context.state);
      }

      function extractLineClasses(type, output) {
        if (type) {
          for (;;) {
            var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);

            if (!lineClass) {
              break;
            }

            type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
            var prop = lineClass[1] ? "bgClass" : "textClass";

            if (output[prop] == null) {
              output[prop] = lineClass[2];
            } else if (!new RegExp("(?:^|\s)" + lineClass[2] + "(?:$|\s)").test(output[prop])) {
              output[prop] += " " + lineClass[2];
            }
          }
        }

        return type;
      } // Run the given mode's parser over a line, calling f for each token.


      function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {
        var flattenSpans = mode.flattenSpans;

        if (flattenSpans == null) {
          flattenSpans = cm.options.flattenSpans;
        }

        var curStart = 0,
            curStyle = null;
        var stream = new StringStream(text, cm.options.tabSize, context),
            style;
        var inner = cm.options.addModeClass && [null];

        if (text == "") {
          extractLineClasses(callBlankLine(mode, context.state), lineClasses);
        }

        while (!stream.eol()) {
          if (stream.pos > cm.options.maxHighlightLength) {
            flattenSpans = false;

            if (forceToEnd) {
              processLine(cm, text, context, stream.pos);
            }

            stream.pos = text.length;
            style = null;
          } else {
            style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);
          }

          if (inner) {
            var mName = inner[0].name;

            if (mName) {
              style = "m-" + (style ? mName + " " + style : mName);
            }
          }

          if (!flattenSpans || curStyle != style) {
            while (curStart < stream.start) {
              curStart = Math.min(stream.start, curStart + 5000);
              f(curStart, curStyle);
            }

            curStyle = style;
          }

          stream.start = stream.pos;
        }

        while (curStart < stream.pos) {
          // Webkit seems to refuse to render text nodes longer than 57444
          // characters, and returns inaccurate measurements in nodes
          // starting around 5000 chars.
          var pos = Math.min(stream.pos, curStart + 5000);
          f(pos, curStyle);
          curStart = pos;
        }
      } // Finds the line to start with when starting a parse. Tries to
      // find a line with a stateAfter, so that it can start with a
      // valid state. If that fails, it returns the line with the
      // smallest indentation, which tends to need the least context to
      // parse correctly.


      function findStartLine(cm, n, precise) {
        var minindent,
            minline,
            doc = cm.doc;
        var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);

        for (var search = n; search > lim; --search) {
          if (search <= doc.first) {
            return doc.first;
          }

          var line = getLine(doc, search - 1),
              after = line.stateAfter;

          if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier)) {
            return search;
          }

          var indented = countColumn(line.text, null, cm.options.tabSize);

          if (minline == null || minindent > indented) {
            minline = search - 1;
            minindent = indented;
          }
        }

        return minline;
      }

      function retreatFrontier(doc, n) {
        doc.modeFrontier = Math.min(doc.modeFrontier, n);

        if (doc.highlightFrontier < n - 10) {
          return;
        }

        var start = doc.first;

        for (var line = n - 1; line > start; line--) {
          var saved = getLine(doc, line).stateAfter; // change is on 3
          // state on line 1 looked ahead 2 -- so saw 3
          // test 1 + 2 < 3 should cover this

          if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {
            start = line + 1;
            break;
          }
        }

        doc.highlightFrontier = Math.min(doc.highlightFrontier, start);
      } // Optimize some code when these features are not used.


      var sawReadOnlySpans = false,
          sawCollapsedSpans = false;

      function seeReadOnlySpans() {
        sawReadOnlySpans = true;
      }

      function seeCollapsedSpans() {
        sawCollapsedSpans = true;
      } // TEXTMARKER SPANS


      function MarkedSpan(marker, from, to) {
        this.marker = marker;
        this.from = from;
        this.to = to;
      } // Search an array of spans for a span matching the given marker.


      function getMarkedSpanFor(spans, marker) {
        if (spans) {
          for (var i = 0; i < spans.length; ++i) {
            var span = spans[i];

            if (span.marker == marker) {
              return span;
            }
          }
        }
      } // Remove a span from an array, returning undefined if no spans are
      // left (we don't store arrays for lines without spans).


      function removeMarkedSpan(spans, span) {
        var r;

        for (var i = 0; i < spans.length; ++i) {
          if (spans[i] != span) {
            (r || (r = [])).push(spans[i]);
          }
        }

        return r;
      } // Add a span to a line.


      function addMarkedSpan(line, span) {
        line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
        span.marker.attachLine(line);
      } // Used for the algorithm that adjusts markers for a change in the
      // document. These functions cut an array of spans at a given
      // character position, returning an array of remaining chunks (or
      // undefined if nothing remains).


      function markedSpansBefore(old, startCh, isInsert) {
        var nw;

        if (old) {
          for (var i = 0; i < old.length; ++i) {
            var span = old[i],
                marker = span.marker;
            var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);

            if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
              var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
              (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
            }
          }
        }

        return nw;
      }

      function markedSpansAfter(old, endCh, isInsert) {
        var nw;

        if (old) {
          for (var i = 0; i < old.length; ++i) {
            var span = old[i],
                marker = span.marker;
            var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);

            if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
              var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
              (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh, span.to == null ? null : span.to - endCh));
            }
          }
        }

        return nw;
      } // Given a change object, compute the new set of marker spans that
      // cover the line in which the change took place. Removes spans
      // entirely within the change, reconnects spans belonging to the
      // same marker that appear on both sides of the change, and cuts off
      // spans partially within the change. Returns an array of span
      // arrays with one element for each line in (after) the change.


      function stretchSpansOverChange(doc, change) {
        if (change.full) {
          return null;
        }

        var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
        var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;

        if (!oldFirst && !oldLast) {
          return null;
        }

        var startCh = change.from.ch,
            endCh = change.to.ch,
            isInsert = cmp(change.from, change.to) == 0; // Get the spans that 'stick out' on both sides

        var first = markedSpansBefore(oldFirst, startCh, isInsert);
        var last = markedSpansAfter(oldLast, endCh, isInsert); // Next, merge those two ends

        var sameLine = change.text.length == 1,
            offset = lst(change.text).length + (sameLine ? startCh : 0);

        if (first) {
          // Fix up .to properties of first
          for (var i = 0; i < first.length; ++i) {
            var span = first[i];

            if (span.to == null) {
              var found = getMarkedSpanFor(last, span.marker);

              if (!found) {
                span.to = startCh;
              } else if (sameLine) {
                span.to = found.to == null ? null : found.to + offset;
              }
            }
          }
        }

        if (last) {
          // Fix up .from in last (or move them into first in case of sameLine)
          for (var i$1 = 0; i$1 < last.length; ++i$1) {
            var span$1 = last[i$1];

            if (span$1.to != null) {
              span$1.to += offset;
            }

            if (span$1.from == null) {
              var found$1 = getMarkedSpanFor(first, span$1.marker);

              if (!found$1) {
                span$1.from = offset;

                if (sameLine) {
                  (first || (first = [])).push(span$1);
                }
              }
            } else {
              span$1.from += offset;

              if (sameLine) {
                (first || (first = [])).push(span$1);
              }
            }
          }
        } // Make sure we didn't create any zero-length spans


        if (first) {
          first = clearEmptySpans(first);
        }

        if (last && last != first) {
          last = clearEmptySpans(last);
        }

        var newMarkers = [first];

        if (!sameLine) {
          // Fill gap with whole-line-spans
          var gap = change.text.length - 2,
              gapMarkers;

          if (gap > 0 && first) {
            for (var i$2 = 0; i$2 < first.length; ++i$2) {
              if (first[i$2].to == null) {
                (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null));
              }
            }
          }

          for (var i$3 = 0; i$3 < gap; ++i$3) {
            newMarkers.push(gapMarkers);
          }

          newMarkers.push(last);
        }

        return newMarkers;
      } // Remove spans that are empty and don't have a clearWhenEmpty
      // option of false.


      function clearEmptySpans(spans) {
        for (var i = 0; i < spans.length; ++i) {
          var span = spans[i];

          if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false) {
            spans.splice(i--, 1);
          }
        }

        if (!spans.length) {
          return null;
        }

        return spans;
      } // Used to 'clip' out readOnly ranges when making a change.


      function removeReadOnlyRanges(doc, from, to) {
        var markers = null;
        doc.iter(from.line, to.line + 1, function (line) {
          if (line.markedSpans) {
            for (var i = 0; i < line.markedSpans.length; ++i) {
              var mark = line.markedSpans[i].marker;

              if (mark.readOnly && (!markers || indexOf(markers, mark) == -1)) {
                (markers || (markers = [])).push(mark);
              }
            }
          }
        });

        if (!markers) {
          return null;
        }

        var parts = [{
          from: from,
          to: to
        }];

        for (var i = 0; i < markers.length; ++i) {
          var mk = markers[i],
              m = mk.find(0);

          for (var j = 0; j < parts.length; ++j) {
            var p = parts[j];

            if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) {
              continue;
            }

            var newParts = [j, 1],
                dfrom = cmp(p.from, m.from),
                dto = cmp(p.to, m.to);

            if (dfrom < 0 || !mk.inclusiveLeft && !dfrom) {
              newParts.push({
                from: p.from,
                to: m.from
              });
            }

            if (dto > 0 || !mk.inclusiveRight && !dto) {
              newParts.push({
                from: m.to,
                to: p.to
              });
            }

            parts.splice.apply(parts, newParts);
            j += newParts.length - 3;
          }
        }

        return parts;
      } // Connect or disconnect spans from a line.


      function detachMarkedSpans(line) {
        var spans = line.markedSpans;

        if (!spans) {
          return;
        }

        for (var i = 0; i < spans.length; ++i) {
          spans[i].marker.detachLine(line);
        }

        line.markedSpans = null;
      }

      function attachMarkedSpans(line, spans) {
        if (!spans) {
          return;
        }

        for (var i = 0; i < spans.length; ++i) {
          spans[i].marker.attachLine(line);
        }

        line.markedSpans = spans;
      } // Helpers used when computing which overlapping collapsed span
      // counts as the larger one.


      function extraLeft(marker) {
        return marker.inclusiveLeft ? -1 : 0;
      }

      function extraRight(marker) {
        return marker.inclusiveRight ? 1 : 0;
      } // Returns a number indicating which of two overlapping collapsed
      // spans is larger (and thus includes the other). Falls back to
      // comparing ids when the spans cover exactly the same range.


      function compareCollapsedMarkers(a, b) {
        var lenDiff = a.lines.length - b.lines.length;

        if (lenDiff != 0) {
          return lenDiff;
        }

        var aPos = a.find(),
            bPos = b.find();
        var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);

        if (fromCmp) {
          return -fromCmp;
        }

        var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);

        if (toCmp) {
          return toCmp;
        }

        return b.id - a.id;
      } // Find out whether a line ends or starts in a collapsed span. If
      // so, return the marker for that span.


      function collapsedSpanAtSide(line, start) {
        var sps = sawCollapsedSpans && line.markedSpans,
            found;

        if (sps) {
          for (var sp = void 0, i = 0; i < sps.length; ++i) {
            sp = sps[i];

            if (sp.marker.collapsed && (start ? sp.from : sp.to) == null && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {
              found = sp.marker;
            }
          }
        }

        return found;
      }

      function collapsedSpanAtStart(line) {
        return collapsedSpanAtSide(line, true);
      }

      function collapsedSpanAtEnd(line) {
        return collapsedSpanAtSide(line, false);
      }

      function collapsedSpanAround(line, ch) {
        var sps = sawCollapsedSpans && line.markedSpans,
            found;

        if (sps) {
          for (var i = 0; i < sps.length; ++i) {
            var sp = sps[i];

            if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {
              found = sp.marker;
            }
          }
        }

        return found;
      } // Test whether there exists a collapsed span that partially
      // overlaps (covers the start or end, but not both) of a new span.
      // Such overlap is not allowed.


      function conflictingCollapsedRange(doc, lineNo, from, to, marker) {
        var line = getLine(doc, lineNo);
        var sps = sawCollapsedSpans && line.markedSpans;

        if (sps) {
          for (var i = 0; i < sps.length; ++i) {
            var sp = sps[i];

            if (!sp.marker.collapsed) {
              continue;
            }

            var found = sp.marker.find(0);
            var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
            var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);

            if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) {
              continue;
            }

            if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) || fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0)) {
              return true;
            }
          }
        }
      } // A visual line is a line as drawn on the screen. Folding, for
      // example, can cause multiple logical lines to appear on the same
      // visual line. This finds the start of the visual line that the
      // given line is part of (usually that is the line itself).


      function visualLine(line) {
        var merged;

        while (merged = collapsedSpanAtStart(line)) {
          line = merged.find(-1, true).line;
        }

        return line;
      }

      function visualLineEnd(line) {
        var merged;

        while (merged = collapsedSpanAtEnd(line)) {
          line = merged.find(1, true).line;
        }

        return line;
      } // Returns an array of logical lines that continue the visual line
      // started by the argument, or undefined if there are no such lines.


      function visualLineContinued(line) {
        var merged, lines;

        while (merged = collapsedSpanAtEnd(line)) {
          line = merged.find(1, true).line;
          (lines || (lines = [])).push(line);
        }

        return lines;
      } // Get the line number of the start of the visual line that the
      // given line number is part of.


      function visualLineNo(doc, lineN) {
        var line = getLine(doc, lineN),
            vis = visualLine(line);

        if (line == vis) {
          return lineN;
        }

        return lineNo(vis);
      } // Get the line number of the start of the next visual line after
      // the given line.


      function visualLineEndNo(doc, lineN) {
        if (lineN > doc.lastLine()) {
          return lineN;
        }

        var line = getLine(doc, lineN),
            merged;

        if (!lineIsHidden(doc, line)) {
          return lineN;
        }

        while (merged = collapsedSpanAtEnd(line)) {
          line = merged.find(1, true).line;
        }

        return lineNo(line) + 1;
      } // Compute whether a line is hidden. Lines count as hidden when they
      // are part of a visual line that starts with another line, or when
      // they are entirely covered by collapsed, non-widget span.


      function lineIsHidden(doc, line) {
        var sps = sawCollapsedSpans && line.markedSpans;

        if (sps) {
          for (var sp = void 0, i = 0; i < sps.length; ++i) {
            sp = sps[i];

            if (!sp.marker.collapsed) {
              continue;
            }

            if (sp.from == null) {
              return true;
            }

            if (sp.marker.widgetNode) {
              continue;
            }

            if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp)) {
              return true;
            }
          }
        }
      }

      function lineIsHiddenInner(doc, line, span) {
        if (span.to == null) {
          var end = span.marker.find(1, true);
          return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));
        }

        if (span.marker.inclusiveRight && span.to == line.text.length) {
          return true;
        }

        for (var sp = void 0, i = 0; i < line.markedSpans.length; ++i) {
          sp = line.markedSpans[i];

          if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to && (sp.to == null || sp.to != span.from) && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc, line, sp)) {
            return true;
          }
        }
      } // Find the height above the given line.


      function _heightAtLine(lineObj) {
        lineObj = visualLine(lineObj);
        var h = 0,
            chunk = lineObj.parent;

        for (var i = 0; i < chunk.lines.length; ++i) {
          var line = chunk.lines[i];

          if (line == lineObj) {
            break;
          } else {
            h += line.height;
          }
        }

        for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
          for (var i$1 = 0; i$1 < p.children.length; ++i$1) {
            var cur = p.children[i$1];

            if (cur == chunk) {
              break;
            } else {
              h += cur.height;
            }
          }
        }

        return h;
      } // Compute the character length of a line, taking into account
      // collapsed ranges (see markText) that might hide parts, and join
      // other lines onto it.


      function lineLength(line) {
        if (line.height == 0) {
          return 0;
        }

        var len = line.text.length,
            merged,
            cur = line;

        while (merged = collapsedSpanAtStart(cur)) {
          var found = merged.find(0, true);
          cur = found.from.line;
          len += found.from.ch - found.to.ch;
        }

        cur = line;

        while (merged = collapsedSpanAtEnd(cur)) {
          var found$1 = merged.find(0, true);
          len -= cur.text.length - found$1.from.ch;
          cur = found$1.to.line;
          len += cur.text.length - found$1.to.ch;
        }

        return len;
      } // Find the longest line in the document.


      function findMaxLine(cm) {
        var d = cm.display,
            doc = cm.doc;
        d.maxLine = getLine(doc, doc.first);
        d.maxLineLength = lineLength(d.maxLine);
        d.maxLineChanged = true;
        doc.iter(function (line) {
          var len = lineLength(line);

          if (len > d.maxLineLength) {
            d.maxLineLength = len;
            d.maxLine = line;
          }
        });
      } // LINE DATA STRUCTURE
      // Line objects. These hold state related to a line, including
      // highlighting info (the styles array).


      var Line = function Line(text, markedSpans, estimateHeight) {
        this.text = text;
        attachMarkedSpans(this, markedSpans);
        this.height = estimateHeight ? estimateHeight(this) : 1;
      };

      Line.prototype.lineNo = function () {
        return lineNo(this);
      };

      eventMixin(Line); // Change the content (text, markers) of a line. Automatically
      // invalidates cached information and tries to re-estimate the
      // line's height.

      function updateLine(line, text, markedSpans, estimateHeight) {
        line.text = text;

        if (line.stateAfter) {
          line.stateAfter = null;
        }

        if (line.styles) {
          line.styles = null;
        }

        if (line.order != null) {
          line.order = null;
        }

        detachMarkedSpans(line);
        attachMarkedSpans(line, markedSpans);
        var estHeight = estimateHeight ? estimateHeight(line) : 1;

        if (estHeight != line.height) {
          updateLineHeight(line, estHeight);
        }
      } // Detach a line from the document tree and its markers.


      function cleanUpLine(line) {
        line.parent = null;
        detachMarkedSpans(line);
      } // Convert a style as returned by a mode (either null, or a string
      // containing one or more styles) to a CSS style. This is cached,
      // and also looks for line-wide styles.


      var styleToClassCache = {},
          styleToClassCacheWithMode = {};

      function interpretTokenStyle(style, options) {
        if (!style || /^\s*$/.test(style)) {
          return null;
        }

        var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
        return cache[style] || (cache[style] = style.replace(/\S+/g, "cm-$&"));
      } // Render the DOM representation of the text of a line. Also builds
      // up a 'line map', which points at the DOM nodes that represent
      // specific stretches of text, and is used by the measuring code.
      // The returned object contains the DOM node, this map, and
      // information about line-wide styles that were set by the mode.


      function buildLineContent(cm, lineView) {
        // The padding-right forces the element to have a 'border', which
        // is needed on Webkit to be able to get line-level bounding
        // rectangles for it (in measureChar).
        var content = eltP("span", null, null, webkit ? "padding-right: .1px" : null);
        var builder = {
          pre: eltP("pre", [content], "CodeMirror-line"),
          content: content,
          col: 0,
          pos: 0,
          cm: cm,
          trailingSpace: false,
          splitSpaces: cm.getOption("lineWrapping")
        };
        lineView.measure = {}; // Iterate over the logical lines that make up this visual line.

        for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
          var line = i ? lineView.rest[i - 1] : lineView.line,
              order = void 0;
          builder.pos = 0;
          builder.addToken = buildToken; // Optionally wire in some hacks into the token-rendering
          // algorithm, to deal with browser quirks.

          if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction))) {
            builder.addToken = buildTokenBadBidi(builder.addToken, order);
          }

          builder.map = [];
          var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
          insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));

          if (line.styleClasses) {
            if (line.styleClasses.bgClass) {
              builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "");
            }

            if (line.styleClasses.textClass) {
              builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || "");
            }
          } // Ensure at least a single node is present, for measuring.


          if (builder.map.length == 0) {
            builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));
          } // Store the map and a cache object for the current logical line


          if (i == 0) {
            lineView.measure.map = builder.map;
            lineView.measure.cache = {};
          } else {
            (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);
            (lineView.measure.caches || (lineView.measure.caches = [])).push({});
          }
        } // See issue #2901


        if (webkit) {
          var last = builder.content.lastChild;

          if (/\bcm-tab\b/.test(last.className) || last.querySelector && last.querySelector(".cm-tab")) {
            builder.content.className = "cm-tab-wrap-hack";
          }
        }

        signal(cm, "renderLine", cm, lineView.line, builder.pre);

        if (builder.pre.className) {
          builder.textClass = joinClasses(builder.pre.className, builder.textClass || "");
        }

        return builder;
      }

      function defaultSpecialCharPlaceholder(ch) {
        var token = elt("span", "\u2022", "cm-invalidchar");
        token.title = "\\u" + ch.charCodeAt(0).toString(16);
        token.setAttribute("aria-label", token.title);
        return token;
      } // Build up the DOM representation for a single token, and add it to
      // the line map. Takes care to render special characters separately.


      function buildToken(builder, text, style, startStyle, endStyle, css, attributes) {
        if (!text) {
          return;
        }

        var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;
        var special = builder.cm.state.specialChars,
            mustWrap = false;
        var content;

        if (!special.test(text)) {
          builder.col += text.length;
          content = document.createTextNode(displayText);
          builder.map.push(builder.pos, builder.pos + text.length, content);

          if (ie && ie_version < 9) {
            mustWrap = true;
          }

          builder.pos += text.length;
        } else {
          content = document.createDocumentFragment();
          var pos = 0;

          while (true) {
            special.lastIndex = pos;
            var m = special.exec(text);
            var skipped = m ? m.index - pos : text.length - pos;

            if (skipped) {
              var txt = document.createTextNode(displayText.slice(pos, pos + skipped));

              if (ie && ie_version < 9) {
                content.appendChild(elt("span", [txt]));
              } else {
                content.appendChild(txt);
              }

              builder.map.push(builder.pos, builder.pos + skipped, txt);
              builder.col += skipped;
              builder.pos += skipped;
            }

            if (!m) {
              break;
            }

            pos += skipped + 1;
            var txt$1 = void 0;

            if (m[0] == "\t") {
              var tabSize = builder.cm.options.tabSize,
                  tabWidth = tabSize - builder.col % tabSize;
              txt$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
              txt$1.setAttribute("role", "presentation");
              txt$1.setAttribute("cm-text", "\t");
              builder.col += tabWidth;
            } else if (m[0] == "\r" || m[0] == "\n") {
              txt$1 = content.appendChild(elt("span", m[0] == "\r" ? "\u240D" : "\u2424", "cm-invalidchar"));
              txt$1.setAttribute("cm-text", m[0]);
              builder.col += 1;
            } else {
              txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);
              txt$1.setAttribute("cm-text", m[0]);

              if (ie && ie_version < 9) {
                content.appendChild(elt("span", [txt$1]));
              } else {
                content.appendChild(txt$1);
              }

              builder.col += 1;
            }

            builder.map.push(builder.pos, builder.pos + 1, txt$1);
            builder.pos++;
          }
        }

        builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;

        if (style || startStyle || endStyle || mustWrap || css) {
          var fullStyle = style || "";

          if (startStyle) {
            fullStyle += startStyle;
          }

          if (endStyle) {
            fullStyle += endStyle;
          }

          var token = elt("span", [content], fullStyle, css);

          if (attributes) {
            for (var attr in attributes) {
              if (attributes.hasOwnProperty(attr) && attr != "style" && attr != "class") {
                token.setAttribute(attr, attributes[attr]);
              }
            }
          }

          return builder.content.appendChild(token);
        }

        builder.content.appendChild(content);
      } // Change some spaces to NBSP to prevent the browser from collapsing
      // trailing spaces at the end of a line when rendering text (issue #1362).


      function splitSpaces(text, trailingBefore) {
        if (text.length > 1 && !/  /.test(text)) {
          return text;
        }

        var spaceBefore = trailingBefore,
            result = "";

        for (var i = 0; i < text.length; i++) {
          var ch = text.charAt(i);

          if (ch == " " && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32)) {
            ch = "\xA0";
          }

          result += ch;
          spaceBefore = ch == " ";
        }

        return result;
      } // Work around nonsense dimensions being reported for stretches of
      // right-to-left text.


      function buildTokenBadBidi(inner, order) {
        return function (builder, text, style, startStyle, endStyle, css, attributes) {
          style = style ? style + " cm-force-border" : "cm-force-border";
          var start = builder.pos,
              end = start + text.length;

          for (;;) {
            // Find the part that overlaps with the start of this text
            var part = void 0;

            for (var i = 0; i < order.length; i++) {
              part = order[i];

              if (part.to > start && part.from <= start) {
                break;
              }
            }

            if (part.to >= end) {
              return inner(builder, text, style, startStyle, endStyle, css, attributes);
            }

            inner(builder, text.slice(0, part.to - start), style, startStyle, null, css, attributes);
            startStyle = null;
            text = text.slice(part.to - start);
            start = part.to;
          }
        };
      }

      function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
        var widget = !ignoreWidget && marker.widgetNode;

        if (widget) {
          builder.map.push(builder.pos, builder.pos + size, widget);
        }

        if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
          if (!widget) {
            widget = builder.content.appendChild(document.createElement("span"));
          }

          widget.setAttribute("cm-marker", marker.id);
        }

        if (widget) {
          builder.cm.display.input.setUneditable(widget);
          builder.content.appendChild(widget);
        }

        builder.pos += size;
        builder.trailingSpace = false;
      } // Outputs a number of spans to make up a line, taking highlighting
      // and marked text into account.


      function insertLineContent(line, builder, styles) {
        var spans = line.markedSpans,
            allText = line.text,
            at = 0;

        if (!spans) {
          for (var i$1 = 1; i$1 < styles.length; i$1 += 2) {
            builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1 + 1], builder.cm.options));
          }

          return;
        }

        var len = allText.length,
            pos = 0,
            i = 1,
            text = "",
            style,
            css;
        var nextChange = 0,
            spanStyle,
            spanEndStyle,
            spanStartStyle,
            collapsed,
            attributes;

        for (;;) {
          if (nextChange == pos) {
            // Update current marker set
            spanStyle = spanEndStyle = spanStartStyle = css = "";
            attributes = null;
            collapsed = null;
            nextChange = Infinity;
            var foundBookmarks = [],
                endStyles = void 0;

            for (var j = 0; j < spans.length; ++j) {
              var sp = spans[j],
                  m = sp.marker;

              if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {
                foundBookmarks.push(m);
              } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
                if (sp.to != null && sp.to != pos && nextChange > sp.to) {
                  nextChange = sp.to;
                  spanEndStyle = "";
                }

                if (m.className) {
                  spanStyle += " " + m.className;
                }

                if (m.css) {
                  css = (css ? css + ";" : "") + m.css;
                }

                if (m.startStyle && sp.from == pos) {
                  spanStartStyle += " " + m.startStyle;
                }

                if (m.endStyle && sp.to == nextChange) {
                  (endStyles || (endStyles = [])).push(m.endStyle, sp.to);
                } // support for the old title property
                // https://github.com/codemirror/CodeMirror/pull/5673


                if (m.title) {
                  (attributes || (attributes = {})).title = m.title;
                }

                if (m.attributes) {
                  for (var attr in m.attributes) {
                    (attributes || (attributes = {}))[attr] = m.attributes[attr];
                  }
                }

                if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0)) {
                  collapsed = sp;
                }
              } else if (sp.from > pos && nextChange > sp.from) {
                nextChange = sp.from;
              }
            }

            if (endStyles) {
              for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2) {
                if (endStyles[j$1 + 1] == nextChange) {
                  spanEndStyle += " " + endStyles[j$1];
                }
              }
            }

            if (!collapsed || collapsed.from == pos) {
              for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2) {
                buildCollapsedSpan(builder, 0, foundBookmarks[j$2]);
              }
            }

            if (collapsed && (collapsed.from || 0) == pos) {
              buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos, collapsed.marker, collapsed.from == null);

              if (collapsed.to == null) {
                return;
              }

              if (collapsed.to == pos) {
                collapsed = false;
              }
            }
          }

          if (pos >= len) {
            break;
          }

          var upto = Math.min(len, nextChange);

          while (true) {
            if (text) {
              var end = pos + text.length;

              if (!collapsed) {
                var tokenText = end > upto ? text.slice(0, upto - pos) : text;
                builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle, spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", css, attributes);
              }

              if (end >= upto) {
                text = text.slice(upto - pos);
                pos = upto;
                break;
              }

              pos = end;
              spanStartStyle = "";
            }

            text = allText.slice(at, at = styles[i++]);
            style = interpretTokenStyle(styles[i++], builder.cm.options);
          }
        }
      } // These objects are used to represent the visible (currently drawn)
      // part of the document. A LineView may correspond to multiple
      // logical lines, if those are connected by collapsed ranges.


      function LineView(doc, line, lineN) {
        // The starting line
        this.line = line; // Continuing lines, if any

        this.rest = visualLineContinued(line); // Number of logical lines in this visual line

        this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
        this.node = this.text = null;
        this.hidden = lineIsHidden(doc, line);
      } // Create a range of LineView objects for the given lines.


      function buildViewArray(cm, from, to) {
        var array = [],
            nextPos;

        for (var pos = from; pos < to; pos = nextPos) {
          var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
          nextPos = pos + view.size;
          array.push(view);
        }

        return array;
      }

      var operationGroup = null;

      function pushOperation(op) {
        if (operationGroup) {
          operationGroup.ops.push(op);
        } else {
          op.ownsGroup = operationGroup = {
            ops: [op],
            delayedCallbacks: []
          };
        }
      }

      function fireCallbacksForOps(group) {
        // Calls delayed callbacks and cursorActivity handlers until no
        // new ones appear
        var callbacks = group.delayedCallbacks,
            i = 0;

        do {
          for (; i < callbacks.length; i++) {
            callbacks[i].call(null);
          }

          for (var j = 0; j < group.ops.length; j++) {
            var op = group.ops[j];

            if (op.cursorActivityHandlers) {
              while (op.cursorActivityCalled < op.cursorActivityHandlers.length) {
                op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);
              }
            }
          }
        } while (i < callbacks.length);
      }

      function finishOperation(op, endCb) {
        var group = op.ownsGroup;

        if (!group) {
          return;
        }

        try {
          fireCallbacksForOps(group);
        } finally {
          operationGroup = null;
          endCb(group);
        }
      }

      var orphanDelayedCallbacks = null; // Often, we want to signal events at a point where we are in the
      // middle of some work, but don't want the handler to start calling
      // other methods on the editor, which might be in an inconsistent
      // state or simply not expect any other events to happen.
      // signalLater looks whether there are any handlers, and schedules
      // them to be executed when the last operation ends, or, if no
      // operation is active, when a timeout fires.

      function signalLater(emitter, type
      /*, values...*/
      ) {
        var arr = getHandlers(emitter, type);

        if (!arr.length) {
          return;
        }

        var args = Array.prototype.slice.call(arguments, 2),
            list;

        if (operationGroup) {
          list = operationGroup.delayedCallbacks;
        } else if (orphanDelayedCallbacks) {
          list = orphanDelayedCallbacks;
        } else {
          list = orphanDelayedCallbacks = [];
          setTimeout(fireOrphanDelayed, 0);
        }

        var loop = function loop(i) {
          list.push(function () {
            return arr[i].apply(null, args);
          });
        };

        for (var i = 0; i < arr.length; ++i) {
          loop(i);
        }
      }

      function fireOrphanDelayed() {
        var delayed = orphanDelayedCallbacks;
        orphanDelayedCallbacks = null;

        for (var i = 0; i < delayed.length; ++i) {
          delayed[i]();
        }
      } // When an aspect of a line changes, a string is added to
      // lineView.changes. This updates the relevant part of the line's
      // DOM structure.


      function updateLineForChanges(cm, lineView, lineN, dims) {
        for (var j = 0; j < lineView.changes.length; j++) {
          var type = lineView.changes[j];

          if (type == "text") {
            updateLineText(cm, lineView);
          } else if (type == "gutter") {
            updateLineGutter(cm, lineView, lineN, dims);
          } else if (type == "class") {
            updateLineClasses(cm, lineView);
          } else if (type == "widget") {
            updateLineWidgets(cm, lineView, dims);
          }
        }

        lineView.changes = null;
      } // Lines with gutter elements, widgets or a background class need to
      // be wrapped, and have the extra elements added to the wrapper div


      function ensureLineWrapped(lineView) {
        if (lineView.node == lineView.text) {
          lineView.node = elt("div", null, null, "position: relative");

          if (lineView.text.parentNode) {
            lineView.text.parentNode.replaceChild(lineView.node, lineView.text);
          }

          lineView.node.appendChild(lineView.text);

          if (ie && ie_version < 8) {
            lineView.node.style.zIndex = 2;
          }
        }

        return lineView.node;
      }

      function updateLineBackground(cm, lineView) {
        var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;

        if (cls) {
          cls += " CodeMirror-linebackground";
        }

        if (lineView.background) {
          if (cls) {
            lineView.background.className = cls;
          } else {
            lineView.background.parentNode.removeChild(lineView.background);
            lineView.background = null;
          }
        } else if (cls) {
          var wrap = ensureLineWrapped(lineView);
          lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
          cm.display.input.setUneditable(lineView.background);
        }
      } // Wrapper around buildLineContent which will reuse the structure
      // in display.externalMeasured when possible.


      function getLineContent(cm, lineView) {
        var ext = cm.display.externalMeasured;

        if (ext && ext.line == lineView.line) {
          cm.display.externalMeasured = null;
          lineView.measure = ext.measure;
          return ext.built;
        }

        return buildLineContent(cm, lineView);
      } // Redraw the line's text. Interacts with the background and text
      // classes because the mode may output tokens that influence these
      // classes.


      function updateLineText(cm, lineView) {
        var cls = lineView.text.className;
        var built = getLineContent(cm, lineView);

        if (lineView.text == lineView.node) {
          lineView.node = built.pre;
        }

        lineView.text.parentNode.replaceChild(built.pre, lineView.text);
        lineView.text = built.pre;

        if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
          lineView.bgClass = built.bgClass;
          lineView.textClass = built.textClass;
          updateLineClasses(cm, lineView);
        } else if (cls) {
          lineView.text.className = cls;
        }
      }

      function updateLineClasses(cm, lineView) {
        updateLineBackground(cm, lineView);

        if (lineView.line.wrapClass) {
          ensureLineWrapped(lineView).className = lineView.line.wrapClass;
        } else if (lineView.node != lineView.text) {
          lineView.node.className = "";
        }

        var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
        lineView.text.className = textClass || "";
      }

      function updateLineGutter(cm, lineView, lineN, dims) {
        if (lineView.gutter) {
          lineView.node.removeChild(lineView.gutter);
          lineView.gutter = null;
        }

        if (lineView.gutterBackground) {
          lineView.node.removeChild(lineView.gutterBackground);
          lineView.gutterBackground = null;
        }

        if (lineView.line.gutterClass) {
          var wrap = ensureLineWrapped(lineView);
          lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass, "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + dims.gutterTotalWidth + "px");
          cm.display.input.setUneditable(lineView.gutterBackground);
          wrap.insertBefore(lineView.gutterBackground, lineView.text);
        }

        var markers = lineView.line.gutterMarkers;

        if (cm.options.lineNumbers || markers) {
          var wrap$1 = ensureLineWrapped(lineView);
          var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px");
          cm.display.input.setUneditable(gutterWrap);
          wrap$1.insertBefore(gutterWrap, lineView.text);

          if (lineView.line.gutterClass) {
            gutterWrap.className += " " + lineView.line.gutterClass;
          }

          if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"])) {
            lineView.lineNumber = gutterWrap.appendChild(elt("div", lineNumberFor(cm.options, lineN), "CodeMirror-linenumber CodeMirror-gutter-elt", "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: " + cm.display.lineNumInnerWidth + "px"));
          }

          if (markers) {
            for (var k = 0; k < cm.display.gutterSpecs.length; ++k) {
              var id = cm.display.gutterSpecs[k].className,
                  found = markers.hasOwnProperty(id) && markers[id];

              if (found) {
                gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt", "left: " + dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"));
              }
            }
          }
        }
      }

      function updateLineWidgets(cm, lineView, dims) {
        if (lineView.alignable) {
          lineView.alignable = null;
        }

        var isWidget = classTest("CodeMirror-linewidget");

        for (var node = lineView.node.firstChild, next = void 0; node; node = next) {
          next = node.nextSibling;

          if (isWidget.test(node.className)) {
            lineView.node.removeChild(node);
          }
        }

        insertLineWidgets(cm, lineView, dims);
      } // Build a line's DOM representation from scratch


      function buildLineElement(cm, lineView, lineN, dims) {
        var built = getLineContent(cm, lineView);
        lineView.text = lineView.node = built.pre;

        if (built.bgClass) {
          lineView.bgClass = built.bgClass;
        }

        if (built.textClass) {
          lineView.textClass = built.textClass;
        }

        updateLineClasses(cm, lineView);
        updateLineGutter(cm, lineView, lineN, dims);
        insertLineWidgets(cm, lineView, dims);
        return lineView.node;
      } // A lineView may contain multiple logical lines (when merged by
      // collapsed spans). The widgets for all of them need to be drawn.


      function insertLineWidgets(cm, lineView, dims) {
        insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);

        if (lineView.rest) {
          for (var i = 0; i < lineView.rest.length; i++) {
            insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false);
          }
        }
      }

      function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
        if (!line.widgets) {
          return;
        }

        var wrap = ensureLineWrapped(lineView);

        for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
          var widget = ws[i],
              node = elt("div", [widget.node], "CodeMirror-linewidget" + (widget.className ? " " + widget.className : ""));

          if (!widget.handleMouseEvents) {
            node.setAttribute("cm-ignore-events", "true");
          }

          positionLineWidget(widget, node, lineView, dims);
          cm.display.input.setUneditable(node);

          if (allowAbove && widget.above) {
            wrap.insertBefore(node, lineView.gutter || lineView.text);
          } else {
            wrap.appendChild(node);
          }

          signalLater(widget, "redraw");
        }
      }

      function positionLineWidget(widget, node, lineView, dims) {
        if (widget.noHScroll) {
          (lineView.alignable || (lineView.alignable = [])).push(node);
          var width = dims.wrapperWidth;
          node.style.left = dims.fixedPos + "px";

          if (!widget.coverGutter) {
            width -= dims.gutterTotalWidth;
            node.style.paddingLeft = dims.gutterTotalWidth + "px";
          }

          node.style.width = width + "px";
        }

        if (widget.coverGutter) {
          node.style.zIndex = 5;
          node.style.position = "relative";

          if (!widget.noHScroll) {
            node.style.marginLeft = -dims.gutterTotalWidth + "px";
          }
        }
      }

      function widgetHeight(widget) {
        if (widget.height != null) {
          return widget.height;
        }

        var cm = widget.doc.cm;

        if (!cm) {
          return 0;
        }

        if (!contains(document.body, widget.node)) {
          var parentStyle = "position: relative;";

          if (widget.coverGutter) {
            parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;";
          }

          if (widget.noHScroll) {
            parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;";
          }

          removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
        }

        return widget.height = widget.node.parentNode.offsetHeight;
      } // Return true when the given mouse event happened in a widget


      function eventInWidget(display, e) {
        for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
          if (!n || n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true" || n.parentNode == display.sizer && n != display.mover) {
            return true;
          }
        }
      } // POSITION MEASUREMENT


      function paddingTop(display) {
        return display.lineSpace.offsetTop;
      }

      function paddingVert(display) {
        return display.mover.offsetHeight - display.lineSpace.offsetHeight;
      }

      function paddingH(display) {
        if (display.cachedPaddingH) {
          return display.cachedPaddingH;
        }

        var e = removeChildrenAndAdd(display.measure, elt("pre", "x", "CodeMirror-line-like"));
        var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
        var data = {
          left: parseInt(style.paddingLeft),
          right: parseInt(style.paddingRight)
        };

        if (!isNaN(data.left) && !isNaN(data.right)) {
          display.cachedPaddingH = data;
        }

        return data;
      }

      function scrollGap(cm) {
        return scrollerGap - cm.display.nativeBarWidth;
      }

      function displayWidth(cm) {
        return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;
      }

      function displayHeight(cm) {
        return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;
      } // Ensure the lineView.wrapping.heights array is populated. This is
      // an array of bottom offsets for the lines that make up a drawn
      // line. When lineWrapping is on, there might be more than one
      // height.


      function ensureLineHeights(cm, lineView, rect) {
        var wrapping = cm.options.lineWrapping;
        var curWidth = wrapping && displayWidth(cm);

        if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
          var heights = lineView.measure.heights = [];

          if (wrapping) {
            lineView.measure.width = curWidth;
            var rects = lineView.text.firstChild.getClientRects();

            for (var i = 0; i < rects.length - 1; i++) {
              var cur = rects[i],
                  next = rects[i + 1];

              if (Math.abs(cur.bottom - next.bottom) > 2) {
                heights.push((cur.bottom + next.top) / 2 - rect.top);
              }
            }
          }

          heights.push(rect.bottom - rect.top);
        }
      } // Find a line map (mapping character offsets to text nodes) and a
      // measurement cache for the given line number. (A line view might
      // contain multiple lines when collapsed ranges are present.)


      function mapFromLineView(lineView, line, lineN) {
        if (lineView.line == line) {
          return {
            map: lineView.measure.map,
            cache: lineView.measure.cache
          };
        }

        for (var i = 0; i < lineView.rest.length; i++) {
          if (lineView.rest[i] == line) {
            return {
              map: lineView.measure.maps[i],
              cache: lineView.measure.caches[i]
            };
          }
        }

        for (var i$1 = 0; i$1 < lineView.rest.length; i$1++) {
          if (lineNo(lineView.rest[i$1]) > lineN) {
            return {
              map: lineView.measure.maps[i$1],
              cache: lineView.measure.caches[i$1],
              before: true
            };
          }
        }
      } // Render a line into the hidden node display.externalMeasured. Used
      // when measurement is needed for a line that's not in the viewport.


      function updateExternalMeasurement(cm, line) {
        line = visualLine(line);
        var lineN = lineNo(line);
        var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
        view.lineN = lineN;
        var built = view.built = buildLineContent(cm, view);
        view.text = built.pre;
        removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
        return view;
      } // Get a {top, bottom, left, right} box (in line-local coordinates)
      // for a given character.


      function measureChar(cm, line, ch, bias) {
        return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);
      } // Find a line view that corresponds to the given line number.


      function findViewForLine(cm, lineN) {
        if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo) {
          return cm.display.view[findViewIndex(cm, lineN)];
        }

        var ext = cm.display.externalMeasured;

        if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size) {
          return ext;
        }
      } // Measurement can be split in two steps, the set-up work that
      // applies to the whole line, and the measurement of the actual
      // character. Functions like coordsChar, that need to do a lot of
      // measurements in a row, can thus ensure that the set-up work is
      // only done once.


      function prepareMeasureForLine(cm, line) {
        var lineN = lineNo(line);
        var view = findViewForLine(cm, lineN);

        if (view && !view.text) {
          view = null;
        } else if (view && view.changes) {
          updateLineForChanges(cm, view, lineN, getDimensions(cm));
          cm.curOp.forceUpdate = true;
        }

        if (!view) {
          view = updateExternalMeasurement(cm, line);
        }

        var info = mapFromLineView(view, line, lineN);
        return {
          line: line,
          view: view,
          rect: null,
          map: info.map,
          cache: info.cache,
          before: info.before,
          hasHeights: false
        };
      } // Given a prepared measurement object, measures the position of an
      // actual character (or fetches it from the cache).


      function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
        if (prepared.before) {
          ch = -1;
        }

        var key = ch + (bias || ""),
            found;

        if (prepared.cache.hasOwnProperty(key)) {
          found = prepared.cache[key];
        } else {
          if (!prepared.rect) {
            prepared.rect = prepared.view.text.getBoundingClientRect();
          }

          if (!prepared.hasHeights) {
            ensureLineHeights(cm, prepared.view, prepared.rect);
            prepared.hasHeights = true;
          }

          found = measureCharInner(cm, prepared, ch, bias);

          if (!found.bogus) {
            prepared.cache[key] = found;
          }
        }

        return {
          left: found.left,
          right: found.right,
          top: varHeight ? found.rtop : found.top,
          bottom: varHeight ? found.rbottom : found.bottom
        };
      }

      var nullRect = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      };

      function nodeAndOffsetInLineMap(map, ch, bias) {
        var node, start, end, collapse, mStart, mEnd; // First, search the line map for the text node corresponding to,
        // or closest to, the target character.

        for (var i = 0; i < map.length; i += 3) {
          mStart = map[i];
          mEnd = map[i + 1];

          if (ch < mStart) {
            start = 0;
            end = 1;
            collapse = "left";
          } else if (ch < mEnd) {
            start = ch - mStart;
            end = start + 1;
          } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {
            end = mEnd - mStart;
            start = end - 1;

            if (ch >= mEnd) {
              collapse = "right";
            }
          }

          if (start != null) {
            node = map[i + 2];

            if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right")) {
              collapse = bias;
            }

            if (bias == "left" && start == 0) {
              while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {
                node = map[(i -= 3) + 2];
                collapse = "left";
              }
            }

            if (bias == "right" && start == mEnd - mStart) {
              while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {
                node = map[(i += 3) + 2];
                collapse = "right";
              }
            }

            break;
          }
        }

        return {
          node: node,
          start: start,
          end: end,
          collapse: collapse,
          coverStart: mStart,
          coverEnd: mEnd
        };
      }

      function getUsefulRect(rects, bias) {
        var rect = nullRect;

        if (bias == "left") {
          for (var i = 0; i < rects.length; i++) {
            if ((rect = rects[i]).left != rect.right) {
              break;
            }
          }
        } else {
          for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {
            if ((rect = rects[i$1]).left != rect.right) {
              break;
            }
          }
        }

        return rect;
      }

      function measureCharInner(cm, prepared, ch, bias) {
        var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
        var node = place.node,
            start = place.start,
            end = place.end,
            collapse = place.collapse;
        var rect;

        if (node.nodeType == 3) {
          // If it is a text node, use a range to retrieve the coordinates.
          for (var i$1 = 0; i$1 < 4; i$1++) {
            // Retry a maximum of 4 times when nonsense rectangles are returned
            while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) {
              --start;
            }

            while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) {
              ++end;
            }

            if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart) {
              rect = node.parentNode.getBoundingClientRect();
            } else {
              rect = getUsefulRect(range(node, start, end).getClientRects(), bias);
            }

            if (rect.left || rect.right || start == 0) {
              break;
            }

            end = start;
            start = start - 1;
            collapse = "right";
          }

          if (ie && ie_version < 11) {
            rect = maybeUpdateRectForZooming(cm.display.measure, rect);
          }
        } else {
          // If it is a widget, simply get the box for the whole widget.
          if (start > 0) {
            collapse = bias = "right";
          }

          var rects;

          if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1) {
            rect = rects[bias == "right" ? rects.length - 1 : 0];
          } else {
            rect = node.getBoundingClientRect();
          }
        }

        if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
          var rSpan = node.parentNode.getClientRects()[0];

          if (rSpan) {
            rect = {
              left: rSpan.left,
              right: rSpan.left + charWidth(cm.display),
              top: rSpan.top,
              bottom: rSpan.bottom
            };
          } else {
            rect = nullRect;
          }
        }

        var rtop = rect.top - prepared.rect.top,
            rbot = rect.bottom - prepared.rect.top;
        var mid = (rtop + rbot) / 2;
        var heights = prepared.view.measure.heights;
        var i = 0;

        for (; i < heights.length - 1; i++) {
          if (mid < heights[i]) {
            break;
          }
        }

        var top = i ? heights[i - 1] : 0,
            bot = heights[i];
        var result = {
          left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
          right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
          top: top,
          bottom: bot
        };

        if (!rect.left && !rect.right) {
          result.bogus = true;
        }

        if (!cm.options.singleCursorHeightPerLine) {
          result.rtop = rtop;
          result.rbottom = rbot;
        }

        return result;
      } // Work around problem with bounding client rects on ranges being
      // returned incorrectly when zoomed on IE10 and below.


      function maybeUpdateRectForZooming(measure, rect) {
        if (!window.screen || screen.logicalXDPI == null || screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure)) {
          return rect;
        }

        var scaleX = screen.logicalXDPI / screen.deviceXDPI;
        var scaleY = screen.logicalYDPI / screen.deviceYDPI;
        return {
          left: rect.left * scaleX,
          right: rect.right * scaleX,
          top: rect.top * scaleY,
          bottom: rect.bottom * scaleY
        };
      }

      function clearLineMeasurementCacheFor(lineView) {
        if (lineView.measure) {
          lineView.measure.cache = {};
          lineView.measure.heights = null;

          if (lineView.rest) {
            for (var i = 0; i < lineView.rest.length; i++) {
              lineView.measure.caches[i] = {};
            }
          }
        }
      }

      function clearLineMeasurementCache(cm) {
        cm.display.externalMeasure = null;
        removeChildren(cm.display.lineMeasure);

        for (var i = 0; i < cm.display.view.length; i++) {
          clearLineMeasurementCacheFor(cm.display.view[i]);
        }
      }

      function clearCaches(cm) {
        clearLineMeasurementCache(cm);
        cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;

        if (!cm.options.lineWrapping) {
          cm.display.maxLineChanged = true;
        }

        cm.display.lineNumChars = null;
      }

      function pageScrollX() {
        // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206
        // which causes page_Offset and bounding client rects to use
        // different reference viewports and invalidate our calculations.
        if (chrome && android) {
          return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft));
        }

        return window.pageXOffset || (document.documentElement || document.body).scrollLeft;
      }

      function pageScrollY() {
        if (chrome && android) {
          return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop));
        }

        return window.pageYOffset || (document.documentElement || document.body).scrollTop;
      }

      function widgetTopHeight(lineObj) {
        var height = 0;

        if (lineObj.widgets) {
          for (var i = 0; i < lineObj.widgets.length; ++i) {
            if (lineObj.widgets[i].above) {
              height += widgetHeight(lineObj.widgets[i]);
            }
          }
        }

        return height;
      } // Converts a {top, bottom, left, right} box from line-local
      // coordinates into another coordinate system. Context may be one of
      // "line", "div" (display.lineDiv), "local"./null (editor), "window",
      // or "page".


      function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
        if (!includeWidgets) {
          var height = widgetTopHeight(lineObj);
          rect.top += height;
          rect.bottom += height;
        }

        if (context == "line") {
          return rect;
        }

        if (!context) {
          context = "local";
        }

        var yOff = _heightAtLine(lineObj);

        if (context == "local") {
          yOff += paddingTop(cm.display);
        } else {
          yOff -= cm.display.viewOffset;
        }

        if (context == "page" || context == "window") {
          var lOff = cm.display.lineSpace.getBoundingClientRect();
          yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
          var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
          rect.left += xOff;
          rect.right += xOff;
        }

        rect.top += yOff;
        rect.bottom += yOff;
        return rect;
      } // Coverts a box from "div" coords to another coordinate system.
      // Context may be "window", "page", "div", or "local"./null.


      function fromCoordSystem(cm, coords, context) {
        if (context == "div") {
          return coords;
        }

        var left = coords.left,
            top = coords.top; // First move into "page" coordinate system

        if (context == "page") {
          left -= pageScrollX();
          top -= pageScrollY();
        } else if (context == "local" || !context) {
          var localBox = cm.display.sizer.getBoundingClientRect();
          left += localBox.left;
          top += localBox.top;
        }

        var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
        return {
          left: left - lineSpaceBox.left,
          top: top - lineSpaceBox.top
        };
      }

      function _charCoords(cm, pos, context, lineObj, bias) {
        if (!lineObj) {
          lineObj = getLine(cm.doc, pos.line);
        }

        return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);
      } // Returns a box for a given cursor position, which may have an
      // 'other' property containing the position of the secondary cursor
      // on a bidi boundary.
      // A cursor Pos(line, char, "before") is on the same visual line as `char - 1`
      // and after `char - 1` in writing order of `char - 1`
      // A cursor Pos(line, char, "after") is on the same visual line as `char`
      // and before `char` in writing order of `char`
      // Examples (upper-case letters are RTL, lower-case are LTR):
      //     Pos(0, 1, ...)
      //     before   after
      // ab     a|b     a|b
      // aB     a|B     aB|
      // Ab     |Ab     A|b
      // AB     B|A     B|A
      // Every position after the last character on a line is considered to stick
      // to the last character on the line.


      function _cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
        lineObj = lineObj || getLine(cm.doc, pos.line);

        if (!preparedMeasure) {
          preparedMeasure = prepareMeasureForLine(cm, lineObj);
        }

        function get(ch, right) {
          var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);

          if (right) {
            m.left = m.right;
          } else {
            m.right = m.left;
          }

          return intoCoordSystem(cm, lineObj, m, context);
        }

        var order = getOrder(lineObj, cm.doc.direction),
            ch = pos.ch,
            sticky = pos.sticky;

        if (ch >= lineObj.text.length) {
          ch = lineObj.text.length;
          sticky = "before";
        } else if (ch <= 0) {
          ch = 0;
          sticky = "after";
        }

        if (!order) {
          return get(sticky == "before" ? ch - 1 : ch, sticky == "before");
        }

        function getBidi(ch, partPos, invert) {
          var part = order[partPos],
              right = part.level == 1;
          return get(invert ? ch - 1 : ch, right != invert);
        }

        var partPos = getBidiPartAt(order, ch, sticky);
        var other = bidiOther;
        var val = getBidi(ch, partPos, sticky == "before");

        if (other != null) {
          val.other = getBidi(ch, other, sticky != "before");
        }

        return val;
      } // Used to cheaply estimate the coordinates for a position. Used for
      // intermediate scroll updates.


      function estimateCoords(cm, pos) {
        var left = 0;
        pos = _clipPos(cm.doc, pos);

        if (!cm.options.lineWrapping) {
          left = charWidth(cm.display) * pos.ch;
        }

        var lineObj = getLine(cm.doc, pos.line);
        var top = _heightAtLine(lineObj) + paddingTop(cm.display);
        return {
          left: left,
          right: left,
          top: top,
          bottom: top + lineObj.height
        };
      } // Positions returned by coordsChar contain some extra information.
      // xRel is the relative x position of the input coordinates compared
      // to the found position (so xRel > 0 means the coordinates are to
      // the right of the character position, for example). When outside
      // is true, that means the coordinates lie outside the line's
      // vertical range.


      function PosWithInfo(line, ch, sticky, outside, xRel) {
        var pos = Pos(line, ch, sticky);
        pos.xRel = xRel;

        if (outside) {
          pos.outside = outside;
        }

        return pos;
      } // Compute the character position closest to the given coordinates.
      // Input must be lineSpace-local ("div" coordinate system).


      function _coordsChar(cm, x, y) {
        var doc = cm.doc;
        y += cm.display.viewOffset;

        if (y < 0) {
          return PosWithInfo(doc.first, 0, null, -1, -1);
        }

        var lineN = _lineAtHeight(doc, y),
            last = doc.first + doc.size - 1;

        if (lineN > last) {
          return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, 1, 1);
        }

        if (x < 0) {
          x = 0;
        }

        var lineObj = getLine(doc, lineN);

        for (;;) {
          var found = coordsCharInner(cm, lineObj, lineN, x, y);
          var collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 || found.outside > 0 ? 1 : 0));

          if (!collapsed) {
            return found;
          }

          var rangeEnd = collapsed.find(1);

          if (rangeEnd.line == lineN) {
            return rangeEnd;
          }

          lineObj = getLine(doc, lineN = rangeEnd.line);
        }
      }

      function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {
        y -= widgetTopHeight(lineObj);
        var end = lineObj.text.length;
        var begin = findFirst(function (ch) {
          return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y;
        }, end, 0);
        end = findFirst(function (ch) {
          return measureCharPrepared(cm, preparedMeasure, ch).top > y;
        }, begin, end);
        return {
          begin: begin,
          end: end
        };
      }

      function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {
        if (!preparedMeasure) {
          preparedMeasure = prepareMeasureForLine(cm, lineObj);
        }

        var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), "line").top;
        return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop);
      } // Returns true if the given side of a box is after the given
      // coordinates, in top-to-bottom, left-to-right order.


      function boxIsAfter(box, x, y, left) {
        return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x;
      }

      function coordsCharInner(cm, lineObj, lineNo, x, y) {
        // Move y into line-local coordinate space
        y -= _heightAtLine(lineObj);
        var preparedMeasure = prepareMeasureForLine(cm, lineObj); // When directly calling `measureCharPrepared`, we have to adjust
        // for the widgets at this line.

        var widgetHeight = widgetTopHeight(lineObj);
        var begin = 0,
            end = lineObj.text.length,
            ltr = true;
        var order = getOrder(lineObj, cm.doc.direction); // If the line isn't plain left-to-right text, first figure out
        // which bidi section the coordinates fall into.

        if (order) {
          var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)(cm, lineObj, lineNo, preparedMeasure, order, x, y);
          ltr = part.level != 1; // The awkward -1 offsets are needed because findFirst (called
          // on these below) will treat its first bound as inclusive,
          // second as exclusive, but we want to actually address the
          // characters in the part's range

          begin = ltr ? part.from : part.to - 1;
          end = ltr ? part.to : part.from - 1;
        } // A binary search to find the first character whose bounding box
        // starts after the coordinates. If we run across any whose box wrap
        // the coordinates, store that.


        var chAround = null,
            boxAround = null;
        var ch = findFirst(function (ch) {
          var box = measureCharPrepared(cm, preparedMeasure, ch);
          box.top += widgetHeight;
          box.bottom += widgetHeight;

          if (!boxIsAfter(box, x, y, false)) {
            return false;
          }

          if (box.top <= y && box.left <= x) {
            chAround = ch;
            boxAround = box;
          }

          return true;
        }, begin, end);
        var baseX,
            sticky,
            outside = false; // If a box around the coordinates was found, use that

        if (boxAround) {
          // Distinguish coordinates nearer to the left or right side of the box
          var atLeft = x - boxAround.left < boxAround.right - x,
              atStart = atLeft == ltr;
          ch = chAround + (atStart ? 0 : 1);
          sticky = atStart ? "after" : "before";
          baseX = atLeft ? boxAround.left : boxAround.right;
        } else {
          // (Adjust for extended bound, if necessary.)
          if (!ltr && (ch == end || ch == begin)) {
            ch++;
          } // To determine which side to associate with, get the box to the
          // left of the character and compare it's vertical position to the
          // coordinates


          sticky = ch == 0 ? "after" : ch == lineObj.text.length ? "before" : measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight <= y == ltr ? "after" : "before"; // Now get accurate coordinates for this place, in order to get a
          // base X position

          var coords = _cursorCoords(cm, Pos(lineNo, ch, sticky), "line", lineObj, preparedMeasure);

          baseX = coords.left;
          outside = y < coords.top ? -1 : y >= coords.bottom ? 1 : 0;
        }

        ch = skipExtendingChars(lineObj.text, ch, 1);
        return PosWithInfo(lineNo, ch, sticky, outside, x - baseX);
      }

      function coordsBidiPart(cm, lineObj, lineNo, preparedMeasure, order, x, y) {
        // Bidi parts are sorted left-to-right, and in a non-line-wrapping
        // situation, we can take this ordering to correspond to the visual
        // ordering. This finds the first part whose end is after the given
        // coordinates.
        var index = findFirst(function (i) {
          var part = order[i],
              ltr = part.level != 1;
          return boxIsAfter(_cursorCoords(cm, Pos(lineNo, ltr ? part.to : part.from, ltr ? "before" : "after"), "line", lineObj, preparedMeasure), x, y, true);
        }, 0, order.length - 1);
        var part = order[index]; // If this isn't the first part, the part's start is also after
        // the coordinates, and the coordinates aren't on the same line as
        // that start, move one part back.

        if (index > 0) {
          var ltr = part.level != 1;

          var start = _cursorCoords(cm, Pos(lineNo, ltr ? part.from : part.to, ltr ? "after" : "before"), "line", lineObj, preparedMeasure);

          if (boxIsAfter(start, x, y, true) && start.top > y) {
            part = order[index - 1];
          }
        }

        return part;
      }

      function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {
        // In a wrapped line, rtl text on wrapping boundaries can do things
        // that don't correspond to the ordering in our `order` array at
        // all, so a binary search doesn't work, and we want to return a
        // part that only spans one line so that the binary search in
        // coordsCharInner is safe. As such, we first find the extent of the
        // wrapped line, and then do a flat search in which we discard any
        // spans that aren't on the line.
        var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);
        var begin = ref.begin;
        var end = ref.end;

        if (/\s/.test(lineObj.text.charAt(end - 1))) {
          end--;
        }

        var part = null,
            closestDist = null;

        for (var i = 0; i < order.length; i++) {
          var p = order[i];

          if (p.from >= end || p.to <= begin) {
            continue;
          }

          var ltr = p.level != 1;
          var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right; // Weigh against spans ending before this, so that they are only
          // picked if nothing ends after

          var dist = endX < x ? x - endX + 1e9 : endX - x;

          if (!part || closestDist > dist) {
            part = p;
            closestDist = dist;
          }
        }

        if (!part) {
          part = order[order.length - 1];
        } // Clip the part to the wrapped line.


        if (part.from < begin) {
          part = {
            from: begin,
            to: part.to,
            level: part.level
          };
        }

        if (part.to > end) {
          part = {
            from: part.from,
            to: end,
            level: part.level
          };
        }

        return part;
      }

      var measureText; // Compute the default text height.

      function textHeight(display) {
        if (display.cachedTextHeight != null) {
          return display.cachedTextHeight;
        }

        if (measureText == null) {
          measureText = elt("pre", null, "CodeMirror-line-like"); // Measure a bunch of lines, for browsers that compute
          // fractional heights.

          for (var i = 0; i < 49; ++i) {
            measureText.appendChild(document.createTextNode("x"));
            measureText.appendChild(elt("br"));
          }

          measureText.appendChild(document.createTextNode("x"));
        }

        removeChildrenAndAdd(display.measure, measureText);
        var height = measureText.offsetHeight / 50;

        if (height > 3) {
          display.cachedTextHeight = height;
        }

        removeChildren(display.measure);
        return height || 1;
      } // Compute the default character width.


      function charWidth(display) {
        if (display.cachedCharWidth != null) {
          return display.cachedCharWidth;
        }

        var anchor = elt("span", "xxxxxxxxxx");
        var pre = elt("pre", [anchor], "CodeMirror-line-like");
        removeChildrenAndAdd(display.measure, pre);
        var rect = anchor.getBoundingClientRect(),
            width = (rect.right - rect.left) / 10;

        if (width > 2) {
          display.cachedCharWidth = width;
        }

        return width || 10;
      } // Do a bulk-read of the DOM positions and sizes needed to draw the
      // view, so that we don't interleave reading and writing to the DOM.


      function getDimensions(cm) {
        var d = cm.display,
            left = {},
            width = {};
        var gutterLeft = d.gutters.clientLeft;

        for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
          var id = cm.display.gutterSpecs[i].className;
          left[id] = n.offsetLeft + n.clientLeft + gutterLeft;
          width[id] = n.clientWidth;
        }

        return {
          fixedPos: compensateForHScroll(d),
          gutterTotalWidth: d.gutters.offsetWidth,
          gutterLeft: left,
          gutterWidth: width,
          wrapperWidth: d.wrapper.clientWidth
        };
      } // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,
      // but using getBoundingClientRect to get a sub-pixel-accurate
      // result.


      function compensateForHScroll(display) {
        return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;
      } // Returns a function that estimates the height of a line, to use as
      // first approximation until the line becomes visible (and is thus
      // properly measurable).


      function estimateHeight(cm) {
        var th = textHeight(cm.display),
            wrapping = cm.options.lineWrapping;
        var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
        return function (line) {
          if (lineIsHidden(cm.doc, line)) {
            return 0;
          }

          var widgetsHeight = 0;

          if (line.widgets) {
            for (var i = 0; i < line.widgets.length; i++) {
              if (line.widgets[i].height) {
                widgetsHeight += line.widgets[i].height;
              }
            }
          }

          if (wrapping) {
            return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;
          } else {
            return widgetsHeight + th;
          }
        };
      }

      function estimateLineHeights(cm) {
        var doc = cm.doc,
            est = estimateHeight(cm);
        doc.iter(function (line) {
          var estHeight = est(line);

          if (estHeight != line.height) {
            updateLineHeight(line, estHeight);
          }
        });
      } // Given a mouse event, find the corresponding position. If liberal
      // is false, it checks whether a gutter or scrollbar was clicked,
      // and returns null if it was. forRect is used by rectangular
      // selections, and tries to estimate a character position even for
      // coordinates beyond the right of the text.


      function posFromMouse(cm, e, liberal, forRect) {
        var display = cm.display;

        if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") {
          return null;
        }

        var x,
            y,
            space = display.lineSpace.getBoundingClientRect(); // Fails unpredictably on IE[67] when mouse is dragged around quickly.

        try {
          x = e.clientX - space.left;
          y = e.clientY - space.top;
        } catch (e) {
          return null;
        }

        var coords = _coordsChar(cm, x, y),
            line;

        if (forRect && coords.xRel > 0 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
          var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
          coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
        }

        return coords;
      } // Find the view element corresponding to a given line. Return null
      // when the line isn't visible.


      function findViewIndex(cm, n) {
        if (n >= cm.display.viewTo) {
          return null;
        }

        n -= cm.display.viewFrom;

        if (n < 0) {
          return null;
        }

        var view = cm.display.view;

        for (var i = 0; i < view.length; i++) {
          n -= view[i].size;

          if (n < 0) {
            return i;
          }
        }
      } // Updates the display.view data structure for a given change to the
      // document. From and to are in pre-change coordinates. Lendiff is
      // the amount of lines added or subtracted by the change. This is
      // used for changes that span multiple lines, or change the way
      // lines are divided into visual lines. regLineChange (below)
      // registers single-line changes.


      function regChange(cm, from, to, lendiff) {
        if (from == null) {
          from = cm.doc.first;
        }

        if (to == null) {
          to = cm.doc.first + cm.doc.size;
        }

        if (!lendiff) {
          lendiff = 0;
        }

        var display = cm.display;

        if (lendiff && to < display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers > from)) {
          display.updateLineNumbers = from;
        }

        cm.curOp.viewChanged = true;

        if (from >= display.viewTo) {
          // Change after
          if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo) {
            resetView(cm);
          }
        } else if (to <= display.viewFrom) {
          // Change before
          if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
            resetView(cm);
          } else {
            display.viewFrom += lendiff;
            display.viewTo += lendiff;
          }
        } else if (from <= display.viewFrom && to >= display.viewTo) {
          // Full overlap
          resetView(cm);
        } else if (from <= display.viewFrom) {
          // Top overlap
          var cut = viewCuttingPoint(cm, to, to + lendiff, 1);

          if (cut) {
            display.view = display.view.slice(cut.index);
            display.viewFrom = cut.lineN;
            display.viewTo += lendiff;
          } else {
            resetView(cm);
          }
        } else if (to >= display.viewTo) {
          // Bottom overlap
          var cut$1 = viewCuttingPoint(cm, from, from, -1);

          if (cut$1) {
            display.view = display.view.slice(0, cut$1.index);
            display.viewTo = cut$1.lineN;
          } else {
            resetView(cm);
          }
        } else {
          // Gap in the middle
          var cutTop = viewCuttingPoint(cm, from, from, -1);
          var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);

          if (cutTop && cutBot) {
            display.view = display.view.slice(0, cutTop.index).concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN)).concat(display.view.slice(cutBot.index));
            display.viewTo += lendiff;
          } else {
            resetView(cm);
          }
        }

        var ext = display.externalMeasured;

        if (ext) {
          if (to < ext.lineN) {
            ext.lineN += lendiff;
          } else if (from < ext.lineN + ext.size) {
            display.externalMeasured = null;
          }
        }
      } // Register a change to a single line. Type must be one of "text",
      // "gutter", "class", "widget"


      function regLineChange(cm, line, type) {
        cm.curOp.viewChanged = true;
        var display = cm.display,
            ext = cm.display.externalMeasured;

        if (ext && line >= ext.lineN && line < ext.lineN + ext.size) {
          display.externalMeasured = null;
        }

        if (line < display.viewFrom || line >= display.viewTo) {
          return;
        }

        var lineView = display.view[findViewIndex(cm, line)];

        if (lineView.node == null) {
          return;
        }

        var arr = lineView.changes || (lineView.changes = []);

        if (indexOf(arr, type) == -1) {
          arr.push(type);
        }
      } // Clear the view.


      function resetView(cm) {
        cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
        cm.display.view = [];
        cm.display.viewOffset = 0;
      }

      function viewCuttingPoint(cm, oldN, newN, dir) {
        var index = findViewIndex(cm, oldN),
            diff,
            view = cm.display.view;

        if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size) {
          return {
            index: index,
            lineN: newN
          };
        }

        var n = cm.display.viewFrom;

        for (var i = 0; i < index; i++) {
          n += view[i].size;
        }

        if (n != oldN) {
          if (dir > 0) {
            if (index == view.length - 1) {
              return null;
            }

            diff = n + view[index].size - oldN;
            index++;
          } else {
            diff = n - oldN;
          }

          oldN += diff;
          newN += diff;
        }

        while (visualLineNo(cm.doc, newN) != newN) {
          if (index == (dir < 0 ? 0 : view.length - 1)) {
            return null;
          }

          newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
          index += dir;
        }

        return {
          index: index,
          lineN: newN
        };
      } // Force the view to cover a given range, adding empty view element
      // or clipping off existing ones as needed.


      function adjustView(cm, from, to) {
        var display = cm.display,
            view = display.view;

        if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
          display.view = buildViewArray(cm, from, to);
          display.viewFrom = from;
        } else {
          if (display.viewFrom > from) {
            display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);
          } else if (display.viewFrom < from) {
            display.view = display.view.slice(findViewIndex(cm, from));
          }

          display.viewFrom = from;

          if (display.viewTo < to) {
            display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));
          } else if (display.viewTo > to) {
            display.view = display.view.slice(0, findViewIndex(cm, to));
          }
        }

        display.viewTo = to;
      } // Count the number of lines in the view whose DOM representation is
      // out of date (or nonexistent).


      function countDirtyView(cm) {
        var view = cm.display.view,
            dirty = 0;

        for (var i = 0; i < view.length; i++) {
          var lineView = view[i];

          if (!lineView.hidden && (!lineView.node || lineView.changes)) {
            ++dirty;
          }
        }

        return dirty;
      }

      function updateSelection(cm) {
        cm.display.input.showSelection(cm.display.input.prepareSelection());
      }

      function prepareSelection(cm, primary) {
        if (primary === void 0) primary = true;
        var doc = cm.doc,
            result = {};
        var curFragment = result.cursors = document.createDocumentFragment();
        var selFragment = result.selection = document.createDocumentFragment();

        for (var i = 0; i < doc.sel.ranges.length; i++) {
          if (!primary && i == doc.sel.primIndex) {
            continue;
          }

          var range = doc.sel.ranges[i];

          if (range.from().line >= cm.display.viewTo || range.to().line < cm.display.viewFrom) {
            continue;
          }

          var collapsed = range.empty();

          if (collapsed || cm.options.showCursorWhenSelecting) {
            drawSelectionCursor(cm, range.head, curFragment);
          }

          if (!collapsed) {
            drawSelectionRange(cm, range, selFragment);
          }
        }

        return result;
      } // Draws a cursor for the given range


      function drawSelectionCursor(cm, head, output) {
        var pos = _cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);

        var cursor = output.appendChild(elt("div", "\xA0", "CodeMirror-cursor"));
        cursor.style.left = pos.left + "px";
        cursor.style.top = pos.top + "px";
        cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";

        if (pos.other) {
          // Secondary cursor, shown when on a 'jump' in bi-directional text
          var otherCursor = output.appendChild(elt("div", "\xA0", "CodeMirror-cursor CodeMirror-secondarycursor"));
          otherCursor.style.display = "";
          otherCursor.style.left = pos.other.left + "px";
          otherCursor.style.top = pos.other.top + "px";
          otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";
        }
      }

      function cmpCoords(a, b) {
        return a.top - b.top || a.left - b.left;
      } // Draws the given range as a highlighted selection


      function drawSelectionRange(cm, range, output) {
        var display = cm.display,
            doc = cm.doc;
        var fragment = document.createDocumentFragment();
        var padding = paddingH(cm.display),
            leftSide = padding.left;
        var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;
        var docLTR = doc.direction == "ltr";

        function add(left, top, width, bottom) {
          if (top < 0) {
            top = 0;
          }

          top = Math.round(top);
          bottom = Math.round(bottom);
          fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left + "px;\n                             top: " + top + "px; width: " + (width == null ? rightSide - left : width) + "px;\n                             height: " + (bottom - top) + "px"));
        }

        function drawForLine(line, fromArg, toArg) {
          var lineObj = getLine(doc, line);
          var lineLen = lineObj.text.length;
          var start, end;

          function coords(ch, bias) {
            return _charCoords(cm, Pos(line, ch), "div", lineObj, bias);
          }

          function wrapX(pos, dir, side) {
            var extent = wrappedLineExtentChar(cm, lineObj, null, pos);
            var prop = dir == "ltr" == (side == "after") ? "left" : "right";
            var ch = side == "after" ? extent.begin : extent.end - (/\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);
            return coords(ch, prop)[prop];
          }

          var order = getOrder(lineObj, doc.direction);
          iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir, i) {
            var ltr = dir == "ltr";
            var fromPos = coords(from, ltr ? "left" : "right");
            var toPos = coords(to - 1, ltr ? "right" : "left");
            var openStart = fromArg == null && from == 0,
                openEnd = toArg == null && to == lineLen;
            var first = i == 0,
                last = !order || i == order.length - 1;

            if (toPos.top - fromPos.top <= 3) {
              // Single line
              var openLeft = (docLTR ? openStart : openEnd) && first;
              var openRight = (docLTR ? openEnd : openStart) && last;
              var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;
              var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;
              add(left, fromPos.top, right - left, fromPos.bottom);
            } else {
              // Multiple lines
              var topLeft, topRight, botLeft, botRight;

              if (ltr) {
                topLeft = docLTR && openStart && first ? leftSide : fromPos.left;
                topRight = docLTR ? rightSide : wrapX(from, dir, "before");
                botLeft = docLTR ? leftSide : wrapX(to, dir, "after");
                botRight = docLTR && openEnd && last ? rightSide : toPos.right;
              } else {
                topLeft = !docLTR ? leftSide : wrapX(from, dir, "before");
                topRight = !docLTR && openStart && first ? rightSide : fromPos.right;
                botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;
                botRight = !docLTR ? rightSide : wrapX(to, dir, "after");
              }

              add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);

              if (fromPos.bottom < toPos.top) {
                add(leftSide, fromPos.bottom, null, toPos.top);
              }

              add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);
            }

            if (!start || cmpCoords(fromPos, start) < 0) {
              start = fromPos;
            }

            if (cmpCoords(toPos, start) < 0) {
              start = toPos;
            }

            if (!end || cmpCoords(fromPos, end) < 0) {
              end = fromPos;
            }

            if (cmpCoords(toPos, end) < 0) {
              end = toPos;
            }
          });
          return {
            start: start,
            end: end
          };
        }

        var sFrom = range.from(),
            sTo = range.to();

        if (sFrom.line == sTo.line) {
          drawForLine(sFrom.line, sFrom.ch, sTo.ch);
        } else {
          var fromLine = getLine(doc, sFrom.line),
              toLine = getLine(doc, sTo.line);
          var singleVLine = visualLine(fromLine) == visualLine(toLine);
          var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
          var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;

          if (singleVLine) {
            if (leftEnd.top < rightStart.top - 2) {
              add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
              add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
            } else {
              add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
            }
          }

          if (leftEnd.bottom < rightStart.top) {
            add(leftSide, leftEnd.bottom, null, rightStart.top);
          }
        }

        output.appendChild(fragment);
      } // Cursor-blinking


      function restartBlink(cm) {
        if (!cm.state.focused) {
          return;
        }

        var display = cm.display;
        clearInterval(display.blinker);
        var on = true;
        display.cursorDiv.style.visibility = "";

        if (cm.options.cursorBlinkRate > 0) {
          display.blinker = setInterval(function () {
            return display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden";
          }, cm.options.cursorBlinkRate);
        } else if (cm.options.cursorBlinkRate < 0) {
          display.cursorDiv.style.visibility = "hidden";
        }
      }

      function ensureFocus(cm) {
        if (!cm.state.focused) {
          cm.display.input.focus();
          onFocus(cm);
        }
      }

      function delayBlurEvent(cm) {
        cm.state.delayingBlurEvent = true;
        setTimeout(function () {
          if (cm.state.delayingBlurEvent) {
            cm.state.delayingBlurEvent = false;
            onBlur(cm);
          }
        }, 100);
      }

      function onFocus(cm, e) {
        if (cm.state.delayingBlurEvent) {
          cm.state.delayingBlurEvent = false;
        }

        if (cm.options.readOnly == "nocursor") {
          return;
        }

        if (!cm.state.focused) {
          signal(cm, "focus", cm, e);
          cm.state.focused = true;
          addClass(cm.display.wrapper, "CodeMirror-focused"); // This test prevents this from firing when a context
          // menu is closed (since the input reset would kill the
          // select-all detection hack)

          if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
            cm.display.input.reset();

            if (webkit) {
              setTimeout(function () {
                return cm.display.input.reset(true);
              }, 20);
            } // Issue #1730

          }

          cm.display.input.receivedFocus();
        }

        restartBlink(cm);
      }

      function onBlur(cm, e) {
        if (cm.state.delayingBlurEvent) {
          return;
        }

        if (cm.state.focused) {
          signal(cm, "blur", cm, e);
          cm.state.focused = false;
          rmClass(cm.display.wrapper, "CodeMirror-focused");
        }

        clearInterval(cm.display.blinker);
        setTimeout(function () {
          if (!cm.state.focused) {
            cm.display.shift = false;
          }
        }, 150);
      } // Read the actual heights of the rendered lines, and update their
      // stored heights to match.


      function updateHeightsInViewport(cm) {
        var display = cm.display;
        var prevBottom = display.lineDiv.offsetTop;

        for (var i = 0; i < display.view.length; i++) {
          var cur = display.view[i],
              wrapping = cm.options.lineWrapping;
          var height = void 0,
              width = 0;

          if (cur.hidden) {
            continue;
          }

          if (ie && ie_version < 8) {
            var bot = cur.node.offsetTop + cur.node.offsetHeight;
            height = bot - prevBottom;
            prevBottom = bot;
          } else {
            var box = cur.node.getBoundingClientRect();
            height = box.bottom - box.top; // Check that lines don't extend past the right of the current
            // editor width

            if (!wrapping && cur.text.firstChild) {
              width = cur.text.firstChild.getBoundingClientRect().right - box.left - 1;
            }
          }

          var diff = cur.line.height - height;

          if (diff > .005 || diff < -.005) {
            updateLineHeight(cur.line, height);
            updateWidgetHeight(cur.line);

            if (cur.rest) {
              for (var j = 0; j < cur.rest.length; j++) {
                updateWidgetHeight(cur.rest[j]);
              }
            }
          }

          if (width > cm.display.sizerWidth) {
            var chWidth = Math.ceil(width / charWidth(cm.display));

            if (chWidth > cm.display.maxLineLength) {
              cm.display.maxLineLength = chWidth;
              cm.display.maxLine = cur.line;
              cm.display.maxLineChanged = true;
            }
          }
        }
      } // Read and store the height of line widgets associated with the
      // given line.


      function updateWidgetHeight(line) {
        if (line.widgets) {
          for (var i = 0; i < line.widgets.length; ++i) {
            var w = line.widgets[i],
                parent = w.node.parentNode;

            if (parent) {
              w.height = parent.offsetHeight;
            }
          }
        }
      } // Compute the lines that are visible in a given viewport (defaults
      // the the current scroll position). viewport may contain top,
      // height, and ensure (see op.scrollToPos) properties.


      function visibleLines(display, doc, viewport) {
        var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
        top = Math.floor(top - paddingTop(display));
        var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;

        var from = _lineAtHeight(doc, top),
            to = _lineAtHeight(doc, bottom); // Ensure is a {from: {line, ch}, to: {line, ch}} object, and
        // forces those lines into the viewport (if possible).


        if (viewport && viewport.ensure) {
          var ensureFrom = viewport.ensure.from.line,
              ensureTo = viewport.ensure.to.line;

          if (ensureFrom < from) {
            from = ensureFrom;
            to = _lineAtHeight(doc, _heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);
          } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
            from = _lineAtHeight(doc, _heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);
            to = ensureTo;
          }
        }

        return {
          from: from,
          to: Math.max(to, from + 1)
        };
      } // SCROLLING THINGS INTO VIEW
      // If an editor sits on the top or bottom of the window, partially
      // scrolled out of view, this ensures that the cursor is visible.


      function maybeScrollWindow(cm, rect) {
        if (signalDOMEvent(cm, "scrollCursorIntoView")) {
          return;
        }

        var display = cm.display,
            box = display.sizer.getBoundingClientRect(),
            doScroll = null;

        if (rect.top + box.top < 0) {
          doScroll = true;
        } else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) {
          doScroll = false;
        }

        if (doScroll != null && !phantom) {
          var scrollNode = elt("div", "\u200B", null, "position: absolute;\n                         top: " + (rect.top - display.viewOffset - paddingTop(cm.display)) + "px;\n                         height: " + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + "px;\n                         left: " + rect.left + "px; width: " + Math.max(2, rect.right - rect.left) + "px;");
          cm.display.lineSpace.appendChild(scrollNode);
          scrollNode.scrollIntoView(doScroll);
          cm.display.lineSpace.removeChild(scrollNode);
        }
      } // Scroll a given position into view (immediately), verifying that
      // it actually became visible (as line heights are accurately
      // measured, the position of something may 'drift' during drawing).


      function scrollPosIntoView(cm, pos, end, margin) {
        if (margin == null) {
          margin = 0;
        }

        var rect;

        if (!cm.options.lineWrapping && pos == end) {
          // Set pos and end to the cursor positions around the character pos sticks to
          // If pos.sticky == "before", that is around pos.ch - 1, otherwise around pos.ch
          // If pos == Pos(_, 0, "before"), pos and end are unchanged
          pos = pos.ch ? Pos(pos.line, pos.sticky == "before" ? pos.ch - 1 : pos.ch, "after") : pos;
          end = pos.sticky == "before" ? Pos(pos.line, pos.ch + 1, "before") : pos;
        }

        for (var limit = 0; limit < 5; limit++) {
          var changed = false;

          var coords = _cursorCoords(cm, pos);

          var endCoords = !end || end == pos ? coords : _cursorCoords(cm, end);
          rect = {
            left: Math.min(coords.left, endCoords.left),
            top: Math.min(coords.top, endCoords.top) - margin,
            right: Math.max(coords.left, endCoords.left),
            bottom: Math.max(coords.bottom, endCoords.bottom) + margin
          };
          var scrollPos = calculateScrollPos(cm, rect);
          var startTop = cm.doc.scrollTop,
              startLeft = cm.doc.scrollLeft;

          if (scrollPos.scrollTop != null) {
            updateScrollTop(cm, scrollPos.scrollTop);

            if (Math.abs(cm.doc.scrollTop - startTop) > 1) {
              changed = true;
            }
          }

          if (scrollPos.scrollLeft != null) {
            setScrollLeft(cm, scrollPos.scrollLeft);

            if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) {
              changed = true;
            }
          }

          if (!changed) {
            break;
          }
        }

        return rect;
      } // Scroll a given set of coordinates into view (immediately).


      function scrollIntoView(cm, rect) {
        var scrollPos = calculateScrollPos(cm, rect);

        if (scrollPos.scrollTop != null) {
          updateScrollTop(cm, scrollPos.scrollTop);
        }

        if (scrollPos.scrollLeft != null) {
          setScrollLeft(cm, scrollPos.scrollLeft);
        }
      } // Calculate a new scroll position needed to scroll the given
      // rectangle into view. Returns an object with scrollTop and
      // scrollLeft properties. When these are undefined, the
      // vertical/horizontal position does not need to be adjusted.


      function calculateScrollPos(cm, rect) {
        var display = cm.display,
            snapMargin = textHeight(cm.display);

        if (rect.top < 0) {
          rect.top = 0;
        }

        var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
        var screen = displayHeight(cm),
            result = {};

        if (rect.bottom - rect.top > screen) {
          rect.bottom = rect.top + screen;
        }

        var docBottom = cm.doc.height + paddingVert(display);
        var atTop = rect.top < snapMargin,
            atBottom = rect.bottom > docBottom - snapMargin;

        if (rect.top < screentop) {
          result.scrollTop = atTop ? 0 : rect.top;
        } else if (rect.bottom > screentop + screen) {
          var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);

          if (newTop != screentop) {
            result.scrollTop = newTop;
          }
        }

        var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;
        var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);
        var tooWide = rect.right - rect.left > screenw;

        if (tooWide) {
          rect.right = rect.left + screenw;
        }

        if (rect.left < 10) {
          result.scrollLeft = 0;
        } else if (rect.left < screenleft) {
          result.scrollLeft = Math.max(0, rect.left - (tooWide ? 0 : 10));
        } else if (rect.right > screenw + screenleft - 3) {
          result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw;
        }

        return result;
      } // Store a relative adjustment to the scroll position in the current
      // operation (to be applied when the operation finishes).


      function addToScrollTop(cm, top) {
        if (top == null) {
          return;
        }

        resolveScrollToPos(cm);
        cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
      } // Make sure that at the end of the operation the current cursor is
      // shown.


      function ensureCursorVisible(cm) {
        resolveScrollToPos(cm);
        var cur = cm.getCursor();
        cm.curOp.scrollToPos = {
          from: cur,
          to: cur,
          margin: cm.options.cursorScrollMargin
        };
      }

      function scrollToCoords(cm, x, y) {
        if (x != null || y != null) {
          resolveScrollToPos(cm);
        }

        if (x != null) {
          cm.curOp.scrollLeft = x;
        }

        if (y != null) {
          cm.curOp.scrollTop = y;
        }
      }

      function scrollToRange(cm, range) {
        resolveScrollToPos(cm);
        cm.curOp.scrollToPos = range;
      } // When an operation has its scrollToPos property set, and another
      // scroll action is applied before the end of the operation, this
      // 'simulates' scrolling that position into view in a cheap way, so
      // that the effect of intermediate scroll commands is not ignored.


      function resolveScrollToPos(cm) {
        var range = cm.curOp.scrollToPos;

        if (range) {
          cm.curOp.scrollToPos = null;
          var from = estimateCoords(cm, range.from),
              to = estimateCoords(cm, range.to);
          scrollToCoordsRange(cm, from, to, range.margin);
        }
      }

      function scrollToCoordsRange(cm, from, to, margin) {
        var sPos = calculateScrollPos(cm, {
          left: Math.min(from.left, to.left),
          top: Math.min(from.top, to.top) - margin,
          right: Math.max(from.right, to.right),
          bottom: Math.max(from.bottom, to.bottom) + margin
        });
        scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);
      } // Sync the scrollable area and scrollbars, ensure the viewport
      // covers the visible area.


      function updateScrollTop(cm, val) {
        if (Math.abs(cm.doc.scrollTop - val) < 2) {
          return;
        }

        if (!gecko) {
          updateDisplaySimple(cm, {
            top: val
          });
        }

        setScrollTop(cm, val, true);

        if (gecko) {
          updateDisplaySimple(cm);
        }

        startWorker(cm, 100);
      }

      function setScrollTop(cm, val, forceScroll) {
        val = Math.max(0, Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val));

        if (cm.display.scroller.scrollTop == val && !forceScroll) {
          return;
        }

        cm.doc.scrollTop = val;
        cm.display.scrollbars.setScrollTop(val);

        if (cm.display.scroller.scrollTop != val) {
          cm.display.scroller.scrollTop = val;
        }
      } // Sync scroller and scrollbar, ensure the gutter elements are
      // aligned.


      function setScrollLeft(cm, val, isScroller, forceScroll) {
        val = Math.max(0, Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth));

        if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) {
          return;
        }

        cm.doc.scrollLeft = val;
        alignHorizontally(cm);

        if (cm.display.scroller.scrollLeft != val) {
          cm.display.scroller.scrollLeft = val;
        }

        cm.display.scrollbars.setScrollLeft(val);
      } // SCROLLBARS
      // Prepare DOM reads needed to update the scrollbars. Done in one
      // shot to minimize update/measure roundtrips.


      function measureForScrollbars(cm) {
        var d = cm.display,
            gutterW = d.gutters.offsetWidth;
        var docH = Math.round(cm.doc.height + paddingVert(cm.display));
        return {
          clientHeight: d.scroller.clientHeight,
          viewHeight: d.wrapper.clientHeight,
          scrollWidth: d.scroller.scrollWidth,
          clientWidth: d.scroller.clientWidth,
          viewWidth: d.wrapper.clientWidth,
          barLeft: cm.options.fixedGutter ? gutterW : 0,
          docHeight: docH,
          scrollHeight: docH + scrollGap(cm) + d.barHeight,
          nativeBarWidth: d.nativeBarWidth,
          gutterWidth: gutterW
        };
      }

      var NativeScrollbars = function NativeScrollbars(place, scroll, cm) {
        this.cm = cm;
        var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
        var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
        vert.tabIndex = horiz.tabIndex = -1;
        place(vert);
        place(horiz);
        on(vert, "scroll", function () {
          if (vert.clientHeight) {
            scroll(vert.scrollTop, "vertical");
          }
        });
        on(horiz, "scroll", function () {
          if (horiz.clientWidth) {
            scroll(horiz.scrollLeft, "horizontal");
          }
        });
        this.checkedZeroWidth = false; // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).

        if (ie && ie_version < 8) {
          this.horiz.style.minHeight = this.vert.style.minWidth = "18px";
        }
      };

      NativeScrollbars.prototype.update = function (measure) {
        var needsH = measure.scrollWidth > measure.clientWidth + 1;
        var needsV = measure.scrollHeight > measure.clientHeight + 1;
        var sWidth = measure.nativeBarWidth;

        if (needsV) {
          this.vert.style.display = "block";
          this.vert.style.bottom = needsH ? sWidth + "px" : "0";
          var totalHeight = measure.viewHeight - (needsH ? sWidth : 0); // A bug in IE8 can cause this value to be negative, so guard it.

          this.vert.firstChild.style.height = Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
        } else {
          this.vert.style.display = "";
          this.vert.firstChild.style.height = "0";
        }

        if (needsH) {
          this.horiz.style.display = "block";
          this.horiz.style.right = needsV ? sWidth + "px" : "0";
          this.horiz.style.left = measure.barLeft + "px";
          var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
          this.horiz.firstChild.style.width = Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
        } else {
          this.horiz.style.display = "";
          this.horiz.firstChild.style.width = "0";
        }

        if (!this.checkedZeroWidth && measure.clientHeight > 0) {
          if (sWidth == 0) {
            this.zeroWidthHack();
          }

          this.checkedZeroWidth = true;
        }

        return {
          right: needsV ? sWidth : 0,
          bottom: needsH ? sWidth : 0
        };
      };

      NativeScrollbars.prototype.setScrollLeft = function (pos) {
        if (this.horiz.scrollLeft != pos) {
          this.horiz.scrollLeft = pos;
        }

        if (this.disableHoriz) {
          this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz");
        }
      };

      NativeScrollbars.prototype.setScrollTop = function (pos) {
        if (this.vert.scrollTop != pos) {
          this.vert.scrollTop = pos;
        }

        if (this.disableVert) {
          this.enableZeroWidthBar(this.vert, this.disableVert, "vert");
        }
      };

      NativeScrollbars.prototype.zeroWidthHack = function () {
        var w = mac && !mac_geMountainLion ? "12px" : "18px";
        this.horiz.style.height = this.vert.style.width = w;
        this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none";
        this.disableHoriz = new Delayed();
        this.disableVert = new Delayed();
      };

      NativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay, type) {
        bar.style.pointerEvents = "auto";

        function maybeDisable() {
          // To find out whether the scrollbar is still visible, we
          // check whether the element under the pixel in the bottom
          // right corner of the scrollbar box is the scrollbar box
          // itself (when the bar is still visible) or its filler child
          // (when the bar is hidden). If it is still visible, we keep
          // it enabled, if it's hidden, we disable pointer events.
          var box = bar.getBoundingClientRect();
          var elt = type == "vert" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2) : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);

          if (elt != bar) {
            bar.style.pointerEvents = "none";
          } else {
            delay.set(1000, maybeDisable);
          }
        }

        delay.set(1000, maybeDisable);
      };

      NativeScrollbars.prototype.clear = function () {
        var parent = this.horiz.parentNode;
        parent.removeChild(this.horiz);
        parent.removeChild(this.vert);
      };

      var NullScrollbars = function NullScrollbars() {};

      NullScrollbars.prototype.update = function () {
        return {
          bottom: 0,
          right: 0
        };
      };

      NullScrollbars.prototype.setScrollLeft = function () {};

      NullScrollbars.prototype.setScrollTop = function () {};

      NullScrollbars.prototype.clear = function () {};

      function updateScrollbars(cm, measure) {
        if (!measure) {
          measure = measureForScrollbars(cm);
        }

        var startWidth = cm.display.barWidth,
            startHeight = cm.display.barHeight;
        updateScrollbarsInner(cm, measure);

        for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {
          if (startWidth != cm.display.barWidth && cm.options.lineWrapping) {
            updateHeightsInViewport(cm);
          }

          updateScrollbarsInner(cm, measureForScrollbars(cm));
          startWidth = cm.display.barWidth;
          startHeight = cm.display.barHeight;
        }
      } // Re-synchronize the fake scrollbars with the actual size of the
      // content.


      function updateScrollbarsInner(cm, measure) {
        var d = cm.display;
        var sizes = d.scrollbars.update(measure);
        d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
        d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";
        d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent";

        if (sizes.right && sizes.bottom) {
          d.scrollbarFiller.style.display = "block";
          d.scrollbarFiller.style.height = sizes.bottom + "px";
          d.scrollbarFiller.style.width = sizes.right + "px";
        } else {
          d.scrollbarFiller.style.display = "";
        }

        if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
          d.gutterFiller.style.display = "block";
          d.gutterFiller.style.height = sizes.bottom + "px";
          d.gutterFiller.style.width = measure.gutterWidth + "px";
        } else {
          d.gutterFiller.style.display = "";
        }
      }

      var scrollbarModel = {
        "native": NativeScrollbars,
        "null": NullScrollbars
      };

      function initScrollbars(cm) {
        if (cm.display.scrollbars) {
          cm.display.scrollbars.clear();

          if (cm.display.scrollbars.addClass) {
            rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);
          }
        }

        cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {
          cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller); // Prevent clicks in the scrollbars from killing focus

          on(node, "mousedown", function () {
            if (cm.state.focused) {
              setTimeout(function () {
                return cm.display.input.focus();
              }, 0);
            }
          });
          node.setAttribute("cm-not-content", "true");
        }, function (pos, axis) {
          if (axis == "horizontal") {
            setScrollLeft(cm, pos);
          } else {
            updateScrollTop(cm, pos);
          }
        }, cm);

        if (cm.display.scrollbars.addClass) {
          addClass(cm.display.wrapper, cm.display.scrollbars.addClass);
        }
      } // Operations are used to wrap a series of changes to the editor
      // state in such a way that each change won't have to update the
      // cursor and display (which would be awkward, slow, and
      // error-prone). Instead, display updates are batched and then all
      // combined and executed at once.


      var nextOpId = 0; // Start a new operation.

      function _startOperation(cm) {
        cm.curOp = {
          cm: cm,
          viewChanged: false,
          // Flag that indicates that lines might need to be redrawn
          startHeight: cm.doc.height,
          // Used to detect need to update scrollbar
          forceUpdate: false,
          // Used to force a redraw
          updateInput: 0,
          // Whether to reset the input textarea
          typing: false,
          // Whether this reset should be careful to leave existing text (for compositing)
          changeObjs: null,
          // Accumulated changes, for firing change events
          cursorActivityHandlers: null,
          // Set of handlers to fire cursorActivity on
          cursorActivityCalled: 0,
          // Tracks which cursorActivity handlers have been called already
          selectionChanged: false,
          // Whether the selection needs to be redrawn
          updateMaxLine: false,
          // Set when the widest line needs to be determined anew
          scrollLeft: null,
          scrollTop: null,
          // Intermediate scroll position, not pushed to DOM yet
          scrollToPos: null,
          // Used to scroll to a specific position
          focus: false,
          id: ++nextOpId // Unique ID

        };
        pushOperation(cm.curOp);
      } // Finish an operation, updating the display and signalling delayed events


      function _endOperation(cm) {
        var op = cm.curOp;

        if (op) {
          finishOperation(op, function (group) {
            for (var i = 0; i < group.ops.length; i++) {
              group.ops[i].cm.curOp = null;
            }

            endOperations(group);
          });
        }
      } // The DOM updates done when an operation finishes are batched so
      // that the minimum number of relayouts are required.


      function endOperations(group) {
        var ops = group.ops;

        for (var i = 0; i < ops.length; i++) // Read DOM
        {
          endOperation_R1(ops[i]);
        }

        for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)
        {
          endOperation_W1(ops[i$1]);
        }

        for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM
        {
          endOperation_R2(ops[i$2]);
        }

        for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)
        {
          endOperation_W2(ops[i$3]);
        }

        for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM
        {
          endOperation_finish(ops[i$4]);
        }
      }

      function endOperation_R1(op) {
        var cm = op.cm,
            display = cm.display;
        maybeClipScrollbars(cm);

        if (op.updateMaxLine) {
          findMaxLine(cm);
        }

        op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null || op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom || op.scrollToPos.to.line >= display.viewTo) || display.maxLineChanged && cm.options.lineWrapping;
        op.update = op.mustUpdate && new DisplayUpdate(cm, op.mustUpdate && {
          top: op.scrollTop,
          ensure: op.scrollToPos
        }, op.forceUpdate);
      }

      function endOperation_W1(op) {
        op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
      }

      function endOperation_R2(op) {
        var cm = op.cm,
            display = cm.display;

        if (op.updatedDisplay) {
          updateHeightsInViewport(cm);
        }

        op.barMeasure = measureForScrollbars(cm); // If the max line changed since it was last measured, measure it,
        // and ensure the document's width matches it.
        // updateDisplay_W2 will use these properties to do the actual resizing

        if (display.maxLineChanged && !cm.options.lineWrapping) {
          op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
          cm.display.sizerWidth = op.adjustWidthTo;
          op.barMeasure.scrollWidth = Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
          op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
        }

        if (op.updatedDisplay || op.selectionChanged) {
          op.preparedSelection = display.input.prepareSelection();
        }
      }

      function endOperation_W2(op) {
        var cm = op.cm;

        if (op.adjustWidthTo != null) {
          cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";

          if (op.maxScrollLeft < cm.doc.scrollLeft) {
            setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);
          }

          cm.display.maxLineChanged = false;
        }

        var takeFocus = op.focus && op.focus == activeElt();

        if (op.preparedSelection) {
          cm.display.input.showSelection(op.preparedSelection, takeFocus);
        }

        if (op.updatedDisplay || op.startHeight != cm.doc.height) {
          updateScrollbars(cm, op.barMeasure);
        }

        if (op.updatedDisplay) {
          setDocumentHeight(cm, op.barMeasure);
        }

        if (op.selectionChanged) {
          restartBlink(cm);
        }

        if (cm.state.focused && op.updateInput) {
          cm.display.input.reset(op.typing);
        }

        if (takeFocus) {
          ensureFocus(op.cm);
        }
      }

      function endOperation_finish(op) {
        var cm = op.cm,
            display = cm.display,
            doc = cm.doc;

        if (op.updatedDisplay) {
          postUpdateDisplay(cm, op.update);
        } // Abort mouse wheel delta measurement, when scrolling explicitly


        if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos)) {
          display.wheelStartX = display.wheelStartY = null;
        } // Propagate the scroll position to the actual DOM scroller


        if (op.scrollTop != null) {
          setScrollTop(cm, op.scrollTop, op.forceScroll);
        }

        if (op.scrollLeft != null) {
          setScrollLeft(cm, op.scrollLeft, true, true);
        } // If we need to scroll a specific position into view, do so.


        if (op.scrollToPos) {
          var rect = scrollPosIntoView(cm, _clipPos(doc, op.scrollToPos.from), _clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
          maybeScrollWindow(cm, rect);
        } // Fire events for markers that are hidden/unidden by editing or
        // undoing


        var hidden = op.maybeHiddenMarkers,
            unhidden = op.maybeUnhiddenMarkers;

        if (hidden) {
          for (var i = 0; i < hidden.length; ++i) {
            if (!hidden[i].lines.length) {
              signal(hidden[i], "hide");
            }
          }
        }

        if (unhidden) {
          for (var i$1 = 0; i$1 < unhidden.length; ++i$1) {
            if (unhidden[i$1].lines.length) {
              signal(unhidden[i$1], "unhide");
            }
          }
        }

        if (display.wrapper.offsetHeight) {
          doc.scrollTop = cm.display.scroller.scrollTop;
        } // Fire change events, and delayed event handlers


        if (op.changeObjs) {
          signal(cm, "changes", cm, op.changeObjs);
        }

        if (op.update) {
          op.update.finish();
        }
      } // Run the given function in an operation


      function runInOp(cm, f) {
        if (cm.curOp) {
          return f();
        }

        _startOperation(cm);

        try {
          return f();
        } finally {
          _endOperation(cm);
        }
      } // Wraps a function in an operation. Returns the wrapped function.


      function operation(cm, f) {
        return function () {
          if (cm.curOp) {
            return f.apply(cm, arguments);
          }

          _startOperation(cm);

          try {
            return f.apply(cm, arguments);
          } finally {
            _endOperation(cm);
          }
        };
      } // Used to add methods to editor and doc instances, wrapping them in
      // operations.


      function methodOp(f) {
        return function () {
          if (this.curOp) {
            return f.apply(this, arguments);
          }

          _startOperation(this);

          try {
            return f.apply(this, arguments);
          } finally {
            _endOperation(this);
          }
        };
      }

      function docMethodOp(f) {
        return function () {
          var cm = this.cm;

          if (!cm || cm.curOp) {
            return f.apply(this, arguments);
          }

          _startOperation(cm);

          try {
            return f.apply(this, arguments);
          } finally {
            _endOperation(cm);
          }
        };
      } // HIGHLIGHT WORKER


      function startWorker(cm, time) {
        if (cm.doc.highlightFrontier < cm.display.viewTo) {
          cm.state.highlight.set(time, bind(highlightWorker, cm));
        }
      }

      function highlightWorker(cm) {
        var doc = cm.doc;

        if (doc.highlightFrontier >= cm.display.viewTo) {
          return;
        }

        var end = +new Date() + cm.options.workTime;
        var context = getContextBefore(cm, doc.highlightFrontier);
        var changedLines = [];
        doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {
          if (context.line >= cm.display.viewFrom) {
            // Visible
            var oldStyles = line.styles;
            var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;
            var highlighted = highlightLine(cm, line, context, true);

            if (resetState) {
              context.state = resetState;
            }

            line.styles = highlighted.styles;
            var oldCls = line.styleClasses,
                newCls = highlighted.classes;

            if (newCls) {
              line.styleClasses = newCls;
            } else if (oldCls) {
              line.styleClasses = null;
            }

            var ischange = !oldStyles || oldStyles.length != line.styles.length || oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);

            for (var i = 0; !ischange && i < oldStyles.length; ++i) {
              ischange = oldStyles[i] != line.styles[i];
            }

            if (ischange) {
              changedLines.push(context.line);
            }

            line.stateAfter = context.save();
            context.nextLine();
          } else {
            if (line.text.length <= cm.options.maxHighlightLength) {
              processLine(cm, line.text, context);
            }

            line.stateAfter = context.line % 5 == 0 ? context.save() : null;
            context.nextLine();
          }

          if (+new Date() > end) {
            startWorker(cm, cm.options.workDelay);
            return true;
          }
        });
        doc.highlightFrontier = context.line;
        doc.modeFrontier = Math.max(doc.modeFrontier, context.line);

        if (changedLines.length) {
          runInOp(cm, function () {
            for (var i = 0; i < changedLines.length; i++) {
              regLineChange(cm, changedLines[i], "text");
            }
          });
        }
      } // DISPLAY DRAWING


      var DisplayUpdate = function DisplayUpdate(cm, viewport, force) {
        var display = cm.display;
        this.viewport = viewport; // Store some values that we'll need later (but don't want to force a relayout for)

        this.visible = visibleLines(display, cm.doc, viewport);
        this.editorIsHidden = !display.wrapper.offsetWidth;
        this.wrapperHeight = display.wrapper.clientHeight;
        this.wrapperWidth = display.wrapper.clientWidth;
        this.oldDisplayWidth = displayWidth(cm);
        this.force = force;
        this.dims = getDimensions(cm);
        this.events = [];
      };

      DisplayUpdate.prototype.signal = function (emitter, type) {
        if (hasHandler(emitter, type)) {
          this.events.push(arguments);
        }
      };

      DisplayUpdate.prototype.finish = function () {
        for (var i = 0; i < this.events.length; i++) {
          signal.apply(null, this.events[i]);
        }
      };

      function maybeClipScrollbars(cm) {
        var display = cm.display;

        if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
          display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
          display.heightForcer.style.height = scrollGap(cm) + "px";
          display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
          display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
          display.scrollbarsClipped = true;
        }
      }

      function selectionSnapshot(cm) {
        if (cm.hasFocus()) {
          return null;
        }

        var active = activeElt();

        if (!active || !contains(cm.display.lineDiv, active)) {
          return null;
        }

        var result = {
          activeElt: active
        };

        if (window.getSelection) {
          var sel = window.getSelection();

          if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {
            result.anchorNode = sel.anchorNode;
            result.anchorOffset = sel.anchorOffset;
            result.focusNode = sel.focusNode;
            result.focusOffset = sel.focusOffset;
          }
        }

        return result;
      }

      function restoreSelection(snapshot) {
        if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) {
          return;
        }

        snapshot.activeElt.focus();

        if (snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {
          var sel = window.getSelection(),
              range = document.createRange();
          range.setEnd(snapshot.anchorNode, snapshot.anchorOffset);
          range.collapse(false);
          sel.removeAllRanges();
          sel.addRange(range);
          sel.extend(snapshot.focusNode, snapshot.focusOffset);
        }
      } // Does the actual updating of the line display. Bails out
      // (returning false) when there is nothing to be done and forced is
      // false.


      function updateDisplayIfNeeded(cm, update) {
        var display = cm.display,
            doc = cm.doc;

        if (update.editorIsHidden) {
          resetView(cm);
          return false;
        } // Bail out if the visible area is already rendered and nothing changed.


        if (!update.force && update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) && display.renderedView == display.view && countDirtyView(cm) == 0) {
          return false;
        }

        if (maybeUpdateLineNumberWidth(cm)) {
          resetView(cm);
          update.dims = getDimensions(cm);
        } // Compute a suitable new viewport (from & to)


        var end = doc.first + doc.size;
        var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
        var to = Math.min(end, update.visible.to + cm.options.viewportMargin);

        if (display.viewFrom < from && from - display.viewFrom < 20) {
          from = Math.max(doc.first, display.viewFrom);
        }

        if (display.viewTo > to && display.viewTo - to < 20) {
          to = Math.min(end, display.viewTo);
        }

        if (sawCollapsedSpans) {
          from = visualLineNo(cm.doc, from);
          to = visualLineEndNo(cm.doc, to);
        }

        var different = from != display.viewFrom || to != display.viewTo || display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
        adjustView(cm, from, to);
        display.viewOffset = _heightAtLine(getLine(cm.doc, display.viewFrom)); // Position the mover div to align with the current scroll position

        cm.display.mover.style.top = display.viewOffset + "px";
        var toUpdate = countDirtyView(cm);

        if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo)) {
          return false;
        } // For big changes, we hide the enclosing element during the
        // update, since that speeds up the operations on most browsers.


        var selSnapshot = selectionSnapshot(cm);

        if (toUpdate > 4) {
          display.lineDiv.style.display = "none";
        }

        patchDisplay(cm, display.updateLineNumbers, update.dims);

        if (toUpdate > 4) {
          display.lineDiv.style.display = "";
        }

        display.renderedView = display.view; // There might have been a widget with a focused element that got
        // hidden or updated, if so re-focus it.

        restoreSelection(selSnapshot); // Prevent selection and cursors from interfering with the scroll
        // width and height.

        removeChildren(display.cursorDiv);
        removeChildren(display.selectionDiv);
        display.gutters.style.height = display.sizer.style.minHeight = 0;

        if (different) {
          display.lastWrapHeight = update.wrapperHeight;
          display.lastWrapWidth = update.wrapperWidth;
          startWorker(cm, 400);
        }

        display.updateLineNumbers = null;
        return true;
      }

      function postUpdateDisplay(cm, update) {
        var viewport = update.viewport;

        for (var first = true;; first = false) {
          if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
            // Clip forced viewport to actual scrollable area.
            if (viewport && viewport.top != null) {
              viewport = {
                top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)
              };
            } // Updated line heights might result in the drawn area not
            // actually covering the viewport. Keep looping until it does.


            update.visible = visibleLines(cm.display, cm.doc, viewport);

            if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo) {
              break;
            }
          } else if (first) {
            update.visible = visibleLines(cm.display, cm.doc, viewport);
          }

          if (!updateDisplayIfNeeded(cm, update)) {
            break;
          }

          updateHeightsInViewport(cm);
          var barMeasure = measureForScrollbars(cm);
          updateSelection(cm);
          updateScrollbars(cm, barMeasure);
          setDocumentHeight(cm, barMeasure);
          update.force = false;
        }

        update.signal(cm, "update", cm);

        if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
          update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
          cm.display.reportedViewFrom = cm.display.viewFrom;
          cm.display.reportedViewTo = cm.display.viewTo;
        }
      }

      function updateDisplaySimple(cm, viewport) {
        var update = new DisplayUpdate(cm, viewport);

        if (updateDisplayIfNeeded(cm, update)) {
          updateHeightsInViewport(cm);
          postUpdateDisplay(cm, update);
          var barMeasure = measureForScrollbars(cm);
          updateSelection(cm);
          updateScrollbars(cm, barMeasure);
          setDocumentHeight(cm, barMeasure);
          update.finish();
        }
      } // Sync the actual display DOM structure with display.view, removing
      // nodes for lines that are no longer in view, and creating the ones
      // that are not there yet, and updating the ones that are out of
      // date.


      function patchDisplay(cm, updateNumbersFrom, dims) {
        var display = cm.display,
            lineNumbers = cm.options.lineNumbers;
        var container = display.lineDiv,
            cur = container.firstChild;

        function rm(node) {
          var next = node.nextSibling; // Works around a throw-scroll bug in OS X Webkit

          if (webkit && mac && cm.display.currentWheelTarget == node) {
            node.style.display = "none";
          } else {
            node.parentNode.removeChild(node);
          }

          return next;
        }

        var view = display.view,
            lineN = display.viewFrom; // Loop over the elements in the view, syncing cur (the DOM nodes
        // in display.lineDiv) with the view as we go.

        for (var i = 0; i < view.length; i++) {
          var lineView = view[i];
          if (lineView.hidden) ;else if (!lineView.node || lineView.node.parentNode != container) {
            // Not drawn yet
            var node = buildLineElement(cm, lineView, lineN, dims);
            container.insertBefore(node, cur);
          } else {
            // Already drawn
            while (cur != lineView.node) {
              cur = rm(cur);
            }

            var updateNumber = lineNumbers && updateNumbersFrom != null && updateNumbersFrom <= lineN && lineView.lineNumber;

            if (lineView.changes) {
              if (indexOf(lineView.changes, "gutter") > -1) {
                updateNumber = false;
              }

              updateLineForChanges(cm, lineView, lineN, dims);
            }

            if (updateNumber) {
              removeChildren(lineView.lineNumber);
              lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
            }

            cur = lineView.node.nextSibling;
          }
          lineN += lineView.size;
        }

        while (cur) {
          cur = rm(cur);
        }
      }

      function updateGutterSpace(display) {
        var width = display.gutters.offsetWidth;
        display.sizer.style.marginLeft = width + "px";
      }

      function setDocumentHeight(cm, measure) {
        cm.display.sizer.style.minHeight = measure.docHeight + "px";
        cm.display.heightForcer.style.top = measure.docHeight + "px";
        cm.display.gutters.style.height = measure.docHeight + cm.display.barHeight + scrollGap(cm) + "px";
      } // Re-align line numbers and gutter marks to compensate for
      // horizontal scrolling.


      function alignHorizontally(cm) {
        var display = cm.display,
            view = display.view;

        if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) {
          return;
        }

        var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
        var gutterW = display.gutters.offsetWidth,
            left = comp + "px";

        for (var i = 0; i < view.length; i++) {
          if (!view[i].hidden) {
            if (cm.options.fixedGutter) {
              if (view[i].gutter) {
                view[i].gutter.style.left = left;
              }

              if (view[i].gutterBackground) {
                view[i].gutterBackground.style.left = left;
              }
            }

            var align = view[i].alignable;

            if (align) {
              for (var j = 0; j < align.length; j++) {
                align[j].style.left = left;
              }
            }
          }
        }

        if (cm.options.fixedGutter) {
          display.gutters.style.left = comp + gutterW + "px";
        }
      } // Used to ensure that the line number gutter is still the right
      // size for the current document size. Returns true when an update
      // is needed.


      function maybeUpdateLineNumberWidth(cm) {
        if (!cm.options.lineNumbers) {
          return false;
        }

        var doc = cm.doc,
            last = lineNumberFor(cm.options, doc.first + doc.size - 1),
            display = cm.display;

        if (last.length != display.lineNumChars) {
          var test = display.measure.appendChild(elt("div", [elt("div", last)], "CodeMirror-linenumber CodeMirror-gutter-elt"));
          var innerW = test.firstChild.offsetWidth,
              padding = test.offsetWidth - innerW;
          display.lineGutter.style.width = "";
          display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
          display.lineNumWidth = display.lineNumInnerWidth + padding;
          display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
          display.lineGutter.style.width = display.lineNumWidth + "px";
          updateGutterSpace(cm.display);
          return true;
        }

        return false;
      }

      function getGutters(gutters, lineNumbers) {
        var result = [],
            sawLineNumbers = false;

        for (var i = 0; i < gutters.length; i++) {
          var name = gutters[i],
              style = null;

          if (typeof name != "string") {
            style = name.style;
            name = name.className;
          }

          if (name == "CodeMirror-linenumbers") {
            if (!lineNumbers) {
              continue;
            } else {
              sawLineNumbers = true;
            }
          }

          result.push({
            className: name,
            style: style
          });
        }

        if (lineNumbers && !sawLineNumbers) {
          result.push({
            className: "CodeMirror-linenumbers",
            style: null
          });
        }

        return result;
      } // Rebuild the gutter elements, ensure the margin to the left of the
      // code matches their width.


      function renderGutters(display) {
        var gutters = display.gutters,
            specs = display.gutterSpecs;
        removeChildren(gutters);
        display.lineGutter = null;

        for (var i = 0; i < specs.length; ++i) {
          var ref = specs[i];
          var className = ref.className;
          var style = ref.style;
          var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + className));

          if (style) {
            gElt.style.cssText = style;
          }

          if (className == "CodeMirror-linenumbers") {
            display.lineGutter = gElt;
            gElt.style.width = (display.lineNumWidth || 1) + "px";
          }
        }

        gutters.style.display = specs.length ? "" : "none";
        updateGutterSpace(display);
      }

      function updateGutters(cm) {
        renderGutters(cm.display);
        regChange(cm);
        alignHorizontally(cm);
      } // The display handles the DOM integration, both for input reading
      // and content drawing. It holds references to DOM nodes and
      // display-related state.


      function Display(place, doc, input, options) {
        var d = this;
        this.input = input; // Covers bottom-right square when both scrollbars are present.

        d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
        d.scrollbarFiller.setAttribute("cm-not-content", "true"); // Covers bottom of gutter when coverGutterNextToScrollbar is on
        // and h scrollbar is present.

        d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
        d.gutterFiller.setAttribute("cm-not-content", "true"); // Will contain the actual code, positioned to cover the viewport.

        d.lineDiv = eltP("div", null, "CodeMirror-code"); // Elements are added to these to represent selection and cursors.

        d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
        d.cursorDiv = elt("div", null, "CodeMirror-cursors"); // A visibility: hidden element used to find the size of things.

        d.measure = elt("div", null, "CodeMirror-measure"); // When lines outside of the viewport are measured, they are drawn in this.

        d.lineMeasure = elt("div", null, "CodeMirror-measure"); // Wraps everything that needs to exist inside the vertically-padded coordinate system

        d.lineSpace = eltP("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv], null, "position: relative; outline: none");
        var lines = eltP("div", [d.lineSpace], "CodeMirror-lines"); // Moved around its parent to cover visible view.

        d.mover = elt("div", [lines], null, "position: relative"); // Set to the height of the document, allowing scrolling.

        d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
        d.sizerWidth = null; // Behavior of elts with overflow: auto and padding is
        // inconsistent across browsers. This is used to ensure the
        // scrollable area is big enough.

        d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;"); // Will contain the gutters, if any.

        d.gutters = elt("div", null, "CodeMirror-gutters");
        d.lineGutter = null; // Actual scrollable element.

        d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
        d.scroller.setAttribute("tabIndex", "-1"); // The element in which the editor lives.

        d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror"); // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)

        if (ie && ie_version < 8) {
          d.gutters.style.zIndex = -1;
          d.scroller.style.paddingRight = 0;
        }

        if (!webkit && !(gecko && mobile)) {
          d.scroller.draggable = true;
        }

        if (place) {
          if (place.appendChild) {
            place.appendChild(d.wrapper);
          } else {
            place(d.wrapper);
          }
        } // Current rendered range (may be bigger than the view window).


        d.viewFrom = d.viewTo = doc.first;
        d.reportedViewFrom = d.reportedViewTo = doc.first; // Information about the rendered lines.

        d.view = [];
        d.renderedView = null; // Holds info about a single rendered line when it was rendered
        // for measurement, while not in view.

        d.externalMeasured = null; // Empty space (in pixels) above the view

        d.viewOffset = 0;
        d.lastWrapHeight = d.lastWrapWidth = 0;
        d.updateLineNumbers = null;
        d.nativeBarWidth = d.barHeight = d.barWidth = 0;
        d.scrollbarsClipped = false; // Used to only resize the line number gutter when necessary (when
        // the amount of lines crosses a boundary that makes its width change)

        d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null; // Set to true when a non-horizontal-scrolling line widget is
        // added. As an optimization, line widget aligning is skipped when
        // this is false.

        d.alignWidgets = false;
        d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null; // Tracks the maximum line length so that the horizontal scrollbar
        // can be kept static when scrolling.

        d.maxLine = null;
        d.maxLineLength = 0;
        d.maxLineChanged = false; // Used for measuring wheel scrolling granularity

        d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null; // True when shift is held down.

        d.shift = false; // Used to track whether anything happened since the context menu
        // was opened.

        d.selForContextMenu = null;
        d.activeTouch = null;
        d.gutterSpecs = getGutters(options.gutters, options.lineNumbers);
        renderGutters(d);
        input.init(d);
      } // Since the delta values reported on mouse wheel events are
      // unstandardized between browsers and even browser versions, and
      // generally horribly unpredictable, this code starts by measuring
      // the scroll effect that the first few mouse wheel events have,
      // and, from that, detects the way it can convert deltas to pixel
      // offsets afterwards.
      //
      // The reason we want to know the amount a wheel event will scroll
      // is that it gives us a chance to update the display before the
      // actual scrolling happens, reducing flickering.


      var wheelSamples = 0,
          wheelPixelsPerUnit = null; // Fill in a browser-detected starting value on browsers where we
      // know one. These don't have to be accurate -- the result of them
      // being wrong would just be a slight flicker on the first wheel
      // scroll (if it is large enough).

      if (ie) {
        wheelPixelsPerUnit = -.53;
      } else if (gecko) {
        wheelPixelsPerUnit = 15;
      } else if (chrome) {
        wheelPixelsPerUnit = -.7;
      } else if (safari) {
        wheelPixelsPerUnit = -1 / 3;
      }

      function wheelEventDelta(e) {
        var dx = e.wheelDeltaX,
            dy = e.wheelDeltaY;

        if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) {
          dx = e.detail;
        }

        if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) {
          dy = e.detail;
        } else if (dy == null) {
          dy = e.wheelDelta;
        }

        return {
          x: dx,
          y: dy
        };
      }

      function wheelEventPixels(e) {
        var delta = wheelEventDelta(e);
        delta.x *= wheelPixelsPerUnit;
        delta.y *= wheelPixelsPerUnit;
        return delta;
      }

      function onScrollWheel(cm, e) {
        var delta = wheelEventDelta(e),
            dx = delta.x,
            dy = delta.y;
        var display = cm.display,
            scroll = display.scroller; // Quit if there's nothing to scroll here

        var canScrollX = scroll.scrollWidth > scroll.clientWidth;
        var canScrollY = scroll.scrollHeight > scroll.clientHeight;

        if (!(dx && canScrollX || dy && canScrollY)) {
          return;
        } // Webkit browsers on OS X abort momentum scrolls when the target
        // of the scroll event is removed from the scrollable element.
        // This hack (see related code in patchDisplay) makes sure the
        // element is kept around.


        if (dy && mac && webkit) {
          outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
            for (var i = 0; i < view.length; i++) {
              if (view[i].node == cur) {
                cm.display.currentWheelTarget = cur;
                break outer;
              }
            }
          }
        } // On some browsers, horizontal scrolling will cause redraws to
        // happen before the gutter has been realigned, causing it to
        // wriggle around in a most unseemly way. When we have an
        // estimated pixels/delta value, we just handle horizontal
        // scrolling entirely here. It'll be slightly off from native, but
        // better than glitching out.


        if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {
          if (dy && canScrollY) {
            updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * wheelPixelsPerUnit));
          }

          setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * wheelPixelsPerUnit)); // Only prevent default scrolling if vertical scrolling is
          // actually possible. Otherwise, it causes vertical scroll
          // jitter on OSX trackpads when deltaX is small and deltaY
          // is large (issue #3579)

          if (!dy || dy && canScrollY) {
            e_preventDefault(e);
          }

          display.wheelStartX = null; // Abort measurement, if in progress

          return;
        } // 'Project' the visible viewport to cover the area that is being
        // scrolled into view (if we know enough to estimate it).


        if (dy && wheelPixelsPerUnit != null) {
          var pixels = dy * wheelPixelsPerUnit;
          var top = cm.doc.scrollTop,
              bot = top + display.wrapper.clientHeight;

          if (pixels < 0) {
            top = Math.max(0, top + pixels - 50);
          } else {
            bot = Math.min(cm.doc.height, bot + pixels + 50);
          }

          updateDisplaySimple(cm, {
            top: top,
            bottom: bot
          });
        }

        if (wheelSamples < 20) {
          if (display.wheelStartX == null) {
            display.wheelStartX = scroll.scrollLeft;
            display.wheelStartY = scroll.scrollTop;
            display.wheelDX = dx;
            display.wheelDY = dy;
            setTimeout(function () {
              if (display.wheelStartX == null) {
                return;
              }

              var movedX = scroll.scrollLeft - display.wheelStartX;
              var movedY = scroll.scrollTop - display.wheelStartY;
              var sample = movedY && display.wheelDY && movedY / display.wheelDY || movedX && display.wheelDX && movedX / display.wheelDX;
              display.wheelStartX = display.wheelStartY = null;

              if (!sample) {
                return;
              }

              wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
              ++wheelSamples;
            }, 200);
          } else {
            display.wheelDX += dx;
            display.wheelDY += dy;
          }
        }
      } // Selection objects are immutable. A new one is created every time
      // the selection changes. A selection is one or more non-overlapping
      // (and non-touching) ranges, sorted, and an integer that indicates
      // which one is the primary selection (the one that's scrolled into
      // view, that getCursor returns, etc).


      var Selection = function Selection(ranges, primIndex) {
        this.ranges = ranges;
        this.primIndex = primIndex;
      };

      Selection.prototype.primary = function () {
        return this.ranges[this.primIndex];
      };

      Selection.prototype.equals = function (other) {
        if (other == this) {
          return true;
        }

        if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) {
          return false;
        }

        for (var i = 0; i < this.ranges.length; i++) {
          var here = this.ranges[i],
              there = other.ranges[i];

          if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) {
            return false;
          }
        }

        return true;
      };

      Selection.prototype.deepCopy = function () {
        var out = [];

        for (var i = 0; i < this.ranges.length; i++) {
          out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head));
        }

        return new Selection(out, this.primIndex);
      };

      Selection.prototype.somethingSelected = function () {
        for (var i = 0; i < this.ranges.length; i++) {
          if (!this.ranges[i].empty()) {
            return true;
          }
        }

        return false;
      };

      Selection.prototype.contains = function (pos, end) {
        if (!end) {
          end = pos;
        }

        for (var i = 0; i < this.ranges.length; i++) {
          var range = this.ranges[i];

          if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0) {
            return i;
          }
        }

        return -1;
      };

      var Range = function Range(anchor, head) {
        this.anchor = anchor;
        this.head = head;
      };

      Range.prototype.from = function () {
        return minPos(this.anchor, this.head);
      };

      Range.prototype.to = function () {
        return maxPos(this.anchor, this.head);
      };

      Range.prototype.empty = function () {
        return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;
      }; // Take an unsorted, potentially overlapping set of ranges, and
      // build a selection out of it. 'Consumes' ranges array (modifying
      // it).


      function normalizeSelection(cm, ranges, primIndex) {
        var mayTouch = cm && cm.options.selectionsMayTouch;
        var prim = ranges[primIndex];
        ranges.sort(function (a, b) {
          return cmp(a.from(), b.from());
        });
        primIndex = indexOf(ranges, prim);

        for (var i = 1; i < ranges.length; i++) {
          var cur = ranges[i],
              prev = ranges[i - 1];
          var diff = cmp(prev.to(), cur.from());

          if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {
            var from = minPos(prev.from(), cur.from()),
                to = maxPos(prev.to(), cur.to());
            var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;

            if (i <= primIndex) {
              --primIndex;
            }

            ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));
          }
        }

        return new Selection(ranges, primIndex);
      }

      function simpleSelection(anchor, head) {
        return new Selection([new Range(anchor, head || anchor)], 0);
      } // Compute the position of the end of a change (its 'to' property
      // refers to the pre-change end).


      function changeEnd(change) {
        if (!change.text) {
          return change.to;
        }

        return Pos(change.from.line + change.text.length - 1, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));
      } // Adjust a position to refer to the post-change position of the
      // same text, or the end of the change if the change covers it.


      function adjustForChange(pos, change) {
        if (cmp(pos, change.from) < 0) {
          return pos;
        }

        if (cmp(pos, change.to) <= 0) {
          return changeEnd(change);
        }

        var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1,
            ch = pos.ch;

        if (pos.line == change.to.line) {
          ch += changeEnd(change).ch - change.to.ch;
        }

        return Pos(line, ch);
      }

      function computeSelAfterChange(doc, change) {
        var out = [];

        for (var i = 0; i < doc.sel.ranges.length; i++) {
          var range = doc.sel.ranges[i];
          out.push(new Range(adjustForChange(range.anchor, change), adjustForChange(range.head, change)));
        }

        return normalizeSelection(doc.cm, out, doc.sel.primIndex);
      }

      function offsetPos(pos, old, nw) {
        if (pos.line == old.line) {
          return Pos(nw.line, pos.ch - old.ch + nw.ch);
        } else {
          return Pos(nw.line + (pos.line - old.line), pos.ch);
        }
      } // Used by replaceSelections to allow moving the selection to the
      // start or around the replaced test. Hint may be "start" or "around".


      function computeReplacedSel(doc, changes, hint) {
        var out = [];
        var oldPrev = Pos(doc.first, 0),
            newPrev = oldPrev;

        for (var i = 0; i < changes.length; i++) {
          var change = changes[i];
          var from = offsetPos(change.from, oldPrev, newPrev);
          var to = offsetPos(changeEnd(change), oldPrev, newPrev);
          oldPrev = change.to;
          newPrev = to;

          if (hint == "around") {
            var range = doc.sel.ranges[i],
                inv = cmp(range.head, range.anchor) < 0;
            out[i] = new Range(inv ? to : from, inv ? from : to);
          } else {
            out[i] = new Range(from, from);
          }
        }

        return new Selection(out, doc.sel.primIndex);
      } // Used to get the editor into a consistent state again when options change.


      function loadMode(cm) {
        cm.doc.mode = getMode(cm.options, cm.doc.modeOption);
        resetModeState(cm);
      }

      function resetModeState(cm) {
        cm.doc.iter(function (line) {
          if (line.stateAfter) {
            line.stateAfter = null;
          }

          if (line.styles) {
            line.styles = null;
          }
        });
        cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;
        startWorker(cm, 100);
        cm.state.modeGen++;

        if (cm.curOp) {
          regChange(cm);
        }
      } // DOCUMENT DATA STRUCTURE
      // By default, updates that start and end at the beginning of a line
      // are treated specially, in order to make the association of line
      // widgets and marker elements with the text behave more intuitive.


      function isWholeLineUpdate(doc, change) {
        return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" && (!doc.cm || doc.cm.options.wholeLineUpdateBefore);
      } // Perform a change on the document data structure.


      function updateDoc(doc, change, markedSpans, estimateHeight) {
        function spansFor(n) {
          return markedSpans ? markedSpans[n] : null;
        }

        function update(line, text, spans) {
          updateLine(line, text, spans, estimateHeight);
          signalLater(line, "change", line, change);
        }

        function linesFor(start, end) {
          var result = [];

          for (var i = start; i < end; ++i) {
            result.push(new Line(text[i], spansFor(i), estimateHeight));
          }

          return result;
        }

        var from = change.from,
            to = change.to,
            text = change.text;
        var firstLine = getLine(doc, from.line),
            lastLine = getLine(doc, to.line);
        var lastText = lst(text),
            lastSpans = spansFor(text.length - 1),
            nlines = to.line - from.line; // Adjust the line structure

        if (change.full) {
          doc.insert(0, linesFor(0, text.length));
          doc.remove(text.length, doc.size - text.length);
        } else if (isWholeLineUpdate(doc, change)) {
          // This is a whole-line replace. Treated specially to make
          // sure line objects move the way they are supposed to.
          var added = linesFor(0, text.length - 1);
          update(lastLine, lastLine.text, lastSpans);

          if (nlines) {
            doc.remove(from.line, nlines);
          }

          if (added.length) {
            doc.insert(from.line, added);
          }
        } else if (firstLine == lastLine) {
          if (text.length == 1) {
            update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
          } else {
            var added$1 = linesFor(1, text.length - 1);
            added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));
            update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
            doc.insert(from.line + 1, added$1);
          }
        } else if (text.length == 1) {
          update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
          doc.remove(from.line + 1, nlines);
        } else {
          update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
          update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
          var added$2 = linesFor(1, text.length - 1);

          if (nlines > 1) {
            doc.remove(from.line + 1, nlines - 1);
          }

          doc.insert(from.line + 1, added$2);
        }

        signalLater(doc, "change", doc, change);
      } // Call f for all linked documents.


      function linkedDocs(doc, f, sharedHistOnly) {
        function propagate(doc, skip, sharedHist) {
          if (doc.linked) {
            for (var i = 0; i < doc.linked.length; ++i) {
              var rel = doc.linked[i];

              if (rel.doc == skip) {
                continue;
              }

              var shared = sharedHist && rel.sharedHist;

              if (sharedHistOnly && !shared) {
                continue;
              }

              f(rel.doc, shared);
              propagate(rel.doc, doc, shared);
            }
          }
        }

        propagate(doc, null, true);
      } // Attach a document to an editor.


      function attachDoc(cm, doc) {
        if (doc.cm) {
          throw new Error("This document is already in use.");
        }

        cm.doc = doc;
        doc.cm = cm;
        estimateLineHeights(cm);
        loadMode(cm);
        setDirectionClass(cm);

        if (!cm.options.lineWrapping) {
          findMaxLine(cm);
        }

        cm.options.mode = doc.modeOption;
        regChange(cm);
      }

      function setDirectionClass(cm) {
        (cm.doc.direction == "rtl" ? addClass : rmClass)(cm.display.lineDiv, "CodeMirror-rtl");
      }

      function directionChanged(cm) {
        runInOp(cm, function () {
          setDirectionClass(cm);
          regChange(cm);
        });
      }

      function History(startGen) {
        // Arrays of change events and selections. Doing something adds an
        // event to done and clears undo. Undoing moves events from done
        // to undone, redoing moves them in the other direction.
        this.done = [];
        this.undone = [];
        this.undoDepth = Infinity; // Used to track when changes can be merged into a single undo
        // event

        this.lastModTime = this.lastSelTime = 0;
        this.lastOp = this.lastSelOp = null;
        this.lastOrigin = this.lastSelOrigin = null; // Used by the isClean() method

        this.generation = this.maxGeneration = startGen || 1;
      } // Create a history change event from an updateDoc-style change
      // object.


      function historyChangeFromChange(doc, change) {
        var histChange = {
          from: copyPos(change.from),
          to: changeEnd(change),
          text: getBetween(doc, change.from, change.to)
        };
        attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
        linkedDocs(doc, function (doc) {
          return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
        }, true);
        return histChange;
      } // Pop all selection events off the end of a history array. Stop at
      // a change event.


      function clearSelectionEvents(array) {
        while (array.length) {
          var last = lst(array);

          if (last.ranges) {
            array.pop();
          } else {
            break;
          }
        }
      } // Find the top change event in the history. Pop off selection
      // events that are in the way.


      function lastChangeEvent(hist, force) {
        if (force) {
          clearSelectionEvents(hist.done);
          return lst(hist.done);
        } else if (hist.done.length && !lst(hist.done).ranges) {
          return lst(hist.done);
        } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
          hist.done.pop();
          return lst(hist.done);
        }
      } // Register a change in the history. Merges changes that are within
      // a single operation, or are close together with an origin that
      // allows merging (starting with "+") into a single event.


      function addChangeToHistory(doc, change, selAfter, opId) {
        var hist = doc.history;
        hist.undone.length = 0;
        var time = +new Date(),
            cur;
        var last;

        if ((hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && (change.origin.charAt(0) == "+" && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500) || change.origin.charAt(0) == "*")) && (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
          // Merge this change into the last event
          last = lst(cur.changes);

          if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
            // Optimized case for simple insertion -- don't want to add
            // new changesets for every character typed
            last.to = changeEnd(change);
          } else {
            // Add new sub-event
            cur.changes.push(historyChangeFromChange(doc, change));
          }
        } else {
          // Can not be merged, start a new event.
          var before = lst(hist.done);

          if (!before || !before.ranges) {
            pushSelectionToHistory(doc.sel, hist.done);
          }

          cur = {
            changes: [historyChangeFromChange(doc, change)],
            generation: hist.generation
          };
          hist.done.push(cur);

          while (hist.done.length > hist.undoDepth) {
            hist.done.shift();

            if (!hist.done[0].ranges) {
              hist.done.shift();
            }
          }
        }

        hist.done.push(selAfter);
        hist.generation = ++hist.maxGeneration;
        hist.lastModTime = hist.lastSelTime = time;
        hist.lastOp = hist.lastSelOp = opId;
        hist.lastOrigin = hist.lastSelOrigin = change.origin;

        if (!last) {
          signal(doc, "historyAdded");
        }
      }

      function selectionEventCanBeMerged(doc, origin, prev, sel) {
        var ch = origin.charAt(0);
        return ch == "*" || ch == "+" && prev.ranges.length == sel.ranges.length && prev.somethingSelected() == sel.somethingSelected() && new Date() - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);
      } // Called whenever the selection changes, sets the new selection as
      // the pending selection in the history, and pushes the old pending
      // selection into the 'done' array when it was significantly
      // different (in number of selected ranges, emptiness, or time).


      function addSelectionToHistory(doc, sel, opId, options) {
        var hist = doc.history,
            origin = options && options.origin; // A new event is started when the previous origin does not match
        // the current, or the origins don't allow matching. Origins
        // starting with * are always merged, those starting with + are
        // merged when similar and close together in time.

        if (opId == hist.lastSelOp || origin && hist.lastSelOrigin == origin && (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin || selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))) {
          hist.done[hist.done.length - 1] = sel;
        } else {
          pushSelectionToHistory(sel, hist.done);
        }

        hist.lastSelTime = +new Date();
        hist.lastSelOrigin = origin;
        hist.lastSelOp = opId;

        if (options && options.clearRedo !== false) {
          clearSelectionEvents(hist.undone);
        }
      }

      function pushSelectionToHistory(sel, dest) {
        var top = lst(dest);

        if (!(top && top.ranges && top.equals(sel))) {
          dest.push(sel);
        }
      } // Used to store marked span information in the history.


      function attachLocalSpans(doc, change, from, to) {
        var existing = change["spans_" + doc.id],
            n = 0;
        doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {
          if (line.markedSpans) {
            (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans;
          }

          ++n;
        });
      } // When un/re-doing restores text containing marked spans, those
      // that have been explicitly cleared should not be restored.


      function removeClearedSpans(spans) {
        if (!spans) {
          return null;
        }

        var out;

        for (var i = 0; i < spans.length; ++i) {
          if (spans[i].marker.explicitlyCleared) {
            if (!out) {
              out = spans.slice(0, i);
            }
          } else if (out) {
            out.push(spans[i]);
          }
        }

        return !out ? spans : out.length ? out : null;
      } // Retrieve and filter the old marked spans stored in a change event.


      function getOldSpans(doc, change) {
        var found = change["spans_" + doc.id];

        if (!found) {
          return null;
        }

        var nw = [];

        for (var i = 0; i < change.text.length; ++i) {
          nw.push(removeClearedSpans(found[i]));
        }

        return nw;
      } // Used for un/re-doing changes from the history. Combines the
      // result of computing the existing spans with the set of spans that
      // existed in the history (so that deleting around a span and then
      // undoing brings back the span).


      function mergeOldSpans(doc, change) {
        var old = getOldSpans(doc, change);
        var stretched = stretchSpansOverChange(doc, change);

        if (!old) {
          return stretched;
        }

        if (!stretched) {
          return old;
        }

        for (var i = 0; i < old.length; ++i) {
          var oldCur = old[i],
              stretchCur = stretched[i];

          if (oldCur && stretchCur) {
            spans: for (var j = 0; j < stretchCur.length; ++j) {
              var span = stretchCur[j];

              for (var k = 0; k < oldCur.length; ++k) {
                if (oldCur[k].marker == span.marker) {
                  continue spans;
                }
              }

              oldCur.push(span);
            }
          } else if (stretchCur) {
            old[i] = stretchCur;
          }
        }

        return old;
      } // Used both to provide a JSON-safe object in .getHistory, and, when
      // detaching a document, to split the history in two


      function copyHistoryArray(events, newGroup, instantiateSel) {
        var copy = [];

        for (var i = 0; i < events.length; ++i) {
          var event = events[i];

          if (event.ranges) {
            copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
            continue;
          }

          var changes = event.changes,
              newChanges = [];
          copy.push({
            changes: newChanges
          });

          for (var j = 0; j < changes.length; ++j) {
            var change = changes[j],
                m = void 0;
            newChanges.push({
              from: change.from,
              to: change.to,
              text: change.text
            });

            if (newGroup) {
              for (var prop in change) {
                if (m = prop.match(/^spans_(\d+)$/)) {
                  if (indexOf(newGroup, Number(m[1])) > -1) {
                    lst(newChanges)[prop] = change[prop];
                    delete change[prop];
                  }
                }
              }
            }
          }
        }

        return copy;
      } // The 'scroll' parameter given to many of these indicated whether
      // the new cursor position should be scrolled into view after
      // modifying the selection.
      // If shift is held or the extend flag is set, extends a range to
      // include a given position (and optionally a second position).
      // Otherwise, simply returns the range between the given positions.
      // Used for cursor motion and such.


      function extendRange(range, head, other, extend) {
        if (extend) {
          var anchor = range.anchor;

          if (other) {
            var posBefore = cmp(head, anchor) < 0;

            if (posBefore != cmp(other, anchor) < 0) {
              anchor = head;
              head = other;
            } else if (posBefore != cmp(head, other) < 0) {
              head = other;
            }
          }

          return new Range(anchor, head);
        } else {
          return new Range(other || head, head);
        }
      } // Extend the primary selection range, discard the rest.


      function extendSelection(doc, head, other, options, extend) {
        if (extend == null) {
          extend = doc.cm && (doc.cm.display.shift || doc.extend);
        }

        setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options);
      } // Extend all selections (pos is an array of selections with length
      // equal the number of selections)


      function extendSelections(doc, heads, options) {
        var out = [];
        var extend = doc.cm && (doc.cm.display.shift || doc.extend);

        for (var i = 0; i < doc.sel.ranges.length; i++) {
          out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend);
        }

        var newSel = normalizeSelection(doc.cm, out, doc.sel.primIndex);
        setSelection(doc, newSel, options);
      } // Updates a single range in the selection.


      function replaceOneSelection(doc, i, range, options) {
        var ranges = doc.sel.ranges.slice(0);
        ranges[i] = range;
        setSelection(doc, normalizeSelection(doc.cm, ranges, doc.sel.primIndex), options);
      } // Reset the selection to a single range.


      function setSimpleSelection(doc, anchor, head, options) {
        setSelection(doc, simpleSelection(anchor, head), options);
      } // Give beforeSelectionChange handlers a change to influence a
      // selection update.


      function filterSelectionChange(doc, sel, options) {
        var obj = {
          ranges: sel.ranges,
          update: function update(ranges) {
            this.ranges = [];

            for (var i = 0; i < ranges.length; i++) {
              this.ranges[i] = new Range(_clipPos(doc, ranges[i].anchor), _clipPos(doc, ranges[i].head));
            }
          },
          origin: options && options.origin
        };
        signal(doc, "beforeSelectionChange", doc, obj);

        if (doc.cm) {
          signal(doc.cm, "beforeSelectionChange", doc.cm, obj);
        }

        if (obj.ranges != sel.ranges) {
          return normalizeSelection(doc.cm, obj.ranges, obj.ranges.length - 1);
        } else {
          return sel;
        }
      }

      function setSelectionReplaceHistory(doc, sel, options) {
        var done = doc.history.done,
            last = lst(done);

        if (last && last.ranges) {
          done[done.length - 1] = sel;
          setSelectionNoUndo(doc, sel, options);
        } else {
          setSelection(doc, sel, options);
        }
      } // Set a new selection.


      function setSelection(doc, sel, options) {
        setSelectionNoUndo(doc, sel, options);
        addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
      }

      function setSelectionNoUndo(doc, sel, options) {
        if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange")) {
          sel = filterSelectionChange(doc, sel, options);
        }

        var bias = options && options.bias || (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
        setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));

        if (!(options && options.scroll === false) && doc.cm) {
          ensureCursorVisible(doc.cm);
        }
      }

      function setSelectionInner(doc, sel) {
        if (sel.equals(doc.sel)) {
          return;
        }

        doc.sel = sel;

        if (doc.cm) {
          doc.cm.curOp.updateInput = 1;
          doc.cm.curOp.selectionChanged = true;
          signalCursorActivity(doc.cm);
        }

        signalLater(doc, "cursorActivity", doc);
      } // Verify that the selection does not partially select any atomic
      // marked ranges.


      function reCheckSelection(doc) {
        setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));
      } // Return a selection that does not partially select any atomic
      // ranges.


      function skipAtomicInSelection(doc, sel, bias, mayClear) {
        var out;

        for (var i = 0; i < sel.ranges.length; i++) {
          var range = sel.ranges[i];
          var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];
          var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);
          var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);

          if (out || newAnchor != range.anchor || newHead != range.head) {
            if (!out) {
              out = sel.ranges.slice(0, i);
            }

            out[i] = new Range(newAnchor, newHead);
          }
        }

        return out ? normalizeSelection(doc.cm, out, sel.primIndex) : sel;
      }

      function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
        var line = getLine(doc, pos.line);

        if (line.markedSpans) {
          for (var i = 0; i < line.markedSpans.length; ++i) {
            var sp = line.markedSpans[i],
                m = sp.marker; // Determine if we should prevent the cursor being placed to the left/right of an atomic marker
            // Historically this was determined using the inclusiveLeft/Right option, but the new way to control it
            // is with selectLeft/Right

            var preventCursorLeft = "selectLeft" in m ? !m.selectLeft : m.inclusiveLeft;
            var preventCursorRight = "selectRight" in m ? !m.selectRight : m.inclusiveRight;

            if ((sp.from == null || (preventCursorLeft ? sp.from <= pos.ch : sp.from < pos.ch)) && (sp.to == null || (preventCursorRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
              if (mayClear) {
                signal(m, "beforeCursorEnter");

                if (m.explicitlyCleared) {
                  if (!line.markedSpans) {
                    break;
                  } else {
                    --i;
                    continue;
                  }
                }
              }

              if (!m.atomic) {
                continue;
              }

              if (oldPos) {
                var near = m.find(dir < 0 ? 1 : -1),
                    diff = void 0;

                if (dir < 0 ? preventCursorRight : preventCursorLeft) {
                  near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null);
                }

                if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0)) {
                  return skipAtomicInner(doc, near, pos, dir, mayClear);
                }
              }

              var far = m.find(dir < 0 ? -1 : 1);

              if (dir < 0 ? preventCursorLeft : preventCursorRight) {
                far = movePos(doc, far, dir, far.line == pos.line ? line : null);
              }

              return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null;
            }
          }
        }

        return pos;
      } // Ensure a given position is not inside an atomic range.


      function skipAtomic(doc, pos, oldPos, bias, mayClear) {
        var dir = bias || 1;
        var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, dir, true) || skipAtomicInner(doc, pos, oldPos, -dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true);

        if (!found) {
          doc.cantEdit = true;
          return Pos(doc.first, 0);
        }

        return found;
      }

      function movePos(doc, pos, dir, line) {
        if (dir < 0 && pos.ch == 0) {
          if (pos.line > doc.first) {
            return _clipPos(doc, Pos(pos.line - 1));
          } else {
            return null;
          }
        } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {
          if (pos.line < doc.first + doc.size - 1) {
            return Pos(pos.line + 1, 0);
          } else {
            return null;
          }
        } else {
          return new Pos(pos.line, pos.ch + dir);
        }
      }

      function selectAll(cm) {
        cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);
      } // UPDATING
      // Allow "beforeChange" event handlers to influence a change


      function filterChange(doc, change, update) {
        var obj = {
          canceled: false,
          from: change.from,
          to: change.to,
          text: change.text,
          origin: change.origin,
          cancel: function cancel() {
            return obj.canceled = true;
          }
        };

        if (update) {
          obj.update = function (from, to, text, origin) {
            if (from) {
              obj.from = _clipPos(doc, from);
            }

            if (to) {
              obj.to = _clipPos(doc, to);
            }

            if (text) {
              obj.text = text;
            }

            if (origin !== undefined) {
              obj.origin = origin;
            }
          };
        }

        signal(doc, "beforeChange", doc, obj);

        if (doc.cm) {
          signal(doc.cm, "beforeChange", doc.cm, obj);
        }

        if (obj.canceled) {
          if (doc.cm) {
            doc.cm.curOp.updateInput = 2;
          }

          return null;
        }

        return {
          from: obj.from,
          to: obj.to,
          text: obj.text,
          origin: obj.origin
        };
      } // Apply a change to a document, and add it to the document's
      // history, and propagating it to all linked documents.


      function makeChange(doc, change, ignoreReadOnly) {
        if (doc.cm) {
          if (!doc.cm.curOp) {
            return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);
          }

          if (doc.cm.state.suppressEdits) {
            return;
          }
        }

        if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
          change = filterChange(doc, change, true);

          if (!change) {
            return;
          }
        } // Possibly split or suppress the update based on the presence
        // of read-only spans in its range.


        var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);

        if (split) {
          for (var i = split.length - 1; i >= 0; --i) {
            makeChangeInner(doc, {
              from: split[i].from,
              to: split[i].to,
              text: i ? [""] : change.text,
              origin: change.origin
            });
          }
        } else {
          makeChangeInner(doc, change);
        }
      }

      function makeChangeInner(doc, change) {
        if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) {
          return;
        }

        var selAfter = computeSelAfterChange(doc, change);
        addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);
        makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
        var rebased = [];
        linkedDocs(doc, function (doc, sharedHist) {
          if (!sharedHist && indexOf(rebased, doc.history) == -1) {
            rebaseHist(doc.history, change);
            rebased.push(doc.history);
          }

          makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
        });
      } // Revert a change stored in a document's history.


      function makeChangeFromHistory(doc, type, allowSelectionOnly) {
        var suppress = doc.cm && doc.cm.state.suppressEdits;

        if (suppress && !allowSelectionOnly) {
          return;
        }

        var hist = doc.history,
            event,
            selAfter = doc.sel;
        var source = type == "undo" ? hist.done : hist.undone,
            dest = type == "undo" ? hist.undone : hist.done; // Verify that there is a useable event (so that ctrl-z won't
        // needlessly clear selection events)

        var i = 0;

        for (; i < source.length; i++) {
          event = source[i];

          if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges) {
            break;
          }
        }

        if (i == source.length) {
          return;
        }

        hist.lastOrigin = hist.lastSelOrigin = null;

        for (;;) {
          event = source.pop();

          if (event.ranges) {
            pushSelectionToHistory(event, dest);

            if (allowSelectionOnly && !event.equals(doc.sel)) {
              setSelection(doc, event, {
                clearRedo: false
              });
              return;
            }

            selAfter = event;
          } else if (suppress) {
            source.push(event);
            return;
          } else {
            break;
          }
        } // Build up a reverse change object to add to the opposite history
        // stack (redo when undoing, and vice versa).


        var antiChanges = [];
        pushSelectionToHistory(selAfter, dest);
        dest.push({
          changes: antiChanges,
          generation: hist.generation
        });
        hist.generation = event.generation || ++hist.maxGeneration;
        var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");

        var loop = function loop(i) {
          var change = event.changes[i];
          change.origin = type;

          if (filter && !filterChange(doc, change, false)) {
            source.length = 0;
            return {};
          }

          antiChanges.push(historyChangeFromChange(doc, change));
          var after = i ? computeSelAfterChange(doc, change) : lst(source);
          makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));

          if (!i && doc.cm) {
            doc.cm.scrollIntoView({
              from: change.from,
              to: changeEnd(change)
            });
          }

          var rebased = []; // Propagate to the linked documents

          linkedDocs(doc, function (doc, sharedHist) {
            if (!sharedHist && indexOf(rebased, doc.history) == -1) {
              rebaseHist(doc.history, change);
              rebased.push(doc.history);
            }

            makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
          });
        };

        for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {
          var returned = loop(i$1);
          if (returned) return returned.v;
        }
      } // Sub-views need their line numbers shifted when text is added
      // above or below them in the parent document.


      function shiftDoc(doc, distance) {
        if (distance == 0) {
          return;
        }

        doc.first += distance;
        doc.sel = new Selection(map(doc.sel.ranges, function (range) {
          return new Range(Pos(range.anchor.line + distance, range.anchor.ch), Pos(range.head.line + distance, range.head.ch));
        }), doc.sel.primIndex);

        if (doc.cm) {
          regChange(doc.cm, doc.first, doc.first - distance, distance);

          for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++) {
            regLineChange(doc.cm, l, "gutter");
          }
        }
      } // More lower-level change function, handling only a single document
      // (not linked ones).


      function makeChangeSingleDoc(doc, change, selAfter, spans) {
        if (doc.cm && !doc.cm.curOp) {
          return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);
        }

        if (change.to.line < doc.first) {
          shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
          return;
        }

        if (change.from.line > doc.lastLine()) {
          return;
        } // Clip the change to the size of this doc


        if (change.from.line < doc.first) {
          var shift = change.text.length - 1 - (doc.first - change.from.line);
          shiftDoc(doc, shift);
          change = {
            from: Pos(doc.first, 0),
            to: Pos(change.to.line + shift, change.to.ch),
            text: [lst(change.text)],
            origin: change.origin
          };
        }

        var last = doc.lastLine();

        if (change.to.line > last) {
          change = {
            from: change.from,
            to: Pos(last, getLine(doc, last).text.length),
            text: [change.text[0]],
            origin: change.origin
          };
        }

        change.removed = getBetween(doc, change.from, change.to);

        if (!selAfter) {
          selAfter = computeSelAfterChange(doc, change);
        }

        if (doc.cm) {
          makeChangeSingleDocInEditor(doc.cm, change, spans);
        } else {
          updateDoc(doc, change, spans);
        }

        setSelectionNoUndo(doc, selAfter, sel_dontScroll);

        if (doc.cantEdit && skipAtomic(doc, Pos(doc.firstLine(), 0))) {
          doc.cantEdit = false;
        }
      } // Handle the interaction of a change to a document with the editor
      // that this document is part of.


      function makeChangeSingleDocInEditor(cm, change, spans) {
        var doc = cm.doc,
            display = cm.display,
            from = change.from,
            to = change.to;
        var recomputeMaxLength = false,
            checkWidthStart = from.line;

        if (!cm.options.lineWrapping) {
          checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
          doc.iter(checkWidthStart, to.line + 1, function (line) {
            if (line == display.maxLine) {
              recomputeMaxLength = true;
              return true;
            }
          });
        }

        if (doc.sel.contains(change.from, change.to) > -1) {
          signalCursorActivity(cm);
        }

        updateDoc(doc, change, spans, estimateHeight(cm));

        if (!cm.options.lineWrapping) {
          doc.iter(checkWidthStart, from.line + change.text.length, function (line) {
            var len = lineLength(line);

            if (len > display.maxLineLength) {
              display.maxLine = line;
              display.maxLineLength = len;
              display.maxLineChanged = true;
              recomputeMaxLength = false;
            }
          });

          if (recomputeMaxLength) {
            cm.curOp.updateMaxLine = true;
          }
        }

        retreatFrontier(doc, from.line);
        startWorker(cm, 400);
        var lendiff = change.text.length - (to.line - from.line) - 1; // Remember that these lines changed, for updating the display

        if (change.full) {
          regChange(cm);
        } else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change)) {
          regLineChange(cm, from.line, "text");
        } else {
          regChange(cm, from.line, to.line + 1, lendiff);
        }

        var changesHandler = hasHandler(cm, "changes"),
            changeHandler = hasHandler(cm, "change");

        if (changeHandler || changesHandler) {
          var obj = {
            from: from,
            to: to,
            text: change.text,
            removed: change.removed,
            origin: change.origin
          };

          if (changeHandler) {
            signalLater(cm, "change", cm, obj);
          }

          if (changesHandler) {
            (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);
          }
        }

        cm.display.selForContextMenu = null;
      }

      function _replaceRange(doc, code, from, to, origin) {
        var assign;

        if (!to) {
          to = from;
        }

        if (cmp(to, from) < 0) {
          assign = [to, from], from = assign[0], to = assign[1];
        }

        if (typeof code == "string") {
          code = doc.splitLines(code);
        }

        makeChange(doc, {
          from: from,
          to: to,
          text: code,
          origin: origin
        });
      } // Rebasing/resetting history to deal with externally-sourced changes


      function rebaseHistSelSingle(pos, from, to, diff) {
        if (to < pos.line) {
          pos.line += diff;
        } else if (from < pos.line) {
          pos.line = from;
          pos.ch = 0;
        }
      } // Tries to rebase an array of history events given a change in the
      // document. If the change touches the same lines as the event, the
      // event, and everything 'behind' it, is discarded. If the change is
      // before the event, the event's positions are updated. Uses a
      // copy-on-write scheme for the positions, to avoid having to
      // reallocate them all on every rebase, but also avoid problems with
      // shared position objects being unsafely updated.


      function rebaseHistArray(array, from, to, diff) {
        for (var i = 0; i < array.length; ++i) {
          var sub = array[i],
              ok = true;

          if (sub.ranges) {
            if (!sub.copied) {
              sub = array[i] = sub.deepCopy();
              sub.copied = true;
            }

            for (var j = 0; j < sub.ranges.length; j++) {
              rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
              rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
            }

            continue;
          }

          for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {
            var cur = sub.changes[j$1];

            if (to < cur.from.line) {
              cur.from = Pos(cur.from.line + diff, cur.from.ch);
              cur.to = Pos(cur.to.line + diff, cur.to.ch);
            } else if (from <= cur.to.line) {
              ok = false;
              break;
            }
          }

          if (!ok) {
            array.splice(0, i + 1);
            i = 0;
          }
        }
      }

      function rebaseHist(hist, change) {
        var from = change.from.line,
            to = change.to.line,
            diff = change.text.length - (to - from) - 1;
        rebaseHistArray(hist.done, from, to, diff);
        rebaseHistArray(hist.undone, from, to, diff);
      } // Utility for applying a change to a line by handle or number,
      // returning the number and optionally registering the line as
      // changed.


      function changeLine(doc, handle, changeType, op) {
        var no = handle,
            line = handle;

        if (typeof handle == "number") {
          line = getLine(doc, clipLine(doc, handle));
        } else {
          no = lineNo(handle);
        }

        if (no == null) {
          return null;
        }

        if (op(line, no) && doc.cm) {
          regLineChange(doc.cm, no, changeType);
        }

        return line;
      } // The document is represented as a BTree consisting of leaves, with
      // chunk of lines in them, and branches, with up to ten leaves or
      // other branch nodes below them. The top node is always a branch
      // node, and is the document object itself (meaning it has
      // additional methods and properties).
      //
      // All nodes have parent links. The tree is used both to go from
      // line numbers to line objects, and to go from objects to numbers.
      // It also indexes by height, and is used to convert between height
      // and line object, and to find the total height of the document.
      //
      // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html


      function LeafChunk(lines) {
        this.lines = lines;
        this.parent = null;
        var height = 0;

        for (var i = 0; i < lines.length; ++i) {
          lines[i].parent = this;
          height += lines[i].height;
        }

        this.height = height;
      }

      LeafChunk.prototype = {
        chunkSize: function chunkSize() {
          return this.lines.length;
        },
        // Remove the n lines at offset 'at'.
        removeInner: function removeInner(at, n) {
          for (var i = at, e = at + n; i < e; ++i) {
            var line = this.lines[i];
            this.height -= line.height;
            cleanUpLine(line);
            signalLater(line, "delete");
          }

          this.lines.splice(at, n);
        },
        // Helper used to collapse a small branch into a single leaf.
        collapse: function collapse(lines) {
          lines.push.apply(lines, this.lines);
        },
        // Insert the given array of lines at offset 'at', count them as
        // having the given height.
        insertInner: function insertInner(at, lines, height) {
          this.height += height;
          this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));

          for (var i = 0; i < lines.length; ++i) {
            lines[i].parent = this;
          }
        },
        // Used to iterate over a part of the tree.
        iterN: function iterN(at, n, op) {
          for (var e = at + n; at < e; ++at) {
            if (op(this.lines[at])) {
              return true;
            }
          }
        }
      };

      function BranchChunk(children) {
        this.children = children;
        var size = 0,
            height = 0;

        for (var i = 0; i < children.length; ++i) {
          var ch = children[i];
          size += ch.chunkSize();
          height += ch.height;
          ch.parent = this;
        }

        this.size = size;
        this.height = height;
        this.parent = null;
      }

      BranchChunk.prototype = {
        chunkSize: function chunkSize() {
          return this.size;
        },
        removeInner: function removeInner(at, n) {
          this.size -= n;

          for (var i = 0; i < this.children.length; ++i) {
            var child = this.children[i],
                sz = child.chunkSize();

            if (at < sz) {
              var rm = Math.min(n, sz - at),
                  oldHeight = child.height;
              child.removeInner(at, rm);
              this.height -= oldHeight - child.height;

              if (sz == rm) {
                this.children.splice(i--, 1);
                child.parent = null;
              }

              if ((n -= rm) == 0) {
                break;
              }

              at = 0;
            } else {
              at -= sz;
            }
          } // If the result is smaller than 25 lines, ensure that it is a
          // single leaf node.


          if (this.size - n < 25 && (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
            var lines = [];
            this.collapse(lines);
            this.children = [new LeafChunk(lines)];
            this.children[0].parent = this;
          }
        },
        collapse: function collapse(lines) {
          for (var i = 0; i < this.children.length; ++i) {
            this.children[i].collapse(lines);
          }
        },
        insertInner: function insertInner(at, lines, height) {
          this.size += lines.length;
          this.height += height;

          for (var i = 0; i < this.children.length; ++i) {
            var child = this.children[i],
                sz = child.chunkSize();

            if (at <= sz) {
              child.insertInner(at, lines, height);

              if (child.lines && child.lines.length > 50) {
                // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.
                // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.
                var remaining = child.lines.length % 25 + 25;

                for (var pos = remaining; pos < child.lines.length;) {
                  var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
                  child.height -= leaf.height;
                  this.children.splice(++i, 0, leaf);
                  leaf.parent = this;
                }

                child.lines = child.lines.slice(0, remaining);
                this.maybeSpill();
              }

              break;
            }

            at -= sz;
          }
        },
        // When a node has grown, check whether it should be split.
        maybeSpill: function maybeSpill() {
          if (this.children.length <= 10) {
            return;
          }

          var me = this;

          do {
            var spilled = me.children.splice(me.children.length - 5, 5);
            var sibling = new BranchChunk(spilled);

            if (!me.parent) {
              // Become the parent node
              var copy = new BranchChunk(me.children);
              copy.parent = me;
              me.children = [copy, sibling];
              me = copy;
            } else {
              me.size -= sibling.size;
              me.height -= sibling.height;
              var myIndex = indexOf(me.parent.children, me);
              me.parent.children.splice(myIndex + 1, 0, sibling);
            }

            sibling.parent = me.parent;
          } while (me.children.length > 10);

          me.parent.maybeSpill();
        },
        iterN: function iterN(at, n, op) {
          for (var i = 0; i < this.children.length; ++i) {
            var child = this.children[i],
                sz = child.chunkSize();

            if (at < sz) {
              var used = Math.min(n, sz - at);

              if (child.iterN(at, used, op)) {
                return true;
              }

              if ((n -= used) == 0) {
                break;
              }

              at = 0;
            } else {
              at -= sz;
            }
          }
        }
      }; // Line widgets are block elements displayed above or below a line.

      var LineWidget = function LineWidget(doc, node, options) {
        if (options) {
          for (var opt in options) {
            if (options.hasOwnProperty(opt)) {
              this[opt] = options[opt];
            }
          }
        }

        this.doc = doc;
        this.node = node;
      };

      LineWidget.prototype.clear = function () {
        var cm = this.doc.cm,
            ws = this.line.widgets,
            line = this.line,
            no = lineNo(line);

        if (no == null || !ws) {
          return;
        }

        for (var i = 0; i < ws.length; ++i) {
          if (ws[i] == this) {
            ws.splice(i--, 1);
          }
        }

        if (!ws.length) {
          line.widgets = null;
        }

        var height = widgetHeight(this);
        updateLineHeight(line, Math.max(0, line.height - height));

        if (cm) {
          runInOp(cm, function () {
            adjustScrollWhenAboveVisible(cm, line, -height);
            regLineChange(cm, no, "widget");
          });
          signalLater(cm, "lineWidgetCleared", cm, this, no);
        }
      };

      LineWidget.prototype.changed = function () {
        var this$1 = this;
        var oldH = this.height,
            cm = this.doc.cm,
            line = this.line;
        this.height = null;
        var diff = widgetHeight(this) - oldH;

        if (!diff) {
          return;
        }

        if (!lineIsHidden(this.doc, line)) {
          updateLineHeight(line, line.height + diff);
        }

        if (cm) {
          runInOp(cm, function () {
            cm.curOp.forceUpdate = true;
            adjustScrollWhenAboveVisible(cm, line, diff);
            signalLater(cm, "lineWidgetChanged", cm, this$1, lineNo(line));
          });
        }
      };

      eventMixin(LineWidget);

      function adjustScrollWhenAboveVisible(cm, line, diff) {
        if (_heightAtLine(line) < (cm.curOp && cm.curOp.scrollTop || cm.doc.scrollTop)) {
          addToScrollTop(cm, diff);
        }
      }

      function addLineWidget(doc, handle, node, options) {
        var widget = new LineWidget(doc, node, options);
        var cm = doc.cm;

        if (cm && widget.noHScroll) {
          cm.display.alignWidgets = true;
        }

        changeLine(doc, handle, "widget", function (line) {
          var widgets = line.widgets || (line.widgets = []);

          if (widget.insertAt == null) {
            widgets.push(widget);
          } else {
            widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);
          }

          widget.line = line;

          if (cm && !lineIsHidden(doc, line)) {
            var aboveVisible = _heightAtLine(line) < doc.scrollTop;
            updateLineHeight(line, line.height + widgetHeight(widget));

            if (aboveVisible) {
              addToScrollTop(cm, widget.height);
            }

            cm.curOp.forceUpdate = true;
          }

          return true;
        });

        if (cm) {
          signalLater(cm, "lineWidgetAdded", cm, widget, typeof handle == "number" ? handle : lineNo(handle));
        }

        return widget;
      } // TEXTMARKERS
      // Created with markText and setBookmark methods. A TextMarker is a
      // handle that can be used to clear or find a marked position in the
      // document. Line objects hold arrays (markedSpans) containing
      // {from, to, marker} object pointing to such marker objects, and
      // indicating that such a marker is present on that line. Multiple
      // lines may point to the same marker when it spans across lines.
      // The spans will have null for their from/to properties when the
      // marker continues beyond the start/end of the line. Markers have
      // links back to the lines they currently touch.
      // Collapsed markers have unique ids, in order to be able to order
      // them, which is needed for uniquely determining an outer marker
      // when they overlap (they may nest, but not partially overlap).


      var nextMarkerId = 0;

      var TextMarker = function TextMarker(doc, type) {
        this.lines = [];
        this.type = type;
        this.doc = doc;
        this.id = ++nextMarkerId;
      }; // Clear the marker.


      TextMarker.prototype.clear = function () {
        if (this.explicitlyCleared) {
          return;
        }

        var cm = this.doc.cm,
            withOp = cm && !cm.curOp;

        if (withOp) {
          _startOperation(cm);
        }

        if (hasHandler(this, "clear")) {
          var found = this.find();

          if (found) {
            signalLater(this, "clear", found.from, found.to);
          }
        }

        var min = null,
            max = null;

        for (var i = 0; i < this.lines.length; ++i) {
          var line = this.lines[i];
          var span = getMarkedSpanFor(line.markedSpans, this);

          if (cm && !this.collapsed) {
            regLineChange(cm, lineNo(line), "text");
          } else if (cm) {
            if (span.to != null) {
              max = lineNo(line);
            }

            if (span.from != null) {
              min = lineNo(line);
            }
          }

          line.markedSpans = removeMarkedSpan(line.markedSpans, span);

          if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm) {
            updateLineHeight(line, textHeight(cm.display));
          }
        }

        if (cm && this.collapsed && !cm.options.lineWrapping) {
          for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {
            var visual = visualLine(this.lines[i$1]),
                len = lineLength(visual);

            if (len > cm.display.maxLineLength) {
              cm.display.maxLine = visual;
              cm.display.maxLineLength = len;
              cm.display.maxLineChanged = true;
            }
          }
        }

        if (min != null && cm && this.collapsed) {
          regChange(cm, min, max + 1);
        }

        this.lines.length = 0;
        this.explicitlyCleared = true;

        if (this.atomic && this.doc.cantEdit) {
          this.doc.cantEdit = false;

          if (cm) {
            reCheckSelection(cm.doc);
          }
        }

        if (cm) {
          signalLater(cm, "markerCleared", cm, this, min, max);
        }

        if (withOp) {
          _endOperation(cm);
        }

        if (this.parent) {
          this.parent.clear();
        }
      }; // Find the position of the marker in the document. Returns a {from,
      // to} object by default. Side can be passed to get a specific side
      // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the
      // Pos objects returned contain a line object, rather than a line
      // number (used to prevent looking up the same line twice).


      TextMarker.prototype.find = function (side, lineObj) {
        if (side == null && this.type == "bookmark") {
          side = 1;
        }

        var from, to;

        for (var i = 0; i < this.lines.length; ++i) {
          var line = this.lines[i];
          var span = getMarkedSpanFor(line.markedSpans, this);

          if (span.from != null) {
            from = Pos(lineObj ? line : lineNo(line), span.from);

            if (side == -1) {
              return from;
            }
          }

          if (span.to != null) {
            to = Pos(lineObj ? line : lineNo(line), span.to);

            if (side == 1) {
              return to;
            }
          }
        }

        return from && {
          from: from,
          to: to
        };
      }; // Signals that the marker's widget changed, and surrounding layout
      // should be recomputed.


      TextMarker.prototype.changed = function () {
        var this$1 = this;
        var pos = this.find(-1, true),
            widget = this,
            cm = this.doc.cm;

        if (!pos || !cm) {
          return;
        }

        runInOp(cm, function () {
          var line = pos.line,
              lineN = lineNo(pos.line);
          var view = findViewForLine(cm, lineN);

          if (view) {
            clearLineMeasurementCacheFor(view);
            cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
          }

          cm.curOp.updateMaxLine = true;

          if (!lineIsHidden(widget.doc, line) && widget.height != null) {
            var oldHeight = widget.height;
            widget.height = null;
            var dHeight = widgetHeight(widget) - oldHeight;

            if (dHeight) {
              updateLineHeight(line, line.height + dHeight);
            }
          }

          signalLater(cm, "markerChanged", cm, this$1);
        });
      };

      TextMarker.prototype.attachLine = function (line) {
        if (!this.lines.length && this.doc.cm) {
          var op = this.doc.cm.curOp;

          if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1) {
            (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
          }
        }

        this.lines.push(line);
      };

      TextMarker.prototype.detachLine = function (line) {
        this.lines.splice(indexOf(this.lines, line), 1);

        if (!this.lines.length && this.doc.cm) {
          var op = this.doc.cm.curOp;
          (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
        }
      };

      eventMixin(TextMarker); // Create a marker, wire it up to the right lines, and

      function _markText(doc, from, to, options, type) {
        // Shared markers (across linked documents) are handled separately
        // (markTextShared will call out to this again, once per
        // document).
        if (options && options.shared) {
          return markTextShared(doc, from, to, options, type);
        } // Ensure we are in an operation.


        if (doc.cm && !doc.cm.curOp) {
          return operation(doc.cm, _markText)(doc, from, to, options, type);
        }

        var marker = new TextMarker(doc, type),
            diff = cmp(from, to);

        if (options) {
          copyObj(options, marker, false);
        } // Don't connect empty markers unless clearWhenEmpty is false


        if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false) {
          return marker;
        }

        if (marker.replacedWith) {
          // Showing up as a widget implies collapsed (widget replaces text)
          marker.collapsed = true;
          marker.widgetNode = eltP("span", [marker.replacedWith], "CodeMirror-widget");

          if (!options.handleMouseEvents) {
            marker.widgetNode.setAttribute("cm-ignore-events", "true");
          }

          if (options.insertLeft) {
            marker.widgetNode.insertLeft = true;
          }
        }

        if (marker.collapsed) {
          if (conflictingCollapsedRange(doc, from.line, from, to, marker) || from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker)) {
            throw new Error("Inserting collapsed marker partially overlapping an existing one");
          }

          seeCollapsedSpans();
        }

        if (marker.addToHistory) {
          addChangeToHistory(doc, {
            from: from,
            to: to,
            origin: "markText"
          }, doc.sel, NaN);
        }

        var curLine = from.line,
            cm = doc.cm,
            updateMaxLine;
        doc.iter(curLine, to.line + 1, function (line) {
          if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine) {
            updateMaxLine = true;
          }

          if (marker.collapsed && curLine != from.line) {
            updateLineHeight(line, 0);
          }

          addMarkedSpan(line, new MarkedSpan(marker, curLine == from.line ? from.ch : null, curLine == to.line ? to.ch : null));
          ++curLine;
        }); // lineIsHidden depends on the presence of the spans, so needs a second pass

        if (marker.collapsed) {
          doc.iter(from.line, to.line + 1, function (line) {
            if (lineIsHidden(doc, line)) {
              updateLineHeight(line, 0);
            }
          });
        }

        if (marker.clearOnEnter) {
          on(marker, "beforeCursorEnter", function () {
            return marker.clear();
          });
        }

        if (marker.readOnly) {
          seeReadOnlySpans();

          if (doc.history.done.length || doc.history.undone.length) {
            doc.clearHistory();
          }
        }

        if (marker.collapsed) {
          marker.id = ++nextMarkerId;
          marker.atomic = true;
        }

        if (cm) {
          // Sync editor state
          if (updateMaxLine) {
            cm.curOp.updateMaxLine = true;
          }

          if (marker.collapsed) {
            regChange(cm, from.line, to.line + 1);
          } else if (marker.className || marker.startStyle || marker.endStyle || marker.css || marker.attributes || marker.title) {
            for (var i = from.line; i <= to.line; i++) {
              regLineChange(cm, i, "text");
            }
          }

          if (marker.atomic) {
            reCheckSelection(cm.doc);
          }

          signalLater(cm, "markerAdded", cm, marker);
        }

        return marker;
      } // SHARED TEXTMARKERS
      // A shared marker spans multiple linked documents. It is
      // implemented as a meta-marker-object controlling multiple normal
      // markers.


      var SharedTextMarker = function SharedTextMarker(markers, primary) {
        this.markers = markers;
        this.primary = primary;

        for (var i = 0; i < markers.length; ++i) {
          markers[i].parent = this;
        }
      };

      SharedTextMarker.prototype.clear = function () {
        if (this.explicitlyCleared) {
          return;
        }

        this.explicitlyCleared = true;

        for (var i = 0; i < this.markers.length; ++i) {
          this.markers[i].clear();
        }

        signalLater(this, "clear");
      };

      SharedTextMarker.prototype.find = function (side, lineObj) {
        return this.primary.find(side, lineObj);
      };

      eventMixin(SharedTextMarker);

      function markTextShared(doc, from, to, options, type) {
        options = copyObj(options);
        options.shared = false;
        var markers = [_markText(doc, from, to, options, type)],
            primary = markers[0];
        var widget = options.widgetNode;
        linkedDocs(doc, function (doc) {
          if (widget) {
            options.widgetNode = widget.cloneNode(true);
          }

          markers.push(_markText(doc, _clipPos(doc, from), _clipPos(doc, to), options, type));

          for (var i = 0; i < doc.linked.length; ++i) {
            if (doc.linked[i].isParent) {
              return;
            }
          }

          primary = lst(markers);
        });
        return new SharedTextMarker(markers, primary);
      }

      function findSharedMarkers(doc) {
        return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) {
          return m.parent;
        });
      }

      function copySharedMarkers(doc, markers) {
        for (var i = 0; i < markers.length; i++) {
          var marker = markers[i],
              pos = marker.find();
          var mFrom = doc.clipPos(pos.from),
              mTo = doc.clipPos(pos.to);

          if (cmp(mFrom, mTo)) {
            var subMark = _markText(doc, mFrom, mTo, marker.primary, marker.primary.type);

            marker.markers.push(subMark);
            subMark.parent = marker;
          }
        }
      }

      function detachSharedMarkers(markers) {
        var loop = function loop(i) {
          var marker = markers[i],
              linked = [marker.primary.doc];
          linkedDocs(marker.primary.doc, function (d) {
            return linked.push(d);
          });

          for (var j = 0; j < marker.markers.length; j++) {
            var subMarker = marker.markers[j];

            if (indexOf(linked, subMarker.doc) == -1) {
              subMarker.parent = null;
              marker.markers.splice(j--, 1);
            }
          }
        };

        for (var i = 0; i < markers.length; i++) {
          loop(i);
        }
      }

      var nextDocId = 0;

      var Doc = function Doc(text, mode, firstLine, lineSep, direction) {
        if (!(this instanceof Doc)) {
          return new Doc(text, mode, firstLine, lineSep, direction);
        }

        if (firstLine == null) {
          firstLine = 0;
        }

        BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
        this.first = firstLine;
        this.scrollTop = this.scrollLeft = 0;
        this.cantEdit = false;
        this.cleanGeneration = 1;
        this.modeFrontier = this.highlightFrontier = firstLine;
        var start = Pos(firstLine, 0);
        this.sel = simpleSelection(start);
        this.history = new History(null);
        this.id = ++nextDocId;
        this.modeOption = mode;
        this.lineSep = lineSep;
        this.direction = direction == "rtl" ? "rtl" : "ltr";
        this.extend = false;

        if (typeof text == "string") {
          text = this.splitLines(text);
        }

        updateDoc(this, {
          from: start,
          to: start,
          text: text
        });
        setSelection(this, simpleSelection(start), sel_dontScroll);
      };

      Doc.prototype = createObj(BranchChunk.prototype, {
        constructor: Doc,
        // Iterate over the document. Supports two forms -- with only one
        // argument, it calls that for each line in the document. With
        // three, it iterates over the range given by the first two (with
        // the second being non-inclusive).
        iter: function iter(from, to, op) {
          if (op) {
            this.iterN(from - this.first, to - from, op);
          } else {
            this.iterN(this.first, this.first + this.size, from);
          }
        },
        // Non-public interface for adding and removing lines.
        insert: function insert(at, lines) {
          var height = 0;

          for (var i = 0; i < lines.length; ++i) {
            height += lines[i].height;
          }

          this.insertInner(at - this.first, lines, height);
        },
        remove: function remove(at, n) {
          this.removeInner(at - this.first, n);
        },
        // From here, the methods are part of the public interface. Most
        // are also available from CodeMirror (editor) instances.
        getValue: function getValue(lineSep) {
          var lines = getLines(this, this.first, this.first + this.size);

          if (lineSep === false) {
            return lines;
          }

          return lines.join(lineSep || this.lineSeparator());
        },
        setValue: docMethodOp(function (code) {
          var top = Pos(this.first, 0),
              last = this.first + this.size - 1;
          makeChange(this, {
            from: top,
            to: Pos(last, getLine(this, last).text.length),
            text: this.splitLines(code),
            origin: "setValue",
            full: true
          }, true);

          if (this.cm) {
            scrollToCoords(this.cm, 0, 0);
          }

          setSelection(this, simpleSelection(top), sel_dontScroll);
        }),
        replaceRange: function replaceRange(code, from, to, origin) {
          from = _clipPos(this, from);
          to = to ? _clipPos(this, to) : from;

          _replaceRange(this, code, from, to, origin);
        },
        getRange: function getRange(from, to, lineSep) {
          var lines = getBetween(this, _clipPos(this, from), _clipPos(this, to));

          if (lineSep === false) {
            return lines;
          }

          return lines.join(lineSep || this.lineSeparator());
        },
        getLine: function getLine(line) {
          var l = this.getLineHandle(line);
          return l && l.text;
        },
        getLineHandle: function getLineHandle(line) {
          if (isLine(this, line)) {
            return getLine(this, line);
          }
        },
        getLineNumber: function getLineNumber(line) {
          return lineNo(line);
        },
        getLineHandleVisualStart: function getLineHandleVisualStart(line) {
          if (typeof line == "number") {
            line = getLine(this, line);
          }

          return visualLine(line);
        },
        lineCount: function lineCount() {
          return this.size;
        },
        firstLine: function firstLine() {
          return this.first;
        },
        lastLine: function lastLine() {
          return this.first + this.size - 1;
        },
        clipPos: function clipPos(pos) {
          return _clipPos(this, pos);
        },
        getCursor: function getCursor(start) {
          var range = this.sel.primary(),
              pos;

          if (start == null || start == "head") {
            pos = range.head;
          } else if (start == "anchor") {
            pos = range.anchor;
          } else if (start == "end" || start == "to" || start === false) {
            pos = range.to();
          } else {
            pos = range.from();
          }

          return pos;
        },
        listSelections: function listSelections() {
          return this.sel.ranges;
        },
        somethingSelected: function somethingSelected() {
          return this.sel.somethingSelected();
        },
        setCursor: docMethodOp(function (line, ch, options) {
          setSimpleSelection(this, _clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
        }),
        setSelection: docMethodOp(function (anchor, head, options) {
          setSimpleSelection(this, _clipPos(this, anchor), _clipPos(this, head || anchor), options);
        }),
        extendSelection: docMethodOp(function (head, other, options) {
          extendSelection(this, _clipPos(this, head), other && _clipPos(this, other), options);
        }),
        extendSelections: docMethodOp(function (heads, options) {
          extendSelections(this, clipPosArray(this, heads), options);
        }),
        extendSelectionsBy: docMethodOp(function (f, options) {
          var heads = map(this.sel.ranges, f);
          extendSelections(this, clipPosArray(this, heads), options);
        }),
        setSelections: docMethodOp(function (ranges, primary, options) {
          if (!ranges.length) {
            return;
          }

          var out = [];

          for (var i = 0; i < ranges.length; i++) {
            out[i] = new Range(_clipPos(this, ranges[i].anchor), _clipPos(this, ranges[i].head));
          }

          if (primary == null) {
            primary = Math.min(ranges.length - 1, this.sel.primIndex);
          }

          setSelection(this, normalizeSelection(this.cm, out, primary), options);
        }),
        addSelection: docMethodOp(function (anchor, head, options) {
          var ranges = this.sel.ranges.slice(0);
          ranges.push(new Range(_clipPos(this, anchor), _clipPos(this, head || anchor)));
          setSelection(this, normalizeSelection(this.cm, ranges, ranges.length - 1), options);
        }),
        getSelection: function getSelection(lineSep) {
          var ranges = this.sel.ranges,
              lines;

          for (var i = 0; i < ranges.length; i++) {
            var sel = getBetween(this, ranges[i].from(), ranges[i].to());
            lines = lines ? lines.concat(sel) : sel;
          }

          if (lineSep === false) {
            return lines;
          } else {
            return lines.join(lineSep || this.lineSeparator());
          }
        },
        getSelections: function getSelections(lineSep) {
          var parts = [],
              ranges = this.sel.ranges;

          for (var i = 0; i < ranges.length; i++) {
            var sel = getBetween(this, ranges[i].from(), ranges[i].to());

            if (lineSep !== false) {
              sel = sel.join(lineSep || this.lineSeparator());
            }

            parts[i] = sel;
          }

          return parts;
        },
        replaceSelection: function replaceSelection(code, collapse, origin) {
          var dup = [];

          for (var i = 0; i < this.sel.ranges.length; i++) {
            dup[i] = code;
          }

          this.replaceSelections(dup, collapse, origin || "+input");
        },
        replaceSelections: docMethodOp(function (code, collapse, origin) {
          var changes = [],
              sel = this.sel;

          for (var i = 0; i < sel.ranges.length; i++) {
            var range = sel.ranges[i];
            changes[i] = {
              from: range.from(),
              to: range.to(),
              text: this.splitLines(code[i]),
              origin: origin
            };
          }

          var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);

          for (var i$1 = changes.length - 1; i$1 >= 0; i$1--) {
            makeChange(this, changes[i$1]);
          }

          if (newSel) {
            setSelectionReplaceHistory(this, newSel);
          } else if (this.cm) {
            ensureCursorVisible(this.cm);
          }
        }),
        undo: docMethodOp(function () {
          makeChangeFromHistory(this, "undo");
        }),
        redo: docMethodOp(function () {
          makeChangeFromHistory(this, "redo");
        }),
        undoSelection: docMethodOp(function () {
          makeChangeFromHistory(this, "undo", true);
        }),
        redoSelection: docMethodOp(function () {
          makeChangeFromHistory(this, "redo", true);
        }),
        setExtending: function setExtending(val) {
          this.extend = val;
        },
        getExtending: function getExtending() {
          return this.extend;
        },
        historySize: function historySize() {
          var hist = this.history,
              done = 0,
              undone = 0;

          for (var i = 0; i < hist.done.length; i++) {
            if (!hist.done[i].ranges) {
              ++done;
            }
          }

          for (var i$1 = 0; i$1 < hist.undone.length; i$1++) {
            if (!hist.undone[i$1].ranges) {
              ++undone;
            }
          }

          return {
            undo: done,
            redo: undone
          };
        },
        clearHistory: function clearHistory() {
          var this$1 = this;
          this.history = new History(this.history.maxGeneration);
          linkedDocs(this, function (doc) {
            return doc.history = this$1.history;
          }, true);
        },
        markClean: function markClean() {
          this.cleanGeneration = this.changeGeneration(true);
        },
        changeGeneration: function changeGeneration(forceSplit) {
          if (forceSplit) {
            this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;
          }

          return this.history.generation;
        },
        isClean: function isClean(gen) {
          return this.history.generation == (gen || this.cleanGeneration);
        },
        getHistory: function getHistory() {
          return {
            done: copyHistoryArray(this.history.done),
            undone: copyHistoryArray(this.history.undone)
          };
        },
        setHistory: function setHistory(histData) {
          var hist = this.history = new History(this.history.maxGeneration);
          hist.done = copyHistoryArray(histData.done.slice(0), null, true);
          hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
        },
        setGutterMarker: docMethodOp(function (line, gutterID, value) {
          return changeLine(this, line, "gutter", function (line) {
            var markers = line.gutterMarkers || (line.gutterMarkers = {});
            markers[gutterID] = value;

            if (!value && isEmpty(markers)) {
              line.gutterMarkers = null;
            }

            return true;
          });
        }),
        clearGutter: docMethodOp(function (gutterID) {
          var this$1 = this;
          this.iter(function (line) {
            if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
              changeLine(this$1, line, "gutter", function () {
                line.gutterMarkers[gutterID] = null;

                if (isEmpty(line.gutterMarkers)) {
                  line.gutterMarkers = null;
                }

                return true;
              });
            }
          });
        }),
        lineInfo: function lineInfo(line) {
          var n;

          if (typeof line == "number") {
            if (!isLine(this, line)) {
              return null;
            }

            n = line;
            line = getLine(this, line);

            if (!line) {
              return null;
            }
          } else {
            n = lineNo(line);

            if (n == null) {
              return null;
            }
          }

          return {
            line: n,
            handle: line,
            text: line.text,
            gutterMarkers: line.gutterMarkers,
            textClass: line.textClass,
            bgClass: line.bgClass,
            wrapClass: line.wrapClass,
            widgets: line.widgets
          };
        },
        addLineClass: docMethodOp(function (handle, where, cls) {
          return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
            var prop = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";

            if (!line[prop]) {
              line[prop] = cls;
            } else if (classTest(cls).test(line[prop])) {
              return false;
            } else {
              line[prop] += " " + cls;
            }

            return true;
          });
        }),
        removeLineClass: docMethodOp(function (handle, where, cls) {
          return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
            var prop = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";
            var cur = line[prop];

            if (!cur) {
              return false;
            } else if (cls == null) {
              line[prop] = null;
            } else {
              var found = cur.match(classTest(cls));

              if (!found) {
                return false;
              }

              var end = found.index + found[0].length;
              line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
            }

            return true;
          });
        }),
        addLineWidget: docMethodOp(function (handle, node, options) {
          return addLineWidget(this, handle, node, options);
        }),
        removeLineWidget: function removeLineWidget(widget) {
          widget.clear();
        },
        markText: function markText(from, to, options) {
          return _markText(this, _clipPos(this, from), _clipPos(this, to), options, options && options.type || "range");
        },
        setBookmark: function setBookmark(pos, options) {
          var realOpts = {
            replacedWith: options && (options.nodeType == null ? options.widget : options),
            insertLeft: options && options.insertLeft,
            clearWhenEmpty: false,
            shared: options && options.shared,
            handleMouseEvents: options && options.handleMouseEvents
          };
          pos = _clipPos(this, pos);
          return _markText(this, pos, pos, realOpts, "bookmark");
        },
        findMarksAt: function findMarksAt(pos) {
          pos = _clipPos(this, pos);
          var markers = [],
              spans = getLine(this, pos.line).markedSpans;

          if (spans) {
            for (var i = 0; i < spans.length; ++i) {
              var span = spans[i];

              if ((span.from == null || span.from <= pos.ch) && (span.to == null || span.to >= pos.ch)) {
                markers.push(span.marker.parent || span.marker);
              }
            }
          }

          return markers;
        },
        findMarks: function findMarks(from, to, filter) {
          from = _clipPos(this, from);
          to = _clipPos(this, to);
          var found = [],
              lineNo = from.line;
          this.iter(from.line, to.line + 1, function (line) {
            var spans = line.markedSpans;

            if (spans) {
              for (var i = 0; i < spans.length; i++) {
                var span = spans[i];

                if (!(span.to != null && lineNo == from.line && from.ch >= span.to || span.from == null && lineNo != from.line || span.from != null && lineNo == to.line && span.from >= to.ch) && (!filter || filter(span.marker))) {
                  found.push(span.marker.parent || span.marker);
                }
              }
            }

            ++lineNo;
          });
          return found;
        },
        getAllMarks: function getAllMarks() {
          var markers = [];
          this.iter(function (line) {
            var sps = line.markedSpans;

            if (sps) {
              for (var i = 0; i < sps.length; ++i) {
                if (sps[i].from != null) {
                  markers.push(sps[i].marker);
                }
              }
            }
          });
          return markers;
        },
        posFromIndex: function posFromIndex(off) {
          var ch,
              lineNo = this.first,
              sepSize = this.lineSeparator().length;
          this.iter(function (line) {
            var sz = line.text.length + sepSize;

            if (sz > off) {
              ch = off;
              return true;
            }

            off -= sz;
            ++lineNo;
          });
          return _clipPos(this, Pos(lineNo, ch));
        },
        indexFromPos: function indexFromPos(coords) {
          coords = _clipPos(this, coords);
          var index = coords.ch;

          if (coords.line < this.first || coords.ch < 0) {
            return 0;
          }

          var sepSize = this.lineSeparator().length;
          this.iter(this.first, coords.line, function (line) {
            // iter aborts when callback returns a truthy value
            index += line.text.length + sepSize;
          });
          return index;
        },
        copy: function copy(copyHistory) {
          var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first, this.lineSep, this.direction);
          doc.scrollTop = this.scrollTop;
          doc.scrollLeft = this.scrollLeft;
          doc.sel = this.sel;
          doc.extend = false;

          if (copyHistory) {
            doc.history.undoDepth = this.history.undoDepth;
            doc.setHistory(this.getHistory());
          }

          return doc;
        },
        linkedDoc: function linkedDoc(options) {
          if (!options) {
            options = {};
          }

          var from = this.first,
              to = this.first + this.size;

          if (options.from != null && options.from > from) {
            from = options.from;
          }

          if (options.to != null && options.to < to) {
            to = options.to;
          }

          var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);

          if (options.sharedHist) {
            copy.history = this.history;
          }

          (this.linked || (this.linked = [])).push({
            doc: copy,
            sharedHist: options.sharedHist
          });
          copy.linked = [{
            doc: this,
            isParent: true,
            sharedHist: options.sharedHist
          }];
          copySharedMarkers(copy, findSharedMarkers(this));
          return copy;
        },
        unlinkDoc: function unlinkDoc(other) {
          if (other instanceof CodeMirror) {
            other = other.doc;
          }

          if (this.linked) {
            for (var i = 0; i < this.linked.length; ++i) {
              var link = this.linked[i];

              if (link.doc != other) {
                continue;
              }

              this.linked.splice(i, 1);
              other.unlinkDoc(this);
              detachSharedMarkers(findSharedMarkers(this));
              break;
            }
          } // If the histories were shared, split them again


          if (other.history == this.history) {
            var splitIds = [other.id];
            linkedDocs(other, function (doc) {
              return splitIds.push(doc.id);
            }, true);
            other.history = new History(null);
            other.history.done = copyHistoryArray(this.history.done, splitIds);
            other.history.undone = copyHistoryArray(this.history.undone, splitIds);
          }
        },
        iterLinkedDocs: function iterLinkedDocs(f) {
          linkedDocs(this, f);
        },
        getMode: function getMode() {
          return this.mode;
        },
        getEditor: function getEditor() {
          return this.cm;
        },
        splitLines: function splitLines(str) {
          if (this.lineSep) {
            return str.split(this.lineSep);
          }

          return splitLinesAuto(str);
        },
        lineSeparator: function lineSeparator() {
          return this.lineSep || "\n";
        },
        setDirection: docMethodOp(function (dir) {
          if (dir != "rtl") {
            dir = "ltr";
          }

          if (dir == this.direction) {
            return;
          }

          this.direction = dir;
          this.iter(function (line) {
            return line.order = null;
          });

          if (this.cm) {
            directionChanged(this.cm);
          }
        })
      }); // Public alias.

      Doc.prototype.eachLine = Doc.prototype.iter; // Kludge to work around strange IE behavior where it'll sometimes
      // re-fire a series of drag-related events right after the drop (#1551)

      var lastDrop = 0;

      function onDrop(e) {
        var cm = this;
        clearDragCursor(cm);

        if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) {
          return;
        }

        e_preventDefault(e);

        if (ie) {
          lastDrop = +new Date();
        }

        var pos = posFromMouse(cm, e, true),
            files = e.dataTransfer.files;

        if (!pos || cm.isReadOnly()) {
          return;
        } // Might be a file drop, in which case we simply extract the text
        // and insert it.


        if (files && files.length && window.FileReader && window.File) {
          var n = files.length,
              text = Array(n),
              read = 0;

          var markAsReadAndPasteIfAllFilesAreRead = function markAsReadAndPasteIfAllFilesAreRead() {
            if (++read == n) {
              operation(cm, function () {
                pos = _clipPos(cm.doc, pos);
                var change = {
                  from: pos,
                  to: pos,
                  text: cm.doc.splitLines(text.filter(function (t) {
                    return t != null;
                  }).join(cm.doc.lineSeparator())),
                  origin: "paste"
                };
                makeChange(cm.doc, change);
                setSelectionReplaceHistory(cm.doc, simpleSelection(_clipPos(cm.doc, pos), _clipPos(cm.doc, changeEnd(change))));
              })();
            }
          };

          var readTextFromFile = function readTextFromFile(file, i) {
            if (cm.options.allowDropFileTypes && indexOf(cm.options.allowDropFileTypes, file.type) == -1) {
              markAsReadAndPasteIfAllFilesAreRead();
              return;
            }

            var reader = new FileReader();

            reader.onerror = function () {
              return markAsReadAndPasteIfAllFilesAreRead();
            };

            reader.onload = function () {
              var content = reader.result;

              if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) {
                markAsReadAndPasteIfAllFilesAreRead();
                return;
              }

              text[i] = content;
              markAsReadAndPasteIfAllFilesAreRead();
            };

            reader.readAsText(file);
          };

          for (var i = 0; i < files.length; i++) {
            readTextFromFile(files[i], i);
          }
        } else {
          // Normal drop
          // Don't do a replace if the drop happened inside of the selected text.
          if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
            cm.state.draggingText(e); // Ensure the editor is re-focused

            setTimeout(function () {
              return cm.display.input.focus();
            }, 20);
            return;
          }

          try {
            var text$1 = e.dataTransfer.getData("Text");

            if (text$1) {
              var selected;

              if (cm.state.draggingText && !cm.state.draggingText.copy) {
                selected = cm.listSelections();
              }

              setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));

              if (selected) {
                for (var i$1 = 0; i$1 < selected.length; ++i$1) {
                  _replaceRange(cm.doc, "", selected[i$1].anchor, selected[i$1].head, "drag");
                }
              }

              cm.replaceSelection(text$1, "around", "paste");
              cm.display.input.focus();
            }
          } catch (e) {}
        }
      }

      function onDragStart(cm, e) {
        if (ie && (!cm.state.draggingText || +new Date() - lastDrop < 100)) {
          e_stop(e);
          return;
        }

        if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) {
          return;
        }

        e.dataTransfer.setData("Text", cm.getSelection());
        e.dataTransfer.effectAllowed = "copyMove"; // Use dummy image instead of default browsers image.
        // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.

        if (e.dataTransfer.setDragImage && !safari) {
          var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
          img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";

          if (presto) {
            img.width = img.height = 1;
            cm.display.wrapper.appendChild(img); // Force a relayout, or Opera won't use our image for some obscure reason

            img._top = img.offsetTop;
          }

          e.dataTransfer.setDragImage(img, 0, 0);

          if (presto) {
            img.parentNode.removeChild(img);
          }
        }
      }

      function onDragOver(cm, e) {
        var pos = posFromMouse(cm, e);

        if (!pos) {
          return;
        }

        var frag = document.createDocumentFragment();
        drawSelectionCursor(cm, pos, frag);

        if (!cm.display.dragCursor) {
          cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
          cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
        }

        removeChildrenAndAdd(cm.display.dragCursor, frag);
      }

      function clearDragCursor(cm) {
        if (cm.display.dragCursor) {
          cm.display.lineSpace.removeChild(cm.display.dragCursor);
          cm.display.dragCursor = null;
        }
      } // These must be handled carefully, because naively registering a
      // handler for each editor will cause the editors to never be
      // garbage collected.


      function forEachCodeMirror(f) {
        if (!document.getElementsByClassName) {
          return;
        }

        var byClass = document.getElementsByClassName("CodeMirror"),
            editors = [];

        for (var i = 0; i < byClass.length; i++) {
          var cm = byClass[i].CodeMirror;

          if (cm) {
            editors.push(cm);
          }
        }

        if (editors.length) {
          editors[0].operation(function () {
            for (var i = 0; i < editors.length; i++) {
              f(editors[i]);
            }
          });
        }
      }

      var globalsRegistered = false;

      function ensureGlobalHandlers() {
        if (globalsRegistered) {
          return;
        }

        registerGlobalHandlers();
        globalsRegistered = true;
      }

      function registerGlobalHandlers() {
        // When the window resizes, we need to refresh active editors.
        var resizeTimer;
        on(window, "resize", function () {
          if (resizeTimer == null) {
            resizeTimer = setTimeout(function () {
              resizeTimer = null;
              forEachCodeMirror(onResize);
            }, 100);
          }
        }); // When the window loses focus, we want to show the editor as blurred

        on(window, "blur", function () {
          return forEachCodeMirror(onBlur);
        });
      } // Called when the window resizes


      function onResize(cm) {
        var d = cm.display; // Might be a text scaling operation, clear size caches.

        d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
        d.scrollbarsClipped = false;
        cm.setSize();
      }

      var keyNames = {
        3: "Pause",
        8: "Backspace",
        9: "Tab",
        13: "Enter",
        16: "Shift",
        17: "Ctrl",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Esc",
        32: "Space",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "Left",
        38: "Up",
        39: "Right",
        40: "Down",
        44: "PrintScrn",
        45: "Insert",
        46: "Delete",
        59: ";",
        61: "=",
        91: "Mod",
        92: "Mod",
        93: "Mod",
        106: "*",
        107: "=",
        109: "-",
        110: ".",
        111: "/",
        145: "ScrollLock",
        173: "-",
        186: ";",
        187: "=",
        188: ",",
        189: "-",
        190: ".",
        191: "/",
        192: "`",
        219: "[",
        220: "\\",
        221: "]",
        222: "'",
        63232: "Up",
        63233: "Down",
        63234: "Left",
        63235: "Right",
        63272: "Delete",
        63273: "Home",
        63275: "End",
        63276: "PageUp",
        63277: "PageDown",
        63302: "Insert"
      }; // Number keys

      for (var i = 0; i < 10; i++) {
        keyNames[i + 48] = keyNames[i + 96] = String(i);
      } // Alphabetic keys


      for (var i$1 = 65; i$1 <= 90; i$1++) {
        keyNames[i$1] = String.fromCharCode(i$1);
      } // Function keys


      for (var i$2 = 1; i$2 <= 12; i$2++) {
        keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2;
      }

      var keyMap = {};
      keyMap.basic = {
        "Left": "goCharLeft",
        "Right": "goCharRight",
        "Up": "goLineUp",
        "Down": "goLineDown",
        "End": "goLineEnd",
        "Home": "goLineStartSmart",
        "PageUp": "goPageUp",
        "PageDown": "goPageDown",
        "Delete": "delCharAfter",
        "Backspace": "delCharBefore",
        "Shift-Backspace": "delCharBefore",
        "Tab": "defaultTab",
        "Shift-Tab": "indentAuto",
        "Enter": "newlineAndIndent",
        "Insert": "toggleOverwrite",
        "Esc": "singleSelection"
      }; // Note that the save and find-related commands aren't defined by
      // default. User code or addons can define them. Unknown commands
      // are simply ignored.

      keyMap.pcDefault = {
        "Ctrl-A": "selectAll",
        "Ctrl-D": "deleteLine",
        "Ctrl-Z": "undo",
        "Shift-Ctrl-Z": "redo",
        "Ctrl-Y": "redo",
        "Ctrl-Home": "goDocStart",
        "Ctrl-End": "goDocEnd",
        "Ctrl-Up": "goLineUp",
        "Ctrl-Down": "goLineDown",
        "Ctrl-Left": "goGroupLeft",
        "Ctrl-Right": "goGroupRight",
        "Alt-Left": "goLineStart",
        "Alt-Right": "goLineEnd",
        "Ctrl-Backspace": "delGroupBefore",
        "Ctrl-Delete": "delGroupAfter",
        "Ctrl-S": "save",
        "Ctrl-F": "find",
        "Ctrl-G": "findNext",
        "Shift-Ctrl-G": "findPrev",
        "Shift-Ctrl-F": "replace",
        "Shift-Ctrl-R": "replaceAll",
        "Ctrl-[": "indentLess",
        "Ctrl-]": "indentMore",
        "Ctrl-U": "undoSelection",
        "Shift-Ctrl-U": "redoSelection",
        "Alt-U": "redoSelection",
        "fallthrough": "basic"
      }; // Very basic readline/emacs-style bindings, which are standard on Mac.

      keyMap.emacsy = {
        "Ctrl-F": "goCharRight",
        "Ctrl-B": "goCharLeft",
        "Ctrl-P": "goLineUp",
        "Ctrl-N": "goLineDown",
        "Alt-F": "goWordRight",
        "Alt-B": "goWordLeft",
        "Ctrl-A": "goLineStart",
        "Ctrl-E": "goLineEnd",
        "Ctrl-V": "goPageDown",
        "Shift-Ctrl-V": "goPageUp",
        "Ctrl-D": "delCharAfter",
        "Ctrl-H": "delCharBefore",
        "Alt-D": "delWordAfter",
        "Alt-Backspace": "delWordBefore",
        "Ctrl-K": "killLine",
        "Ctrl-T": "transposeChars",
        "Ctrl-O": "openLine"
      };
      keyMap.macDefault = {
        "Cmd-A": "selectAll",
        "Cmd-D": "deleteLine",
        "Cmd-Z": "undo",
        "Shift-Cmd-Z": "redo",
        "Cmd-Y": "redo",
        "Cmd-Home": "goDocStart",
        "Cmd-Up": "goDocStart",
        "Cmd-End": "goDocEnd",
        "Cmd-Down": "goDocEnd",
        "Alt-Left": "goGroupLeft",
        "Alt-Right": "goGroupRight",
        "Cmd-Left": "goLineLeft",
        "Cmd-Right": "goLineRight",
        "Alt-Backspace": "delGroupBefore",
        "Ctrl-Alt-Backspace": "delGroupAfter",
        "Alt-Delete": "delGroupAfter",
        "Cmd-S": "save",
        "Cmd-F": "find",
        "Cmd-G": "findNext",
        "Shift-Cmd-G": "findPrev",
        "Cmd-Alt-F": "replace",
        "Shift-Cmd-Alt-F": "replaceAll",
        "Cmd-[": "indentLess",
        "Cmd-]": "indentMore",
        "Cmd-Backspace": "delWrappedLineLeft",
        "Cmd-Delete": "delWrappedLineRight",
        "Cmd-U": "undoSelection",
        "Shift-Cmd-U": "redoSelection",
        "Ctrl-Up": "goDocStart",
        "Ctrl-Down": "goDocEnd",
        "fallthrough": ["basic", "emacsy"]
      };
      keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault; // KEYMAP DISPATCH

      function normalizeKeyName(name) {
        var parts = name.split(/-(?!$)/);
        name = parts[parts.length - 1];
        var alt, ctrl, shift, cmd;

        for (var i = 0; i < parts.length - 1; i++) {
          var mod = parts[i];

          if (/^(cmd|meta|m)$/i.test(mod)) {
            cmd = true;
          } else if (/^a(lt)?$/i.test(mod)) {
            alt = true;
          } else if (/^(c|ctrl|control)$/i.test(mod)) {
            ctrl = true;
          } else if (/^s(hift)?$/i.test(mod)) {
            shift = true;
          } else {
            throw new Error("Unrecognized modifier name: " + mod);
          }
        }

        if (alt) {
          name = "Alt-" + name;
        }

        if (ctrl) {
          name = "Ctrl-" + name;
        }

        if (cmd) {
          name = "Cmd-" + name;
        }

        if (shift) {
          name = "Shift-" + name;
        }

        return name;
      } // This is a kludge to keep keymaps mostly working as raw objects
      // (backwards compatibility) while at the same time support features
      // like normalization and multi-stroke key bindings. It compiles a
      // new normalized keymap, and then updates the old object to reflect
      // this.


      function normalizeKeyMap(keymap) {
        var copy = {};

        for (var keyname in keymap) {
          if (keymap.hasOwnProperty(keyname)) {
            var value = keymap[keyname];

            if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) {
              continue;
            }

            if (value == "...") {
              delete keymap[keyname];
              continue;
            }

            var keys = map(keyname.split(" "), normalizeKeyName);

            for (var i = 0; i < keys.length; i++) {
              var val = void 0,
                  name = void 0;

              if (i == keys.length - 1) {
                name = keys.join(" ");
                val = value;
              } else {
                name = keys.slice(0, i + 1).join(" ");
                val = "...";
              }

              var prev = copy[name];

              if (!prev) {
                copy[name] = val;
              } else if (prev != val) {
                throw new Error("Inconsistent bindings for " + name);
              }
            }

            delete keymap[keyname];
          }
        }

        for (var prop in copy) {
          keymap[prop] = copy[prop];
        }

        return keymap;
      }

      function lookupKey(key, map, handle, context) {
        map = getKeyMap(map);
        var found = map.call ? map.call(key, context) : map[key];

        if (found === false) {
          return "nothing";
        }

        if (found === "...") {
          return "multi";
        }

        if (found != null && handle(found)) {
          return "handled";
        }

        if (map.fallthrough) {
          if (Object.prototype.toString.call(map.fallthrough) != "[object Array]") {
            return lookupKey(key, map.fallthrough, handle, context);
          }

          for (var i = 0; i < map.fallthrough.length; i++) {
            var result = lookupKey(key, map.fallthrough[i], handle, context);

            if (result) {
              return result;
            }
          }
        }
      } // Modifier key presses don't count as 'real' key presses for the
      // purpose of keymap fallthrough.


      function isModifierKey(value) {
        var name = typeof value == "string" ? value : keyNames[value.keyCode];
        return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod";
      }

      function addModifierNames(name, event, noShift) {
        var base = name;

        if (event.altKey && base != "Alt") {
          name = "Alt-" + name;
        }

        if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") {
          name = "Ctrl-" + name;
        }

        if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Cmd") {
          name = "Cmd-" + name;
        }

        if (!noShift && event.shiftKey && base != "Shift") {
          name = "Shift-" + name;
        }

        return name;
      } // Look up the name of a key as indicated by an event object.


      function keyName(event, noShift) {
        if (presto && event.keyCode == 34 && event["char"]) {
          return false;
        }

        var name = keyNames[event.keyCode];

        if (name == null || event.altGraphKey) {
          return false;
        } // Ctrl-ScrollLock has keyCode 3, same as Ctrl-Pause,
        // so we'll use event.code when available (Chrome 48+, FF 38+, Safari 10.1+)


        if (event.keyCode == 3 && event.code) {
          name = event.code;
        }

        return addModifierNames(name, event, noShift);
      }

      function getKeyMap(val) {
        return typeof val == "string" ? keyMap[val] : val;
      } // Helper for deleting text near the selection(s), used to implement
      // backspace, delete, and similar functionality.


      function deleteNearSelection(cm, compute) {
        var ranges = cm.doc.sel.ranges,
            kill = []; // Build up a set of ranges to kill first, merging overlapping
        // ranges.

        for (var i = 0; i < ranges.length; i++) {
          var toKill = compute(ranges[i]);

          while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
            var replaced = kill.pop();

            if (cmp(replaced.from, toKill.from) < 0) {
              toKill.from = replaced.from;
              break;
            }
          }

          kill.push(toKill);
        } // Next, remove those actual ranges.


        runInOp(cm, function () {
          for (var i = kill.length - 1; i >= 0; i--) {
            _replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete");
          }

          ensureCursorVisible(cm);
        });
      }

      function moveCharLogically(line, ch, dir) {
        var target = skipExtendingChars(line.text, ch + dir, dir);
        return target < 0 || target > line.text.length ? null : target;
      }

      function moveLogically(line, start, dir) {
        var ch = moveCharLogically(line, start.ch, dir);
        return ch == null ? null : new Pos(start.line, ch, dir < 0 ? "after" : "before");
      }

      function endOfLine(visually, cm, lineObj, lineNo, dir) {
        if (visually) {
          if (cm.doc.direction == "rtl") {
            dir = -dir;
          }

          var order = getOrder(lineObj, cm.doc.direction);

          if (order) {
            var part = dir < 0 ? lst(order) : order[0];
            var moveInStorageOrder = dir < 0 == (part.level == 1);
            var sticky = moveInStorageOrder ? "after" : "before";
            var ch; // With a wrapped rtl chunk (possibly spanning multiple bidi parts),
            // it could be that the last bidi part is not on the last visual line,
            // since visual lines contain content order-consecutive chunks.
            // Thus, in rtl, we are looking for the first (content-order) character
            // in the rtl chunk that is on the last line (that is, the same line
            // as the last (content-order) character).

            if (part.level > 0 || cm.doc.direction == "rtl") {
              var prep = prepareMeasureForLine(cm, lineObj);
              ch = dir < 0 ? lineObj.text.length - 1 : 0;
              var targetTop = measureCharPrepared(cm, prep, ch).top;
              ch = findFirst(function (ch) {
                return measureCharPrepared(cm, prep, ch).top == targetTop;
              }, dir < 0 == (part.level == 1) ? part.from : part.to - 1, ch);

              if (sticky == "before") {
                ch = moveCharLogically(lineObj, ch, 1);
              }
            } else {
              ch = dir < 0 ? part.to : part.from;
            }

            return new Pos(lineNo, ch, sticky);
          }
        }

        return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? "before" : "after");
      }

      function moveVisually(cm, line, start, dir) {
        var bidi = getOrder(line, cm.doc.direction);

        if (!bidi) {
          return moveLogically(line, start, dir);
        }

        if (start.ch >= line.text.length) {
          start.ch = line.text.length;
          start.sticky = "before";
        } else if (start.ch <= 0) {
          start.ch = 0;
          start.sticky = "after";
        }

        var partPos = getBidiPartAt(bidi, start.ch, start.sticky),
            part = bidi[partPos];

        if (cm.doc.direction == "ltr" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {
          // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,
          // nothing interesting happens.
          return moveLogically(line, start, dir);
        }

        var mv = function mv(pos, dir) {
          return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir);
        };

        var prep;

        var getWrappedLineExtent = function getWrappedLineExtent(ch) {
          if (!cm.options.lineWrapping) {
            return {
              begin: 0,
              end: line.text.length
            };
          }

          prep = prep || prepareMeasureForLine(cm, line);
          return wrappedLineExtentChar(cm, line, prep, ch);
        };

        var wrappedLineExtent = getWrappedLineExtent(start.sticky == "before" ? mv(start, -1) : start.ch);

        if (cm.doc.direction == "rtl" || part.level == 1) {
          var moveInStorageOrder = part.level == 1 == dir < 0;
          var ch = mv(start, moveInStorageOrder ? 1 : -1);

          if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {
            // Case 2: We move within an rtl part or in an rtl editor on the same visual line
            var sticky = moveInStorageOrder ? "before" : "after";
            return new Pos(start.line, ch, sticky);
          }
        } // Case 3: Could not move within this bidi part in this visual line, so leave
        // the current bidi part


        var searchInVisualLine = function searchInVisualLine(partPos, dir, wrappedLineExtent) {
          var getRes = function getRes(ch, moveInStorageOrder) {
            return moveInStorageOrder ? new Pos(start.line, mv(ch, 1), "before") : new Pos(start.line, ch, "after");
          };

          for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {
            var part = bidi[partPos];
            var moveInStorageOrder = dir > 0 == (part.level != 1);
            var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);

            if (part.from <= ch && ch < part.to) {
              return getRes(ch, moveInStorageOrder);
            }

            ch = moveInStorageOrder ? part.from : mv(part.to, -1);

            if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) {
              return getRes(ch, moveInStorageOrder);
            }
          }
        }; // Case 3a: Look for other bidi parts on the same visual line


        var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);

        if (res) {
          return res;
        } // Case 3b: Look for other bidi parts on the next visual line


        var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);

        if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {
          res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));

          if (res) {
            return res;
          }
        } // Case 4: Nowhere to move


        return null;
      } // Commands are parameter-less actions that can be performed on an
      // editor, mostly used for keybindings.


      var commands = {
        selectAll: selectAll,
        singleSelection: function singleSelection(cm) {
          return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll);
        },
        killLine: function killLine(cm) {
          return deleteNearSelection(cm, function (range) {
            if (range.empty()) {
              var len = getLine(cm.doc, range.head.line).text.length;

              if (range.head.ch == len && range.head.line < cm.lastLine()) {
                return {
                  from: range.head,
                  to: Pos(range.head.line + 1, 0)
                };
              } else {
                return {
                  from: range.head,
                  to: Pos(range.head.line, len)
                };
              }
            } else {
              return {
                from: range.from(),
                to: range.to()
              };
            }
          });
        },
        deleteLine: function deleteLine(cm) {
          return deleteNearSelection(cm, function (range) {
            return {
              from: Pos(range.from().line, 0),
              to: _clipPos(cm.doc, Pos(range.to().line + 1, 0))
            };
          });
        },
        delLineLeft: function delLineLeft(cm) {
          return deleteNearSelection(cm, function (range) {
            return {
              from: Pos(range.from().line, 0),
              to: range.from()
            };
          });
        },
        delWrappedLineLeft: function delWrappedLineLeft(cm) {
          return deleteNearSelection(cm, function (range) {
            var top = cm.charCoords(range.head, "div").top + 5;
            var leftPos = cm.coordsChar({
              left: 0,
              top: top
            }, "div");
            return {
              from: leftPos,
              to: range.from()
            };
          });
        },
        delWrappedLineRight: function delWrappedLineRight(cm) {
          return deleteNearSelection(cm, function (range) {
            var top = cm.charCoords(range.head, "div").top + 5;
            var rightPos = cm.coordsChar({
              left: cm.display.lineDiv.offsetWidth + 100,
              top: top
            }, "div");
            return {
              from: range.from(),
              to: rightPos
            };
          });
        },
        undo: function undo(cm) {
          return cm.undo();
        },
        redo: function redo(cm) {
          return cm.redo();
        },
        undoSelection: function undoSelection(cm) {
          return cm.undoSelection();
        },
        redoSelection: function redoSelection(cm) {
          return cm.redoSelection();
        },
        goDocStart: function goDocStart(cm) {
          return cm.extendSelection(Pos(cm.firstLine(), 0));
        },
        goDocEnd: function goDocEnd(cm) {
          return cm.extendSelection(Pos(cm.lastLine()));
        },
        goLineStart: function goLineStart(cm) {
          return cm.extendSelectionsBy(function (range) {
            return lineStart(cm, range.head.line);
          }, {
            origin: "+move",
            bias: 1
          });
        },
        goLineStartSmart: function goLineStartSmart(cm) {
          return cm.extendSelectionsBy(function (range) {
            return lineStartSmart(cm, range.head);
          }, {
            origin: "+move",
            bias: 1
          });
        },
        goLineEnd: function goLineEnd(cm) {
          return cm.extendSelectionsBy(function (range) {
            return lineEnd(cm, range.head.line);
          }, {
            origin: "+move",
            bias: -1
          });
        },
        goLineRight: function goLineRight(cm) {
          return cm.extendSelectionsBy(function (range) {
            var top = cm.cursorCoords(range.head, "div").top + 5;
            return cm.coordsChar({
              left: cm.display.lineDiv.offsetWidth + 100,
              top: top
            }, "div");
          }, sel_move);
        },
        goLineLeft: function goLineLeft(cm) {
          return cm.extendSelectionsBy(function (range) {
            var top = cm.cursorCoords(range.head, "div").top + 5;
            return cm.coordsChar({
              left: 0,
              top: top
            }, "div");
          }, sel_move);
        },
        goLineLeftSmart: function goLineLeftSmart(cm) {
          return cm.extendSelectionsBy(function (range) {
            var top = cm.cursorCoords(range.head, "div").top + 5;
            var pos = cm.coordsChar({
              left: 0,
              top: top
            }, "div");

            if (pos.ch < cm.getLine(pos.line).search(/\S/)) {
              return lineStartSmart(cm, range.head);
            }

            return pos;
          }, sel_move);
        },
        goLineUp: function goLineUp(cm) {
          return cm.moveV(-1, "line");
        },
        goLineDown: function goLineDown(cm) {
          return cm.moveV(1, "line");
        },
        goPageUp: function goPageUp(cm) {
          return cm.moveV(-1, "page");
        },
        goPageDown: function goPageDown(cm) {
          return cm.moveV(1, "page");
        },
        goCharLeft: function goCharLeft(cm) {
          return cm.moveH(-1, "char");
        },
        goCharRight: function goCharRight(cm) {
          return cm.moveH(1, "char");
        },
        goColumnLeft: function goColumnLeft(cm) {
          return cm.moveH(-1, "column");
        },
        goColumnRight: function goColumnRight(cm) {
          return cm.moveH(1, "column");
        },
        goWordLeft: function goWordLeft(cm) {
          return cm.moveH(-1, "word");
        },
        goGroupRight: function goGroupRight(cm) {
          return cm.moveH(1, "group");
        },
        goGroupLeft: function goGroupLeft(cm) {
          return cm.moveH(-1, "group");
        },
        goWordRight: function goWordRight(cm) {
          return cm.moveH(1, "word");
        },
        delCharBefore: function delCharBefore(cm) {
          return cm.deleteH(-1, "char");
        },
        delCharAfter: function delCharAfter(cm) {
          return cm.deleteH(1, "char");
        },
        delWordBefore: function delWordBefore(cm) {
          return cm.deleteH(-1, "word");
        },
        delWordAfter: function delWordAfter(cm) {
          return cm.deleteH(1, "word");
        },
        delGroupBefore: function delGroupBefore(cm) {
          return cm.deleteH(-1, "group");
        },
        delGroupAfter: function delGroupAfter(cm) {
          return cm.deleteH(1, "group");
        },
        indentAuto: function indentAuto(cm) {
          return cm.indentSelection("smart");
        },
        indentMore: function indentMore(cm) {
          return cm.indentSelection("add");
        },
        indentLess: function indentLess(cm) {
          return cm.indentSelection("subtract");
        },
        insertTab: function insertTab(cm) {
          return cm.replaceSelection("\t");
        },
        insertSoftTab: function insertSoftTab(cm) {
          var spaces = [],
              ranges = cm.listSelections(),
              tabSize = cm.options.tabSize;

          for (var i = 0; i < ranges.length; i++) {
            var pos = ranges[i].from();
            var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
            spaces.push(spaceStr(tabSize - col % tabSize));
          }

          cm.replaceSelections(spaces);
        },
        defaultTab: function defaultTab(cm) {
          if (cm.somethingSelected()) {
            cm.indentSelection("add");
          } else {
            cm.execCommand("insertTab");
          }
        },
        // Swap the two chars left and right of each selection's head.
        // Move cursor behind the two swapped characters afterwards.
        //
        // Doesn't consider line feeds a character.
        // Doesn't scan more than one line above to find a character.
        // Doesn't do anything on an empty line.
        // Doesn't do anything with non-empty selections.
        transposeChars: function transposeChars(cm) {
          return runInOp(cm, function () {
            var ranges = cm.listSelections(),
                newSel = [];

            for (var i = 0; i < ranges.length; i++) {
              if (!ranges[i].empty()) {
                continue;
              }

              var cur = ranges[i].head,
                  line = getLine(cm.doc, cur.line).text;

              if (line) {
                if (cur.ch == line.length) {
                  cur = new Pos(cur.line, cur.ch - 1);
                }

                if (cur.ch > 0) {
                  cur = new Pos(cur.line, cur.ch + 1);
                  cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2), Pos(cur.line, cur.ch - 2), cur, "+transpose");
                } else if (cur.line > cm.doc.first) {
                  var prev = getLine(cm.doc, cur.line - 1).text;

                  if (prev) {
                    cur = new Pos(cur.line, 1);
                    cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() + prev.charAt(prev.length - 1), Pos(cur.line - 1, prev.length - 1), cur, "+transpose");
                  }
                }
              }

              newSel.push(new Range(cur, cur));
            }

            cm.setSelections(newSel);
          });
        },
        newlineAndIndent: function newlineAndIndent(cm) {
          return runInOp(cm, function () {
            var sels = cm.listSelections();

            for (var i = sels.length - 1; i >= 0; i--) {
              cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, "+input");
            }

            sels = cm.listSelections();

            for (var i$1 = 0; i$1 < sels.length; i$1++) {
              cm.indentLine(sels[i$1].from().line, null, true);
            }

            ensureCursorVisible(cm);
          });
        },
        openLine: function openLine(cm) {
          return cm.replaceSelection("\n", "start");
        },
        toggleOverwrite: function toggleOverwrite(cm) {
          return cm.toggleOverwrite();
        }
      };

      function lineStart(cm, lineN) {
        var line = getLine(cm.doc, lineN);
        var visual = visualLine(line);

        if (visual != line) {
          lineN = lineNo(visual);
        }

        return endOfLine(true, cm, visual, lineN, 1);
      }

      function lineEnd(cm, lineN) {
        var line = getLine(cm.doc, lineN);
        var visual = visualLineEnd(line);

        if (visual != line) {
          lineN = lineNo(visual);
        }

        return endOfLine(true, cm, line, lineN, -1);
      }

      function lineStartSmart(cm, pos) {
        var start = lineStart(cm, pos.line);
        var line = getLine(cm.doc, start.line);
        var order = getOrder(line, cm.doc.direction);

        if (!order || order[0].level == 0) {
          var firstNonWS = Math.max(start.ch, line.text.search(/\S/));
          var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
          return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky);
        }

        return start;
      } // Run a handler that was bound to a key.


      function doHandleBinding(cm, bound, dropShift) {
        if (typeof bound == "string") {
          bound = commands[bound];

          if (!bound) {
            return false;
          }
        } // Ensure previous input has been read, so that the handler sees a
        // consistent view of the document


        cm.display.input.ensurePolled();
        var prevShift = cm.display.shift,
            done = false;

        try {
          if (cm.isReadOnly()) {
            cm.state.suppressEdits = true;
          }

          if (dropShift) {
            cm.display.shift = false;
          }

          done = bound(cm) != Pass;
        } finally {
          cm.display.shift = prevShift;
          cm.state.suppressEdits = false;
        }

        return done;
      }

      function lookupKeyForEditor(cm, name, handle) {
        for (var i = 0; i < cm.state.keyMaps.length; i++) {
          var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);

          if (result) {
            return result;
          }
        }

        return cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm) || lookupKey(name, cm.options.keyMap, handle, cm);
      } // Note that, despite the name, this function is also used to check
      // for bound mouse clicks.


      var stopSeq = new Delayed();

      function dispatchKey(cm, name, e, handle) {
        var seq = cm.state.keySeq;

        if (seq) {
          if (isModifierKey(name)) {
            return "handled";
          }

          if (/\'$/.test(name)) {
            cm.state.keySeq = null;
          } else {
            stopSeq.set(50, function () {
              if (cm.state.keySeq == seq) {
                cm.state.keySeq = null;
                cm.display.input.reset();
              }
            });
          }

          if (dispatchKeyInner(cm, seq + " " + name, e, handle)) {
            return true;
          }
        }

        return dispatchKeyInner(cm, name, e, handle);
      }

      function dispatchKeyInner(cm, name, e, handle) {
        var result = lookupKeyForEditor(cm, name, handle);

        if (result == "multi") {
          cm.state.keySeq = name;
        }

        if (result == "handled") {
          signalLater(cm, "keyHandled", cm, name, e);
        }

        if (result == "handled" || result == "multi") {
          e_preventDefault(e);
          restartBlink(cm);
        }

        return !!result;
      } // Handle a key from the keydown event.


      function handleKeyBinding(cm, e) {
        var name = keyName(e, true);

        if (!name) {
          return false;
        }

        if (e.shiftKey && !cm.state.keySeq) {
          // First try to resolve full name (including 'Shift-'). Failing
          // that, see if there is a cursor-motion command (starting with
          // 'go') bound to the keyname without 'Shift-'.
          return dispatchKey(cm, "Shift-" + name, e, function (b) {
            return doHandleBinding(cm, b, true);
          }) || dispatchKey(cm, name, e, function (b) {
            if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion) {
              return doHandleBinding(cm, b);
            }
          });
        } else {
          return dispatchKey(cm, name, e, function (b) {
            return doHandleBinding(cm, b);
          });
        }
      } // Handle a key from the keypress event


      function handleCharBinding(cm, e, ch) {
        return dispatchKey(cm, "'" + ch + "'", e, function (b) {
          return doHandleBinding(cm, b, true);
        });
      }

      var lastStoppedKey = null;

      function onKeyDown(e) {
        var cm = this;
        cm.curOp.focus = activeElt();

        if (signalDOMEvent(cm, e)) {
          return;
        } // IE does strange things with escape.


        if (ie && ie_version < 11 && e.keyCode == 27) {
          e.returnValue = false;
        }

        var code = e.keyCode;
        cm.display.shift = code == 16 || e.shiftKey;
        var handled = handleKeyBinding(cm, e);

        if (presto) {
          lastStoppedKey = handled ? code : null; // Opera has no cut event... we try to at least catch the key combo

          if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey)) {
            cm.replaceSelection("", null, "cut");
          }
        }

        if (gecko && !mac && !handled && code == 46 && e.shiftKey && !e.ctrlKey && document.execCommand) {
          document.execCommand("cut");
        } // Turn mouse into crosshair when Alt is held on Mac.


        if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className)) {
          showCrossHair(cm);
        }
      }

      function showCrossHair(cm) {
        var lineDiv = cm.display.lineDiv;
        addClass(lineDiv, "CodeMirror-crosshair");

        function up(e) {
          if (e.keyCode == 18 || !e.altKey) {
            rmClass(lineDiv, "CodeMirror-crosshair");
            off(document, "keyup", up);
            off(document, "mouseover", up);
          }
        }

        on(document, "keyup", up);
        on(document, "mouseover", up);
      }

      function onKeyUp(e) {
        if (e.keyCode == 16) {
          this.doc.sel.shift = false;
        }

        signalDOMEvent(this, e);
      }

      function onKeyPress(e) {
        var cm = this;

        if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) {
          return;
        }

        var keyCode = e.keyCode,
            charCode = e.charCode;

        if (presto && keyCode == lastStoppedKey) {
          lastStoppedKey = null;
          e_preventDefault(e);
          return;
        }

        if (presto && (!e.which || e.which < 10) && handleKeyBinding(cm, e)) {
          return;
        }

        var ch = String.fromCharCode(charCode == null ? keyCode : charCode); // Some browsers fire keypress events for backspace

        if (ch == "\x08") {
          return;
        }

        if (handleCharBinding(cm, e, ch)) {
          return;
        }

        cm.display.input.onKeyPress(e);
      }

      var DOUBLECLICK_DELAY = 400;

      var PastClick = function PastClick(time, pos, button) {
        this.time = time;
        this.pos = pos;
        this.button = button;
      };

      PastClick.prototype.compare = function (time, pos, button) {
        return this.time + DOUBLECLICK_DELAY > time && cmp(pos, this.pos) == 0 && button == this.button;
      };

      var lastClick, lastDoubleClick;

      function clickRepeat(pos, button) {
        var now = +new Date();

        if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {
          lastClick = lastDoubleClick = null;
          return "triple";
        } else if (lastClick && lastClick.compare(now, pos, button)) {
          lastDoubleClick = new PastClick(now, pos, button);
          lastClick = null;
          return "double";
        } else {
          lastClick = new PastClick(now, pos, button);
          lastDoubleClick = null;
          return "single";
        }
      } // A mouse down can be a single click, double click, triple click,
      // start of selection drag, start of text drag, new cursor
      // (ctrl-click), rectangle drag (alt-drag), or xwin
      // middle-click-paste. Or it might be a click on something we should
      // not interfere with, such as a scrollbar or widget.


      function onMouseDown(e) {
        var cm = this,
            display = cm.display;

        if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) {
          return;
        }

        display.input.ensurePolled();
        display.shift = e.shiftKey;

        if (eventInWidget(display, e)) {
          if (!webkit) {
            // Briefly turn off draggability, to allow widgets to do
            // normal dragging things.
            display.scroller.draggable = false;
            setTimeout(function () {
              return display.scroller.draggable = true;
            }, 100);
          }

          return;
        }

        if (clickInGutter(cm, e)) {
          return;
        }

        var pos = posFromMouse(cm, e),
            button = e_button(e),
            repeat = pos ? clickRepeat(pos, button) : "single";
        window.focus(); // #3261: make sure, that we're not starting a second selection

        if (button == 1 && cm.state.selectingText) {
          cm.state.selectingText(e);
        }

        if (pos && handleMappedButton(cm, button, pos, repeat, e)) {
          return;
        }

        if (button == 1) {
          if (pos) {
            leftButtonDown(cm, pos, repeat, e);
          } else if (e_target(e) == display.scroller) {
            e_preventDefault(e);
          }
        } else if (button == 2) {
          if (pos) {
            extendSelection(cm.doc, pos);
          }

          setTimeout(function () {
            return display.input.focus();
          }, 20);
        } else if (button == 3) {
          if (captureRightClick) {
            cm.display.input.onContextMenu(e);
          } else {
            delayBlurEvent(cm);
          }
        }
      }

      function handleMappedButton(cm, button, pos, repeat, event) {
        var name = "Click";

        if (repeat == "double") {
          name = "Double" + name;
        } else if (repeat == "triple") {
          name = "Triple" + name;
        }

        name = (button == 1 ? "Left" : button == 2 ? "Middle" : "Right") + name;
        return dispatchKey(cm, addModifierNames(name, event), event, function (bound) {
          if (typeof bound == "string") {
            bound = commands[bound];
          }

          if (!bound) {
            return false;
          }

          var done = false;

          try {
            if (cm.isReadOnly()) {
              cm.state.suppressEdits = true;
            }

            done = bound(cm, pos) != Pass;
          } finally {
            cm.state.suppressEdits = false;
          }

          return done;
        });
      }

      function configureMouse(cm, repeat, event) {
        var option = cm.getOption("configureMouse");
        var value = option ? option(cm, repeat, event) : {};

        if (value.unit == null) {
          var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;
          value.unit = rect ? "rectangle" : repeat == "single" ? "char" : repeat == "double" ? "word" : "line";
        }

        if (value.extend == null || cm.doc.extend) {
          value.extend = cm.doc.extend || event.shiftKey;
        }

        if (value.addNew == null) {
          value.addNew = mac ? event.metaKey : event.ctrlKey;
        }

        if (value.moveOnDrag == null) {
          value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey);
        }

        return value;
      }

      function leftButtonDown(cm, pos, repeat, event) {
        if (ie) {
          setTimeout(bind(ensureFocus, cm), 0);
        } else {
          cm.curOp.focus = activeElt();
        }

        var behavior = configureMouse(cm, repeat, event);
        var sel = cm.doc.sel,
            contained;

        if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() && repeat == "single" && (contained = sel.contains(pos)) > -1 && (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) && (cmp(contained.to(), pos) > 0 || pos.xRel < 0)) {
          leftButtonStartDrag(cm, event, pos, behavior);
        } else {
          leftButtonSelect(cm, event, pos, behavior);
        }
      } // Start a text drag. When it ends, see if any dragging actually
      // happen, and treat as a click if it didn't.


      function leftButtonStartDrag(cm, event, pos, behavior) {
        var display = cm.display,
            moved = false;
        var dragEnd = operation(cm, function (e) {
          if (webkit) {
            display.scroller.draggable = false;
          }

          cm.state.draggingText = false;
          off(display.wrapper.ownerDocument, "mouseup", dragEnd);
          off(display.wrapper.ownerDocument, "mousemove", mouseMove);
          off(display.scroller, "dragstart", dragStart);
          off(display.scroller, "drop", dragEnd);

          if (!moved) {
            e_preventDefault(e);

            if (!behavior.addNew) {
              extendSelection(cm.doc, pos, null, null, behavior.extend);
            } // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)


            if (webkit || ie && ie_version == 9) {
              setTimeout(function () {
                display.wrapper.ownerDocument.body.focus();
                display.input.focus();
              }, 20);
            } else {
              display.input.focus();
            }
          }
        });

        var mouseMove = function mouseMove(e2) {
          moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;
        };

        var dragStart = function dragStart() {
          return moved = true;
        }; // Let the drag handler handle this.


        if (webkit) {
          display.scroller.draggable = true;
        }

        cm.state.draggingText = dragEnd;
        dragEnd.copy = !behavior.moveOnDrag; // IE's approach to draggable

        if (display.scroller.dragDrop) {
          display.scroller.dragDrop();
        }

        on(display.wrapper.ownerDocument, "mouseup", dragEnd);
        on(display.wrapper.ownerDocument, "mousemove", mouseMove);
        on(display.scroller, "dragstart", dragStart);
        on(display.scroller, "drop", dragEnd);
        delayBlurEvent(cm);
        setTimeout(function () {
          return display.input.focus();
        }, 20);
      }

      function rangeForUnit(cm, pos, unit) {
        if (unit == "char") {
          return new Range(pos, pos);
        }

        if (unit == "word") {
          return cm.findWordAt(pos);
        }

        if (unit == "line") {
          return new Range(Pos(pos.line, 0), _clipPos(cm.doc, Pos(pos.line + 1, 0)));
        }

        var result = unit(cm, pos);
        return new Range(result.from, result.to);
      } // Normal selection, as opposed to text dragging.


      function leftButtonSelect(cm, event, start, behavior) {
        var display = cm.display,
            doc = cm.doc;
        e_preventDefault(event);
        var ourRange,
            ourIndex,
            startSel = doc.sel,
            ranges = startSel.ranges;

        if (behavior.addNew && !behavior.extend) {
          ourIndex = doc.sel.contains(start);

          if (ourIndex > -1) {
            ourRange = ranges[ourIndex];
          } else {
            ourRange = new Range(start, start);
          }
        } else {
          ourRange = doc.sel.primary();
          ourIndex = doc.sel.primIndex;
        }

        if (behavior.unit == "rectangle") {
          if (!behavior.addNew) {
            ourRange = new Range(start, start);
          }

          start = posFromMouse(cm, event, true, true);
          ourIndex = -1;
        } else {
          var range = rangeForUnit(cm, start, behavior.unit);

          if (behavior.extend) {
            ourRange = extendRange(ourRange, range.anchor, range.head, behavior.extend);
          } else {
            ourRange = range;
          }
        }

        if (!behavior.addNew) {
          ourIndex = 0;
          setSelection(doc, new Selection([ourRange], 0), sel_mouse);
          startSel = doc.sel;
        } else if (ourIndex == -1) {
          ourIndex = ranges.length;
          setSelection(doc, normalizeSelection(cm, ranges.concat([ourRange]), ourIndex), {
            scroll: false,
            origin: "*mouse"
          });
        } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == "char" && !behavior.extend) {
          setSelection(doc, normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0), {
            scroll: false,
            origin: "*mouse"
          });
          startSel = doc.sel;
        } else {
          replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
        }

        var lastPos = start;

        function extendTo(pos) {
          if (cmp(lastPos, pos) == 0) {
            return;
          }

          lastPos = pos;

          if (behavior.unit == "rectangle") {
            var ranges = [],
                tabSize = cm.options.tabSize;
            var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);
            var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
            var left = Math.min(startCol, posCol),
                right = Math.max(startCol, posCol);

            for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line)); line <= end; line++) {
              var text = getLine(doc, line).text,
                  leftPos = findColumn(text, left, tabSize);

              if (left == right) {
                ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));
              } else if (text.length > leftPos) {
                ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));
              }
            }

            if (!ranges.length) {
              ranges.push(new Range(start, start));
            }

            setSelection(doc, normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex), {
              origin: "*mouse",
              scroll: false
            });
            cm.scrollIntoView(pos);
          } else {
            var oldRange = ourRange;
            var range = rangeForUnit(cm, pos, behavior.unit);
            var anchor = oldRange.anchor,
                head;

            if (cmp(range.anchor, anchor) > 0) {
              head = range.head;
              anchor = minPos(oldRange.from(), range.anchor);
            } else {
              head = range.anchor;
              anchor = maxPos(oldRange.to(), range.head);
            }

            var ranges$1 = startSel.ranges.slice(0);
            ranges$1[ourIndex] = bidiSimplify(cm, new Range(_clipPos(doc, anchor), head));
            setSelection(doc, normalizeSelection(cm, ranges$1, ourIndex), sel_mouse);
          }
        }

        var editorSize = display.wrapper.getBoundingClientRect(); // Used to ensure timeout re-tries don't fire when another extend
        // happened in the meantime (clearTimeout isn't reliable -- at
        // least on Chrome, the timeouts still happen even when cleared,
        // if the clear happens after their scheduled firing time).

        var counter = 0;

        function extend(e) {
          var curCount = ++counter;
          var cur = posFromMouse(cm, e, true, behavior.unit == "rectangle");

          if (!cur) {
            return;
          }

          if (cmp(cur, lastPos) != 0) {
            cm.curOp.focus = activeElt();
            extendTo(cur);
            var visible = visibleLines(display, doc);

            if (cur.line >= visible.to || cur.line < visible.from) {
              setTimeout(operation(cm, function () {
                if (counter == curCount) {
                  extend(e);
                }
              }), 150);
            }
          } else {
            var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;

            if (outside) {
              setTimeout(operation(cm, function () {
                if (counter != curCount) {
                  return;
                }

                display.scroller.scrollTop += outside;
                extend(e);
              }), 50);
            }
          }
        }

        function done(e) {
          cm.state.selectingText = false;
          counter = Infinity; // If e is null or undefined we interpret this as someone trying
          // to explicitly cancel the selection rather than the user
          // letting go of the mouse button.

          if (e) {
            e_preventDefault(e);
            display.input.focus();
          }

          off(display.wrapper.ownerDocument, "mousemove", move);
          off(display.wrapper.ownerDocument, "mouseup", up);
          doc.history.lastSelOrigin = null;
        }

        var move = operation(cm, function (e) {
          if (e.buttons === 0 || !e_button(e)) {
            done(e);
          } else {
            extend(e);
          }
        });
        var up = operation(cm, done);
        cm.state.selectingText = up;
        on(display.wrapper.ownerDocument, "mousemove", move);
        on(display.wrapper.ownerDocument, "mouseup", up);
      } // Used when mouse-selecting to adjust the anchor to the proper side
      // of a bidi jump depending on the visual position of the head.


      function bidiSimplify(cm, range) {
        var anchor = range.anchor;
        var head = range.head;
        var anchorLine = getLine(cm.doc, anchor.line);

        if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) {
          return range;
        }

        var order = getOrder(anchorLine);

        if (!order) {
          return range;
        }

        var index = getBidiPartAt(order, anchor.ch, anchor.sticky),
            part = order[index];

        if (part.from != anchor.ch && part.to != anchor.ch) {
          return range;
        }

        var boundary = index + (part.from == anchor.ch == (part.level != 1) ? 0 : 1);

        if (boundary == 0 || boundary == order.length) {
          return range;
        } // Compute the relative visual position of the head compared to the
        // anchor (<0 is to the left, >0 to the right)


        var leftSide;

        if (head.line != anchor.line) {
          leftSide = (head.line - anchor.line) * (cm.doc.direction == "ltr" ? 1 : -1) > 0;
        } else {
          var headIndex = getBidiPartAt(order, head.ch, head.sticky);
          var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);

          if (headIndex == boundary - 1 || headIndex == boundary) {
            leftSide = dir < 0;
          } else {
            leftSide = dir > 0;
          }
        }

        var usePart = order[boundary + (leftSide ? -1 : 0)];
        var from = leftSide == (usePart.level == 1);
        var ch = from ? usePart.from : usePart.to,
            sticky = from ? "after" : "before";
        return anchor.ch == ch && anchor.sticky == sticky ? range : new Range(new Pos(anchor.line, ch, sticky), head);
      } // Determines whether an event happened in the gutter, and fires the
      // handlers for the corresponding event.


      function gutterEvent(cm, e, type, prevent) {
        var mX, mY;

        if (e.touches) {
          mX = e.touches[0].clientX;
          mY = e.touches[0].clientY;
        } else {
          try {
            mX = e.clientX;
            mY = e.clientY;
          } catch (e) {
            return false;
          }
        }

        if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) {
          return false;
        }

        if (prevent) {
          e_preventDefault(e);
        }

        var display = cm.display;
        var lineBox = display.lineDiv.getBoundingClientRect();

        if (mY > lineBox.bottom || !hasHandler(cm, type)) {
          return e_defaultPrevented(e);
        }

        mY -= lineBox.top - display.viewOffset;

        for (var i = 0; i < cm.display.gutterSpecs.length; ++i) {
          var g = display.gutters.childNodes[i];

          if (g && g.getBoundingClientRect().right >= mX) {
            var line = _lineAtHeight(cm.doc, mY);

            var gutter = cm.display.gutterSpecs[i];
            signal(cm, type, cm, line, gutter.className, e);
            return e_defaultPrevented(e);
          }
        }
      }

      function clickInGutter(cm, e) {
        return gutterEvent(cm, e, "gutterClick", true);
      } // CONTEXT MENU HANDLING
      // To make the context menu work, we need to briefly unhide the
      // textarea (making it as unobtrusive as possible) to let the
      // right-click take effect on it.


      function onContextMenu(cm, e) {
        if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) {
          return;
        }

        if (signalDOMEvent(cm, e, "contextmenu")) {
          return;
        }

        if (!captureRightClick) {
          cm.display.input.onContextMenu(e);
        }
      }

      function contextMenuInGutter(cm, e) {
        if (!hasHandler(cm, "gutterContextMenu")) {
          return false;
        }

        return gutterEvent(cm, e, "gutterContextMenu", false);
      }

      function themeChanged(cm) {
        cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") + cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
        clearCaches(cm);
      }

      var Init = {
        toString: function toString() {
          return "CodeMirror.Init";
        }
      };
      var defaults = {};
      var optionHandlers = {};

      function defineOptions(CodeMirror) {
        var optionHandlers = CodeMirror.optionHandlers;

        function option(name, deflt, handle, notOnInit) {
          CodeMirror.defaults[name] = deflt;

          if (handle) {
            optionHandlers[name] = notOnInit ? function (cm, val, old) {
              if (old != Init) {
                handle(cm, val, old);
              }
            } : handle;
          }
        }

        CodeMirror.defineOption = option; // Passed to option handlers when there is no old value.

        CodeMirror.Init = Init; // These two are, on init, called from the constructor because they
        // have to be initialized before the editor can start at all.

        option("value", "", function (cm, val) {
          return cm.setValue(val);
        }, true);
        option("mode", null, function (cm, val) {
          cm.doc.modeOption = val;
          loadMode(cm);
        }, true);
        option("indentUnit", 2, loadMode, true);
        option("indentWithTabs", false);
        option("smartIndent", true);
        option("tabSize", 4, function (cm) {
          resetModeState(cm);
          clearCaches(cm);
          regChange(cm);
        }, true);
        option("lineSeparator", null, function (cm, val) {
          cm.doc.lineSep = val;

          if (!val) {
            return;
          }

          var newBreaks = [],
              lineNo = cm.doc.first;
          cm.doc.iter(function (line) {
            for (var pos = 0;;) {
              var found = line.text.indexOf(val, pos);

              if (found == -1) {
                break;
              }

              pos = found + val.length;
              newBreaks.push(Pos(lineNo, found));
            }

            lineNo++;
          });

          for (var i = newBreaks.length - 1; i >= 0; i--) {
            _replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length));
          }
        });
        option("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff\ufff9-\ufffc]/g, function (cm, val, old) {
          cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g");

          if (old != Init) {
            cm.refresh();
          }
        });
        option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function (cm) {
          return cm.refresh();
        }, true);
        option("electricChars", true);
        option("inputStyle", mobile ? "contenteditable" : "textarea", function () {
          throw new Error("inputStyle can not (yet) be changed in a running editor"); // FIXME
        }, true);
        option("spellcheck", false, function (cm, val) {
          return cm.getInputField().spellcheck = val;
        }, true);
        option("autocorrect", false, function (cm, val) {
          return cm.getInputField().autocorrect = val;
        }, true);
        option("autocapitalize", false, function (cm, val) {
          return cm.getInputField().autocapitalize = val;
        }, true);
        option("rtlMoveVisually", !windows);
        option("wholeLineUpdateBefore", true);
        option("theme", "default", function (cm) {
          themeChanged(cm);
          updateGutters(cm);
        }, true);
        option("keyMap", "default", function (cm, val, old) {
          var next = getKeyMap(val);
          var prev = old != Init && getKeyMap(old);

          if (prev && prev.detach) {
            prev.detach(cm, next);
          }

          if (next.attach) {
            next.attach(cm, prev || null);
          }
        });
        option("extraKeys", null);
        option("configureMouse", null);
        option("lineWrapping", false, wrappingChanged, true);
        option("gutters", [], function (cm, val) {
          cm.display.gutterSpecs = getGutters(val, cm.options.lineNumbers);
          updateGutters(cm);
        }, true);
        option("fixedGutter", true, function (cm, val) {
          cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
          cm.refresh();
        }, true);
        option("coverGutterNextToScrollbar", false, function (cm) {
          return updateScrollbars(cm);
        }, true);
        option("scrollbarStyle", "native", function (cm) {
          initScrollbars(cm);
          updateScrollbars(cm);
          cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
          cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
        }, true);
        option("lineNumbers", false, function (cm, val) {
          cm.display.gutterSpecs = getGutters(cm.options.gutters, val);
          updateGutters(cm);
        }, true);
        option("firstLineNumber", 1, updateGutters, true);
        option("lineNumberFormatter", function (integer) {
          return integer;
        }, updateGutters, true);
        option("showCursorWhenSelecting", false, updateSelection, true);
        option("resetSelectionOnContextMenu", true);
        option("lineWiseCopyCut", true);
        option("pasteLinesPerSelection", true);
        option("selectionsMayTouch", false);
        option("readOnly", false, function (cm, val) {
          if (val == "nocursor") {
            onBlur(cm);
            cm.display.input.blur();
          }

          cm.display.input.readOnlyChanged(val);
        });
        option("disableInput", false, function (cm, val) {
          if (!val) {
            cm.display.input.reset();
          }
        }, true);
        option("dragDrop", true, dragDropChanged);
        option("allowDropFileTypes", null);
        option("cursorBlinkRate", 530);
        option("cursorScrollMargin", 0);
        option("cursorHeight", 1, updateSelection, true);
        option("singleCursorHeightPerLine", true, updateSelection, true);
        option("workTime", 100);
        option("workDelay", 100);
        option("flattenSpans", true, resetModeState, true);
        option("addModeClass", false, resetModeState, true);
        option("pollInterval", 100);
        option("undoDepth", 200, function (cm, val) {
          return cm.doc.history.undoDepth = val;
        });
        option("historyEventDelay", 1250);
        option("viewportMargin", 10, function (cm) {
          return cm.refresh();
        }, true);
        option("maxHighlightLength", 10000, resetModeState, true);
        option("moveInputWithCursor", true, function (cm, val) {
          if (!val) {
            cm.display.input.resetPosition();
          }
        });
        option("tabindex", null, function (cm, val) {
          return cm.display.input.getField().tabIndex = val || "";
        });
        option("autofocus", null);
        option("direction", "ltr", function (cm, val) {
          return cm.doc.setDirection(val);
        }, true);
        option("phrases", null);
      }

      function dragDropChanged(cm, value, old) {
        var wasOn = old && old != Init;

        if (!value != !wasOn) {
          var funcs = cm.display.dragFunctions;
          var toggle = value ? on : off;
          toggle(cm.display.scroller, "dragstart", funcs.start);
          toggle(cm.display.scroller, "dragenter", funcs.enter);
          toggle(cm.display.scroller, "dragover", funcs.over);
          toggle(cm.display.scroller, "dragleave", funcs.leave);
          toggle(cm.display.scroller, "drop", funcs.drop);
        }
      }

      function wrappingChanged(cm) {
        if (cm.options.lineWrapping) {
          addClass(cm.display.wrapper, "CodeMirror-wrap");
          cm.display.sizer.style.minWidth = "";
          cm.display.sizerWidth = null;
        } else {
          rmClass(cm.display.wrapper, "CodeMirror-wrap");
          findMaxLine(cm);
        }

        estimateLineHeights(cm);
        regChange(cm);
        clearCaches(cm);
        setTimeout(function () {
          return updateScrollbars(cm);
        }, 100);
      } // A CodeMirror instance represents an editor. This is the object
      // that user code is usually dealing with.


      function CodeMirror(place, options) {
        var this$1 = this;

        if (!(this instanceof CodeMirror)) {
          return new CodeMirror(place, options);
        }

        this.options = options = options ? copyObj(options) : {}; // Determine effective options based on given values and defaults.

        copyObj(defaults, options, false);
        var doc = options.value;

        if (typeof doc == "string") {
          doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction);
        } else if (options.mode) {
          doc.modeOption = options.mode;
        }

        this.doc = doc;
        var input = new CodeMirror.inputStyles[options.inputStyle](this);
        var display = this.display = new Display(place, doc, input, options);
        display.wrapper.CodeMirror = this;
        themeChanged(this);

        if (options.lineWrapping) {
          this.display.wrapper.className += " CodeMirror-wrap";
        }

        initScrollbars(this);
        this.state = {
          keyMaps: [],
          // stores maps added by addKeyMap
          overlays: [],
          // highlighting overlays, as added by addOverlay
          modeGen: 0,
          // bumped when mode/overlay changes, used to invalidate highlighting info
          overwrite: false,
          delayingBlurEvent: false,
          focused: false,
          suppressEdits: false,
          // used to disable editing during key handlers when in readOnly mode
          pasteIncoming: -1,
          cutIncoming: -1,
          // help recognize paste/cut edits in input.poll
          selectingText: false,
          draggingText: false,
          highlight: new Delayed(),
          // stores highlight worker timeout
          keySeq: null,
          // Unfinished key sequence
          specialChars: null
        };

        if (options.autofocus && !mobile) {
          display.input.focus();
        } // Override magic textarea content restore that IE sometimes does
        // on our hidden textarea on reload


        if (ie && ie_version < 11) {
          setTimeout(function () {
            return this$1.display.input.reset(true);
          }, 20);
        }

        registerEventHandlers(this);
        ensureGlobalHandlers();

        _startOperation(this);

        this.curOp.forceUpdate = true;
        attachDoc(this, doc);

        if (options.autofocus && !mobile || this.hasFocus()) {
          setTimeout(bind(onFocus, this), 20);
        } else {
          onBlur(this);
        }

        for (var opt in optionHandlers) {
          if (optionHandlers.hasOwnProperty(opt)) {
            optionHandlers[opt](this, options[opt], Init);
          }
        }

        maybeUpdateLineNumberWidth(this);

        if (options.finishInit) {
          options.finishInit(this);
        }

        for (var i = 0; i < initHooks.length; ++i) {
          initHooks[i](this);
        }

        _endOperation(this); // Suppress optimizelegibility in Webkit, since it breaks text
        // measuring on line wrapping boundaries.


        if (webkit && options.lineWrapping && getComputedStyle(display.lineDiv).textRendering == "optimizelegibility") {
          display.lineDiv.style.textRendering = "auto";
        }
      } // The default configuration options.


      CodeMirror.defaults = defaults; // Functions to run when options are changed.

      CodeMirror.optionHandlers = optionHandlers; // Attach the necessary event handlers when initializing the editor

      function registerEventHandlers(cm) {
        var d = cm.display;
        on(d.scroller, "mousedown", operation(cm, onMouseDown)); // Older IE's will not fire a second mousedown for a double click

        if (ie && ie_version < 11) {
          on(d.scroller, "dblclick", operation(cm, function (e) {
            if (signalDOMEvent(cm, e)) {
              return;
            }

            var pos = posFromMouse(cm, e);

            if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) {
              return;
            }

            e_preventDefault(e);
            var word = cm.findWordAt(pos);
            extendSelection(cm.doc, word.anchor, word.head);
          }));
        } else {
          on(d.scroller, "dblclick", function (e) {
            return signalDOMEvent(cm, e) || e_preventDefault(e);
          });
        } // Some browsers fire contextmenu *after* opening the menu, at
        // which point we can't mess with it anymore. Context menu is
        // handled in onMouseDown for these browsers.


        on(d.scroller, "contextmenu", function (e) {
          return onContextMenu(cm, e);
        });
        on(d.input.getField(), "contextmenu", function (e) {
          if (!d.scroller.contains(e.target)) {
            onContextMenu(cm, e);
          }
        }); // Used to suppress mouse event handling when a touch happens

        var touchFinished,
            prevTouch = {
          end: 0
        };

        function finishTouch() {
          if (d.activeTouch) {
            touchFinished = setTimeout(function () {
              return d.activeTouch = null;
            }, 1000);
            prevTouch = d.activeTouch;
            prevTouch.end = +new Date();
          }
        }

        function isMouseLikeTouchEvent(e) {
          if (e.touches.length != 1) {
            return false;
          }

          var touch = e.touches[0];
          return touch.radiusX <= 1 && touch.radiusY <= 1;
        }

        function farAway(touch, other) {
          if (other.left == null) {
            return true;
          }

          var dx = other.left - touch.left,
              dy = other.top - touch.top;
          return dx * dx + dy * dy > 20 * 20;
        }

        on(d.scroller, "touchstart", function (e) {
          if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {
            d.input.ensurePolled();
            clearTimeout(touchFinished);
            var now = +new Date();
            d.activeTouch = {
              start: now,
              moved: false,
              prev: now - prevTouch.end <= 300 ? prevTouch : null
            };

            if (e.touches.length == 1) {
              d.activeTouch.left = e.touches[0].pageX;
              d.activeTouch.top = e.touches[0].pageY;
            }
          }
        });
        on(d.scroller, "touchmove", function () {
          if (d.activeTouch) {
            d.activeTouch.moved = true;
          }
        });
        on(d.scroller, "touchend", function (e) {
          var touch = d.activeTouch;

          if (touch && !eventInWidget(d, e) && touch.left != null && !touch.moved && new Date() - touch.start < 300) {
            var pos = cm.coordsChar(d.activeTouch, "page"),
                range;

            if (!touch.prev || farAway(touch, touch.prev)) // Single tap
              {
                range = new Range(pos, pos);
              } else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap
              {
                range = cm.findWordAt(pos);
              } else // Triple tap
              {
                range = new Range(Pos(pos.line, 0), _clipPos(cm.doc, Pos(pos.line + 1, 0)));
              }

            cm.setSelection(range.anchor, range.head);
            cm.focus();
            e_preventDefault(e);
          }

          finishTouch();
        });
        on(d.scroller, "touchcancel", finishTouch); // Sync scrolling between fake scrollbars and real scrollable
        // area, ensure viewport is updated when scrolling.

        on(d.scroller, "scroll", function () {
          if (d.scroller.clientHeight) {
            updateScrollTop(cm, d.scroller.scrollTop);
            setScrollLeft(cm, d.scroller.scrollLeft, true);
            signal(cm, "scroll", cm);
          }
        }); // Listen to wheel events in order to try and update the viewport on time.

        on(d.scroller, "mousewheel", function (e) {
          return onScrollWheel(cm, e);
        });
        on(d.scroller, "DOMMouseScroll", function (e) {
          return onScrollWheel(cm, e);
        }); // Prevent wrapper from ever scrolling

        on(d.wrapper, "scroll", function () {
          return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0;
        });
        d.dragFunctions = {
          enter: function enter(e) {
            if (!signalDOMEvent(cm, e)) {
              e_stop(e);
            }
          },
          over: function over(e) {
            if (!signalDOMEvent(cm, e)) {
              onDragOver(cm, e);
              e_stop(e);
            }
          },
          start: function start(e) {
            return onDragStart(cm, e);
          },
          drop: operation(cm, onDrop),
          leave: function leave(e) {
            if (!signalDOMEvent(cm, e)) {
              clearDragCursor(cm);
            }
          }
        };
        var inp = d.input.getField();
        on(inp, "keyup", function (e) {
          return onKeyUp.call(cm, e);
        });
        on(inp, "keydown", operation(cm, onKeyDown));
        on(inp, "keypress", operation(cm, onKeyPress));
        on(inp, "focus", function (e) {
          return onFocus(cm, e);
        });
        on(inp, "blur", function (e) {
          return onBlur(cm, e);
        });
      }

      var initHooks = [];

      CodeMirror.defineInitHook = function (f) {
        return initHooks.push(f);
      }; // Indent the given line. The how parameter can be "smart",
      // "add"/null, "subtract", or "prev". When aggressive is false
      // (typically set to true for forced single-line indents), empty
      // lines are not indented, and places where the mode returns Pass
      // are left alone.


      function indentLine(cm, n, how, aggressive) {
        var doc = cm.doc,
            state;

        if (how == null) {
          how = "add";
        }

        if (how == "smart") {
          // Fall back to "prev" when the mode doesn't have an indentation
          // method.
          if (!doc.mode.indent) {
            how = "prev";
          } else {
            state = getContextBefore(cm, n).state;
          }
        }

        var tabSize = cm.options.tabSize;
        var line = getLine(doc, n),
            curSpace = countColumn(line.text, null, tabSize);

        if (line.stateAfter) {
          line.stateAfter = null;
        }

        var curSpaceString = line.text.match(/^\s*/)[0],
            indentation;

        if (!aggressive && !/\S/.test(line.text)) {
          indentation = 0;
          how = "not";
        } else if (how == "smart") {
          indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);

          if (indentation == Pass || indentation > 150) {
            if (!aggressive) {
              return;
            }

            how = "prev";
          }
        }

        if (how == "prev") {
          if (n > doc.first) {
            indentation = countColumn(getLine(doc, n - 1).text, null, tabSize);
          } else {
            indentation = 0;
          }
        } else if (how == "add") {
          indentation = curSpace + cm.options.indentUnit;
        } else if (how == "subtract") {
          indentation = curSpace - cm.options.indentUnit;
        } else if (typeof how == "number") {
          indentation = curSpace + how;
        }

        indentation = Math.max(0, indentation);
        var indentString = "",
            pos = 0;

        if (cm.options.indentWithTabs) {
          for (var i = Math.floor(indentation / tabSize); i; --i) {
            pos += tabSize;
            indentString += "\t";
          }
        }

        if (pos < indentation) {
          indentString += spaceStr(indentation - pos);
        }

        if (indentString != curSpaceString) {
          _replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");

          line.stateAfter = null;
          return true;
        } else {
          // Ensure that, if the cursor was in the whitespace at the start
          // of the line, it is moved to the end of that space.
          for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {
            var range = doc.sel.ranges[i$1];

            if (range.head.line == n && range.head.ch < curSpaceString.length) {
              var pos$1 = Pos(n, curSpaceString.length);
              replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));
              break;
            }
          }
        }
      } // This will be set to a {lineWise: bool, text: [string]} object, so
      // that, when pasting, we know what kind of selections the copied
      // text was made out of.


      var lastCopied = null;

      function setLastCopied(newLastCopied) {
        lastCopied = newLastCopied;
      }

      function applyTextInput(cm, inserted, deleted, sel, origin) {
        var doc = cm.doc;
        cm.display.shift = false;

        if (!sel) {
          sel = doc.sel;
        }

        var recent = +new Date() - 200;
        var paste = origin == "paste" || cm.state.pasteIncoming > recent;
        var textLines = splitLinesAuto(inserted),
            multiPaste = null; // When pasting N lines into N selections, insert one line per selection

        if (paste && sel.ranges.length > 1) {
          if (lastCopied && lastCopied.text.join("\n") == inserted) {
            if (sel.ranges.length % lastCopied.text.length == 0) {
              multiPaste = [];

              for (var i = 0; i < lastCopied.text.length; i++) {
                multiPaste.push(doc.splitLines(lastCopied.text[i]));
              }
            }
          } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {
            multiPaste = map(textLines, function (l) {
              return [l];
            });
          }
        }

        var updateInput = cm.curOp.updateInput; // Normal behavior is to insert the new text into every selection

        for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {
          var range = sel.ranges[i$1];
          var from = range.from(),
              to = range.to();

          if (range.empty()) {
            if (deleted && deleted > 0) // Handle deletion
              {
                from = Pos(from.line, from.ch - deleted);
              } else if (cm.state.overwrite && !paste) // Handle overwrite
              {
                to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));
              } else if (paste && lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == inserted) {
              from = to = Pos(from.line, 0);
            }
          }

          var changeEvent = {
            from: from,
            to: to,
            text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,
            origin: origin || (paste ? "paste" : cm.state.cutIncoming > recent ? "cut" : "+input")
          };
          makeChange(cm.doc, changeEvent);
          signalLater(cm, "inputRead", cm, changeEvent);
        }

        if (inserted && !paste) {
          triggerElectric(cm, inserted);
        }

        ensureCursorVisible(cm);

        if (cm.curOp.updateInput < 2) {
          cm.curOp.updateInput = updateInput;
        }

        cm.curOp.typing = true;
        cm.state.pasteIncoming = cm.state.cutIncoming = -1;
      }

      function handlePaste(e, cm) {
        var pasted = e.clipboardData && e.clipboardData.getData("Text");

        if (pasted) {
          e.preventDefault();

          if (!cm.isReadOnly() && !cm.options.disableInput) {
            runInOp(cm, function () {
              return applyTextInput(cm, pasted, 0, null, "paste");
            });
          }

          return true;
        }
      }

      function triggerElectric(cm, inserted) {
        // When an 'electric' character is inserted, immediately trigger a reindent
        if (!cm.options.electricChars || !cm.options.smartIndent) {
          return;
        }

        var sel = cm.doc.sel;

        for (var i = sel.ranges.length - 1; i >= 0; i--) {
          var range = sel.ranges[i];

          if (range.head.ch > 100 || i && sel.ranges[i - 1].head.line == range.head.line) {
            continue;
          }

          var mode = cm.getModeAt(range.head);
          var indented = false;

          if (mode.electricChars) {
            for (var j = 0; j < mode.electricChars.length; j++) {
              if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
                indented = indentLine(cm, range.head.line, "smart");
                break;
              }
            }
          } else if (mode.electricInput) {
            if (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch))) {
              indented = indentLine(cm, range.head.line, "smart");
            }
          }

          if (indented) {
            signalLater(cm, "electricInput", cm, range.head.line);
          }
        }
      }

      function copyableRanges(cm) {
        var text = [],
            ranges = [];

        for (var i = 0; i < cm.doc.sel.ranges.length; i++) {
          var line = cm.doc.sel.ranges[i].head.line;
          var lineRange = {
            anchor: Pos(line, 0),
            head: Pos(line + 1, 0)
          };
          ranges.push(lineRange);
          text.push(cm.getRange(lineRange.anchor, lineRange.head));
        }

        return {
          text: text,
          ranges: ranges
        };
      }

      function disableBrowserMagic(field, spellcheck, autocorrect, autocapitalize) {
        field.setAttribute("autocorrect", autocorrect ? "" : "off");
        field.setAttribute("autocapitalize", autocapitalize ? "" : "off");
        field.setAttribute("spellcheck", !!spellcheck);
      }

      function hiddenTextarea() {
        var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none");
        var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;"); // The textarea is kept positioned near the cursor to prevent the
        // fact that it'll be scrolled into view on input from scrolling
        // our fake cursor out of view. On webkit, when wrap=off, paste is
        // very slow. So make the area wide instead.

        if (webkit) {
          te.style.width = "1000px";
        } else {
          te.setAttribute("wrap", "off");
        } // If border: 0; -- iOS fails to open keyboard (issue #1287)


        if (ios) {
          te.style.border = "1px solid black";
        }

        disableBrowserMagic(te);
        return div;
      } // The publicly visible API. Note that methodOp(f) means
      // 'wrap f in an operation, performed on its `this` parameter'.
      // This is not the complete set of editor methods. Most of the
      // methods defined on the Doc type are also injected into
      // CodeMirror.prototype, for backwards compatibility and
      // convenience.


      function addEditorMethods(CodeMirror) {
        var optionHandlers = CodeMirror.optionHandlers;
        var helpers = CodeMirror.helpers = {};
        CodeMirror.prototype = {
          constructor: CodeMirror,
          focus: function focus() {
            window.focus();
            this.display.input.focus();
          },
          setOption: function setOption(option, value) {
            var options = this.options,
                old = options[option];

            if (options[option] == value && option != "mode") {
              return;
            }

            options[option] = value;

            if (optionHandlers.hasOwnProperty(option)) {
              operation(this, optionHandlers[option])(this, value, old);
            }

            signal(this, "optionChange", this, option);
          },
          getOption: function getOption(option) {
            return this.options[option];
          },
          getDoc: function getDoc() {
            return this.doc;
          },
          addKeyMap: function addKeyMap(map, bottom) {
            this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map));
          },
          removeKeyMap: function removeKeyMap(map) {
            var maps = this.state.keyMaps;

            for (var i = 0; i < maps.length; ++i) {
              if (maps[i] == map || maps[i].name == map) {
                maps.splice(i, 1);
                return true;
              }
            }
          },
          addOverlay: methodOp(function (spec, options) {
            var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);

            if (mode.startState) {
              throw new Error("Overlays may not be stateful.");
            }

            insertSorted(this.state.overlays, {
              mode: mode,
              modeSpec: spec,
              opaque: options && options.opaque,
              priority: options && options.priority || 0
            }, function (overlay) {
              return overlay.priority;
            });
            this.state.modeGen++;
            regChange(this);
          }),
          removeOverlay: methodOp(function (spec) {
            var overlays = this.state.overlays;

            for (var i = 0; i < overlays.length; ++i) {
              var cur = overlays[i].modeSpec;

              if (cur == spec || typeof spec == "string" && cur.name == spec) {
                overlays.splice(i, 1);
                this.state.modeGen++;
                regChange(this);
                return;
              }
            }
          }),
          indentLine: methodOp(function (n, dir, aggressive) {
            if (typeof dir != "string" && typeof dir != "number") {
              if (dir == null) {
                dir = this.options.smartIndent ? "smart" : "prev";
              } else {
                dir = dir ? "add" : "subtract";
              }
            }

            if (isLine(this.doc, n)) {
              indentLine(this, n, dir, aggressive);
            }
          }),
          indentSelection: methodOp(function (how) {
            var ranges = this.doc.sel.ranges,
                end = -1;

            for (var i = 0; i < ranges.length; i++) {
              var range = ranges[i];

              if (!range.empty()) {
                var from = range.from(),
                    to = range.to();
                var start = Math.max(end, from.line);
                end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;

                for (var j = start; j < end; ++j) {
                  indentLine(this, j, how);
                }

                var newRanges = this.doc.sel.ranges;

                if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0) {
                  replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll);
                }
              } else if (range.head.line > end) {
                indentLine(this, range.head.line, how, true);
                end = range.head.line;

                if (i == this.doc.sel.primIndex) {
                  ensureCursorVisible(this);
                }
              }
            }
          }),
          // Fetch the parser token for a given character. Useful for hacks
          // that want to inspect the mode state (say, for completion).
          getTokenAt: function getTokenAt(pos, precise) {
            return takeToken(this, pos, precise);
          },
          getLineTokens: function getLineTokens(line, precise) {
            return takeToken(this, Pos(line), precise, true);
          },
          getTokenTypeAt: function getTokenTypeAt(pos) {
            pos = _clipPos(this.doc, pos);
            var styles = getLineStyles(this, getLine(this.doc, pos.line));
            var before = 0,
                after = (styles.length - 1) / 2,
                ch = pos.ch;
            var type;

            if (ch == 0) {
              type = styles[2];
            } else {
              for (;;) {
                var mid = before + after >> 1;

                if ((mid ? styles[mid * 2 - 1] : 0) >= ch) {
                  after = mid;
                } else if (styles[mid * 2 + 1] < ch) {
                  before = mid + 1;
                } else {
                  type = styles[mid * 2 + 2];
                  break;
                }
              }
            }

            var cut = type ? type.indexOf("overlay ") : -1;
            return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);
          },
          getModeAt: function getModeAt(pos) {
            var mode = this.doc.mode;

            if (!mode.innerMode) {
              return mode;
            }

            return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;
          },
          getHelper: function getHelper(pos, type) {
            return this.getHelpers(pos, type)[0];
          },
          getHelpers: function getHelpers(pos, type) {
            var found = [];

            if (!helpers.hasOwnProperty(type)) {
              return found;
            }

            var help = helpers[type],
                mode = this.getModeAt(pos);

            if (typeof mode[type] == "string") {
              if (help[mode[type]]) {
                found.push(help[mode[type]]);
              }
            } else if (mode[type]) {
              for (var i = 0; i < mode[type].length; i++) {
                var val = help[mode[type][i]];

                if (val) {
                  found.push(val);
                }
              }
            } else if (mode.helperType && help[mode.helperType]) {
              found.push(help[mode.helperType]);
            } else if (help[mode.name]) {
              found.push(help[mode.name]);
            }

            for (var i$1 = 0; i$1 < help._global.length; i$1++) {
              var cur = help._global[i$1];

              if (cur.pred(mode, this) && indexOf(found, cur.val) == -1) {
                found.push(cur.val);
              }
            }

            return found;
          },
          getStateAfter: function getStateAfter(line, precise) {
            var doc = this.doc;
            line = clipLine(doc, line == null ? doc.first + doc.size - 1 : line);
            return getContextBefore(this, line + 1, precise).state;
          },
          cursorCoords: function cursorCoords(start, mode) {
            var pos,
                range = this.doc.sel.primary();

            if (start == null) {
              pos = range.head;
            } else if (_typeof(start) == "object") {
              pos = _clipPos(this.doc, start);
            } else {
              pos = start ? range.from() : range.to();
            }

            return _cursorCoords(this, pos, mode || "page");
          },
          charCoords: function charCoords(pos, mode) {
            return _charCoords(this, _clipPos(this.doc, pos), mode || "page");
          },
          coordsChar: function coordsChar(coords, mode) {
            coords = fromCoordSystem(this, coords, mode || "page");
            return _coordsChar(this, coords.left, coords.top);
          },
          lineAtHeight: function lineAtHeight(height, mode) {
            height = fromCoordSystem(this, {
              top: height,
              left: 0
            }, mode || "page").top;
            return _lineAtHeight(this.doc, height + this.display.viewOffset);
          },
          heightAtLine: function heightAtLine(line, mode, includeWidgets) {
            var end = false,
                lineObj;

            if (typeof line == "number") {
              var last = this.doc.first + this.doc.size - 1;

              if (line < this.doc.first) {
                line = this.doc.first;
              } else if (line > last) {
                line = last;
                end = true;
              }

              lineObj = getLine(this.doc, line);
            } else {
              lineObj = line;
            }

            return intoCoordSystem(this, lineObj, {
              top: 0,
              left: 0
            }, mode || "page", includeWidgets || end).top + (end ? this.doc.height - _heightAtLine(lineObj) : 0);
          },
          defaultTextHeight: function defaultTextHeight() {
            return textHeight(this.display);
          },
          defaultCharWidth: function defaultCharWidth() {
            return charWidth(this.display);
          },
          getViewport: function getViewport() {
            return {
              from: this.display.viewFrom,
              to: this.display.viewTo
            };
          },
          addWidget: function addWidget(pos, node, scroll, vert, horiz) {
            var display = this.display;
            pos = _cursorCoords(this, _clipPos(this.doc, pos));
            var top = pos.bottom,
                left = pos.left;
            node.style.position = "absolute";
            node.setAttribute("cm-ignore-events", "true");
            this.display.input.setUneditable(node);
            display.sizer.appendChild(node);

            if (vert == "over") {
              top = pos.top;
            } else if (vert == "above" || vert == "near") {
              var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
                  hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth); // Default to positioning above (if specified and possible); otherwise default to positioning below

              if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight) {
                top = pos.top - node.offsetHeight;
              } else if (pos.bottom + node.offsetHeight <= vspace) {
                top = pos.bottom;
              }

              if (left + node.offsetWidth > hspace) {
                left = hspace - node.offsetWidth;
              }
            }

            node.style.top = top + "px";
            node.style.left = node.style.right = "";

            if (horiz == "right") {
              left = display.sizer.clientWidth - node.offsetWidth;
              node.style.right = "0px";
            } else {
              if (horiz == "left") {
                left = 0;
              } else if (horiz == "middle") {
                left = (display.sizer.clientWidth - node.offsetWidth) / 2;
              }

              node.style.left = left + "px";
            }

            if (scroll) {
              scrollIntoView(this, {
                left: left,
                top: top,
                right: left + node.offsetWidth,
                bottom: top + node.offsetHeight
              });
            }
          },
          triggerOnKeyDown: methodOp(onKeyDown),
          triggerOnKeyPress: methodOp(onKeyPress),
          triggerOnKeyUp: onKeyUp,
          triggerOnMouseDown: methodOp(onMouseDown),
          execCommand: function execCommand(cmd) {
            if (commands.hasOwnProperty(cmd)) {
              return commands[cmd].call(null, this);
            }
          },
          triggerElectric: methodOp(function (text) {
            triggerElectric(this, text);
          }),
          findPosH: function findPosH(from, amount, unit, visually) {
            var dir = 1;

            if (amount < 0) {
              dir = -1;
              amount = -amount;
            }

            var cur = _clipPos(this.doc, from);

            for (var i = 0; i < amount; ++i) {
              cur = _findPosH(this.doc, cur, dir, unit, visually);

              if (cur.hitSide) {
                break;
              }
            }

            return cur;
          },
          moveH: methodOp(function (dir, unit) {
            var this$1 = this;
            this.extendSelectionsBy(function (range) {
              if (this$1.display.shift || this$1.doc.extend || range.empty()) {
                return _findPosH(this$1.doc, range.head, dir, unit, this$1.options.rtlMoveVisually);
              } else {
                return dir < 0 ? range.from() : range.to();
              }
            }, sel_move);
          }),
          deleteH: methodOp(function (dir, unit) {
            var sel = this.doc.sel,
                doc = this.doc;

            if (sel.somethingSelected()) {
              doc.replaceSelection("", null, "+delete");
            } else {
              deleteNearSelection(this, function (range) {
                var other = _findPosH(doc, range.head, dir, unit, false);

                return dir < 0 ? {
                  from: other,
                  to: range.head
                } : {
                  from: range.head,
                  to: other
                };
              });
            }
          }),
          findPosV: function findPosV(from, amount, unit, goalColumn) {
            var dir = 1,
                x = goalColumn;

            if (amount < 0) {
              dir = -1;
              amount = -amount;
            }

            var cur = _clipPos(this.doc, from);

            for (var i = 0; i < amount; ++i) {
              var coords = _cursorCoords(this, cur, "div");

              if (x == null) {
                x = coords.left;
              } else {
                coords.left = x;
              }

              cur = _findPosV(this, coords, dir, unit);

              if (cur.hitSide) {
                break;
              }
            }

            return cur;
          },
          moveV: methodOp(function (dir, unit) {
            var this$1 = this;
            var doc = this.doc,
                goals = [];
            var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();
            doc.extendSelectionsBy(function (range) {
              if (collapse) {
                return dir < 0 ? range.from() : range.to();
              }

              var headPos = _cursorCoords(this$1, range.head, "div");

              if (range.goalColumn != null) {
                headPos.left = range.goalColumn;
              }

              goals.push(headPos.left);

              var pos = _findPosV(this$1, headPos, dir, unit);

              if (unit == "page" && range == doc.sel.primary()) {
                addToScrollTop(this$1, _charCoords(this$1, pos, "div").top - headPos.top);
              }

              return pos;
            }, sel_move);

            if (goals.length) {
              for (var i = 0; i < doc.sel.ranges.length; i++) {
                doc.sel.ranges[i].goalColumn = goals[i];
              }
            }
          }),
          // Find the word at the given position (as returned by coordsChar).
          findWordAt: function findWordAt(pos) {
            var doc = this.doc,
                line = getLine(doc, pos.line).text;
            var start = pos.ch,
                end = pos.ch;

            if (line) {
              var helper = this.getHelper(pos, "wordChars");

              if ((pos.sticky == "before" || end == line.length) && start) {
                --start;
              } else {
                ++end;
              }

              var startChar = line.charAt(start);
              var check = isWordChar(startChar, helper) ? function (ch) {
                return isWordChar(ch, helper);
              } : /\s/.test(startChar) ? function (ch) {
                return /\s/.test(ch);
              } : function (ch) {
                return !/\s/.test(ch) && !isWordChar(ch);
              };

              while (start > 0 && check(line.charAt(start - 1))) {
                --start;
              }

              while (end < line.length && check(line.charAt(end))) {
                ++end;
              }
            }

            return new Range(Pos(pos.line, start), Pos(pos.line, end));
          },
          toggleOverwrite: function toggleOverwrite(value) {
            if (value != null && value == this.state.overwrite) {
              return;
            }

            if (this.state.overwrite = !this.state.overwrite) {
              addClass(this.display.cursorDiv, "CodeMirror-overwrite");
            } else {
              rmClass(this.display.cursorDiv, "CodeMirror-overwrite");
            }

            signal(this, "overwriteToggle", this, this.state.overwrite);
          },
          hasFocus: function hasFocus() {
            return this.display.input.getField() == activeElt();
          },
          isReadOnly: function isReadOnly() {
            return !!(this.options.readOnly || this.doc.cantEdit);
          },
          scrollTo: methodOp(function (x, y) {
            scrollToCoords(this, x, y);
          }),
          getScrollInfo: function getScrollInfo() {
            var scroller = this.display.scroller;
            return {
              left: scroller.scrollLeft,
              top: scroller.scrollTop,
              height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
              width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
              clientHeight: displayHeight(this),
              clientWidth: displayWidth(this)
            };
          },
          scrollIntoView: methodOp(function (range, margin) {
            if (range == null) {
              range = {
                from: this.doc.sel.primary().head,
                to: null
              };

              if (margin == null) {
                margin = this.options.cursorScrollMargin;
              }
            } else if (typeof range == "number") {
              range = {
                from: Pos(range, 0),
                to: null
              };
            } else if (range.from == null) {
              range = {
                from: range,
                to: null
              };
            }

            if (!range.to) {
              range.to = range.from;
            }

            range.margin = margin || 0;

            if (range.from.line != null) {
              scrollToRange(this, range);
            } else {
              scrollToCoordsRange(this, range.from, range.to, range.margin);
            }
          }),
          setSize: methodOp(function (width, height) {
            var this$1 = this;

            var interpret = function interpret(val) {
              return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val;
            };

            if (width != null) {
              this.display.wrapper.style.width = interpret(width);
            }

            if (height != null) {
              this.display.wrapper.style.height = interpret(height);
            }

            if (this.options.lineWrapping) {
              clearLineMeasurementCache(this);
            }

            var lineNo = this.display.viewFrom;
            this.doc.iter(lineNo, this.display.viewTo, function (line) {
              if (line.widgets) {
                for (var i = 0; i < line.widgets.length; i++) {
                  if (line.widgets[i].noHScroll) {
                    regLineChange(this$1, lineNo, "widget");
                    break;
                  }
                }
              }

              ++lineNo;
            });
            this.curOp.forceUpdate = true;
            signal(this, "refresh", this);
          }),
          operation: function operation(f) {
            return runInOp(this, f);
          },
          startOperation: function startOperation() {
            return _startOperation(this);
          },
          endOperation: function endOperation() {
            return _endOperation(this);
          },
          refresh: methodOp(function () {
            var oldHeight = this.display.cachedTextHeight;
            regChange(this);
            this.curOp.forceUpdate = true;
            clearCaches(this);
            scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);
            updateGutterSpace(this.display);

            if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5) {
              estimateLineHeights(this);
            }

            signal(this, "refresh", this);
          }),
          swapDoc: methodOp(function (doc) {
            var old = this.doc;
            old.cm = null; // Cancel the current text selection if any (#5821)

            if (this.state.selectingText) {
              this.state.selectingText();
            }

            attachDoc(this, doc);
            clearCaches(this);
            this.display.input.reset();
            scrollToCoords(this, doc.scrollLeft, doc.scrollTop);
            this.curOp.forceScroll = true;
            signalLater(this, "swapDoc", this, old);
            return old;
          }),
          phrase: function phrase(phraseText) {
            var phrases = this.options.phrases;
            return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText;
          },
          getInputField: function getInputField() {
            return this.display.input.getField();
          },
          getWrapperElement: function getWrapperElement() {
            return this.display.wrapper;
          },
          getScrollerElement: function getScrollerElement() {
            return this.display.scroller;
          },
          getGutterElement: function getGutterElement() {
            return this.display.gutters;
          }
        };
        eventMixin(CodeMirror);

        CodeMirror.registerHelper = function (type, name, value) {
          if (!helpers.hasOwnProperty(type)) {
            helpers[type] = CodeMirror[type] = {
              _global: []
            };
          }

          helpers[type][name] = value;
        };

        CodeMirror.registerGlobalHelper = function (type, name, predicate, value) {
          CodeMirror.registerHelper(type, name, value);

          helpers[type]._global.push({
            pred: predicate,
            val: value
          });
        };
      } // Used for horizontal relative motion. Dir is -1 or 1 (left or
      // right), unit can be "char", "column" (like char, but doesn't
      // cross line boundaries), "word" (across next word), or "group" (to
      // the start of next group of word or non-word-non-whitespace
      // chars). The visually param controls whether, in right-to-left
      // text, direction 1 means to move towards the next index in the
      // string, or towards the character to the right of the current
      // position. The resulting position will have a hitSide=true
      // property if it reached the end of the document.


      function _findPosH(doc, pos, dir, unit, visually) {
        var oldPos = pos;
        var origDir = dir;
        var lineObj = getLine(doc, pos.line);
        var lineDir = visually && doc.direction == "rtl" ? -dir : dir;

        function findNextLine() {
          var l = pos.line + lineDir;

          if (l < doc.first || l >= doc.first + doc.size) {
            return false;
          }

          pos = new Pos(l, pos.ch, pos.sticky);
          return lineObj = getLine(doc, l);
        }

        function moveOnce(boundToLine) {
          var next;

          if (visually) {
            next = moveVisually(doc.cm, lineObj, pos, dir);
          } else {
            next = moveLogically(lineObj, pos, dir);
          }

          if (next == null) {
            if (!boundToLine && findNextLine()) {
              pos = endOfLine(visually, doc.cm, lineObj, pos.line, lineDir);
            } else {
              return false;
            }
          } else {
            pos = next;
          }

          return true;
        }

        if (unit == "char") {
          moveOnce();
        } else if (unit == "column") {
          moveOnce(true);
        } else if (unit == "word" || unit == "group") {
          var sawType = null,
              group = unit == "group";
          var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");

          for (var first = true;; first = false) {
            if (dir < 0 && !moveOnce(!first)) {
              break;
            }

            var cur = lineObj.text.charAt(pos.ch) || "\n";
            var type = isWordChar(cur, helper) ? "w" : group && cur == "\n" ? "n" : !group || /\s/.test(cur) ? null : "p";

            if (group && !first && !type) {
              type = "s";
            }

            if (sawType && sawType != type) {
              if (dir < 0) {
                dir = 1;
                moveOnce();
                pos.sticky = "after";
              }

              break;
            }

            if (type) {
              sawType = type;
            }

            if (dir > 0 && !moveOnce(!first)) {
              break;
            }
          }
        }

        var result = skipAtomic(doc, pos, oldPos, origDir, true);

        if (equalCursorPos(oldPos, result)) {
          result.hitSide = true;
        }

        return result;
      } // For relative vertical movement. Dir may be -1 or 1. Unit can be
      // "page" or "line". The resulting position will have a hitSide=true
      // property if it reached the end of the document.


      function _findPosV(cm, pos, dir, unit) {
        var doc = cm.doc,
            x = pos.left,
            y;

        if (unit == "page") {
          var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
          var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);
          y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;
        } else if (unit == "line") {
          y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
        }

        var target;

        for (;;) {
          target = _coordsChar(cm, x, y);

          if (!target.outside) {
            break;
          }

          if (dir < 0 ? y <= 0 : y >= doc.height) {
            target.hitSide = true;
            break;
          }

          y += dir * 5;
        }

        return target;
      } // CONTENTEDITABLE INPUT STYLE


      var ContentEditableInput = function ContentEditableInput(cm) {
        this.cm = cm;
        this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
        this.polling = new Delayed();
        this.composing = null;
        this.gracePeriod = false;
        this.readDOMTimeout = null;
      };

      ContentEditableInput.prototype.init = function (display) {
        var this$1 = this;
        var input = this,
            cm = input.cm;
        var div = input.div = display.lineDiv;
        disableBrowserMagic(div, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);
        on(div, "paste", function (e) {
          if (signalDOMEvent(cm, e) || handlePaste(e, cm)) {
            return;
          } // IE doesn't fire input events, so we schedule a read for the pasted content in this way


          if (ie_version <= 11) {
            setTimeout(operation(cm, function () {
              return this$1.updateFromDOM();
            }), 20);
          }
        });
        on(div, "compositionstart", function (e) {
          this$1.composing = {
            data: e.data,
            done: false
          };
        });
        on(div, "compositionupdate", function (e) {
          if (!this$1.composing) {
            this$1.composing = {
              data: e.data,
              done: false
            };
          }
        });
        on(div, "compositionend", function (e) {
          if (this$1.composing) {
            if (e.data != this$1.composing.data) {
              this$1.readFromDOMSoon();
            }

            this$1.composing.done = true;
          }
        });
        on(div, "touchstart", function () {
          return input.forceCompositionEnd();
        });
        on(div, "input", function () {
          if (!this$1.composing) {
            this$1.readFromDOMSoon();
          }
        });

        function onCopyCut(e) {
          if (signalDOMEvent(cm, e)) {
            return;
          }

          if (cm.somethingSelected()) {
            setLastCopied({
              lineWise: false,
              text: cm.getSelections()
            });

            if (e.type == "cut") {
              cm.replaceSelection("", null, "cut");
            }
          } else if (!cm.options.lineWiseCopyCut) {
            return;
          } else {
            var ranges = copyableRanges(cm);
            setLastCopied({
              lineWise: true,
              text: ranges.text
            });

            if (e.type == "cut") {
              cm.operation(function () {
                cm.setSelections(ranges.ranges, 0, sel_dontScroll);
                cm.replaceSelection("", null, "cut");
              });
            }
          }

          if (e.clipboardData) {
            e.clipboardData.clearData();
            var content = lastCopied.text.join("\n"); // iOS exposes the clipboard API, but seems to discard content inserted into it

            e.clipboardData.setData("Text", content);

            if (e.clipboardData.getData("Text") == content) {
              e.preventDefault();
              return;
            }
          } // Old-fashioned briefly-focus-a-textarea hack


          var kludge = hiddenTextarea(),
              te = kludge.firstChild;
          cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
          te.value = lastCopied.text.join("\n");
          var hadFocus = document.activeElement;
          selectInput(te);
          setTimeout(function () {
            cm.display.lineSpace.removeChild(kludge);
            hadFocus.focus();

            if (hadFocus == div) {
              input.showPrimarySelection();
            }
          }, 50);
        }

        on(div, "copy", onCopyCut);
        on(div, "cut", onCopyCut);
      };

      ContentEditableInput.prototype.prepareSelection = function () {
        var result = prepareSelection(this.cm, false);
        result.focus = document.activeElement == this.div;
        return result;
      };

      ContentEditableInput.prototype.showSelection = function (info, takeFocus) {
        if (!info || !this.cm.display.view.length) {
          return;
        }

        if (info.focus || takeFocus) {
          this.showPrimarySelection();
        }

        this.showMultipleSelections(info);
      };

      ContentEditableInput.prototype.getSelection = function () {
        return this.cm.display.wrapper.ownerDocument.getSelection();
      };

      ContentEditableInput.prototype.showPrimarySelection = function () {
        var sel = this.getSelection(),
            cm = this.cm,
            prim = cm.doc.sel.primary();
        var from = prim.from(),
            to = prim.to();

        if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {
          sel.removeAllRanges();
          return;
        }

        var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
        var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);

        if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad && cmp(minPos(curAnchor, curFocus), from) == 0 && cmp(maxPos(curAnchor, curFocus), to) == 0) {
          return;
        }

        var view = cm.display.view;
        var start = from.line >= cm.display.viewFrom && posToDOM(cm, from) || {
          node: view[0].measure.map[2],
          offset: 0
        };
        var end = to.line < cm.display.viewTo && posToDOM(cm, to);

        if (!end) {
          var measure = view[view.length - 1].measure;
          var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
          end = {
            node: map[map.length - 1],
            offset: map[map.length - 2] - map[map.length - 3]
          };
        }

        if (!start || !end) {
          sel.removeAllRanges();
          return;
        }

        var old = sel.rangeCount && sel.getRangeAt(0),
            rng;

        try {
          rng = range(start.node, start.offset, end.offset, end.node);
        } catch (e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible


        if (rng) {
          if (!gecko && cm.state.focused) {
            sel.collapse(start.node, start.offset);

            if (!rng.collapsed) {
              sel.removeAllRanges();
              sel.addRange(rng);
            }
          } else {
            sel.removeAllRanges();
            sel.addRange(rng);
          }

          if (old && sel.anchorNode == null) {
            sel.addRange(old);
          } else if (gecko) {
            this.startGracePeriod();
          }
        }

        this.rememberSelection();
      };

      ContentEditableInput.prototype.startGracePeriod = function () {
        var this$1 = this;
        clearTimeout(this.gracePeriod);
        this.gracePeriod = setTimeout(function () {
          this$1.gracePeriod = false;

          if (this$1.selectionChanged()) {
            this$1.cm.operation(function () {
              return this$1.cm.curOp.selectionChanged = true;
            });
          }
        }, 20);
      };

      ContentEditableInput.prototype.showMultipleSelections = function (info) {
        removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
        removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
      };

      ContentEditableInput.prototype.rememberSelection = function () {
        var sel = this.getSelection();
        this.lastAnchorNode = sel.anchorNode;
        this.lastAnchorOffset = sel.anchorOffset;
        this.lastFocusNode = sel.focusNode;
        this.lastFocusOffset = sel.focusOffset;
      };

      ContentEditableInput.prototype.selectionInEditor = function () {
        var sel = this.getSelection();

        if (!sel.rangeCount) {
          return false;
        }

        var node = sel.getRangeAt(0).commonAncestorContainer;
        return contains(this.div, node);
      };

      ContentEditableInput.prototype.focus = function () {
        if (this.cm.options.readOnly != "nocursor") {
          if (!this.selectionInEditor() || document.activeElement != this.div) {
            this.showSelection(this.prepareSelection(), true);
          }

          this.div.focus();
        }
      };

      ContentEditableInput.prototype.blur = function () {
        this.div.blur();
      };

      ContentEditableInput.prototype.getField = function () {
        return this.div;
      };

      ContentEditableInput.prototype.supportsTouch = function () {
        return true;
      };

      ContentEditableInput.prototype.receivedFocus = function () {
        var input = this;

        if (this.selectionInEditor()) {
          this.pollSelection();
        } else {
          runInOp(this.cm, function () {
            return input.cm.curOp.selectionChanged = true;
          });
        }

        function poll() {
          if (input.cm.state.focused) {
            input.pollSelection();
            input.polling.set(input.cm.options.pollInterval, poll);
          }
        }

        this.polling.set(this.cm.options.pollInterval, poll);
      };

      ContentEditableInput.prototype.selectionChanged = function () {
        var sel = this.getSelection();
        return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset || sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;
      };

      ContentEditableInput.prototype.pollSelection = function () {
        if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) {
          return;
        }

        var sel = this.getSelection(),
            cm = this.cm; // On Android Chrome (version 56, at least), backspacing into an
        // uneditable block element will put the cursor in that element,
        // and then, because it's not editable, hide the virtual keyboard.
        // Because Android doesn't allow us to actually detect backspace
        // presses in a sane way, this code checks for when that happens
        // and simulates a backspace press in this case.

        if (android && chrome && this.cm.display.gutterSpecs.length && isInGutter(sel.anchorNode)) {
          this.cm.triggerOnKeyDown({
            type: "keydown",
            keyCode: 8,
            preventDefault: Math.abs
          });
          this.blur();
          this.focus();
          return;
        }

        if (this.composing) {
          return;
        }

        this.rememberSelection();
        var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
        var head = domToPos(cm, sel.focusNode, sel.focusOffset);

        if (anchor && head) {
          runInOp(cm, function () {
            setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);

            if (anchor.bad || head.bad) {
              cm.curOp.selectionChanged = true;
            }
          });
        }
      };

      ContentEditableInput.prototype.pollContent = function () {
        if (this.readDOMTimeout != null) {
          clearTimeout(this.readDOMTimeout);
          this.readDOMTimeout = null;
        }

        var cm = this.cm,
            display = cm.display,
            sel = cm.doc.sel.primary();
        var from = sel.from(),
            to = sel.to();

        if (from.ch == 0 && from.line > cm.firstLine()) {
          from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length);
        }

        if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine()) {
          to = Pos(to.line + 1, 0);
        }

        if (from.line < display.viewFrom || to.line > display.viewTo - 1) {
          return false;
        }

        var fromIndex, fromLine, fromNode;

        if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
          fromLine = lineNo(display.view[0].line);
          fromNode = display.view[0].node;
        } else {
          fromLine = lineNo(display.view[fromIndex].line);
          fromNode = display.view[fromIndex - 1].node.nextSibling;
        }

        var toIndex = findViewIndex(cm, to.line);
        var toLine, toNode;

        if (toIndex == display.view.length - 1) {
          toLine = display.viewTo - 1;
          toNode = display.lineDiv.lastChild;
        } else {
          toLine = lineNo(display.view[toIndex + 1].line) - 1;
          toNode = display.view[toIndex + 1].node.previousSibling;
        }

        if (!fromNode) {
          return false;
        }

        var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
        var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));

        while (newText.length > 1 && oldText.length > 1) {
          if (lst(newText) == lst(oldText)) {
            newText.pop();
            oldText.pop();
            toLine--;
          } else if (newText[0] == oldText[0]) {
            newText.shift();
            oldText.shift();
            fromLine++;
          } else {
            break;
          }
        }

        var cutFront = 0,
            cutEnd = 0;
        var newTop = newText[0],
            oldTop = oldText[0],
            maxCutFront = Math.min(newTop.length, oldTop.length);

        while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront)) {
          ++cutFront;
        }

        var newBot = lst(newText),
            oldBot = lst(oldText);
        var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0), oldBot.length - (oldText.length == 1 ? cutFront : 0));

        while (cutEnd < maxCutEnd && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
          ++cutEnd;
        } // Try to move start of change to start of selection if ambiguous


        if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {
          while (cutFront && cutFront > from.ch && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
            cutFront--;
            cutEnd++;
          }
        }

        newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, "");
        newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "");
        var chFrom = Pos(fromLine, cutFront);
        var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);

        if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
          _replaceRange(cm.doc, newText, chFrom, chTo, "+input");

          return true;
        }
      };

      ContentEditableInput.prototype.ensurePolled = function () {
        this.forceCompositionEnd();
      };

      ContentEditableInput.prototype.reset = function () {
        this.forceCompositionEnd();
      };

      ContentEditableInput.prototype.forceCompositionEnd = function () {
        if (!this.composing) {
          return;
        }

        clearTimeout(this.readDOMTimeout);
        this.composing = null;
        this.updateFromDOM();
        this.div.blur();
        this.div.focus();
      };

      ContentEditableInput.prototype.readFromDOMSoon = function () {
        var this$1 = this;

        if (this.readDOMTimeout != null) {
          return;
        }

        this.readDOMTimeout = setTimeout(function () {
          this$1.readDOMTimeout = null;

          if (this$1.composing) {
            if (this$1.composing.done) {
              this$1.composing = null;
            } else {
              return;
            }
          }

          this$1.updateFromDOM();
        }, 80);
      };

      ContentEditableInput.prototype.updateFromDOM = function () {
        var this$1 = this;

        if (this.cm.isReadOnly() || !this.pollContent()) {
          runInOp(this.cm, function () {
            return regChange(this$1.cm);
          });
        }
      };

      ContentEditableInput.prototype.setUneditable = function (node) {
        node.contentEditable = "false";
      };

      ContentEditableInput.prototype.onKeyPress = function (e) {
        if (e.charCode == 0 || this.composing) {
          return;
        }

        e.preventDefault();

        if (!this.cm.isReadOnly()) {
          operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);
        }
      };

      ContentEditableInput.prototype.readOnlyChanged = function (val) {
        this.div.contentEditable = String(val != "nocursor");
      };

      ContentEditableInput.prototype.onContextMenu = function () {};

      ContentEditableInput.prototype.resetPosition = function () {};

      ContentEditableInput.prototype.needsContentAttribute = true;

      function posToDOM(cm, pos) {
        var view = findViewForLine(cm, pos.line);

        if (!view || view.hidden) {
          return null;
        }

        var line = getLine(cm.doc, pos.line);
        var info = mapFromLineView(view, line, pos.line);
        var order = getOrder(line, cm.doc.direction),
            side = "left";

        if (order) {
          var partPos = getBidiPartAt(order, pos.ch);
          side = partPos % 2 ? "right" : "left";
        }

        var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
        result.offset = result.collapse == "right" ? result.end : result.start;
        return result;
      }

      function isInGutter(node) {
        for (var scan = node; scan; scan = scan.parentNode) {
          if (/CodeMirror-gutter-wrapper/.test(scan.className)) {
            return true;
          }
        }

        return false;
      }

      function badPos(pos, bad) {
        if (bad) {
          pos.bad = true;
        }

        return pos;
      }

      function domTextBetween(cm, from, to, fromLine, toLine) {
        var text = "",
            closing = false,
            lineSep = cm.doc.lineSeparator(),
            extraLinebreak = false;

        function recognizeMarker(id) {
          return function (marker) {
            return marker.id == id;
          };
        }

        function close() {
          if (closing) {
            text += lineSep;

            if (extraLinebreak) {
              text += lineSep;
            }

            closing = extraLinebreak = false;
          }
        }

        function addText(str) {
          if (str) {
            close();
            text += str;
          }
        }

        function walk(node) {
          if (node.nodeType == 1) {
            var cmText = node.getAttribute("cm-text");

            if (cmText) {
              addText(cmText);
              return;
            }

            var markerID = node.getAttribute("cm-marker"),
                range;

            if (markerID) {
              var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));

              if (found.length && (range = found[0].find(0))) {
                addText(getBetween(cm.doc, range.from, range.to).join(lineSep));
              }

              return;
            }

            if (node.getAttribute("contenteditable") == "false") {
              return;
            }

            var isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);

            if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0) {
              return;
            }

            if (isBlock) {
              close();
            }

            for (var i = 0; i < node.childNodes.length; i++) {
              walk(node.childNodes[i]);
            }

            if (/^(pre|p)$/i.test(node.nodeName)) {
              extraLinebreak = true;
            }

            if (isBlock) {
              closing = true;
            }
          } else if (node.nodeType == 3) {
            addText(node.nodeValue.replace(/\u200b/g, "").replace(/\u00a0/g, " "));
          }
        }

        for (;;) {
          walk(from);

          if (from == to) {
            break;
          }

          from = from.nextSibling;
          extraLinebreak = false;
        }

        return text;
      }

      function domToPos(cm, node, offset) {
        var lineNode;

        if (node == cm.display.lineDiv) {
          lineNode = cm.display.lineDiv.childNodes[offset];

          if (!lineNode) {
            return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);
          }

          node = null;
          offset = 0;
        } else {
          for (lineNode = node;; lineNode = lineNode.parentNode) {
            if (!lineNode || lineNode == cm.display.lineDiv) {
              return null;
            }

            if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) {
              break;
            }
          }
        }

        for (var i = 0; i < cm.display.view.length; i++) {
          var lineView = cm.display.view[i];

          if (lineView.node == lineNode) {
            return locateNodeInLineView(lineView, node, offset);
          }
        }
      }

      function locateNodeInLineView(lineView, node, offset) {
        var wrapper = lineView.text.firstChild,
            bad = false;

        if (!node || !contains(wrapper, node)) {
          return badPos(Pos(lineNo(lineView.line), 0), true);
        }

        if (node == wrapper) {
          bad = true;
          node = wrapper.childNodes[offset];
          offset = 0;

          if (!node) {
            var line = lineView.rest ? lst(lineView.rest) : lineView.line;
            return badPos(Pos(lineNo(line), line.text.length), bad);
          }
        }

        var textNode = node.nodeType == 3 ? node : null,
            topNode = node;

        if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
          textNode = node.firstChild;

          if (offset) {
            offset = textNode.nodeValue.length;
          }
        }

        while (topNode.parentNode != wrapper) {
          topNode = topNode.parentNode;
        }

        var measure = lineView.measure,
            maps = measure.maps;

        function find(textNode, topNode, offset) {
          for (var i = -1; i < (maps ? maps.length : 0); i++) {
            var map = i < 0 ? measure.map : maps[i];

            for (var j = 0; j < map.length; j += 3) {
              var curNode = map[j + 2];

              if (curNode == textNode || curNode == topNode) {
                var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);
                var ch = map[j] + offset;

                if (offset < 0 || curNode != textNode) {
                  ch = map[j + (offset ? 1 : 0)];
                }

                return Pos(line, ch);
              }
            }
          }
        }

        var found = find(textNode, topNode, offset);

        if (found) {
          return badPos(found, bad);
        } // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems


        for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
          found = find(after, after.firstChild, 0);

          if (found) {
            return badPos(Pos(found.line, found.ch - dist), bad);
          } else {
            dist += after.textContent.length;
          }
        }

        for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {
          found = find(before, before.firstChild, -1);

          if (found) {
            return badPos(Pos(found.line, found.ch + dist$1), bad);
          } else {
            dist$1 += before.textContent.length;
          }
        }
      } // TEXTAREA INPUT STYLE


      var TextareaInput = function TextareaInput(cm) {
        this.cm = cm; // See input.poll and input.reset

        this.prevInput = ""; // Flag that indicates whether we expect input to appear real soon
        // now (after some event like 'keypress' or 'input') and are
        // polling intensively.

        this.pollingFast = false; // Self-resetting timeout for the poller

        this.polling = new Delayed(); // Used to work around IE issue with selection being forgotten when focus moves away from textarea

        this.hasSelection = false;
        this.composing = null;
      };

      TextareaInput.prototype.init = function (display) {
        var this$1 = this;
        var input = this,
            cm = this.cm;
        this.createField(display);
        var te = this.textarea;
        display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild); // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)

        if (ios) {
          te.style.width = "0px";
        }

        on(te, "input", function () {
          if (ie && ie_version >= 9 && this$1.hasSelection) {
            this$1.hasSelection = null;
          }

          input.poll();
        });
        on(te, "paste", function (e) {
          if (signalDOMEvent(cm, e) || handlePaste(e, cm)) {
            return;
          }

          cm.state.pasteIncoming = +new Date();
          input.fastPoll();
        });

        function prepareCopyCut(e) {
          if (signalDOMEvent(cm, e)) {
            return;
          }

          if (cm.somethingSelected()) {
            setLastCopied({
              lineWise: false,
              text: cm.getSelections()
            });
          } else if (!cm.options.lineWiseCopyCut) {
            return;
          } else {
            var ranges = copyableRanges(cm);
            setLastCopied({
              lineWise: true,
              text: ranges.text
            });

            if (e.type == "cut") {
              cm.setSelections(ranges.ranges, null, sel_dontScroll);
            } else {
              input.prevInput = "";
              te.value = ranges.text.join("\n");
              selectInput(te);
            }
          }

          if (e.type == "cut") {
            cm.state.cutIncoming = +new Date();
          }
        }

        on(te, "cut", prepareCopyCut);
        on(te, "copy", prepareCopyCut);
        on(display.scroller, "paste", function (e) {
          if (eventInWidget(display, e) || signalDOMEvent(cm, e)) {
            return;
          }

          if (!te.dispatchEvent) {
            cm.state.pasteIncoming = +new Date();
            input.focus();
            return;
          } // Pass the `paste` event to the textarea so it's handled by its event listener.


          var event = new Event("paste");
          event.clipboardData = e.clipboardData;
          te.dispatchEvent(event);
        }); // Prevent normal selection in the editor (we handle our own)

        on(display.lineSpace, "selectstart", function (e) {
          if (!eventInWidget(display, e)) {
            e_preventDefault(e);
          }
        });
        on(te, "compositionstart", function () {
          var start = cm.getCursor("from");

          if (input.composing) {
            input.composing.range.clear();
          }

          input.composing = {
            start: start,
            range: cm.markText(start, cm.getCursor("to"), {
              className: "CodeMirror-composing"
            })
          };
        });
        on(te, "compositionend", function () {
          if (input.composing) {
            input.poll();
            input.composing.range.clear();
            input.composing = null;
          }
        });
      };

      TextareaInput.prototype.createField = function (_display) {
        // Wraps and hides input textarea
        this.wrapper = hiddenTextarea(); // The semihidden textarea that is focused when the editor is
        // focused, and receives input.

        this.textarea = this.wrapper.firstChild;
      };

      TextareaInput.prototype.prepareSelection = function () {
        // Redraw the selection and/or cursor
        var cm = this.cm,
            display = cm.display,
            doc = cm.doc;
        var result = prepareSelection(cm); // Move the hidden textarea near the cursor to prevent scrolling artifacts

        if (cm.options.moveInputWithCursor) {
          var headPos = _cursorCoords(cm, doc.sel.primary().head, "div");

          var wrapOff = display.wrapper.getBoundingClientRect(),
              lineOff = display.lineDiv.getBoundingClientRect();
          result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10, headPos.top + lineOff.top - wrapOff.top));
          result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10, headPos.left + lineOff.left - wrapOff.left));
        }

        return result;
      };

      TextareaInput.prototype.showSelection = function (drawn) {
        var cm = this.cm,
            display = cm.display;
        removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
        removeChildrenAndAdd(display.selectionDiv, drawn.selection);

        if (drawn.teTop != null) {
          this.wrapper.style.top = drawn.teTop + "px";
          this.wrapper.style.left = drawn.teLeft + "px";
        }
      }; // Reset the input to correspond to the selection (or to be empty,
      // when not typing and nothing is selected)


      TextareaInput.prototype.reset = function (typing) {
        if (this.contextMenuPending || this.composing) {
          return;
        }

        var cm = this.cm;

        if (cm.somethingSelected()) {
          this.prevInput = "";
          var content = cm.getSelection();
          this.textarea.value = content;

          if (cm.state.focused) {
            selectInput(this.textarea);
          }

          if (ie && ie_version >= 9) {
            this.hasSelection = content;
          }
        } else if (!typing) {
          this.prevInput = this.textarea.value = "";

          if (ie && ie_version >= 9) {
            this.hasSelection = null;
          }
        }
      };

      TextareaInput.prototype.getField = function () {
        return this.textarea;
      };

      TextareaInput.prototype.supportsTouch = function () {
        return false;
      };

      TextareaInput.prototype.focus = function () {
        if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt() != this.textarea)) {
          try {
            this.textarea.focus();
          } catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM

        }
      };

      TextareaInput.prototype.blur = function () {
        this.textarea.blur();
      };

      TextareaInput.prototype.resetPosition = function () {
        this.wrapper.style.top = this.wrapper.style.left = 0;
      };

      TextareaInput.prototype.receivedFocus = function () {
        this.slowPoll();
      }; // Poll for input changes, using the normal rate of polling. This
      // runs as long as the editor is focused.


      TextareaInput.prototype.slowPoll = function () {
        var this$1 = this;

        if (this.pollingFast) {
          return;
        }

        this.polling.set(this.cm.options.pollInterval, function () {
          this$1.poll();

          if (this$1.cm.state.focused) {
            this$1.slowPoll();
          }
        });
      }; // When an event has just come in that is likely to add or change
      // something in the input textarea, we poll faster, to ensure that
      // the change appears on the screen quickly.


      TextareaInput.prototype.fastPoll = function () {
        var missed = false,
            input = this;
        input.pollingFast = true;

        function p() {
          var changed = input.poll();

          if (!changed && !missed) {
            missed = true;
            input.polling.set(60, p);
          } else {
            input.pollingFast = false;
            input.slowPoll();
          }
        }

        input.polling.set(20, p);
      }; // Read input from the textarea, and update the document to match.
      // When something is selected, it is present in the textarea, and
      // selected (unless it is huge, in which case a placeholder is
      // used). When nothing is selected, the cursor sits after previously
      // seen text (can be empty), which is stored in prevInput (we must
      // not reset the textarea when typing, because that breaks IME).


      TextareaInput.prototype.poll = function () {
        var this$1 = this;
        var cm = this.cm,
            input = this.textarea,
            prevInput = this.prevInput; // Since this is called a *lot*, try to bail out as cheaply as
        // possible when it is clear that nothing happened. hasSelection
        // will be the case when there is a lot of text in the textarea,
        // in which case reading its value would be expensive.

        if (this.contextMenuPending || !cm.state.focused || hasSelection(input) && !prevInput && !this.composing || cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq) {
          return false;
        }

        var text = input.value; // If nothing changed, bail.

        if (text == prevInput && !cm.somethingSelected()) {
          return false;
        } // Work around nonsensical selection resetting in IE9/10, and
        // inexplicable appearance of private area unicode characters on
        // some key combos in Mac (#2689).


        if (ie && ie_version >= 9 && this.hasSelection === text || mac && /[\uf700-\uf7ff]/.test(text)) {
          cm.display.input.reset();
          return false;
        }

        if (cm.doc.sel == cm.display.selForContextMenu) {
          var first = text.charCodeAt(0);

          if (first == 0x200b && !prevInput) {
            prevInput = "\u200B";
          }

          if (first == 0x21da) {
            this.reset();
            return this.cm.execCommand("undo");
          }
        } // Find the part of the input that is actually new


        var same = 0,
            l = Math.min(prevInput.length, text.length);

        while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) {
          ++same;
        }

        runInOp(cm, function () {
          applyTextInput(cm, text.slice(same), prevInput.length - same, null, this$1.composing ? "*compose" : null); // Don't leave long text in the textarea, since it makes further polling slow

          if (text.length > 1000 || text.indexOf("\n") > -1) {
            input.value = this$1.prevInput = "";
          } else {
            this$1.prevInput = text;
          }

          if (this$1.composing) {
            this$1.composing.range.clear();
            this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor("to"), {
              className: "CodeMirror-composing"
            });
          }
        });
        return true;
      };

      TextareaInput.prototype.ensurePolled = function () {
        if (this.pollingFast && this.poll()) {
          this.pollingFast = false;
        }
      };

      TextareaInput.prototype.onKeyPress = function () {
        if (ie && ie_version >= 9) {
          this.hasSelection = null;
        }

        this.fastPoll();
      };

      TextareaInput.prototype.onContextMenu = function (e) {
        var input = this,
            cm = input.cm,
            display = cm.display,
            te = input.textarea;

        if (input.contextMenuPending) {
          input.contextMenuPending();
        }

        var pos = posFromMouse(cm, e),
            scrollPos = display.scroller.scrollTop;

        if (!pos || presto) {
          return;
        } // Opera is difficult.
        // Reset the current text selection only if the click is done outside of the selection
        // and 'resetSelectionOnContextMenu' option is true.


        var reset = cm.options.resetSelectionOnContextMenu;

        if (reset && cm.doc.sel.contains(pos) == -1) {
          operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);
        }

        var oldCSS = te.style.cssText,
            oldWrapperCSS = input.wrapper.style.cssText;
        var wrapperBox = input.wrapper.offsetParent.getBoundingClientRect();
        input.wrapper.style.cssText = "position: static";
        te.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e.clientY - wrapperBox.top - 5) + "px; left: " + (e.clientX - wrapperBox.left - 5) + "px;\n      z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
        var oldScrollY;

        if (webkit) {
          oldScrollY = window.scrollY;
        } // Work around Chrome issue (#2712)


        display.input.focus();

        if (webkit) {
          window.scrollTo(null, oldScrollY);
        }

        display.input.reset(); // Adds "Select all" to context menu in FF

        if (!cm.somethingSelected()) {
          te.value = input.prevInput = " ";
        }

        input.contextMenuPending = rehide;
        display.selForContextMenu = cm.doc.sel;
        clearTimeout(display.detectingSelectAll); // Select-all will be greyed out if there's nothing to select, so
        // this adds a zero-width space so that we can later check whether
        // it got selected.

        function prepareSelectAllHack() {
          if (te.selectionStart != null) {
            var selected = cm.somethingSelected();
            var extval = "\u200B" + (selected ? te.value : "");
            te.value = "\u21DA"; // Used to catch context-menu undo

            te.value = extval;
            input.prevInput = selected ? "" : "\u200B";
            te.selectionStart = 1;
            te.selectionEnd = extval.length; // Re-set this, in case some other handler touched the
            // selection in the meantime.

            display.selForContextMenu = cm.doc.sel;
          }
        }

        function rehide() {
          if (input.contextMenuPending != rehide) {
            return;
          }

          input.contextMenuPending = false;
          input.wrapper.style.cssText = oldWrapperCSS;
          te.style.cssText = oldCSS;

          if (ie && ie_version < 9) {
            display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);
          } // Try to detect the user choosing select-all


          if (te.selectionStart != null) {
            if (!ie || ie && ie_version < 9) {
              prepareSelectAllHack();
            }

            var i = 0,
                poll = function poll() {
              if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 && te.selectionEnd > 0 && input.prevInput == "\u200B") {
                operation(cm, selectAll)(cm);
              } else if (i++ < 10) {
                display.detectingSelectAll = setTimeout(poll, 500);
              } else {
                display.selForContextMenu = null;
                display.input.reset();
              }
            };

            display.detectingSelectAll = setTimeout(poll, 200);
          }
        }

        if (ie && ie_version >= 9) {
          prepareSelectAllHack();
        }

        if (captureRightClick) {
          e_stop(e);

          var mouseup = function mouseup() {
            off(window, "mouseup", mouseup);
            setTimeout(rehide, 20);
          };

          on(window, "mouseup", mouseup);
        } else {
          setTimeout(rehide, 50);
        }
      };

      TextareaInput.prototype.readOnlyChanged = function (val) {
        if (!val) {
          this.reset();
        }

        this.textarea.disabled = val == "nocursor";
      };

      TextareaInput.prototype.setUneditable = function () {};

      TextareaInput.prototype.needsContentAttribute = false;

      function fromTextArea(textarea, options) {
        options = options ? copyObj(options) : {};
        options.value = textarea.value;

        if (!options.tabindex && textarea.tabIndex) {
          options.tabindex = textarea.tabIndex;
        }

        if (!options.placeholder && textarea.placeholder) {
          options.placeholder = textarea.placeholder;
        } // Set autofocus to true if this textarea is focused, or if it has
        // autofocus and no other element is focused.


        if (options.autofocus == null) {
          var hasFocus = activeElt();
          options.autofocus = hasFocus == textarea || textarea.getAttribute("autofocus") != null && hasFocus == document.body;
        }

        function save() {
          textarea.value = cm.getValue();
        }

        var realSubmit;

        if (textarea.form) {
          on(textarea.form, "submit", save); // Deplorable hack to make the submit method do the right thing.

          if (!options.leaveSubmitMethodAlone) {
            var form = textarea.form;
            realSubmit = form.submit;

            try {
              var wrappedSubmit = form.submit = function () {
                save();
                form.submit = realSubmit;
                form.submit();
                form.submit = wrappedSubmit;
              };
            } catch (e) {}
          }
        }

        options.finishInit = function (cm) {
          cm.save = save;

          cm.getTextArea = function () {
            return textarea;
          };

          cm.toTextArea = function () {
            cm.toTextArea = isNaN; // Prevent this from being ran twice

            save();
            textarea.parentNode.removeChild(cm.getWrapperElement());
            textarea.style.display = "";

            if (textarea.form) {
              off(textarea.form, "submit", save);

              if (!options.leaveSubmitMethodAlone && typeof textarea.form.submit == "function") {
                textarea.form.submit = realSubmit;
              }
            }
          };
        };

        textarea.style.display = "none";
        var cm = CodeMirror(function (node) {
          return textarea.parentNode.insertBefore(node, textarea.nextSibling);
        }, options);
        return cm;
      }

      function addLegacyProps(CodeMirror) {
        CodeMirror.off = off;
        CodeMirror.on = on;
        CodeMirror.wheelEventPixels = wheelEventPixels;
        CodeMirror.Doc = Doc;
        CodeMirror.splitLines = splitLinesAuto;
        CodeMirror.countColumn = countColumn;
        CodeMirror.findColumn = findColumn;
        CodeMirror.isWordChar = isWordCharBasic;
        CodeMirror.Pass = Pass;
        CodeMirror.signal = signal;
        CodeMirror.Line = Line;
        CodeMirror.changeEnd = changeEnd;
        CodeMirror.scrollbarModel = scrollbarModel;
        CodeMirror.Pos = Pos;
        CodeMirror.cmpPos = cmp;
        CodeMirror.modes = modes;
        CodeMirror.mimeModes = mimeModes;
        CodeMirror.resolveMode = resolveMode;
        CodeMirror.getMode = getMode;
        CodeMirror.modeExtensions = modeExtensions;
        CodeMirror.extendMode = extendMode;
        CodeMirror.copyState = copyState;
        CodeMirror.startState = startState;
        CodeMirror.innerMode = innerMode;
        CodeMirror.commands = commands;
        CodeMirror.keyMap = keyMap;
        CodeMirror.keyName = keyName;
        CodeMirror.isModifierKey = isModifierKey;
        CodeMirror.lookupKey = lookupKey;
        CodeMirror.normalizeKeyMap = normalizeKeyMap;
        CodeMirror.StringStream = StringStream;
        CodeMirror.SharedTextMarker = SharedTextMarker;
        CodeMirror.TextMarker = TextMarker;
        CodeMirror.LineWidget = LineWidget;
        CodeMirror.e_preventDefault = e_preventDefault;
        CodeMirror.e_stopPropagation = e_stopPropagation;
        CodeMirror.e_stop = e_stop;
        CodeMirror.addClass = addClass;
        CodeMirror.contains = contains;
        CodeMirror.rmClass = rmClass;
        CodeMirror.keyNames = keyNames;
      } // EDITOR CONSTRUCTOR


      defineOptions(CodeMirror);
      addEditorMethods(CodeMirror); // Set up methods on CodeMirror's prototype to redirect to the editor's document.

      var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");

      for (var prop in Doc.prototype) {
        if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0) {
          CodeMirror.prototype[prop] = function (method) {
            return function () {
              return method.apply(this.doc, arguments);
            };
          }(Doc.prototype[prop]);
        }
      }

      eventMixin(Doc);
      CodeMirror.inputStyles = {
        "textarea": TextareaInput,
        "contenteditable": ContentEditableInput
      }; // Extra arguments are stored as the mode's dependencies, which is
      // used by (legacy) mechanisms like loadmode.js to automatically
      // load a mode. (Preferred mechanism is the require/define calls.)

      CodeMirror.defineMode = function (name
      /*, mode, …*/
      ) {
        if (!CodeMirror.defaults.mode && name != "null") {
          CodeMirror.defaults.mode = name;
        }

        defineMode.apply(this, arguments);
      };

      CodeMirror.defineMIME = defineMIME; // Minimal default mode.

      CodeMirror.defineMode("null", function () {
        return {
          token: function token(stream) {
            return stream.skipToEnd();
          }
        };
      });
      CodeMirror.defineMIME("text/plain", "null"); // EXTENSIONS

      CodeMirror.defineExtension = function (name, func) {
        CodeMirror.prototype[name] = func;
      };

      CodeMirror.defineDocExtension = function (name, func) {
        Doc.prototype[name] = func;
      };

      CodeMirror.fromTextArea = fromTextArea;
      addLegacyProps(CodeMirror);
      CodeMirror.version = "5.52.2";
      return CodeMirror;
    });
  });

  var xml = createCommonjsModule(function (module, exports) {
    // CodeMirror, copyright (c) by Marijn Haverbeke and others
    // Distributed under an MIT license: https://codemirror.net/LICENSE
    (function (mod) {
      mod(codemirror);
    })(function (CodeMirror) {

      var htmlConfig = {
        autoSelfClosers: {
          'area': true,
          'base': true,
          'br': true,
          'col': true,
          'command': true,
          'embed': true,
          'frame': true,
          'hr': true,
          'img': true,
          'input': true,
          'keygen': true,
          'link': true,
          'meta': true,
          'param': true,
          'source': true,
          'track': true,
          'wbr': true,
          'menuitem': true
        },
        implicitlyClosed: {
          'dd': true,
          'li': true,
          'optgroup': true,
          'option': true,
          'p': true,
          'rp': true,
          'rt': true,
          'tbody': true,
          'td': true,
          'tfoot': true,
          'th': true,
          'tr': true
        },
        contextGrabbers: {
          'dd': {
            'dd': true,
            'dt': true
          },
          'dt': {
            'dd': true,
            'dt': true
          },
          'li': {
            'li': true
          },
          'option': {
            'option': true,
            'optgroup': true
          },
          'optgroup': {
            'optgroup': true
          },
          'p': {
            'address': true,
            'article': true,
            'aside': true,
            'blockquote': true,
            'dir': true,
            'div': true,
            'dl': true,
            'fieldset': true,
            'footer': true,
            'form': true,
            'h1': true,
            'h2': true,
            'h3': true,
            'h4': true,
            'h5': true,
            'h6': true,
            'header': true,
            'hgroup': true,
            'hr': true,
            'menu': true,
            'nav': true,
            'ol': true,
            'p': true,
            'pre': true,
            'section': true,
            'table': true,
            'ul': true
          },
          'rp': {
            'rp': true,
            'rt': true
          },
          'rt': {
            'rp': true,
            'rt': true
          },
          'tbody': {
            'tbody': true,
            'tfoot': true
          },
          'td': {
            'td': true,
            'th': true
          },
          'tfoot': {
            'tbody': true
          },
          'th': {
            'td': true,
            'th': true
          },
          'thead': {
            'tbody': true,
            'tfoot': true
          },
          'tr': {
            'tr': true
          }
        },
        doNotIndent: {
          "pre": true
        },
        allowUnquoted: true,
        allowMissing: true,
        caseFold: true
      };
      var xmlConfig = {
        autoSelfClosers: {},
        implicitlyClosed: {},
        contextGrabbers: {},
        doNotIndent: {},
        allowUnquoted: false,
        allowMissing: false,
        allowMissingTagName: false,
        caseFold: false
      };
      CodeMirror.defineMode("xml", function (editorConf, config_) {
        var indentUnit = editorConf.indentUnit;
        var config = {};
        var defaults = config_.htmlMode ? htmlConfig : xmlConfig;

        for (var prop in defaults) {
          config[prop] = defaults[prop];
        }

        for (var prop in config_) {
          config[prop] = config_[prop];
        } // Return variables for tokenizers


        var type, setStyle;

        function inText(stream, state) {
          function chain(parser) {
            state.tokenize = parser;
            return parser(stream, state);
          }

          var ch = stream.next();

          if (ch == "<") {
            if (stream.eat("!")) {
              if (stream.eat("[")) {
                if (stream.match("CDATA[")) return chain(inBlock("atom", "]]>"));else return null;
              } else if (stream.match("--")) {
                return chain(inBlock("comment", "-->"));
              } else if (stream.match("DOCTYPE", true, true)) {
                stream.eatWhile(/[\w\._\-]/);
                return chain(doctype(1));
              } else {
                return null;
              }
            } else if (stream.eat("?")) {
              stream.eatWhile(/[\w\._\-]/);
              state.tokenize = inBlock("meta", "?>");
              return "meta";
            } else {
              type = stream.eat("/") ? "closeTag" : "openTag";
              state.tokenize = inTag;
              return "tag bracket";
            }
          } else if (ch == "&") {
            var ok;

            if (stream.eat("#")) {
              if (stream.eat("x")) {
                ok = stream.eatWhile(/[a-fA-F\d]/) && stream.eat(";");
              } else {
                ok = stream.eatWhile(/[\d]/) && stream.eat(";");
              }
            } else {
              ok = stream.eatWhile(/[\w\.\-:]/) && stream.eat(";");
            }

            return ok ? "atom" : "error";
          } else {
            stream.eatWhile(/[^&<]/);
            return null;
          }
        }

        inText.isInText = true;

        function inTag(stream, state) {
          var ch = stream.next();

          if (ch == ">" || ch == "/" && stream.eat(">")) {
            state.tokenize = inText;
            type = ch == ">" ? "endTag" : "selfcloseTag";
            return "tag bracket";
          } else if (ch == "=") {
            type = "equals";
            return null;
          } else if (ch == "<") {
            state.tokenize = inText;
            state.state = baseState;
            state.tagName = state.tagStart = null;
            var next = state.tokenize(stream, state);
            return next ? next + " tag error" : "tag error";
          } else if (/[\'\"]/.test(ch)) {
            state.tokenize = inAttribute(ch);
            state.stringStartCol = stream.column();
            return state.tokenize(stream, state);
          } else {
            stream.match(/^[^\s\u00a0=<>\"\']*[^\s\u00a0=<>\"\'\/]/);
            return "word";
          }
        }

        function inAttribute(quote) {
          var closure = function closure(stream, state) {
            while (!stream.eol()) {
              if (stream.next() == quote) {
                state.tokenize = inTag;
                break;
              }
            }

            return "string";
          };

          closure.isInAttribute = true;
          return closure;
        }

        function inBlock(style, terminator) {
          return function (stream, state) {
            while (!stream.eol()) {
              if (stream.match(terminator)) {
                state.tokenize = inText;
                break;
              }

              stream.next();
            }

            return style;
          };
        }

        function doctype(depth) {
          return function (stream, state) {
            var ch;

            while ((ch = stream.next()) != null) {
              if (ch == "<") {
                state.tokenize = doctype(depth + 1);
                return state.tokenize(stream, state);
              } else if (ch == ">") {
                if (depth == 1) {
                  state.tokenize = inText;
                  break;
                } else {
                  state.tokenize = doctype(depth - 1);
                  return state.tokenize(stream, state);
                }
              }
            }

            return "meta";
          };
        }

        function Context(state, tagName, startOfLine) {
          this.prev = state.context;
          this.tagName = tagName;
          this.indent = state.indented;
          this.startOfLine = startOfLine;
          if (config.doNotIndent.hasOwnProperty(tagName) || state.context && state.context.noIndent) this.noIndent = true;
        }

        function popContext(state) {
          if (state.context) state.context = state.context.prev;
        }

        function maybePopContext(state, nextTagName) {
          var parentTagName;

          while (true) {
            if (!state.context) {
              return;
            }

            parentTagName = state.context.tagName;

            if (!config.contextGrabbers.hasOwnProperty(parentTagName) || !config.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {
              return;
            }

            popContext(state);
          }
        }

        function baseState(type, stream, state) {
          if (type == "openTag") {
            state.tagStart = stream.column();
            return tagNameState;
          } else if (type == "closeTag") {
            return closeTagNameState;
          } else {
            return baseState;
          }
        }

        function tagNameState(type, stream, state) {
          if (type == "word") {
            state.tagName = stream.current();
            setStyle = "tag";
            return attrState;
          } else if (config.allowMissingTagName && type == "endTag") {
            setStyle = "tag bracket";
            return attrState(type, stream, state);
          } else {
            setStyle = "error";
            return tagNameState;
          }
        }

        function closeTagNameState(type, stream, state) {
          if (type == "word") {
            var tagName = stream.current();
            if (state.context && state.context.tagName != tagName && config.implicitlyClosed.hasOwnProperty(state.context.tagName)) popContext(state);

            if (state.context && state.context.tagName == tagName || config.matchClosing === false) {
              setStyle = "tag";
              return closeState;
            } else {
              setStyle = "tag error";
              return closeStateErr;
            }
          } else if (config.allowMissingTagName && type == "endTag") {
            setStyle = "tag bracket";
            return closeState(type, stream, state);
          } else {
            setStyle = "error";
            return closeStateErr;
          }
        }

        function closeState(type, _stream, state) {
          if (type != "endTag") {
            setStyle = "error";
            return closeState;
          }

          popContext(state);
          return baseState;
        }

        function closeStateErr(type, stream, state) {
          setStyle = "error";
          return closeState(type, stream, state);
        }

        function attrState(type, _stream, state) {
          if (type == "word") {
            setStyle = "attribute";
            return attrEqState;
          } else if (type == "endTag" || type == "selfcloseTag") {
            var tagName = state.tagName,
                tagStart = state.tagStart;
            state.tagName = state.tagStart = null;

            if (type == "selfcloseTag" || config.autoSelfClosers.hasOwnProperty(tagName)) {
              maybePopContext(state, tagName);
            } else {
              maybePopContext(state, tagName);
              state.context = new Context(state, tagName, tagStart == state.indented);
            }

            return baseState;
          }

          setStyle = "error";
          return attrState;
        }

        function attrEqState(type, stream, state) {
          if (type == "equals") return attrValueState;
          if (!config.allowMissing) setStyle = "error";
          return attrState(type, stream, state);
        }

        function attrValueState(type, stream, state) {
          if (type == "string") return attrContinuedState;

          if (type == "word" && config.allowUnquoted) {
            setStyle = "string";
            return attrState;
          }

          setStyle = "error";
          return attrState(type, stream, state);
        }

        function attrContinuedState(type, stream, state) {
          if (type == "string") return attrContinuedState;
          return attrState(type, stream, state);
        }

        return {
          startState: function startState(baseIndent) {
            var state = {
              tokenize: inText,
              state: baseState,
              indented: baseIndent || 0,
              tagName: null,
              tagStart: null,
              context: null
            };
            if (baseIndent != null) state.baseIndent = baseIndent;
            return state;
          },
          token: function token(stream, state) {
            if (!state.tagName && stream.sol()) state.indented = stream.indentation();
            if (stream.eatSpace()) return null;
            type = null;
            var style = state.tokenize(stream, state);

            if ((style || type) && style != "comment") {
              setStyle = null;
              state.state = state.state(type || style, stream, state);
              if (setStyle) style = setStyle == "error" ? style + " error" : setStyle;
            }

            return style;
          },
          indent: function indent(state, textAfter, fullLine) {
            var context = state.context; // Indent multi-line strings (e.g. css).

            if (state.tokenize.isInAttribute) {
              if (state.tagStart == state.indented) return state.stringStartCol + 1;else return state.indented + indentUnit;
            }

            if (context && context.noIndent) return CodeMirror.Pass;
            if (state.tokenize != inTag && state.tokenize != inText) return fullLine ? fullLine.match(/^(\s*)/)[0].length : 0; // Indent the starts of attribute names.

            if (state.tagName) {
              if (config.multilineTagIndentPastTag !== false) return state.tagStart + state.tagName.length + 2;else return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);
            }

            if (config.alignCDATA && /<!\[CDATA\[/.test(textAfter)) return 0;
            var tagAfter = textAfter && /^<(\/)?([\w_:\.-]*)/.exec(textAfter);

            if (tagAfter && tagAfter[1]) {
              // Closing tag spotted
              while (context) {
                if (context.tagName == tagAfter[2]) {
                  context = context.prev;
                  break;
                } else if (config.implicitlyClosed.hasOwnProperty(context.tagName)) {
                  context = context.prev;
                } else {
                  break;
                }
              }
            } else if (tagAfter) {
              // Opening tag spotted
              while (context) {
                var grabbers = config.contextGrabbers[context.tagName];
                if (grabbers && grabbers.hasOwnProperty(tagAfter[2])) context = context.prev;else break;
              }
            }

            while (context && context.prev && !context.startOfLine) {
              context = context.prev;
            }

            if (context) return context.indent + indentUnit;else return state.baseIndent || 0;
          },
          electricInput: /<\/[\s\w:]+>$/,
          blockCommentStart: "<!--",
          blockCommentEnd: "-->",
          configuration: config.htmlMode ? "html" : "xml",
          helperType: config.htmlMode ? "html" : "xml",
          skipAttribute: function skipAttribute(state) {
            if (state.state == attrValueState) state.state = attrState;
          },
          xmlCurrentTag: function xmlCurrentTag(state) {
            return state.tagName ? {
              name: state.tagName,
              close: state.type == "closeTag"
            } : null;
          },
          xmlCurrentContext: function xmlCurrentContext(state) {
            var context = [];

            for (var cx = state.context; cx; cx = cx.prev) {
              if (cx.tagName) context.push(cx.tagName);
            }

            return context.reverse();
          }
        };
      });
      CodeMirror.defineMIME("text/xml", "xml");
      CodeMirror.defineMIME("application/xml", "xml");
      if (!CodeMirror.mimeModes.hasOwnProperty("text/html")) CodeMirror.defineMIME("text/html", {
        name: "xml",
        htmlMode: true
      });
    });
  });

  var CLASS_NAME = '_coral-Playground';
  /**
   Enumeration for {@link Playground} screens.

   @typedef {Object} PlaygroundScreenEnum

   @property {String} FULLSCREEN
   Editor covers the whole screen.
   @property {String} HORIZONTAL
   Split editor/preview horizontally.
   @property {String} VERTICAL
   Split editor/preview vertically.
   */

  var SCREEN_ENUM = {
    FULLSCREEN: 'fullscreen',
    HORIZONTAL: 'horizontal',
    VERTICAL: 'vertical'
  };
  var PROPERTIES = ['livereload', 'screen', 'code']; // builds an array containing all possible variant classnames. this will be used to remove classnames when the variant
  // changes

  var SCREEN_CLASSES = [];

  for (var value in SCREEN_ENUM) {
    SCREEN_CLASSES.push("".concat(CLASS_NAME, "--").concat(SCREEN_ENUM[value]));
  }

  var CODEMIRROR_CONFIG = {
    mode: 'text/xml',
    lineNumbers: true,
    matchBrackets: true,
    indentWithTabs: true,
    tabSize: 2,
    indentUnit: 2
  };
  var DEBOUNCE_TIME = 250;
  /**
   @class Coral.Playground
   @classdesc A Playground component with JS/CSS/HTML editor and live preview. Sharing code is possible by copy pasting
   the URL
   @htmltag coral-playground
   @extends {HTMLElement}
   @extends {BaseComponent}
   */

  var Playground = /*#__PURE__*/function (_BaseComponent) {
    _inherits(Playground, _BaseComponent);

    var _super = _createSuper(Playground);

    /**
     Takes an optional configuration object for initialization.
      @param {?Object} config
     */
    function Playground() {
      var _this;

      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, Playground);

      _this = _super.call(this);
      _this._config = config; // Template

      _this._elements = {};
      template$16.call(_this._elements, {
        commons: commons
      });
      var overlayId = _this._elements.overlay.id; // Events

      var events = {
        'click [handle="share"]': '_onShareClick',
        'click [handle="run"]': '_onRunClick'
      }; // Overlay

      events["global:capture:change #".concat(overlayId, " [handle=\"livereload\"]")] = '_onLiveReloadChange';
      events["global:capture:change #".concat(overlayId, " [handle=\"screen\"]")] = '_onScreenChange';

      _this._delegateEvents(events); // Init editor


      _this._editor = new codemirror(_this._elements.editor, CODEMIRROR_CONFIG); // Bind editor

      _this._editor.on('change', function () {
        if (_this.livereload) {
          _this._debounceTrigger('coral-playground:coderun');
        } else {
          _this._elements.run.style.visibility = 'visible';
        }
      });

      _this._elements.frame.onload = function () {
        _this._elements.loading.hidden = true;

        _this.trigger('coral-playground:load');
      };

      return _this;
    }
    /**
     Whether the preview is updated automatically on code change.
      @type {Boolean}
     @default false
     @htmlattribute livereload
     */


    _createClass(Playground, [{
      key: "_debounceTrigger",
      value: function _debounceTrigger(event) {
        var _this2 = this;

        // Debounce
        if (this._timeout !== null) {
          window.clearTimeout(this._timeout);
        }

        this._timeout = window.setTimeout(function () {
          _this2._timeout = null;

          _this2.trigger(event);
        }, DEBOUNCE_TIME);
      }
    }, {
      key: "_onRunClick",
      value: function _onRunClick() {
        this._debounceTrigger('coral-playground:coderun');
      }
    }, {
      key: "_onShareClick",
      value: function _onShareClick() {
        var _this3 = this;

        this._elements.copy.value = location.href;

        this._elements.copy.select();

        document.execCommand('copy');
        this._elements.sharetip.open = true;
        window.setTimeout(function () {
          _this3._elements.sharetip.open = false;
        }, 1000);
      }
    }, {
      key: "_onLiveReloadChange",
      value: function _onLiveReloadChange(event) {
        this.livereload = event.matchedTarget.checked;
      }
    }, {
      key: "_onScreenChange",
      value: function _onScreenChange(event) {
        this.screen = event.matchedTarget.value;
      }
    }, {
      key: "run",

      /**
       Runs the code.
        @param {String} code
       */
      value: function run(code) {
        this._elements.loading.hidden = false;
        this._elements.frame.srcdoc = code;
      }
      /**
       Returns the query hash for sharing.
        @return {String}
       */

    }, {
      key: "share",
      value: function share() {
        var _this4 = this;

        var query = '?';
        PROPERTIES.forEach(function (property) {
          if (_this4[property]) {
            query += "".concat(property, "=").concat(property === 'code' ? Playground._compress(_this4.code) : _this4[property], "&");
          }
        });
        return query;
      }
      /**
       Returns {@link Playground} screens.
        @return {PlaygroundScreenEnum}
       */

    }, {
      key: "connectedCallback",

      /** @ignore */
      value: function connectedCallback() {
        var _this5 = this;

        this.classList.add(CLASS_NAME);
        this.appendChild(this._elements.wrapper); // Set properties and defaults

        this.screen = this._config.screen;
        this.code = this._config.code;
        this.livereload = this._config.livereload;
        window.requestAnimationFrame(function () {
          _this5._editor.refresh();

          if (_this5.livereload) {
            _this5._debounceTrigger('coral-playground:coderun');
          }
        });
      }
    }, {
      key: "livereload",
      get: function get() {
        return this._livereload;
      },
      set: function set(value) {
        if (value) {
          this._livereload = true;

          this._elements.livereload.setAttribute('checked', '');

          this._elements.run.style.visibility = 'hidden';

          this._debounceTrigger('coral-playground:coderun');
        } else {
          this._livereload = false;

          this._elements.livereload.removeAttribute('checked');

          this._elements.run.style.visibility = 'visible';
        }

        this._debounceTrigger('coral-playground:settingschange');
      }
      /**
       The playground screen see {@link PlaygroundScreenEnum}.
        @type {String}
       @default PlaygroundScreenEnum.SPLIT_VERTICAL
       @htmlattribute screen
       */

    }, {
      key: "screen",
      get: function get() {
        return this._screen;
      },
      set: function set(value) {
        var _this$classList;

        value = transform.string(value).toLowerCase();
        this._screen = validate.enumeration(SCREEN_ENUM)(value) && value || SCREEN_ENUM.VERTICAL;

        this._reflectAttribute('screen', this._screen);

        this._elements.screen.value = this._screen;

        (_this$classList = this.classList).remove.apply(_this$classList, SCREEN_CLASSES);

        this.classList.add("".concat(CLASS_NAME, "--").concat(this._screen));

        this._elements.overlay.reposition();

        this._debounceTrigger('coral-playground:settingschange');
      }
      /**
       The editor code.
        @type {String}
       */

    }, {
      key: "code",
      get: function get() {
        return this._editor.getValue();
      },
      set: function set(value) {
        this._editor.setValue(value || '');
      }
    }], [{
      key: "_parseQueryString",
      value: function _parseQueryString(query) {
        var objURL = {};
        query.replace(new RegExp('([^?=&]+)(=([^&]*))?', 'g'), // eslint-disable-next-line no-unused-vars
        function ($0, $1, $2, $3) {
          objURL[$1] = decodeURI($3);
        });
        return objURL;
      }
    }, {
      key: "_compress",
      value: function _compress(code) {
        var bytes = Array.prototype.map.call(code, function (char) {
          return char.charCodeAt(0);
        });
        var compressed = rawdeflate(bytes);
        return window.btoa(compressed);
      }
    }, {
      key: "_uncompress",
      value: function _uncompress(base64) {
        var bytes = window.atob(base64);
        var uncompressed = rawinflate(bytes.split(','));
        return Array.prototype.map.call(uncompressed, function (byte) {
          return String.fromCharCode(byte);
        }).join('');
      }
      /**
       Reads a query hash and returns a configuration that can be consumed by a {@link Playground} instance.
        @param {String} query
       @return {Object}
       */

    }, {
      key: "read",
      value: function read(query) {
        var params = Playground._parseQueryString(query);

        var config = {};

        if (Object.keys(params).length) {
          PROPERTIES.forEach(function (property) {
            config[property] = property === 'code' && params[property] ? Playground._uncompress(params[property]) : params[property];
          });
        }

        return config;
      }
    }, {
      key: "screen",
      get: function get() {
        return SCREEN_ENUM;
      }
      /** @ignore */

    }, {
      key: "observedAttributes",
      get: function get() {
        return _get(_getPrototypeOf(Playground), "observedAttributes", this).concat(['livereload', 'screen']);
      }
    }]);

    return Playground;
  }(BaseComponent(HTMLElement));

  /**
   * Copyright 2019 Adobe. All rights reserved.
   * This file is licensed to you under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License. You may obtain a copy
   * of the License at http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under
   * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
   * OF ANY KIND, either express or implied. See the License for the specific language
   * governing permissions and limitations under the License.
   */
  window.customElements.define('coral-playground', Playground); // Export all on the Coral namespace

  window.Coral = {};
  window.Coral.Playground = Playground;

  for (var component in components) {
    window.Coral[component] = components[component];
  }

}());
//# sourceMappingURL=coral.js.map
