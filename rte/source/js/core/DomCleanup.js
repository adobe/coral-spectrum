/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.DomCleanup
 * This class implements a DOM-based cleanup module to ensure that the input can be
 * processed and the output is suitable for persisting it (the actual HTML is generated by
 * the component's {@link CUI.rte.HtmlSerializer}, which applies additional rules to
 * cleanup the generated HTML).
 * @constructor
 * Creates a new DomCleanup.
 * @param {Object} config The kernel's configuration
 */
CUI.rte.DomCleanup = new Class({

    toString: "DomCleanup",

    /**
     * @cfg {String[]} tagsToRemove
     * List of tags to be removed
     */
    tagsToRemove: null,

    /**
     * Rules for preprocessing pasted content. Only valid if {@link #prepareHtmlPaste} is
     * used. Format is defined at {@link CUI.rte.plugins.EditToolsPlugin#htmlPasteRules}
     * @private
     * @type Object
     */
    pasteRules: null,

    /**
     * The editor kernel we're working on
     * @private
     * @type CUI.rte.EditorKernel
     */
    editorKernel: null,

    /**
     * The edit context we're working in
     * @private
     * @type CUI.rte.EditContext
     */
    context: null,

    /**
     * The current HTML rules
     * @private
     * @type CUI.rte.HtmlRules
     */
    htmlRules: null,

    /**
     * Processing mode; as defined by the constants of this class.
     * @private
     * @type Number
     */
    processingMode: null,

    /**
     * Array of DOM elements to be removed after traversing the DOM tree
     * @private
     * @type HTMLElement[]
     */
    elementsToRemove: null,

    /**
     * Array of sub tree roots to be removed
     * @private
     * @type HTMLElement[]
     */
    subTreesToRemove: null,

    /**
     * Array of DOM elements to be changed after traversing the DOM tree. Each array
     * element has a domToChange property that determines the element to be changed, and
     * a changedDom property that defines the changed element.
     * @private
     * @type Object[]
     */
    elementsToChange: null,

    /**
     * Array of DOM elements to be inserted after traversing the DOM tree. Each array
     * element has a domToInsert property that determines the element to be inserted, a
     * parentDom property that defines the parent element it gets appended to, and an
     * (optional) refDom property that determines the sibling element the new element gets
     * inserted before
     */
    elementsToInsert: null,

    /**
     * Array of empty editing blocks that have to be "fixed for editing" on IE
     */
    emptyBlocksIE: null,


    construct: function(config) {
        CUI.rte.Utils.apply(this, config);
    },


    // -- Helpers --------------------------------------------------------------------------

    /**
     * <p>Marks the specified DOM element for being removed.</p>
     * <p>Using this method prevents that the same DOM element is added multiple times
     * to the list of elements to be removed.</p>
     * @param {HTMLElement} dom The DOM element to be removed
     */
    markForRemoval: function(dom) {
        if (!CUI.rte.Common.arrayContains(this.elementsToRemove, dom)) {
            this.elementsToRemove.push(dom);
        }
    },

    /**
     * Marks the sub tree that starts at the specified DOM element for being deleted. The
     * specified element will get deleted as well.
     * @param {HTMLElement} root The root element of the sub tree to be marked for removal
     */
    markSubTreeForRemoval: function(root) {
        this.subTreesToRemove.push(root);
    },

    /**
     * Marks the specified DOM element for be inserted according the specified rules.
     * @param {HTMLElement} dom The element to be inserted
     * @param {HTMLElement} parentDom The parent element
     * @param {HTMLElement} siblingRef (optional) The element the new element is inserted
     *        before; if not specified, the DOM element will be appended
     */
    markForInsertion: function(dom, parentDom, siblingRef) {
        this.elementsToInsert.push({
            "domToInsert": dom,
            "parentDom": parentDom,
            "refDom": siblingRef
        })
    },

    /**
     * <p>Checks if we are doing any preprocessing.</p>
     * <p>This method returns true for "default" preprocessing, but also for paste
     * preprocessing.</p>
     * @return {Boolean} True if any kind of preprocessing is currently executed
     */
    isPreProcessing: function() {
        var dcu = CUI.rte.DomCleanup;
        return (this.processingMode == dcu.PASTE_PREPARE)
                || (this.processingMode == dcu.PRE);
    },

    /**
     * Flattens the specified DOM element by creating paragraphs from the specified
     * container structures and removing nested structures of the specified type.
     * @param {HTMLElement} dom The DOM element to be flattened
     * @param {String|String[]} tagsToFlatten Defines the tag or tags that contain content
     *        to be flattened; for example: "li" for list items
     * @param {String|String[]} nestingTags Defines the tag or tags that mark nested
     *        striucture; for example: "table" for nested tables
     * @return {HTMLElement} The first flattened element (changed container element)
     */
    flattenNestedStructure: function(dom, tagsToFlatten, nestingTags) {
        var com = CUI.rte.Common;
        var continueDom = null;
        var parentRef = dom.parentNode;
        var insertRef = dom.nextSibling;
        var replacementTag = this.pasteRules.fallbackBlockTag || "p";
        var nodesToFlatten = com.getTags(dom, tagsToFlatten);
        var nodeCnt = nodesToFlatten.length;
        for (var n = 0; n < nodeCnt; n++) {
            var domToFlatten = nodesToFlatten[n];
            var flattenedDom = this.context.createElement(replacementTag);
            if (continueDom == null) {
                continueDom = flattenedDom;
            }
            com.insertBefore(parentRef, flattenedDom, insertRef);
            // move children - skip nested containers (nested content elements are already
            // included in nodesToFlatten)
            var children = domToFlatten.childNodes;
            while (children.length > 0) {
                var childToMove = children[0];
                if (!com.isTag(childToMove, nestingTags)) {
                    flattenedDom.appendChild(childToMove);
                }
            }
        }
        dom.parentNode.removeChild(dom);
        return continueDom;
    },


    // -- Processing methods ---------------------------------------------------------------

    /**
     * <p>Checks if the specified DOM element marks the root of a valid sub tree in the DOM.
     * </p>
     * <p>If the method returns false, the entire sub tree gets removed, including the
     * specified DOM element.</p>
     * <p>If the method returns false, ancestor elements or sub trees can still be
     * declared invalid.</p>
     * @param {HTMLElement} dom The DOM element to check
     * @return {Boolean} True if the sub tree starting at the specified element is
     *         considered valid
     */
    isValidSubTree: function(dom) {
        var com = CUI.rte.Common;
        var isValid = true;
        // handle temporary elements first
        var tempAttrib = com.getAttribute(dom, com.TEMP_EL_ATTRIB, true);
        if (tempAttrib) {
            var splitAttrib = tempAttrib.split(":");
            var keepChildren = com.arrayContains(splitAttrib, "keepChildren");
            var emptyOnly = com.arrayContains(splitAttrib, "emptyOnly");
            if (!keepChildren) {
                if (emptyOnly) {
                    // check for emptiness has to be executed recursively
                    function checkEmpty(dom) {
                        if (dom.nodeType === 3) {
                            return false;
                        }
                        var childCnt = dom.childNodes.length;
                        if (childCnt === 0) {
                            return true;
                        }
                        for (var c = 0; c < childCnt; c++) {
                            var child = dom.childNodes[c];
                            var tempAttrib = com.getAttribute(dom, com.TEMP_EL_ATTRIB,
                                    true);
                            if (!tempAttrib) {
                                return false;
                            }
                            var splitAttrib = tempAttrib.split(":");
                            if (com.arrayContains(splitAttrib, "emptyOnly")) {
                                if (!checkEmpty(child)) {
                                    return false;
                                }
                            } else {
                                return false;
                            }
                        }
                        return true;
                    }
                    if (checkEmpty(dom)) {
                        isValid = false;
                    } else {
                        com.removeAttribute(dom, com.TEMP_EL_ATTRIB);
                    }
                } else {
                    isValid = false;
                }
            }
        }
        return isValid;
    },

    /**
     * <p>Checks if the specified DOM element is valid according to current rules.</p>
     * <p>Note that - contrary to {@link #isValidSubTree} - this method only removes
     * the specified element (if false is returned) and leaves the ancestor elements intact.
     * </p>
     * @param {HTMLElement} dom The DOM element to check
     * @return {Boolean} True if the DOM element is considered valid
     */
    isValidElement: function(dom) {
        var com = CUI.rte.Common;
        var tagName = dom.tagName.toLowerCase();
        // ignore namespaced tags
        var namespace = com.getNamespace(dom);
        if (namespace != null) {
            return false;
        }
        // ignore blacklisted tags
        if (this.tagsToRemove) {
            if (com.arrayContains(this.tagsToRemove, tagName)) {
                return false;
            }
        }
        // ignore elements with "_rtetemp" attribute
        if (com.isTag(dom, "span") && com.isAttribDefined(dom, "_rtetemp")) {
            return false;
        }
        // ignore temporary elements that keep child nodes
        var tempAttrib = com.getAttribute(dom, com.TEMP_EL_ATTRIB, true);
        if (tempAttrib) {
            var splitAttrib = tempAttrib.split(":");
            var keepChildren = com.arrayContains(splitAttrib, "keepChildren");
            if (keepChildren) {
                return false;
            }
        }
        return true;
    },

    /**
     * <p>Change linefeeds in preformatted sections into "br" tags - although this is
     * no correct HTML, browsers tend to be more stable with br tags (and selection handling
     * is much easier) while editing.</p>
     */
    handlePreformattedSection: function(dom) {
        var context = this.context;
        var com = CUI.rte.Common;
        if (this.isPreProcessing()) {
            if (com.isTag(dom, "pre")) {
                var recurse = function(toProcess) {
                    var parentNode = toProcess.parentNode;
                    if (toProcess.nodeType == 3) {
                        var nodeText = toProcess.nodeValue;
                        nodeText = nodeText.replace(/\r\n/g, "\n");
                        nodeText = nodeText.replace(/\r/g, "\n");
                        do {
                            var pos = nodeText.indexOf("\n");
                            if (pos >= 0) {
                                if (pos > 0) {
                                    parentNode.insertBefore(context.createTextNode(
                                            nodeText.substring(0, pos)), toProcess);
                                }
                                parentNode.insertBefore(context.createElement("br"),
                                        toProcess);
                                nodeText = nodeText.substring(pos + 1, nodeText.length);
                            }
                        } while (pos >= 0);
                        if (nodeText.length == 0) {
                            parentNode.removeChild(toProcess);
                        } else {
                            toProcess.nodeValue = nodeText;
                        }
                    } else if (toProcess.nodeType == 1) {
                        var childCnt = toProcess.childNodes.length;
                        for (var c = childCnt - 1; c >= 0; c--) {
                            recurse(toProcess.childNodes[c]);
                        }
                    }
                };
                recurse(dom);
                // remove trailing br (if there is one), as it is implied by the closing
                // pre tag
                var lastTextChild = com.getLastTextChild(dom, true, false);
                if (com.isTag(lastTextChild, "br")) {
                    var predesc = com.getPreviousCharacterNode(context, lastTextChild,
                            com.EDITBLOCK_TAGS);
                    if (com.isTag(predesc, "br")) {
                        if (com.ua.isGecko || com.ua.isWebKit) {
                            com.setAttribute(lastTextChild, com.BR_TEMP_ATTRIB, "brEOB");
                        } else if (com.ua.isIE) {
                            lastTextChild.parentNode.removeChild(lastTextChild);
                            CUI.rte.DomProcessor.fixEmptyLinefeedIE(context, predesc);
                        }
                    } else {
                        lastTextChild.parentNode.removeChild(lastTextChild);
                    }
                }
            }
        } else {
            // change "\n"'s into "br"s inside "pre" blocks, as browsers tend to be more
            // stable when linefeeds are still represented as "br" while editing
            // (counterpart is in handlePreformattedSection)
            if (com.isTag(dom, "br")
                    && com.getTagInPath(this.context, dom, "pre")) {
                this.elementsToChange.push({
                    "domToChange": dom,
                    "changedDom": this.context.createTextNode("\n")
                });
            }
        }
    },

    /**
     * <p>Handles empty lines at the end of blocks for the browsers that require it
     * (currently WebKit and Gecko).</p>
     * <p>Additional "br" tags get removed on reverse cleanup again (see isValidElement).
     * </p>
     * @param {HTMLElement} dom The
     */
    handleEmptyLinesAtEOB: function(dom) {
        var com = CUI.rte.Common;
        var dpr = CUI.rte.DomProcessor;
        var brReplacement;
        if (this.isPreProcessing()) {
            var text = com.getNodeText(dom);
            if ((text == dpr.NBSP) && dpr.isBlockEnd(this.context, dom))   {
                if (com.ua.isWebKit || com.ua.isGecko) {
                    // Gecko/WebKit: replace &nbsp;s that are placeholders for empty lines
                    // at the end of a block by appropriately marked additional <br>s
                    brReplacement = this.context.createElement("br");
                    com.setAttribute(brReplacement, com.BR_TEMP_ATTRIB, "brEOB");
                    this.elementsToChange.push({
                        "domToChange": dom,
                        "changedDom": brReplacement
                    });
                } else if (com.ua.isIE) {
                    // IE: remove &nbsp;s that are placeholders for empty blocks
                    var prevNode = com.getPreviousCharacterNode(this.context, dom,
                            com.EDITBLOCK_TAGS);
                    if (com.isTag(prevNode, "br")) {
                        // placeholder for empty line at the end of an empty block
                        this.markForRemoval(dom);
                        dpr.fixEmptyLinefeedIE(this.context, prevNode);
                    } else if (!prevNode) {
                        this.markForRemoval(dom);
                        var block = dpr.getEditBlock(this.context, dom);
                        this.emptyBlocksIE.push(block);
                    }
                }
            }
        } else {
            if (com.ua.isGecko || com.ua.isWebKit) {
                // Gecko/Webkit: Remove unnecessary <br> nodes; replace them by &nbsp;s
                // if they are placeholders for empty lines at the end of a block;
                // "br"s in "pre" areas are handled in handlePreformattedSection()
                if (com.isTag(dom, "br") && !com.getTagInPath(this.context, dom, "pre")) {
                    var editBlock = com.getTagInPath(this.context, dom, com.EDITBLOCK_TAGS);
                    var isEmptyBlock =
                            editBlock && (com.getCharacterNodes(editBlock).length == 1);
                    if (isEmptyBlock) {
                        this.markForRemoval(dom);
                    } else {
                        var isMarkedDirty = com.isAttribDefined(dom, com.BR_TEMP_ATTRIB)
                                || com.hasAttributes(dom, { "type": "_moz" });
                        if (isMarkedDirty && dpr.isBlockEnd(this.context, dom)) {
                            this.elementsToChange.push({
                                "domToChange": dom,
                                "changedDom": this.context.createTextNode(dpr.NBSP)
                            });
                        }
                    }
                }
            } else if (com.ua.isIE) {
                // IE: Add &nbsp; if required
                if (com.isTag(dom, "br") && dpr.isBlockEnd(this.context, dom)) {
                    var nbsp = this.context.createTextNode(dpr.NBSP);
                    this.markForInsertion(nbsp, dom.parentNode);
                }
            }
        }
    },

    /**
     * Enforces HTML rules on the specified DOM element.
     * @param {HTMLElement} dom The DOM element to apply rules to
     * @return {Boolean} True if the DOM element was marked for removal
     */
    applyHtmlRules: function(dom) {
        // todo maybe we should move an extended version of this method to HtmlRules for common use?
        var com = CUI.rte.Common;
        // adjust tag names to more appropriate (regarding editing) tag names if
        // necessary
        var tagName = dom.tagName.toLowerCase();
        var changedTagName = (this.isPreProcessing() ?
            this.htmlRules.docType.adjustToRaw(tagName)
            : this.htmlRules.docType.adjustToDocType(tagName));
        var changedDom;
        if (changedTagName != null) {
            if (changedTagName.length > 0) {
                changedDom = this.context.createElement(changedTagName);
                this.elementsToChange.push({
                    "domToChange": dom,
                    "changedDom": changedDom
                });
            } else { //#37049 - remove blacklisted tags
                this.elementsToRemove.push(dom);
                return true;
            }
            return false;
        }
        if (this.isPreProcessing()) {
            // handle links (add attributes as specified by rules, remove links with invalid
            // HREFs)
            if (com.isTag(dom, "a")) {
                var href = com.getAttribute(dom, "href");
                if (href) {
                    if (this.htmlRules.links.validateHref(href)) {
                        this.htmlRules.links.applyToObject(dom);
                        return false;
                    } else {
                        this.markForRemoval(dom);
                        return true;
                    }
                }
            }
        }
        return false;
    },

    /**
     * <p>Handles alignment for the specified DOM element.</p>
     * <p>It is ensured that for several block tags the "style" attribute is used rather
     * than the "align" attribute (due to editing restrictions of several browsers).</p>
     * @param {HTMLElement} dom The DOM element to process
     */
    handleAlignment: function(dom) {
        var com = CUI.rte.Common;
        // currently, we only do this for div/p tags
        var tagsToHandle = [ "p", "div" ];
        if (com.isTag(dom, tagsToHandle)) {
            if (this.isPreProcessing()) {
                var alignAttrib = com.getAttribute(dom, "align", true);
                if (alignAttrib) {
                    com.removeAttribute(dom, "align");
                    dom.style.textAlign = alignAttrib;
                }
            }
        }
    },

    /**
     * <p>Handles "a" elements.</p>
     * <p>For named anchors, this means that a suitable CSS class is applied or removed.
     * Additionally, the DOM will be changed to meet editing requirements if necessary.</p>
     * <p>For links, a RTE-specific property is added that holds the original HREF. On
     * postprocessing, this RTE-specific property is moved to the HREF attribute again.</p>
     * <p>You can specify any DOM element, as the element is checked before it is
     * actually processed.</p>
     * @param {HTMLElement} dom The DOM element
     */
    handleAnchor: function(dom) {
        var com = CUI.rte.Common;
        var dcu = CUI.rte.DomCleanup;
        var nameAttrib;
        if (com.isTag(dom, "a")) {
            nameAttrib = com.getAttribute(dom, "name", true);
            var hrefAttrib = CUI.rte.HtmlRules.Links.getLinkHref(dom);
            if (nameAttrib) {
                if (this.isPreProcessing()) {
                    // change <a name="bla">text</a> to <a name="bla"></a>text
                    var children = dom.childNodes;
                    var parentDom = dom.parentNode;
                    var insertRef = dom.nextSibling;
                    while (children.length > 0) {
                        com.insertBefore(parentDom, children[0], insertRef);
                    }
                    if (!com.ua.isWebKit) {
                        com.addClass(dom, CUI.rte.Theme.ANCHOR_CLASS);
                    } else {
                        var imgReplacement = this.context.createElement("img");
                        com.setAttribute(imgReplacement, "src",
                                CUI.rte.Utils.getBlankImageUrl());
                        com.setAttribute(imgReplacement, com.A_NAME_REPLACEMENT_ATTRIB,
                                nameAttrib);
                        com.addClass(imgReplacement, CUI.rte.Theme.ANCHOR_CLASS);
                        this.elementsToChange.push({
                            "domToChange": dom,
                            "changedDom": imgReplacement
                        });
                    }
                } else if (this.processingMode == dcu.POST) {
                    com.removeClass(dom, CUI.rte.Theme.ANCHOR_CLASS);
                }
            }
            if (hrefAttrib) {
                if (this.processingMode == dcu.PASTE_PREPARE) {
                    var helperAttrib = com.getAttribute(dom, com.HREF_ATTRIB);
                    if (!helperAttrib) {
                        com.setAttribute(dom, com.HREF_ATTRIB, hrefAttrib);
                    }
                }
            }
        } else if (com.ua.isWebKit && com.isTag(dom, "img")
                && com.isAttribDefined(dom, com.A_NAME_REPLACEMENT_ATTRIB)) {
            if (!this.isPreProcessing()) {
                var anchorDom = this.context.createElement("a");
                nameAttrib = com.getAttribute(dom, com.A_NAME_REPLACEMENT_ATTRIB);
                com.setAttribute(anchorDom, "name", nameAttrib);
                this.elementsToChange.push({
                    "domToChange": dom,
                    "changedDom": anchorDom
                });
            }
        }
    },

    /**
     * <p>Handles images.</p>
     * <p>Here, the SRC-attribute is doubled for editing, as browser do nasty things with
     * it.</p>
     * <p>You can specify any DOM element, as the element is checked before it is
     * actually processed.</p>
     * @param {HTMLElement} dom The DOM element
     */
    handleImage: function(dom) {
        var com = CUI.rte.Common;
        var dcu = CUI.rte.DomCleanup;
        if (com.isTag(dom, "img")) {
            var srcAttrib;
            if ((this.processingMode == dcu.PRE) && com.isTag(dom, "img")) {
                srcAttrib = com.getAttribute(dom, CUI.rte.Common.SRC_ATTRIB);
                srcAttrib = (srcAttrib ? srcAttrib : com.getAttribute(dom, "src", true));
                com.setAttribute(dom, "src", CUI.rte.Utils.processUrl(srcAttrib,
                        CUI.rte.Utils.URL_IMAGE));
            }
            if (this.processingMode == dcu.PASTE_PREPARE) {
                srcAttrib = com.getAttribute(dom, "src", true);
                if (srcAttrib) {
                    var helperAttrib = com.getAttribute(dom, CUI.rte.Common.SRC_ATTRIB);
                    if (!helperAttrib) {
                        com.setAttribute(dom, CUI.rte.Common.SRC_ATTRIB,
                                CUI.rte.HtmlRules.removePrefixForInternalLinks(srcAttrib));
                    }
                }
            }
        }
    },

    /**
     * <p>Handles tables.</p>
     * <p>In this case, table without a border get a class added that makes the border
     * temporarily visible for editing.</p>
     * <p>You can specify any DOM element, as the element is checked before it is
     * actually processed.</p>
     * @param {HTMLElement} dom The DOM element
     */
    handleTable: function(dom) {
        var com = CUI.rte.Common;
        var dcu = CUI.rte.DomCleanup;
        if (com.isTag(dom, "table")) {
            var borderAttrib = com.getAttribute(dom, "border", true);
            var hasBorder = false;
            if (borderAttrib) {
                try {
                    hasBorder = (parseInt(borderAttrib) > 0);
                } catch (e) {
                    // ignore, as we can't do anything about it
                }
            }
            if (!hasBorder) {
                if (this.isPreProcessing()) {
                    com.addClass(dom, CUI.rte.Theme.TABLE_NOBORDER_CLASS);
                } else if (this.processingMode == dcu.POST) {
                    com.removeClass(dom, CUI.rte.Theme.TABLE_NOBORDER_CLASS);
                }
            }
        } else if (com.isTag(dom, [ "td", "th"] )) {
            if (this.processingMode == dcu.POST) {
                com.removeClass(dom, CUI.rte.Theme.TABLESELECTION_CLASS);
            }
        }
    },

    /**
     * <p>Handles lists.</p>
     * <p>It is ensured that nested lists are correctly structured.</p>
     * @param {HTMLElement} dom The DOM element
     */
    handleList: function(dom) {
        var com = CUI.rte.Common;
        var lut = CUI.rte.ListUtils;
        if (com.isTag(dom, com.LIST_TAGS)) {
            if (lut.isTopLevelList(this.context, dom)) {
                var listProcessor = new CUI.rte.ListRepresentation();
                listProcessor.fromItem(this.context, dom);
                listProcessor.ensureHierarchy(this.context);
            }
        }
    },

    /**
     * <p>Handles style information in the style attribute of span elements.</p>
     * @param {HTMLElement} dom The DOM element
     */
    handleSpanStyles: function(dom) {
        var com = CUI.rte.Common;
        if (this.isPreProcessing()) {
            if (com.isTag(dom, "span")) {
                var changedDom, changeDef;
                if (dom.style.fontWeight == "bold") {
                    changedDom = this.context.createElement("b");
                    changeDef = {
                        "domToChange": dom,
                        "changedDom": changedDom
                    };
                }
                if (dom.style.fontStyle == "italic") {
                    var italicDom = this.context.createElement("i");
                    if (changedDom) {
                        changedDom.appendChild(italicDom);
                        changeDef.childDom = italicDom;
                    } else {
                        changedDom = italicDom;
                        changeDef = {
                            "domToChange": dom,
                            "changedDom": changedDom
                        };
                    }
                }
                if (dom.style.textDecoration == "underline") {
                    var underlineDom = this.context.createElement("u");
                    if (changedDom) {
                        if (changeDef.childDom) {
                            changeDef.childDom.appendChild(underlineDom);
                        } else {
                            changedDom.appendChild(underlineDom);
                        }
                        changeDef.childDom = underlineDom;
                    } else {
                        changedDom = underlineDom;
                        changeDef = {
                            "domToChange": dom,
                            "changedDom": changedDom
                        };
                    }
                }
                if (changeDef) {
                    this.elementsToChange.push(changeDef);
                }
            }
        }
    },

    /**
     * This method handles several specific tags.
     * @param {HTMLElement} dom The DOM element
     */
    handleSpecificTags: function(dom) {
        this.handleAlignment(dom);
        this.handleAnchor(dom);
        this.handleImage(dom);
        this.handleTable(dom);
        this.handleSpanStyles(dom);
        this.handleList(dom);
        this.handlePreformattedSection(dom);
    },

    /**
     * This method handles empty content.
     * @param {HTMLElement} rootDom The root DOM
     */
    handleEmptyContent: function(rootDom) {
        var com = CUI.rte.Common;
        var dpr = CUI.rte.DomProcessor;
        var dcu = CUI.rte.DomCleanup;
        if (this.processingMode == dcu.PRE) {
            if (rootDom.childNodes.length == 0) {
                var placeholder = dpr.createEmptyLinePlaceholder(this.context, true,
                        this.htmlRules.blockHandling.defaultEditBlockType);
                rootDom.appendChild(placeholder);
            } else if (rootDom.childNodes.length == 1) {
                // newer Firefox versions automatically change an empty string set as
                // innerHTML into a single <br> node (which is corrected into <p><br></p>
                // by handleContainerRules
                var blockNode = rootDom.childNodes[0];
                var textNodes = com.getCharacterNodes(blockNode);
                if ((textNodes.length == 1) && com.isTag(textNodes[0], "br")) {
                    com.setAttribute(textNodes[0], com.BR_TEMP_ATTRIB, "brEOB");
                }
            }
        } else if (this.processingMode == dcu.POST) {
            if (rootDom.childNodes.length == 1) {
                var singleChild = rootDom.childNodes[0];
                if (com.isTag(singleChild, com.EDITBLOCK_TAGS)) {
                    if (dpr.isEmptyLineBlock(singleChild)) {
                        rootDom.removeChild(singleChild);
                    }
                }
            }
        }
    },


    /**
     * Handles container-related HTML rules, such as removing the block around a single
     * content block if configured accordingly.
     * @param {HTMLElement} rootDom The root DOM
     */
    handleContainerRules: function(rootDom) {
        var com = CUI.rte.Common;
        var dpr = CUI.rte.DomProcessor;
        var dcu = CUI.rte.DomCleanup;
        var blockRules = this.htmlRules.blockHandling;
        var defaultEditBlock = blockRules.defaultEditBlockType;
        var blockRepTag = blockRules.singleParagraphContainerReplacement;
        if (this.processingMode == dcu.PRE) {
            dpr.ensureBlockContent(this.context, defaultEditBlock, null, false, false);
            dpr.adjustTables(this.context);
            var fixIECnt = this.emptyBlocksIE.length;
            for (var i = 0; i < fixIECnt; i++) {
                dpr.fixEmptyEditingBlockIE(this.context, this.emptyBlocksIE[i]);
            }
        } else if (this.processingMode == dcu.POST) {
            if (blockRules.removeSingleParagraphContainer) {
                var rootElCnt = rootDom.childNodes.length;
                if (rootElCnt == 1) {
                    var blockDom = rootDom.childNodes[0];
                    if (com.isTag(blockDom, defaultEditBlock)) {
                        var bStyle = blockDom.style;
                        var blockClass = com.getAttribute(blockDom, "class", true);
                        if (blockClass || bStyle.textAlign || bStyle.marginLeft) {
                            // change tag, as there are properties to keep on the single
                            // block
                            if (defaultEditBlock != blockRepTag) {
                                var newBlockDom = this.context.createElement(blockRepTag);
                                if (blockClass) {
                                    com.setAttribute(newBlockDom, "class", blockClass);
                                }
                                if (bStyle.textAlign) {
                                    newBlockDom.style.textAlign = bStyle.textAlign;
                                }
                                if (bStyle.marginLeft) {
                                    newBlockDom.style.marginLeft = bStyle.marginLeft;
                                }
                                com.replaceNode(blockDom, newBlockDom);
                            }
                        } else {
                            // nothing to keep, so we'll simply remove the single block
                            dpr.removeWithoutChildren(blockDom);
                        }
                    }
                }
            }
        }
    },


    // -- Additional paste processing ------------------------------------------------------

    /**
     * Checks if the specified element is allowed for tags and marks it for removal if not.
     * @param {HTMLElement} dom The element to check
     * @return {HTMLElement} The element or null if the element has been marked for removal
     */
    checkAllowedForPaste: function(dom) {
        var com = CUI.rte.Common;
        var markForRemoval = true;
        // tags that are always allowed
        var defaultAllowedTags = [ "br" ];
        // tags that are considered "basic tags"
        var basicTags = {
            "b": "bold", "i": "italic", "u": "underline", "a": "anchor",
            "img": "image", "sub": "subscript", "sup": "superscript"
        };
        var basicTagDef = null;
        if (this.pasteRules.allowBasics) {
            var tagNameLC = dom.tagName.toLowerCase();
            if (basicTags.hasOwnProperty(tagNameLC)) {
                basicTagDef = basicTags[tagNameLC];
            }
        }
        if (this.pasteRules.table) {
            if ((this.pasteRules.table.allow)
                    || (this.pasteRules.table.ignoreMode == "paragraph")) {
                defaultAllowedTags.push("table");
                defaultAllowedTags.push("tbody");
                defaultAllowedTags.push("tr");
                defaultAllowedTags.push("td");
                defaultAllowedTags.push("th");
            }
        }
        if (this.pasteRules.list) {
            if ((this.pasteRules.list.allow)
                    || (this.pasteRules.list.ignoreMode == "paragraph")) {
                defaultAllowedTags.push("ul");
                defaultAllowedTags.push("ol");
                defaultAllowedTags.push("li");
            }
        }
        if (basicTagDef != null) {
            markForRemoval = (this.pasteRules.allowBasics[basicTagDef] !== true);
        } else if (com.isTag(dom, defaultAllowedTags)) {
            markForRemoval = false;
        } else if (com.isTag(dom, com.BLOCK_TAGS)) {
            // block tags are handled differently
            markForRemoval = false;
        } else if (com.isTag(dom, "span") && (com.parseCSS(dom).length > 0)) { // exception for span if it has css classes assigned
            markForRemoval = false
        }
        if (markForRemoval) {
            this.elementsToRemove.push(dom);
            return null;
        }
        return dom;
    },

    /**
     * Applies table-specific paste-rules.
     * @param {HTMLElement} dom The table's DOM element
     * @return {HTMLElement} The DOM element to continue processing with
     */
    handleTablesOnPaste: function(dom) {
        var com = CUI.rte.Common;
        var tableRules = this.pasteRules.table;
        if (tableRules.allow) {
            return dom;
        }
        if (tableRules.ignoreMode == "remove") {
            // delete child nodes directly to avoid unnecessary processing, and mark
            // table itself for removal
            com.removeAllChildren(dom);
            this.markForRemoval(dom);
            return dom;
        }
        return this.flattenNestedStructure(dom, com.TABLE_CELLS, "table");
    },

    /**
     * Applies list-specific paste-rules.
     * @param {HTMLElement} dom The table's DOM element
     * @return {HTMLElement} The DOM element to continue processing with
     */
    handleListsOnPaste: function(dom) {
        var com = CUI.rte.Common;
        var listRules = this.pasteRules.list;
        if (listRules.allow) {
            return dom;
        }
        if (listRules.ignoreMode == "remove") {
            // delete child nodes directly to avoid unnecessary processing, and mark
            // list itself for removal
            com.removeAllChildren(dom);
            this.markForRemoval(dom);
            return dom;
        }
        return this.flattenNestedStructure(dom, "li", com.LIST_TAGS);
    },

    /**
     * Checks if the specified DOM element is a block tag and changes it according to the
     * paste rules if necessary.
     * @param {HTMLElement} dom The DOM element
     */
    handleBlockTagsOnPaste: function(dom) {
        var com = CUI.rte.Common;
        if (com.isTag(dom, com.BLOCK_TAGS)) {
            var tagNameLC = dom.tagName.toLowerCase();
            // tables and lists must be handled specifically if a rule is available
            if (com.isTag(dom, "table") && this.pasteRules.table) {
                return this.handleTablesOnPaste(dom);
            }
            if (com.isTag(dom, com.LIST_TAGS) && this.pasteRules.list) {
                return this.handleListsOnPaste(dom);
            }
            var mustChange = true;
            if (this.pasteRules.allowBlockTags) {
                mustChange = !com.arrayContains(this.pasteRules.allowBlockTags, tagNameLC);
            }
            if (mustChange) {
                var fallbackTag = this.pasteRules.fallbackBlockTag || "p";
                var changedDom = this.context.createElement(fallbackTag);
                this.elementsToChange.push({
                    "domToChange": dom,
                    "changedDom": changedDom
                });
            }
        }
    },

    /**
     * Handles "class" attributes of elements due to the paste rules defined.
     * @param {HTMLElement} dom The DOM element
     */
    handleCssClassesOnPaste: function(dom) {
        var com = CUI.rte.Common;
        var cssMode = (this.pasteRules.cssMode || "remove");
        var cssClasses = com.parseCSS(dom);
        if (cssClasses && (cssClasses.length > 0)) {
            switch (cssMode) {
                case "remove":
                    com.removeAttribute(dom, "class");
                    break;
                case "whitelist":
                    var allowedClasses = this.pasteRules.allowedCssNames || [ ];

                    // get allowed classes from plugin
                    if(this.editorKernel.registeredPlugins.styles) {
                        var style,
                            stylesFromPlugin = this.editorKernel.registeredPlugins.styles.getStyles() || [];

                        for (var i=0; i < stylesFromPlugin.length; i++) {
                            allowedClasses.push(stylesFromPlugin[i].cssName);
                        }
                    }

                    var classCnt = cssClasses.length;
                    for (var c = 0; c < classCnt; c++) {
                        var classToCheck = cssClasses[c];
                        if (!com.arrayContains(allowedClasses, classToCheck)) {
                            com.removeClass(dom, classToCheck);
                        }
                    }
                    break;
            }
        }
    },

    /**
     * Compiles a RegExp object from the specified parameter if it is a String.
     * @param {String|RegExp} regex The potential regular expression
     */
    manageRegEx: function(regex) {
        // do it in a separate method to avoid potential leak
        if (typeof(regex) == "string") {
            regex = eval(regex);
        }
        return regex;
    },

    /**
     * Executes several security checks on the specified DOM element according to the
     * defined paste rules.
     * @param {HTMLElement} dom The DOM element
     * @return {HTMLElement} The DOM element or null if the element has been marked for
     *         removal
     */
    handleSecurity: function(dom) {
        var com = CUI.rte.Common;
        // execute link verification
        if (com.isTag(dom, "a")) {
            var hrefAttrib = com.getAttribute(dom, "href", true);
            if (hrefAttrib && this.pasteRules.linkRemoveRegEx) {
                var regex = this.manageRegEx(this.pasteRules.linkRemoveRegEx);
                if (regex) {
                    if (hrefAttrib.search(regex) >= 0) {
                        this.markForRemoval(dom);
                        return null;
                    }
                }
            }
        }
        return dom;
    },

    /**
     * Removes attributes that are not allowed.
     * @param {HTMLElement} dom The DOM element
     */
    handleAttributes: function(dom) {
        var com = CUI.rte.Common;
        var attribs = com.getAttributeNames(dom);
        var globalAllowed = null;
        var tagAllowed = null;
        var tagNameLC = dom.tagName.toLowerCase();
        if (this.pasteRules.allowedAttributes) {
            globalAllowed = this.pasteRules.allowedAttributes["*"];
            tagAllowed = this.pasteRules.allowedAttributes[tagNameLC];
        }
        var attribCnt = attribs.length;
        for (var a = 0; a < attribCnt; a++) {
            var attribName = attribs[a];
            var isAllowed = false;
            if (globalAllowed && com.arrayContains(globalAllowed, attribName)) {
                isAllowed = true;
            }
            if (tagAllowed && com.arrayContains(tagAllowed, attribName)) {
                isAllowed = true;
            }
            if (!isAllowed) {
                com.removeAttribute(dom, attribName);
            }
        }
    },

    /**
     * <p>This method handles the preprocessing for pasted HTML content.</p>
     * <p>It may be called in any processing mode.</p>
     * @param {HTMLElement} dom The DOM element to be processed
     * @return {HTMLElement} The DOM element to continue processing with
     */
    handlePasteProcessing: function(dom) {
        var dcu = CUI.rte.DomCleanup;
        var originalDom = dom;
        if ((this.mode = dcu.PASTE_PREPARE) && (this.pasteRules != null)) {
            if (dom) {
                dom = this.handleSecurity(dom);
            }
            if (dom) {
                this.handleBlockTagsOnPaste(dom);
                this.handleCssClassesOnPaste(dom);
                this.handleAttributes(dom);
            }
            dom = this.checkAllowedForPaste(dom);
        }
        // continue with original DOM if element has been marked for removal
        return dom || originalDom;
    },


    // -- Processing -----------------------------------------------------------------------

    /**
     * Optimize the tree (executes operations that can't be efficiently processed
     * in the event-driven manner the DomCleanup else works).
     * @param {HTMLElement} root The root element
     */
    optimizeTree: function(root) {

        var com = CUI.rte.Common;

        function optimizeNode(dom, joinableTags) {
            if (com.isTag(dom, joinableTags)) {
                var isDone = false;
                do {
                    var nextDom = dom.nextSibling;
                    if (nextDom) {
                        if (com.equals(dom, nextDom)) {
                            com.moveChildren(nextDom, dom, 0, true);
                            nextDom.parentNode.removeChild(nextDom);
                        } else {
                            isDone = true;
                        }
                    } else {
                        isDone = true;
                    }
                } while (!isDone);
            }
            if (dom.nodeType === 1) {
                for (var c = 0; c < dom.childNodes.length; c++) {
                    optimizeNode(dom.childNodes[c], joinableTags);
                }
            }
        }

        if (!this.isPreProcessing()) {
            var optimizable = [
                "b", "i", "u", "big", "small", "strong", "em", "sub", "sup", "span"
            ];
            optimizeNode(root, optimizable);
        }
    },

    /**
     * Traverses the specified sub-tree recursively.
     * @param {HTMLElement} dom Root element of the sub-tree
     * @param {Boolean} isRoot True if we are at the root node of the entire traversal
     */
    traverse: function(dom, isRoot) {
        var ignoreRecursion = false;
        if (!isRoot) {
            if (dom.nodeType == 1) {
                if (!this.isValidSubTree(dom)) {
                    this.markSubTreeForRemoval(dom);
                    ignoreRecursion = true;
                } else if (!this.isValidElement(dom)) {
                    this.markForRemoval(dom);
                } else {
                    // paste processing works as a "pre-filter"
                    dom = this.handlePasteProcessing(dom);
                    var isRemoved = false;
                    if (this.htmlRules) {
                        isRemoved = this.applyHtmlRules(dom);
                    }
                    if (!isRemoved) {
                        this.handleSpecificTags(dom);
                    }
                }
            }
            this.handleEmptyLinesAtEOB(dom);
        }
        if (!ignoreRecursion) {
            var children = dom.childNodes;
            for (var c = 0; c < children.length; c++) {
                this.traverse(children[c], false);
            }
        }
    },

    /**
     * Removes elements that were marked for removal while traversing the DOM tree.
     */
    removeElements: function() {
        var dpr = CUI.rte.DomProcessor;
        var removeCnt = this.elementsToRemove.length;
        for (var r = 0; r < removeCnt; r++) {
            dpr.removeWithoutChildren(this.elementsToRemove[r]);
        }
        this.elementsToRemove.length = 0;
        removeCnt = this.subTreesToRemove.length;
        for (r = 0; r < removeCnt; r++) {
            var toRemove = this.subTreesToRemove[r];
            if (toRemove.parentNode) {
                toRemove.parentNode.removeChild(toRemove);
            }
        }
        this.subTreesToRemove.length = 0;
    },

    /**
     * Replaces elements that were marked accordingly while traversing the DOM tree.
     */
    replaceElements: function() {
        var com = CUI.rte.Common;
        var replaceCnt = this.elementsToChange.length;
        for (var r = 0; r < replaceCnt; r++) {
            var changeDef = this.elementsToChange[r];
            var toChange = changeDef.domToChange;
            com.replaceNode(toChange, changeDef.changedDom, changeDef.childDom);
            // if element was marked for removal, we'll have to remove it from that list
            // as we'd otherwise provoke an exception
            for (var rm = 0; rm < this.elementsToRemove.length; rm++) {
                if (this.elementsToRemove[rm] == toChange) {
                    this.elementsToRemove.splice(rm, 1);
                    break;
                }
            }
        }
    },

    /**
     * Inserts the elements that were marked accordingly while traversing the DOM tree.
     */
    insertElements: function() {
        var com = CUI.rte.Common;
        var insertCnt = this.elementsToInsert.length;
        for (var i = 0; i < insertCnt; i++) {
            var changeDef = this.elementsToInsert[i];
            var toInsert = changeDef.domToInsert;
            var parentDom = changeDef.parentDom;
            var siblingRef = changeDef.refDom;
            if (siblingRef) {
                parentDom.insertBefore(toInsert, siblingRef);
            } else {
                parentDom.appendChild(toInsert);
            }
        }
    },


    // -- "Interface"/Implementation -------------------------------------------------------

    /**
     * Executes the DOM cleanup (used by each of the processing methods).
     * @param {CUI.rte.EditorKernel} editorKernel The editor representation
     * @param {HTMLElement} rootDom The root element to begin cleanup with
     * @private
     */
    execute: function(editorKernel, rootDom) {
        // init
        this.editorKernel = editorKernel;
        this.context = editorKernel.getEditContext();
        this.htmlRules = editorKernel.getHtmlRules();

        function clear(array) {
            if (array) {
                array.length = 0;
                return array;
            }
            return [ ];
        }

        this.elementsToRemove = clear(this.elementsToRemove);
        this.subTreesToRemove = clear(this.subTreesToRemove);
        this.elementsToChange = clear(this.elementsToChange);
        this.elementsToInsert = clear(this.elementsToInsert);
        this.emptyBlocksIE = clear(this.emptyBlocksIE);

        // actually execute
        this.traverse(rootDom, true);
        this.insertElements();
        this.replaceElements();
        this.removeElements();
        this.optimizeTree(rootDom);
        this.handleContainerRules(rootDom);
        this.handleEmptyContent(rootDom);
    },

    /**
     * Executes DOM-based preprocessing on the specified root node.
     * @param {CUI.rte.EditorKernel} editorKernel The editor representation
     * @param {HTMLElement} rootDom The root node
     */
    preprocess: function(editorKernel, rootDom) {
        this.processingMode = CUI.rte.DomCleanup.PRE;
        this.execute(editorKernel, rootDom);
    },

    /**
     * Executes DOM-based postprocessing on the specified root node.
     * @param {CUI.rte.EditorKernel} editorKernel The editor representation
     * @param {HTMLElement} rootDom The root node
     */
    postprocess: function(editorKernel, rootDom) {
        this.processingMode = CUI.rte.DomCleanup.POST;
        this.execute(editorKernel, rootDom);
    },

    /**
     * Executes DOM-based preprocessing of HTML content that was pasted from a potentially
     * unknown source.
     * @param {CUI.rte.EditorKernel} editorKernel The editor representation
     * @param {HTMLElement} rootDom The root node
     * @param {Object} pasteRules The rules to be applied for pasted content
     */
    prepareHtmlPaste: function(editorKernel, rootDom, pasteRules) {
        this.processingMode = CUI.rte.DomCleanup.PASTE_PREPARE;
        this.pasteRules = pasteRules;
        this.execute(editorKernel, rootDom);
    }

});


/**
 * Mode: Preprocessing (= persisted to editable state)
 */
CUI.rte.DomCleanup.PRE = 0;

/**
 * Mode: Postprocessing (= edited to a pesistable state)
 */
CUI.rte.DomCleanup.POST = 1;

/**
 * Mode: Preprocessing of HTML content pasted from anywhere
 */
CUI.rte.DomCleanup.PASTE_PREPARE = 2;