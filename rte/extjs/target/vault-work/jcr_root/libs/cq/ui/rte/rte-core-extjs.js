/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

window.CUI = window.CUI || { };
CUI.rte = CUI.rte || {};
CUI.rte.commands = {};
CUI.rte.plugins = {};
CUI.rte.adapter = {};
CUI.rte.ui = {};
CUI.rte.ui.ext = {};
CUI.rte.ui.cui = {};
CUI.rte.ui.stub = {};

/**
  Crockford's new_constructor pattern, modified to allow walking the prototype chain, automatic constructor/destructor chaining, easy toString methods, and syntactic sugar for calling superclass methods

  @see Base

  @function

  @param {Object} descriptor                        Descriptor object
  @param {String or Function} descriptor.toString   A string or method to use for the toString of this class and instances of this class
  @param {Object} descriptor.extend                 The class to extend
  @param {Function} descriptor.construct            The constructor (setup) method for the new class
  @param {Function} descriptor.destruct             The destructor (teardown) method for the new class
  @param {Mixed} descriptor.*                       Other methods and properties for the new class

  @returns {Base} The created class.
*/
var Class;

(function() {
  /**
    @name Base

    @classdesc The abstract class which contains methods that all classes will inherit.
    Base cannot be extended or instantiated and does not exist in the global namespace.
    If you create a class using <code class="prettyprint">new Class()</code> or <code class="prettyprint">MyClass.extend()</code>, it will come with Base' methods.

    @desc Base is an abstract class and cannot be instantiated directly. Constructors are chained automatically, so you never need to call the constructor of an inherited class directly
    @constructs

    @param {Object} options  Instance options. Guaranteed to be defined as at least an empty Object
   */

  /**
    Binds a method of this instance to the execution scope of this instance.

    @name bind
    @memberOf Base.prototype
    @function

    @param {Function} func The this.method you want to bind
   */
  var bindFunc = function(func) {
    // Bind the function to always execute in scope
    var boundFunc = func.bind(this);

    // Store the method name
    boundFunc._methodName = func._methodName;

    // Store the bound function back to the class
    this[boundFunc._methodName] = boundFunc;

    // Return the bound function
    return boundFunc;
  };

  /**
    Extends this class using the passed descriptor.
    Called on the Class itself (not an instance), this is an alternative to using <code class="prettyprint">new Class()</code>.
    Any class created using Class will have this static method on the class itself.

    @name extend
    @memberOf Base
    @function
    @static

    @param {Object} descriptor                        Descriptor object
    @param {String or Function} descriptor.toString   A string or method to use for the toString of this class and instances of this class
    @param {Object} descriptor.extend                 The class to extend
    @param {Function} descriptor.construct            The constructor (setup) method for the new class
    @param {Function} descriptor.destruct             The destructor (teardown) method for the new class
    @param {Anything} descriptor.*                    Other methods and properties for the new class
   */
  var extendClass = function(descriptor) {
    return new Class(_.extend({}, descriptor, {
      extend: this
    }));
  };

  Class = function(descriptor) {
    descriptor = descriptor || {};

    if (descriptor.hasOwnProperty('extend') && !descriptor.extend) {
      console.warn('Class: %s is attempting to extend a non-truthy thing', descriptor.toString === 'function' ? descriptor.toString : descriptor.toString, descriptor.extend);
    }

    // Extend Object by default
    var extend = descriptor.extend || Object;

    // Construct and destruct are not required
    var construct = descriptor.construct;
    var destruct = descriptor.destruct;

    // Remove special methods and keywords from descriptor
    delete descriptor.bind;
    delete descriptor.extend;
    delete descriptor.destruct;
    delete descriptor.construct;

    // Add toString method, if necessary
    if (descriptor.hasOwnProperty('toString') && typeof descriptor.toString !== 'function') {
      // Return the string provided
      var classString = descriptor.toString;
      descriptor.toString = function() {
        return classString.toString();
      };
    }
    else if (!descriptor.hasOwnProperty('toString') && extend.prototype.hasOwnProperty('toString')) {
      // Use parent's toString
      descriptor.toString = extend.prototype.toString;
    }

    // The remaining properties in descriptor are our methods
    var methodsAndProps = descriptor;

    // Create an object with the prototype of the class we're extending
    var prototype = Object.create(extend && extend.prototype);

    // Store super class as a property of the new class' prototype
    prototype.superClass = extend.prototype;

    // Copy new methods into prototype
    if (methodsAndProps) {
      for (var key in methodsAndProps) {
        if (methodsAndProps.hasOwnProperty(key)) {
          prototype[key] = methodsAndProps[key];

          // Store the method name so calls to inherited() work
          if (typeof methodsAndProps[key] === 'function') {
            prototype[key]._methodName = key;
            prototype[key]._parentProto = prototype;
          }
        }
      }
    }

    /**
      Call the superclass method with the same name as the currently executing method

      @name inherited
      @memberOf Base.prototype
      @function

      @param {Arguments} args  Unadulterated arguments array from calling function
     */
    prototype.inherited = function(args) {

      // Get the function that call us from the passed arguments objected
      var caller = args.callee;

      // Get the name of the method that called us from a property of the method
      var methodName = caller._methodName;

      if (!methodName) {
        console.error("Class.inherited: can't call inherited method: calling method did not have _methodName", args.callee);
        return;
      }

      // Start iterating at the prototype that this function is defined in
      var curProto = caller._parentProto;
      var inheritedFunc = null;

      // Iterate up the prototype chain until we find the inherited function
      while (curProto.superClass) {
        curProto = curProto.superClass;
        inheritedFunc = curProto[methodName];
        if (typeof inheritedFunc === 'function')
          break;
      }

      if (typeof inheritedFunc === 'function') {
        // Store our inherited function
        var oldInherited = this.inherited;

        // Overwrite our inherited function with that of the prototype so the called function can call its parent
        this.inherited = curProto.inherited;

        // Call the inherited function our scope, apply the passed args array
        var retVal = inheritedFunc.apply(this, args);

        // Revert our inherited function to the old function
        this.inherited = oldInherited;

        // Return the value called by the inherited function
        return retVal;
      }
      else {
        console.warn("Class.inherited: can't call inherited method for '%s': no method by that name found", methodName);
      }
    };

    // Add bind to the prototype of the class
    prototype.bind = bindFunc;

    /**
      Destroys this instance and frees associated memory. Destructors are chained automatically, so the <code class="prettyprint">destruct()</code> method of all inherited classes will be called for you

      @name destruct
      @memberOf Base.prototype
      @function
     */
    prototype.destruct = function() {
      // Call our destruct method first
      if (typeof destruct === 'function') {
        destruct.apply(this);
      }

      // Call superclass destruct method after this class' method
      if (extend && extend.prototype && typeof extend.prototype.destruct === 'function') {
        extend.prototype.destruct.apply(this);
      }
    };

    // Create a chained construct function which calls the superclass' construct function
    prototype.construct = function() {
      // Add a blank object as the first arg to the constructor, if none provided
      var args = arguments; // get around JSHint complaining about modifying arguments
      if (args[0] === undefined) {
        args.length = 1;
        args[0] = {};
      }

      // call superclass constructor
      if (extend && extend.prototype && typeof extend.prototype.construct === 'function') {
        extend.prototype.construct.apply(this, arguments);
      }

      // call constructor
      if (typeof construct === 'function') {
        construct.apply(this, arguments);
      }
    };

    // Create a function that generates instances of our class and calls our construct functions
    /** @ignore */
    var instanceGenerator = function() {
      // Create a new object with the prototype we built
      var instance = Object.create(prototype);

      // Call all inherited construct functions
      prototype.construct.apply(instance, arguments);

      return instance;
    };

    instanceGenerator.toString = prototype.toString;

    // Set the prototype of our instance generator to the prototype of our new class so things like MyClass.prototype.method.apply(this) work
    instanceGenerator.prototype = prototype;

    // Add extend to the instance generator for the class
    instanceGenerator.extend = extendClass;

    // The constructor, as far as JS is concerned, is actually our instance generator
    prototype.constructor = instanceGenerator;

    return instanceGenerator;
  };

  if (!Object.create) {
    /**
      Polyfill for Object.create. Creates a new object with the specified prototype.

      @author <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/create/">Mozilla MDN</a>

      @param {Object} prototype  The prototype to create a new object with
     */
    Object.create = function (prototype) {
      if (arguments.length > 1) {
        throw new Error('Object.create implementation only accepts the first parameter.');
      }
      function Func() {}
      Func.prototype = prototype;
      return new Func();
    };
  }

  if (!Function.prototype.bind) {
    /**
      Polyfill for Function.bind. Binds a function to always execute in a specific scope.

      @author <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind">Mozilla MDN</a>

      @param {Object} scope  The scope to bind the function to
     */
    Function.prototype.bind = function (scope) {
      if (typeof this !== "function") {
        // closest thing possible to the ECMAScript 5 internal IsCallable function
        throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
      }

      var aArgs = Array.prototype.slice.call(arguments, 1);
      var fToBind = this;
      /** @ignore */
      var NoOp = function() {};
      /** @ignore */
      var fBound = function() {
        return fToBind.apply(this instanceof NoOp ? this : scope, aArgs.concat(Array.prototype.slice.call(arguments)));
      };

      NoOp.prototype = this.prototype;
      fBound.prototype = new NoOp();

      return fBound;
    };
  }
}());

/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

CUI.rte.Eventing = function() {

    var handlerMap = [ ];

    return {

        on: function(editContext, obj, eventName, handler, scope, options) {
            var wrapper = function(extEvent) {
                var evt = new CUI.rte.adapter.ExtEvent(extEvent, editContext);
                handler.call(this, evt);
            };
            handlerMap.push({
                "handler": handler,
                "wrapper": wrapper
            });
            CQ.Ext.EventManager.on(obj, eventName, wrapper, scope, options);
        },

        un: function(obj, eventName, handler, scope) {
            var wrapper = null;
            for (var e = 0; e < handlerMap.length; e++) {
                if (handlerMap[e].handler === handler) {
                    wrapper = handlerMap[e].wrapper;
                    handlerMap.splice(e, 1);
                    break;
                }
            }
            if (wrapper == null) {
                throw new Error("Unregistered handler provided.");
            }
            CQ.Ext.EventManager.un(obj, eventName, wrapper, scope);
        }

    };

}();
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * This class represents basic editor-related events, such as keystrokes or mouseclicks.
 * @class CUI.rte.EditorEvent
 */
CUI.rte.EditorEvent = new Class({

    toString: "EditorEvent",

    /**
     * The event's type
     * @type String
     * @private
     */
    type: null,

    /**
     * The key (for key-related events)
     * @type String
     * @private
     */
    key: null,

    /**
     * The character code of the key (for key-related events)
     * @type Number
     * @private
     */
    charCode: 0,

    /**
     * Flag that determines if the "Meta" key was held when the event occured
     * @type Boolean
     * @private
     */
    metaKeyPressed: false,

    /**
     * Flag that determines if the "Control" key was held when the event occured
     * @type Boolean
     * @private
     */
    ctrlKeyPressed: false,

    /**
     * The mouse button (for events related to mouse clicks)
     * @type Number
     * @private
     */
    button: Math.NaN,

    /**
     * Property that is used to signal if the event was cancelled by a listener; if a
     * listener sets this to true, event bubbling will be stopped and the system's default
     * behaviour will be  prevented.
     * @property {Boolean} cancelKey
     */
    cancelKey: false,

    /**
     * The edit context for the event
     * @property {CUI.rte.EditContext} editContext
     */
    editContext: null,


    /**
     * Constructor substitution.
     * @private
     */
    _init: function(cfg) {
        CUI.rte.Utils.apply(this, cfg);
    },

    /**
     * Gets the event type.
     * @return {String} The type
     */
    getType: function() {
        return this.type;
    },

    /**
     * <p>Checks if the specified event represents a caret key (left, right, up, down).</p>
     * <p>Returns false for non key-related events.</p>
     * @return {Boolean} True if the specified event represents a caret key
     */
    isCaretKey: function() {
        throw new Error(
                "EditorEvent#isCaretKey must be overridden by the extending class.");
    },

    /**
     * <p>Checks if the specified event describes a caret movement (for example through
     * one of the caret movement keys or pageup/pagedown).</p>
     * <p>Returns false for non key-related events.</p>
     * @return {Boolean} True if the specified event describes a caret movement
     */
    isCaretMovement: function() {
        throw new Error(
                "EditorEvent#isCaretMovement must be overridden by the extending class.");
    },

    /**
     * <p>Gets the key that is connected to the event.</p>
     * <p>Only valid for key-related events; check {@link #getType()} first.</p>
     * @return {String} The key
     */
    getKey: function() {
        return this.key;
    },

    /**
     * <p>Gets the char code that is connected to the event.</p>
     * <p>Only valid for key-related events; check {@link #getType()} first.</p>
     * @return {Number} The char code
     */
    getCharCode: function() {
        return this.charCode;
    },

    /**
     * <p>Checks if the event is related to the Tab key.</p>
     * <p>For non key-related events, this will return false.</p>
     * @return {Boolean} true if the event is related to the Tab key
     */
    isTab: function() {
        throw new Error(
                "EditorEvent#isTab must be overridden by the extending class.");
    },

    /**
     * <p>Checks if the event is related to the Enter key.</p>
     * <p>For non key-related events, this will return false.</p>
     * @return {Boolean} true if the event is related to the Enter key
     */
    isEnter: function() {
        throw new Error(
                "EditorEvent#isEnter must be overridden by the extending class.");
    },

    /**
     * <p>Checks if the event is related to the Space key.</p>
     * <p>For non key-related events, this will return false.</p>
     * @return {Boolean} true if the event is related to the Space key
     */
    isSpace: function() {
        throw new Error(
                "EditorEvent#isSpace must be overridden by the extending class.");
    },

    /**
     * <p>Checks if the event is related to the Backspace key.</p>
     * <p>For non key-related events, this will return false.</p>
     * @return {Boolean} true if the event is related to the Backspace key
     */
    isBackSpace: function() {
        throw new Error(
                "EditorEvent#isBackSpace must be overridden by the extending class.");
    },

    /**
     * <p>Checks if the event is related to the Delete key.</p>
     * <p>For non key-related events, this will return false.</p>
     * @return {Boolean} true if the event is related to the Delete key
     */
    isDelete: function() {
        throw new Error(
                "EditorEvent#isDelete must be overridden by the extending class.");
    },

    /**
     * Determines if one of the Shift keys was held when the event originated.
     * @return {Boolean} True if one of the Shift keys was held
     */
    isShift: function() {
        return this.shiftKeyPressed;
    },

    /**
     * Determines if the Meta key was held when the event originated.
     * @return {Boolean} True if the Meta key was held
     */
    isMeta: function() {
        return this.metaKeyPressed;
    },

    /**
     * Determines if the Control key was held when the event originated.
     * @return {Boolean} True if the Control key was held
     */
    isCtrl: function() {
        return this.ctrlKeyPressed;
    },

    /**
     * <p>Determines the position of the mouse for the event.</p>
     * <p>Only valid for mouse-related events; check {@link #getType()} first.</p>
     * @return {Boolean} True if the Meta key was held
     */
    getPos: function() {
        return this.pos;
    },

    /**
     * <p>Determines the mouse's button state for the event.</p>
     * <p>Only valid for mouse-related events; check {@link #getType()} first.</p>
     * @return {Number} The mouse button held (0 for first/left mouse button)
     */
    getButton: function() {
        return this.button;
    },

    /**
     * Prevents the browser's default behaviour for this event.
     */
    preventDefault: function() {
        throw new Error(
                "EditorEvent#preventDefault must be overridden by the extending class.");
    },

    /**
     * Stops the propagation of the event to parent DOM elements.
     */
    stopPropagation: function() {
        throw new Error(
                "EditorEvent#stopPropagation must be overridden by the extending class.");
    },

    /**
     * Stops the event - shortcut for both preventing the browser's default behaviour and
     * bubbling up to parent elements.
     */
    stopEvent: function() {
        throw new Error(
                "EditorEvent#stopEvent must be overridden by the extending class.");
    }

});
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * This class implaments a {@link CUI.rte.EditorEvent} for the ExtJS toolkit.
 * @class CUI.rte.adapter.ExtEvent
 * @extends CUI.rte.EditorEvent
 */
CUI.rte.adapter.ExtEvent = new Class({

    toString: "ExtEvent",

    extend: CUI.rte.EditorEvent,

    /**
     * The native ExtJS event
     * @type CQ.Ext.EventObject
     * @private
     */
    nativeEvent: null,

    /**
     * The native ExtJS event (for backward compatibility)
     * @type CQ.Ext.EventObject
     * @private
     */
    extEvent: null,

    /**
     * Creates a new editor event from the specified ExtJS event.
     * @param {CQ.Ext.EventObject} extEvent The underlying, native ExtJS event
     * @param {CUI.rte.EditContext} editContext The editor context for the event
     */
    construct: function(extEvent, editContext) {
        // console.log(extEvent);
        this.nativeEvent = extEvent;
        this.extEvent = extEvent;
        // map to common properties
        var cfg = {
            "type": extEvent.type,
            "key": extEvent.getKey(),
            "charCode": extEvent.getCharCode(),
            "metaKeyPressed": extEvent.metaKey,
            "ctrlKeyPressed": extEvent.ctrlKey,
            "shiftKeyPressed": extEvent.shiftKey,
            "pos": {
                "x": extEvent.getPageX(),
                "y": extEvent.getPageY()
            },
            "button": extEvent.button,
            "editContext": editContext
        };
        this._init(cfg);
    },

    // overrides CUI.rte.EdittorEvent#isTab
    isTab: function() {
        return this.nativeEvent.getKey() == this.nativeEvent.TAB;
    },

    // overrides CUI.rte.EdittorEvent#isEnter
    isEnter: function() {
        return this.nativeEvent.getKey() == this.nativeEvent.ENTER;
    },

    // overrides CUI.rte.EdittorEvent#isSpace
    isSpace: function() {
        return this.nativeEvent.getKey() == this.nativeEvent.SPACE;
    },

    // overrides CUI.rte.EdittorEvent#isBackSpace
    isBackSpace: function() {
        return this.nativeEvent.getKey() == this.nativeEvent.BACKSPACE;
    },

    // overrides CUI.rte.EdittorEvent#isDelete
    isDelete: function() {
        return this.nativeEvent.getKey() == this.nativeEvent.DELETE;
    },

     // overrides CUI.rte.EdittorEvent#isCaretKey
    isCaretKey: function() {
        var key = this.nativeEvent.getKey();
        return (key == this.nativeEvent.UP) || (key == this.nativeEvent.DOWN)
                || (key == this.nativeEvent.LEFT) || (key == this.nativeEvent.RIGHT);
    },

    // overrides CUI.rte.EdittorEvent#isCaretMovement
    isCaretMovement: function() {
        var key = this.nativeEvent.getKey();
        return this.isCaretKey()
                || (key == this.nativeEvent.PAGE_UP) || (key == this.nativeEvent.PAGE_DOWN)
                || (key == this.nativeEvent.HOME) || (key == this.nativeEvent.END);
    },

    // overrides CUI.rte.EdittorEvent#preventDefault
    preventDefault: function() {
        this.nativeEvent.preventDefault();
    },

    // overrides CUI.rte.EdittorEvent#stopPropagation
    stopPropagation: function() {
        this.nativeEvent.stopPropagation();
    },

    // overrides CUI.rte.EdittorEvent#stopEvent
    stopEvent: function() {
        this.nativeEvent.stopEvent();
    }

});
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

CUI.rte.Query = function() {

    return {

        selectNode: function(q, dom) {
            return CQ.Ext.DomQuery.selectNode(q, dom);
        },

        select: function(q, dom) {
            return CQ.Ext.DomQuery.select(q, dom);
        }

    };

}();
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

CUI.rte.AdapterUtils = function() {

    return {

        isArray: function(obj) {
            return CQ.Ext.isArray(obj);
        },

        isString: function(obj) {
            return CQ.Ext.isString(obj);
        },

        apply: function(obj, config, defaults) {
            return CQ.Ext.apply(obj, config, defaults);
        },

        getPagePosition: function(dom) {
            return CQ.Ext.get(dom).getXY();
        },

        jsonDecode: function(str) {
            return CQ.Ext.util.JSON.decode(str);
        },

        getBlankImageUrl: function() {
            return CQ.Ext.BLANK_IMAGE_URL;
        }

    };

}();
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * This class provides an overridable set of constants to be used by the RTE.
 * @class CUI.rte.Constants
 */
CUI.rte.Constants = {

    EXTENSION_HTML: ".html"

};
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * <p>This class allows to hook some special functionality into the RichTextEditor.</p>
 * <p>The provided default implementation depends on jQuery.</p>
 * <p>The class may be overridden in page-load time with application-specific functionality.
 */
CUI.rte.Hooks = new Class({

    copyObject: function(obj) {
        var newObj;
        if (CUI.rte.Utils.isArray(obj)) {
            newObj = [ ];
            for (var i = 0; i < obj.length; i++) {
                newObj.push(this.copyObject(obj[i]))
            }
        } else if (typeof(obj) == "object") {
            newObj = { };
            for (var k in obj) {
                if (obj.hasOwnProperty(k)) {
                    newObj[k] = this.copyObject(obj[k])
                }
            }
        } else {
            newObj = obj;
        }
        return newObj;
    },

    applyDefaults: function(obj, defaults) {
        obj = obj || { };
        defaults = defaults || { };
        if (typeof(obj) === "object") {
            for (var k in defaults) {
                if (defaults.hasOwnProperty(k)) {
                    var v = defaults[k];
                    if (v && (typeof(v) === "object") && !CUI.rte.Utils.isArray(v)) {
                        obj[k] = this.applyDefaults(obj[k], v);
                    } else if (typeof(obj[k] === "undefined")) {
                        obj[k] = v;
                    }
                }
            }
        }
        return obj;
    },

    getMainWindow: function() {
        return window;
    },

    processUrl: function(url, type) {
        return url;
    },

    onPluginCreated: function(plugin) {
        return plugin;
    },

    resolveRelativePath: function(relPath) {
        var path = document.location.pathname;
        var parentPath = path.substring(0, path.lastIndexOf("/"));
        var parts = parentPath.split("/");
        var relParts = relPath.split("/");
        for (var r = 0; r < relParts.length; r++) {
            var relPart = relParts[r];
            if (relPart === "..") {
                if (parts.length <= 1) {
                    throw new Error("Invalid relative path: " + relPath);
                }
                parts.splice(parts.length - 1, 1);
            } else if (relPart !== ".") {
                parts.push(relPart);
            }
        }
        return parts.join("/");
    },

    isExistingPage: function(path) {
        return true;
    },

    getServerPrefix: function(url) {
        var protSepPos = url.indexOf("://");
        if (protSepPos < 0) {
            return "";
        }
        var afterProtPos = url.indexOf("/", protSepPos + 3);
        return afterProtPos < 0 ? url : url.substring(0, afterProtPos);
    }

});

/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

CUI.rte.Utils = function() {

    var hooks = null;
    var getHooks = function() {
        if (!hooks) {
            hooks = new CUI.rte.Hooks();
        }
        return hooks;
    };

    return {

        scope: function(fn, scope) {
            return function() {
                fn.apply(scope, arguments);
            };
        },

        defer: function(fn, ms, scope, args) {
            var callFn = fn;
            if (scope) {
                callFn = function() {
                    if (args) {
                        fn.apply(scope, args);
                    } else {
                        fn.call(scope);
                    }
                };
            } else if (args) {
                callFn = function() {
                    fn.apply(scope, args);
                }
            }
            return window.setTimeout(callFn, ms);
        },

        htmlEncode: function(str) {
            if (str) {
                str = str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;")
                        .replace(/"/g, "&quot;");
            }
            return str;
        },

        htmlDecode: function(str) {
            if (str) {
                str = str.replace(/&lt;/g, "<").replace(/&gt;/g, ">")
                        .replace(/&quot;/g, "\"").replace(/&amp;/g, "&");
            }
            return str;
        },

        stripTags: function(str) {
            if (str) {
                str = str.replace(/<\/?[a-z][a-z0-9]*[^<>]*>/gi, "");
            }
            return str;
        },

        i18n: function(str, values) {
            // TODO replace with correct internationalization when available ...
            if (values) {
                if (CUI.rte.Utils.isArray(values)) {
                    str = str.replace("{0}", values);
                } else {
                    for (var s = 0; s < values.length; s++) {
                        str = str.replace("{" + s + "}", values[s])
                    }
                }
            }
            return str;
        },

        merge: function(obj1, obj2) {
            for (var name in obj2) {
                if (obj2.hasOwnProperty(name)) {
                    obj1[name] = obj2[name];
                }
            }
            return obj1;
        },


        // "hooked" calls

        copyObject: function(obj) {
            return getHooks().copyObject(obj);
        },

        applyDefaults: function(obj, defaults) {
            return getHooks().applyDefaults(obj, defaults);
        },

        getMainWindow: function() {
            return getHooks().getMainWindow();
        },

        processUrl: function(url, type) {
            return getHooks().processUrl(url, type);
        },

        onPluginCreated: function(plugin) {
            return getHooks().onPluginCreated(plugin);
        },

        resolveRelativePath: function(relPath) {
            return getHooks().resolveRelativePath(relPath);
        },

        isExistingPage: function(path) {
            return getHooks().isExistingPage(path);
        },

        getServerPrefix: function(url) {
            return getHooks().getServerPrefix(url);
        },

        URL_IMAGE: "image",

        // mapping adapter specific stuff:

        isArray: CUI.rte.AdapterUtils.isArray,

        isString: CUI.rte.AdapterUtils.isString,

        apply: CUI.rte.AdapterUtils.apply,

        getPagePosition: CUI.rte.AdapterUtils.getPagePosition,

        jsonDecode: CUI.rte.AdapterUtils.jsonDecode,

        getBlankImageUrl: CUI.rte.AdapterUtils.getBlankImageUrl

    };

}();

/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.EditContext
 * This class is used to abstract the context the editor is used in.
 * @constructor
 * @param {HTMLElement} iFrame iframe the editor is running in (if any)
 * @param {window} win The window object that is suitable for the editor
 * @param {document} doc The document object that is suitable for the editor
 * @param {HTMLElement} root The "root" element (the iframe's body tag or the div that is
 *        made editable)
 */
CUI.rte.EditContext = new Class({

    toString: "EditContext",

    /**
     * @private
     * @type HTMLElement
     */
    iFrame: null,

    /**
     * @private
     * @type window
     */
    win: null,

    /**
     * @private
     * @type document
     */
    doc: null,

    /**
     * @private
     * @type HTMLElement
     */
    root: null,

    construct: function(iFrame, win, doc, root) {
        this.iFrame = iFrame;
        this.win = win;
        this.doc = doc;
        this.root = root;
    },

    /**
     * Creates the specified DOM element for the context.
     * @param {String} tagName The element's name
     * @return {HTMLElement} The DOM element; null, if context is not yet initialized
     */
    createElement: function(tagName) {
        return (this.doc != null ? this.doc.createElement(tagName) : null);
    },

    /**
     * Creates a text node with the specified text data.
     * @param {String} textData Text data of the node
     * @return {HTMLElement} The text node
     */
    createTextNode: function(textData) {
        return (this.doc != null ? this.doc.createTextNode(textData) : null);
    },

    /**
     * Checks if the edit context is fully initialized.
     * @return {Boolean} true if the edit context is fully initialized
     */
    isInitialized: function() {
        return (this.win != null) && (this.doc != null) && (this.root != null);
    }

});
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.EditorKernel
 * @private
 * This class implements the core functionality each rich text-based editor requires.
 * It abstracts that core functionality from the component implementation - hence rich text
 * functionality may be used in different contexts, for example as a widget vs. inplace
 * editing.
 */
CUI.rte.EditorKernel = new Class({

    toString: "EditorKernel",

    /**
     * @cfg {Boolean} removeSingleParagraphContainer
     * True if the paragraph element of texts that consist only of a single paragraph
     * should be removed on {@link #getValue}/{@link #syncValue} (defaults to false).
     * For example, if a text is &lt;p&gt;Single paragraph text&lt;/p&gt;, the surrounding
     * "p" tag would get removed if this option was set to true. This option is mainly for
     * backward compatibility with CQ 5.1, where container tags had not yet been available.
     * Hence texts that were created by a CQ 5.1 instance will be surrounded by a single "p"
     * element before they are edited in a CQ 5.2 instance. By setting this option to true,
     * this automatically added "p" tag will get removed before the text is saved, at least
     * if no other paragraphs or containers were added.
     * @deprecated Use {@link CUI.rte.HtmlRules.BlockHandling#removeSingleParagraphContainer} instead
     */
    removeSingleParagraphContainer: false,

    /**
     * @cfg {String} singleParagraphContainerReplacement
     * Specifies the name of the tag that has to be used if a paragraph container cannot
     * be simply removed because it carries additional info (for example, alignment and/or
     * CSS classes; defaults to "div"). Note that this setting only takes effect if
     * {@link #removeSingleParagraphContainer} is set to true.
     * @deprecated Use {@link CUI.rte.HtmlRules.BlockHandling#singleParagraphContainerReplacement} instead
     */
    singleParagraphContainerReplacement: null,

    /**
     * @cfg {Object[]} linkInternalize
     * <p>Defines a list of attributes for which link internalizing has to be applied.</p>
     * <p>Link internalizing is necessary as the browser usually stores entire URLs in the
     * DOM, not relative links. Hence internal links must be rewritten to be "internal"
     * before submitting the text.</p>
     * <p>For example, the "href" attribute of a link might be created as something like
     * "http://localhost:4502/cq5/content/geometrixx/en.html", which has
     * to be stored as "/content/geometrixx/en.html".</p>
     * <p>Each element of the Array must have the following properties:</p>
     * <ul>
     *   <li><code>tag</code> : String<br>
     *     The name of the tag for which the internalizing should be done</li>
     *   <li><code>attribute</code> : String<br>
     *     The name of the attribute that contains the link to be internalized</li>
     * </ul>
     * <p>Defaults to:</p>
<pre>
[
     {
        "tag": "a",
        "attribute": "href"
    }, {
        "tag": "img",
        "attribute": "src"
    }
]
</pre>
     */
    linkInternalize: null,

    /**
     * @cfg {Object} rtePlugins
     * <p>This is the root of all plugin-specific configuration.</p>
     * <p>You must provide a config element for each plugin you are about to configure.
     * Use the plugin's ID (see class documentation) as the property name for the
     * corresponding config element. Each config element has config options that are
     * used by all plugins, and plugin-specific options. Commonly used options are:</p>
     * <ul>
     *   <li><code>features</code> : String[]/String<br>
     *   A String[] that contains all features of a plugin that should be
     *   enabled; alternatively a String "*" may be provided to enable all features of the
     *   corresponding plugin</li>
     *   <li><code>tooltips</code> : Object<br>
     *   An object that defines the tooltips for the plugin's icons. Property name specifies
     *   the name of the icon (usually the ID of the feature that is represented by the
     *   icon; the value has a tooltip description object as required by Ext.</li>
     * </ul>
     * <p>Plugin-specific options are documented at the respective plugin. Note that this
     * object is null after constructing the RichText object has finished, as the
     * configuration is transferred to the respective plugin.</p>
     */

    /**
     * @cfg {CUI.rte.HtmlRules} htmlRules
     * This object defines how to create/process HTML. Defaults to null (uses default
     * HTML rules).
     * @since 5.3
     */
    htmlRules: null,

    /**
     * Processing module used for pre-processing HTML before editing
     * @private
     * @type CUI.rte.DomCleanup
     */
    preProcessor: null,

    /**
     * Processing module used for post-processing HTML before submitting or editing as
     * source code
     * @private
     * @type CUI.rte.DomCleanup
     */
    postProcessor: null,

    /**
     * Associative array of registered commands; values of type
     * {@link CUI.rte.commands.Commands}
     * @private
     * @type Object
     */
    registeredCommands: null,

    /**
     * Associative array of registered plugins; values of type
     * {@link CUI.rte.plugins.Plugin}
     * @private
     * @type Object
     */
    registeredPlugins: null,

    /**
     * Current edit context. This should never be accessed directly, but only through
     * {@link #getEditContext}.
     * @private
     * @type CUI.rte.EditContext
     */
    editContext: null,

    /**
     * <p>Internal event listeners. Each element of the Array must have the following
     * properties:</p>
     * <ul>
     *   <li><code>fn</code> : String<br>
     *     A (suitably scoped) Function object that contains the listener code</li>
     *   <li><code>plugin</code> : String<br>
     *     The plugin that registers the listener</li>
     *   <li><code>deferred</code> : Boolean<br>
     *     True if the listener should be executed deferred (which is sometimes necessary to
     *     avoid some timing pitfalls, but not supported for all event types)</li>
     * </ul>
     * @private
     * @type Object[]
     */
    internalListeners: null,

    /**
     * <p>UI listeners. Each element of the Array must have the followeing properties:</p>
     * <ul>
     *   <li><code>fn</code> : String<br>
     *     A (suitably scoped) Function object that contains the listener code.</li>
     * </ul>
     * @private
     * @type Object[]
     */
    uiListeners: null,

    /**
     * The toolbar (toolkit-independent)
     * @private
     * @type CUI.rte.ui.Toolbar
     */
    toolbar: null,

    /**
     * Context menu builder
     * @private
     * @type CUI.rte.ui.ContextMenuBuilder
     */
    contextMenuBuilder: null,

    /**
     * Currently displayed context menu (if any)
     * @private
     * @type Object
     */
    contextMenu: null,

    /**
     * The selection before the context menu gets invoked; required to be restored before
     * any command invoked through the context menu gets actually relayed
     * @private
     */
    contextMenuSavedRange: null,

    /**
     * Table of internally regsitered event handlers
     * @private
     * @type Object
     */
    registeredHandlers: null,

    /**
     * Flag that determines if internal event handling is currently disabled.
     * @private
     * @type Boolean
     */
    isEventingDisabled: false,

    /**
     * Flag that determines if the current focus blur is only a temporary blur. This is
     * used to distinguish focus changes to the toolbar (= temporary blur) from focus
     * changes to somewhere else (those blurs lead to a disabled toolbar). Therefore,
     * toolbar elements that do not immediately return focus to the editor kernel, must
     * explicitly set this flag to true on receiving the focus themselves. For example,
     * a (style of format) selector sets isTemporaryBlur to true in their focus event.
     * On the other hand, buttons usually don't require to set it, as they are returning
     * focus immediately.
     * @private
     * @type Boolean
     */
    isTemporaryBlur: false,

    /**
     * Flag that determines if focus handling is active for this editor kernel. If disabled,
     * the toolbar doesn't get enabled/disabled on focus changes. This may for example
     * be used in situations where the client wants to take control over the toolbar (for
     * example in source edit mode)
     * @private
     * @type Boolean
     */
    isFocusHandlingDisabled: false,

    /**
     * Flag that determines if the kernel currently holds the keyboard focus.
     * @publicProp
     * @type Boolean
     */
    hasFocus: false,

    /**
     * Flag that determines if the kernel is currently enabled
     * @private
     * @type Boolean
     */
    isEnabled: false,

    /**
     * Object that defines which actions have to be executed on next focus gain.
     * @private
     * @type Object
     */
    focusGainActions: null,

    /**
     * Registered key shortcuts; key: the letter (Ctrl+&lt;letter&gt;); value: the command
     * @private
     * @type Object
     */
    keyboardShortcuts: null,

    /**
     * The UI toolkit to be used; default value: ext
     */
    uiToolkit: null,

    /**
     * The dialog manager to be used
     */
    dialogManager: null,


    construct: function(config) {
        config = config || { };
        CUI.rte.Utils.applyDefaults(config, {
            "linkInternalize": [ {
                "tag": "a",
                "attribute": "href"
            }, {
                "tag": "img",
                "attribute": "src"
            } ]
        });
        this.keyboardShortcuts = { };
        // commands
        this.registeredCommands =
            CUI.rte.commands.CommandRegistry.createRegisteredCommands();
        // plugins
        this.registeredPlugins =
            CUI.rte.plugins.PluginRegistry.createRegisteredPlugins(this);
        CUI.rte.Compatibility.moveDeprecatedPluginConfig(config);
        CUI.rte.Compatibility.moveDeprecatedHtmlRules(config);
        CUI.rte.Compatibility.configurePlugins(config, this);
        delete config.rtePlugins;
        // Initialize HTML rules
        if (config.htmlRules) {
            this.htmlRules = new CUI.rte.HtmlRules(config.htmlRules);
            delete config.htmlRules;
        } else {
            this.htmlRules = new CUI.rte.HtmlRules();
        }
        // Toolkit ...
        if (config.uiToolkit) {
            this.uiToolkit = config.uiToolkit;
            delete config.uiToolkit;
        } else {
            this.uiToolkit = CUI.rte._toolkit
                    || CUI.rte.EditorKernel.DEFAULT_TOOLKIT;
        }
        // other config
        this.linkInternalize = config.linkInternalize;
        delete config.linkInternalize;
        // pre/post processing
        var tagRules = { };
        if (this.tagReplace) {
            // Compatibility layer for CQ 5.2
            for (var tag in this.tagReplace) {
                if (this.tagReplace.hasOwnProperty(tag)) {
                    var replaceTag = this.tagReplace[tag];
                    tagRules[tag] = {
                        "rename": replaceTag
                    };
                }
            }
        }
        // Processing HTML code/DOM
        this.preProcessor = new CUI.rte.DomCleanup({
            "tagsToRemove": [ "font" ]
        });
        this.postProcessor = new CUI.rte.DomCleanup({
            "tagsToRemove": [ "font" ]
        });
        // other stuff
        var tk = CUI.rte.ui.ToolkitRegistry.get(this.uiToolkit);
        this.contextMenuBuilder = tk.createContextMenuBuilder(this);
        this.dialogManager = tk.createDialogManager(this);
        this.registeredHandlers = [ ];
        this.isEnabled = true;
        this.focusGainActions = { };
    },


    // Interface ---------------------------------------------------------------------------

    /**
     * Returns a suitable edit context for this EditorKernel's instance.
     * @return {CUI.rte.EditContext} The edit context for this instance
     */
    getEditContext: function() {
        // may be overridden by implementing EditorKernels
        if (this.editContext == null) {
            this.editContext = new CUI.rte.EditContext();
        }
        return this.editContext;
    },

    /**
     * Gets the HTML rules valid for this EditorKernel.
     * @return {CUI.rte.HtmlRules} The HTML rules
     */
    getHtmlRules: function() {
        return this.htmlRules;
    },

    /**
     * Returns the path of the currently edited content (if available).
     * @return {String} The content path; null if no content path is available
     */
    getContentPath: function() {
        // must be overridden by implementing classes
        return null;
    },

    /**
     * Get the DOM element that is responsible for focus handling.
     * @param {CUI.rte.EditContext} context (optional) The edit context
     * @return {HTMLElement} The DOM element that is responsible for focus handling
     */
    getFocusDom: function(context) {
        // must be overridden by implementing EditorKernels
        return null;
    },

    /**
     * Focusses the DOM element responsible for rich text editing.
     * @param {CUI.rte.EditContext} context (optional) The edit context
     */
    focus: function(context) {
        // must be overridden by implementing EditorKernels
    },

    /**
     * Blurs the focus.
     * @param {CUI.rte.EditContext} context (optional) The edit context
     */
    blurFocus: function(context) {
        // must be overridden by implementing EditorKernels
    },

    /**
     * Calculates a suitable position for a subordinate window.
     * @param {String} hint A positioning hint; allowed values are: "default"; defaults to
     *        "default"
     * @return {Number[]} The XY position for the subordinate window (e.g., [100, 200])
     */
    calculateWindowPosition: function(hint) {
        // must be overridden by implementing editor kernels
        return [ 0, 0 ];
    },

    /**
     * Calculates a suitable position for the context menu.
     * @param {CUI.rte.EditorEvent} event The event that invoked the context menu
     * @return {Number[]} The XY position for the context menu (e.g., [100, 200])
     */
    calculateContextMenuPosition: function(event) {
        // must be overridden by implementing editor kernels
        return [ 0, 0 ];
    },

    /**
     * Determines if the editor kernel can edit the html source.
     * @return {Boolean} True if the kernel is capable of editing the html source
     * @since 5.5
     */
    canEditSource: function() {
        // may be overridden accordingly
        return false;
    },

    /**
     * Gets the dialog manager for this editor kernel.
     * @return {CUI.rte.ui.DialogManager} The dialog manager
     * @since 5.6
     */
    getDialogManager: function() {
        return this.dialogManager;
    },


    // Helpers -----------------------------------------------------------------------------

    /**
     * Deferred focusing of the DOM element responsible for rich text editing.
     * @param {Function} addFn (optional) additional function to be executed after focus request
     */
    deferFocus: function(addFn) {
        // may be overridden if necessary
        CUI.rte.Utils.defer(function() {
            this.focus();
            if (addFn && (typeof(addFn) == "function")) {
                addFn();
            }
        }, 10, this);
    },

    /**
     * Disables the kernel's event handling temporarily. It may be re-enabled by using
     * {@link #reenableEventHandling}.
     */
    disableEventHandling: function() {
        this.isEventingDisabled = true;
    },

    /**
     * Reeanbles the kernel's event handling after it was disabled temporarily (using
     * {@link #disableEventHandling}).
     */
    reenableEventHandling: function() {
        this.isEventingDisabled = false;
    },

    /**
     * Enables focus handling.
     */
    enableFocusHandling: function() {
        this.isFocusHandlingDisabled = false;
    },

    /**
     * Disables focus handling.
     */
    disableFocusHandling: function() {
        this.isFocusHandlingDisabled = true;
    },

    /**
     * Executes some Gecko-related initialization. For example, disables the "enahanced"
     * table editing handles provided by Gecko browsers.
     */
    initializeGeckoSpecific: function() {
        var com = CUI.rte.Common;

        if (com.ua.isGecko && this.isEnabled) {
            var context = this.getEditContext();
            if (context.isInitialized()) {
                try {
                    context.doc.execCmd("useCSS", true);
                } catch (e) {
                    // ignore if unsupported
                }
                try {
                    context.doc.execCommand("styleWithCSS", false, false);
                } catch (e) {
                    // ignore if unsupported
                }
                try {
                    context.doc.execCommand("enableInlineTableEditing", false, false);
                } catch (e) {
                    // ignore if unsupported
                }
            }
        }
    },

    /**
     * <p>Ensures that the caret gets initialized.</p>
     * <p>Will be executed immediately, if the editor kernel currently has the focus, or
     * optionally on next focus gain.</p>
     */
    initializeCaret: function(enforceInit) {
        // may be overridden by the respective kernel implementation
    },

    /**
     * <p>Restores the last known IE selection.</p>
     * <p>This must be used to restore a selection after focus losses. For example, dragging
     * (and dropping) an image has to call this method to restore the insert point.</p>
     * <p>This method can be safely called for non-IE browsers - such calls are simply
     * ignored.</p>
     */
    restoreSelectionToLastKnownBookmark: function() {
        var sel = CUI.rte.Selection;
        var com = CUI.rte.Common;
        var context = this.getEditContext();
        if (com.ua.isOldIE && this.lastKnownBookmark) {
            if (!this.hasFocus) {
                this.focus();
            }
            sel.selectBookmark(context, this.lastKnownBookmark);
        }
    },


    // DOM-Event handling ------------------------------------------------------------------

    /**
     * Registers a DOM event handler.
     * @param {HTMLElement/window/document} obj The DOM object to register the handler for
     * @param {String} eventName The name of the event
     * @param {Function} handler The handler to be registered
     * @param {Object} scope Scope the handler will be executed in
     * @param {Object} options (optional) Options
     */
    registerHandler: function(obj, eventName, handler, scope, options) {
        CUI.rte.Eventing.on(this.editContext, obj, eventName, handler, scope, options);
        this.registeredHandlers.push({
            "obj": obj,
            "eventName": eventName,
            "handler": handler,
            "scope": scope
        });
    },

    /**
     * Registers several DOM event handlers at once.
     * @param {HTMLElement/window/document} obj The DOM object to register the handler for
     * @param {Object} events The events to be registered. The key specifies the event name,
     *        the value contains the handler Function
     * @param {Object} scope Scope the handler will be executed in
     * @param {Object} options (optional) Options
     */
    registerHandlers: function(obj, events, scope, options) {
        for (var eventName in events) {
            if (events.hasOwnProperty(eventName)) {
                var handler = events[eventName];
                this.registerHandler(obj, eventName, handler, scope, options);
            }
        }
    },

    /**
     * Unregisters all elements that were registered through {@link #registerHandler} and
     * {@link #registerHandlers}.
     */
    unregisterHandlers: function() {
        var handlerCnt = this.registeredHandlers.length;
        for (var h = 0; h < handlerCnt; h++) {
            var def = this.registeredHandlers[h];
            CUI.rte.Eventing.un(def.obj, def.eventName, def.handler, def.scope);
        }
        this.registeredHandlers.length = 0;
    },

    /**
     * <p>Initializes event handling for this editor kernel.</p>
     * <p>Use {@link #suspendEventHandling}</p> to clean up after using the editor kernel.
     * </p>
     */
    initializeEventHandling: function() {
        var com = CUI.rte.Common;
        var context = this.getEditContext();
        if (context.isInitialized() && this.isEnabled) {
            var doc = context.doc;
            // deferred execution handlers - no workarounds here; performance-intense
            // operations are explicitly welcome for deferred execution!
            if (com.ua.isIE) {
                // IE must use selectionchange event to react on selection/caret changes,
                // otherwise we get invalid selections when clicking inside an existing
                // selection - see bug #21013
                this.registerHandlers(doc, {
                        "selectionchange": function(e) {
                            this.onEditorEvent(e);
                        },
                        "keyup": function(e) {
                            this.onEditorEvent(e);
                            if (this.isEventingDisabled) {
                                return;
                            }
                            this.firePluginEvent("deferredkeyup", e, true);
                        },
                        "mousedown": function(e) {
                            if (this.isEventingDisabled) {
                                return;
                            }
                            this.firePluginEvent("deferredmousedown", e, true);
                        },
                        "mouseup": function(e) {
                            if (this.isEventingDisabled) {
                                return;
                            }
                            this.firePluginEvent("deferredmouseup", e, true);
                        }
                    }, this, {
                        "buffer": 100
                    });
            } else {
                // other browsers should listen to keyup/mousedown events
                this.registerHandlers(doc, {
                        "keyup": function(e) {
                            this.onEditorEvent(e);
                            if (this.isEventingDisabled) {
                                return;
                            }
                            this.firePluginEvent("deferredkeyup", e, true);
                        }
                    }, this, {
                        "buffer": 100
                    });
                if (!com.ua.isTouch) {
                    this.registerHandlers(doc, {
                            "mousedown": function(e) {
                                if (this.isEventingDisabled) {
                                    return;
                                }
                                this.firePluginEvent("deferredmousedown", e, true);
                            },
                            "mouseup": function(e) {
                                this.onEditorEvent(e);
                                if (this.isEventingDisabled) {
                                     return;
                                }
                                this.firePluginEvent("deferredmouseup", e, true);
                            }
                        }, this, {
                            "buffer": 100
                        });
                } else {
                    // touchstart/touchend are mapped to corresponding mousedown/mouseup
                    // events
                    this.registerHandlers(doc, {
                            "touchstart": function(e) {
                                if (this.isEventingDisabled) {
                                    return;
                                }
                                this.firePluginEvent("deferredmousedown", e, true);
                            },
                            "touchend": function(e) {
                                this.onEditorEvent(e);
                                if (this.isEventingDisabled) {
                                     return;
                                }
                                this.firePluginEvent("deferredmouseup", e, true);
                            }
                        }, this, {
                            "buffer": 100
                        });
                }
            }
            // keydown is the same across all browsers and all device categories
            this.registerHandlers(doc, {
                    "keydown": function(e) {
                        if (this.isEventingDisabled) {
                            return;
                        }
                        this.firePluginEvent("deferredkeydown", e, true);
                    }
                }, this, {
                    "buffer": 100
                });

            // directly executed handlers - put workarounds that rely on immediately being
            // able on the DOM here. keep in mind that these events may get fired quite
            // often, so "expensive" operations should be executed here only if absolutely
            // necessary!
            this.registerHandlers(doc, {
                    "keydown": function(e) {
                        if (this.isEventingDisabled) {
                            return;
                        }
                        if (e.isCtrl()) {
                            if (com.ua.isIE) {
                                // handling of Ctrl-keys must be handled here for IE
                                var c = String.fromCharCode(e.getCharCode()).toLowerCase();
                                var cmd = this.keyboardShortcuts[c];
                                if (cmd) {
                                    this.applyCommand(e);
                                    return;
                                } else {
                                    // prevent formatting shortcuts from being automatically
                                    // executed
                                    if ((c == 'b') || (c == 'i') || (c == 'u')
                                            || (c == 'm')) {
                                        e.stopEvent();
                                        return;
                                    }
                                }
                            }
                        }
                        this.firePluginEvent("beforekeydown", e, false);
                        if (!e.cancelKey) {
                            this.firePluginEvent("keydown", e, false);
                        }
                        if (e.cancelKey) {
                            e.stopEvent();
                            this.deferFocus();
                        }
                    },
                    "keyup": function(e) {
                        if (this.isEventingDisabled) {
                            return;
                        }
                        this.firePluginEvent("beforekeyup", e, false);
                        if (!e.cancelKey) {
                            this.firePluginEvent("keyup", e, false);
                        }
                        if (e.cancelKey) {
                            e.stopEvent();
                            this.deferFocus();
                        }
                    },
                    "keypress": function(e) {
                        if (this.isEventingDisabled) {
                            return;
                        }
                        if (com.ua.isGecko) {
                            // shortcut handling on Gecko
                            this.applyCommand(e);
                        }
                        if (!e.cancelKey) {
                            this.firePluginEvent("beforekeypress", e, false);
                        }
                        if (!e.cancelKey) {
                            this.firePluginEvent("keypress", e, false);
                        }
                        if (e.cancelKey) {
                            e.stopEvent();
                            this.deferFocus();
                        }
                    }
                }, this);

            // Mouse/Touch Events; fired directly
            if (com.ua.isTouch) {
                this.registerHandlers(doc, {
                    "touchstart": function(e) {
                        if (this.isEventingDisabled) {
                            return;
                        }
                        this.firePluginEvent("mousedown", e, false);
                    }, "touchend": function(e) {
                        if (this.isEventingDisabled) {
                            return;
                        }
                        this.firePluginEvent("mouseup", e, false);
                    }
                }, this);
            } else {
                this.registerHandlers(doc, {
                    "mousedown": function(e) {
                        if (this.isEventingDisabled) {
                            return;
                        }
                        this.firePluginEvent("mousedown", e, false);
                    },
                    "mouseup": function(e) {
                        if (this.isEventingDisabled) {
                            return;
                        }
                        this.firePluginEvent("mouseup", e, false);
                    }
                }, this);
            }

            // Focus-Events, fired immediately
            this.registerHandlers(this.getFocusDom(context), {
                    "focus": function(e) {
                        this.onFocus(e);
                    },
                    "blur": function(e) {
                        this.onBlur(e);
                    }
                }, this);

            // Other Events, fired immediately
            this.registerHandlers(doc.body, {
                "paste": function(e) {
                    this.onPaste(e);
                }
            }, this);

            this.initializeGeckoSpecific();

            this.registerHandler(context.root, "contextmenu", function(event) {
                    if (this.isEventingDisabled) {
                        return false;
                    }
                    // disable internal event handling for the time the context menu
                    // is shown to prevent side-effects
                    this.isEventingDisabled = true;
                    event.preventDefault();
                    if (!this.handleContextMenu(event)) {
                        // no context menu shown: enable event handling again
                        this.isEventingDisabled = false;
                    }
                    return false;
                }, this);
        }
    },

    /**
     * <p>Adds CSS "feature classes" to the specified DOM element.</p>
     * <p>Supported feature classes are:</p>
     * <ul>
     *   <li>ie - Internet Explorer</li>
     *   <li>ie6 - Internet Explorer 6</li>
     *   <li>ie7 - Internet Explorer 7</li>
     *   <li>ie8 - Internet Explorer 8</li>
     *   <li>ie9 - Internet Explorer 9</li>
     *   <li>ie10 - Internet Explorer 10</li>
     *   <li>gecko - Gecko engine</li>
     *   <li>webkit - Webkit engine</li>
     *   <li>safari - Safari</li>
     *   <li>chrome - Chrome</li>
     * </ul>
     * @param {HTMLElement} dom The DOM element
     */
    addFeatureClasses: function(dom) {
        var com = CUI.rte.Common;
        function addConditionally(cond, cssClass) {
            if (cond) {
                com.addClass(dom, cssClass);
            }
        }
        addConditionally(com.ua.isIE, "ie");
        addConditionally(com.ua.isIE6, "ie6");
        addConditionally(com.ua.isIE7, "ie7");
        addConditionally(com.ua.isIE8, "ie8");
        addConditionally(com.ua.isIE9, "ie9");
        addConditionally(com.ua.isIE10, "ie10");
        addConditionally(com.ua.isGecko, "gecko");
        addConditionally(com.ua.isWebKit, "webkit");
        addConditionally(com.ua.isSafari, "safari");
        addConditionally(com.ua.isChrome, "chrome");
    },

    /**
     * <p>Suspends event handling for this editor kernel.</p>
     * <p>Use {@link #initializeEventHandling} to re-establish event handling.</p>
     */
    suspendEventHandling: function() {
        this.unregisterHandlers();
    },

    /**
     * Internal handler for focus events.
     * @private
     */
    onFocus: function(e) {
        var com = CUI.rte.Common;

        if (!this.hasFocus) {
            if (com.ua.isOldIE) {
                // IE sends a onFocus event if the main window, but not the editor window
                // gets the focus, so we'll ignore the focus event if the range doesn't
                // point to the editor's window object
                var context = this.getEditContext();
                var editorWin = context.win;
                var range = CUI.rte.Selection.getLeadRange(context);
                var rangeWin;
                if (range.item) {
                    rangeWin = range.item(0).ownerDocument.parentWindow;
                } else {
                    rangeWin = range.parentElement().ownerDocument.parentWindow;
                }
                var hasRange = (rangeWin == editorWin);
                if (!hasRange) {
                    return;
                }
            }
            this.isEventingDisabled = false;
            this.hasFocus = true;
            if (!this.isFocusHandlingDisabled) {
                this.enableToolbar();
                this.updateToolbar();
            }
            this.onEditorEvent(e);
            // execute deferred stuff that has been scheduled for being executed on focus
            // gain
            if (this.focusGainActions.initializeCaret) {
                this.initializeCaret(false);
                this.focusGainActions.initializeCaret = false;
            }
        }
    },

    /**
     * Internal handler for blur events.
     * @private
     */
    onBlur: function(e) {
        if (this.hasFocus) {
            this.isEventingDisabled = true;
            this.isTemporaryBlur = false;
            this.hasFocus = false;
            if (!this.isFocusHandlingDisabled) {
                CUI.rte.Utils.defer(function() {
                    if (this.isEventingDisabled && !this.isTemporaryBlur) {
                        this.disableToolbar();
                    }
                }, 100, this);
            }
        }
    },

    /**
     * Internal handler for paste events (currently supported browsers only).
     * @private
     */
    onPaste: function(e) {
        if (this.isEventingDisabled) {
            return;
        }
        this.firePluginEvent("paste", e, false);
    },

    /**
     * <p>Notifies an (indirect) blur.</p>
     * <p>This method may be used to tell the editor kernel about implicit blurs. For
     * example, Gecko doen't send explicit blur events if the internal iframe gets hidden.
     * </p>
     */
    notifyBlur: function() {
        if (this.hasFocus) {
            this.onBlur();
        }
    },

    /**
     * <p>Centralized handler for deferred editor events (which should not be executed on
     * directly, but after a short while if no other event occurs).</p>
     * <p>There is several cleanup code in place; but mainly, the toolbar gets updated
     * (as it is a quite expensive operation).</p>
     * @param {Object} e The editor event (wrapping the original Ext event)
     * @private
     */
    onEditorEvent: function(e) {
        var com = CUI.rte.Common;
        var ignoreEventForContextMenu = false;
        if (com.ua.isOldIE) {
            if (e.getType() == "selectionchange") {
                ignoreEventForContextMenu = true;
                // store current bookmark to have it available later
                var context = this.getEditContext();
                if (context.isInitialized() && this.hasFocus) {
                    this.lastKnownBookmark = CUI.rte.Selection.createSelectionBookmark(
                            context);
                }
            }
        } else {
            ignoreEventForContextMenu = (e.getType() == "mouseup") && (e.getButton() == 2);
        }
        if (!ignoreEventForContextMenu) {
            if (this.contextMenu && this.contextMenuBuilder.isVisible()) {
                this.contextMenuBuilder.hideAll();
                this.isEventingDisabled = false;
            }
        }
        if (this.isEventingDisabled) {
            return;
        }
        this.fireUIEvent("updatestate");
    },


    // Markup-based processing -------------------------------------------------------------

    /**
     * @private
     */
    getEmptyLinePlaceholderMarkup: function() {
        // will be adjusted in a browser-specific way by DomCleanup
        return "<p>&nbsp;</p>";
    },


    // Pre- and postprocessing -------------------------------------------------------------

    setUnprocessedHtml: function(html) {
        if (html.length < 1) {
            var interceptedHtml = this.execContentInterception("emptyContent", null);
            if (interceptedHtml != null) {
                html = interceptedHtml;
            } else {
                html = this.getEmptyLinePlaceholderMarkup();
            }
        }
        var context = this.getEditContext();
        this.htmlRules.serializer.deserialize(context, html, context.root,
                this.htmlRules.docType);
        CUI.rte.WhitespaceProcessor.process(context, context.root);
        this.preProcessor.preprocess(this, context.root);
        this.execContentInterception("postprocessDom", {
            "editContext": context
        });
    },

    getProcessedHtml: function() {
        var context = this.getEditContext();
        var root = context.root.cloneNode(true);
        this.execContentInterception("cleanDom", {
            "editContext": this.getEditContext(),
            "root": root
        });
        this.postProcessor.postprocess(this, root);
        return this.htmlRules.serializer.serialize(context, root, this.htmlRules.docType);
    },


    // Executing commands ------------------------------------------------------------------

    /**
     * @private
     */
    getCustomCommand: function(command) {
        var customCommand = this.registeredCommands[command];
        if (customCommand) {
            return customCommand;
        }
        for (var cmd in this.registeredCommands) {
            var cmdToCheck = this.registeredCommands[cmd];
            if (cmdToCheck.isCommand(command)) {
                return cmdToCheck;
            }
        }
        return null;
    },

    /**
     * Executes an editor command on the editor document and performs necessary focus and
     * toolbar updates. Commands that are not supported by a specific browser are emulated
     * accordingly. <b>This should only be called after the editor is initialized.</b>
     * @param {String} cmd The Midas command
     * @param {Object} value (optional) The value to pass to the command (defaults to null)
     */
    relayCmd: function(cmd, value) {
        if (!this.isEnabled) {
            return;
        }
        CUI.rte.Utils.defer(function() {
            var context = this.getEditContext();
            var sel = CUI.rte.Selection;
            var com = CUI.rte.Common;

            if (context.isInitialized()) {
                this.focus(context);
            }
            try {
                var preferredScrollOffset;
                if (context.isInitialized()) {
                    preferredScrollOffset = (com.ua.isIE ? null :
                        sel.getPreferredScrollOffset(context));
                }
                var execRet = this.execCmd(cmd, value, context);
                if (com.ua.isGecko && execRet && context.isInitialized()) {
                    if (execRet.geckoEnsureCaretVisibility) {
                        sel.ensureCaretVisibility(context, preferredScrollOffset);
                    }
                    if (execRet.bookmark) {
                        sel.selectBookmark(context, execRet.bookmark);
                    }
                }
            } catch (e) {
                if (e.message == "Cannot paste.") {
                    this.editorKernel.getDialogManager().alert(
                            CUI.rte.Utils.i18n("Paste"),
                            CUI.rte.Utils.i18n("Could not paste due to security restrictions of the browser.<br>Please use Ctrl+V to paste directly."),
                            CUI.rte.Utils.scope(this.deferFocus, this));
                } else if (e.message == "Cannot copy.") {
                    this.editorKernel.getDialogManager().alert(
                            CUI.rte.Utils.i18n("Copy"),
                            CUI.rte.Utils.i18n("Could not copy due to security restrictions of the browser.<br>Please use Ctrl+C to copy directly."),
                            CUI.rte.Utils.scope(this.deferFocus, this));
                } else if (e.message == "Cannot cut.") {
                    this.editorKernel.getDialogManager().alert(
                            CUI.rte.Utils.i18n("Cut"),
                            CUI.rte.Utils.i18n("Could not cut due to security restrictions of the browser.<br>Please use Ctrl+X to cut directly."),
                            CUI.rte.Utils.scope(this.deferFocus, this));
                } else if (e.message == "Could not insert html due to IE limitations.") {
                    this.editorKernel.getDialogManager().alert(
                            CUI.rte.Utils.i18n("Error"),
                            CUI.rte.Utils.i18n("Could not insert text due to internal Internet Explorer limitations. Please try to select a smaller text fragment and try again."),
                            CUI.rte.Utils.scope(this.deferFocus, this));
                } else {
                    throw e;
                }
            }
            this.fireUIEvent("updatestate");
        }, 10, this);
    },

    /**
     * Executes an editor command directly on the editor document. For visual commands, you
     * should use {@link #relayCmd} instead. Commands that are not supported by a specific
     * browser are emulated accordingly. <b>This method should only be called after the
     * editor is initialized. Otherwise, it will return immediately if the command is not
     * explicitly flagged for use in unitialized state.</b>
     * @param {String} command The Midas command
     * @param {Object} value (optional) The value to pass to the command (defaults to null)
     * @param {CUI.rte.EditContext} context (optional) The edit context
     */
    execCmd: function(command, value, context){
        var sel = CUI.rte.Selection;
        var dpr = CUI.rte.DomProcessor;
        var cmd = CUI.rte.commands.Command;
        var com = CUI.rte.Common;
        // init
        if (!this.isEnabled) {
            return null;
        }
        if (!context) {
            context = this.getEditContext();
        }
        // check if a custom command has to be used instead of browser's implementation
        var customCommand = this.getCustomCommand(command);
        if (!context.isInitialized() && !customCommand) {
            return null;
        }
        if (!context.isInitialized()) {
            if (customCommand.requiresInitializedComponent(command)) {
                return null;
            }
        }
        if (this.initialized) {
            this.firePluginEvent("beforecommandexecuted", {
                "cmd": command,
                "cmdValue": value,
                "customCommand": customCommand
            }, false);
        }
        var calleeRet = null;
        if (customCommand) {
            var options = customCommand.getProcessingOptions();
            var execOptions = {
                "editContext": context,
                "command": command,
                "value": value,
                "component": this
            };
            if (context.isInitialized()) {
                if ((options & cmd.PO_SELECTION) > 0) {
                    execOptions.selection = this.createQualifiedSelection(context);
                    // Use normalized selection if we have a selection to ensure
                    // start node does not point "behind" a node, but points to the
                    // first actually included node. If the selection represents a caret,
                    // we'll have to use the un-normalized selection, because the position
                    // behind a node may have different impact than the position before
                    // the succeeding node (for example, t|<b>ex</b>t will insert a
                    // character in plaintext, whereas t<b>|ex</b>t will insert a bold
                    // character.
                    if (execOptions.selection
                            && sel.shouldNormalizePSel(context, execOptions.selection)) {
                        sel.normalizeProcessingSelection(context, execOptions.selection);
                    }
                }
                if ((options & cmd.PO_BOOKMARK) > 0) {
                    if (execOptions.selection) {
                        execOptions.bookmark = sel.bookmarkFromProcessingSelection(context,
                                execOptions.selection);
                    } else {
                        execOptions.bookmark = sel.createSelectionBookmark(context);
                    }
                }
                if ((options & cmd.PO_NODELIST) > 0) {
                    if (!execOptions.selection) {
                        execOptions.selection = this.createQualifiedSelection(context);
                    }
                    execOptions.nodeList = dpr.createNodeList(context,
                            execOptions.selection);
                }
            }
            var execRet = customCommand.execute(execOptions);
            if (context.isInitialized()) {
                var bookmark = execOptions.bookmark;
                if (bookmark && execRet && execRet.selOffset) {
                    if (execRet.selOffset.start) {
                        bookmark.startPos += execRet.selOffset.start;
                    }
                    if (execRet.selOffset.collapse) {
                        bookmark.charCnt = 0;
                    } else if (execRet.selOffset.cnt) {
                        bookmark.charCnt += execRet.selOffset.cnt;
                    }
                }
                if (bookmark) {
                    sel.selectBookmark(context, bookmark);
                }
            }
            if (execRet && execRet.calleeRet) {
                calleeRet = execRet.calleeRet;
            }
        } else {
            context.doc.execCommand(command, false, value === undefined ? null : value);
            if (com.ua.isGecko && com.strStartsWith(command, "insert")
                    && com.strEndsWith(command, "list")) {
                // clean up, as Gecko creates lines, not paragraphs
                dpr.ensureBlockContent(context, "p", null, true, false);
            }
        }
        if (context.isInitialized()) {
            this.firePluginEvent("commandexecuted", {
                "cmd": command,
                "cmdValue": value,
                "customCommand": customCommand
            }, false);
        }
        return calleeRet;
    },

    /**
     * <p>Queries the state for the specified command.</p>
     * <p>The result is dependent on the specified command. Some commands may not return
     * any state. See command documentation for more information.</p>
     * @param {String} command The command to query state for
     * @param {Object} selectionDef (optional) Analyzed selection
     * @since 5.3
     */
    queryState: function(command, selectionDef) {
        if (!this.isEnabled) {
            return false;
        }
        var context = this.getEditContext();
        if (!context.isInitialized) {
            return false;
        }
        var customCommand = this.getCustomCommand(command);
        if (!customCommand) {
            return context.doc.queryCommandState(command);
        }
        if (!selectionDef) {
            selectionDef = this.analyzeSelection();
        }
        if (!selectionDef) {
            return false;
        }
        return customCommand.queryState(selectionDef, command);
    },


    // Keyboard shortcuts ------------------------------------------------------------------

    /**
     * Registers a keyboard shortcut for the specified command.
     * @param {String} letter The letter to register; "b" will register the command for
     *        Ctrl+B
     * @param {String} command The command to be executed for the shortcut
     * @since 5.5
     */
    registerKeyboardShortcut: function(letter, command) {
        this.keyboardShortcuts[letter.toLowerCase()] = command;
    },

    /**
     * Applies several key commands on Gecko
     * @private
     */
    applyCommand: function(e) {
        if (e.isCtrl()) {
            var c = String.fromCharCode(e.getCharCode()).toLowerCase();
            var cmd = this.keyboardShortcuts[c];
            if (cmd) {
                e.cancelKey = true;
                e.stopEvent();
                this.focus();
                this.execCmd(cmd);
                this.deferFocus();
            }
        }
    },

    /**
     * Requests source edit mode (if available).
     * @param {Boolean} enable True if source edit mode should be activated
     */
    requestSourceEdit: function(enable) {
        this.isTemporaryBlur = true;
        this.fireUIEvent((enable ? "enable" : "disable") + "sourceedit");
    },


    // State -------------------------------------------------------------------------------

    /**
     * Enables the editor kernel for editing.
     */
    enable: function() {
        this.isEnabled = true;
        this.initializeEventHandling();
        if (this.hasFocus) {
            this.updateToolbar();
        }
    },

    /**
     * Disables the editor kernel for editing.
     */
    disable: function() {
        this.suspendEventHandling();
        this.disableToolbar([ "sourceedit" ]);
        this.isEnabled = false;
    },


    // Selection handling ------------------------------------------------------------------

    /**
     * <p>Creates a "qualified" processing selection.</p>
     * <p>"Qualified" means the original browser selection plus manipulations executed
     * by one or more plugins.</p>
     * @return {Object} qualified selection; null if no valid selection exists
     * @private
     */
    createQualifiedSelection: function(context) {
        var selection = CUI.rte.Selection.createProcessingSelection(context);
        if (!selection || (selection.startNode == null)) {
            return null;
        }
        for (var pluginId in this.registeredPlugins) {
            if (this.registeredPlugins.hasOwnProperty(pluginId)) {
                var plugin = this.registeredPlugins[pluginId];
                plugin.manipulateSelection(selection);
            }
        }
        return selection;
    },

    /**
     * <p>Creates a "qualified" range bookmark.</p>
     * <p>"Qualified" means the original ranges selection plus manipulations executed
     * by one or more plugins.</p>
     * @return {Object} qualified range bookmark
     * @private
     */
    createQualifiedRangeBookmark: function(context) {
        var bookmark = CUI.rte.Selection.createRangeBookmark(context);
        for (var pluginId in this.registeredPlugins) {
            if (this.registeredPlugins.hasOwnProperty(pluginId)) {
                var plugin = this.registeredPlugins[pluginId];
                plugin.saveRangeBookmark(bookmark);
            }
        }
        return bookmark;
    },

    /**
     * <p>Selects a "qualified" range bookmark.</p>
     * <p>"Qualified" means the original ranges selection plus manipulations executed
     * by one or more plugins.</p>
     * @param {Object} bookmark qualified range bookmark
     * @private
     */
    selectQualifiedRangeBookmark: function(context, bookmark) {
        CUI.rte.Selection.selectRangeBookmark(context, bookmark);
        for (var pluginId in this.registeredPlugins) {
            if (this.registeredPlugins.hasOwnProperty(pluginId)) {
                var plugin = this.registeredPlugins[pluginId];
                plugin.restoreRangeBookmark(bookmark);
            }
        }
    },

    /**
     * <p>Analyzes the current selection considering the following:</p>
     * <ul>
     *   <li>isSelection - if there is an actual selection or just a collapsed
     *     selection (caret)</li>
     *   <li>anchorCount - number of links intersected by the current selection</li>
     *   <li>anchors - definition (href, target) of all links intersected by the selection
     *     </li>
     *   <li>namedAnchorCount - number of anchors (a name="...") intersected by the current
     *     selection</li>
     *   <li>namedAnchors - definition of all anchors (a name="...") intersected by the
     *     current selection</li>
     *   <li>nodeList - List of nodes the selection consists of (see
     *     {@link CUI.rte.NodeList})</li>
     *   <li>styleCount - number of different CSS styles (classes) that are present in the
     *     current selection</li>
     *   <li>styles - CSS styles (classes) that are present in the current
     *     selection</li>
     *   <li>isContinuousStyle - true if there is only one style (CSS class) present in the
     *     current selection (not caret)</li>
     *   <li>containerList - list of all container tags that are intersected by the current
     *     selection</li>
     *   <li>consistentFormatting - list of all common ancestors DOM nodes (which define
     *     the formatting that is consistent through the entire selection)</li>
     *   <li>editContext - the edit context</li>
     *   <li>selection - the original processing selection</li>
     *   <li>selectedDom - the DOM node that is currently selected (if only the object
     *     itself is selected)</li>
     * </ul>
     * @return {Object} The result as described above
     * @private
     */
    analyzeSelection: function(context) {
        var sel = CUI.rte.Selection;
        var dpr = CUI.rte.DomProcessor;
        if (!context) {
            context = this.getEditContext();
        }
        var anchors = [ ];
        var namedAnchors = [ ];
        var stylesDef = { };
        var consistentFormatting = [ ];
        var selection = this.createQualifiedSelection(context);
        if (!selection) {
            return null;
        }
        var isSelection = sel.isSelection(selection);
        // Use normalized selection if we have a selection to ensure
        // start node does not point "behind" a node, but points to the
        // first actually included node. If the selection represents a caret,
        // we'll have to use the un-normalized selection, because the position
        // behind a node may have different impact than the position before
        // the succeeding node (for example, t|<b>ex</b>t will insert a
        // character in plaintext, whereas t<b>|ex</b>t will insert a bold
        // character.
        if (sel.shouldNormalizePSel(context, selection)) {
            sel.normalizeProcessingSelection(context, selection);
        }
        var nodeList = dpr.createNodeList(context, selection);
        nodeList.getAnchors(context, anchors, true);
        nodeList.getNamedAnchors(context, namedAnchors, true);
        if (isSelection) {
            nodeList.getStyles(context, stylesDef, true);
        } else {
            var styleNode = selection.startNode;
            dpr.getStyles(context, stylesDef, styleNode);
        }
        var commonAncestor = nodeList.commonAncestor;
        while (commonAncestor) {
            if (commonAncestor == context.root) {
                break;
            }
            consistentFormatting.push(commonAncestor);
            commonAncestor = commonAncestor.parentNode;
        }
        var selectedDom = sel.getSelectedDom(selection);
        var styles = (stylesDef.styles ? stylesDef.styles : [ ]);
        return {
            "selection": selection,
            "selectedDom": selectedDom,
            "nodeList": nodeList,
            "isSelection": isSelection,
            "anchorCount": anchors.length,
            "anchors": anchors,
            "namedAnchorCount": namedAnchors.length,
            "namedAnchors": namedAnchors,
            "styleCount": styles.length,
            "styles": styles,
            "isContinuousStyle": stylesDef.isContinuousStyle,
            "consistentFormatting": consistentFormatting,
            "containerList": dpr.createContainerList(context, selection),
            "auxRoots": dpr.getAuxRoots(context, selection),
            "editContext": context
        };
    },


    // Plugin-related stuff ----------------------------------------------------------------

    /**
     * <p>Registers a editor-related event handler for a plugin.</P>
     * <p>Currently the following events are supported:</p>
     * <ul>
     *   <li>mousedown</li>
     *   <li>mouseup</li>
     *   <li>beforekeydown (vetoable)</li>
     *   <li>keydown</li>
     *   <li>beforekeyup (vetoable)</li>
     *   <li>keyup</li>
     *   <li>beforecommandexecuted (non-deferred usage only)</li>
     *   <li>commandexecuted (non-deferred usage only)</li>
     * </ul>
     * <p>Note that you can specify a priority for the listener to ensure the order in which
     * listeners are executed. Default priority is 1000.</p>
     * @param {String} eventName Event name (see doc for supported values)
     * @param {Function} fn Event handler function
     * @param {Object} scope Scope for fn
     * @param {CUI.rte.plugins.Plugin} plugin Plugin that registers the event handler
     * @param {Boolean} isDeferred True if the listener should be executed
     *        "deferred"
     * @param {Number} priority (optional) The listener's priority; defaults to 1000
     * @private
     */
    addPluginListener: function(eventName, fn, scope, plugin, isDeferred, priority) {
        if (priority == null) {
            priority = 1000;
        }
        if (!this.internalListeners) {
            this.internalListeners = { };
        }
        if (!this.internalListeners[eventName]) {
            this.internalListeners[eventName] = [ ];
        }
        var listeners = this.internalListeners[eventName];
        var listenerCnt = listeners.length;
        var listenerDef = {
            "fn": scope ? CUI.rte.Utils.scope(fn, scope) : fn,
            "plugin": plugin,
            "deferred": isDeferred,
            "priority": priority
        };
        for (var l = 0; l < listenerCnt; l++) {
            var listenerToCheck = listeners[l];
            if (listenerToCheck.priority > priority) {
                listeners.splice(l, 0, listenerDef);
                return;
            }
        }
        listeners.push(listenerDef);
    },

    /**
     * Unregisters all editor-related event handlers of a specific type for the specified
     * plugin.
     * @param {String} eventName Event name (see {@link #addPluginListener} for supported
     *        values)
     * @param {CUI.rte.plugins.Plugin} plugin Plugin that unregisters its event handlers
     * @private
     */
    removePluginListener: function(eventName, plugin) {
        if (!this.internalListeners || !this.internalListeners[eventName]) {
            return;
        }
        var listeners = this.internalListeners[eventName];
        var listenerCnt = listeners.length;
        for (var l = listenerCnt - 1; l >= 0; l--) {
            if (listeners[l].plugin == plugin) {
                listeners.splice(l, 1);
            }
        }
    },

    /**
     * <p>Fires an editor-related event.</p>
     * <p>Both {@link CUI.rte.EditorEvent}s and "higher level"/custom events can be
     * sent to the registered listeners using this method. To dispatch a custom event,
     * provide a suitable Object as parameter param. Note that the eventName parameter is
     * ignored if a {@link CUI.rte.EditorEvent} is provided as param.</p>
     * @param {String} eventName Event name (see {@link #addPluginListener} for supported
     *        values)
     * @param {Object|CUI.rte.EditorEvent} param Event specific parameter: either an
     *        Object for a custom event, or a CUI.rte.EditorEvent for forwarding
     *        editor events.
     * @param {Boolean} isDeferred True if the Event is fired from a deferred
     *        context (note that the event is always dispatched immediately, but it is
     *        dispatched to different event listeners)
     * @private
     */
    firePluginEvent: function(eventName, param, isDeferred) {
        if (!this.internalListeners || !this.internalListeners[eventName]) {
            return;
        }
        // pass/forward EditorEvents 1:1; create a PluginEvent otherwise - this allows
        // the listeners to manipulate EditorEvents (mainly: cancel the event) directly
        // and the callee to react on it appropriately
        var event;
        if (param instanceof CUI.rte.EditorEvent) {
            event = param;
        } else {
            event = new CUI.rte.plugins.PluginEvent(eventName, this.getEditContext(),
                    param);
        }
        var listenerCnt = this.internalListeners[eventName].length;
        for (var l = 0; l < listenerCnt; l++) {
            var listenerDef = this.internalListeners[eventName][l];
            if (listenerDef && listenerDef.fn) {
                if (listenerDef.deferred == isDeferred) {
                    listenerDef.fn(event);
                }
            }
        }
        return event;
    },

    /**
     * <p>Executes a content interception.</p>
     * <p>"Content interceptions" are used for providing plugin-specific content or
     * processing content in a plugin-specific way. For example, the table plugin may
     * intercept the "empty content" situation and provide a different empty content
     * markup than the default in table edit mode. Also, it may intercept the HTML
     * creation on submit and change the transmitted HTML (for example) to an empty string
     * if actually an empty table would be submitted in table edit mode.</p>
     * @param {String} contentType Content type to intercept
     * @param {Object} defs Definitions of the content interception; format depends on the
     *        content type
     */
    execContentInterception: function(contentType, defs) {
        for (var pluginId in this.registeredPlugins) {
            if (this.registeredPlugins.hasOwnProperty(pluginId)) {
                var plugin = this.registeredPlugins[pluginId];
                var interceptedContent = plugin.interceptContent(contentType, defs);
                if (interceptedContent != null) {
                    return interceptedContent;
                }
            }
        }
        return null;
    },


    // UI-related stuff --------------------------------------------------------------------

    /**
     * <p>Registers a UI-related event handler.</P>
     * <p>Currently the following events are supported:</p>
     * <ul>
     *   <li>updatestate - signals a selection state change</li>
     *   <li>preventdrop - signals that drag & drop on the text component should be
     *     temporarily disabled</li>
     *   <li>reactivatedrop - signals that drag & drop on the text component should be
     *     reactivated</li>
     *   <li>enablesourceedit - signals that source edit mode is requested</li>
     *   <li>disablesourceedit - signals that WYSIWYG edit mode is requested</li>
     *   <li>dialogshow - signals that a dependent dialog has been shown</li>
     *   <li>dialoghide - signals that a dependent dialog has been hidden</li>
     * </ul>
     * @param {String} eventName Event name (see doc for supported values)
     * @param {Function} fn Event handler function
     * @param {Object} scope Scope for fn
     * @private
     */
    addUIListener: function(eventName, fn, scope) {
        if (!this.uiListeners) {
            this.uiListeners = { };
        }
        if (!this.uiListeners[eventName]) {
            this.uiListeners[eventName] = [ ];
        }
        this.uiListeners[eventName].push({
            "fn": scope ? CUI.rte.Utils.scope(fn, scope) : fn
        });
    },

    /**
     * Unregisters all UI-related event handlers of a specific type.
     * @param {String} eventName Event name (see {@link #addUIListener} for supported
     *        values)
     * @private
     */
    removeUIListener: function(eventName) {
        if (!this.uiListeners || !this.uiListeners[eventName]) {
            return;
        }
        delete this.uiListeners[eventName];
    },

    /**
     * Fires a UI-related event.
     * @param {String} eventName Event name (see {@link #addUIListener} for supported
     *        values)
     * @param {Object} param (optional) Event specific parameter
     * @private
     */
    fireUIEvent: function(eventName, param) {
        if (!this.uiListeners || !this.uiListeners[eventName]) {
            return;
        }
        var event = new CUI.rte.ui.UIEvent(eventName, this.getEditContext(), param);
        var listenerCnt = this.uiListeners[eventName].length;
        for (var l = 0; l < listenerCnt; l++) {
            var listenerDef = this.uiListeners[eventName][l];
            if (listenerDef && listenerDef.fn) {
                listenerDef.fn(event);
            }
        }
        return event;
    },


    // Toolbar integration -----------------------------------------------------------------

    /**
     * @private
     */
    getToolbarHeight: function() {
        return this.toolbar.getHeight();
    },

    /**
     * Gets a toolbar item that is located in any of the editor's toolbars.
     * @param {Number} itemId item id of the toolbar item to determine
     * @private
     */
    getToolbarItem: function(itemId) {
        return this.toolbar.getItem(itemId);
    },

    /**
     * Creates the toolbar.
     * @param {Object} options (optional) kernel-specific options
     */
    createToolbar: function(options) {
        options = options || { };
        options.editorKernel = this;
        var tbBuilder = this.createToolbarBuilder();
        for (var pluginId in this.registeredPlugins) {
            if (this.registeredPlugins.hasOwnProperty(pluginId)) {
                var plugin = this.registeredPlugins[pluginId];
                plugin.initializeUI(tbBuilder);
            }
        }
        this.toolbar = tbBuilder.createToolbar(options);
    },

    /**
     * Create a kernel-specific instance of {@link CUI.rte.ui.ToolbarBuilder}.
     * @return {CUI.rte.ui.ToolbarBuilder} The kernel-specific toolbar builde instance
     *         to be used
     */
    createToolbarBuilder: function() {
        // must be overridden by implementing classes
        return null;
    },

    /**
     * Updates the toolbar to the current editor state.
     * @private
     * @hide
     */
    updateToolbar: function() {
        if (!this.isEnabled) {
            return;
        }
        var selectionDef = this.analyzeSelection();
        if (!selectionDef) {
            return;
        }
        for (var pluginId in this.registeredPlugins) {
            if (this.registeredPlugins.hasOwnProperty(pluginId)) {
                var plugin = this.registeredPlugins[pluginId];
                plugin.updateState(selectionDef);
            }
        }
        if (!this.contextMenu || !this.contextMenuBuilder.isVisible()) {
            this.contextMenuBuilder.hideAll();
        }
    },

    adjustToolbarToWidth: function(width) {
        this.toolbar.adjustToWidth(width);
    },

    enableToolbar: function() {
        this.toolbar.enable();
    },

    disableToolbar: function(excludeItems) {
        this.toolbar.disable(excludeItems);
    },

    destroyToolbar: function() {
        this.toolbar.destroy();
    },


    // Context menu implementation ---------------------------------------------------------

    /**
     * Handles a context menu event by building and showing the context menu.
     * @param {Event} event The HTML event that triggered the context menu
     * @return {Boolean} True if the context menu has been shown
     * @private
     */
    handleContextMenu: function(event) {
        var dpr = CUI.rte.DomProcessor;
        this.contextMenuBuilder.clear();
        var context = this.getEditContext();
        var selection = this.createQualifiedSelection(context);
        if (!selection) {
            return false;
        }
        var nodeList = dpr.createNodeList(context, selection);
        var selectionDef = {
            "selection": selection,
            "nodeList": nodeList
        };
        for (var id in this.registeredPlugins) {
            if (this.registeredPlugins.hasOwnProperty(id)) {
                this.registeredPlugins[id].handleContextMenu(this.contextMenuBuilder,
                        selectionDef, context);
            }
        }
        this.contextMenu = this.contextMenuBuilder.build(selectionDef, context);
        if (this.contextMenu) {
            this.contextMenuSavedRange = this.createQualifiedRangeBookmark(context);
            var cmPos = this.calculateContextMenuPosition(event);
            this.contextMenuBuilder.showAt(cmPos[0], cmPos[1]);
            return true;
        }
        return false;
    }


});

/**
 * The default UI toolkit to be used
 * @type String
 */
CUI.rte.EditorKernel.DEFAULT_TOOLKIT = "ext";
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.IFrameKernel
 * @extends CUI.rte.EditorKernel
 * @private
 * This class implements an EditorKernel for iFrame-based rich text editing.
 * @constructor
 * Creates a new IFrameKernel for rich text editing.
 * @param {Object} config The kernel's configuration
 */
CUI.rte.IFrameKernel = new Class({

    toString: "IFrameKernel",

    extend: CUI.rte.EditorKernel,

    /**
     * Path to content being edited
     * @private
     * @type String
     */
    contentPath: null,


    // Interface implementation ------------------------------------------------------------

    /**
     * Initializes the edit context once the rich text editing has been initialized.
     * @param {HTMLElement} iFrame The iFrame
     * @param {window} win The window object that is responsible for editing
     * @param {document} doc The document object that is reponsible for editing
     * @param {HTMLElement} root The root element (the "body" element of the iFrame)
     */
    initializeEditContext: function(iFrame, win, doc, root) {
        this.editContext = new CUI.rte.EditContext(iFrame, win, doc, root);
        this.addFeatureClasses(root);
    },

    /**
     * <p>Ensures that the caret gets initialized.</p>
     * <p>Will be executed immediately, if the editor kernel currently has the focus, or
     * optionally on next focus gain.</p>
     */
    initializeCaret: function(enforceInit) {
        var com = CUI.rte.Common;
        var sel = CUI.rte.Selection;
        if (this.hasFocus) {
            var context = this.getEditContext();
            sel.resetSelection(context, "start");
            if ((com.ua.isGecko || com.ua.isWebKit) && context.iFrame) {
                sel.ensureCaretVisibility(context, 0);
            }
        } else if (enforceInit) {
            this.focusGainActions.initializeCaret = true;
        }
    },

    /**
     * Gets the path to the content being edited.
     * @return {String} The content path
     */
    getContentPath: function() {
        return this.contentPath;
    },

    /**
     * Get the DOM element that is responsible for focus handling.
     * @param {CUI.rte.EditContext} context (optional) The edit context
     * @return {HTMLElement} The DOM element that is responsible for focus handling
     */
    getFocusDom: function(context) {
        if (!context) {
            context = this.getEditContext();
        }
        return context.win;
    },

    /**
     * Focusses the DOM element responsible for rich text editing.
     * @param {CUI.rte.EditContext} context (optional) The edit context
     */
    focus: function(context) {
        if (!context) {
            context = this.getEditContext();
        }
        if (context.win) {
            context.win.focus();
        }
    },

    /**
     * Blurs the focus.
     * @param {CUI.rte.EditContext} context (optional) The edit context
     */
    blurFocus: function(context) {
        if (!context) {
            context = this.getEditContext();
        }
        if (context.win) {
            context.win.blur();
        }
    },

    /**
     * Calculates a suitable position for a subordinate window.
     * @param {String} hint A positioning hint; allowed values are: "default"; defaults to
     *        "default"
     * @return {Number[]} The XY position for the subordinate window (e.g., [100, 200])
     */
    calculateWindowPosition: function(hint) {
        var winPos = null;
        switch (hint) {
            default:
                winPos = this.getEditorPosition();
                break;
        }
        return winPos || [ 0, 0 ];
    },

    // overrides CUI.rte.EditorKernel#calculateContextMenuPosition
    calculateContextMenuPosition: function(event) {
        var editContext = this.getEditContext();
        var editorPos = this.getEditorPosition();
        var scrollPos = [ 0, 0 ];
        var com = CUI.rte.Common;

        if (!com.ua.isOldIE) {
            scrollPos = [ editContext.root.scrollLeft, editContext.root.scrollTop ];
        } else {
            var contentWindow = CUI.rte.Utils.getMainWindow();
            var doc = contentWindow.document;
            var body = doc.body;
            scrollPos = [ doc.documentElement.scrollLeft || body.scrollLeft,
                    doc.documentElement.scrollTop || body.scrollTop ];
        }
        var eventPos = event.getPos();
        return [ editorPos[0] + eventPos.x - scrollPos[0],
                editorPos[1] + eventPos.y - scrollPos[1] ];
    },

    // overrides CUI.rte.EditorKernel#createToolbarBuilder
    createToolbarBuilder: function() {
        var ui = CUI.rte.ui;
        return ui.ToolkitRegistry.get(this.uiToolkit).createToolbarBuilder(
                ui.Toolkit.TBHINT_LOCAL);
    },

    // overrides CUI.rte.EditorKernel#canEditSource
    canEditSource: function() {
        return true;
    },


    // Additional methods ------------------------------------------------------------------

    /**
     * Sets the path to the content being edited.
     * @param {String} contentPath The content path
     */
    setContentPath: function(contentPath) {
        this.contentPath = contentPath;
    },

    // Helpers -----------------------------------------------------------------------------

    /**
     * <p>Gets the current position of the iframe.</p>
     * @return {Number[]} The XY position of the element (e.g., [100, 200])
     */
    getEditorPosition: function() {
        var context = this.getEditContext();
        if (!context.iFrame) {
            return null;
        }
        return CUI.rte.Utils.getPagePosition(context.iFrame);
    }

});

/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.DivKernel
 * @extends CUI.rte.EditorKernel
 * @private
 * This class implements an EditorKernel for div-based rich text editing.
 * @constructor
 * Creates a new DivKernel for rich text editing.
 * @param {Object} config The kernel's configuration
 */
CUI.rte.DivKernel = new Class({

    toString: "DivKernel",

    extend: CUI.rte.EditorKernel,

    /**
     * Path to content being edited
     * @private
     * @type String
     */
    contentPath: null,


    // Interface implementation ------------------------------------------------------------

    /**
     * Initializes the edit context once the rich text editing has been initialized.
     * @param {window} win The window object that is responsible for editing
     * @param {document} doc The document object that is reponsible for editing
     * @param {HTMLElement} root The root element (the "div" element being edited)
     */
    initializeEditContext: function(win, doc, root) {
        this.editContext = new CUI.rte.EditContext(null, win, doc, root);
        this.addFeatureClasses(root);
    },

    /**
     * <p>Ensures that the caret gets initialized.</p>
     * <p>Will be executed immediately, if the editor kernel currently has the focus, or
     * optionally on next focus gain.</p>
     */
    initializeCaret: function(enforceInit, emptyTextPara) {
        var com = CUI.rte.Common;
        var sel = CUI.rte.Selection;
        var context = this.getEditContext();
        if (com.ua.isGecko || com.ua.isWebKit) {
            this.deferFocus(CUI.rte.Utils.scope(function() {
                sel.resetSelection(context, "start");
                this.fireUIEvent("updatestate");
            }, this));
        } else if (com.ua.isIE) {
            CUI.rte.Utils.defer(function() {
                this.focus();
                // workaround: EditorKernel does not always get first focus, so manually
                // ensuring that editorKernel.hasFocus is set correctly
                this.hasFocus = true;
                if (emptyTextPara != null) {
                    sel.selectNode(context, emptyTextPara, true);
                } else {
                    sel.resetSelection(context, "start");
                }
            }, 1, this);
        }
    },

    /**
     * Gets the path to the content being edited.
     * @return {String} The content path
     */
    getContentPath: function() {
        return this.contentPath;
    },

    /**
     * Get the DOM element that is responsible for focus handling.
     * @param {CUI.rte.EditContext} context (optional) The edit context
     * @return {HTMLElement} The DOM element that is responsible for focus handling
     */
    getFocusDom: function(context) {
        if (!context) {
            context = this.getEditContext();
        }
        return context.root;
    },

    /**
     * Focusses the DOM element responsible for rich text editing.
     * @param {CUI.rte.EditContext} context (optional) The edit context
     */
    focus: function(context) {
        if (!context) {
            context = this.getEditContext();
        }
        if (context.root) {
            try {
                context.root.focus();
            } catch (e) {
                // IE sometimes chokes on this, so at least prevent an error message popping
                // up
            }
        }
    },

    /**
     * Blurs the focus.
     * @param {CUI.rte.EditContext} context (optional) The edit context
     */
    blurFocus: function(context) {
        if (!context) {
            context = this.getEditContext();
        }
        if (context.root) {
            context.root.blur();
        }
    },

    /**
     * Calculates a suitable position for a subordinate window.
     * @param {String} hint A positioning hint; allowed values are: "default"; defaults to
     *        "default"
     * @return {Number[]} The XY position for the subordinate window (e.g., [100, 200])
     */
    calculateWindowPosition: function(hint) {
        var context = this.getEditContext();
        var winPos = null;
        var scrollTop = context.doc.documentElement.scrollTop || context.doc.body.scrollTop;
        switch (hint) {
            default:
                winPos = [ 0, scrollTop ];
                break;
        }
        return winPos || [ 0, 0 ];
    },

    // overrides CUI.rte.EditorKernel#calculateContextMenuPosition
    calculateContextMenuPosition: function(event) {
        var eventPos = event.getPos();
        return [ eventPos.x, eventPos.y ];
    },

    // overrides CUI.rte.EditorKernel#createToolbarBuilder
    createToolbarBuilder: function() {
        var ui = CUI.rte.ui;
        return ui.ToolkitRegistry.get(this.uiToolkit).createToolbarBuilder(
                ui.Toolkit.TBHINT_GLOBAL);
    },


    // Additional methods ------------------------------------------------------------------

    /**
     * Sets the path to the content being edited.
     * @param {String} contentPath The content path
     */
    setContentPath: function(contentPath) {
        this.contentPath = contentPath;
    }

});

/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.Common
 * @static
 * @private
 * The Common provides some commonly used utility functionality.
 */
CUI.rte.Common = function() {

    var docMode = window.document.documentMode, // documentMode property explaination: http://msdn.microsoft.com/en-us/library/ie/cc196988%28v=vs.85%29.aspx
        ua = navigator.userAgent.toLowerCase(),
        check = function(r){
            return r.test(ua);
        },
        isWebkit = check(/webkit/),
        isGecko = !isWebkit && check(/gecko/), // because the Webkit user agent string sometimes contains "like Gecko"
        isIE = check(/msie/),
        isIE6 = isIE && check(/msie 6/),
        isIE7 = isIE && (check(/msie 7/) || docMode == 7),
        isIE8 = isIE && (check(/msie 8/) || docMode == 8),
        isIE9 = isIE && (check(/msie 9/) || docMode == 9),
        isIE10 = isIE && (check(/msie 10/) || docMode == 10),
        isOldIE = isIE && (isIE6 || isIE7 || isIE8), // indicator that this IE versions are using the old proprietary behavior (especially selection)
        isW3cIE = isIE && !isOldIE,
        isMac = check(/macintosh|mac os x/),
        isChrome = isWebkit && check(/\bchrome\b/),
        isSafari = isWebkit && !isChrome && check(/safari/),
        isTouch = "ontouchstart" in window;

    /**
     * Flag if the internal logging mechanism is enabled (used for ieLog())
     */
    var isLogEnabled = true;

    /**
     * Recursive part of getNodeAtPosition.
     */
    var getNodeAtPositionRec = function(context, node, state, pos) {
        var com = CUI.rte.Common;
        if (node.nodeType == 3) {
            var textLen = com.getNodeCharacterCnt(node);
            var endPos = state.charPos + textLen;
            if ((pos >= state.charPos) && (pos < endPos)) {
                state.node = {
                    "dom": node,
                    "start": state.charPos,
                    "offset": pos - state.charPos,
                    "nodeBefore": state.nodeBefore
                };
                return;
            } else if (pos == endPos) {
                state.nodeBefore = node;
                state.startBefore = state.charPos;
            }
            state.charPos += textLen;
        } else if (node.nodeType == 1) {
            if (com.isOneCharacterNode(node)) {
                if (state.charPos == pos) {
                    state.node = {
                        "isNodeSelection": true,
                        "startOfElement": true,
                        "dom": node
                    };
                    return;
                }
                state.charPos++;
            } else {
                // if we got the first item of an irregularily nested edit block
                // (nested lists), we'll have to correct one character position before
                // we calculate anything else
                if (com.isTag(node, com.EDITBLOCK_UNREGNEST_TAGS)) {
                    if ((com.getChildIndex(node) == 0)
                            && com.isFirstNestedList(context, node.parentNode)) {
                        var pNode = node;
                        do {
                            pNode = com.getParentNode(context, pNode);
                            if (pNode && com.isTag(pNode,
                                    com.EDITBLOCK_UNREGNEST_TAGS)) {
                                if (state.charPos == pos) {
                                    var superItem = state.nodeBefore;
                                    var offset = com.getNodeCharacterCnt(superItem);
                                    var itemParent = superItem.parentNode;
                                    state.node = {
                                        "dom": superItem,
                                        "offset": offset,
                                        "parentDom": itemParent,
                                        "isUnregularNestedIssue": true,
                                        "nestedItemDom": node
                                    };
                                    return;
                                }
                                state.charPos++;
                                break;
                            }
                        } while (pNode);
                    }
                }
                var myCharPos = state.charPos;
                var childCnt = node.childNodes.length;
                for (var childIndex = 0; childIndex < childCnt; childIndex++) {
                    getNodeAtPositionRec(context, node.childNodes[childIndex], state, pos);
                    if (state.node) {
                        if (!state.node.parentDom) {
                            state.node.parentDom = node;
                            state.node.parentStart = myCharPos;
                            state.node.parentOffset = pos - myCharPos;
                        }
                        return;
                    }
                }
                if (com.isTag(node, com.EDITBLOCK_TAGS)) {
                    // as always, there are corner cases we have to handle differently -
                    // if we are at the last element of a nested structure, we will
                    // usually directly move to the next nested element, without the
                    // additional character position that is added when entering the
                    // nested structure
                    var isValidEOEB = true;
                    var nestingType = null;
                    if (com.isTag(node, com.EDITBLOCK_NESTED_TAGS)) {
                        nestingType = com.EDITBLOCK_NESTED_TAGS;
                    } else if (com.isTag(node, com.EDITBLOCK_UNREGNEST_TAGS)) {
                        nestingType = com.EDITBLOCK_UNREGNEST_TAGS;
                    }
                    if (nestingType != null) {
                        isValidEOEB = !com.isLastChildDeep(node, nestingType);
                    }
                    if (isValidEOEB) {
                        if (state.charPos == pos) {
                            state.node = {
                                "isNodeSelection": true,
                                "startOfElement": false,
                                "dom": node
                            };
                            return;
                        }
                        state.charPos++;
                    }
                }
            }
        }
    };

    /**
     * Recursive part of getCharacterOffsetForNode.
     * @param {Object} context
     * @param {Node} node
     * @param {Number} charPos
     * @param {Node} processingNode
     */
    var getCharacterOffsetForNodeRec = function(context, node, charPos, processingNode) {
        var com = CUI.rte.Common;
        // if we got the first item of an irregularily nested edit block (nested lists),
        // we'll have to correct one character position before we calculate anything
        if (com.isTag(processingNode, com.EDITBLOCK_UNREGNEST_TAGS)) {
            if ((com.getChildIndex(processingNode) == 0)
                    && com.isFirstNestedList(context, processingNode.parentNode)) {
                var pNode = processingNode;
                do {
                    pNode = com.getParentNode(context, pNode);
                    if (pNode && com.isTag(pNode, com.EDITBLOCK_UNREGNEST_TAGS)) {
                        charPos++;
                        break;
                    }
                } while (pNode);
            }
        }
        if (processingNode == node) {
            return {
                "isFound": true,
                "charPos": charPos
            };
        }
        if (processingNode.nodeType == 3) {
            charPos += com.getNodeCharacterCnt(processingNode);
            return {
                "isFound": false,
                "charPos": charPos
            };
        }
        if (processingNode.nodeType == 1) {
            if (com.isOneCharacterNode(processingNode)) {
                charPos++;
            } else {
                var childCnt = processingNode.childNodes.length;
                for (var childIndex = 0; childIndex < childCnt; childIndex++) {
                    var childResult = getCharacterOffsetForNodeRec(context,
                            node, charPos, processingNode.childNodes[childIndex]);
                    if (childResult.isFound) {
                        return childResult;
                    }
                    charPos = childResult.charPos;
                }
                // we'll have to add one character at the end of "edit blocks", to
                // distinguish the end of an edit block from the begin of the
                // succeeding edit block
                if (com.isTag(processingNode, com.EDITBLOCK_TAGS)) {
                    var addCharPos = true;
                    // as always, there are corner cases we have to handle differently -
                    // if we are at the last element of a nested structure, we will
                    // usually directly move to the next nested element, without the
                    // additional character position that is added when entering the
                    // nested structure
                    if (com.isTag(processingNode, com.EDITBLOCK_NESTED_TAGS)) {
                        // if a table cell being closed is the last element of the
                        // edit element, we must not add the character offset
                        addCharPos = !com.isLastElementOfNestingLevel(context,
                                processingNode);
                    } else if (com.isTag(processingNode,
                            com.EDITBLOCK_UNREGNEST_TAGS)) {
                        // if a list item being closed has a nested list as last
                        // element, we must not add the character offset
                        addCharPos = !com.isLastChildDeep(processingNode,
                                com.EDITBLOCK_UNREGNEST_TAGS);
                    }
                    if (addCharPos) {
                        charPos++;
                    }
                }
            }
            return {
                "isFound": false,
                "charPos": charPos
            };
        }
        return {
            "isFound": false,
            "charPos": -1
        };
    };


    return {

        /**
         * user agent information.
         * @type {Object} allows to check the browser/engine type and version
         */
        ua: {
            /**
             * True if the detected browser uses WebKit.
             * @type Boolean
             */
            isWebKit: isWebkit,
            /**
             * True if the detected browser uses the Gecko layout engine (e.g. Mozilla, Firefox).
             * @type Boolean
             */
            isGecko : isGecko,
            /**
             * True if the detected browser is Internet Explorer.
             * @type {Boolean}
             */
            isIE: isIE,
            /**
             * True if the detected browser is Internet Explorer 6.x.
             * @type {Boolean}
             */
            isIE6: isIE6,
            /**
             * True if the detected browser is Internet Explorer 7.x.
             * @type {Boolean}
             */
            isIE7: isIE7,
            /**
             * True if the detected browser is Internet Explorer 8.x.
             * @type {Boolean}
             */
            isIE8: isIE8,
            /**
             * True if the detected browser is Internet Explorer 9.x.
             * @type {Boolean}
             */
            isIE9: isIE9,
            /**
             * True if the detected browser is Internet Explorer 10.x.
             * @type Boolean
             */
            isIE10: isIE10,
            /**
             * True if the detected browser is a Internet Explorer which uses the old proprietary selection mode
             * @type {Boolean}
             */
            isOldIE: isOldIE,
            /**
             * True if the detected browser is a Internet Explorer which uses the W3C selection mode
             * @type {Boolean}
             */
            isW3cIE: isW3cIE,
            /**
             * True if the detected platform is Mac OS.
             * @type Boolean
             */
            isMac: isMac,
            /**
             * True if the detected browser is Chrome
             */
            isChrome: isChrome,
            /**
             * True if the detected browser is Safari
             */
            isSafari: isSafari,
            /**
             * True if a touch-enabled device is used
             */
            isTouch: isTouch
        },

        /**
         * Check if the given DOM node is the root node of the current editing context.
         * @param {CUI.rte.EditContext} context The edit context
         * @param {Node} dom DOM node to check
         * @return {Boolean} True if the given Node is a body node
         */
        isRootNode: function(context, dom) {
            return (context.root == dom);
        },

        /**
         * Check if the given DOM node has (one of) the given tag name(s).
         * <p>
         * Note that the method works case-insensitive; e.g. <code>isTag(dom, "IMG")</code>
         * and <code>isTag(dom, "img")</code> would both match an image tag.
         * @param {Node} dom dom DOM node to check
         * @param {String|Array} tagName name of the tag the node has to be checked against;
         *        if an array, the node will be checked if one of the specified tag names
         *        does match
         * @return {Boolean} True if the given node matches (one of) the given tag name(s)
         */
        isTag: function(dom, tagName) {
            if (!dom || (dom.nodeType != 1)) {
                return false;
            }
            var domTag = dom.tagName.toLowerCase();
            if (!CUI.rte.Utils.isArray(tagName)) {
                return (domTag == tagName.toLowerCase());
            }
            var tagCnt = tagName.length;
            for (var tagIndex = 0; tagIndex < tagCnt; tagIndex++) {
                if (domTag == tagName[tagIndex].toLowerCase()) {
                    return true;
                }
            }
            return false;
        },

        /**
         * Gets the namespace for the specified DOM element.
         * @param {HTMLElement} dom The DOM element to retrieve the namespace for
         * @return {String} The namespace of the specified DOM element; null if no namespace
         *         is available (= default HTML namespace)
         */
        getNamespace: function(dom) {
            var com = CUI.rte.Common;

            if (dom && dom.nodeType == 1) {
                // IE 10 doesn't support scopeName in Standards mode anymore, so check
                // before using it and rely on standard compliant behaviour otherwise
                if (com.ua.isIE && dom.scopeName) {
                    if (dom.scopeName != "HTML") {
                        return dom.scopeName.toLowerCase();
                    }
                } else {
                    var tagName = dom.tagName;
                    var sepPos = tagName.indexOf(":");
                    if (sepPos > 0) {
                        return tagName.substring(0, sepPos).toLowerCase();
                    }
                }
            }
            return null;
        },

        /**
         * Inserts the specified node before the second specified node in a
         * browser-independent way.
         * @param {HTMLElement} parentDom The parent node
         * @param {HTMLElement} dom The DOM element to insert
         * @param {HTMLElement} domRef The reference element; null to insert at the end
         *        of the existing child nodes of parentDom
         */
        insertBefore: function(parentDom, dom, domRef) {
            if (domRef != null) {
                parentDom.insertBefore(dom, domRef);
            } else {
                // IE6 bombs if we are using insertBefore(dom, null), so we are using
                // appendChild instead
                parentDom.appendChild(dom);
            }
        },

        /**
         * <p>Checks if the given DOM object has the specified attributes.</p>
         * <p>It is required that all attributes defined in the specified attribute
         * definition have equivalent values in the DOM object for this method to return
         * true.</p>
         * <p>Note that you can use "_class" or "className" to specifiy the name of the
         * class attribute.</p>
         * @param {HTMLElement} dom DOM object to check
         * @param {Object} attribs Attribute definition
         */
        hasAttributes: function(dom, attribs) {
            if (!dom || (dom.nodeType != 1)) {
                return false;
            }
            for (var name in attribs) {
                if (attribs.hasOwnProperty(name)) {
                    if ((name == "_class") || (name == "className")) {
                        name = "class";
                    }
                    var cmpValue = CUI.rte.Common.getAttribute(dom, name);
                    if (cmpValue != attribs[name]) {
                        return false;
                    }
                }
            }
            return true;
        },

        /**
         * <p>Check if an attribute of the specified name is defined for the specified DOM
         * node.</p>
         * <p>The method will also return false if the attribute is defined, but has no
         * content (attrib=""). This is required for IE(6) compoatibility.</p>
         * <p>Note that you can address the "class" attribute of the node through "class"
         * and the "style" attribute through "style".</p>
         * @param {HTMLElement} dom The DOM node to check
         * @param {String} attribName The attribute name to check
         * @return {Boolean} True, if the attribute is defined for the DOM node
         */
        isAttribDefined: function(dom, attribName) {
            var attribValue = CUI.rte.Common.getAttribute(dom, attribName, true);
            return (attribValue != null);
        },

        /**
         * <p>Gets the value of the attribute with the specified name in an
         * browser-independent way.</p>
         * <p>Note that you can address the "class" attribute of the node through "class"
         * and the "style" attribute through "style".</p>
         * @param {HTMLElement} dom The DOM node containing the attribute
         * @param {String} attribName The name of the attribute to retrieve
         * @param {Boolean} normalize True if empty attribute values (attrib="") should be
         *        returned as null rather than a String of length 0
         * @return {String} The attribute's value
         */
        getAttribute: function(dom, attribName, normalize) {
            var com = CUI.rte.Common;

            if (!dom) {
                return null;
            }
            var attribNameLC = attribName.toLowerCase();
            var attribValue;
            if ((attribNameLC == "style") && com.ua.isOldIE) {
                attribValue = dom.style.cssText;
            } else {
                // the "name" attribute of an "a" tag must be retrieved through the
                // "attributes" collection for IE 6/7; see bug #36231
                var tagName = dom.tagName.toLowerCase();
                if ((com.ua.isIE6 || com.ua.isIE7)
                        && ((attribNameLC == "name") && (tagName == "a"))) {
                    attribValue = dom.attributes["name"].nodeValue;
                } else {
                    attribValue = dom.getAttribute(
                            CUI.rte.Common.getIEAttributeName(attribName));
                }
            }
            if (normalize && ((attribValue != null) && (attribValue.length == 0))) {
                attribValue = null;
            }
            if (normalize && (attribValue != null)) {
                if ((attribNameLC == "colspan") || (attribNameLC == "rowspan")) {
                    try {
                        if (parseInt(attribValue) == 1) {
                            attribValue = null;
                        }
                    } catch (e) {
                        // ignored
                    }
                }
            }
            return attribValue;
        },

        /**
         * <p>Sets the value of the attribute with the specified name to the specified value
         * in a browser-independent way.</p>
         * <p>Note that you can address the "class" attribute of the node through "class"
         * and the "style" attribute through "style".</p>
         * @param {HTMLElement} dom The DOM element
         * @param {String} attribName The name of the attribute to be set
         * @param {String} attribValue The attribute value to be set
         */
        setAttribute: function(dom, attribName, attribValue) {
            var com = CUI.rte.Common,
                attribNameLC = attribName.toLowerCase();
            if (typeof attribValue != String) {
                attribValue = String(attribValue);
            }
            if ((attribNameLC == "style") && com.ua.isOldIE) {
                dom.style.cssText = attribValue;
                return;
            }
            // the "name" attribute of an "a" tag must be set through the "attributes"
            // collection for IE 6/7; see bug #36231
            if ((com.ua.isIE6 || com.ua.isIE7)
                    && ((attribNameLC == "name") && (dom.tagName.toLowerCase() == "a"))) {
                dom.attributes["name"].nodeValue = attribValue;
                return;
            }
            attribName = CUI.rte.Common.getIEAttributeName(attribName);
            dom.setAttribute(attribName, attribValue);
        },

        /**
         * Removes the specified attribute from the specified DOM element.
         * @param {HTMLElement} dom The DOM element
         * @param {String} attribName Name of attribute to remove
         */
        removeAttribute: function(dom, attribName) {
            var com = CUI.rte.Common;

            if (com.ua.isOldIE) {
                if (attribName == "style") {
                    dom.style.cssText = null;
                    return;
                }
            }
            dom.removeAttribute(CUI.rte.Common.getIEAttributeName(attribName));
        },

        /**
         * Copies an attribute from dom1 to dom2 if it is actually available on dom1.
         * @param {HTMLElement} dom1 The source DOM element
         * @param {HTMLElement} dom2 The destination DOM element
         * @param {String} attribName The name of the attribute to be copied
         */
        copyAttribute: function(dom1, dom2, attribName) {
            var attribValue = dom1[attribName];
            if (attribValue != null) {
                dom2[attribName] = attribValue;
            }
        },

        /**
         * Copies all available attributes from dom1 to dom2.
         * @param {HTMLElement} dom1 The source DOM element
         * @param {HTMLElement} dom2 The destination DOM element
         * @param {String[]} excludedAttribs (optional) List of attribute names to be
         *        excluded from copying
         */
        copyAttributes: function(dom1, dom2, excludedAttribs) {
            var com = CUI.rte.Common;
            var a, attributeCnt, attrib, attribName;
            if (com.ua.isIE6 || com.ua.isIE7) {
                // IE needs a special way of handling things again ...
                var attribNames = com.getIEAttributeNames(dom1, true);
                attributeCnt = attribNames.length;
                for (a = 0; a < attributeCnt; a++) {
                    attribName = attribNames[a];
                    if ((excludedAttribs == null)
                            || !com.arrayContains(excludedAttribs, attribName)) {
                        var attribValue;
                        var attribNameLC = attribName.toLowerCase();
                        if (attribNameLC == "style") {
                           attribValue = dom1.style.cssText;
                        } else if (attribNameLC == "class") {
                            attribValue = dom1.getAttribute("className");
                            attribName = "className";
                        } else if (com.isTag(dom1, "a") && (attribNameLC == "name")) {
                            attribValue = dom1.attributes["name"].nodeValue;
                        } else {
                            attribValue = dom1.getAttribute(attribName);
                        }
                        if (attribValue != null) {
                            if (attribNameLC == "style") {
                                dom2.style.cssText = attribValue;
                            } else if (com.isTag(dom2, "a") && (attribNameLC == "name")) {
                                dom2.attributes["name"].nodeValue = attribValue;
                            } else {
                                dom2.setAttribute(attribName, attribValue);
                            }
                        }
                    }
                }
                return;
            }
            var attribs = dom1.attributes;
            attributeCnt = attribs.length;
            for (a = 0; a < attributeCnt; a++) {
                attrib = attribs[a];
                attribName = attrib.name;
                attribName = (com.ua.isIE8 ? attribName.toLowerCase() : attribName);
                if ((excludedAttribs == null)
                        || !com.arrayContains(excludedAttribs, attribName)) {
                    // don't need colspan/rowspan's of 1, as reported by IE 8
                    var value = attrib.value;
                    if (com.ua.isIE8) {
                        if ((attribName == "colspan") || (attribName == "rowspan")) {
                            if (value == "1") {
                                value = null;
                            }
                        }
                    }
                    if (value != null) {
                        dom2.setAttribute(attribName, attrib.value);
                    }
                }
            }
        },

        /**
         * <p>Compares the attributes of the specified DOM elements.</p>
         * <p>Note that attributes that are reported to be empty are omitted.</p>
         * @param {HTMLElement} dom1 The first element
         * @param {HTMLElement} dom2 The second element
         * @return {Boolean} True if both elements share the same attributes
         */
        compareAttributes: function(dom1, dom2) {
            var com = CUI.rte.Common;
            var name, value, cmpValue;
            var attribs1 = dom1.attributes;
            var attribs2 = dom2.attributes;
            var a1Cnt = attribs1.length;
            for (var a1 = 0; a1 < a1Cnt; a1++) {
                name = attribs1[a1].name;
                value = com.getAttribute(dom1, name, true);
                if (value != null) {
                    cmpValue = com.getAttribute(dom2, name, true);
                    if (cmpValue != value) {
                        return false;
                    }
                }
            }
            var a2Cnt = attribs2.length;
            for (var a2 = 0; a2 < a2Cnt; a2++) {
                name = attribs2[a2].name;
                value = com.getAttribute(dom2, name, true);
                if (value != null) {
                    cmpValue = com.getAttribute(dom1, name, true);
                    if (cmpValue != value) {
                        return false;
                    }
                }
            }
            return true;
        },

        /**
         * Creates an array with the names of all attributes of the specified DOM element.
         * @param {HTMLElement} dom The DOM element
         * @param {Boolean} keepCase (optional) True if the case of attribute names should
         *        be preserved
         * @param {Function} filter (optional) A filter method that allows to filter out a
         *        specific attribute; gets the DOM element, the attribute name and the
         *        lower case representation of the attribute's name as parameters; must
         *        return true to filter out the attribute.
         * @return {String[]} Array with all attribute names
         */
        getAttributeNames: function(dom, keepCase, filter) {
            var com = CUI.rte.Common;

            if (com.ua.isOldIE) {
                return CUI.rte.Common.getIEAttributeNames(dom, keepCase, filter);
            }
            // this is the correct method to determine valid DOM attributes on other
            // browsers
            var attribNames = [ ];
            var attribCnt = dom.attributes.length;
            for (var a = 0; a < attribCnt; a++) {
                var attribName = dom.attributes.item(a).nodeName;
                var attribNameLC = attribName.toLowerCase();
                var isFilteredOut = false;
                if (filter) {
                    isFilteredOut = filter(dom, attribName, attribNameLC);
                }
                if (!isFilteredOut) {
                    attribNames.push(keepCase ? attribName : attribNameLC);
                }
            }
            return attribNames;
        },

        /**
         * Gets all DOM nodes below the specified node (including the node itself) that are
         * of the specified type.
         * @param {HTMLElement} dom DOM node to check (recursively)
         * @param {String|String[]} tagName Tag name(s) of the specified type(s)
         * @return {HTMLElement[]} Array containing all specified tags
         */
        getTags: function(dom, tagName, nodes) {
            if (!nodes) {
                nodes = [ ];
            }
            var com = CUI.rte.Common;
            if (com.isTag(dom, tagName)) {
                nodes.push(dom);
            }
            if (dom.nodeType == 1) {
                var childCnt = dom.childNodes.length;
                for (var c = 0; c < childCnt; c++) {
                    com.getTags(dom.childNodes[c], tagName, nodes);
                }
            }
            return nodes;
        },

        /**
         * Checks if the specified DOM node or one of its descendants is of the specified
         * type.
         * @param {HTMLElement} dom DOM node to check (recursively)
         * @param {String} tagName Tag name of the specified type
         */
        containsTag: function(dom, tagName) {
            var com = CUI.rte.Common;
            if (com.isTag(dom, tagName)) {
                return true;
            }
            if (dom.nodeType == 1) {
                var childCnt = dom.childNodes.length;
                for (var c = 0; c < childCnt; c++) {
                    if (com.containsTag(dom.childNodes[c], tagName)) {
                        return true;
                    }
                }
            }
            return false;
        },

        /**
         * Checks if the specified DOM nodes are equal. This is the case if both nodes
         * share the same tag name and all attributes (structure nodes) or their text
         * contents are equal (text nodes).
         * @param {HTMLElement} dom1 first DOM node
         * @param {HTMLElement} dom2 second DOM node
         * @return {Boolean} true if both DOM nodes are equal according to the rules
         *         specified above
         */
        equals: function(dom1, dom2) {
            var com = CUI.rte.Common;
            if (dom1.nodeType != dom2.nodeType) {
                return false;
            }
            if (dom1.nodeType == 3) {
                return (dom1.nodeValue == dom2.nodeValue);
            }
            if (dom1.tagName.toLowerCase() != dom2.tagName.toLowerCase()) {
                return false;
            }
            return com.compareAttributes(dom1, dom2);
        },

        /**
         * <p>Adds the specified text node to the specified parentNode. If nodeBefore is
         * specified, the text node is inserted before that node. Otherwise, it is appended
         * to the current list of child nodes.</p>
         * <p>Note that this method merges the node with existing text nodes if possible.
         * It returns the actual node and character offset, if the text node has been
         * merged.</p>
         * @param {HTMLElement} dom Text node to append
         * @param {HTMLElement} parentNode Parent node
         * @param {HTMLElement} nodeBefore The node the text has to be inserted before
         * @return {Object} Object defining the actual insert operation; properties:
         *         dom, startPos, charCnt
         */
        addTextNode: function(dom, parentNode, nodeBefore) {
            var text = dom.nodeValue;
            var charCnt = text.length;
            var childCnt = parentNode.childNodes.length;
            if (childCnt == 0) {
                parentNode.appendChild(dom);
                return {
                    "dom": dom,
                    "startPos": 0,
                    "charCnt": charCnt
                };
            }
            var nextSibling = nodeBefore;
            if (nextSibling && (nextSibling.nodeType != 3)) {
                nextSibling = null;
            }
            var prevSibling;
            if (nodeBefore) {
                prevSibling = nodeBefore.previousSibling;
            } else {
                prevSibling = parentNode.lastChild;
            }
            if (prevSibling && (prevSibling.nodeType != 3)) {
                prevSibling = null;
            }
            var startOffs = (prevSibling ? prevSibling.nodeValue.length : 0);
            if (nextSibling && prevSibling) {
                prevSibling.nodeValue += text + nextSibling.nodeValue;
                dom = prevSibling;
                parentNode.removeChild(nextSibling);
            } else if (nextSibling) {
                nextSibling.nodeValue = text + nextSibling.nodeValue;
                dom = nextSibling;
            } else if (prevSibling) {
                prevSibling.nodeValue += text;
                dom = prevSibling;
            } else {
                if (nodeBefore) {
                    parentNode.insertBefore(dom, nodeBefore);
                } else {
                    parentNode.appendChild(dom);
                }
            }
            return {
                "dom": dom,
                "startPos": startOffs,
                "charCnt": charCnt
            };
        },

        /**
         * Get the textual "payload" of the given text node.
         * <p>
         * The payload is the character data that is actually relevant for node/character
         * calculations. It does not have any whitespace in it.
         * @param {Node} node text DOM node (<code>nodeType == 3</code>)
         * @return {String} the textual payload of the given text node
         */
        getNodeText: function(node) {
            if (node.nodeType != 3) {
                return "";
            }
            var nodeText = node.nodeValue;
            if (nodeText) {
                nodeText = nodeText.replace(/[\n\t\r]/g, "");
            }
            return nodeText;
        },

        /**
         * <p>Checks if the specified DOM element represents a (structural) node that must
         * be counted as a character, rather than being ignored for character position
         * calculation. (For example: br, img, a name).</p>
         * <p>Please note that this method does not count empty edit blocks
         * (&lt;p&gt;&lt;/p&gt;) as one character nodes, although they are actually counted
         * as one character nodes due to invalid recursion.</p>
         * @param {HTMLElement} dom The DOM element to be checked
         * @return {Boolean} True if the DOM element must be counted as a character
         */
        isOneCharacterNode: function(dom) {
            if (!dom || (dom.nodeType == 3)) {
                return false;
            }
            var com = CUI.rte.Common;
            var tagList = com.ONE_CHARACTER_NODES;
            for (var i = 0; i < tagList.length; i++) {
                var isMatching = com.matchesTagDef(dom, tagList[i]);
                if (isMatching) {
                    return true;
                }
            }
            return false;
        },

        /**
         * Checks if the specified DOM element represents a character node. A character node
         * is a node that must be counted as a character (regarding caret movement et al).
         * All text nodes are character node. Additionally, several structural nodes (like
         * "a name", "br", "img") are character nodes.
         * @param {HTMLElement} dom The DOM element to be checked
         * @return {Boolean} True if the DOM element is a character
         */
        isCharacterNode: function(dom) {
            if (!dom) {
                return false;
            }
            return (dom.nodeType == 3) || CUI.rte.Common.isOneCharacterNode(dom);
        },

        /**
         * Checks if the specified DOM element represents an editable node. A editable
         * node is a text node, a "one character" structural node and empty edit blocks.
         * @param {HTMLElement} dom The DOM element to be checked
         * @return {Boolean} True if the DOM element is an editable node
         */
        isEditableNode: function(dom) {
            if (!dom) {
                return false;
            }
            var com = CUI.rte.Common;
            return com.isCharacterNode(dom) || com.isEmptyEditingBlock(dom, true);
        },

        /**
         * Checks if the specified node is a or contains at least one character node (as a
         * child node).
         * @param {HTMLElement} dom The DOM element to be checked
         * @return {Boolean} True if the DOM element contains at least one character
         */
        containsCharacterNode: function(dom) {
            var com = CUI.rte.Common;
            if (com.isCharacterNode(dom)) {
                return true;
            }
            if (dom.nodeType != 1) {
                return false;
            }
            var children = dom.childNodes;
            var childCnt = children.length;
            for (var c = 0; c < childCnt; c++) {
                if (com.containsCharacterNode(children[c])) {
                    return true;
                }
            }
            return false;
        },

        /**
         * Determines all character nodes for the subtree starting at the specified node.
         * @param {HTMLElement} dom
         * @return {HTMLElement[]} Array containing all character nodes
         */
        getCharacterNodes: function(dom, array) {
            var com = CUI.rte.Common;
            if (!array) {
                array = [ ];
            }
            if (com.isCharacterNode(dom)) {
                array.push(dom);
            }
            if (dom.nodeType == 1) {
                var children = dom.childNodes;
                var childCnt = children.length;
                for (var c = 0; c < childCnt; c++) {
                    com.getCharacterNodes(children[c], array);
                }
            }
            return array;
        },

        /**
         * Checks if the specified node is an empty edit block tag (ie &lt;p&gt;&lt;/p&gt;,
         * which is used by IE).
         * @param {HTMLElement} dom The DOM element to be checked
         * @param {Boolean} checkDeep (optional) True if the specified node will qualify
         *        as "empty" if it has no "character" child nodes. False, if the specified
         *        node must only qualify as "empty" if it has no child nodes
         * @return {Boolean} True if the DOM element is an empty edit block
         */
        isEmptyEditingBlock: function(dom, checkDeep) {
            var com = CUI.rte.Common;
            if (dom.nodeType == 3) {
                return false;
            }
            if (!com.isTag(dom, com.EDITBLOCK_TAGS)) {
                return false;
            }
            if (!checkDeep) {
                return (dom.childNodes.length == 0);
            }
            return !com.containsCharacterNode(dom);
        },

        /**
         * Get the number of characters of the given node that are relevant for the
         * calculation of character positions.
         * <p>
         * Note that this method does not work recursively.
         * @see CUI.rte.Common.getNodeText
         * @param {Node} node DOM node
         * @return {Number} Number of relevant characters
         */
        getNodeCharacterCnt: function(node) {
            var com = CUI.rte.Common;
            if (node.nodeType == 1) {
                if (com.isOneCharacterNode(node)) {
                    return 1;
                }
                // consider empty edit blocks as well
                if (com.isEmptyEditingBlock(node, true)) {
                    return 1;
                }
                return 0;
            }
            var nodeText = CUI.rte.Common.getNodeText(node);
            if (nodeText) {
                return nodeText.length;
            }
            return 0;
        },

        /**
         * <p>Gets the number of characters of the specified node and all of its subnodes
         * that are relevant for the calculation of character positions.</p>
         * <p>Note that this method works recursively and doesn't consider edit block roots
         * ("p", "td", "li").</p>
         * .
         * @see CUI.rte.Common.getNodeText
         * @param {Node} node DOM node
         * @return {Number} Number of relevant characters
         */
        getNodeTextLength: function(node) {
            var com = CUI.rte.Common;
            if (node.nodeType == 3) {
                return com.getNodeCharacterCnt(node);
            } else if (node.nodeType == 1) {
                var charCnt = com.getNodeCharacterCnt(node);
                var childCnt = node.childNodes.length;
                for (var childIndex = 0; childIndex < childCnt; childIndex++) {
                    var childToProcess = node.childNodes[childIndex];
                    charCnt += com.getNodeTextLength(childToProcess);
                }
                return charCnt;
            }
            return 0;
        },

        /**
         * Get the node at the given character position.
         * @param {CUI.rte.EditContext} context The edit context
         * @param {Number} pos character position to be calculated
         * @return {Object} definition of the DOM node at the given character position
         */
        getNodeAtPosition: function(context, pos) {
            var state = {
                "node": null,
                "charPos": 0,
                "nodeBefore": null
            };
            getNodeAtPositionRec(context, context.root, state, pos);
            var node = state.node;
            if (!node) {
                if (!state.nodeBefore) {
                    return null;
                }
                node = {
                    "dom": null,
                    "nodeBefore": state.nodeBefore
                };
            }
            return node;
        },

        /**
         * Calculates the character position of the given node.
         * @param {CUI.rte.EditContext} context The edit context
         * @param {Node} node DOM node for which the character offset is to be calculated
         * @return {Number} Character position for the given node
         */
        getCharacterOffsetForNode: function(context, node) {
            return getCharacterOffsetForNodeRec(context, node, 0, context.root).charPos;
        },

        /**
         * <p>Get the previous sibling of the specified DOM node.</p>
         * <p>This method considers multiple hierarchical levels (whereas
         * HTMLElement.nextSibling only works on the same hierarchical level) and can be
         * used for DOM walking.</p>
         * @param {CUI.rte.EditContext} context The edit context
         * @param {HTMLElement} node The DOM node
         * @return {HTMLElement} previous sibling of dom; <code>null</code> if
         *         there is no previous sibling
         */
        getPreviousNode: function(context, node) {
            if (node.previousSibling) {
                node = node.previousSibling;
                while (true) {
                    var childCnt = node.childNodes.length;
                    if (childCnt == 0) {
                        return node;
                    }
                    node = node.childNodes[childCnt - 1];
                }
            }
            return CUI.rte.Common.getParentNode(context, node);
        },

        /**
         * <p>Get the previous text sibling of the given DOM node.</p>
         * <p>Note that "text like" structural elements (like br or img) are not considered
         * by this method.</p>
         * <p>Note on handling break tags: the method will not return a previous node if
         * break tags are specified and the initial node's type is one of the break tags.
         * This is contrary to the behaviour of {@link #getNextTextNode}, but correct in
         * the context of DOM traversal.</p>
         * @param {CUI.rte.EditContext} context The edit context
         * @param {HTMLElement} node The DOM node
         * @return {HTMLElement} previous text sibling of dom; null if there is no previous
         *         sibling
         */
        getPreviousTextNode: function(context, node, breakTags) {
            var com = CUI.rte.Common;
            if (breakTags && com.isTag(node, breakTags)) {
                return null;
            }
            do {
                node = com.getPreviousNode(context, node);
                if (breakTags && com.isTag(node, breakTags)) {
                    node = null;
                    break;
                }
            } while (node && (node.nodeType != 3));
            return node;
        },

        /**
         * <p>Get the previous sibling of the given DOM node that is handled as a character
         * node in the context of positioning the caret.</p>
         * <p>Hence "text like" structural elements (like br or img) are considered by this
         * method.</p>
         * <p>Note on handling break tags: the method will not return a previous node if
         * break tags are specified and the initial node's type is one of the break tags.
         * This is contrary to the behaviour of {@link #getNextCharacterNode}, but
         * correct in the context of DOM traversal.</p>
         * @param {CUI.rte.EditContext} context The edit context
         * @param {HTMLElement} node The DOM node
         * @return {HTMLElement} previous sibling of dom that is a text node or has to be
         *         handled like a character for caret positioning; null if there is no
         *         previous sibling
         */
        getPreviousCharacterNode: function(context, node, breakTags) {
            var com = CUI.rte.Common;
            // if we're looking for a previous node, we'll have to check the starting
            // node also, contrary to getNextCharacterNode
            if (breakTags && com.isTag(node, breakTags)) {
                return null;
            }
            do {
                node = com.getPreviousNode(context, node);
                if (breakTags && com.isTag(node, breakTags)) {
                    node = null;
                    break;
                }
            } while (node && (com.getNodeCharacterCnt(node) == 0));
            return node;
        },

        /**
         * <p>Get the previous sibling of the given DOM node that is editable.</p>
         * <p>This method returns text nodes, "one character" structural nodes and
         * empty editing blocks (IE only).</p>
         * <p>Note on handling break tags: the method will not return a previous node if
         * break tags are specified and the initial node's type is one of the break tags.
         * This is contrary to the behaviour of {@link #getNextTextNode}, but correct in
         * the context of DOM traversal.</p>
         * @param {CUI.rte.EditContext} context The edit context
         * @param {HTMLElement} node The DOM node
         * @return {HTMLElement} next sibling of dom that is a text node or has to be
         *         handled like a character for caret positioning; null if there is no
         *         next sibling
         */
        getPreviousEditableNode: function(context, node, breakTags) {
            var com = CUI.rte.Common;
            if (!node) {
                return null;
            }
            if (breakTags && com.isTag(node, breakTags)) {
                return null;
            }
            do {
                node = com.getPreviousNode(context, node);
                if (breakTags && com.isTag(node, breakTags)) {
                    node = null;
                    break;
                }
            } while (node && !com.isEditableNode(node));
            return node;
        },

        /**
         * <p>Get the next sibling of the specified DOM node.</p>
         * <p>This method considers multiple hierarchical levels (whereas
         * HTMLElement.nextSibling only works on the same hierarchical level) and can be
         * used for DOM walking.</p>
         * @param {CUI.rte.EditContext} context The edit context
         * @param {HTMLElement} node The DOM node
         * @return {HTMLElement} next sibling of dom; null if there is no next sibling
         */
        getNextNode: function(context, node) {
            if (node.childNodes.length > 0) {
                return node.childNodes[0];
            }
            if (node.nextSibling) {
                return node.nextSibling;
            }
            while (true) {
                node = CUI.rte.Common.getParentNode(context, node);
                if (!node) {
                    return null;
                }
                if (node.nextSibling) {
                    return node.nextSibling;
                }
            }
        },

        /**
         * <p>Get the next text sibling of the specified DOM node.</p>
         * <p>Note that "text like" structural elements (like br or img) are not considered
         * by this method.</p>
         * <p>Note on handling break tags: the method will return a next node if break tags
         * are specified and the initial node's type is one of the break tags. This is
         * contrary to the behaviour of {@link #getPreviousTextNode}, but correct in
         * the context of DOM traversal.</p>
         * @param {CUI.rte.EditContext} context The edit context
         * @param {HTMLElement} node The DOM node
         * @return {HTMLElement} next text sibling of dom; null if there is no previous
         *         sibling
         */
        getNextTextNode: function(context, node, breakTags) {
            var com = CUI.rte.Common;
            do {
                node = com.getNextNode(context, node);
                if (breakTags && com.isTag(node, breakTags)) {
                    node = null;
                    break;
                }
            } while (node && (node.nodeType != 3));
            return node;
        },

        /**
         * <p>Get the next sibling of the given DOM node that is handled as a character
         * node in the context of positioning the caret.</p>
         * <p>Hence "text like" structural elements (like br or img) are considered by this
         * method.</p>
         * <p>Note on handling break tags: the method will return a next node if break tags
         * are specified and the initial node's type is one of the break tags. This is
         * contrary to the behaviour of {@link #getPreviousCharacterNode}, but correct in
         * the context of DOM traversal.</p>
         * @param {CUI.rte.EditContext} context The edit context
         * @param {HTMLElement} node The DOM node
         * @return {HTMLElement} next sibling of dom that is a text node or has to be
         *         handled like a character for caret positioning; null if there is no
         *         next sibling
         */
        getNextCharacterNode: function(context, node, breakTags) {
            var com = CUI.rte.Common;
            do {
                node = com.getNextNode(context, node);
                if (breakTags && com.isTag(node, breakTags)) {
                    node = null;
                    break;
                }
            } while (node && (com.getNodeCharacterCnt(node) == 0));
            return node;
        },

        /**
         * <p>Get the next sibling of the given DOM node that is editable.</p>
         * <p>This method returns text nodes, "one character" structural nodes and
         * empty editing blocks (IE only).</p>
         * <p>Note on handling break tags: the method will return a next node if break tags
         * are specified and the initial node's type is one of the break tags. This is
         * contrary to the behaviour of {@link #getPreviousEditableNode}, but correct in
         * the context of DOM traversal.</p>
         * @param {CUI.rte.EditContext} context The edit context
         * @param {HTMLElement} node The DOM node
         * @return {HTMLElement} next sibling of dom that is a text node or has to be
         *         handled like a character for caret positioning; null if there is no
         *         next sibling
         */
        getNextEditableNode: function(context, node, breakTags) {
            var com = CUI.rte.Common;
            if (!node) {
                return null;
            }
            do {
                node = com.getNextNode(context, node);
                if (breakTags && com.isTag(node, breakTags)) {
                    node = null;
                    break;
                }
            } while (node && !com.isEditableNode(node));
            return node;
        },

        /**
         * <p>Check if dom1 is an ancestor node of dom2.</p>
         * <p>Note that this method will (correctly) return false if dom1 == dom2.</p>
         * @param {HTMLElement} dom1 potential DOM ancestor node
         * @param {HTMLElement} dom2 potential DOM descendant node
         * @return {Boolean} True if <code>dom1</code> is an ancestor node
         *         of <code>dom2</code>
         */
        isAncestor: function(context, dom1, dom2) {
            do {
                dom2 = CUI.rte.Common.getParentNode(context, dom2);
                if (dom2) {
                    if (dom2 == dom1) {
                        return true;
                    }
                }
            } while (dom2);
            return false;
        },

        /**
         * Checks if any of the descendant nodes of the specified sub-tree root has any of
         * the specified tags.
         * @param {HTMLElement} subTreeRoot The sub-tree root to check (node not included)
         * @param {String/String[]} tags The tag(s) to check against
         */
        isLastChildDeep: function(subTreeRoot, tags) {
            var com = CUI.rte.Common;
            var checkNode = subTreeRoot;
            do {
                if (checkNode.nodeType != 1) {
                    return false;
                }
                var children = checkNode.childNodes;
                if (children.length == 0) {
                    return false;
                }
                checkNode = children[children.length - 1];
                if (com.isTag(checkNode, tags)) {
                    return true;
                }
            } while (true);
        },

        /**
         * Checks if the specified element is the last element of a nesting level, for
         * example the last cell of a table that is nested into another table.
         * @param {CUI.rte.EditContext} context The edit context
         * @param {HTMLElement} node The node to check
         */
        isLastElementOfNestingLevel: function(context, node) {
            var com = CUI.rte.Common;
            // get the corresponding nesting element
            while (!com.isTag(node, com.EDITBLOCK_NESTED_TAGS)
                    && !com.isTag(node, com.EDITBLOCK_UNREGNEST_TAGS)) {
                node = com.getParent(context, node);
                if (!node) {
                    return false;
                }
            }
            var pNode = com.getParentNode(context, node);
            if (!pNode) {
                return false;
            }
            var maxChild = pNode.childNodes.length - 1;
            if (com.getChildIndex(node) != maxChild) {
                return false;
            }
            // this is only valid for nested tags, so ensure that we are actually in a
            // nested context
            // todo check if this is true for mixed nestings (list in a table/table in a list)
            if (!com.containsTagInPath(context, pNode, com.EDITBLOCK_UNREGNEST_TAGS)
                    && !com.containsTagInPath(context, pNode, com.EDITBLOCK_NESTED_TAGS)) {
                return false;
            }
            // ok, we are last in the list of the parent element; this may not be enough
            // (we may have found last cell of a row, but not of the entire table), so
            // we'll do some further element-specific stuff here
            if (com.isTag(node, [ "td", "th" ])) {
                var tBody = com.getParentNode(context, pNode);
                if (!tBody) {
                    return false;
                }
                maxChild = tBody.childNodes.length - 1;
                return (com.getChildIndex(pNode) == maxChild);
            }
            // in case of a list item, we can have multiple adjacent nested lists on the
            // same hierarchical level; this method must return false for all nested list
            // items besides the very last item
            if (com.isTag(node, "li")) {
                var list = node.parentNode;
                return com.isLastNestedList(context, list);
            }
            return true;
        },

        /**
         * Gets the index that the given DOM node has in the <code>childNodes</code> array
         * of its parent node.
         * @param {HTMLElement} node The DOM node to check
         * @return {Number} child index in dom's parent node; -1 if the specified DOM node
         *         has no parent
         */
        getChildIndex: function(node) {
            if (!node.parentNode) {
                return -1;
            }
            var childCnt = node.parentNode.childNodes.length;
            for (var childIndex = 0; childIndex < childCnt; childIndex++) {
                if (node.parentNode.childNodes[childIndex] == node) {
                    return childIndex;
                }
            }
            return -1;
        },

        /**
         * Get the last "deep-child" of the given node.
         * <p>
         * This method works recursively. It will actually get the last descendant node.
         * @param {HTMLElement} node DOM node
         * @return {HTMLElement} The last descendant node; null if there are no
         *         descendant nodes
         */
        getLastChild: function(node, isRecCall) {
            var com = CUI.rte.Common;
            if (node.nodeType == 3) {
                return node;
            }
            var childCnt = node.childNodes.length;
            if (childCnt == 0) {
                return (isRecCall ? node : null);
            }
            return com.getLastChild(node.childNodes[childCnt - 1], true);
        },

        /**
         * <p>Get the first "deep-child" of the given node.</p>
         * <p>This method works recursively. It will actually get the first descendant node.
         * </p>
         * @param {HTMLElement} node DOM node
         * @return {HTMLElement} The first descendant node; null if there are no
         *         descendant nodes
         */
        getFirstChild: function(node, isRecCall) {
            var com = CUI.rte.Common;
            if (node.nodeType == 3) {
                return node;
            }
            var childCnt = node.childNodes.length;
            if (childCnt == 0) {
                return (isRecCall ? node : null);
            }
            return com.getFirstChild(node.childNodes[0], true);
        },

        /**
         * Check if the given node has a textual descendant node (or is itself a textual
         * node).
         * <p>
         * Note on using useTextLen: If set to true, this method will also consider
         * "text-like" structural DOM nodes (such as br) as text.
         * @param {HTMLElement} node Node to check
         * @param {Boolean} useTextLen True if the text length should be used (instead of
         *        the actual nodeType) to determine if a given node has a textual descendant
         *        node
         * @return {Boolean} True if the given node has a textual descendant, else false
         */
        hasTextChild: function(node, useTextLen) {
            return (CUI.rte.Common.getFirstTextChild(node, useTextLen) != null);
        },

        /**
         * <p>Get the first descendant text node of the given node.</p>
         * <p>Note on using useTextLen: If set to true, this method will also consider
         * "text-like" structural DOM nodes (such as br) as text. So be aware that you
         * might get a non-textual node as a result if you are setting this option.</i>
         * @param {HTMLElement} node Node for which the text node has to be determined
         * @param {Boolean} useTextLen True if the text length should be used (instead of
         *        the actual nodeType) to determine if a given node contains text
         * @param {Boolean} includeSelf True if the specified node itself is considered as
         *        a potential text node
         * @return {HTMLElement} The first descendant text node; null, if there is no
         *         text node available
         */
        getFirstTextChild: function(node, useTextLen, includeSelf) {
            var com = CUI.rte.Common;
            if (includeSelf) {
                if (useTextLen) {
                    if (com.getNodeCharacterCnt(node) > 0) {
                        return node;
                    }
                } else if (node.nodeType == 3) {
                    return node;
                }
            }
            var childCnt = node.childNodes.length;
            for (var c = 0; c < childCnt; c++) {
                var textNode = com.getFirstTextChild(node.childNodes[c], useTextLen, true);
                if (textNode) {
                    return textNode;
                }
            }
            return null;
        },

        /**
         * Get the last descendant text node of the given node.
         * @param {HTMLElement} node Node for which the text node has to be determined
         * @param {Boolean} useTextLen True if the text length should be used (instead of
         *        the actual nodeType) to determine if a given node contains text
         * @param {Boolean} includeSelf True if the specified node itself is considered as
         *        a potential text node
         * @return {HTMLElement} The last descendant text node; null, if there is no
         *         text node available
         */
        getLastTextChild: function(node, useTextLen, includeSelf) {
            var com = CUI.rte.Common;
            if (includeSelf) {
                if (useTextLen) {
                    if (com.getNodeCharacterCnt(node) > 0) {
                        return node;
                    }
                } else if (node.nodeType == 3) {
                    return node;
                }
            }
            var childCnt = node.childNodes.length;
            for (var c = childCnt - 1; c >= 0; c--) {
                var textNode = com.getLastTextChild(node.childNodes[c], useTextLen, true);
                if (textNode) {
                    return textNode;
                }
            }
            return null;
        },

        /**
         * Creates an (independent) array of the specified node's child nodes.
         * @param {HTMLElement} dom The node to create the child's list from
         * @return {HTMLElement[]} List of child nodes
         */
        childNodesAsArray: function(dom) {
            var array = [ ];
            if (dom.nodeType == 1) {
                var childCnt = dom.childNodes.length;
                for (var c = 0; c < childCnt; c++) {
                    array.push(dom.childNodes[c]);
                }
            }
            return array;
        },

        /**
         * Get the parent node of the given DOM node, up to (and including) the
         * document's root node.
         * @param {CUI.rte.EditContext} context The edit context
         * @param {HTMLElement} node DOM node for which the parent node has to be determined
         * @return {HTMLElement} parent node; <code>null</code> if the given node has no
         *         more "content" parent nodes
         */
        getParentNode: function(context, node) {
            if (node == context.root) {
                return null;
            }
            return node.parentNode;
        },

        /**
         * <p>Checks if the specified node is a "zombie node".</p>
         * <p>Later Gecko versions introduced the behaviour that sometimes nodes get
         * referenced (for example by the selection) that are not connected to the
         * document anymore. This method can be used to detect such cases.</p>
         * @param {CUI.rte.EditContext} context The edit context
         * @param {HTMLElement} dom The DOM node to check
         * @return {Boolean} True if the specified node is a zombie node
         */
        isZombieNode: function(context, dom) {
            while (dom) {
                if (dom == context.root) {
                    return false;
                }
                dom = dom.parentNode;
            }
            return true;
        },

        /**
         * Get the "block node" for the given DOM node.
         * <p>
         * Note that this method does only return the ancestor node (of <code>dom</code>)
         * that is a direct child of the document's root element. For proper block node
         * detection see the {@link #BLOCK_TAGS} array.
         * @see CUI.rte.DomProcessor#getScopedBlockNode
         * @param {CUI.rte.EditContext} context The edit context
         * @param {HTMLElement} dom DOM node for which the "block node" has to be determined
         * @deprecated Use proper detection of block nodes instead
         */
        getBlockNode: function(context, dom) {
            var com = CUI.rte.Common;
            while (dom) {
                if (com.getParentNode(context, dom.parentNode) == null) {
                    return dom;
                }
                dom = dom.parentNode;
            }
            return null;
        },

        /**
         * Checks if the given DOM node is a "block node".
         * <p>
         * Note that this method only checks if the given node is a direct child of the
         * document's body tag. For proper block node detection see the {@link #BLOCK_TAGS}
         * array.
         * @param {CUI.rte.EditContext} context The edit context
         * @param {HTMLElement} dom DOM node to check
         * @return {Boolean} True if the given DOM node is a direct child of
         *         the document's body element
         * @deprecated Use proper detection of block nodes instead
         */
        isBlockNode: function(context, dom) {
            return (dom && dom.parentNode
                    && CUI.rte.Common.isRootNode(context, dom.parentNode));
        },

        /**
         * @deprecated Use proper detection of block nodes instead
         */
        getLastBlockNode: function(context, dom) {
            while (!CUI.rte.Common.isRootNode(context, dom)) {
                dom = dom.parentNode;
            }
            var blocks = context.root.childNodes;
            if (blocks.length == 0) {
                return null;
            }
            return blocks[blocks.length - 1];
        },

        hasContent: function(dom) {
            if (dom.nodeType == 3) {
                return true;
            }
            var childCnt = dom.childNodes.length;
            if (childCnt == 0) {
                return false;
            }
            for (var childIndex = 0; childIndex < childCnt; childIndex++) {
                var childToProcess = dom.childNodes[childIndex];
                if (childToProcess.nodeType == 3) {
                    var text = childToProcess.nodeValue;
                    text = text.replace(/[\n\t\r \u00A0]/g, "");
                    if (text.length > 0) {
                        return true;
                    }
                } else {
                    var hasChildContent = CUI.rte.Common.hasContent(
                            childToProcess);
                    if (hasChildContent) {
                        return true;
                    }
                }
            }
            return false;
        },

        /**
         * <p>Gets the first node "up the DOM tree" that matches the specified tag
         * definition (tag name and attributes).</p>
         * <p>If the specified DOM matches the tag definition itself, it is returned instead
         * of any super matching element.</p>
         * @param {CUI.rte.EditContext} context
         * @param {HTMLElement} dom The DOM element to start DOM traversal with
         * @param {String} tagName The tag name to check for
         * @param {Object} attribs Attribute definition
         * @return {HTMLElement} The first super element that matches the specified
         *         tag definition; null if no such element exists
         */
        getTagInPath: function(context, dom, tagName, attribs) {
            var com = CUI.rte.Common;
            while (dom) {
                if (dom.nodeType == 1) {
                    if (dom == context.root) {
                        return null;
                    }
                    if (com.isTag(dom, tagName)) {
                        if (!attribs || com.hasAttributes(dom, attribs)) {
                            return dom;
                        }
                    }
                }
                dom = com.getParentNode(context, dom);
            }
            return null;
        },

        containsTagInPath: function(context, dom, tagName, attribs) {
            return (CUI.rte.Common.getTagInPath(context, dom, tagName, attribs)
                    != null);
        },

        matchesTagDefs: function(dom, tagDefs) {
            var com = CUI.rte.Common;
            if (!CUI.rte.Utils.isArray(tagDefs)) {
                return com.matchesTagDef(dom, tagDefs);
            }
            var defCnt = tagDefs.length;
            for (var t = 0; t < defCnt; t++) {
                if (CUI.rte.Common.matchesTagDef(dom, tagDefs[t])) {
                    return true;
                }
            }
            return false;
        },

        matchesTagDef: function(dom, tagDef) {
            var com = CUI.rte.Common;
            if (!com.isTag(dom, tagDef.tagName)) {
                return false;
            }
            var attribIndex, attribCnt, attribToCheck;
            if (tagDef.attribsDefined) {
                attribCnt = tagDef.attribsDefined.length;
                for (attribIndex = 0; attribIndex < attribCnt; attribIndex++) {
                    attribToCheck = tagDef.attribsDefined[attribIndex];
                    if (!com.isAttribDefined(dom, attribToCheck)) {
                        return false;
                    }
                }
            }
            if (tagDef.attribsUndefined) {
                attribCnt = tagDef.attribsUndefined.length;
                for (attribIndex = 0; attribIndex < attribCnt; attribIndex++) {
                    attribToCheck = tagDef.attribsUndefined[attribIndex];
                    if (com.isAttribDefined(dom, attribToCheck)) {
                        return false;
                    }
                }
            }
            if (tagDef.attribValues) {
                var def = tagDef.attribValues;
                for (var name in def) {
                    if (def.hasOwnProperty(name)) {
                        attribToCheck = com.getAttribute(dom, name, true);
                        if (!attribToCheck) {
                            return false;
                        }
                        if (attribToCheck != def[name]) {
                            return false;
                        }
                    }
                }
            }
            if (tagDef.empty) {
                if (dom.childNodes.length > 0) {
                    return false;
                }
            }
            return true;
        },

        /**
         * <p>Gets the list nesting level for the specified DOM element.</p>
         * <p>If the specified DOM element is a list itself, it does not add as another
         * list level.</p>
         * @param {CUI.rte.EditContext} context The edit context
         * @param {HTMLElement} dom The DOM element to determine list nesting for
         * @return {Number} The list nesting level of the specified DOM element
         */
        getListLevel: function(context, dom) {
            var com = CUI.rte.Common;
            var indentLevel = 0;
            while (dom) {
                dom = com.getParentNode(context, dom);
                if (dom && (com.isTag(dom, "ul") || com.isTag(dom, "ol"))) {
                    indentLevel++;
                }
            }
            return indentLevel;
        },

        /**
         * Checks if the specified list DOM is the first nested list.
         * @param {HTMLElement} listDom DOM of list to check
         * @return {Boolean} True if the specified list DOM is the first nested list
         */
        isFirstNestedList: function(context, listDom) {
            // todo adapt if other unregular nested structures are supported in the future
            var com = CUI.rte.Common;
            var itemDom = com.getTagInPath(context, listDom, "li");
            if (!itemDom) {
                return false;
            }
            var childCnt = itemDom.childNodes.length;
            for (var c = 0; c < childCnt; c++) {
                var childToCheck = itemDom.childNodes[c];
                if (childToCheck == listDom) {
                    return true;
                }
                if (com.isTag(childToCheck, com.LIST_TAGS)) {
                    return false;
                }
            }
            return false;
        },

        /**
         * Checks if the specified list DOM is the last nested list.
         * @param {HTMLElement} listDom DOM of list to check
         * @return {Boolean} True if the specified list DOM is the first nested list
         */
        isLastNestedList: function(context, listDom) {
            var com = CUI.rte.Common;
            var itemDom = com.getTagInPath(context, listDom, "li");
            if (!itemDom) {
                return false;
            }
            var childCnt = itemDom.childNodes.length;
            for (var c = childCnt - 1; c >= 0; c--) {
                var childToCheck = itemDom.childNodes[c];
                if (childToCheck == listDom) {
                    return true;
                }
                if (com.isTag(childToCheck, com.LIST_TAGS)) {
                    return false;
                }
            }
            return false;
        },

        /**
         * Gets all child nodes of the specified DOM element that are of a specified type.
         * @param {HTMLElement} dom The DOM element
         * @param {String|String[]} tagName Type(s) to look for
         * @param {Boolean} isRecursive True if the search should be executed recursively
         * @param {String|String[]} stopTag Tag(s) to stop further recursion. For example,
         *        if "table" is specified here, nested tables will not be considered by
         *        the search.
         * @param {HTMLElement[]} result (optional) Array the results have to be added to
         * @return {HTMLElement[]} Array with all child nodes that match the specified
         *         criteria
         */
        getChildNodesByType: function(dom, tagName, isRecursive, stopTag, result) {
            var com = CUI.rte.Common;
            result = result || [ ];
            var children = dom.childNodes;
            var childCnt = children.length;
            for (var i = 0; i < childCnt; i++) {
                var child = children[i];
                if (com.isTag(child, tagName)) {
                    result.push(child);
                }
                if (isRecursive && (child.nodeType == 1)) {
                    var isStopTag = stopTag && com.isTag(child, stopTag);
                    if (!isStopTag) {
                        com.getChildNodesByType(child, tagName, isRecursive, stopTag,
                                result);
                    }
                }
            }
            return result;
        },

        getConsistentStyle: function(context, domList, styleName, defaultValue) {
            var nodeCnt = domList.length;
            var consistentStyle;
            for (var nodeIndex = 0; nodeIndex < nodeCnt; nodeIndex++) {
                var dom = domList[nodeIndex];
                var styleAttrib = CUI.rte.Common.getStyleProp(context, dom, styleName);
                styleAttrib = (styleAttrib ? styleAttrib : defaultValue);
                if (nodeIndex == 0) {
                    consistentStyle = styleAttrib;
                } else if (styleAttrib != consistentStyle) {
                    return null;
                }
            }
            return consistentStyle;
        },


        // --- DOM processing --------------------------------------------------------------

        insertNode: function(dom, node, offset) {
            var com = CUI.rte.Common;
            if (node.nodeType == 1) {
                if (!offset) {
                    node.parentNode.insertBefore(dom, node);
                } else if (offset >= node.childNodes.length) {
                    node.parentNode.append(dom);
                } else {
                    var insertRef = node.childNodes[offset];
                    node.parentNode.insertBefore(dom, insertRef);
                }
                return;
            }
            if (offset == 0) {
                node.parentNode.insertBefore(dom, node);
            } else if (offset >= com.getNodeCharacterCnt(node)) {
                node.parentNode.insertBefore(dom, node.nextSibling);
            } else {
                var nodeText = node.nodeValue;
                node.nodeValue = nodeText.substring(0, offset);
                var splitTextNode = node.cloneNode(false);
                splitTextNode.nodeValue = nodeText.substring(offset, nodeText.length);
                var nextSibling = node.nextSibling;
                var pNode = node.parentNode;
                pNode.insertBefore(dom, nextSibling);
                pNode.insertBefore(splitTextNode, nextSibling);
            }
        },

        /**
         * <p>Replaces one DOM element with another without changing the DOM structure
         * (other than replacing the DOM element).</p>
         * <p>If the replacement is an entire structure, you should specify childParent,
         * which specifies the node to which the child nodes of the replaced node are
         * moved.</p>
         * @param {HTMLElement} toReplace The node to be replaced
         * @param {HTMLElement} replacement The node (or substructure) to replace with
         * @param {HTMLElement} childParent (optional, if a substructure is specified as
         *        replacement) The node the child nodes of toReplace will be moved to
         */
        replaceNode: function(toReplace, replacement, childParent) {
            var children = toReplace.childNodes;
            if (!childParent) {
                childParent = replacement;
            }
            while (children.length > 0) {
                var child = children[0];
                toReplace.removeChild(child);
                childParent.appendChild(child);
            }
            toReplace.parentNode.replaceChild(replacement, toReplace);
        },

        /**
         * Moves the children of one node to another node.
         * @param {HTMLElement} src Node to move children from
         * @param {HTMLElement} dest Node to move children to
         * @param {Number} startIndex Index of first node to move (0/null to move all nodes)
         * @param {Boolean} insertAtEnd True if the moved nodes should be appended at the
         *        end of the destination node's existing child nodes
         */
        moveChildren: function(src, dest, startIndex, insertAtEnd) {
            var com = CUI.rte.Common;
            if (startIndex == null) {
                startIndex = 0;
            }
            var moveCnt = src.childNodes.length;
            var moveIndex = 0;
            for (var c = moveCnt - 1; c >= startIndex; c--) {
                var childToMove = src.childNodes[c];
                src.removeChild(childToMove);
                if (!insertAtEnd) {
                    com.insertBefore(dest, childToMove, dest.firstChild);
                } else {
                    if (moveIndex == 0) {
                        dest.appendChild(childToMove);
                    } else {
                        var insertRef = dest.childNodes[dest.childNodes.length - moveIndex];
                        com.insertBefore(dest, childToMove, insertRef);
                    }
                    moveIndex++;
                }
            }
        },

        /**
         * Removes all child nodes of the specified DOM node.
         * @param {HTMLElement} dom DOM node to remove child nodes from
         */
        removeAllChildren: function(dom) {
            if (dom.nodeType != 1) {
                return;
            }
            while (dom.childNodes.length > 0) {
                dom.removeChild(dom.childNodes[0]);
            }
        },

        /**
         * Removes all nodes with no child nodes "up the hierarchy", starting from the
         * given DOM node.
         * @param {CUI.rte.EditContext} context The edit context
         * @param {Node} dom DOM node to start
         */
        removeNodesWithoutContent: function(context, dom) {
            while (dom && !CUI.rte.Common.isRootNode(context, dom)) {
                if (dom.childNodes.length > 0) {
                    break;
                }
                var removeParent = dom.parentNode;
                removeParent.removeChild(dom);
                dom = removeParent;
            }
        },

        /**
         * Get the value for the given style attribute name that is actually valid for
         * the specified DOM element. If necessary, the value is taken from a parent element
         * accordingly.
         * @param {CUI.rte.EditContext} context The edit context
         * @param {HTMLElement} dom DOM element
         * @param {String} styleName Name of the style attribute
         * @return {String} Style value; null if no applicable style value has been found
         */
        getStyleProp: function(context, dom, styleName) {
            if (dom == context.root) {
                return null;
            }
            while (dom) {
                if (dom.nodeType == 1) {
                    if (dom.style && dom.style[styleName]) {
                        return dom.style[styleName];
                    }
                }
                dom = CUI.rte.Common.getParentNode(context, dom);
            }
            return null;
        },


        // --- CSS processing --------------------------------------------------------------

        /**
         * Parse the CSS classes of the specified DOM node to an array.
         * @param {HTMLElement} dom DOM node for which the CSS classes should be determined
         * @return {Array} Array (of Strings) containing all classes applied to the given
         *         DOM node
         */
        parseCSS: function(dom) {
            if (dom.nodeType != 1) {
                return [ ];
            }
            var classNames = CUI.rte.Common.getAttribute(dom, "class");
            if (!classNames) {
                return [ ];
            }
            return classNames.split(" ");
        },

        /**
         * Check if the specified DOM node has the given CSS class applied.
         * @param {HTMLElement} dom DOM node to check
         * @param {String} className CSS class name to check
         * @return {Boolean} True, if the given CSS class is applied to the
         *         given DOM node
         */
        hasCSS: function(dom, className) {
            if (dom.nodeType != 1) {
                return false;
            }
            var classes = CUI.rte.Common.parseCSS(dom);
            var clsCnt = classes.length;
            for (var c = 0; c < clsCnt; c++) {
                if (classes[c] == className) {
                    return true;
                }
            }
            return false;
        },

        /**
         * <p>Applies the specified CSS class to the specified DOM node.</p>
         * <p>If the DOM node already has the CSS class applied, the call is simply ignored.
         * </p>
         * @param {HTMLElement} dom DOM node
         * @param {String} className CSS class name to be applied
         */
        addClass: function(dom, className) {
            var com = CUI.rte.Common;
            if (!com.hasCSS(dom, className)) {
                var domClassName = com.getAttribute(dom, "class");
                if (domClassName) {
                    domClassName += " " + className;
                } else {
                    domClassName = className;
                }
                com.setAttribute(dom, "class", domClassName);
            }
        },

        /**
         * <p>Removes the specified CSS class from the specified DOM node.</p>
         * <p>If the DOM node doesn't have the CSS class applied, the call is simply
         * ignored.</p>
         * @param {HTMLElement} dom The DOM node
         * @param {String} className CSS class name to be removed
         */
        removeClass: function(dom, className) {
            var com = CUI.rte.Common;
            var classNames = com.parseCSS(dom);
            var recreateStr = "";
            var mustSet = false;
            for (var i = 0; i < classNames.length; i++) {
                if (classNames[i] == className) {
                    mustSet = true;
                } else {
                    if (recreateStr.length > 0) {
                        recreateStr += " ";
                    }
                    recreateStr += classNames[i];
                }
            }
            if (mustSet) {
                if (recreateStr) {
                    com.setAttribute(dom, "class", recreateStr);
                } else {
                    com.removeAllClasses(dom);
                }
            }
        },

        /**
         * <p>Removes all CSS classes from the specified DOM node.</p>
         * <p>If the DOM node doesn't have the CSS class applied, the call is simply
         * ignored.</p>
         * @param {HTMLElement} dom DOM node
         */
        removeAllClasses: function(dom) {
            CUI.rte.Common.removeAttribute(dom, "class");
        },


        // --- Browser-specific stuff ------------------------------------------------------

        /**
         * <p>Gets the translated IE attribute name if required.</p>
         * <p>IE does not implement attribute functions correctly. Mainly, the names
         * are differing. These method is used to work around that problem. Note that
         * there are other issues (handling of style attribute), which are not handled
         * by this method.</p>
         * <p>Note that you can call the method on other browsers as well.</p>
         * @param {String} attribName The attribute name to translate
         * @return {String} The attribute name as suitable for IE
         */
        getIEAttributeName: function(attribName) {
            var com = CUI.rte.Common;

            if (com.ua.isOldIE) {
                var attribNameLC = attribName.toLowerCase();
                // handle "class" attribute seperately, as "class" is a JavaScript keyword
                // and we can't imagine in what kind of browser hell we're running in if
                // we are using it as a key in an "associative array"
                if ((attribNameLC == "class") && (com.ua.isIE6 || com.ua.isIE7)) {
                    return "className";
                }
                // use table for other attribute names
                var translatedAttribName = CUI.rte.Common.IE_ATTRIB_NAMES[attribNameLC];
                if (translatedAttribName != null) {
                    attribName = translatedAttribName;
                }
            }
            return attribName;
        },

        /**
         * Gets all valid(!) attribute names for IE, as IE's implementation of the
         * attributes property is quite unusable for determining this.
         * @param {HTMLElement} dom The DOM element to get the list of attributes for
         * @param {Boolean} keepCase (optional) True if the case of the attribute names
         *        should be kept (this might be required for some IE issues to be worked
         *        around)
         * @param {Function} filter (optional) A filter method that allows to filter out a
         *        specific attribute; gets the DOM element, the attribute name and the
         *        lower case representation of the attribute's name as parameters; must
         *        return true to filter out the attribute.
         * @return {String[]} Array of all valid attribute names
         */
        getIEAttributeNames: function(dom, keepCase, filter) {
            var attributeNames = [ ];
            // IE bugs around again, so we'll use outerHTML to determine all *valid*
            // attributes
            var domHtml = dom.outerHTML;
            var tagEndPos = domHtml.indexOf(">");
            domHtml = domHtml.substring(0, tagEndPos + 1);
            var parsed = CUI.rte.HtmlProcessor.parseTag(domHtml);
            var attributes = parsed.attributes;
            for (var attribName in attributes) {
                var isFilteredOut = false;
                var attrib = attributes[attribName];
                if (filter) {
                    isFilteredOut = filter(dom, attrib.originalName, attribName);
                }
                if (!isFilteredOut) {
                    if (keepCase) {
                        attributeNames.push(attrib.originalName);
                    } else {
                        attributeNames.push(attribName);
                    }
                }
            }
            return attributeNames;
        },


        // --- Miscellaneous & Debugging ---------------------------------------------------

        /**
         * Removes all JCR-specific data from the given object.
         * <p>
         * You'll need this method to clean up collections with generic content before
         * iterating over them using something like <code>for (var key in coll)</code>.
         * Note that this method does intentionally not work recursively!
         * @param {Object} coll "Collection" to be cleaned
         */
        removeJcrData: function(coll) {
            for (var key in coll) {
                if (CUI.rte.Common.strStartsWith(key, "jcr:")) {
                    delete coll[key];
                } else if (key == "xtype") {
                    delete coll[key];
                }
            }
        },

        /**
         * Check if the given array contains the given object.
         * @param {Array} array Array to check
         * @param {Object} object Object to be checked
         * @param {Function} cmp (optional) Function that is used to determine if two array
         *        elements equal each other
         * @return {Boolean} True</code> if <code>object is an element of
         *         <code>array/code>
         */
        arrayContains: function(array, object, cmp) {
            return (CUI.rte.Common.arrayIndex(array, object, cmp) >= 0);
        },

        /**
         * Adds the content of the specified array to the other specified array. All
         * elements are inserted at the end of the existing array.
         * @param {Array} array The base array; elements will be added to this array.
         * @param {Array} arrayToAdd The array to add; elements will be added at the end
         *                           of the object specified by parameter array
         */
        arrayAdd: function(array, arrayToAdd) {
            var copyCnt = arrayToAdd.length;
            for (var c = 0; c < copyCnt; c++) {
                array.push(arrayToAdd[c]);
            }
        },

        /**
         * Get the index of the given object within the given array.
         * @param {Array} array Array to check
         * @param {Object} object Object to be checked
         * @param {Function} cmp (optional) Function that is used to determine if two array
         *        elements equal each other
         * @return {Number} array index of the given object; <code>-1</code> if
         *         <code>object</code> is not an element of <code>array/code>
         */
        arrayIndex: function(array, object, cmp) {
            for (var i = 0; i < array.length; i++) {
                if (!cmp) {
                    if (array[i] == object) {
                        return i;
                    }
                } else if (cmp(array[i], object)) {
                    return i;
                }
            }
            return -1;
        },

        /**
         * Creates a 1:1 copy of the specified array.
         * @param {Array} arrayToCopy Array to copy
         * @return {Array} The copied array
         */
        arrayCopy: function(arrayToCopy) {
            var copy = [ ];
            var itemCnt = arrayToCopy.length;
            for (var i = 0; i < itemCnt; i++) {
                copy.push(arrayToCopy[i]);
            }
            return copy;
        },

        /**
         * Ensures that the specified object is an array. If it is an object, it is
         * converted into an array, losing the object keys.
         * @param {Object} obj The object to check/convert
         * @param {String} keyName (optional) If specified, name/value pairs are converted
         *        into objects that consist of two properties: The key (of the original
         *        object) is set as a property with the name specified by keyName; the
         *        value (of the original object) is set as a property with the name
         *        specified by valueName; for exampe: "propName": "propValue" is transformed
         *        into { [keyName]: "propName", [valueName]: "propValue" }
         * @param {String} valueName (optional) If specified, name/value pairs are converted
         *        into objects that consist of two properties: The key (of the original
         *        object) is set as a property with the name specified by keyName; the
         *        value (of the original object) is set as a property with the name
         *        specified by valueName; for exampe: "propName": "propValue" is transformed
         *        into { [keyName]: "propName", [valueName]: "propValue" }
         * @return {Array} The object (if it is already an array) or the converted object or
         *         null, if the object could not be converted to an array
         */
        toArray: function(obj, keyName, valueName) {
            if (!obj) {
                return null;
            }
            if (CUI.rte.Utils.isArray(obj)) {
                return obj;
            }
            if (typeof(obj) == "object") {
                var array = [ ];
                for (var key in obj) {
                    if (obj.hasOwnProperty(key)) {
                        if (!keyName || !valueName) {
                            array.push(obj[key]);
                        } else {
                            var convObj = { };
                            convObj[keyName] = key;
                            convObj[valueName] = obj[key];
                            array.push(convObj);
                        }
                    }
                }
                return array;
            }
            return [ obj ];
        },

        /**
         * Check if the given string starts with the given partial string.
         * @param {String} str String to check
         * @param {String} partialStr partial String
         * @return {Boolean} True, if str starts with partialStr, else false
         */
        strStartsWith: function(str, partialStr) {
            var pLen = partialStr.length;
            if (str.length >= pLen) {
                return (str.substring(0, pLen) == partialStr);
            }
            return false;
        },

        /**
         * Check if the given string ends with the given partial string.
         * @param {String} str String to check
         * @param {String} partialStr partial String
         * @return {Boolean} True, if str ends with partialStr, else false
         */
        strEndsWith: function(str, partialStr) {
            var sLen = str.length;
            var pLen = partialStr.length;
            if (sLen >= pLen) {
                return (str.substring(sLen - pLen, sLen) == partialStr);
            }
            return false;
        },

        /**
         * Executes a simple String replacement.
         * @param {String} text The source text
         * @param {Number} startPos The first character to be replaced
         * @param {Number} endPosIncl The last character (inclusive) to be replaced
         * @param {String} replacement The replacement
         * @return {String} The result of the replacement
         */
        strReplace: function(text, startPos, endPosIncl, replacement) {
            var preStr = "";
            if (startPos > 0) {
                preStr = text.substring(0, startPos);
            }
            var postStr = "";
            if ((endPosIncl + 1) < text.length) {
                postStr = text.substring(endPosIncl + 1, text.length);
            }
            return preStr + replacement + postStr;
        },

        /**
         * Create an index path for the given DOM node.
         * <p>
         * An index path consists of the respective child positions up to the body node.
         * The index path may be used to determine if a node is "before" or "behind"
         * another node.
         * @param {CUI.rte.EditContext} context The edit context
         * @param {Node} node DOM node for which the index path has to be created
         * @return {Array} index path for the given node
         */
        createIndexPath: function(context, node) {
            var parentNode = CUI.rte.Common.getParentNode(context, node);
            if (!parentNode) {
                return [];
            }
            var sortIndex = CUI.rte.Common.getChildIndex(node);
            var sortIndices = CUI.rte.Common.createIndexPath(context, parentNode);
            sortIndices.push(sortIndex);
            return sortIndices;
        },

        /**
         * Compare two index paths.
         * <p>
         * An index path consists of the respective child positions up to the body node.
         * The index path may be used to determine if a node is "before" or "behind"
         * another node.
         * @param {Array} index1 first index path
         * @param {Array} index2 second index path
         * @return {Number} 0 if both index paths are the same;
         *         1 if <code>index1</code> is "before" <code>index2</code>;
         *         -1 if <code>index1</code> is "behind" <code>index2</code>
         */
        compareIndexPaths: function(index1, index2) {
            var i1Cnt = index1.length;
            var i2Cnt = index2.length;
            var index = 0;
            while (true) {
                if (index >= i1Cnt) {
                    if (index >= i2Cnt) {
                        // same node
                        return 0;
                    }
                    // 1 is parent of 2
                    return 1;
                }
                if (index >= i2Cnt) {
                    // 2 is parent of 1
                    return -1;
                }
                if (index1[index] < index2[index]) {
                    return 1;
                }
                if (index1[index] > index2[index]) {
                    return -1;
                }
                index++;
            }
        },

        /**
         * Blocks execution of JavaScript for the given amount of time and, if specified,
         * under the given condition.
         * @param {Number} ms Time to block JavaScript execution thread in milliseconds
         * @param {Boolean} cond (optional) A condition that has to be true for the block
         *        to be executed
         */
        block: function(ms, cond) {
            if ((typeof cond === "undefined") || cond) {
                var endTime = new Date().getTime() + ms;
                while (new Date().getTime() < endTime);
            }
        },

        /**
         * Gets the "outer html" of the specified DOM node (= the HTML code that represents
         * the specified node and all of its child nodes, recursively).
         * @param {CUI.rte.EditContext} context The edit context
         * @param {HTMLElement} dom The HTML element to get the outer HTML for
         */
        getOuterHTML: function(context, dom) {
            var com = CUI.rte.Common;

            if (com.ua.isIE) {
                return dom.outerHTML;
            }
            var fakeSpan = context.createElement("span");
            fakeSpan.appendChild(dom.cloneNode(true));
            return fakeSpan.innerHTML;
        },

        /**
         * Dump the given DOM node.
         * @param {Node} node DOM node to dump
         * @param {String} prefix text prefix (optional)
         * @param {String} suffix text suffix (optional)
         */
        dumpNode: function(node, prefix, suffix) {
            var text = (prefix ? prefix : "");
            if (node) {
                var childNo = CUI.rte.Common.getChildIndex(node);
                if (node.nodeType == 1) {
                    text += node.tagName;
                } else if (node.nodeType == 3) {
                    text += "\"" + node.nodeValue + "\"";
                } else if (node.nodeType == 8) {
                    text += "(comment) " + node.nodeValue;
                } else {
                    text += "(nodeType #" + node.nodeType + ")";
                }
                text += " (parentNode.childNodes[" + childNo + "])";
            } else {
                text += "[No node]";
            }
            if (suffix) {
                text += suffix;
            }
            return text;
        },

        /**
         * Dump the given DOM node recursively.
         * @param {Node} node DOM node to dump
         * @param {Number} indent indent (spaces) of the current recursion (optional)
         */
        dumpNodeRecursively: function(node, indent) {
            if (!indent) {
                indent = 0;
            }
            var text = "";
            for (var indentIndex = 0; indentIndex < indent; indentIndex++) {
                text += "   ";
            }
            text += CUI.rte.Common.dumpNode(node) + "\n";
            if (node && (node.nodeType == 1)) {
                var childCnt = node.childNodes.length;
                for (var childIndex = 0; childIndex < childCnt; childIndex++) {
                    text += CUI.rte.Common.dumpNodeRecursively(
                            node.childNodes[childIndex], indent + 1);
                }
            }
            return text;
        },

        /**
         * Dump the specified JavaScript object recursively.
         * @param {Object} obj Object to dump
         * @param {Number} indent indent (spaces) of the current recursion (optional)
         * @param {Boolean} dumpDomRecursively True if DOM nodes that are
         *        contained in the object hierarchy should be dumped recursively
         */
        dumpObject: function(obj, indent, dumpDomRecursively) {
            var com = CUI.rte.Common;
            var dump = "";
            if (!indent) {
                indent = 0;
            }
            var indentStr = "";
            for (var indentPos = 0; indentPos < indent; indentPos++) {
                indentStr += " ";
            }
            if (!obj) {
                return indentStr + "---";
            }
            if (obj.hasOwnProperty) {
                for (var name in obj) {
                    if (obj.hasOwnProperty(name)) {
                        var value = obj[name];
                        dump += indentStr + name + ":";
                        if ((value === null) || (value === undefined)) {
                            dump += " [undefined]\n";
                        } else if (typeof(value) == "object") {
                            if (value.nodeType && (value.tagName || value.nodeValue)) {
                                if (dumpDomRecursively) {
                                    dump += "\n" + com.dumpNodeRecursively(value,
                                            indent + 2);
                                } else {
                                    dump += com.dumpNode(value) + "\n";
                                }
                            } else {
                                dump += "\n" + com.dumpObject(value,
                                        indent + 2);
                            }
                        } else {
                            dump += " " + value + "\n";
                        }
                    }
                }
            } else {
                if (obj.nodeType) {
                    if (dumpDomRecursively) {
                        dump += com.dumpNodeRecursively(obj, indent);
                    } else {
                        dump += indentStr + com.dumpNode(obj) + "\n";
                    }
                } else {
                    dump += indentStr + "[native object]\n";
                }
            }
            return dump;
        },

        /**
         * Provides simple logging facilities for IE, which requires a DOM element with
         * id == "debug" to be present. If no such DOM element is found, the logging
         * request is simply ignored.
         * @param {String} msg The message to be logged
         * @param {Boolean} enforceDebuggingDiv True if the debugging DIV should be enforced
         */
        ieLog: function(msg, enforceDebuggingDiv) {
            if (!isLogEnabled) {
                return;
            }
            var div = document.getElementById("cuiRTEdebug");
            if (!div && enforceDebuggingDiv) {
                var doc = window.document;
                var width = doc.body.clientWidth - 310;
                div = doc.createElement("div");
                div.id = "cuiRTEdebug";
                div.style.width = "300px";
                div.style.height = "300px";
                div.style.position = "absolute";
                div.style.top = "10px";
                div.style.left = width + "px";
                div.style.zIndex = 10000;
                div.style.overflowY = "scroll";
                div.style.border = "1px solid";
                div.style.fontFamily = "sans-serif";
                div.style.fontSize = "12px";
                div.style.backgroundColor = "#ffffff";
                doc.body.appendChild(div);
            }
            if (div) {
                if (!msg) {
                    msg = "";
                }
                msg = CUI.rte.Utils.htmlEncode(msg);
                var addBr = true;
                if ((msg.length > 0) && (msg.charAt(msg.length - 1) == "\n")) {
                    addBr = false;
                }
                msg = msg.replace(/\n/g, "<br>");
                msg = msg.replace(/ /g, "&nbsp;");
                div.innerHTML = div.innerHTML + msg + (addBr ? "<br>" : "");
            }
        },

        /**
         * Enables or disables the logging facilities provided by {@link #ieLog}.
         * @param {Boolean} isEnabled True to enable logging through {@link #ieLog}
         */
        setLogEnabled: function(isEnabled) {
            isLogEnabled = isEnabled;
            if (isLogEnabled) {
                CUI.rte.Common.ieLog(null, true);
            }
        },

        /**
         * Array that contains the tag name of nodes that are treated as one character
         * when counting characters
         * @type String[]
         * @static
         * @final
         */
        ONE_CHARACTER_NODES: [
            {
                "tagName": "a",
                "attribsDefined": [ "name" ],
                "attribsUndefined": [ "href" ]
            }, {
                "tagName": "img"
            }, {
                "tagName": "br"
            }
        ],

        /**
         * List of actual block tags
         * @type String[]
         */
        BLOCK_TAGS: [
            "p", "h1", "h2", "h3", "h4", "h5", "h6", "div", "ol", "ul", "pre", "table",
            "address", "blockquote", "center", "dl", "fieldset", "form", "hr", "marquee",
            "noscript", "script"
        ],

        /**
         * List of edit fragment tags - editing fragments are DOM structures that are
         * considered to be edited as some kind of a block. The most important difference
         * to the average structure is that their end is counted as an extra space in
         * functions that map node/offset to a character position
         * @type String[]
         */
        EDITBLOCK_TAGS: [
            "p", "h1", "h2", "h3", "h4", "h5", "h6", "div", "li", "pre", "td", "th",
            "address", "blockquote", "center", "caption"
        ],

        /**
         * List of edit fragment tags that may be nested
         * @type String[]
         */
        EDITBLOCK_NESTED_TAGS: [
            "td", "th"
        ],

        /**
         * List of edit fragment tags that may be nested and if so, are nested irregularily.
         * This is currently the case for list items only.
         * @type String[]
         */
        EDITBLOCK_UNREGNEST_TAGS: [
            "li"
        ],

        /**
         * Prefix for RTE-specific attributes
         */
        RTE_ATTRIB_PREFIX: "_rte",

        /**
         * Helper attribute for providing "stable" HREF support - the HREF of a link is
         * stored both in the href attribute (which may be changed by browser deliberately)
         * and the attribute defined by this constant (which is supposed to not being
         * touched by the browser)
         */
        HREF_ATTRIB: "_rte_href",

        /**
         * Helper attribute for providing "stable" SRC support - the SRC of an image is
         * stored both in the href attribute (which may be changed by browser deliberately)
         * and the attribute defined by this constant (which is supposed to not being
         * touched by the browser)
         */
        SRC_ATTRIB: "_rte_src",

        /**
         * Helper attribute for determining helper line breaks used for working around
         * Webkit and Gecko issues
         */
        BR_TEMP_ATTRIB: "_rte_temp_br",

        /**
         * Helper attribute for images that are used as placeholders for named anchors
         */
        A_NAME_REPLACEMENT_ATTRIB: "_rte_a_name_repl",

        /**
         * Array of tags that are defining a table cell
         * @type String[]
         * @private
         */
        TABLE_CELLS: [ "td", "th" ],

        /**
         * Array of tags that are defining lists
         * @type String[]
         * @private
         */
        LIST_TAGS: [ "ul", "ol" ],

        /**
         * Table of attribute names that have to be translated for IE to work correctly
         */
        IE_ATTRIB_NAMES: {
            "cellpadding": "cellPadding",
            "cellspacing": "cellSpacing",
            "valign": "vAlign",
            "bgcolor": "bgColor",
            "rowspan": "rowSpan",
            "colspan": "colSpan"
        },

        /**
         * Attribute filter for temporary Gecko-stuff
         * @param {HTMLElement} dom The DOM element
         * @param {String} attribName Attribute name (browser-dependent)
         * @param {String} attribNameLC Lower case version of the attribute name
         */
        FILTER_GECKO_TEMPORARY_ATTRIBS: function(dom, attribName, attribNameLC) {
            var com = CUI.rte.Common;
            // exclude temporary Mozilla attributes (as far as currently known)
            return com.strStartsWith(attribNameLC, "_moz")
                || (com.isTag(dom, "br") && (attribNameLC == "type"));
        }

    };

}();
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.HtmlProcessor
 * @static
 * @private
 * <p>The RichText.HtmlProcessor provides the means to process HTML based on its String
 * representation. It contains an HTML parser + several helper methods.</p>
 * <p><b>Caution:</b> String-based processing is a performance bottleneck on IE &lt; 8, so
 * if you plan to process large chunks of HTML, you should better use DOM-based processing
 * instead.</p>
 */
CUI.rte.HtmlProcessor = function() {

    return {

        // Helpers -------------------------------------------------------------------------

        /**
         * Does a simple String replacement.
         * @param {String} text The source text
         * @param {Number} startPos The first character to be replaced
         * @param {Number} endPosIncl The last character (inclusive) to be replaced
         * @param {String} replacement The replacement
         * @return {String} The result of the replacement
         */
        replace: function(text, startPos, endPosIncl, replacement) {
            return CUI.rte.Common.strReplace(text, startPos, endPosIncl, replacement);
        },

        isBlockTag: function(tagName) {
            var tags = CUI.rte.Common.BLOCK_TAGS;
            var tagNameLC = tagName.toLowerCase();
            var tagCnt = tags.length;
            for (var tagIndex = 0; tagIndex < tagCnt; tagIndex++) {
                if (tags[tagIndex] == tagNameLC) {
                    return true;
                }
            }
            return false;
        },

        /**
         * Skips whitespace in the given String (if applicable).
         * @param {String} str The String to be processed
         * @param {Number} pos Position from where to skip whitespaces
         * @return {Number} Position of next non-whitespace character; -1 if no more
         *         (non-whitespace) characters were found
         */
        skipWhitespace: function(str, pos) {
            while ((pos < str.length) && (str.charCodeAt(pos) <= 32)) {
                pos++;
            }
            if (pos >= str.length) {
                return -1;
            }
            return pos;
        },

        /**
         * Strips surrounding whitespace from the given string.
         * @param {String} text The String for which the whitespace should be stripped
         * @return {String} The String, without surrounding whitespace
         * @type String
         */
        stripSurroundingWhitespace: function(text, excludeSpace) {
            var spaceIndex = 0;
            var lastValidChar = (excludeSpace ? 31 : 32);
            while (spaceIndex < text.length) {
                if (text.charCodeAt(spaceIndex) > lastValidChar) {
                    break;
                }
                spaceIndex++;
            }
            if (spaceIndex < text.length) {
                text = text.substring(spaceIndex, text.length);
            } else {
                text = "";
            }
            spaceIndex = text.length;
            while (spaceIndex > 0) {
                spaceIndex--;
                if (text.charCodeAt(spaceIndex) >= lastValidChar) {
                    break;
                }
            }
            if (spaceIndex >= 0) {
                text = text.substring(0, spaceIndex + 1);
            } else {
                text = "";
            }
            return text;
        },

        /**
         * Removes trailing characters.
         * @param {String} text The text to remove trailing characters from
         * @param {String} chars The characters to be removed
         * @return {String} The processed text
         */
        removeTrailingChars: function(text, chars) {
            var pos = text.length - 1;
            while (pos > 0) {
                if (chars.indexOf(text.charAt(pos)) < 0) {
                    return text.substring(0, pos + 1);
                }
                pos--;
            }
            return "";
        },


        // Parsing -------------------------------------------------------------------------

        /**
         * <p>Parses the String representation of a tag into an object representation that
         * is much easier to process.</p>
         * <p>The object representation has the following properties:</p>
         * <ul>
         *   <li><code>tagName</code> : String<br>
         *     The name of the tag (lower case)</li>
         *   <li><code>attributes</code> : Object<br>
         *     A table representing the attributes of the tag; each object has the following
         *     properties:
         *     <ul>
         *       <li><code>name</code> : String<br>
         *         The name of the attribute (lower case).</li>
         *       <li><code>value</code> : String<br>
         *         The value of the attribute</li>
         *       <li><code>quoted</code> : Boolean<br>
         *         True if the attribute value is surrounded by quotation marks (IE loves to
         *         not quote simple attribute values)</li>
         *       <li><code>pos</code> : Number<br>
         *         The position where the attribute starts (relative to <code>tagStr</code>)
         *         </li>
         *       <li><code>cnt</code> : Number<br>
         *         Number of characters the attribute takes</li>
         *     </ul>
         *   </li>
         *   <li><code>isShortTag</code> : Boolean<br>
         *     True if the tag is a "short tag", i.e. &lt;br /&gt;</li>
         * </ul>
         * @param {String} tagStr The String, representing the tag (for example: &lt;a
         *        href="/path/to/page"&gt;)
         * @return {Object} An object representation of the tag String
         */
        parseTag: function(tagStr) {
            var hpr = CUI.rte.HtmlProcessor;
            // some preparations ...
            tagStr = tagStr.replace(/\r\n/g, " ");
            tagStr = tagStr.replace(/[\r\n\t]/g, " ");
            var tagDef = {
                tagName: null,
                attributes: { }
            };
            if (tagStr.length < 3) {
                return tagDef;
            }
            // parse tag
            var firstChar = hpr.skipWhitespace(tagStr, 0);
            if (firstChar < 0) {
                return tagDef;
            }
            if (tagStr.charAt(firstChar) != "<") {
                return tagDef;
            }
            var closingBrace = tagStr.lastIndexOf(">");
            if (closingBrace <= firstChar) {
                return tagDef;
            }
            if (closingBrace > 0) {
                // exclude "/" of tag shortform (<br/>) from parsing if necessary
                if (tagStr.charAt(closingBrace - 1) == '/') {
                    closingBrace--;
                    tagDef.isShortTag = true;
                }
            }
            var tagEnd = tagStr.indexOf(" ", firstChar);
            if (tagEnd < 0) {
                // tag only, no attributes
                tagDef.tagName =
                        tagStr.substring(firstChar + 1, closingBrace).toLowerCase();
                return tagDef;
            }
            tagDef.tagName = tagStr.substring(firstChar + 1, tagEnd).toLowerCase();
            // handle attributes
            var processPos = tagEnd;
            while (true) {
                if (processPos >= closingBrace) {
                    return tagDef;
                }
                processPos = hpr.skipWhitespace(tagStr, processPos);
                if (processPos < 0) {
                    return tagDef;
                }
                var attribSepPos = tagStr.indexOf("=", processPos);
                // IE issue: ismap="ismap" gets reduced to ismap
                var shortAttrib = null;
                var spaceSepPos = tagStr.indexOf(" ", processPos);
                if ((spaceSepPos >= 0)
                        && ((spaceSepPos < attribSepPos) || attribSepPos < 0)) {
                    // consider superfluous whitespace (width = "200")
                    var endSpacePos = hpr.skipWhitespace(tagStr, spaceSepPos);
                    if (endSpacePos != attribSepPos) {
                        shortAttrib = tagStr.substring(processPos, spaceSepPos);
                        processPos = endSpacePos;
                    }
                } else if (attribSepPos < 0) {
                    // handle short attrib at end of tag (<img src="..." ismap>)
                    if (processPos < (tagStr.length - 1)) {
                        shortAttrib = tagStr.substring(processPos, tagStr.length);
                        // remove closing ">" and superflous whitespace
                        shortAttrib = hpr.removeTrailingChars(shortAttrib, " >");
                    }
                    processPos = tagStr.length;
                }
                var attributeName;
                if (shortAttrib != null) {
                    attributeName = shortAttrib.toLowerCase();
                    tagDef.attributes[attributeName] = {
                        "name": attributeName,
                        "originalName": shortAttrib,
                        "shortAttrib": true,
                        "quoted": false
                    };
                } else {
                    if (attribSepPos < 0) {
                        return tagDef;
                    }
                    var originalAttributeName = tagStr.substring(processPos, attribSepPos);
                    originalAttributeName = hpr.removeTrailingChars(originalAttributeName,
                            " ");
                    attributeName = originalAttributeName.toLowerCase();
                    attribSepPos = hpr.skipWhitespace(tagStr, attribSepPos + 1);
                    var spacePos = tagStr.indexOf(" ", attribSepPos);
                    var quotChar = "\"";
                    var quotPos = tagStr.indexOf("\"", attribSepPos);
                    var aposPos = tagStr.indexOf("'", attribSepPos);
                    var attributeValue;
                    var valueStartIndex = -1;
                    var valueCharCnt = -1;
                    var isQuotedValue = true;
                    if (quotPos > closingBrace) {
                        quotPos = -1;
                    }
                    if (aposPos > closingBrace) {
                        aposPos = -1;
                    }
                    if (spacePos > closingBrace) {
                        spacePos = -1;
                    }
                    // "browsers do such things", chapter 12789: IE uses ' if attribute values
                    // contain "
                    if (aposPos >= 0) {
                        if ((aposPos < quotPos) || (quotPos < 0)) {
                            quotPos = aposPos;
                            quotChar = "'";
                        }
                    }
                    if ((quotPos >= 0) && ((quotPos < spacePos) || (spacePos < 0))) {
                        var endQuotPos = tagStr.indexOf(quotChar, quotPos + 1);
                        if (endQuotPos < 0) {
                            // error - return what has already been parsed
                            return tagDef;
                        }
                        attributeValue = tagStr.substring(quotPos + 1, endQuotPos);
                        valueStartIndex = quotPos + 1;
                        valueCharCnt = (endQuotPos - (quotPos + 1));
                        processPos = endQuotPos + 1;
                    } else {
                        var lastCharPos = (spacePos >= 0 ? spacePos : closingBrace);
                        // attribute value without quotation marks - IE likes to do such
                        // things
                        attributeValue = tagStr.substring(attribSepPos, lastCharPos);
                        isQuotedValue = false;
                        valueStartIndex = attribSepPos;
                        valueCharCnt = (lastCharPos - attribSepPos);
                        processPos = lastCharPos + 1;
                    }
                    tagDef.attributes[attributeName] = {
                        "name": attributeName,
                        "originalName": originalAttributeName,
                        "value": attributeValue,
                        "pos": valueStartIndex,
                        "cnt": valueCharCnt,
                        "shortAttrib": false,
                        "quoted": isQuotedValue
                    };
                }
            }
        },

        /**
         * Parses the String representation of a CSS style definition into an object
         * representation that is much easier to process.
         * @param {String} styleStr The style definition to parse (for example: font-family:
         *                          Arial; font-weight: bold)
         * @return {Object} A table that contains the parsed style definition (for example:
         *         <code>{ "font-family": "Arial", "font-weight:", "bold" }</code>)
         * @type Object
         */
        parseStyleDef: function(styleStr) {
            styleStr = CUI.rte.Utils.htmlDecode(styleStr);
            var processPos = 0;
            var styleDef = { };
            while (true) {
                processPos =
                        CUI.rte.HtmlProcessor.skipWhitespace(styleStr, processPos);
                if (processPos < 0) {
                    return styleDef;
                }
                var sepPos = styleStr.indexOf(":", processPos + 1);
                var styleName = styleStr.substring(processPos, sepPos);
                styleName = CUI.rte.HtmlProcessor
                            .stripSurroundingWhitespace(styleName);
                if (styleName.length == 0) {
                    return styleDef;
                }
                var defEndPos = styleStr.indexOf(";", sepPos + 1);
                if (defEndPos < 0) {
                    defEndPos = styleStr.length;
                }
                var styleCode = styleStr.substring(sepPos + 1, defEndPos);
                styleCode = CUI.rte.HtmlProcessor
                        .stripSurroundingWhitespace(styleCode);
                styleDef[styleName] = styleCode;
                processPos = defEndPos + 1;
            }
        },

        /**
         * <p>Handles the callback for HTML text for <code>parseHtml()</code>.</p>
         * @private
         * @param {String} htmlStr HTML string that is currently being parsed
         * @param {Object} callback callback object
         * @param {Number} startPos position of first character
         * @param {Number} endPos position of last character (exclusive)
         * @return {Object} object containing a <code>html</code> property that contains the
         *         replaced text and a <code>delta</code> property that contains the
         *         positioning delta
         */
        handleHtmlText: function(htmlStr, callback, startPos, endPos) {
            var noReplacementRet = {
                "html": htmlStr,
                "delta": 0
            };
            if (!callback.onHtmlText) {
                return noReplacementRet;
            }
            if (endPos <= startPos) {
                return noReplacementRet;
            }
            var text = htmlStr.substring(startPos, endPos);
            var replaceStr = callback.onHtmlText(text);
            if (replaceStr == null) {
                return noReplacementRet;
            }
            var delta = replaceStr.length - (endPos - startPos);
            htmlStr = CUI.rte.HtmlProcessor.replace(
                    htmlStr, startPos, endPos - 1, replaceStr);
            return {
                "html": htmlStr,
                "delta": delta
            };
        },

        /**
         * <p>Gets the most probable end position of the specified processing tag.</p>
         * <p>Currently handled:</p>
         * <ul>
         *   <li>&lt;-- ... --&gt;</li>
         *   <li>&lt;? ... ?&gt;</li>
         *   <li>&lt;<! ... >&gt;<li>
         * </ul>
         * @private
         * @param {String} htmlStr
         * @param {Number} dataPos
         */
        getProcessingTagEndPos: function(htmlStr, dataPos) {
            var strLen = htmlStr.length;
            var charAtPos = htmlStr.charAt(dataPos);
            if (charAtPos == "!") {
                if (strLen > dataPos + 3) {
                    if (htmlStr.substring(dataPos, dataPos + 3) == "!--") {
                        return htmlStr.indexOf("-->", dataPos + 3) + 2;
                    }
                }
                return htmlStr.indexOf(">", dataPos + 1);
            }
            return htmlStr.indexOf(">", dataPos);
        },

        /**
         * <p>Parses the tags of a HTML string generically.</p>
         * <p>The caller should define a callback object with the following methods (each
         * is optional and only called if present):</p>
         * <ul>
         *   <li><code>htmlStart</code> : Function<br>
         *     This method is called before the first tag is parsed.</li>
         *   <li><code>htmlEnd</code> : Function<br>
         *     This method is called after the last tag has been parsed.</li>
         *   <li><code>onTagStart</code> : Function<br>
         *     This method is called on an opening tag. It takes the following parameters:
         *     <ol>
         *       <li><code>tagName</code> : String<br>
         *         The name of the tag.</li>
         *       <li><code>attributes</code> : Object<br>
         *         Information of the attributes as key/value pairs. Each value consists of
         *         the following properties:
         *         <ul>
         *           <li><code>name</code> : String<br>
         *             The name of the attribute (lower case).</li>
         *           <li><code>value</code> : String<br>
         *             The value of the attribute</li>
         *           <li><code>quoted</code> : Boolean<br>
         *             True if the attribute value is surrounded by quotation marks (IE
         *             loves to not quote simple attribute values)</li>
         *           <li><code>pos</code> : Number<br>
         *             The position where the attribute starts (relative to
         *             <code>tagStr</code>)</li>
         *           <li><code>cnt</code> : Number<br>
         *             Number of characters the attribute takes</li>
         *         </ul>
         *       </li>
         *       <li><code>isShortTag</code> : Boolean<br>
         *         True if the tag is a "short tag", that means it already includes the
         *         closing tag (i.e. &lt;br /&gt;). Note that the corresponding
         *         {@link #onTagEnd} method will be called for each tag, including short
         *         tags.</li>
         *       <li><code>startPos</code> : Number<br>
         *         Position (relative to the entire HTML to parse) of the first character (a
         *         '&lt;') of the tag.</li>
         *       <li><code>tagLen</code> : Number<br>
         *         Number of characters the tag is actually consisting of (from '&lt;' to
         *         '&gt;', as it is formatted in the HTML to parse)</li>
         *     </ol>
         *   </li>
         *   <li><code>onTagEnd</code> : Function<br>
         *     This method is called on a closing tag. It takes the following parameters:
         *     <ol>
         *       <li><code>tagName</code> : String<br>
         *         The name of the tag.</li>
         *       <li><code>isShortTag</code> : Boolean<br>
         *         True if the tag is a "short tag", that means it already includes the
         *         closing tag (i.e. &lt;br /&gt;). Note that the corresponding
         *         {@link #onTagEnd} method will be called for each tag, including short
         *         tags.</li>
         *       <li><code>startPos</code> : Number<br>
         *         Position (relative to the entire HTML to parse) of the first character (a
         *         '&lt;') of the tag.</li>
         *       <li><code>tagLen</code> : Number<br>
         *         Number of characters the tag is actually consisting of (from '&lt;' to
         *         '&gt;', as it is formatted in the HTML to parse)</li>
         *     </ol>
         *   </li>
         *   <li><code>onProcessingTag</code> : Function<br>
         *     This method is called on "processing tags" (like &lt;? ... ?&gt;, &lt;!--
         *     &gt;, ...). It takes the entire processing tag as its only parameter.</li>
         *   <li><code>onHtmlText</code> : Function<br>
         *     This method is called for HTML text. It takes the text as its only parameter.
         *     </li>
         * </ul>
         * <p>Note that all tag- and attribute names are lowercase.</p>
         * @param {String} htmlStr HTML string to parse
         * @param {Object} callback callback object which is called on opening and closing
         *                          tags (if <code>tagStart</code> resp. <code>tagEnd</code>
         *                          is specified)
         * @return {String} HTML after processing
         */
        parseHtml: function(htmlStr, callback) {
            var hpr = CUI.rte.HtmlProcessor;
            var processingPos = 0;
            var textPos = 0;
            var textHandlerResult;
            while ((processingPos >= 0) && (processingPos < htmlStr.length)) {
                var tagStartPos = htmlStr.indexOf("<", processingPos);
                if (tagStartPos >= 0) {
                    var dataPos = hpr.skipWhitespace(htmlStr, tagStartPos + 1);
                    var firstCharOfTag = htmlStr.charAt(dataPos);

                    var tagName, tagEndPos, replaceStr;
                    if ((firstCharOfTag == "?") || (firstCharOfTag == "!")) {
                        // "Processing tags" (<!DOCTYPE >, <!-- -->, <? ?>)
                        processingPos = hpr.getProcessingTagEndPos(htmlStr, dataPos);
                        if (processingPos > 0) {
                            textHandlerResult = hpr.handleHtmlText(htmlStr, callback,
                                    textPos, tagStartPos);
                            htmlStr = textHandlerResult.html;
                            tagStartPos += textHandlerResult.delta;
                            dataPos += textHandlerResult.delta;
                            processingPos += textHandlerResult.delta;
                            if (callback.onProcessingTag) {
                                var pTag =
                                        htmlStr.substring(tagStartPos, processingPos + 1);
                                replaceStr = callback.onProcessingTag(pTag);
                                if (replaceStr != null) {
                                    htmlStr = hpr.replace(htmlStr,
                                            tagStartPos, processingPos, replaceStr);
                                    processingPos += replaceStr.length - pTag.length + 1;
                                }
                            } else {
                                processingPos++;
                            }
                            textPos = processingPos;
                        }

                    } else if (firstCharOfTag == "/") {

                        // closing tags
                        tagEndPos = htmlStr.indexOf(">", dataPos + 1);
                        if (tagEndPos > 0) {
                            textHandlerResult = hpr.handleHtmlText(htmlStr, callback,
                                    textPos, tagStartPos);
                            htmlStr = textHandlerResult.html;
                            tagStartPos += textHandlerResult.delta;
                            dataPos += textHandlerResult.delta;
                            tagEndPos += textHandlerResult.delta;
                            tagName = htmlStr.substring(dataPos + 1, tagEndPos);
                            tagName = hpr.stripSurroundingWhitespace(tagName);
                            if (callback.onTagEnd) {
                                var endTagLen = tagEndPos - tagStartPos + 1;
                                replaceStr = callback.onTagEnd(tagName.toLowerCase(), false,
                                        tagStartPos, endTagLen);
                                if (replaceStr != null) {
                                    htmlStr = hpr.replace(
                                            htmlStr, tagStartPos, tagEndPos, replaceStr);
                                    tagEndPos += replaceStr.length - endTagLen;
                                }
                            }
                        } else {
                            tagEndPos = dataPos;
                        }
                        processingPos = tagEndPos + 1;
                        textPos = processingPos;

                    } else {

                        // opening tags
                        tagEndPos = htmlStr.indexOf(">", tagStartPos);
                        if (tagEndPos > 0) {
                            var includesClosingTag = false;
                            if (htmlStr.charAt(tagEndPos - 1) == '/') {
                                includesClosingTag = true;
                            }
                            textHandlerResult = hpr.handleHtmlText(htmlStr, callback,
                                    textPos, tagStartPos);
                            htmlStr = textHandlerResult.html;
                            tagStartPos += textHandlerResult.delta;
                            dataPos += textHandlerResult.delta;
                            tagEndPos += textHandlerResult.delta;
                            var tag = htmlStr.substring(tagStartPos, tagEndPos + 1);
                            var tagDef = hpr.parseTag(tag);
                            tagName = tagDef.tagName;
                            if (tagName && callback.onTagStart) {
                                replaceStr = callback.onTagStart(tagName, tagDef.attributes,
                                        includesClosingTag, tagStartPos, tag.length,
                                        tagStartPos, tag.length);
                                if (replaceStr != null) {
                                    htmlStr = hpr.replace(
                                            htmlStr, tagStartPos, tagEndPos, replaceStr);
                                    tagEndPos += replaceStr.length - tag.length;
                                }
                            }
                            if (tagName && includesClosingTag && callback.onTagEnd) {
                                replaceStr = callback.onTagEnd(tagName, includesClosingTag,
                                        tagStartPos, tag.length);
                                if (replaceStr != null) {
                                    htmlStr = hpr.replace(
                                            htmlStr, tagEndPos + 1, tagEndPos, replaceStr);
                                    tagEndPos += replaceStr.length;
                                }
                            }
                        } else {
                            tagEndPos = dataPos;
                        }
                        processingPos = tagEndPos + 1;
                        textPos = processingPos;

                    }
                } else {
                    textHandlerResult = hpr.handleHtmlText(htmlStr, callback, processingPos,
                            htmlStr.length);
                    htmlStr = textHandlerResult.html;
                    processingPos = -1;
                }
            }
            return htmlStr;
        },

        /**
         * Checks if the given attribute definitions equal each other.
         * <p>
         * Both attribute definitions must be in the format that is created by
         * <code>CUI.rte.HtmlProcessor.parseTag()</code>.
         * @param {Object} attribs attribute set
         * @param {Object} cmpAttribs attribute set to compare
         * @return {Boolean} True if the given attribute definitions equal each other
         */
        hasEqualAttributes: function(attribs, cmpAttribs) {
            var attribCnt = 0;
            for (var attribToCheck in attribs) {
                if (attribs.hasOwnProperty(attribToCheck)) {
                    if (!cmpAttribs.hasOwnProperty(attribToCheck)) {
                        return false;
                    }
                    if (attribs[attribToCheck].value != cmpAttribs[attribToCheck].value) {
                        return false;
                    }
                    attribCnt++;
                }
            }
            for (attribToCheck in cmpAttribs) {
                if (cmpAttribs.hasOwnProperty(attribToCheck)) {
                    attribCnt--;
                    if (attribCnt < 0) {
                        return false;
                    }
                }
            }
            return (attribCnt == 0);
        },


        // Processing helpers --------------------------------------------------------------

        /**
         * Parses a style-related tag (resp. its style attribute) and creates simple
         * tag replacements that work with the browser's components.
         * @param {String} tagStr The tag string to parse; for example: &lt;span
         *                        style="font-weight:bold"&gt;
         * @return {Array} Array with tag replacements; for example: <code>[ "b" ]</code>
         * @deprecated
         */
        parseStyleTag: function(tagStr) {
            var tagReplacement = null;
            var tagDef = CUI.rte.HtmlProcessor.parseTag(tagStr);
            var styleDef = tagDef.attributes["style"];
            if (styleDef) {
                styleDef = styleDef.value;
                var styleDefs = CUI.rte.HtmlProcessor.parseStyleDef(styleDef);
                if (styleDefs["font-weight"] == "bold") {
                    if (!tagReplacement) {
                        tagReplacement = new Array();
                    }
                    tagReplacement.push("b");
                }
                if (styleDefs["font-style"] == "italic") {
                    if (!tagReplacement) {
                        tagReplacement = new Array();
                    }
                    tagReplacement.push("i");
                }
            }
            return tagReplacement;
        },


        // Processing ----------------------------------------------------------------------

        /**
         * Executes a simple tag replace.
         * <p>
         * Attributes can not be properly processed using this method. Use
         * <code>parseHtml()</code> instead.
         *
         * @deprecated use pre/post processing facilities instead
         *
         * @param {String} value The String where the given tag replacements will be applied
         *                      to
         * @param {Object} tagReplace The replacements to apply; key: tag to be replace (for
         *                            example: strong); value: replacing tag (for example:
         *                            b)
         */
        executeTagReplace: function(value, tagReplace) {
            if (tagReplace) {
                for (var srcTag in tagReplace) {
                    if (tagReplace.hasOwnProperty(srcTag)) {
                        var destTag = tagReplace[srcTag];
                        if (srcTag && destTag) {
                            var srcStartTag = "<" + srcTag + ">";
                            var srcEndTag = "<\\/" + srcTag + ">";
                            var destStartTag = "<" + destTag + ">";
                            var destEndTag = "</" + destTag + ">";
                            var expStart = eval("/" + srcStartTag + "/gi");
                            var expEnd = eval("/" + srcEndTag + "/gi");
                            value = value.replace(expStart, destStartTag);
                            value = value.replace(expEnd, destEndTag);
                        }
                    }
                }
            }
            return value;
        },

        /**
         * @deprecated use generic parsing functionality if appropriate to avoid unnecessary
         * maintenance
         */
        executeStyleReplace: function(value) {
            var tag, tagEndPos, tagsToReplace, replaceText;
            var replacePos = 0;
            var spanEndTags = new Array();
            while (replacePos >= 0) {
                var valueLC = value.toLowerCase();
                tag = null;
                var closingTagPos = valueLC.indexOf("</span>", replacePos);
                var wholeTagPos = valueLC.indexOf("<span>", replacePos);
                replacePos = valueLC.indexOf("<span ", replacePos);
                if ((wholeTagPos >= 0)
                    && ((wholeTagPos < replacePos) || (replacePos < 0))) {
                    replacePos = wholeTagPos;
                }
                while ((closingTagPos >= 0)
                        && ((closingTagPos < replacePos) || (replacePos < 0))) {
                    tagsToReplace = spanEndTags.pop();
                    var replaceCnt = tagsToReplace.length;
                    if ((replaceCnt > 0) && (tagsToReplace[0] != "span")) {
                        replaceText = "";
                        for (var replaceIndex = replaceCnt - 1;
                                replaceIndex >= 0; replaceIndex--) {
                            replaceText += "</" + tagsToReplace[replaceIndex] + ">";
                        }
                        value = CUI.rte.HtmlProcessor.replace(
                                value, closingTagPos, closingTagPos + 6, replaceText);
                        closingTagPos += replaceText.length;
                        // correct replacePos by the difference between old and new
                        // closing tag
                        replacePos += replaceText.length - 7;
                    } else  {
                        closingTagPos += 7;
                    }
                    valueLC = value.toLowerCase();
                    closingTagPos = valueLC.indexOf("</span>", closingTagPos);
                }
                if (replacePos >= 0) {
                    tagEndPos = valueLC.indexOf(">", replacePos);
                    if (tagEndPos > replacePos) {
                         tag = value.substring(replacePos, tagEndPos + 1);
                    }
                }
                if (tag) {
                    tagsToReplace = CUI.rte.HtmlProcessor.parseStyleTag(tag);
                    if (tagsToReplace) {
                        replaceText = "";
                        var tagCnt = tagsToReplace.length;
                        var closingTagInfo = new Array();
                        for (var tagIndex = 0; tagIndex < tagCnt; tagIndex++) {
                            var tagToReplace = tagsToReplace[tagIndex];
                            closingTagInfo.push(tagToReplace);
                            replaceText += "<" + tagToReplace + ">";
                        }
                        value = CUI.rte.HtmlProcessor.replace(
                            value, replacePos, tagEndPos, replaceText);
                        replacePos += replaceText.length;
                        spanEndTags.push(closingTagInfo);
                    } else {
                        replacePos += tag.length;
                        spanEndTags.push([ "span" ]);
                    }
                }
            }
            return value;
        },

        /**
         * <p>Internalizes links that were rewritten by the underlying browser component to
         * point to URLs that look valid to the browser.</p>
         * <p>Note that link internalizing might become obsolete if we used a different
         * DOM-to-HTML conversion method, as the attribs collection of each DOM element
         * should already contain the correct, relative link. Unfortunately, the innerHTML
         * method currently used for DOM-to-HTML conversion uses DOM attributes instead of
         * the attribs collection, hence requiring link internalizing.</p>
         * @param {String} value The String which contains the links to be internalized
         * @param {Object} linkInternalize definition of which tags are suitable for
         *        link internalization; property tag defines the tag (for example: img);
         *        property attribute defines the attribute that carries the link to
         *        be internalized (for example: src)
         * @return {String} The String with internalized links
         */
        executeInternalizeLinks: function(value, linkInternalize) {
            var valueLC = value.toLowerCase();
            var replacePos, tagEndPos;
            var tagCnt = linkInternalize.length;
            for (var tagIndex = 0; tagIndex < tagCnt; tagIndex++) {
                var tag = linkInternalize[tagIndex];
                var tagName = tag["tag"];
                var attribute = tag["attribute"];
                replacePos = 0;
                while ((replacePos >= 0) && (replacePos < value.length)) {
                    replacePos = valueLC.indexOf("<" + tagName + " ", replacePos);
                    if (replacePos >= 0) {
                        var tagStr = null;
                        tagEndPos = valueLC.indexOf(">", replacePos + 1);
                        if (tagEndPos > replacePos) {
                            tagStr = value.substring(replacePos, tagEndPos + 1);
                        }
                        if (tagStr) {
                            var tagDef = CUI.rte.HtmlProcessor.parseTag(tagStr);
                            if (tagDef) {
                                var attribDef = tagDef.attributes[attribute];
                                if (attribDef && !attribDef.shortAttrib) {
                                    var attribValue = attribDef.value;
                                    var attribPos = attribDef.pos;
                                    var attribCharCnt = attribDef.cnt;
                                    var isQuoted = attribDef.quoted;
                                    var url = CUI.rte.HtmlRules.Links
                                            .removePrefixForInternalLinks(attribValue);
                                    if (url != attribValue) {
                                        if (!isQuoted) {
                                            url = "\"" + url + "\"";
                                        }
                                        value = CUI.rte.HtmlProcessor.replace(
                                                value, replacePos + attribPos,
                                                replacePos + attribPos + attribCharCnt - 1,
                                                url);
                                        valueLC = value.toLowerCase();
                                        replacePos += tagStr.length
                                                + (url.length - attribValue.length);
                                    } else {
                                        replacePos += tagStr.length;
                                    }
                                } else {
                                    replacePos += tagStr.length;
                                }
                            } else {
                                replacePos += tagStr.length;
                            }
                        } else {
                            replacePos += tagName.length + 2;
                        }
                    }
                }
            }
            return value;
        },

        /**
         * Creates HTML code for the specified tag definition.
         * @param {String} tagName Name of the tag
         * @param {Object} attribs Attribute definition as created by
         *        {@link CUI.rte.HtmlProcessor.parseHtml}
         * @param {Boolean} isClosingTag True if a closing tag should be created
         * @param {Boolean} isShortTag True if the tag is a "short tag" (for example
         *        &lt;br /&gt;)
         * @param {Boolean} normalizeTag True if the tag should be created in a "normalized"
         *        form (mostly, tag name and attribute names are put to lower case)
         * @return {String} HTML code for the specified tag definition
         */
        createTag: function(tagName, attribs, isClosingTag, isShortTag, normalizeTag) {
            if (isClosingTag && isShortTag) {
                return "";
            }
            var tag = "<";
            if (isClosingTag) {
                tag += "/";
            }
            tag += (normalizeTag ? tagName.toLowerCase() : tagName);
            if (attribs && !isClosingTag) {
                tag += CUI.rte.HtmlProcessor.createAttributes(attribs, normalizeTag);
            }
            if (isShortTag) {
                tag += " /";
            }
            tag += ">";
            return tag;
        },

        /**
         * Creates HTML code for the specified attribute definition.
         * @param {Array} attribs
         * @param {Boolean} normalizeTag
         */
        createAttributes: function(attribs, normalizeTag) {
            var strRep = "";
            if (!attribs) {
                return strRep;
            }
            for (var attribName in attribs) {
                if (attribs.hasOwnProperty(attribName)) {
                    if (attribName != "classname") {
                        var attribDef = attribs[attribName];
                        if (attribDef) {
                            strRep += " " + (normalizeTag ? attribName.toLowerCase()
                                    : attribName);
                            if (attribDef.shortAttrib) {
                                if (normalizeTag) {
                                    strRep += "=\"" + attribName.toLowerCase() + "\"";
                                }
                            } else {
                                strRep += "=";
                                var value = attribDef.value;
                                var isQuoted = attribDef.quoted;
                                if (!isQuoted) {
                                    isQuoted = (value.indexOf(" ") >= 0);
                                }
                                if (isQuoted || normalizeTag) {
                                    strRep += "\"";
                                }
                                strRep += value;
                                if (isQuoted || normalizeTag) {
                                    strRep += "\"";
                                }
                            }
                        }
                    }
                }
            }
            return strRep;
        }

    };

}();


/**
 * @class CUI.rte.HtmlProcessor.StripTags
 * @private
 * This class implements a "Tag strip" processor, which removes all tags from a given
 * HTML fragment.
 */
CUI.rte.HtmlProcessor.StripTags = new Class({

    toString: "HtmlProcessor.StripTags",

    /**
     * Flag if content has to be ignored
     */
    ignoreContent: false,

    /**
     * Strips all tags from the given HTML-String.
     * @param {String} html HTML code
     * @return {String} the plain text code
     */
    strip: function(html) {
        return CUI.rte.HtmlProcessor.parseHtml(html, this);
    },

    /**
     * Handler for starting HTML tags.
     * @param {String} tagName Name of tag
     * @private
     */
    onTagStart: function(tagName) {
        if ((tagName == "style") || (tagName == "script")) {
            this.ignoreContent = true;
        }
        if (tagName == "br") {
            return "\n";
        }
        return "";
    },

    /**
     * Handler for ending HTML tags.
     * @param {String} tagName Name of tag
     * @private
     */
    onTagEnd: function(tagName) {
        if ((tagName == "style") || (tagName == "script")) {
            this.ignoreContent = false;
        }
        if (tagName == "tr") {
            return "\n";
        }
        if (tagName == "p") {
            return "\n\n";
        }
        if (tagName.match(/h[1-6]/)) {
            return "\n\n";
        }
        if (tagName == "li") {
            return "\n\n";
        }
        return "";
    },

    onHtmlText: function(text) {
        if (this.ignoreContent) {
            return "";
        }
        var noCrLfText = text.replace(/[\n\r]/g, " ");
        return (noCrLfText != text ? noCrLfText : null);
    },

    onProcessingTag: function(pTag) {
        return "";
    }

});
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.DomProcessor
 * @static
 * @private
 * The DomProcessor provides utility functions to manipulate the DOM directly.
 */
CUI.rte.DomProcessor = function() {

    var com = CUI.rte.Common;

    return {

        getTagType: function(dom) {
            var dpr = CUI.rte.DomProcessor;
            var tagName = (dom instanceof String ? dom : dom.tagName).toLowerCase();
            var type = dpr.STRUCTURE;
            var typeTable = dpr.TYPE_TABLE;
            if (typeTable.hasOwnProperty(tagName)) {
                type = typeTable[tagName];
                if (typeof(type) != "string") {
                    type = type.type;
                }
            }
            return type;
        },

        resolveTagType: function(dom) {
            var dpr = CUI.rte.DomProcessor;
            var tagName = (dom instanceof String ? dom : dom.tagName).toLowerCase();
            var type = dpr.STRUCTURE;
            var typeTable = dpr.TYPE_TABLE;
            if (typeTable.hasOwnProperty(tagName)) {
                type = typeTable[tagName];
                if (typeof(type) != "string") {
                    if (type.type == dpr.DYNAMIC) {
                        if (type.getDynamicType) {
                            type = type.getDynamicType(dom);
                        } else {
                            type = dpr.STRUCTURE;
                        }
                    } else {
                        type = type.type;
                    }
                }
            }
            return type;
        },

        createNodeList: function(context, selection) {
            var nodeList = new CUI.rte.NodeList();
            if (selection.cellSelection && selection.cellSelection.cells) {
                nodeList.createFromDomNodes(context, selection.cellSelection.cells);
            } else {
                nodeList.createFromDocument(context, selection);
            }
            return nodeList;
        },

        getCommonAncestor: function(context, dom1, dom2) {
            if ((dom1 == null) || (dom2 == null)) {
                return null;
            }
            if (com.isAncestor(context, dom1, dom2)) {
                return dom1.parentNode;
            }
            if (com.isAncestor(context, dom2, dom1)) {
                return dom2.parentNode;
            }
            while (dom1) {
                var dom2Check = dom2;
                while (dom2Check) {
                    if (dom2Check == dom1) {
                        return dom1;
                    }
                    dom2Check = com.getParentNode(context, dom2Check);
                }
                dom1 = com.getParentNode(context, dom1);
            }
            return null;
        },

        /**
         * Splits the specified text node at the specified offset(s).
         * @param {CUI.rte.EditContext} context The edit context
         * @param {HTMLElement} textNode The text node to be split
         * @param {Number|Number[]} splitPoints Offsets to split the node
         * @return {HTMLElement[]} Array containing all split nodes in correct order
         */
        splitTextNode: function(context, textNode, splitPoints) {
            if (textNode.nodeType != 3) {
                throw new Error("splitTextNode() may only operate on text nodes.");
            }
            if (!CUI.rte.Utils.isArray(splitPoints)) {
                splitPoints = [ splitPoints ];
            }
            splitPoints.sort(function(c1, c2) {
                return c1 - c2;
            });
            var splitNodes = [ ];
            var startPos = 0;
            var textToSplit = textNode.nodeValue;
            var pointCnt = splitPoints.length;
            var parentNode = textNode.parentNode;
            var fragText, splitNode;
            for (var pointIndex = 0; pointIndex < pointCnt; pointIndex++) {
                var splitPos = splitPoints[pointIndex];
                fragText = textToSplit.substring(startPos, splitPos);
                splitNode = context.createTextNode(fragText);
                splitNodes.push(splitNode);
                parentNode.insertBefore(splitNode, textNode);
                startPos = splitPos;
            }
            fragText = textToSplit.substring(startPos, textToSplit.length);
            splitNode = context.createTextNode(fragText);
            splitNodes.push(splitNode);
            parentNode.insertBefore(splitNode, textNode);
            parentNode.removeChild(textNode);
            return splitNodes;
        },

        /**
         * <p>Creates a new DOM element with the specified attributes in a browser
         * independent way.</p>
         * <p>Note that you can use "class" or "className" for specifying the "class"
         * attribute and "style" to specify the "style" attribute.</p>
         * @param {CUI.rte.EditContext} context The edit context
         * @param {String} tagName The tag of the element to be created
         * @param {Object} attribs Attribute definition (key: attribute name; value:
         *        attribute value); null for a DOM element without attributes
         * @return {HTMLElement} The created DOM element
         */
        createNode: function(context, tagName, attribs) {
            // IE <= 7 is not able to create anchors the normal way, so we'll have to
            // create it in a single step; see bug #36231
            // http://msdn.microsoft.com/en-us/library/ms534184(v=VS.85).aspx
            var useInnerHTML = (com.ua.isIE6 || com.ua.isIE7)
                    && ((tagName.toLowerCase() == "a") && attribs.hasOwnProperty("name"));
            var node = (useInnerHTML ? null : context.createElement(tagName));
            var tagStr = null;
            if (useInnerHTML) {
                tagStr = "<" + tagName;
            }
            if (attribs) {
                for (var name in attribs) {
                    if (attribs.hasOwnProperty(name)) {
                        var value = attribs[name];
                        if (useInnerHTML) {
                            value = CUI.rte.Utils.htmlEncode(value);
                            tagStr += " " + name  + "=\"" + value + "\"";
                        } else {
                            name = (name == "className" ? "class" : name);
                            CUI.rte.Common.setAttribute(node, name, value);
                        }
                    }
                }
            }
            if (useInnerHTML) {
                tagStr += "></" + tagName + ">";
                node = context.createElement(tagStr);
            }
            return node;
        },

        /**
         * Inserts a new element with the specified tag name and attributes as a direct
         * parent node of the specified node. The specified node will be the only child
         * node of the newly created element.
         * @param {CUI.rte.EditContext} context The edit context
         * @param {HTMLElement} node The node that will be the child of the newly created
         *        element
         * @param {String} tagName Tag name of the element to be created
         * @param {Object} attribs Attributes of the element to be created
         */
        insertAsParent: function(context, node, tagName, attribs) {
            var dpr = CUI.rte.DomProcessor;
            var nodeToInsert = dpr.createNode(context, tagName, attribs);
            var parentNode = node.parentNode;
            parentNode.insertBefore(nodeToInsert, node);
            parentNode.removeChild(node);
            nodeToInsert.appendChild(node);
            return nodeToInsert;
        },

        /**
         * Removes the specified node without removing its child nodes. The child nodes
         * will be inserted in the node's parent node at the position of the node to be
         * removed.
         * @param {HTMLElement} nodeToRemove The node to be removed
         */
        removeWithoutChildren: function(nodeToRemove) {
            var newParent = nodeToRemove.parentNode;
            while (nodeToRemove.childNodes.length > 0) {
                var nodeToMove = nodeToRemove.childNodes[0];
                nodeToRemove.removeChild(nodeToMove);
                newParent.insertBefore(nodeToMove, nodeToRemove);
            }
            newParent.removeChild(nodeToRemove);
        },

        /**
         * Moves the nodes, specified by the "nodes" list, to a newly created node, which
         * is created before the first node of the "nodes" list.
         * @param {CUI.rte.EditContext} context The edit context
         * @param {HTMLElement} baseNode The parent of the nodes to be moved
         * @param {HTMLElement[]} nodes List of nodes to be moved (must be child nodes of
         *        baseNode)
         * @param {String} tagName Tag name of the node to be created
         * @param {Object} attribs Attributes of the node to be created
         */
        restructureAsChild: function(context, baseNode, nodes, tagName, attribs) {
            var dpr = CUI.rte.DomProcessor;
            var nodeToInsert = dpr.createNode(context, tagName, attribs);
            baseNode.insertBefore(nodeToInsert, nodes[0]);
            var nodeCnt = nodes.length;
            for (var nodeIndex = 0; nodeIndex < nodeCnt; nodeIndex++) {
                var nodeToRestructure = nodes[nodeIndex];
                baseNode.removeChild(nodeToRestructure);
                nodeToInsert.appendChild(nodeToRestructure);
            }
            return nodeToInsert;
        },

        /**
         * Determines if the given DOM node may represent a placeholder object.
         * @deprecated
         * @param {HTMLElement} node Node to check
         * @return {Boolean} True if the given DOM node may represent a placeholder object
         */
        isPlaceholderObject: function(node) {
            if (com.ua.isIE) {
                return ((node.nodeType == 3)
                        && (node.nodeValue == CUI.rte.DomProcessor.NBSP));
            } else {
                var isPlaceholder = com.isTag(node, "br");
                if (!isPlaceholder && com.isTag(node.parentNode, [ "td", "th" ])) {
                    isPlaceholder = ((node.nodeType == 3)
                            && (node.nodeValue == CUI.rte.DomProcessor.NBSP));
                }
                return isPlaceholder;
            }
        },

        /**
         * @deprecated
         */
        getEmptyLinePlaceholder: function(node) {
            if (node.nodeType != 1) {
                return null;
            }
            if (node.childNodes.length != 1) {
                return null;
            }
            var child = node.childNodes[0];
            if (CUI.rte.DomProcessor.isPlaceholderObject(child)) {
                return child;
            }
            return null;
        },

        /**
         * Checks if the given node represents an empty "line" (consisting of a placeholder
         * object only).
         * @deprecated
         * @param {HTMLElement} node Node to check
         */
        isEmptyLinePlaceholder: function(node) {
            return (CUI.rte.DomProcessor.getEmptyLinePlaceholder(node) != null);
        },

        /**
         * Creates a browser-specific empty line placeholder.
         * @param {CUI.rte.EditContext} context The edit context
         * @param {Boolean} createBlock True if a surrounding paragraph node has also to
         *        be created
         * @param {String} blockType (optional) The type of block to create; if none is
         *        specified, a "p" block is created by default
         * @return {HTMLElement} The placeholder element if one has been created (note that
         *         this might be null on IE when createBlock == false).
         */
        createEmptyLinePlaceholder: function(context, createBlock, blockType) {
            var placeholder;
            if (!com.ua.isIE) {
                placeholder = CUI.rte.DomProcessor.createGeckoPlaceholder(context);
            }
            if (createBlock) {
                var para = context.createElement(blockType || "p");
                if (placeholder) {
                    para.appendChild(placeholder);
                }
                placeholder = para;
            }
            return placeholder;
        },

        /**
         * Creates a Gecko-compatible placeholder br. Can also be used for Webkit browsers.
         * @param {CUI.rte.EditContext} context The edit context
         * @return {HTMLElement} The placeholder element
         */
        createGeckoPlaceholder: function(context) {
            var placeholder = context.createElement("br");
            if (com.ua.isGecko || com.ua.isWebKit) {
                com.setAttribute(placeholder, com.BR_TEMP_ATTRIB, "brEOB");
            }
            return placeholder;
        },

        /**
         * Ensures that a placeholder is available for an empty edit block.
         * @param {CUI.rte.EditContext} context The edit context
         * @param {HTMLElement} editBlockDom The edit block
         */
        ensureValidEmptyEditBlock: function(context, editBlockDom) {
            if (!com.isTag(editBlockDom, com.EDITBLOCK_TAGS)
                    || (editBlockDom.nodeType != 1)) {
                throw new Error("No valid edit block provided");
            }
            if (editBlockDom.childNodes.length == 0) {
                var dpr = CUI.rte.DomProcessor;
                if (!com.ua.isIE) {
                    editBlockDom.appendChild(dpr.createGeckoPlaceholder(context));
                }
                dpr.fixEmptyEditingBlockIE(context, editBlockDom);
            }
        },

        /**
         * @deprecated
         */
        ensureEmptyLinePlaceholders: function(context, node) {
            if (node.nodeType == 1) {
                var dpr = CUI.rte.DomProcessor;
                var sel = CUI.rte.Selection;
                if (dpr.getTagType(node) == dpr.CONTAINER) {
                    var textChild = com.getFirstTextChild(node, true);
                    if (textChild == null) {
                        var placeholderNode = dpr.getEmptyLinePlaceholder(node);
                        if (!placeholderNode) {
                            placeholderNode = dpr.createEmptyLinePlaceholder(context,
                                    false);
                            if (placeholderNode) {
                                var appendingNode = com.getFirstChild(node);
                                if (appendingNode == null) {
                                    appendingNode = node;
                                } else {
                                    // prevent appending the placeholder object to a named
                                    // anchor (or similar)
                                    while (sel.isNoInsertNode(appendingNode)) {
                                        appendingNode = appendingNode.parentNode;
                                        if (appendingNode == node) {
                                            break;
                                        }
                                    }
                                }
                                appendingNode.appendChild(placeholderNode);
                            }
                        }
                    } else {
                        // here we'll have to check if the structure is correct, as on Gecko
                        // we might get something like <p><b></b><br></p> which would
                        // prevent us from keeping formatting (see bug #22395)
                        if (dpr.isPlaceholderObject(textChild)) {
                            var firstChild = com.getFirstChild(node);
                            // prevent moving the placeholder object into a named anchor
                            // (or similar)
                            if (!sel.isNoInsertNode(firstChild)) {
                                if (firstChild != textChild) {
                                    textChild.parentNode.removeChild(textChild);
                                    firstChild.appendChild(textChild);
                                }
                            }
                        }
                    }
                }
            }
        },

        /**
         * Checks if the specified block node represents an empty line.
         * @param {HTMLElement} blockNode The block node to check
         * @return {Boolean} True if the specified block node represents an empty line
         */
        isEmptyLineBlock: function(blockNode) {
            var dpr = CUI.rte.DomProcessor;
            var isEmpty = dpr.isEmptyLinePlaceholder(blockNode);
            if (!isEmpty) {
                // handle completely empty blocks + Blocks containing a single &nbsp; node
                var characterNodes = com.getCharacterNodes(blockNode);
                if (characterNodes.length == 0) {
                    isEmpty = true;
                } else if (characterNodes.length == 1) {
                    var text = com.getNodeText(characterNodes[0]);
                    isEmpty = (text == dpr.NBSP);
                }
            }
            return isEmpty;
        },

        /**
         * <p>On Internet Explorer, this method should be called on each newly created,
         * empty edit block to ensure that it is actually editable.</p>
         * <p>Implicitly (= by RTE) inserted empty blocks are usually not editable due to
         * some internal IE issues, so there has to be some "selection magic" executed
         * to ensure the user can actually see and edit them.</p>
         * <p>Note that you may call the method on a deliberate node and even on Gecko
         * browsers, as it will automatically determine if the fix has to be applied or
         * not.</p>
         * <p>Note also that the node must have already been added to the DOM-tree of the
         * editor's document before this method is called. Otherwise IE will throw an
         * exception.</p>
         * <p>Also note that this method changes the behaviour of the outerHTML and
         * innerHTML properties: Before calling this method, an empty block is reported
         * - outerHTML for example has a value of &lt;p&gt;&lt;/p&gt;. Afterwards, an
         * additional &amp;nbsp; is visible - the outerHTML changes to
         * &lt;p&gt;&amp;nbsp;&lt;/p&gt;. The additional &amp;nbsp; is not actually present
         * in the DOM, cannot be iterated or removed.</p>
         * @param {CUI.rte.EditContext} context The edit context
         * @param {HTMLElement} editBlock The editing block
         */
        fixEmptyEditingBlockIE: function(context, editBlock) {
            // Workaround to ensure that IE actually displays an empty block. It is not
            // really comprehensible when empty paragraphs are automatically displayed, and
            // when they have to be "made displayable" manually
            if (com.ua.isIE && com.isEmptyEditingBlock(editBlock, true)) {
                if (com.isTag(editBlock, com.TABLE_CELLS)) {
                    // not required and throwing an exception on table cells
                    return;
                }
                var dpr = CUI.rte.DomProcessor;
                // we'll have to provide another node before the span that is used for
                // "persisting" the block, as IE would remove the paragraph otherwise
                // if there is a "a name" at the end of the previous block
                var secNode = context.createTextNode(dpr.NBSP);
                editBlock.appendChild(secNode);
                var helperNode = context.createElement("span");
                editBlock.appendChild(helperNode);
                helperNode.appendChild(context.createTextNode(dpr.NBSP));
                // required for IE8 compatibility
                context.win.focus();
                var range = context.doc.selection.createRange();
                range.moveToElementText(helperNode);
                // this seems to finally make the paragraph displayable
                range.pasteHTML("");
                editBlock.removeChild(secNode);
            }
        },

        /**
         * This fixes empty lines at the end of a block similar to the way
         * {@link #fixEmptyEditingBlockIE} does for empty blocks.
         * @param {CUI.rte.EditContext} context The editing context
         * @param {HTMLElement} brDom The linefeed (&lt;br&gt;) to be fixed
         */
        fixEmptyLinefeedIE: function(context, brDom) {
            if (com.ua.isIE) {
                var dpr = CUI.rte.DomProcessor;
                var helperNode = context.createElement("span");
                var insertRef = brDom.nextSibling;
                insertRef ? brDom.parentNode.insertBefore(helperNode, insertRef)
                        : brDom.parentNode.appendChild(helperNode);
                helperNode.appendChild(context.createTextNode(dpr.NBSP));
                context.win.focus();
                var range = context.doc.selection.createRange();
                range.moveToElementText(helperNode);
                range.pasteHTML("");
            }
        },

        /**
         * Ensure the minimum content that is required for the browser to work properly.
         * @private
         */
        ensureMinimumContent: function(context) {
            var dpr = CUI.rte.DomProcessor;
            var com = CUI.rte.Common;
            var sel = CUI.rte.Selection;
            var pNode = null;
            if (context.root.childNodes.length == 1) {
                var nodeToCheck = context.root.childNodes[0];
                if (com.isTag(nodeToCheck, "br")) {
                    context.root.removeChild(nodeToCheck);
                }
                if (com.isTag(nodeToCheck, "p")) {
                    dpr.ensureEmptyLinePlaceholders(context, nodeToCheck);
                }
            }
            var bookmark = dpr.ensureBlockContent(context, "p", null, false, true);
            if (bookmark) {
                sel.selectBookmark(context, bookmark);
            }
            if (context.root.childNodes.length == 0) {
                pNode = context.createElement("p");
                context.root.appendChild(pNode);
                dpr.ensureEmptyLinePlaceholders(context, pNode);
                sel.selectNode(context, pNode, true);
            }
            return pNode;
        },

        /**
         * Checks if the specified selection represents an empty line and returns the
         * block node for the empty line if there is one.
         * @param {CUI.rte.EditContext} context The edit context
         * @param {Object} selection Processing selection to check (as createad by
         *        {@link CUI.rte.Selection#createProcessingSelection})
         * @return {HTMLElement} The edit block node if there is an empty line; null if the
         *         selection doesn't specify an empty line
         */
        getEmptyLine: function(context, selection) {
            var dpr = CUI.rte.DomProcessor;
            var blockNode = dpr.getEditBlock(context, selection.startNode);
            if (!blockNode) {
                return null;
            }
            // check if the block nodes of start and end node are the same
            if (selection.endNode) {
                var blockEndNode = dpr.getEditBlock(context, selection.endNode);
                if (blockNode != blockEndNode) {
                    return null;
                }
            }
            return (dpr.isEmptyLineBlock(blockNode) ? blockNode : null);
        },

        /**
         * Checks if the specified selection represents an empty line.
         * @param {CUI.rte.EditContext} context The edit context
         * @param {Object} selection Processing selection to check (as createad by
         *        {@link CUI.rte.Selection#createProcessingSelection})
         * @return {Boolean} True if the selection represents an empty line
         */
        isEmptyLine: function(context, selection) {
            return (CUI.rte.DomProcessor.getEmptyLine(context, selection) != null);
        },

        /**
         * <p>Determines if the specified node determines an empty line.</p>
         * <p>This is the case for "br" nodes that have either another "br" node as
         * "previous character sibling" or no direct "previous character subling". The
         * latter condition is valid for IE only.</p>
         * @param {CUI.rte.EditContext} context The edit context
         * @param {HTMLElement} node The DOM element to check
         * @return {Boolean} True if the specified node determines an empty linefeed node
         */
        isEmptyLineDeterminator: function(context, node) {
            if (!com.isTag(node, "br")) {
                return false;
            }
            var prev = com.getPreviousCharacterNode(context, node, com.EDITBLOCK_TAGS);
            return (((prev == null) && com.ua.isIE) || com.isTag(prev, "br"));
        },

        /**
         * <p>Adjusts the table structure of the document represented by the specified
         * edit context.</p>
         * <p>Tables that are nested in paragraphs are moved out of this paragraph. Header
         * cells are moved from the "thead" section to the "tbody" section.</p>
         * @param {CUI.rte.EditContext} context The edit context
         */
        adjustTables: function(context) {
            var root = context.root;
            var blockNodes = root.childNodes;
            var i;
            for (i = 0; i < blockNodes.length; i++) {
                var nodeToCheck = blockNodes[i];
                if (com.isTag(nodeToCheck, "p")) {
                    if (nodeToCheck.childNodes.length == 1) {
                        var childNode = nodeToCheck.childNodes[0];
                        if (com.isTag(childNode, "table")) {
                            root.insertBefore(childNode, nodeToCheck);
                            root.removeChild(nodeToCheck);
                            nodeToCheck = childNode;
                        }
                    }
                }
                if (com.isTag(nodeToCheck, "table")) {
                    var header = com.getChildNodesByType(nodeToCheck, "thead");
                    if (header.length == 1) {
                        header = header[0];
                        var tBody = com.getChildNodesByType(nodeToCheck, "tbody");
                        if (tBody.length == 0) {
                            tBody.push(context.createElement("tbody"));
                        }
                        tBody = tBody[0];
                        var insertNode = null;
                        if (tBody.childNodes.length > 0) {
                            insertNode = tBody.childNodes[0];
                        }
                        for (i = header.childNodes.length - 1; i >= 0; i--) {
                            var rowToMove = header.childNodes[i];
                            header.removeChild(rowToMove);
                            tBody.insertBefore(rowToMove, insertNode);
                        }
                        nodeToCheck.removeChild(header);
                    }
                }
            }
        },

        /**
         * Removes all non-table blocks to ensure that only tables are left for editing.
         * @param {CUI.rte.EditContext} context The edit context
         */
        removeNonTableBlocks: function(context) {
            var root = context.root;
            var blocks = root.childNodes;
            for (var i = blocks.length - 1; i >= 0; i--) {
                if (!com.isTag(blocks[i], "table")) {
                    root.removeChild(blocks[i]);
                }
            }
        },

        /**
         * @private
         */
        hasSimilarParent: function(context, dom) {
            var dpr = CUI.rte.DomProcessor;
            if (!dom || (dom.nodeType != 1)) {
                return false;
            }
            var checkDom = com.getParentNode(context, dom);
            while (checkDom) {
                if (dpr.getTagType(checkDom) == dpr.CONTAINER) {
                    return false;
                }
                if (checkDom.nodeType == 1) {
                    if (com.equals(dom, checkDom)) {
                        return true;
                    }
                }
                checkDom = com.getParentNode(context, checkDom);
            }
            return false;
        },

        /**
         * Removes duplicate DOM nodes. For example, the inner "b" node in &lt;b&gt;A bold
         * &lt;b&gt;text&lt;/b&gt;.&lt;/b&gt; gets removed, as it is unnecessary.
         * @param {CUI.rte.EditContext} context The edit context
         * @param {HTMLElement} startNode first node to check (inclusive)
         * @param {HTMLElement} endNode last node to check (inclusive)
         * @return {Object} Object that contains the valid start/end node after duplicates
         *         have been removed (properties: startNode, endNode)
         */
        removeDuplicateStructures: function(context, startNode, endNode) {
            var dpr = CUI.rte.DomProcessor;
            var node = startNode;
            while (node) {
                var isProcessed = false;
                if (node.nodeType == 1) {
                    if ((dpr.getTagType(node) != dpr.CONTAINER)
                            && dpr.hasSimilarParent(context, node)) {
                        var nextNode = com.getNextNode(context, node);
                        if (node == startNode) {
                            startNode = nextNode;
                        }
                        if (node == endNode) {
                            endNode = nextNode;
                        }
                        dpr.removeWithoutChildren(node);
                        node = nextNode;
                        isProcessed = true;
                    }
                }
                if (!isProcessed) {
                    if (node == endNode) {
                        break;
                    }
                    node = com.getNextNode(context, node);
                }
            }
            return {
                "startNode": startNode,
                "endNode": endNode
            };
        },

        /**
         * <p>Joins the specified DOM text node with the preceding or succeeding text node
         * structurally if possible.</p>
         * <p>For example: &lt;b&gt;ABC &lt;/b&gt;&lt;b&gt;DEF&lt;/b&gt; can be joined to
         * &lt;b&gt;ABC DEF&lt;/b&gt;</p>
         * @param {CUI.rte.EditContext} context The edit context
         * @param {HTMLElement} dom node t0 check; if this is no text node, the first
         *        descendant text node will be used instead
         * @param {Boolean} joinPreceding True if the specified DOM node should be joined
         *        with the preceding text node; False if the succeeding node should be used
         *        for joining
         */
        joinIdenticalStructures: function(context, dom, joinPreceding) {
            var dpr = CUI.rte.DomProcessor;
            if (dom.nodeType == 1) {
                dom = com.getFirstTextChild(dom) || dom;
            }
            var joinDom = (joinPreceding ? com.getPreviousTextNode(context, dom)
                    : com.getNextTextNode(context, dom));
            if (!dom || !joinDom) {
                return;
            }
            var domCheck = com.getParentNode(context, dom);
            var joinCheck = com.getParentNode(context, joinDom);
            var canJoin = true;
            var hasCommonAncestors = false;
            while (dpr.getTagType(domCheck) == dpr.STRUCTURE) {
                if (!com.equals(domCheck, joinCheck)) {
                    canJoin = false;
                    break;
                }
                hasCommonAncestors = true;
                domCheck = com.getParentNode(context, domCheck);
                joinCheck = com.getParentNode(context, joinCheck);
                if ((domCheck == null) || (joinCheck == null)) {
                    canJoin = (domCheck == joinCheck);
                    break;
                }
            }
            if (canJoin) {
                // must share the same container
                canJoin = (domCheck == joinCheck);
            }
            if (canJoin && hasCommonAncestors) {
                var destParent = dom.parentNode;
                var srcParent = joinDom.parentNode;
                // joining up the hierarchy
                while (destParent != srcParent) {
                    var newSrcParent = srcParent.parentNode;
                    if (joinPreceding) {
                        com.moveChildren(srcParent, destParent, 0, false);
                    } else {
                        com.moveChildren(srcParent, destParent, 0, true);
                    }
                    // clean up after every iteration
                    com.removeNodesWithoutContent(context, srcParent);
                    srcParent = newSrcParent;
                    destParent = destParent.parentNode;
                    if (dpr.getTagType(destParent) == dpr.CONTAINER) {
                        break;
                    }
                }
            }
        },

        splitToParent: function(splitParent, node, offset) {
            var sel = CUI.rte.Selection;
            var isNoInsertNode = sel.isNoInsertNode(node) && (offset == null);
            var clonedNode, parentNode, nodeToMove;
            var nodesToMove = [ ];
            var isOriginalNode = true;
            var childIndex;
            while (true) {
                if (!node) {
                    return null;
                }
                if (isNoInsertNode) {
                    // must mark all nodes "behind" the current node for moving, as the
                    // normal mechanism does not work for non-insertable nodes
                    childIndex = com.getChildIndex(node);
                    var children = node.parentNode.childNodes;
                    for (; childIndex < children.length; childIndex++) {
                        nodeToMove = children[childIndex];
                        nodesToMove.push(nodeToMove);
                    }
                    node = node.parentNode;
                    isNoInsertNode = false;
                }
                parentNode = node.parentNode;
                if (node.nodeType == 3) {
                    if (offset == 0) {
                        // will be removed one hierarchy level up on moving
                        nodesToMove.push(node);
                    } else if (offset < com.getNodeCharacterCnt(node)) {
                        var nodeText = node.nodeValue;
                        node.nodeValue = nodeText.substring(0, offset);
                        clonedNode = node.cloneNode(false);
                        clonedNode.nodeValue = nodeText.substring(offset, nodeText.length);
                        nodesToMove.push(clonedNode);
                    }
                } else {
                    // edge case: splitting from a parent node offset
                    if (isOriginalNode) {
                        for (childIndex = offset; childIndex < node.childNodes.length;
                                childIndex++) {
                            nodesToMove.push(node.childNodes[childIndex]);
                        }
                    }
                    clonedNode = node.cloneNode(false);
                    var copyCnt = nodesToMove.length;
                    for (var moveIndex = 0; moveIndex < copyCnt; moveIndex++) {
                        nodeToMove = nodesToMove[moveIndex];
                        if (nodeToMove.parentNode) {
                            nodeToMove.parentNode.removeChild(nodeToMove);
                        }
                        clonedNode.appendChild(nodesToMove[moveIndex]);
                    }
                    nodesToMove.length = 0;
                    nodesToMove.push(clonedNode);
                }
                if (node != splitParent) {
                    childIndex = com.getChildIndex(node) + 1;
                    while (childIndex < parentNode.childNodes.length) {
                        nodeToMove = parentNode.childNodes[childIndex];
                        parentNode.removeChild(nodeToMove);
                        nodesToMove.push(nodeToMove);
                    }
                } else {
                    if (node.nextSibling) {
                        parentNode.insertBefore(clonedNode, node.nextSibling);
                    } else {
                        parentNode.appendChild(clonedNode);
                    }
                    return clonedNode;
                }
                node = parentNode;
                isOriginalNode = false;
            }
        },

        removeUnwantedEmptyTags: function(node, tagList) {
            if (com.matchesTagDefs(node, tagList)) {
                if (!com.hasTextChild(node, true)) {
                    node.parentNode.removeChild(node);
                    return;
                }
            }
            if (node.nodeType == 1) {
                var childCnt = node.childNodes.length;
                for (var c = childCnt - 1; c >= 0; c--) {
                    CUI.rte.DomProcessor.removeUnwantedEmptyTags(node.childNodes[c],
                            tagList);
                }
            }
        },

        /**
         * <p>Inserts a new paragraph at the specified text position.</p>
         * <p>Note that the node returned is the new paragraph in an
         * implementation-specific, technical way. It is always the latter of both affected
         * paragraphs contentwise. This may not always be what you'd expect: If inserting a
         * paragraph at the beginning of an existing paragraph, the existing paragraph seems
         * to be returned as "new paragraph". This is practically not the case, because the
         * method creates a new paragraph (which is actually returned), inserts it behind
         * the existing one and then (in the given case) moves all child nodes to the newly
         * created paragraph, seemingly returning the existing paragraph.</p>
         * <p>Interpretation of <code>offset</code>:</p>
         * <ul>
         *     <li>if node is a text node, it determines the character offset where the
         *     paragraph has to be inserted.</li>
         *     <li>if node is a structural node, it determines the index of child nodes
         *     where the paragraph has to be inserted before.</li>
         *     <li>if node is a "one character structural node" (&lt;bt&gt;, &lt;img&gt;),
         *     a value of 0 determines that the paragraph has to be inserted after the
         *     one character node.</li>
         *     <li>A value of null determines that the paragraph has to be inserted at
         *     the end of the child list of a structural node.</li>
         * </ul>
         * @param {CUI.rte.EditContext} context The edit context
         * @param {HTMLElement} node Node that determines the insert position
         * @param {Number} offset (optional) Offset which determines the insert position
         * @return {HTMLElement} The newly created paragraph
         */
        insertParagraph: function(context, node, offset) {
            var dpr = CUI.rte.DomProcessor;
            var newPara;
            // inserting "behind" a one-character node must be handled differently:
            // use the next text node in the block if available or offset to parent DOM
            // instead
            if (com.isOneCharacterNode(node) && (offset == 0)) {
                var nextTextNode = com.getNextCharacterNode(context, node,
                        com.EDITBLOCK_TAGS);
                if (nextTextNode) {
                    node = nextTextNode;
                    offset = (node.nodeType == 3 ? 0 : null);
                } else {
                    offset = com.getChildIndex(node) + 1;
                    node = com.getParentNode(context, node);
                }
            }
            // handle EOT & EOL with objects
            if ((node.nodeType == 1) && !com.isOneCharacterNode(node)
                    && ((offset == null) || (offset == node.childNodes.length))) {
                if (offset == null) {
                    offset = node.childNodes.length;
                }
                if (com.isRootNode(context, node)) {
                    newPara = node.childNodes[offset - 1].cloneNode(false);
                    node.appendChild(newPara);
                    node = node.childNodes[offset - 1];
                } else {
                    newPara = node.cloneNode(false);
                    node.parentNode.insertBefore(newPara, node.nextSibling);
                }
                var clonedRoot = null;
                var copyNode = com.getLastTextChild(node);
                copyNode = copyNode ? copyNode : com.getLastChild(node);
                copyNode = copyNode ? copyNode : node;
                while (copyNode != node) {
                    if ((copyNode.nodeType == 1) && !dpr.isNoInsertNode(copyNode)) {
                        var clonedNode = copyNode.cloneNode(false);
                        if (clonedRoot != null) {
                            clonedNode.appendChild(clonedRoot);
                        }
                        clonedRoot = clonedNode;
                    }
                    copyNode = com.getParentNode(context, copyNode);
                }
                if (clonedRoot != null) {
                    newPara.appendChild(clonedRoot);
                }
                dpr.ensureEmptyLinePlaceholders(context, newPara);
                dpr.fixEmptyEditingBlockIE(context, newPara);
            } else {
                var scopedBlock = dpr.getScopedBlockNode(context, node);
                if (!scopedBlock) {
                    throw new Error("Inserting paragraph outside an existing format scope");
                }
                var containerNode = scopedBlock.dom;
                if (scopedBlock.isAuxiliaryRoot) {
                    // if a block is created explicitly inside an aux root (for example a
                    // table cell), move the existing content into a splitable paragraph
                    // first
                    var newParagraph = context.createElement("p");
                    com.moveChildren(containerNode, newParagraph);
                    containerNode.appendChild(newParagraph);
                    containerNode = newParagraph;
                }
                newPara = dpr.splitToParent(containerNode, node, offset);
                dpr.removeUnwantedEmptyTags(containerNode, dpr.EMPTYTEXT_EXCLUSIONS);
                var toCheck = com.getLastTextChild(containerNode, true, false);
                if (com.isTag(toCheck, "br")) {
                    toCheck.parentNode.removeChild(toCheck);
                }
                dpr.removeUnwantedEmptyTags(newPara, dpr.EMPTYTEXT_EXCLUSIONS);
                dpr.ensureEmptyLinePlaceholders(context, newPara);
                dpr.ensureEmptyLinePlaceholders(context, containerNode);
                dpr.fixEmptyEditingBlockIE(context, newPara);
                dpr.fixEmptyEditingBlockIE(context, containerNode);
            }
            return newPara;
        },

        /**
         * <p>Checks if the specified node is at the beginning of a block.</p>
         * <p>Note that in &lt;p&gt;&lt;b&gt;Test&lt;/b&gt;text&lt;/p&gt; both the
         * "b" tag and the first character of "Test" are recognized as residing at the
         * beginning of the "p" block.</p>
         * @param {CUI.rte.EditContext} context The edit context
         * @param {HTMLElement} dom The HTML element to check
         * @param {Number} offset The character offest (if dom is a text node) or the
         *        offset in dom's childNodes array
         */
        isBlockStart: function(context, dom, offset) {
            var dpr = CUI.rte.DomProcessor;
            var scopedBlock = dpr.getScopedBlockNode(context, dom);
            if (!scopedBlock) {
                return false;
            }
            scopedBlock = scopedBlock.dom;
            if (dom.nodeType == 3) {
                if (offset > 0) {
                    return false;
                }
                return (com.getFirstTextChild(scopedBlock, true) == dom);
            }
            if (offset != null) {
                if (offset > 0) {
                    return false;
                }
            }
            var walker = scopedBlock;
            while ((walker.nodeType == 1) && (walker.childNodes.length > 0)) {
                if (walker.childNodes[0] == dom) {
                    return true;
                }
                walker = walker.childNodes[0];
            }
            return false;
        },

        /**
         * <p>Checks if the specified node is at the end of a block.</p>
         * <p>Note that in &lt;p&gt;Test &lt;b&gt;text&lt;/b&gt;&lt;/p&gt; both the
         * "b" tag and the last character of "text" are recognized as residing at the
         * end of the "p" block.</p>
         * @param {CUI.rte.EditContext} context The edit context
         * @param {HTMLElement} dom The HTML element to check
         * @param {Number} offset The character offest (if dom is a text node) or the
         *        offset in dom's childNodes array
         */
        isBlockEnd: function(context, dom, offset) {
            var dpr = CUI.rte.DomProcessor;
            var scopedBlock = dpr.getScopedBlockNode(context, dom);
            if (!scopedBlock) {
                return false;
            }
            scopedBlock = scopedBlock.dom;
            if (dom.nodeType == 3) {
                if (offset < dom.nodeValue.length) {
                    return false;
                }
                return (com.getLastTextChild(scopedBlock, true) == dom);
            }
            if (offset != null) {
                if (offset < dom.childNodes.length - 1) {
                    return false;
                }
            }
            var walker = scopedBlock;
            while ((walker.nodeType == 1) && (walker.childNodes.length > 0)) {
                if (walker.childNodes[walker.childNodes.length - 1] == dom) {
                    return true;
                }
                walker = walker.childNodes[walker.childNodes.length - 1];
            }
            return false;
        },

        /**
         * <p>Get the container node (such as p, ul, etc.) for the specified DOM
         * element.</p>
         * <p>Note that only container nodes that are directly under the body node are
         * taken into account. "Auxiliary root nodes" (such as td, th) will not be included.
         * </p>
         * @param {CUI.rte.EditContext} context The edit context
         * @param {HTMLElement} dom DOM element to determine container node for
         * @return {HTMLElement} container DOM node; null if no container node is present
         */
        getContainerNode: function(context, dom) {
            var dpr = CUI.rte.DomProcessor;
            while (dom) {
                if (dom.nodeType == 1) {
                    if (!com.isTag(dom, dpr.AUXILIARY_ROOT_TAGS)) {
                        if (dpr.getTagType(dom) == dpr.CONTAINER) {
                            return dom;
                        }
                    }
                }
                dom = com.getParentNode(context, dom);
            }
            return null;
        },

        /**
         * Gets the edit block for the specified node.
         * @param {CUI.rte.EditContext} context The edit context
         * @param {HTMLElement} dom The DOM element to get the edit block for
         */
        getEditBlock: function(context, dom) {
            return com.getTagInPath(context, dom, com.EDITBLOCK_TAGS);
        },

        /**
         * Gets all editable blocks under the specified auxiliary root.
         * @param {HTMLElement} auxRoot The auxiliary root (or the document's body element)
         * @param {HTMLElement[]} editBlocks (optional) The array containing all edit blocks
         *        found
         * @return {HTMLElement[]}  The array containing all edit blocks found
         */
        getEditBlocks: function(auxRoot, editBlocks) {
            var dpr = CUI.rte.DomProcessor;
            if (editBlocks === undefined) {
                editBlocks = [ ];
            }
            var childCnt = auxRoot.childNodes.length;
            for (var c = 0; c < childCnt; c++) {
                var child = auxRoot.childNodes[c];
                if (!com.isTag(child, dpr.AUXILIARY_ROOT_TAGS)) {
                    if (com.isTag(child, com.EDITBLOCK_TAGS)) {
                        editBlocks.push(child)
                    }
                    dpr.getEditBlocks(child, editBlocks);
                }
            }
            return editBlocks;
        },

        /**
         * Checks if there are any editable blocks under the specified auxiliary root.
         * @param {HTMLElement} auxRoot The auxiliary root (or the document's body element)
         * @return {Boolean} True if there are editable blocks available
         */
        hasEditBlocks: function(auxRoot) {
            var dpr = CUI.rte.DomProcessor;
            var childCnt = auxRoot.childNodes.length;
            for (var c = 0; c < childCnt; c++) {
                var child = auxRoot.childNodes[c];
                if (!com.isTag(child, dpr.AUXILIARY_ROOT_TAGS)) {
                    if (com.isTag(child, com.EDITBLOCK_TAGS)
                            || dpr.hasEditBlocks(child)) {
                        return true;
                    }
                }
            }
            return false;
        },

        /**
         * <p>Gets the "auxiliary root" for the specified node.</p>
         * <p>This is either one of the elements that is specified as an aux root (table
         * cells, etc.) or the document's body node.</p>
         * @param {CUI.rte.EditContext} context The edit context
         * @param {HTMLElement} dom The DOM element to determine the aux root for; if the
         *        specified element is an auxiliary root by itself, dom (and not dom's super
         *        auxiliary root) is returned
         * @return {HTMLElement} The auxiliary root (or the document's body node)
         */
        getAuxRootNode: function(context, dom) {
            while (dom) {
                if (com.isRootNode(context, dom)) {
                    return dom;
                }
                if (com.isTag(dom, CUI.rte.DomProcessor.AUXILIARY_ROOT_TAGS)) {
                    return dom;
                }
                dom = com.getParentNode(context, dom);
            }
            return context.root;
        },

        /**
         * <p>Get the container node (such as p, ul, etc.) for the specified DOM
         * element, considering it being the last container node in the document
         * (required for handling "end of text" situations.</p>
         * <p>Note that only container nodes that are directly under the body node are
         * taken into account. "Auxiliary root nodes" (such as td, th) will not be included.
         * </p>
         * @param {HTMLElement} dom DOM element to determine container node for
         * @return {HTMLElement} container DOM node; null if no container node is present
         */
        getLastContainerNode: function(context, dom) {
            var dpr = CUI.rte.DomProcessor;
            var node = com.getLastChild(dom);
            while (node && (node != dom)) {
                if (node.nodeType == 1) {
                    if (dpr.getTagType(node) == dpr.CONTAINER) {
                        if (!com.isTag(node, dpr.AUXILIARY_ROOT_TAGS)) {
                            return node;
                        }
                    }
                }
                node = com.getPreviousNode(context, node);
            }
            return null;
        },

        /**
         * @private
         */
        getSiblingContainerNode: function(context, dom, delimiterDom, fn) {
            var dpr = CUI.rte.DomProcessor;
            while (dom) {
                if (dom == delimiterDom) {
                    return null;
                }
                if (dom.nodeType == 1) {
                    if (dpr.getTagType(dom) == dpr.CONTAINER) {
                        if (!com.isTag(dom, dpr.AUXILIARY_ROOT_TAGS)) {
                            return dom;
                        }
                    }
                }
                dom = fn(context, dom);
            }
            return null;
        },

        getFormatTagInPath: function(context, dom, formatDefs) {
            while (dom) {
                if (dom.nodeType == 1) {
                    if (com.isRootNode(context, dom)) {
                        return null;
                    }
                    var tagToCheck = dom.tagName.toLowerCase();
                    for (var formatId in formatDefs) {
                        var formatDef = formatDefs[formatId];
                        if (formatDef.tag && (formatDef.tag == tagToCheck)) {
                            return dom;
                        }
                    }
                }
                dom = dom.parentNode;
            }
            return null;
        },

        /**
         * <p>Creates a list of all "first level" container nodes (such as p, h1, etc.),
         * covered by the specified selection.</p>
         * <p>Note that only container nodes that are directly under the body node are
         * taken into account. "Auxiliary root nodes" (such as td, th) will not be included.
         * Also note that this method only includes "container" nodes (nodes that are
         * explicitly marked as such through {@link CUI.rte.DomProcessor.TYPE_TABLE}),
         * not block nodes.</p>
         * @param {CUI.rte.EditContext} context The edit context
         * @param {Object} selection Selection to create container list from (as created by
         *        CUI.rte.Selection.createProcessingSelection()
         */
        createContainerList: function(context, selection) {
            var sel = CUI.rte.Selection;
            var dpr = CUI.rte.DomProcessor;
            selection = sel.adaptToInclusiveEndNode(context, selection);
            var startNode = selection.startNode;
            var endNode = selection.endNode;
            var node;
            if (!selection.isEOT) {
                node = dpr.getContainerNode(context, startNode);
            } else {
                node = dpr.getLastContainerNode(context, startNode);
            }
            if (!node && endNode && (endNode != startNode)) {
                // corner case: selection might start under an auxiliary root - then take
                // next container (only if there is a end node and the end node is different
                // from the start node)
                node = dpr.getSiblingContainerNode(context, startNode, endNode,
                        com.getNextNode);
            }
            if (!node) {
                return [ ];
            }
            if (!endNode) {
                return [ node ];
            }
            endNode = dpr.getContainerNode(context, endNode);
            if (!endNode) {
                endNode = dpr.getLastContainerNode(context, selection.endNode);
            }
            if (!endNode) {
                // corner case: selection might end under an auxiliary root - then take
                // previous container
                endNode = dpr.getSiblingContainerNode(context, selection.endNode, startNode,
                        com.getPreviousNode);
            }
            if (!endNode) {
                return [ node ];
            }
            var containerNodes = [ ];
            while (node) {
                if (node.nodeType == 1) {
                    // as auxiliary roots are usually also container tags, exclude them
                    // as we only cover first level container nodes
                    if (!com.isTag(node, dpr.AUXILIARY_ROOT_TAGS)) {
                        if (dpr.getTagType(node) == dpr.CONTAINER) {
                            containerNodes.push(node);
                        }
                    }
                }
                if (node == endNode) {
                    break;
                }
                node = com.getNextNode(context, node);
            }
            return containerNodes;
        },

        /**
         * <p>Creates a list of all block nodes (such as p, h1, etc.), covered by the
         * specified selection.</p>
         * @param {CUI.rte.EditContext} context The edit context
         * @param {Object} selection Selection to create block list from (as created by
         *        CUI.rte.Selection.createProcessingSelection()
         * @deprecated
         */
        createBlockList: function(context, selection) {
            var sel = CUI.rte.Selection;
            selection = sel.adaptToInclusiveEndNode(context, selection);
            var startNode = selection.startNode;
            var endNode = selection.endNode;
            var node;
            if (!selection.isEOT) {
                node = com.getBlockNode(context, startNode);
            } else {
                node = com.getLastBlockNode(context, startNode);
            }
            if (!node) {
                return [ ];
            }
            if (!endNode) {
                return [ node ];
            }
            endNode = com.getBlockNode(context, endNode);
            if (!endNode) {
                return [ node ];
            }
            var blockNodes = [ ];
            while (node) {
                if (node.nodeType == 1) {
                    if (com.isBlockNode(context, node)) {
                        blockNodes.push(node);
                    }
                }
                if (node == endNode) {
                    break;
                }
                node = com.getNextNode(context, node);
            }
            return blockNodes;
        },

        /**
         * <p>Checks if the given node has any child that is a container node.</p>
         * <p>Note that this method does not work recursively (by nature). Hence the
         * specified node must be a body node or an auxiliary root node.</p>
         * @private
         */
        hasContainerChildNodes: function(dom) {
            var dpr = CUI.rte.DomProcessor;
            var childCnt = dom.childNodes.length;
            for (var c = 0; c < childCnt; c++) {
                var child = dom.childNodes[c];
                if (child.nodeType == 1) {
                    if (dpr.getTagType(child) == dpr.CONTAINER) {
                        return true;
                    }
                }
            }
            return false;
        },

        /**
         * <p>Creates a list of auxiliary root nodes for the given selection.</p>
         * <p>Note that only auxiliary roots without any containing container nodes are
         * returned. For example: &lt;td&gt;text&lt;/td&gt; is reported as an auxiliary
         * root, whereas &lt;td&gt;&gt;p&lt;para 1&gt;/p&lt;&gt;p&lt;para 2&gt;/p&lt;
         * &lt;/td&gt; is not reported as an auxiliary root.</p>
         * @param {CUI.rte.EditContext} context The edit context
         * @param {Object} selection Processing selection
         * @return {Array} List of auxiliary roots
         */
        getAuxRoots: function(context, selection) {
            var sel = CUI.rte.Selection;
            var dpr = CUI.rte.DomProcessor;
            var auxRoots = [ ];
            // handle cell selection separately
            if (selection.cellSelection) {
                var cells = selection.cellSelection.cells;
                if (cells && (cells.length > 0)) {
                    for (var c = 0; c < cells.length; c++) {
                        auxRoots.push(cells[c]);
                    }
                    return auxRoots;
                }
            }
            selection = sel.adaptToInclusiveEndNode(context, selection);
            var node = selection.startNode;
            var endNode = selection.endNode;
            while (node) {
                if (node.nodeType == 1) {
                    if (dpr.getTagType(node) == dpr.CONTAINER) {
                        if (com.isTag(node, dpr.AUXILIARY_ROOT_TAGS)) {
                            auxRoots.push(node);
                        }
                        break;
                    }
                }
                node = com.getParentNode(context, node);
            }
            // corner case: we're starting on a non-container
            if (!node) {
                node = com.getTagInPath(context, selection.startNode, com.BLOCK_TAGS);
                if (!node) {
                    return auxRoots;
                }
            }
            if (endNode && (endNode != node)) {
                node = com.getNextNode(context, node);
                while (node) {
                    if (node.nodeType == 1) {
                        if (com.isTag(node, dpr.AUXILIARY_ROOT_TAGS)) {
                            if (!dpr.hasContainerChildNodes(node)) {
                                auxRoots.push(node);
                            }
                        }
                    }
                    if (node == endNode) {
                        break;
                    }
                    node = com.getNextNode(context, node);
                }
            }
            return auxRoots;
        },

        changeContainerTag: function(context, containerList, blueprintDom,
                ensurePlaceholder) {
            var dpr = CUI.rte.DomProcessor;
            var elCnt = containerList.length;
            var isToPre = com.isTag(blueprintDom, "pre");
            for (var elIndex = 0; elIndex < elCnt; elIndex++) {
                var containerEl = containerList[elIndex];
                var isFromPre = com.isTag(containerEl, "pre");
                var clonedDom = blueprintDom.cloneNode(blueprintDom);
                var txt = containerEl.innerHTML;
                com.replaceNode(containerEl, clonedDom);
                if (isFromPre != isToPre) {
                    if (isFromPre) {
                        // $todo handle multispaces
                        txt = txt.replace(/\n\r/g, "\n");
                        txt = txt.replace(/\r\n/g, "\n");
                        txt = txt.replace(/\r/g, "\n");
                        txt = txt.replace(/\n/g, "<br>");
                        clonedDom.innerHTML = txt;
                    }
                }
                if (ensurePlaceholder) {
                    dpr.ensureEmptyLinePlaceholders(context, clonedDom);
                }
                dpr.fixEmptyEditingBlockIE(context, clonedDom);
            }
        },

        getStyles: function(context, stylesDef, node) {
            var styles = stylesDef.styles;
            if (!styles) {
                styles = [ ];
                stylesDef.styles = styles;
            }
            while (!com.isRootNode(context, node)) {
                if (com.isTag(node, "span")) {
                    if (node.className) {
                        styles.push({
                            "dom": node,
                            "className": node.className
                        });
                    }
                }
                node = com.getParentNode(context, node);
            }
            stylesDef.isContinuousStyle = (styles.length == 1);
        },

        getScopedBlockNode: function(context, dom) {
            var dpr = CUI.rte.DomProcessor;
            while (dom) {
                if (com.isTag(dom, com.BLOCK_TAGS)) {
                    return {
                        "dom": dom,
                        "isAuxiliaryRoot": false
                    };
                }
                if (com.isTag(dom, dpr.AUXILIARY_ROOT_TAGS)) {
                    return {
                        "dom": dom,
                        "isAuxiliaryRoot": true
                    };
                }
                if (com.isRootNode(context, dom.parentNode)) {
                    return {
                        "dom": dom,
                        "isAuxiliaryRoot": false
                    };
                }
                dom = com.getParentNode(context, dom);
            }
            return null;
        },

        ensureBlockContent: function(context, tagName, attribs, brAsParDelimiter,
                                     createBookmark) {
            var com = CUI.rte.Common;
            var dpr = CUI.rte.DomProcessor;
            var sel = CUI.rte.Selection;
            var bookmark = null;
            var pNode = null;
            var root = context.root;
            var insertTag = null;
            var nodes = root.childNodes;
            for (var childIndex = nodes.length - 1; childIndex >= 0; childIndex--) {
                var nodeToProcess = nodes[childIndex];
                var isBr = com.isTag(nodeToProcess, "br");
                var isBlockNode = com.isTag(nodeToProcess, com.BLOCK_TAGS);
                if ((nodeToProcess.nodeType == 3) || (isBr && !brAsParDelimiter)
                        || (!isBr && !isBlockNode)) {
                    if ((bookmark == null) && createBookmark) {
                        bookmark = sel.createSelectionBookmark(context);
                    }
                    if (!pNode) {
                        pNode = dpr.createNode(context, tagName, attribs);
                        root.insertBefore(pNode, insertTag);
                        insertTag = pNode;
                    }
                    // Firefox 6 throws an exception if a node with _moz_editor_bogus_node
                    // attribute set to TRUE is removed from its parent (although it is
                    // physically present ...)
                    if (nodeToProcess.parentNode) {
                        root.removeChild(nodeToProcess);
                    }
                    pNode.insertBefore(nodeToProcess, pNode.firstChild);
                } else if (isBr) {
                    if ((bookmark == null) && createBookmark) {
                        bookmark = sel.createSelectionBookmark(context);
                    }
                    pNode = null;
                    root.removeChild(nodeToProcess);
                } else if (nodeToProcess.nodeType == 1) {
                    insertTag = nodeToProcess;
                    pNode = null;
                }
            }
            return bookmark;
        },

        /**
         * Inserts the specified plain text at the specified position.
         * @param {CUI.rte.EditContext} context The edit context
         * @param {HTMLElement} node The node where the text will be inserted
         * @param {Number} offset Inserting offset; null (in conjunction with a structural
         *        node) means "insert at the first possible child position; for example
         *        if node is a "p" tag, the text gets inserted before the first character
         *        of that paragraph)
         * @param {String} text The text to insert
         */
        insertText: function(context, node, offset, text) {
            var root = context.root;
            var firstNode, nodeSave;
            if (node.nodeType == 1) {
                if (offset == null) {
                    nodeSave = node;
                    node = com.getFirstTextChild(node);
                    if (!node) {
                        var isBlockNode = false;
                        firstNode = com.getFirstChild(nodeSave);
                        if (!firstNode) {
                            if (!com.isOneCharacterNode(nodeSave)) {
                                // inserting in an empty structural node
                                firstNode = nodeSave;
                                isBlockNode = true;
                            } else {
                                // inserting before BR, IMG, A et al
                                firstNode = nodeSave;
                            }
                        }
                        else if (!com.isCharacterNode(firstNode)) {
                            isBlockNode = true;
                        }
                        node = context.createTextNode("");
                        if (isBlockNode) {
                            firstNode.appendChild(node);
                        } else {
                            firstNode.parentNode.insertBefore(node, firstNode);
                        }
                    }
                    offset = 0;
                } else {
                    var childCnt = node.childNodes.length;
                    if (childCnt > 0) {
                        if (offset >= childCnt) {
                            // EOL/EOT
                            node = com.getLastChild(node);
                            if (node.nodeType == 3) {
                                offset = com.getNodeCharacterCnt(node);
                            } else {
                                var pNode = node.parentNode;
                                node = context.createTextNode("");
                                pNode.appendChild(node);
                                offset = 0;
                            }
                        } else {
                            node = node.childNodes[offset];
                            if (node.nodeType == 1) {
                                node = com.getPreviousCharacterNode(context, node);
                                if (!node) {
                                    // BOT
                                    firstNode = com.getFirstChild(root);
                                    node = context.createTextNode("");
                                    firstNode.parentNode.insertBefore(node, firstNode);
                                } else if (node.nodeType == 1) {
                                    // if previous node is also a "one character node", we
                                    // will insert an empty text node behind
                                    var textNode = context.createTextNode("");
                                    node.parentNode.insertBefore(textNode,
                                            node.nextSibling);
                                    node = textNode;
                                }
                            }
                            offset = com.getNodeCharacterCnt(node);
                        }
                    } else {
                        node = com.getPreviousTextNode(context, node);
                        if (!node) {
                            // BOT
                            firstNode = com.getFirstChild(root);
                            node = context.createTextNode("");
                            firstNode.parentNode.insertBefore(node, firstNode);
                        }
                        offset = com.getNodeCharacterCnt(node);
                    }
                }
            }
            var currentText = node.nodeValue;
            if (currentText.length <= offset) {
                currentText += text;
            } else if (offset == 0) {
                currentText = text + currentText;
            } else {
                currentText = currentText.substring(0, offset) + text
                        + currentText.substring(offset, currentText.length);
            }
            node.nodeValue = currentText;
            return {
                "node": node,
                "offset": offset + text.length
            };
        },

        /**
         * Removes all elements that match the specified tag definitions from the DOM
         * recursively.
         * @param {HTMLElement} rootEl The root element to execute the removal on
         * @param {Object} tagDefsToRemove The definition of the tags to be removed. See
         *        {@link CUI.rte.Common#matchesTagDefs} for an explanation
         */
        removeTagsFromHierarchy: function(rootEl, tagDefsToRemove) {
            var dpr = CUI.rte.DomProcessor;
            var com = CUI.rte.Common;
            var childCnt = rootEl.childNodes.length;
            for (var childIndex = childCnt - 1; childIndex >= 0; childIndex--) {
                var childToProcess = rootEl.childNodes[childIndex];
                dpr.removeTagsFromHierarchy(childToProcess, tagDefsToRemove);
            }
            if (rootEl.nodeType == 1) {
                if (com.matchesTagDefs(rootEl, tagDefsToRemove)) {
                    dpr.removeWithoutChildren(rootEl);
                }
            }
        },

        saveChildNodes: function(dom) {
            var savedChildren = [ ];
            var children = dom.childNodes;
            for (var i = 0; i < children.length; i++) {
                var child = children[i];
                var savedChild = {
                    "dom": child
                };
                savedChildren.push(savedChild);
                if (child.nodeType == 1) {
                    savedChild.children = CUI.rte.DomProcessor.saveChildNodes(
                            child);
                } else {
                    savedChild.text = child.nodeValue;
                }
            }
            return savedChildren;
        },

        restoreChildNodes: function(dom, savedChildren) {
            while (dom.childNodes.length > 0) {
                dom.removeChild(dom.childNodes[0]);
            }
            for (var i = 0; i < savedChildren.length; i++) {
                var child = savedChildren[i];
                var domChild = child.dom;
                if (child.text !== undefined) {
                    domChild.nodeValue = child.text;
                }
                var children = child.children;
                dom.appendChild(domChild);
                if (children) {
                    CUI.rte.DomProcessor.restoreChildNodes(domChild, children);
                }
            }
        },

        /**
         * Inserts the specified DOM node at the specified location.
         * @param {CUI.rte.EditContext} context The edit context
         * @param {HTMLElement} dom Element to insert
         * @param {HTMLElement} insertNode Node of insert location
         * @param {Number} insertOffset Offset of insert location
         */
        insertElement: function(context, dom, insertNode, insertOffset) {
            var parent = insertNode.parentNode;
            if (insertNode.nodeType == 3) {
                // set marker inside a text node
                if (insertOffset == 0) {
                    parent.insertBefore(dom, insertNode);
                } else if (insertOffset >= com.getNodeCharacterCnt(insertNode)) {
                    parent.insertBefore(dom, insertNode.nextSibling);
                } else {
                    var splitNodes = CUI.rte.DomProcessor.splitTextNode(context,
                            insertNode, insertOffset);
                    parent.insertBefore(dom, splitNodes[1]);
                }
                return;
            }
            if (com.isOneCharacterNode(dom)) {
                if (insertOffset == null) {
                    com.insertBefore(parent, dom, insertNode);
                } else {
                    com.insertBefore(parent, dom, insertNode.nextSibling);
                }
            } else {
                var children = insertNode.childNodes;
                if ((insertOffset != null) && (insertOffset < children.length)) {
                    insertNode.insertBefore(dom, children[insertOffset]);
                } else {
                    insertNode.appendChild(dom);
                }
            }
        },

        /**
         * Creates a marker span.
         * @param {CUI.rte.EditContext} context The edit context
         * @param {HTMLElement} node Node the marker is to be added
         * @param {Number} offset Offset of the marker (relative to node)
         * @return {HTMLElement} The marker span
         */
        createMarker: function(context, node, offset) {
            var markerDom = context.createElement("span");
            CUI.rte.DomProcessor.insertElement(context, markerDom, node, offset);
            return markerDom;
        },

        /**
         * Removes a marker span previously set by {@link #createMarker}.
         * @param {CUI.rte.EditContext} context The edit context
         * @param {HTMLElement} markerDom The marker span to be removed
         */
        removeMarker: function(context, markerDom) {
            var prevNode = markerDom.previousSibling;
            var nextNode = markerDom.nextSibling;
            com.removeNodesWithoutContent(context, markerDom);
            if (prevNode && nextNode) {
                if ((prevNode.nodeType == 3) && (nextNode.nodeType == 3)) {
                    prevNode.nodeValue += nextNode.nodeValue;
                    nextNode.parentNode.removeChild(nextNode);
                }
            }
        },

        /**
         * Gecko has several bugs (row-in-row, no table root element) that have to be
         * corrected. As content may theoretically be copied from Gecko to IE, this
         * method should also be called in IE's pasting mechanisms.
         * @param {CUI.rte.EditContext} context The edit context
         * @param {HTMLElement} dom The DOM element that contains the pasted DOM to be
         *        corrected
         */
        correctGeckoCopyBugs: function(context, dom) {
            // fix "no table tag" issue
            var html = dom.innerHTML;
            var htmlLC = html.toLowerCase();
            if (com.strStartsWith(htmlLC, "<tr>") || com.strStartsWith(htmlLC, "<tr ")) {
                dom.innerHTML = "<table>" + html + "</table>";
            }
            // fix "row-in-row" issue (<table><tr><tr><td>...</td></tr></tr></table>
            var rows = com.getChildNodesByType(dom, "tr", true);
            var rowCnt = rows.length;
            for (var r = rowCnt - 1; r >= 0; r--) {
                var row = rows[r];
                var childRows = com.getChildNodesByType(row, "tr", false);
                if (childRows.length > 0) {
                    CUI.rte.DomProcessor.removeWithoutChildren(row);
                }
            }
        },

        /**
         * <p>Checks if the specified DOM element represents a named anchor and returns
         * additional information about it if appropriate.</p>
         * <p>Note that a named anchor must not necessarily be represented by a
         * corresponding "a" DOM element, but may also be substituted by another element,
         * for example a specially attributed image, as not all browsers support editing
         * named anchor elements correctly.</p>
         * @param {HTMLElement} dom The DOM element to check
         * @return {Object} Null if the specified DOM element does not represent a named
         *         anchor; otherwise an object with properties dom (the DOM object) name
         *         (the appropriate name attribute) and isAnchorTag (True if the DOM object
         *         is actually an "a" element, false if the "a" element is substituted by,
         *         for example, an "img" element)
         */
        checkNamedAnchor: function(dom) {
            if (com.ua.isWebKit) {
                // on Webkit, anchors are edited as img elements with a marker
                // attribute set accordingly
                if (com.isTag(dom, "img")) {
                    var nameReplacement = com.getAttribute(dom,
                            com.A_NAME_REPLACEMENT_ATTRIB);
                    if (nameReplacement != null) {
                        return {
                            "dom": dom,
                            "name": nameReplacement,
                            "isAnchorTag": false
                        };
                    }
                }
            } else {
                if (com.isTag(dom, "a") && com.isAttribDefined(dom, "name")) {
                    return {
                        "dom": dom,
                        "name": dom.name,
                        "isAnchorTag": true
                    };
                }
            }
            return null;
        },

        /**
         * Main node type of a {@link CUI.rte.NodeList}'s node: Text node
         * @type String
         */
        TEXT_NODE: "text",

        /**
         * Main node type of a {@link CUI.rte.NodeList}'s node: Structural node
         * @type String
         */
        DOM_NODE: "dom",

        /**
         * Type of DOM/structural node: Container - containers (such as div, p) are
         * considered to be "stronger" than simple structures (such as b, i, u) and hence
         * handled differently, for example when being surrounded: the content of containers
         * always gets explicitly surrounded, for example <i>&lt;p&gt;&lt;span
         * class="test"&gt;Surrounded paragraph &lt;/span&gt;&lt;/p&gt;</i>
         * @type String
         */
        CONTAINER: "container",

        /**
         * Type of DOM/structural node: (Simple) Structure
         * @type String
         */
        STRUCTURE: "structure",

        /**
         * Type of DOM/structural node: Dynamic - the type of some tags is dependent on the
         * context they're used in. For example, "a" tags are sometimes handled as
         * containers, sometimes as structures, sometimes not at all
         * @type String
         */
        DYNAMIC: "dynamic",

        /**
         * Type of DOM/structural node: The node has to be ignored regarding processing
         * functions. For example, list nodes must not be included in any formatting
         * operation, but their item nodes must be included.
         * @type String
         */
        IGNORE: "ignore",

        /**
         * List of tags that may provide their own block tag root
         * @type Array
         */
        AUXILIARY_ROOT_TAGS: [
            "td", "th", "caption"
        ],

        /**
         * Constant that defines the &amp;nbsp; char code
         * @type Number
         */
        NBSP_CODE: 160,

        /**
         * Constant that defines the &amp;nbsp; character
         * @type String
         */
        NBSP: String.fromCharCode(160),

        EMPTYTEXT_EXCLUSIONS: [ {
                "tagName": "a",
                "attribsDefined": [ "href" ],
                "attribsUndefined": [ "name" ]
            },
            { "tagName": "b" }, { "tagName": "i" }, { "tagName": "u" },
            { "tagName": "sub" }, { "tagName": "sup" },
            { "tagName": "span" }
        ]

    };

}();

/**
 * This table is used to determine the type (<code>STRUCTURE</code>,
 * <code>CONTAINER</p>, <p>DYNAMIC</p> of a tag. If nothing is specified
 * for a given tag, <code>STRUCTURE</code> is used as a default. Note: This table
 * may be changed if required. <i>But don't do so unless you are absolutely sure
 * about what you are doing!</i>
 */
CUI.rte.DomProcessor.TYPE_TABLE = {
    "h1": CUI.rte.DomProcessor.CONTAINER,
    "h2": CUI.rte.DomProcessor.CONTAINER,
    "h3": CUI.rte.DomProcessor.CONTAINER,
    "h4": CUI.rte.DomProcessor.CONTAINER,
    "h5": CUI.rte.DomProcessor.CONTAINER,
    "h6": CUI.rte.DomProcessor.CONTAINER,
    "p": CUI.rte.DomProcessor.CONTAINER,
    "div": CUI.rte.DomProcessor.CONTAINER,
    "li": CUI.rte.DomProcessor.CONTAINER,
    "ul": CUI.rte.DomProcessor.IGNORE,
    "ol": CUI.rte.DomProcessor.IGNORE,
    "table": CUI.rte.DomProcessor.IGNORE,
    "tbody": CUI.rte.DomProcessor.IGNORE,
    "thead": CUI.rte.DomProcessor.IGNORE,
    "tfoot": CUI.rte.DomProcessor.IGNORE,
    "tr": CUI.rte.DomProcessor.IGNORE,
    "td": CUI.rte.DomProcessor.CONTAINER,
    "th": CUI.rte.DomProcessor.CONTAINER,
    "caption": CUI.rte.DomProcessor.CONTAINER,
    "address": CUI.rte.DomProcessor.CONTAINER,
    "blockquote": CUI.rte.DomProcessor.CONTAINER,
    "pre": CUI.rte.DomProcessor.CONTAINER
};

/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.DomProcessor
 * @static
 * @private
 * The WhitespaceProcessor provides utility functions to remove unnecessary whitespace
 * from the DOM.
 */
CUI.rte.WhitespaceProcessor = function() {

    var com = CUI.rte.Common;

    var dpr = CUI.rte.DomProcessor;

    return {

        /**
         * Normalizes whitespace in the specified text by:
         * <ul>
         *   <li>Replacing different types (tab, linefeed) of whitespace by simple spaces.
         *     </li>
         *   <li>Removing double/multiple spaces by single spaces</li>
         *   <li>Removing leading and trailing spaces if specified<li>
         * </ul>
         * @param {String} text The text to be normalized
         * @param {Boolean} trimLeft True if leading spaces should be trimmed
         * @param {Boolean} trimRight True if trailing spaces should be timmed
         * @return {String} The normalized text
         */
        normalizeWhitespace: function(text, trimLeft, trimRight) {
            var wsp = CUI.rte.WhitespaceProcessor;
            text = text.replace(wsp.WHITESPACE_REGEX, " ");
            text = text.replace(wsp.MULTISPACE_REGEX, " ");
            var charPos;
            if (trimLeft) {
                charPos = 0;
                while ((charPos < text.length) && (text.charAt(charPos) == " ")) {
                    charPos++;
                }
                if (charPos < text.length) {
                    text = text.substring(charPos, text.length);
                } else {
                    text = "";
                }
            }
            if (trimRight) {
                charPos = text.length - 1;
                while ((charPos >= 0) && (text.charAt(charPos) == " ")) {
                    charPos--;
                }
                if (charPos >= 0) {
                    text = text.substring(0, charPos + 1);
                } else {
                    text = "";
                }
            }
            return text;
        },

        /**
         * <p>Handles the whitespace of a text block.</p>
         * <p>A text block are any number of adjacent text nodes, sharing the same
         * parent node.</p>
         * <p>Note that adjacent text nodes are merged into one single text node if
         * necessary.</p>
         * @param {String} text The text of the text block (to be normalized)
         * @param {HTMLElement[]} children Array with child nodes of the parent node
         * @param {Number} startIndex Index of first child the text block is consisting of
         * @param {Number} endIndex Index of last child the text block is consisting of
         * @param {Array} nodesToRemove Array that is filled with nodes that have to be
         *        removed because of joined text nodes
         * @param {Boolean} trimEdges True if trailing and leading whitespace has to be
         *        trimmed
         */
        handleTextBlock: function(text, children, startIndex, endIndex, nodesToRemove,
                                  trimEdges) {
            var wsp = CUI.rte.WhitespaceProcessor;
            var childCnt = children.length;
            var trimLeft = (startIndex == 0) && trimEdges;
            if (!trimLeft && trimEdges) {
                if (com.isTag(children[startIndex - 1], "br")) {
                    trimLeft = true;
                }
            }
            var trimRight = (endIndex == (childCnt - 1)) && trimEdges;
            if (!trimRight && trimEdges) {
                if (com.isTag(children[endIndex + 1], "br")) {
                    trimRight = true;
                }
            }
            text = wsp.normalizeWhitespace(text, trimLeft, trimRight);
            children[startIndex].nodeValue = text;
            if (text.length == 0) {
                nodesToRemove.push(children[startIndex]);
            }
            for (var mr = startIndex + 1; mr <= endIndex; mr++) {
                nodesToRemove.push(children[mr]);
            }
        },

        /**
         * <p>Handles "no text" structures.</p>
         * <p>"No text" structures have a certain parent element that does not allow to
         * have text nodes (directly) under it. For example, text under a "table" node
         * must not have (editable) text, hence all text nodes under it can safely be
         * removed.</p>
         * @param {CUI.rte.EditContext} context The edit context
         * @param {HTMLElement} dom The "no text" parent node
         * @param {Object[]} removalRules Rules that define the nodes that have to be
         *        removed before whitespace processing is being applied
         */
        handleNoTextStructure: function(context, dom, removalRules) {
            var wsp = CUI.rte.WhitespaceProcessor;
            var children = dom.childNodes;
            var childCnt = children.length;
            // remove all text nodes if the current node is a "no text" tag
            for (var c = childCnt - 1; c >= 0; c--) {
                var child = children[c];
                if (child.nodeType == 3) {
                    dom.removeChild(child);
                } else {
                    var isEditBlock = com.isTag(child, com.EDITBLOCK_TAGS);
                    wsp.processStructure(context, child, isEditBlock, removalRules);
                }
            }
        },

        /**
         * <p>Cleans the text nodes of an "average" structural node.</p>
         * <p>Unnecessary whitespace is removed. The method works recursively. Trailing
         * and leading whitespace (as specified by the trimEdges parameter) should only be
         * trimmed for edit block parent nodes such as "p", "h1", "td", etc.</p>
         * <p>Note that adjacent text nodes are merged by this method.</p>
         * @param {CUI.rte.EditContext} context The edit context
         * @param {HTMLElement} dom The parental structural node
         * @param {Boolean} trimEdges True if trailing and leading whitspace has to be
         *        trimmed
         * @param {Object[]} removalRules Rules that define the nodes that have to be
         *        removed before whitespace processing is being applied
         */
        cleanTextNodes: function(context, dom, trimEdges, removalRules) {
            var wsp = CUI.rte.WhitespaceProcessor;
            var children = dom.childNodes;
            // join all text nodes as far as possible and execute whitespace processing on
            // them
            var text = "";
            var textStartIndex = 0;
            var childrenToRemove = [ ];
            for (var c = 0; c < children.length; c++) {
                var child = children[c];
                if (child.nodeType == 3) {
                    text += child.nodeValue;
                    if (c == (children.length - 1)) {
                        wsp.handleTextBlock(text, children, textStartIndex, c,
                                childrenToRemove, trimEdges);
                    }
                } else {
                    if (textStartIndex < c) {
                        wsp.handleTextBlock(text, children, textStartIndex, c - 1,
                                childrenToRemove, trimEdges);
                    }
                    textStartIndex = c + 1;
                    text = "";
                    wsp.processStructure(context, child, com.isTag(child,
                            com.EDITBLOCK_TAGS), removalRules);
                }
            }
            // remove blocks that are superfluous by now
            for (var r = 0; r < childrenToRemove.length; r++) {
                dom.removeChild(childrenToRemove[r]);
            }
        },

        /**
         * <p>Executes some "super-structural" normalizing.</p>
         * <p>"Super-structural" means that the text nodes of several hierarchical levels
         * are considered for normalizing whitespace. For example,
         * "Some.&lt;b&gt;.text.&lt;/b&gt;" should be normalized to
         * "Some.&lt;b&gt;text&lt;/b&gt;", which can only be done by considering text
         * nodes on different hierarchical levels.</p>
         * @param {CUI.rte.EditContext} context The edit context
         * @param {HTMLElement} dom The structural node to be normalized
         */
        normalizeSuperStructural: function(context, dom) {
            var wsp = CUI.rte.WhitespaceProcessor;
            var children = dom.childNodes;
            var childCnt = children.length;
            var childrenToRemove = [ ];
            var child;
            for (var c = 1; c < childCnt; c++) {
                child = children[c];
                if (!com.isTag(child, wsp.AS_IS_TAGS)) {
                    var prevChild = children[c - 1];
                    var textChild = com.getFirstTextChild(child, false, true);
                    var prevTextChild = com.getLastTextChild(prevChild, false, true);
                    if (textChild && prevTextChild) {
                        var text = textChild.nodeValue;
                        var prevText = prevTextChild.nodeValue;
                        if (com.strStartsWith(text, " ")
                                && com.strEndsWith(prevText, " ")) {
                            if ((child.nodeType == 3) && (prevChild.nodeType == 1)) {
                                // convert "a <b> b </b> c" to "a <b>b</b> c" rather than to
                                // "a <b>b </b>c"
                                prevText = wsp.normalizeWhitespace(prevText, false, true);
                                prevTextChild.nodeValue = prevText;
                                if (prevText.length == 0) {
                                    childrenToRemove.push(prevTextChild);
                                }
                            } else {
                                text = wsp.normalizeWhitespace(text, true, false);
                                textChild.nodeValue = text;
                                if (text.length == 0) {
                                    childrenToRemove.push(textChild);
                                }
                            }
                        }
                    }
                }
            }
            // remove blocks that are superfluous by now
            for (var r = 0; r < childrenToRemove.length; r++) {
                child = childrenToRemove[r];
                child.parentNode.removeChild(child);
            }
        },

        /**
         * <p>Trims and removes empty text nodes between blocks of the specified parent
         * node.</p>
         * <p>For example, "&lt;td&gt;...&lt;p&gt;Para&lt;/p&gt;....&lt;/td&gt;" should be
         * normalized to "&lt;td&gt;&lt;p&gt;Para&lt;/p&gt;&lt;/td&gt;";
         * "&lt;td&gt;..Text..&lt;p&gt;Para&lt;/p&gt;..Text..&lt;/td&gt;" to
         * "&lt;td&gt;Text&lt;p&gt;Para&lt;/p&gt;Text&lt;/td&gt;"
         * @param {CUI.rte.EditContext} context The edit context
         * @param {HTMLElement} dom The parent node to be processed
         */
        handleTextNodesBetweenBlocks: function(context, dom) {
            var wsp = CUI.rte.WhitespaceProcessor;
            var children = dom.childNodes;
            var childCnt = children.length;
            // remove all empty text nodes if they are preceded or succeed by a block
            for (var c = childCnt - 1; c >= 0; c--) {
                var child = children[c];
                if (child.nodeType == 3) {
                    var text = child.nodeValue;
                    var noTextCheck = text.replace(wsp.WHITESPACEONLY_REGEX, "");
                    var hasBlockSiblingLeft = false;
                    var hasBlockSiblingRight = false;
                    var prevSib = child.previousSibling;
                    if (prevSib) {
                        hasBlockSiblingLeft = com.isTag(prevSib, com.BLOCK_TAGS)
                                || com.isTag(prevSib, com.EDITBLOCK_TAGS);
                    }
                    var nextSib = child.nextSibling;
                    if (nextSib) {
                        hasBlockSiblingRight = com.isTag(nextSib, com.BLOCK_TAGS)
                                || com.isTag(nextSib, com.EDITBLOCK_TAGS);
                    }
                    if (hasBlockSiblingLeft || hasBlockSiblingRight) {
                        if (noTextCheck.length == 0) {
                            dom.removeChild(child);
                        } else {
                            text = wsp.normalizeWhitespace(text, hasBlockSiblingLeft,
                                    hasBlockSiblingRight);
                            if (text.length > 0) {
                                child.nodeValue = text;
                            } else {
                                dom.removeChild(child);
                            }
                        }
                    }
                }
            }
        },

        /**
         * <p>Removes all child nodes that match the specified removal rules.</p>
         * @param {CUI.rte.EditContext} context The edit context
         * @param {HTMLElement} dom The parent node
         * @param {Object[]} removalRules Rules that define the nodes that have to be
         *        removed before whitespace processing is being applied
         */
        removeUnsupportedNodes: function(context, dom, removalRules) {
            if (!removalRules) {
                return;
            }
            var children = dom.childNodes;
            var childCnt = children.length;
            var ruleCnt = removalRules.length;
            for (var c = childCnt - 1; c >= 0; c--) {
                var child = children[c];
                for (var r = 0; r < ruleCnt; r++) {
                    var rule = removalRules[r];
                    var mustRemove = false;
                    if ((rule.tagName != null) && com.isTag(child, rule.tagName)) {
                        mustRemove = true;
                    } else if ((rule.namespace != null)) {
                        var namespace = com.getNamespace(child);
                        if (namespace != null) {
                            var nspcRules = rule.namespace;
                            if (!CUI.rte.Utils.isArray(nspcRules)) {
                                nspcRules = [ nspcRules ];
                            }
                            var nspcRuleCnt = nspcRules.length;
                            for (var n = 0; n < nspcRuleCnt; n++) {
                                var ruleNspc = nspcRules[n];
                                if ((ruleNspc == "*") || (namespace == ruleNspc)) {
                                    mustRemove = true;
                                    break;
                                }
                            }
                        }
                    } else if ((rule.nodeType != null)
                            && (child.nodeType == rule.nodeType)) {
                        mustRemove = true;
                    } else if ((rule.fn != null) && (rule.fn(child))) {
                        mustRemove = true;
                    }
                    if (mustRemove) {
                        if (!rule.keepChildren) {
                            dom.removeChild(child);
                        } else {
                            var delta = child.childNodes.length;
                            dpr.removeWithoutChildren(child);
                            // re-scan moved nodes
                            if (delta > 0) {
                                c += delta;
                            }
                        }
                        break;
                    }
                }
            }
        },

        /**
         * <p>Processes a DOM structure recursively.</p>
         * <p>Note that leading and trailing whitespace (as specified by the trimEdges
         * parameter) should be trimmed for edit block elements only.</p>
         * @param {CUI.rte.EditContext} context The edit context
         * @param {HTMLElement} dom The structural DOM node to be processed
         * @param {Boolean} trimEdges True if trailing and leading whitespace must be
         *        trimmed
         * @param {Object[]} removalRules Rules that define the nodes that have to be
         *        removed before whitespace processing is being applied
         * @private
         */
        processStructure: function(context, dom, trimEdges, removalRules) {
            var wsp = CUI.rte.WhitespaceProcessor;
            // keep "as is tags" as they are (don't change anything for "pre" tag, etc.)
            if (com.isTag(dom, wsp.AS_IS_TAGS)) {
                return;
            }
            wsp.removeUnsupportedNodes(context, dom, removalRules);
            if (com.isTag(dom, wsp.NO_TEXT_TAGS)) {
                wsp.handleNoTextStructure(context, dom, removalRules);
                return;
            }
            wsp.cleanTextNodes(context, dom, trimEdges, removalRules);
            wsp.normalizeSuperStructural(context, dom);
            wsp.handleTextNodesBetweenBlocks(context, dom);
        },

        /**
         * <p>Processes the specified node recursively by removing all unnecessary
         * whitespace.</p>
         * @param {CUI.rte.EditContext} context The edit context
         * @param {HTMLElement} dom The element to be processed
         * @param {Object[]} removalRules Rules that define what nodes will be removed
         *        before whitespace rules are applied
         * @param {Boolean} omitDefaultRemoveRules True if default remove rules will be
         *        omitted; false if default remove rules have to be be applied
         */
        process: function(context, dom, removalRules, omitDefaultRemoveRules) {
            var wsp = CUI.rte.WhitespaceProcessor;
            if (!omitDefaultRemoveRules) {
                if (removalRules != null) {
                    removalRules = com.arrayCopy(removalRules);
                    com.arrayAdd(removalRules, wsp.DEFAULT_REMOVAL_RULES);
                } else {
                    removalRules = wsp.DEFAULT_REMOVAL_RULES;
                }
            }
            if (com.isTag(dom, com.EDITBLOCK_TAGS)) {
                wsp.processStructure(context, dom, true, removalRules);
            } else if (!com.isTag(dom, wsp.AS_IS_TAGS)) {
                if (dom.nodeType == 1) {
                    wsp.processStructure(context, dom, true, removalRules);
                } else if (dom.nodeType == 3) {
                    var text = dom.nodeValue;
                    dom.nodeValue = wsp.normalizeWhitespace(text, true, true);
                } else {
                    // nodes of an unsupported type get removed immediately
                    dom.parentNode.removeChild(dom);
                }
            }
        },

        AS_IS_TAGS: [ "pre" ],

        NO_TEXT_TAGS: [ "table", "tbody", "thead", "tr", "ul", "ol" ],

        WHITESPACE_REGEX: /[ \n\r\t]/g,

        MULTISPACE_REGEX: / {2,}/g,

        WHITESPACEONLY_REGEX: / /g,

        DEFAULT_REMOVAL_RULES: [ {
                // Commentary nodes
                "nodeType": 8
            }, {
                // Processing instructions
                "nodeType": 7
            }, {
                // tags that are not suitable for content
                "tagName": [ "meta", "link", "style", "script" ],
                "keepChildren": false
            }, {
                // MS Word specific, namespaced tags, to keep content for
                "namespace": [ "st1" ],
                "keepChildren": true
            }, {
                // other namedspace tags, to be removed completely
                "namespace": [ "*" ]
            }
        ]

    };

}();
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.NodeList
 * @private
 * <p>Class that implements a node list that can be used to manipulate document ranges
 * more easily.</p>
 * <p>Some explanation on the terms used:</p>
 * <ul>
 *   <li>Document range - is a fragment of a document, determined by its first character
 *   position and the number of characters. This is the same model as used by
 *   {@link CUI.rte.Selection}.</li>
 *   <li>Common ancestor - refers to the DOM node that is the direct parent of all nodes of
 *   the represented document range.</li>
 *   <li>"Aligned" - most often, document ranges will start and end in the middle of a DOM
 *   text node. This is referred to as "unaligned". If a document range starts or ends at
 *   the beginning/end of a DOM text node, it is referred to as "aligned".</li>
 * </ul>
 * <p>Some explanation on how this class works:</p>
 * <ul>
 *   <li>Use {@link CUI.rte.DomProcessor#createNodeList} to create a corresponding
 *   node list.</li>
 *   <li>Use {@link #surround} to surround the document range with a certain tag. For
 *   example, you could surround the document range with a "span" tag that contains
 *   a "class" attribute to style the range accordingly. {@link #surround} will handle
 *   some common rules to ensure a correct nesting of tags. See the documentation of
 *   {@link #surround} for further information about what is supported.</li>
 * </ul>
 */
CUI.rte.NodeList = new Class({

    toString: "NodeList",

    /**
     * @property nodes
     */
    nodes: null,

    /**
     * @property commonAncestor
     */
    commonAncestor: null,

    /**
     * @property nodesChanged
     */
    nodesChanged: null,

    /**
     * @cfg {Boolean} removeExistingStructuresOnSurround
     * True if existing structures of the surrounding tags should be removed; defaults to
     * true; example: Surrounding "This is &lt;b&gt;bold&lt;/b&gt;" will result in
     * "&lt;b&gt;This is bold&lt;/b&gt;" if this option has been set to true; else
     * "&lt;b&gt;This is &lt;b&gt;bold&lt;/b&gt;&lt;/b&gt;"
     */
    removeExistingStructuresOnSurround: false,


    construct: function(config) {
        config = config || { };
        CUI.rte.Utils.applyDefaults(config, {
            "removeExistingStructuresOnSurround": true
        });
        CUI.rte.Utils.apply(this, config);
        this.nodes = [ ];
        this.nodesChanged = [ ];
    },

    /**
     * @private
     */
    addChildNode: function(nodeToAdd, nodeList, index) {
        nodeToAdd.parentNode = null;
        nodeToAdd.nodeList = nodeList;
        if (!index || (index >= this.nodes.length)) {
            this.nodes.push(nodeToAdd);
        } else {
            this.nodes.splice(index, 0, nodeToAdd);
        }
    },

    /**
     * @private
     */
    removeChildNode: function(node) {
        var removeIndex = this.getTopLevelNodeIndex(node);
        if (removeIndex < 0) {
            return -1;
        }
        this.nodes.splice(removeIndex, 1);
        return removeIndex;
    },

    /**
     * @private
     */
    createTextNode: function(dom, startOffs, endOffs, parentNode) {
        var textLen = CUI.rte.Common.getNodeCharacterCnt(dom);
        if (textLen > 0) {
            var offset = 0;
            var charCnt = textLen;
            if (startOffs != null) {
                offset = startOffs;
                charCnt -= startOffs;
            }
            if (endOffs != null) {
                charCnt -= (textLen - endOffs);
            }
            // there are situations where charCnt can get invalid (when selecting the
            // [virtual] character "behind" an edit block), which we have to correct to
            // a charCnt inside the boundaries of the node
            if ((offset + charCnt) > textLen) {
                charCnt = textLen - offset;
            }
            var textNode = new CUI.rte.DomProcessor.TextNode(dom, offset, charCnt);
            if (!parentNode) {
                this.addChildNode(textNode, this);
            } else {
                parentNode.addChildNode(textNode, this);
            }
        }
    },

    /**
     * @private
     */
    createStructuralNode: function(dom, parentNode) {
        var strucNode = new CUI.rte.DomProcessor.StructuralNode(dom);
        if (!parentNode) {
            this.addChildNode(strucNode, this);
        } else {
            parentNode.addChildNode(strucNode, this);
        }
        return strucNode;
    },

    /**
     * @private
     */
    createAncestors: function(context, node, startOffs, endOffs) {
        var com = CUI.rte.Common;
        var isInitialNodeSkipped = com.isOneCharacterNode(node) && (startOffs == 0);
        var addNode = !isInitialNodeSkipped;
        var path = [ ];
        if (node == this.commonAncestor) {
            if (addNode) {
                path.push(node);
            }
        } else {
            do {
                if (addNode) {
                    path.push(node);
                } else {
                    addNode = true;
                }
                node = com.getParentNode(context, node);
            } while (node && (node != this.commonAncestor));
        }
        var parentNode = null;
        var pathCnt = path.length;
        var commonNode = null;
        for (var pathIndex = pathCnt - 1; pathIndex >= 0; pathIndex--) {
            var i;
            if (pathIndex == (pathCnt - 1)) {
                for (i = 0; i < this.nodes.length; i++) {
                    if (this.nodes[i].dom == path[pathIndex]) {
                        commonNode = this.nodes[i];
                        break;
                    }
                }
            } else if (commonNode) {
                var newCommonNode = null;
                for (i = 0; i < commonNode.childNodes.length; i++) {
                    if (commonNode.childNodes[i].dom == path[pathIndex]) {
                        newCommonNode = commonNode.childNodes[i];
                        break;
                    }
                }
                commonNode = newCommonNode;
            }
            if (!commonNode) {
                if (path[pathIndex].nodeType == 1) {
                    parentNode = this.createStructuralNode(path[pathIndex], parentNode);
                } else if (path[pathIndex].nodeType == 3) {
                    this.createTextNode(path[pathIndex], startOffs, endOffs, parentNode);
                }
            } else {
                parentNode = commonNode;
            }
        }
        return {
            "parentNode": parentNode,
            "isInitialNodeSkipped": isInitialNodeSkipped
        };
    },

    /**
     * @private
     */
    createList: function(context, selection) {
        var com = CUI.rte.Common;
        var startNode = selection.startNode;
        var endNode = selection.endNode;
        if (endNode == null) {
            endNode = startNode;
        }
        var startOffs = selection.startOffset;
        var endOffs = null;
        // build ancestor nodes
        var processingNode = selection.startNode;
        if (processingNode.nodeType == 3) {
            if (startNode == endNode) {
                if (selection.endOffset != null) {
                    endOffs = selection.endOffset + 1;
                } else {
                    endOffs = selection.startOffset;
                }
            }
        }
        var ancestorDef = this.createAncestors(context, processingNode, startOffs, endOffs);
        var parentNode = ancestorDef.parentNode;
        if (startNode == endNode) {
            return;
        }

        var isInitialNodeSkipped = ancestorDef.isInitialNodeSkipped;
        var isFirstNode = true;
        while (true) {
            // determine next node to process
            var children = processingNode.childNodes;
            if (children.length > 0) {
                processingNode = processingNode.firstChild;
            } else {
                if (!(isInitialNodeSkipped && isFirstNode)) {
                    if ((processingNode.nodeType == 1) && parentNode) {
                        parentNode = parentNode.parentNode;
                    }
                }
                if (processingNode.nextSibling) {
                    processingNode = processingNode.nextSibling;
                } else {
                    while (true) {
                        processingNode = com.getParentNode(context, processingNode);
                        parentNode = parentNode.parentNode;
                        if (!processingNode) {
                            break;
                        }
                        if (processingNode.nextSibling) {
                            processingNode = processingNode.nextSibling;
                            break;
                        }
                    }
                }
            }
            isFirstNode = false;
            // handle end node
            startOffs = null;
            endOffs = null;
            if (processingNode == endNode) {
                if (endNode.nodeType == 3) {
                    endOffs = selection.endOffset + 1;
                }
            }
            // add node
            if (processingNode.nodeType == 1) {
                parentNode = this.createStructuralNode(processingNode, parentNode);
            } else if (processingNode.nodeType == 3) {
                this.createTextNode(processingNode, startOffs, endOffs, parentNode);
            }
            // check for end condition
            if (processingNode == endNode) {
                break;
            }
        }
    },

    createFromDocument: function(context, selection) {
        var dpr = CUI.rte.DomProcessor;
        var sel = CUI.rte.Selection;
        this.nodes.length = 0;
        // corner case: invalid selection - may happen on IE while focus transfer
        if (!selection.startNode) {
            return selection;
        }
        // work on a copy of the processing selection, as it gets altered
        selection = {
            "startNode": selection.startNode,
            "startOffset": selection.startOffset,
            "endNode": selection.endNode,
            "endOffset": selection.endOffset,
            "isEOT": selection.isEOT
        };
        // Use normalized selection if we have a selection to ensure
        // start node does not point "behind" a node, but points to the
        // first actually included node. If the selection represents a caret,
        // we'll have to use the un-normalized selection, because the position
        // behind a node may have different impact than the position before
        // the succeeding node (for example, t|<b>ex</b>t will insert a
        // character in plaintext, whereas t<b>|ex</b>t will insert a bold
        // character.
        if (sel.shouldNormalizePSelForNodeList(context, selection)) {
            sel.normalizeProcessingSelection(context, selection);
        }
        // corner case: caret at end of the text will create an empty list
        if (selection.isEOT) {
            var children = context.root.childNodes;
            this.commonAncestor = children[children.length - 1];
            return selection;
        }
        // adjust end node to point to the last inclusive node
        selection = sel.adaptToInclusiveEndNode(context, selection);
        if ((selection.startNode == selection.endNode) || (selection.endNode == null)) {
            this.commonAncestor = selection.startNode.parentNode;
        } else {
            this.commonAncestor = dpr.getCommonAncestor(context, selection.startNode,
                    selection.endNode);
        }
        if (!this.commonAncestor) {
            throw new Error("No common ancestor found, cannot continue.");
        }
        this.createList(context, selection);
        return selection;
    },

    /**
     * @private
     */
    createDomChildren: function(dom, parentNode) {
        var children = dom.childNodes;
        for (var i = 0; i < children.length; i++) {
            var child = children[i];
            if (child.nodeType == 1) {
                var listNode = this.createStructuralNode(child, parentNode);
                this.createDomChildren(child, listNode);
            } else if (child.nodeType == 3) {
                this.createTextNode(child, null, null, parentNode);
            }
        }
    },

    createFromDomNodes: function(context, domNodes) {
        var dpr = CUI.rte.DomProcessor;
        this.commonAncestor = domNodes[0];
        var nodeCnt = domNodes.length;
        for (var i = 1; i < nodeCnt; i++) {
            if (!CUI.rte.Common.isAncestor(context, this.commonAncestor, domNodes[i])) {
                this.commonAncestor = dpr.getCommonAncestor(context, this.commonAncestor,
                        domNodes[i]);
            }
        }
        if (!this.commonAncestor) {
            throw new Error("No common ancestor found, cannot continue.");
        }
        for (i = 0; i < nodeCnt; i++) {
            var dom = domNodes[i];
            var ancestorDef = this.createAncestors(context, dom, null, null);
            this.createDomChildren(dom, ancestorDef.parentNode);
        }
    },

    /**
     * <p>Removes empty side-structures from the node list.</p>
     * <p>Side-structures are selection-leftovers, for example if a selection begins after
     * the last character of an editing block.</p>
     */
    removeEmptySideStructures: function() {
        var com = CUI.rte.Common;
        if (this.nodes.length > 0) {
            var nodeToCheck = this.nodes[0];
            if (nodeToCheck.isEmptySideStructure()) {
                this.nodes.splice(0, 1);
            }
            if (this.nodes.length > 0) {
                var nodeIndex = this.nodes.length - 1;
                nodeToCheck = this.nodes[nodeIndex];
                if (nodeToCheck.isEmptySideStructure()) {
                    this.nodes.splice(nodeIndex, 1);
                }
            }
            // adjust to new ancestor if possible
            while (this.nodes.length == 1) {
                var newCommonAncestor = this.nodes[0];
                if (!com.isCharacterNode(newCommonAncestor.dom)) {
                    this.commonAncestor = newCommonAncestor.dom;
                    this.nodes.length = 0;
                    if (newCommonAncestor.childNodes) {
                        var childCnt = newCommonAncestor.childNodes.length;
                        for (var c = 0; c < childCnt; c++) {
                            var childToMove = newCommonAncestor.childNodes[c];
                            childToMove.parentNode = null;
                            this.nodes.push(childToMove);
                        }
                    }
                } else {
                    break;
                }
            }
        }
    },

    hasContainers: function() {
        var nodeCnt = this.nodes.length;
        for (var nodeIndex = 0; nodeIndex < nodeCnt; nodeIndex++) {
            var nodeToProcess = this.nodes[nodeIndex];
            if (nodeToProcess.hasContainers()) {
                return true;
            }
        }
        return false;
    },

    isAligned: function(fn) {
        if (!fn) {
            fn = function(node) {
                return node.isAligned();
            };
        }
        var nodeCnt = this.nodes.length;
        for (var nodeIndex = 0; nodeIndex < nodeCnt; nodeIndex++) {
            var nodeToProcess = this.nodes[nodeIndex];
            if (!fn(nodeToProcess)) {
                return false;
            }
        }
        return true;
    },

    /**
     * Creates a list of all edit blocks contained in the node list.
     * @param {CUI.rte.EditContext} context The edit context
     * @param {Boolean} considerAncestors True if ancestor nodes should also be considered
     *        if no edit blocks were found in the node list itself
     */
    getEditBlocksByAuxRoots: function(context, considerAncestors) {
        var com = CUI.rte.Common;
        var dpr = CUI.rte.DomProcessor;
        var nodeCnt = this.nodes.length;
        var b, editBlocks;
        var segmentedBlocks = [ ];
        var currentAuxRoot = null;
        for (var n = 0; n < nodeCnt; n++) {
            this.nodes[n].execRecursively(function(node) {
                var dom = node.dom;
                if (com.isTag(dom, dpr.AUXILIARY_ROOT_TAGS)) {
                    editBlocks = [ ];
                    segmentedBlocks.push(editBlocks);
                    editBlocks.push(dom);
                    currentAuxRoot = dom;
                } else if (com.isTag(dom, com.EDITBLOCK_TAGS)) {
                    var nodeAuxRoot = dpr.getAuxRootNode(context, dom);
                    if (nodeAuxRoot != currentAuxRoot) {
                        editBlocks = [ ];
                        segmentedBlocks.push(editBlocks);
                        currentAuxRoot = nodeAuxRoot;
                    }
                    editBlocks.push(dom);
                }
            });
        }
        if ((segmentedBlocks.length == 0) && considerAncestors) {
            var domToCheck = this.commonAncestor;
            while (domToCheck) {
                if (com.isTag(domToCheck, com.EDITBLOCK_TAGS)) {
                    segmentedBlocks.push([ domToCheck ]);
                    break;
                }
                domToCheck = com.getParentNode(context, domToCheck);
            }
        }
        for (b = segmentedBlocks.length - 1; b >= 0; b--) {
            var blocks = segmentedBlocks[b];
            var bl = blocks.length;
            if (bl == 0) {
                segmentedBlocks.splice(b, 1);
            } else if (com.isTag(blocks[0], dpr.AUXILIARY_ROOT_TAGS)) {
                if (bl > 1) {
                    blocks.splice(0, 1)
                } else if (dpr.hasEditBlocks(blocks[0])) {
                    segmentedBlocks.splice(b, 1);
                }
            }
        }
        return segmentedBlocks;
    },

    normalize: function() {
        var invalidatedNodes = [ ];
        var childCnt = this.nodes.length;
        for (var c = 0; c < childCnt; c++) {
            this.nodes[c].normalize(this, invalidatedNodes);
        }
        var removeCnt = invalidatedNodes.length;
        for (var r = 0; r < removeCnt; r++) {
            this.remove(invalidatedNodes[r]);
        }
    },

    /**
     * @private
     */
    createTopLevelDomNodes: function() {
        var domNodes = [ ];
        var nodeCnt = this.nodes.length;
        for (var nodeIndex = 0; nodeIndex < nodeCnt; nodeIndex++) {
            domNodes.push(this.nodes[nodeIndex].dom);
        }
        return domNodes;
    },

    /**
     * @private
     */
    getTopLevelNodeIndex: function(node) {
        var nodeCnt = this.nodes.length;
        for (var nodeIndex = 0; nodeIndex < nodeCnt; nodeIndex++) {
            var nodeToProcess = this.nodes[nodeIndex];
            if (nodeToProcess == node) {
                return nodeIndex;
            }
        }
        return -1;
    },

    /**
     * <p>"Surrounds" the node list (document range) with the given tag.</p>
     * <p>The method can handle the following use-cases ("|" marks the start/end of the
     * document range; surrounding tag is &lt;span class="test"&gt;:</p>
     * <ul>
     *   <li>Splitting simple text nodes: <i>Ex|amp|le</i> -&gt;
     *   <i>Ex&lt;span class="test"&gt;amp&lt;/span&gt;le</i></li>
     *   <li>Handling structural nodes (as "b", "i", "u", ...): <i>This |is
     *   &lt;b&gt;bold&lt;/b&gt;| text</i> -&gt; <i>This &lt;span class="test"&gt;i
     *   &lt;b&gt;bold&lt;/b&gt;&lt;/span&gt; text</i></li>
     *   <li>Handling container nodes (as "div", "p"): <i>|&lt;p&gt;Paragraph 1&lt;/p&gt;
     *   &lt;p&gt;Paragraph 2&lt;/p&gt;|</i> -&gt; <i>|&lt;p&gt;&lt;span class="test"&gt;
     *   Paragraph 1&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;span class="test"&gt;Paragraph 2
     *   &lt;/span&gt;&lt;/p&gt;|</i></li>
     * </ul>
     * <p>This method does not optimize the sub tree (for example, remove unnecessary nodes
     * that will be created if for example <i>|this is &lt;b&gt;bold&lt;/b&gt;|</i> is
     * surrounded by another "b" tag (the result would then be
     * <i>&lt;b&gt;this is &lt;b&gt;bold&lt;/b&gt;&lt;/b&gt;</i>).</p>
     * @param {CUI.rte.EditContext} context The edit context
     * @param {String} tag Name of tag the document range has to be surrounded with
     * @param {Object} attribs Table of attributes to be used with the surrounding tag
     * @return {Array} Array with all additionally created nodes
     */
    surround: function(context, tag, attribs) {
        var dpr = CUI.rte.DomProcessor;
        var com = CUI.rte.Common;
        var sel = CUI.rte.Selection;
        this.removeEmptySideStructures();
        this.nodesChanged.length = 0;
        var nodeCnt, nodeIndex;
        var nodesAdded = [ ];
        // normalize text nodes
        this.normalize();
        // if everything is "aligned" and there are no containers, we can simply
        // insert a new structure node in between the existing nodes
        var doComplexSurround = true;
        if (this.isAligned() && !this.hasContainers()) {
            var containerNode = dpr.restructureAsChild(context, this.commonAncestor,
                    this.createTopLevelDomNodes(), tag, attribs);
            var nodesToCopy = this.nodes;
            this.nodes = [ ];
            var parentNode = this.createStructuralNode(containerNode, null);
            this.nodes.push(parentNode);
            nodeCnt = nodesToCopy.length;
            for (nodeIndex = 0; nodeIndex < nodeCnt; nodeIndex++) {
                parentNode.addChildNode(nodesToCopy[nodeIndex], this);
            }
            this.nodesChanged.push(containerNode);
            doComplexSurround = false;
            nodesAdded.push(containerNode);
        }
        if (doComplexSurround) {
            // must do the surround node by node, unfortunately ...
            nodeCnt = this.nodes.length;
            var surroundingNode = null;
            for (nodeIndex = 0; nodeIndex < nodeCnt; nodeIndex++) {
                var nodeToSurround = this.nodes[nodeIndex];
                surroundingNode = nodeToSurround.surround(context, surroundingNode, tag,
                        attribs, nodesAdded);
            }
        }
        if (this.nodesChanged.length > 0) {
            var startNode = this.nodesChanged[0];
            var endNode = this.nodesChanged[this.nodesChanged.length - 1];
            if (startNode == endNode) {
                endNode = com.getLastChild(startNode);
            }
            var selection = dpr.removeDuplicateStructures(context, startNode, endNode);
            dpr.joinIdenticalStructures(context, selection.startNode, true);
            dpr.joinIdenticalStructures(context, selection.endNode, false);
            if (doComplexSurround) {
                // todo table cell selection cannot work this way, as selection is derived from changed nodes
                if (selection.cellSelection && selection.cellSelection.cells) {
                    this.createFromDomNodes(context, selection.cellSelection.cells);
                } else {
                    var normalizeNode = function(node, isStart) {
                        var offset = null;
                        if (com.isOneCharacterNode(node)) {
                            offset = (isStart ? null : 0);
                        } else if (node.nodeType == 3) {
                            offset = (isStart ? 0 : node.nodeValue.length);
                        } else if (node.nodeType == 1) {
                            var ftn = com.getFirstTextChild(node, true);
                            if (ftn) {
                                node = ftn;
                                offset = (isStart
                                        ? sel.getFirstSelectionOffset(context, ftn)
                                        : sel.getLastSelectionOffset(context, ftn, true));
                            }
                        }
                        return {
                            "node": node,
                            "offset": offset
                        };
                    };
                    var startDef = normalizeNode(selection.startNode, true);
                    selection.startNode = startDef.node;
                    selection.startOffset = startDef.offset;
                    var endDef = normalizeNode(selection.endNode, false);
                    selection.endNode = endDef.node;
                    selection.endOffset = endDef.offset;
                    this.createFromDocument(context, selection);
                }
            }
        }
        return nodesAdded;
    },

    removeUnnecessaryLinebreaks: function(context, processAncestors) {
        var ancestorContainer;
        var dpr = CUI.rte.DomProcessor;
        var com = CUI.rte.Common;
        if (processAncestors) {
            var dom = this.commonAncestor;
            while (dom) {
                if (dom.nodeType == 1) {
                    if (com.isRootNode(context, dom)) {
                        break;
                    }
                    if (dpr.getTagType(dom) == dpr.CONTAINER) {
                        ancestorContainer = dom;
                        break;
                    }
                }
                dom = com.getParentNode(context, dom);
            }
        }
        var nodeCnt = this.nodes.length;
        var nodesToRemove = [ ];
        for (var nodeIndex = 0; nodeIndex < nodeCnt; nodeIndex++) {
            var nodeToProcess = this.nodes[nodeIndex];
            if (nodeToProcess.nodeType == dpr.DOM_NODE) {
                nodeToProcess.getUnnecessaryLinebreaks(ancestorContainer, nodesToRemove);
            }
        }
        var removeCnt = nodesToRemove.length;
        for (var removeIndex = 0; removeIndex < removeCnt; removeIndex++) {
            var nodeToRemove = nodesToRemove[removeIndex];
            var parent = nodeToRemove.parentNode;
            parent = (parent ? parent : this);
            dpr.removeWithoutChildren(nodeToRemove.dom);
            parent.removeChildNode(nodeToRemove);
        }
    },

    /**
     * @private
     */
    getByDomRec: function(node, dom) {
        if (node.dom == dom) {
            return node;
        }
        if (node.childNodes) {
            var childCnt = node.childNodes.length;
            for (var c = 0; c < childCnt; c++) {
                var nodeFound = this.getByDomRec(node.childNodes[c], dom);
                if (nodeFound) {
                    return nodeFound;
                }
            }
        }
        return null;
    },

    getByDom: function(dom, isRecursive) {
        var nodeCnt = this.nodes.length;
        for (var n = 0; n < nodeCnt; n++) {
            var nodeToCheck = this.nodes[n];
            if (nodeToCheck.dom == dom) {
                return nodeToCheck;
            }
            if (isRecursive) {
                var nodeFound = this.getByDomRec(nodeToCheck, dom);
                if (nodeFound) {
                    return nodeFound;
                }
            }
        }
        return null;
    },

    contains: function(dom, isRecursive) {
        return (this.getByDom(dom, isRecursive) != null);
    },

    /**
     * @private
     */
    isolateNode: function(node, leftTarget, rightTarget) {
        var com = CUI.rte.Common;
        var childIndex = com.getChildIndex(node);
        var parent = node.parentNode;
        var childToMove, c;
        for (c = 0; c < childIndex; c++) {
            childToMove = parent.childNodes[0];
            parent.removeChild(childToMove);
            leftTarget.appendChild(childToMove);
        }
        var childCnt = parent.childNodes.length;
        for (c = childCnt - 1; c >= 1; c--) {
            childToMove = parent.childNodes[c];
            parent.removeChild(childToMove);
            rightTarget.insertBefore(childToMove, rightTarget.firstChild);
        }
    },

    /**
     * @private
     */
    handleAlignment: function(context, parentNodes) {
        var dpr = CUI.rte.DomProcessor;
        var parentLeft = parentNodes[1];
        var parentRight = parentNodes[2];
        // handle node list
        var childCnt = this.nodes.length;
        for (var c = 0; c < childCnt; c++) {
            var childToProcess = this.nodes[c];
            if (childToProcess.nodeType == dpr.TEXT_NODE) {
                // handle text nodes here
                childToProcess.split(context, parentLeft, parentRight);
            }
        }
    },

    /**
     * Removes all instances the specified element from the node list.
     * @param {CUI.rte.EditContext} context The edit context
     * @param {String} tag Name of the tag to be removed
     * @param {Object} attribs Attribute list; may be null
     * @param {Boolean} processAncestors True, if the node list's ancestor nodes should also
     *        be considered for removing
     */
    removeNodesByTag: function(context, tag, attribs, processAncestors) {
        var dpr = CUI.rte.DomProcessor;
        var com = CUI.rte.Common;
        // normalize text nodes
        this.normalize();
        var c, childCnt;
        var pNode = null;
        if (processAncestors) {
            // handle removals in ancestor nodes
            var nodeToProcess = this.commonAncestor;
            var path = [ ];
            var copy1, copy2, pNode1, pNode2;
            while (nodeToProcess) {
                var nodeParent = com.getParentNode(context, nodeToProcess);
                if (nodeToProcess.nodeType == 1) {
                    if (dpr.getTagType(nodeToProcess) == dpr.CONTAINER) {
                        break;
                    }
                    if (com.isTag(nodeToProcess, tag)
                            && (!attribs || com.hasAttributes(nodeToProcess, attribs))) {
                        pNode = nodeToProcess.parentNode;
                        pNode1 = nodeToProcess.cloneNode(false);
                        pNode.insertBefore(pNode1, nodeToProcess);
                        pNode2 = nodeToProcess.cloneNode(false);
                        pNode.insertBefore(pNode2, nodeToProcess.nextSibling);
                        pNode = nodeToProcess;
                        while (path.length > 0) {
                            pNode = path.pop();
                            this.isolateNode(pNode, pNode1, pNode2);
                            copy1 = pNode.cloneNode(false);
                            pNode1.appendChild(copy1);
                            pNode1 = copy1;
                            copy2 = pNode.cloneNode(false);
                            pNode2.insertBefore(copy2, pNode2.firstChild);
                            pNode2 = copy2;
                        }
                        this.handleAlignment(context, [ pNode, pNode1, pNode2]);
                        com.removeNodesWithoutContent(context, pNode1);
                        com.removeNodesWithoutContent(context, pNode2);
                        dpr.removeWithoutChildren(nodeToProcess);
                        break;
                    }
                    path.push(nodeToProcess);
                }
                nodeToProcess = nodeParent;
            }
        }
        // handle child removal
        childCnt = this.nodes.length;
        for (c = childCnt - 1; c >= 0; c--) {
            var childToProcess = this.nodes[c];
            if (childToProcess.nodeType == dpr.DOM_NODE) {
                childToProcess.removeNodesByTag(context, tag, attribs, this);
            }
        }
    },

    /**
     * Removes a node from the list and the DOM.
     * <p>
     * Child nodes are preserved.
     * @param {Node} node The node to be removed
     */
    remove: function(node) {
        var removeIndex = this.getTopLevelNodeIndex(node);
        if (removeIndex < 0) {
            node.parentNode.removeChild(node);
            return;
        }
        // DOM processing
        if (!node.isInvalidatedByNormalization) {
            CUI.rte.DomProcessor.removeWithoutChildren(node.dom);
        }
        // node list processing
        this.nodes.splice(removeIndex, 1);
        if (node.childNodes) {
            var childrenToMove = node.childNodes;
            var childCnt = childrenToMove.length;
            for (var childIndex = 0; childIndex < childCnt; childIndex++) {
                var childToMove = childrenToMove[childIndex];
                childToMove.parentNode = this;
                this.nodes.splice(removeIndex + childIndex, 0, childToMove);
            }
        }
    },

    getAnchors: function(context, anchors, checkAncestors) {
        var com = CUI.rte.Common;
        if (checkAncestors) {
            var nodeToCheck = this.commonAncestor;
            while (nodeToCheck) {
                if (nodeToCheck.nodeType == 1) {
                    if (com.isRootNode(context, nodeToCheck)) {
                        break;
                    }
                    var tagLC = nodeToCheck.tagName.toLowerCase();
                    if (tagLC == "a") {
                        if (com.isAttribDefined(nodeToCheck, "href")) {
                            var anchor = {
                                "dom": nodeToCheck,
                                "href": com.getAttribute(nodeToCheck, com.HREF_ATTRIB)
                                        || com.getAttribute(nodeToCheck, "href")
                            };
                            if (nodeToCheck.className) {
                                anchor["cssClass"] = nodeToCheck.className;
                            }
                            if (nodeToCheck.target) {
                                anchor["target"] = nodeToCheck.target;
                            }
                            anchors.push(anchor);
                        }
                    }
                }
                nodeToCheck = com.getParentNode(context, nodeToCheck);
            }
        }
        var nodeCnt = this.nodes.length;
        for (var nodeIndex = 0; nodeIndex < nodeCnt; nodeIndex++) {
            var nodeToProcess = this.nodes[nodeIndex];
            if (nodeToProcess.nodeType == CUI.rte.DomProcessor.DOM_NODE) {
                nodeToProcess.getAnchors(anchors);
            }
        }
    },

    getNamedAnchors: function(context, namedAnchors, checkAncestors) {
        var com = CUI.rte.Common;
        if (checkAncestors) {
            var nodeToCheck = this.commonAncestor;
            while (nodeToCheck) {
                if (nodeToCheck.nodeType == 1) {
                    if (com.isRootNode(context, nodeToCheck)) {
                        break;
                    }
                    var anchorDef = CUI.rte.DomProcessor.checkNamedAnchor(nodeToCheck);
                    if (anchorDef) {
                        namedAnchors.push(anchorDef);
                    }
                }
                nodeToCheck = com.getParentNode(context, nodeToCheck);
            }
        }
        var nodeCnt = this.nodes.length;
        for (var nodeIndex = 0; nodeIndex < nodeCnt; nodeIndex++) {
            var nodeToProcess = this.nodes[nodeIndex];
            if (nodeToProcess.nodeType == CUI.rte.DomProcessor.DOM_NODE) {
                nodeToProcess.getNamedAnchors(namedAnchors);
            }
        }
    },

    getStyles: function(context, stylesDef, checkAncestors) {
        var com = CUI.rte.Common;
        var styles = stylesDef.styles;
        if (!styles) {
            styles = [ ];
            stylesDef.styles = styles;
        }
        var hasParentStyle = false;
        if (checkAncestors) {
            var nodeToCheck = this.commonAncestor;
            while (nodeToCheck) {
                if (nodeToCheck.nodeType == 1) {
                    if (com.isRootNode(context, nodeToCheck)) {
                        break;
                    }
                    var tagLC = nodeToCheck.tagName.toLowerCase();
                    if (tagLC == "span") {
                        if (nodeToCheck.className) {
                            hasParentStyle = true;
                            styles.push({
                                "dom": nodeToCheck,
                                "className": nodeToCheck.className
                            });
                        }
                    }
                }
                nodeToCheck = com.getParentNode(context, nodeToCheck);
            }
        }
        var continuousStyle = null;
        var hasTopLevelText = false;
        var nodeCnt = this.nodes.length;
        for (var nodeIndex = 0; nodeIndex < nodeCnt; nodeIndex++) {
            var nodeToProcess = this.nodes[nodeIndex];
            if (nodeToProcess.nodeType == CUI.rte.DomProcessor.DOM_NODE) {
                var nodeState = nodeToProcess.getStyles(styles);
                continuousStyle = CUI.rte.NodeList.calcNewContState(
                        continuousStyle, nodeState);
            } else {
                hasTopLevelText = true;
            }
        }
        if (continuousStyle == null) {
            continuousStyle = "unstyled";
        }
        stylesDef.isContinuousStyle = (hasParentStyle && (continuousStyle == "unstyled"))
                || (!hasParentStyle && (continuousStyle == "single") && !hasTopLevelText);
    },

    containsTag: function(tagName) {
        tagName = tagName.toLowerCase();
        var nodeCnt = this.nodes.length;
        for (var nodeIndex = 0; nodeIndex < nodeCnt; nodeIndex++) {
            var nodeToProcess = this.nodes[nodeIndex];
            if (nodeToProcess.nodeType == CUI.rte.DomProcessor.DOM_NODE) {
                if (nodeToProcess.containsTag(tagName)) {
                    return true;
                }
            }
        }
        return false;
    },

    /**
     * @private
     */
    executeMatcherOnDom: function(dom, tagMatcher) {
        var com = CUI.rte.Common;
        var isMatching = false;
        var matcherCnt = tagMatcher.length;
        for (var matcherIndex = 0; matcherIndex < matcherCnt; matcherIndex++) {
            var matcher = tagMatcher[matcherIndex];
            if (matcher.extMatcher) {
                var result = matcher.extMatcher(dom);
                if (result.isMatching) {
                    isMatching = true;
                    break;
                }
            } else if (matcher.matcher) {
                if (matcher.matcher(dom)) {
                    isMatching = true;
                    break;
                }
            } else {
                if (com.matchesTagDef(dom, matcher)) {
                    isMatching = true;
                    break;
                }
            }
        }
        return isMatching;
    },

    /**
     * <p>Gets a list of all DOM nodes (contained in the node list) that are matched by the
     * specified tag matcher(s).</p>
     * <p>You can also include ancestor nodes that match the tag matcher to be included in
     * the results. If you are using this option, you can force the method to include only:
     * </p>
     * <ul>
     *   <li>Elements that are contained in the node list. If there are elements contained
     *     in the node list, the common ancestor is also checked and included if suitable
     *     (this is necessary for selections that contain a single item of a list + item(s)
     *     of a nested list, as the selection covers the text of that single item only, not
     *     the item itself).</li>
     *   <li>If no suitable elements are contained in the node list, take the first suitable
     *     ancestor element (if any).</li>
     * </ul>
     * <p>This behaviour is suitable for getting the most suitable, selected element(s)
     * inside nested structures; for example the actually selected cell(s) of a table or
     * item(s) of a list, rather than including all parent cells/list items.</p>
     * @param {CUI.rte.EditContext} context The edit context
     * @param {Object[]} tagMatcher Array of tag matchers to be applied
     * @param {Boolean} checkAncestors True, if suitable ancestor elements should also be
     *        included in the results
     * @param {Boolean} breakOnFound True, if the rules defined above should be used
     *        (= consider first suitable ancestor element *only* if the node list (incl.
     *        child nodes) doesn't contain a suitable element); is considered only if
     *        checkAncestors == true
     * @return {Object[]} Array with all matching tags (properties: nodeType, isAncestor,
     *         dom)
     */
    getTags: function(context, tagMatcher, checkAncestors, breakOnFound) {
        var dpr = CUI.rte.DomProcessor;
        var com = CUI.rte.Common;
        var tags = [ ];
        var nodeCnt = this.nodes.length;
        for (var nodeIndex = 0; nodeIndex < nodeCnt; nodeIndex++) {
            if (this.nodes[nodeIndex].nodeType == dpr.DOM_NODE) {
                this.nodes[nodeIndex].getTags(tagMatcher, tags);
            }
        }
        if (breakOnFound && (tags.length > 0)) {
            if (this.executeMatcherOnDom(this.commonAncestor, tagMatcher)) {
                tags.splice(0, 0, {
                    "nodeType": null,
                    "isAncestor": true,
                    "dom": this.commonAncestor
                });
            }
            return tags;
        }
        if (checkAncestors) {
            var dom = this.commonAncestor;
            while (dom) {
                if (this.executeMatcherOnDom(dom, tagMatcher)) {
                    tags.splice(0, 0, {
                        "nodeType": null,
                        "isAncestor": true,
                        "dom": dom
                    });
                    if (breakOnFound) {
                        return tags;
                    }
                }
                dom = com.getParentNode(context, dom);
            }
        }
        return tags;
    },

    hasContent: function() {
        var nodeCnt = this.nodes.length;
        for (var nodeIndex = 0; nodeIndex < nodeCnt; nodeIndex++) {
            if (this.nodes[nodeIndex].nodeType == CUI.rte.DomProcessor.TEXT_NODE) {
                return true;
            } else {
                if (this.nodes[nodeIndex].hasContent()) {
                    return true;
                }
            }
        }
        return false;
    },

    hasCharacterNodes: function() {
        var nodeCnt = this.nodes.length;
        for (var nodeIndex = 0; nodeIndex < nodeCnt; nodeIndex++) {
            if (this.nodes[nodeIndex].hasCharacterNodes()) {
                return true;
            }
        }
        return false;
    },

    /**
     * Gets the first node (deep) of the node list.
     * @return {CUI.rte.DomProcessor.TextNode|CUI.rte.DomProcessor.StructuralNode}
     *         The first node (deep) of the node list; null if the node list is empty
     */
    getFirstNode: function() {
        if (this.nodes.length == 0) {
            return null;
        }
        var node = this.nodes[0];
        while (node.nodeType == CUI.rte.DomProcessor.DOM_NODE) {
            if (!node.childNodes || (node.childNodes.length == 0)) {
                break;
            }
            node = node.childNodes[0];
        }
        return node;
    },

    /**
     * Gets the last node (deep) of the node list.
     * @return {CUI.rte.DomProcessor.TextNode|CUI.rte.DomProcessor.StructuralNode}
     *         The last node (deep) of the node list; null if the node list is empty
     */
    getLastNode: function() {
        var nodeCnt = this.nodes.length;
        if (nodeCnt == 0) {
            return null;
        }
        var node = this.nodes[nodeCnt - 1];
        while (node.nodeType == CUI.rte.DomProcessor.DOM_NODE) {
            if (!node.childNodes) {
                break;
            }
            var childCnt = node.childNodes.length;
            if (childCnt == 0) {
                break;
            }
            node = node.childNodes[childCnt - 1];
        }
        return node;
    },

    createDump: function() {
        var nodeCnt = this.nodes.length;
        var ancestorDef = "---";
        if (this.commonAncestor.nodeType == 1) {
            ancestorDef = this.commonAncestor.tagName;
        } else {
            ancestorDef = this.commonAncestor.nodeValue;
        }
        var dump = "Common ancestor: " + ancestorDef + "\n";
        dump += "Nodes in list: "
                + nodeCnt + "\n";
        for (var nodeIndex = 0; nodeIndex < nodeCnt; nodeIndex++) {
            var nodeToDump = this.nodes[nodeIndex];
            dump += nodeToDump.createDump() + "\n";
        }
        return dump;
    }

});


/**
 * @class CUI.rte.DomProcessor.TextNode
 * @private
 * This class represents a text node inside a node list.
 */
CUI.rte.DomProcessor.TextNode = new Class({

    toString: "TextNode",

    nodeType: CUI.rte.DomProcessor.TEXT_NODE,

    nodeList: null,

    parentNode: null,

    dom: null,

    startPos: 0,

    charCnt: 0,

    nodeLength: 0,

    /**
     * Flag if the node has been invalidated through text node normalization
     * @private
     * @type Boolean
     */
    isInvalidatedByNormalization: false,

    construct: function(dom, startPos, charCnt) {
        this.dom = dom;
        this.startPos = startPos;
        this.charCnt = charCnt;
        this.nodeLength = CUI.rte.Common.getNodeCharacterCnt(dom);
    },

    /**
     * Executes the specified function for the node and all child nodes.
     * @param {Function} fn The function to execute. Gets the node as parameter.
     */
    execRecursively: function(fn) {
        fn(this);
    },

    isStartAligned: function() {
        return (this.startPos == 0);
    },

    isEndAligned: function() {
        return ((this.startPos + this.charCnt) == this.nodeLength);
    },

    isAligned: function() {
        return this.isStartAligned() && this.isEndAligned();
    },

    hasContainers: function() {
        return false;
    },

    /**
     * Gets the actual text content that is included by this node (considering the
     * alignment of the node).
     * @return {String} The actual content of the node
     */
    getActualTextContent: function() {
        var nodeText = this.dom.nodeValue;
        if (this.startPos >= this.nodeLength) {
            return "";
        }
        return nodeText.substring(this.startPos, this.startPos + this.charCnt);
    },

    /**
     * Gets the text content of the underlying DOM text node that is <i>not</i> included
     * in this node.
     * @return {String} The excluded text content
     */
    getExcludedTextContent: function() {
        var nodeText = this.dom.nodeValue;
        if (this.startPos == 0) {
            return nodeText.substring(this.charCnt);
        }
        return nodeText.substring(0, this.startPos);
    },

    hasCharacterNodes: function() {
        return true;
    },

    isEmptySideStructure: function() {
        return (this.charCnt == 0);
    },

    normalize: function(nodeList, invalidatedNodes) {
        if (this.isInvalidatedByNormalization) {
            return;
        }
        var nodeInList;
        while (true) {
            var prevNode = this.dom.previousSibling;
            if (!prevNode || (prevNode.nodeType != 3)) {
                break;
            }
            this.dom.nodeValue = prevNode.nodeValue + this.dom.nodeValue;
            this.startPos += prevNode.nodeValue.length;
            nodeInList = nodeList.getByDom(prevNode, true);
            if (nodeInList) {
                if (this.startPos != 0) {
                    throw new Error(
                            "Trying to mormalize something that can't be normalized.");
                }
                this.startPos -= nodeInList.charCnt;
                this.charCnt += nodeInList.charCnt;
                nodeInList.isInvalidatedByNormalization = true;
                invalidatedNodes.push(nodeInList);
            }
            prevNode.parentNode.removeChild(prevNode);
            this.nodeLength = this.dom.nodeValue.length;
        }
        while (true) {
            var nextNode = this.dom.nextSibling;
            if (!nextNode || (nextNode.nodeType != 3)) {
                break;
            }
            this.dom.nodeValue += nextNode.nodeValue;
            nodeInList = nodeList.getByDom(nextNode, true);
            if (nodeInList) {
                if ((this.startPos + this.charCnt) < this.nodeLength) {
                    throw new Error(
                            "Trying to mormalize something that can't be normalized.");
                }
                this.charCnt += nodeInList.charCnt;
                nodeInList.isInvalidatedByNormalization = true;
                invalidatedNodes.push(nodeInList);
            }
            nextNode.parentNode.removeChild(nextNode);
            this.nodeLength = this.dom.nodeValue.length;
        }
    },

    /**
     * "Surrounds" the text node with a tag of the given name/attribute or adds the text
     * node to an existing "surrounding node" in a suitable way.
     * <p>
     * The method handles the possibly necessary splitting of the node accordingly.
     * @param {CUI.rte.EditContext} context The edit context
     * @param {Node} surroundingNode "surrounding node" to work on; <code>null</code> if no
     *                               "surrounding node" is yet existing
     * @param {String} tagName tag name of the "surrounding node" (if one has to be created)
     * @param {Object} attributes attributes of the "surrounding node" (if one has to be
     *                            created)
     * @return {Node} the "surrounding node" to continue working on
     */
    surround: function(context, surroundingNode, tagName, attributes) {
        var insertNode = this.dom;
        var splitNodeIndex = 0;
        var splitPoints = [ ];
        if (!this.isStartAligned()) {
            splitPoints.push(this.startPos);
            splitNodeIndex = 1;
        }
        if (!this.isEndAligned()) {
            splitPoints.push(this.startPos + this.charCnt);
        }
        if (splitPoints.length > 0) {
            // this.dom gets invalid here
            var splitNodes = CUI.rte.DomProcessor.splitTextNode(context, this.dom,
                    splitPoints);
            insertNode = splitNodes[splitNodeIndex];
        }
        if (surroundingNode != null) {
            insertNode.parentNode.removeChild(insertNode);
            surroundingNode.appendChild(insertNode);
        } else {
            surroundingNode = CUI.rte.DomProcessor.insertAsParent(context,
                    insertNode, tagName, attributes);
            this.nodeList.nodesChanged.push(surroundingNode);
        }
        this.dom = insertNode;
        this.nodeList.nodesChanged.push(insertNode);
        return surroundingNode;
    },

    /**
     * Creates a new DOM text node from the actual text of the node.
     * @param {CUI.rte.EditContext} context The edit context
     * @return {HTMLElement} The DOM text node
     */
    createNewTextNode: function(context) {
        return context.createTextNode(this.getActualTextContent());
    },

    split: function(context, outerLeft, outerRight) {
        var com = CUI.rte.Common;
        var nodeText = this.dom.nodeValue;
        if (!this.isAligned()) {
            this.dom.nodeValue = nodeText.substring(this.startPos,
                    this.startPos + this.charCnt);
            var textNode;
            if (!this.isStartAligned()) {
                textNode = context.createTextNode(nodeText.substring(0, this.startPos));
                com.addTextNode(textNode, outerLeft);
                // outerLeft.appendChild(textNode);
            }
            if (!this.isEndAligned()) {
                textNode = context.createTextNode(nodeText.substring(
                        this.startPos + this.charCnt, nodeText.length));
                com.addTextNode(textNode, outerRight);
                // outerRight.appendChild(textNode);
            }
            this.startPos = 0;
            this.charCnt = this.dom.nodeValue.length;
        }
    },

    createDump: function() {
        var content;
        var nodeText = this.dom.nodeValue;
        if (this.charCnt == 0) {
            if (this.startPos < (nodeText.length - 1)) {
                content = "(" + nodeText.substring(this.startPos, this.startPos + 1) + ")";
            } else {
                content = "(behind text)";
            }
        } else {
            content = nodeText.substring(this.startPos, this.startPos + this.charCnt);
        }
        content = content.replace(/ /g, "*");
        return "Text node (s:" + this.startPos + "/l:" + this.charCnt + "/tl:"
                + this.nodeLength + "): " + content;
    }

});

/**
 * @private
 * @static
 */
CUI.rte.NodeList.calcNewContState = function(state, stateToAdd) {
    if (state == null) {
        state = stateToAdd;
    } else if ((state == "unstyled") || (state == "single")) {
        if ((stateToAdd == "single") || (stateToAdd == "multiple")) {
            state = "multiple";
        } else if (state == "single" && (state == "unstyled")) {
            state = "multiple";
        }
    } else if (stateToAdd == "multiple") {
        state = "multiple";
    }
    return state;
};

/**
 * @class CUI.rte.DomProcessor.StructuralNode
 * @private
 * This class represents a structural node (= tag) inside a node list.
 */
CUI.rte.DomProcessor.StructuralNode = new Class({

    toString: "DomProcessor.StructuralNode",

    nodeType: CUI.rte.DomProcessor.DOM_NODE,

    parentNode: null,

    tagName: null,

    dom: null,

    nodeList: null,

    type: null,

    childNodes: null,

    /**
     * Flag if the node has been invalidated through text node normalization; is always
     * false for structural nodes
     * @private
     * @type Boolean
     */
    isInvalidatedByNormalization: false,

    construct: function(dom) {
        this.dom = dom;
        this.tagName = dom.tagName.toLowerCase();
        this.type = CUI.rte.DomProcessor.getTagType(dom);
    },

    /**
     * Executes the specified function for the node and all child nodes.
     * @param {Function} fn The function to execute. Gets the node as parameter. If it
     *        returns true, the recursion is cancelled for the sub-tree starting at this
     *        node
     */
    execRecursively: function(fn) {
        var breakRecursion = fn(this);
        if (this.childNodes && (breakRecursion !== true)) {
            var childCnt = this.childNodes.length;
            for (var c = 0; c < childCnt; c++) {
                this.childNodes[c].execRecursively(fn);
            }
        }
    },

    addChildNode: function(nodeToAdd, nodeList, index) {
        if (!this.childNodes) {
            this.childNodes = [ ];
        }
        nodeToAdd.parentNode = this;
        nodeToAdd.nodeList = nodeList;
        if (!index || (index >= this.childNodes.length)) {
            this.childNodes.push(nodeToAdd);
        } else {
            this.childNodes.splice(index, 0, nodeToAdd);
        }
    },

    removeChildNode: function(nodeToRemove) {
        var removeIndex = this.getChildIndex(nodeToRemove);
        if (removeIndex < 0) {
            return -1;
        }
        this.childNodes.splice(removeIndex, 1);
        if (this.childNodes.length == 0) {
            this.childNodes = null;
        }
        return removeIndex;
    },

    /**
     * @private
     */
    getActualParent: function() {
        return (this.parentNode ? this.parent : this.nodeList);
    },

    isStartAligned: function() {
        if (this.childNodes == null) {
            return true;
        }
        var childCnt = this.childNodes.length;
        for (var childIndex = 0; childIndex < childCnt; childIndex++) {
            var childToProcess = this.childNodes[childIndex];
            var isAligned = childToProcess.isStartAligned();
            if (!isAligned) {
                return false;
            }
        }
        return true;
    },

    isEndAligned: function() {
        if (this.childNodes == null) {
            return true;
        }
        var childCnt = this.childNodes.length;
        for (var childIndex = 0; childIndex < childCnt; childIndex++) {
            var childToProcess = this.childNodes[childIndex];
            var isAligned = childToProcess.isEndAligned();
            if (!isAligned) {
                return false;
            }
        }
        return true;
    },

    isAligned: function() {
        if (this.childNodes == null) {
            return true;
        }
        var childCnt = this.childNodes.length;
        for (var childIndex = 0; childIndex < childCnt; childIndex++) {
            var childToProcess = this.childNodes[childIndex];
            var isAligned = childToProcess.isAligned();
            if (!isAligned) {
                return false;
            }
        }
        return true;
    },

    hasContainers: function(excludeSelf) {
        var dpr = CUI.rte.DomProcessor;
        var isContainer;
        if (this.type == dpr.DYNAMIC) {
            isContainer = true;
            if (dpr.TYPE_TABLE.hasOwnProperty(this.tagName)) {
                var tagDef = dpr.TYPE_TABLE[this.tagName];
                if (tagDef && tagDef.getDynamicType) {
                    isContainer = (tagDef.getDynamicType(this.dom) == dpr.CONTAINER);
                }
            }
        } else {
            isContainer = (this.type == dpr.CONTAINER);
        }
        if ((excludeSelf !== true) && isContainer) {
            return true;
        }
        if (this.childNodes != null) {
            var childCnt = this.childNodes.length;
            for (var childIndex = 0; childIndex < childCnt; childIndex++) {
                if (this.childNodes[childIndex].hasContainers()) {
                    return true;
                }
            }
        }
        return false;
    },

    containsTag: function(tagName) {
        if (this.tagName == tagName) {
            return true;
        }
        if (this.childNodes) {
            var childCnt = this.childNodes.length;
            for (var childIndex = 0; childIndex < childCnt; childIndex++) {
                var childToProcess = this.childNodes[childIndex];
                if (childToProcess.nodeType == CUI.rte.DomProcessor.DOM_NODE) {
                    if (childToProcess.containsTag(tagName)) {
                        return true;
                    }
                }
            }
        }
        return false;
    },

    getTags: function(tagMatcher, tags) {
        var dpr = CUI.rte.DomProcessor;
        var com = CUI.rte.Common;
        var matcherCnt = tagMatcher.length;
        var preventSubTreeRecursion = false;
        for (var matcherIndex = 0; matcherIndex < matcherCnt; matcherIndex++) {
            var matcher = tagMatcher[matcherIndex];
            if (matcher.extMatcher) {
                var result = matcher.extMatcher(this.dom);
                if (result.isMatching) {
                    tags.push(this);
                    preventSubTreeRecursion = result.preventRecursionIfMatching;
                    break;
                }
                if (result.preventRecursion === true) {
                    preventSubTreeRecursion = true;
                }
            } else if (matcher.matcher) {
                if (matcher.matcher(this.dom)) {
                    tags.push(this);
                    break;
                }
            } else {
                if (com.matchesTagDef(this.dom, matcher)) {
                    tags.push(this);
                    break;
                }
            }
        }
        if (this.childNodes && !preventSubTreeRecursion) {
            var childCnt = this.childNodes.length;
            for (var childIndex = 0; childIndex < childCnt; childIndex++) {
                if (this.childNodes[childIndex].nodeType == dpr.DOM_NODE) {
                    this.childNodes[childIndex].getTags(tagMatcher, tags);
                }
            }
        }
        return tags;
    },

    normalize: function(nodeList, invalidatedNodes) {
        if (this.childNodes) {
            var childCnt = this.childNodes.length;
            for (var c = 0; c < childCnt; c++) {
                this.childNodes[c].normalize(nodeList, invalidatedNodes);
            }
        }
    },

    hasContent: function() {
        if (!this.childNodes) {
            return false;
        }
        var childCnt = this.childNodes.length;
        for (var childIndex = 0; childIndex < childCnt; childIndex++) {
            var childToProcess = this.childNodes[childIndex];
            if (childToProcess.nodeType == CUI.rte.DomProcessor.TEXT_NODE) {
                return true;
            } else {
                if (childToProcess.hasContent()) {
                    return true;
                }
            }
        }
        return false;
    },

    hasCharacterNodes: function() {
        var com = CUI.rte.Common;
        if (com.isCharacterNode(this.dom)) {
            return true;
        }
        if (this.childNodes != null) {
            var childCnt = this.childNodes.length;
            for (var c = 0; c < childCnt; c++) {
                if (this.childNodes[c].hasCharacterNodes()) {
                    return true;
                }
            }
        }
    },

    isEmptySideStructure: function(excludeSelf) {
        var com = CUI.rte.Common;
        if (!excludeSelf) {
            if (com.isCharacterNode(this.dom)) {
                return false;
            }
            if (com.isEmptyEditingBlock(this.dom)) {
                return false;
            }
        }
        if (this.childNodes != null) {
            var childCnt = this.childNodes.length;
            for (var c = 0; c < childCnt; c++) {
                if (!this.childNodes[c].isEmptySideStructure()) {
                    return false;
                }
            }
        }
        return true;
    },

    getAnchors: function(anchors) {
        var com = CUI.rte.Common;
        if ((this.tagName == "a") && !this.isEmptySideStructure(true)) {
            if (com.isAttribDefined(this.dom, "href")) {
                var anchor = {
                    "dom": this.dom,
                    "href": com.getAttribute(this.dom, com.HREF_ATTRIB)
                        || com.getAttribute(this.dom, "href")
                };
                if (this.dom.target) {
                    anchor["target"] = this.dom.target;
                }
                anchors.push(anchor);
            }
        }
        if (this.childNodes != null) {
            var childCnt = this.childNodes.length;
            for (var childIndex = 0; childIndex < childCnt; childIndex++) {
                var childToProcess = this.childNodes[childIndex];
                if (childToProcess.nodeType == CUI.rte.DomProcessor.DOM_NODE) {
                    childToProcess.getAnchors(anchors);
                }
            }
        }
    },

    getNamedAnchors: function(anchors) {
        var anchorDef = CUI.rte.DomProcessor.checkNamedAnchor(this.dom);
        if (anchorDef) {
            anchors.push(anchorDef);
        }
        if (this.childNodes != null) {
            var childCnt = this.childNodes.length;
            for (var childIndex = 0; childIndex < childCnt; childIndex++) {
                var childToProcess = this.childNodes[childIndex];
                if (childToProcess.nodeType == CUI.rte.DomProcessor.DOM_NODE) {
                    childToProcess.getNamedAnchors(anchors);
                }
            }
        }
    },

    getStyles: function(styles) {
        var continuousState = "unstyled";
        if (this.tagName == "span") {
            if (this.dom.className) {
                styles.push({
                    "dom": this.dom,
                    "className": this.dom.className
                });
                continuousState = "single";
            }
        }
        if (this.childNodes != null) {
            var hasText = false;
            var childrenState = null;
            var childCnt = this.childNodes.length;
            for (var childIndex = 0; childIndex < childCnt; childIndex++) {
                var childToProcess = this.childNodes[childIndex];
                if (childToProcess.nodeType == CUI.rte.DomProcessor.DOM_NODE) {
                    var childState = childToProcess.getStyles(styles);
                    childrenState = CUI.rte.NodeList.calcNewContState(childrenState,
                            childState);
                } else {
                    hasText = true;
                }
            }
            if (childrenState == null) {
                childrenState = "unstyled";
            }
            if (continuousState == "unstyled") {
                if (childrenState != "unstyled") {
                    continuousState = (hasText ? "multiple" : childrenState);
                }
            } else {
                continuousState = (childrenState == "unstyled" ? continuousState
                        : "multiple");
            }
        }
        return continuousState;
    },

    /**
     * @private
     */
    createChildDomNodes: function() {
        var nodes = [ ];
        if (this.childNodes == null) {
            return nodes;
        }
        var childCnt = this.childNodes.length;
        for (var childIndex = 0; childIndex < childCnt; childIndex++) {
            nodes.push(this.childNodes[childIndex].dom);
        }
        return nodes;
    },

    /**
     * @private
     */
    addChangedNodes: function(root) {
        this.nodeList.nodesChanged.push(root);
        if (root.nodeType == 1) {
            var childCnt = root.childNodes.length;
            for (var childIndex = 0; childIndex < childCnt; childIndex++) {
                this.addChangedNodes(root.childNodes[childIndex]);
            }
        }
    },

    /**
     * Implementation of <code>surround()</code> for structural nodes.
     * @private
     */
    surroundStructure: function(context, surroundingNode, tag, attribs, nodesAdded,
                                config) {
        var dpr = CUI.rte.DomProcessor;
        var isApplicable = true;
        if (config && config.isApplicable) {
            isApplicable = config.isApplicable(this.dom, tag, attribs);
        }
        if (!isApplicable) {
            return null;
        }
        if (this.isAligned()) {
            // if the whole structure is aligned, we can just change the structure
            if (surroundingNode != null) {
                this.dom.parentNode.removeChild(this.dom);
                surroundingNode.appendChild(this.dom);
                this.nodeList.nodesChanged.push(this.dom);
            } else {
                surroundingNode = dpr.insertAsParent(context, this.dom, tag, attribs);
                nodesAdded.push(surroundingNode);
                this.nodeList.nodesChanged.push(surroundingNode);
                this.nodeList.nodesChanged.push(this.dom);
            }
        } else {
            // if the structure is unaligned, we'll have to process the "left" and "right"
            // subtrees accordingly
            var subtreeToMove;
            if (!this.isStartAligned()) {
                // console.log("processLeftSubtree");
                subtreeToMove = this.processLeftSubtree(context);
                surroundingNode = dpr.createNode(context, tag, attribs);
                nodesAdded.push(surroundingNode);
                surroundingNode.appendChild(subtreeToMove);
                this.dom.parentNode.insertBefore(surroundingNode, this.dom.nextSibling);
                this.addChangedNodes(surroundingNode);
            }
            if (!this.isEndAligned()) {
                // console.log("processRightSubtree");
                subtreeToMove = this.processRightSubtree(context);
                surroundingNode.appendChild(subtreeToMove);
                this.addChangedNodes(subtreeToMove);
            }
        }
        return surroundingNode;
    },

    /**
     * Implementation of <code>surround()</code> for container nodes.
     * @private
     */
    surroundContainer: function(context, surroundingNode, tag, attribs, nodesAdded,
                                config) {
        var dpr = CUI.rte.DomProcessor;
        var isApplicable = true;
        if (config && config.isApplicable) {
            isApplicable = config.isApplicable(this.dom, tag, attribs);
        }
        if (!isApplicable) {
            return null;
        }
        if (this.childNodes == null) {
            return surroundingNode;
        }
        if (this.isAligned()) {
            if (!this.hasContainers(true)) {
                // if the whole structure is aligned, we can just change the structure
                var childNodes = this.createChildDomNodes();
                var nodeAdded = dpr.restructureAsChild(context, this.dom, childNodes, tag,
                        attribs);
                nodesAdded.push(nodeAdded);
                this.addChangedNodes(nodeAdded);
            } else {
                if (this.childNodes != null) {
                    var childCnt = this.childNodes.length;
                    for (var childIndex = 0; childIndex < childCnt; childIndex++) {
                        var childToProcess = this.childNodes[childIndex];
                        childToProcess.surround(context, surroundingNode, tag, attribs,
                                nodesAdded);
                    }
                }
            }
        } else {
            surroundingNode = dpr.createNode(context, tag, attribs);
            nodesAdded.push(surroundingNode);
            // if the structure is unaligned, we'll have to process the "left" and "right"
            // subtrees accordingly
            if (!this.isStartAligned()) {
                this.processLeftContainerSubtree(context, surroundingNode, true);
                this.dom.appendChild(surroundingNode);
            }
            if (!this.isEndAligned()) {
                this.processRightContainerSubtree(context, surroundingNode, true);
                this.dom.insertBefore(surroundingNode, this.dom.firstChild);
            }
            this.addChangedNodes(surroundingNode);
        }
        return null;
    },

    /**
     * "Surrounds" the structural node (and all of its successor nodes) with a tag of the
     * given name/attribute or adds the represented structure to an existing "surrounding
     * node" in a suitable way.
     * <p>
     * The method handles the possibly necessary splitting of text nodes accordingly.
     * @param {CUI.rte.EditContext} context The edit context
     * @param {Node} surroundingNode "surrounding node" to work on; <code>null</code> if no
     *                               "surrounding node" is yet existing
     * @param {String} tag tag name of the "surrounding node" (if one has to be created)
     * @param {Object} attribs attributes of the "surrounding node" (if one has to be
     *                         created)
     * @param {Array} nodesAdded Array where all newly created nodes are recorded to
     * @return {Node} the "surrounding node" to continue working on
     */
    surround: function(context, surroundingNode, tag, attribs, nodesAdded) {
        var dpr = CUI.rte.DomProcessor;
        switch (this.type) {
            case dpr.STRUCTURE:
                surroundingNode = this.surroundStructure(context, surroundingNode, tag,
                        attribs, nodesAdded);
                break;
            case dpr.CONTAINER:
                surroundingNode = this.surroundContainer(context, surroundingNode, tag,
                        attribs, nodesAdded);
                break;
            case dpr.DYNAMIC:
                var config = null;
                var containerTag = this.tagName;
                var typeTable = dpr.TYPE_TABLE;
                if (typeTable.hasOwnProperty(containerTag)) {
                    var tagDef = typeTable[containerTag];
                    if (typeof(tagDef) == "object") {
                        config = tagDef;
                    }
                }
                var isContainer = true;
                if (config && config.getDynamicType) {
                    isContainer = (config.getDynamicType(this.dom) == dpr.CONTAINER);
                }
                if (isContainer) {
                    surroundingNode = this.surroundContainer(context, surroundingNode, tag,
                            attribs, nodesAdded, config);
                } else {
                    surroundingNode = this.surroundStructure(context, surroundingNode, tag,
                            attribs, nodesAdded, config);
                }
                break;
            case dpr.IGNORE:
                if (this.childNodes) {
                    var childCnt = this.childNodes.length;
                    for (var childIndex = 0; childIndex < childCnt; childIndex++) {
                        var child = this.childNodes[childIndex];
                        if (child.nodeType == dpr.DOM_NODE) {
                            surroundingNode = child.surround(context, surroundingNode, tag,
                                    attribs, nodesAdded);
                        }
                    }
                }
                break;
        }
        return surroundingNode;
    },

    /**
     * This method does the necessary processing for surrounding structures that are
     * unaligned at the start ("left" subtree).
     * <p>
     * For example, <i>&lt;b&gt;Bold |text&lt;/b&gt; is great!|</i> has to be processed as
     * follows to preserve a valid tag nesting: <i>&lt;b&gt;Bold &lt;span class="test"&gt;
     * text&lt;/span&gt;&lt;/b&gt;&lt;span class="test"&gt; is great!&lt;/span&gt;</i>.
     * <p>
     * This method processes the initial "b" structure and:
     * <ul>
     * <li>Splits the "Bold text" DOM text node in two separate "Bold " and "text" nodes.
     * </li>
     * <li>Removes the "Bold text" DOM text node from the existing DOM tree and adds
     * the "Bold " text node instead.</li>
     * <li>Creates a copy of the DOM structure (the "b" node in this case).</li>
     * <li>Adds the "text" DOM text node to the copy of the "b" node).</li>
     * <li>Returns the copied DOM structure, including the split text node, so the caller
     * can use this for executing the surrounding operation.</li>
     * </ul>
     * @param {CUI.rte.EditContext} context The edit context
     * @param {HTMLElement} subTreeRoot (optional) root node to start with
     * @return {HTMLElement} the DOM subtree to be used for the surrounding operation
     */
    processLeftSubtree: function(context, subTreeRoot) {
        var dpr = CUI.rte.DomProcessor;
        var com = CUI.rte.Common;
        // we'll create a clone of the current node as part of the subtree that actually
        // gets surrounded
        var clonedNode = this.dom.cloneNode(false);
        if (!subTreeRoot) {
            subTreeRoot = clonedNode;
        } else {
            subTreeRoot.appendChild(clonedNode);
        }
        // process child nodes
        if (this.childNodes == null) {
            return subTreeRoot;
        }
        var childCnt = this.childNodes.length;
        for (var childIndex = 0; childIndex < childCnt; childIndex++) {
            var childToProcess = this.childNodes[childIndex];
            var nodeType = childToProcess.nodeType;
            if (nodeType == dpr.DOM_NODE) {
                var dom = childToProcess.dom;
                if (com.isOneCharacterNode(dom)) {
                    // br, img, etc.: move to cloned subtrees if included in node list;
                    // keep it otherwise
                    if (childToProcess.isAligned()) {
                        dom.parentNode.removeChild(dom);
                        clonedNode.appendChild(dom);
                    }
                } else {
                    childToProcess.processLeftSubtree(context, clonedNode);
                }
            } else if (nodeType == dpr.TEXT_NODE) {
                var childText = childToProcess.dom;
                if (childToProcess.isAligned()) {
                    // here we can handle the entire node "at once"
                    var removalParent = childText.parentNode;
                    removalParent.removeChild(childText);
                    com.removeNodesWithoutContent(context, removalParent);
                    com.addTextNode(childText, clonedNode);
                } else {
                    // here we must split the text node and assign one half to the
                    // sub tree that stays the same and the other one to the sub tree
                    // that gets actually surrounded
                    clonedNode.appendChild(childToProcess.createNewTextNode(context));
                    var overflowParent = childText.parentNode;  // == this.dom
                    var overflowRef = childText.nextSibling;
                    overflowParent.removeChild(childText);
                    if (childToProcess.startPos > 0) {
                        var overflowText = childToProcess.getExcludedTextContent();
                        com.addTextNode(context.createTextNode(overflowText),
                                overflowParent, overflowRef);
                    } else {
                        com.removeNodesWithoutContent(context, overflowParent);
                    }
                }
            }
        }
        return subTreeRoot;
    },

    /**
     * This method does the necessary processing for surrounding structures that are
     * unaligned at the end ("right" subtree).
     * <p>
     * For example, <i>Let's try |some &lt;i&gt;italic| text&lt;/i&gt;.</i> has to be
     * processed as follows to preserve a valid tag nesting: <i>Let's try
     * &lt;span class="test"&gt;some &lt;/span&gt;&lt;i&gt;&lt;span class="test"&gt;italic
     * &lt;/span&gt; text&lt;/i&gt;</i>.
     * <p>
     * This method processes the "i" structure at the end and:
     * <ul>
     * <li>Splits the "italic text" DOM text node in two separate "italic " and "text"
     * nodes.
     * </li>
     * <li>Removes the "italic text" DOM text node from the existing DOM tree and adds
     * the " text" text node instead.</li>
     * <li>Creates a copy of the DOM structure (the "i" node in this case).</li>
     * <li>Adds the "italic " DOM text node to the copy of the "i" node).</li>
     * <li>Returns the copied DOM structure, including the split text node, so the caller
     * can use this for executing the surrounding operation.</li>
     * </ul>
     * @param {CUI.rte.EditContext} context The edit context
     * @param {HTMLElement} subTreeRoot (optional) root node to start with
     * @return {HTMLElement} the DOM subtree to be used for the surrounding operation
     */
    processRightSubtree: function(context, subTreeRoot) {
        var dpr = CUI.rte.DomProcessor;
        var com = CUI.rte.Common;
        var clonedNode = this.dom.cloneNode(false);
        if (!subTreeRoot) {
            subTreeRoot = clonedNode;
        } else {
            subTreeRoot.appendChild(clonedNode);
        }
        // process child nodes
        if (this.childNodes == null) {
            return subTreeRoot;
        }
        var childCnt = this.childNodes.length;
        for (var childIndex = 0; childIndex < childCnt; childIndex++) {
            var childToProcess = this.childNodes[childIndex];
            var nodeType = childToProcess.nodeType;
            if (nodeType == dpr.DOM_NODE) {
                var dom = childToProcess.dom;
                if (com.isOneCharacterNode(dom)) {
                    // br, img, etc.: move to cloned subtrees if included in node list;
                    // keep it otherwise
                    if (childToProcess.isAligned()) {
                        dom.parentNode.removeChild(dom);
                        clonedNode.appendChild(dom);
                    }
                } else {
                    childToProcess.processRightSubtree(context, clonedNode);
                }
            } else if (nodeType == dpr.TEXT_NODE) {
                var childText = childToProcess.dom;
                if (childToProcess.isAligned()) {
                    var removalParent = childText.parentNode;
                    removalParent.removeChild(childText);
                    com.removeNodesWithoutContent(context, removalParent);
                    com.addTextNode(childText, clonedNode);
                } else {
                    clonedNode.appendChild(childToProcess.createNewTextNode(context));
                    var overflowParent = childText.parentNode;
                    var overflowRef = childText.nextSibling;
                    overflowParent.removeChild(childText);
                    var actualCharCnt = childToProcess.startPos + childToProcess.charCnt;
                    if (actualCharCnt < childToProcess.nodeLength) {
                        var overflowText = childToProcess.getExcludedTextContent();
                        com.addTextNode(context.createTextNode(overflowText),
                                overflowParent, overflowRef);
                    } else {
                        com.removeNodesWithoutContent(context, overflowParent);
                    }
                }
            }
        }
        return subTreeRoot;
    },

    /**
     * This method does the necessary processing for surrounding containers that are
     * unaligned at the start ("left" subtree).
     * <p>
     * This method works similar to <code>processLeftContainer()</code>, but is
     * adjusted to work with containers correctly (other move rules apply there).
     * @param {CUI.rte.EditContext} context The edit context
     * @param {HTMLElement} subTreeRoot root node to start with
     * @param {Boolean} skipContent True if the content of <code>this</code>
     *                              should be skipped, so only the content of child nodes
     *                              is getting processed
     */
    processLeftContainerSubtree: function(context, subTreeRoot, skipContent) {
        var dpr = CUI.rte.DomProcessor;
        var com = CUI.rte.Common;
        var baseNode;
        if (!skipContent) {
            if (this.isAligned()) {
                this.dom.parentNode.removeChild(this.dom);
                subTreeRoot.appendChild(this.dom);
                return;
            }
            baseNode = this.dom.cloneNode(false);
            subTreeRoot.appendChild(baseNode);
        } else {
            baseNode = subTreeRoot;
        }
        var childCnt = this.childNodes.length;
        for (var childIndex = 0; childIndex < childCnt; childIndex++) {
            var childToProcess = this.childNodes[childIndex];
            var nodeType = childToProcess.nodeType;
            if (nodeType == dpr.DOM_NODE) {
                childToProcess.processLeftContainerSubtree(context, baseNode);
            } else if (nodeType == dpr.TEXT_NODE) {
                var childText = childToProcess.dom;
                if (childToProcess.isAligned()) {
                    var removalParent = childText.parentNode;
                    removalParent.removeChild(childText);
                    com.removeNodesWithoutContent(context, removalParent);
                    com.addTextNode(childText, baseNode);
                } else {
                    baseNode.appendChild(childToProcess.createNewTextNode(context));
                    var overflowParent = childText.parentNode;
                    overflowParent.removeChild(childText);
                    if (childToProcess.startPos > 0) {
                        var overflowText = childText.nodeValue.substring(0,
                                childToProcess.startPos);
                        com.addTextNode(context.createTextNode(overflowText),
                                overflowParent);
                    } else {
                        com.removeNodesWithoutContent(context, overflowParent);
                    }
                }
            }
        }
    },

    /**
     * This method does the necessary processing for surrounding containers that are
     * unaligned at the end ("right" subtree).
     * <p>
     * This method works similar to <code>processRightContainer()</code>, but is
     * adjusted to work with containers correctly (other move rules apply there).
     * @param {CUI.rte.EditContext} context The edit context
     * @param {HTMLElement} subTreeRoot root node to start with
     * @param {Boolean} skipContent True if the content of <code>this</code>
     *                              should be skipped, so only the content of child nodes
     *                              is getting processed
     */
    processRightContainerSubtree: function(context, subTreeRoot, skipContent) {
        var dpr = CUI.rte.DomProcessor;
        var com = CUI.rte.Common;
        var baseNode;
        if (!skipContent) {
            if (this.isAligned()) {
                this.dom.parentNode.removeChild(this.dom);
                subTreeRoot.appendChild(this.dom);
                return;
            }
            baseNode = this.dom.cloneNode(false);
            subTreeRoot.appendChild(baseNode);
        } else {
            baseNode = subTreeRoot;
        }
        var childCnt = this.childNodes.length;
        for (var childIndex = 0; childIndex < childCnt; childIndex++) {
            var childToProcess = this.childNodes[childIndex];
            var nodeType = childToProcess.nodeType;
            if (nodeType == dpr.DOM_NODE) {
                childToProcess.processRightContainerSubtree(context, baseNode);
            } else if (nodeType == dpr.TEXT_NODE) {
                var childText = childToProcess.dom;
                if (childToProcess.isAligned()) {
                    var removalParent = childText.parentNode;
                    removalParent.removeChild(childText);
                    com.removeNodesWithoutContent(context, removalParent);
                    com.addTextNode(childText, baseNode);
                } else {
                    baseNode.appendChild(childToProcess.createNewTextNode(context));
                    var overflowParent = childText.parentNode;
                    overflowParent.removeChild(childText);
                    var actualCharCnt = childToProcess.startPos + childToProcess.charCnt;
                    if (actualCharCnt < childToProcess.nodeLength) {
                        var overflowText = childText.nodeValue.substring(
                                actualCharCnt, childToProcess.nodeLength);
                        com.addTextNode(context.createTextNode(overflowText),
                                overflowParent, overflowParent.firstChild);
                    } else {
                        com.removeNodesWithoutContent(context, overflowParent);
                    }
                }
            }
        }
    },

    matches: function(tag, attribs) {
        var com = CUI.rte.Common;
        if (com.isTag(this.dom, tag)) {
            if (!attribs || com.hasAttributes(attribs)) {
                return true;
            }
        }
        return false;
    },

    removeNodesByTag: function(context, tag, attribs, nodeList) {
        var dpr = CUI.rte.DomProcessor;
        if (this.childNodes) {
            var childCnt = this.childNodes.length;
            for (var c = childCnt - 1; c >= 0; c--) {
                var childToProcess = this.childNodes[c];
                if (childToProcess.nodeType == dpr.DOM_NODE) {
                    childToProcess.removeNodesByTag(context, tag, attribs, nodeList);
                }
            }
        }
        if (this.matches(tag, attribs)) {
            var overflow;
            if (!this.isStartAligned()) {
                if (this.type == dpr.STRUCTURE) {
                    overflow = this.processLeftSubtree(context);
                    if (overflow) {
                        this.dom.parentNode.insertBefore(overflow, this.dom.nextSibling);
                        this.dom = overflow;
                    }
                }
            }
            if (!this.isEndAligned()) {
                if (this.type == dpr.STRUCTURE) {
                    overflow = this.processRightSubtree(context);
                    if (overflow) {
                        this.dom.parentNode.insertBefore(overflow, this.dom);
                        this.dom = overflow;
                    }
                }
            }
            nodeList.remove(this);
        }
    },

    getUnnecessaryLinebreaks: function(container, nodesToRemove) {
        var dpr = CUI.rte.DomProcessor;
        var com = CUI.rte.Common;
        if (this.tagName == "br") {
            // this node may potentially be removed if:
            // - there is a container node
            // - the linebreak is the last child node of this container
            if (container) {
                if (com.getLastChild(container) == this.dom) {
                    nodesToRemove.push(this);
                }
            }
        } else if (this.type == dpr.CONTAINER) {
            container = this.dom;
        }
        if (this.childNodes) {
            var childCnt = this.childNodes.length;
            for (var childIndex = 0; childIndex < childCnt; childIndex++) {
                var childToProcess = this.childNodes[childIndex];
                if (childToProcess.nodeType == dpr.DOM_NODE) {
                    childToProcess.getUnnecessaryLinebreaks(container, nodesToRemove);
                }
            }
        }
    },

    /**
     * @private
     */
    getChildIndex: function(node) {
        if (!this.childNodes) {
            return -1;
        }
        var childCnt = this.childNodes.length;
        for (var childIndex = 0; childIndex < childCnt; childIndex++) {
            var childToProcess = this.childNodes[childIndex];
            if (childToProcess == node) {
                return childIndex;
            }
        }
        return -1;
    },

    /**
     * @private
     */
    removeChild: function(childToRemove) {
        var childIndex, childCnt;
        if (this.childNodes) {
            var removeIndex = this.getChildIndex(childToRemove);
            if (removeIndex >= 0) {
                // DOM processing
                if (!childToRemove.isInvalidatedByNormalization) {
                    CUI.rte.DomProcessor.removeWithoutChildren(childToRemove.dom);
                }
                // node list processing
                this.childNodes.splice(removeIndex, 1);
                if (childToRemove.childNodes) {
                    var childrenToMove = childToRemove.childNodes;
                    childCnt = childrenToMove.length;
                    for (childIndex = 0; childIndex < childCnt; childIndex++) {
                        var childToMove = childrenToMove[childIndex];
                        childToMove.parentNode = this;
                        this.childNodes.splice(removeIndex + childIndex, 0, childToMove);
                    }
                }
            }
        }
    },

    createDump: function(indent) {
        if (!this.childNodes) {
            return "DOM node; tag name: " + this.tagName;
        } else {
            var indentStr = "";
            if (indent) {
                for (var spc = 0; spc < indent; spc++) {
                    indentStr += "   ";
                }
            } else {
                indent = 0;
            }
            var dump = "DOM node; tag name: " + this.tagName;
            indentStr += "   ";
            var childCnt = this.childNodes.length;
            for (var childIndex = 0; childIndex < childCnt; childIndex++) {
                var childToDump = this.childNodes[childIndex];
                dump += "\n" + indentStr + childToDump.createDump(indent + 1);
            }
            return dump;
        }
    }

});
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.Selection
 * @static
 * @private
 * <p>The RichText.Selection provides utility functions to handle
 * text selections/ranges in a browser-independent way.</p>
 * <p>Bookmarks provide means to persist selections even if the underlying DOM changes,
 * as they use character positions to determine the selection. Bookmarks are also
 * browser-independent - a given character position addresses the same DOM node/offset
 * on each browser platform.</p>
 * <p>Ranges/processing selections rely on the underlying DOM being persistent, as they use
 * nodes and offsets to address the actual text fragment.</p>
 * <p>Rules for calculating character positions:</p>
 * <ul>
 *   <li>There must be no "invisible" whitespace. Hence, no tabs and linefeeds must be
 *     present in the DOM at all!</li>
 *   <li>Each character of a text node is counted "as is".</li>
 *   <li>Several structural nodes (such as "br") are counted as a single character. These
 *     node types are defined by {@link CUI.rte.Common#ONE_CHARACTER_NODES}.</li>
 *   <li>At the end of each edit block ("p", "h1", ...), an additional character is added.
 *     Edit blocks are defined by {@link CUI.rte.Common#EDITBLOCK_TAGS}.</li>
 *   <li>Special attention should be put on nested structures: If there are paragraphs
 *     ("p") present in a table cell ("td"/"th"), two character positions are added
 *     after the last paragraph of that cell (one for the closing "p", the other for the
 *     closing "td"/"th").</li>
 *   <li>The end of the last cell of a nested table is counted as only one character (the
 *     closing "td"/"th" is only counted once, regardless of how much table cells get
 *     actually closed over the hierarchy).</li>
 * </ul>
 */
CUI.rte.Selection = function() {

    var com = CUI.rte.Common;

    var dpr = CUI.rte.DomProcessor;

    /**
     * Checks if the specified node definition is directly following up a DOM structure.
     * If so, the node definition is corrected to point behind the last character of that
     * structure (instead of pointing before the first character of the follow-up, which
     * is basically the same position, but described by a differend node/offset combination.
     * @param {CUI.rte.EditContext} context The edit context
     * @param {Object} nodeDef Node definition (will be adjusted accordingly)
     */
    var correctToPreviousStructure = function(context, nodeDef) {
        var node = nodeDef.node;
        var offs = nodeDef.offset;
        if (node && (offs == 0)) {
            // type: abc <b>def</b>| ghi -> abc <b>def|</b> ghi
            var prevSib = node.previousSibling;
            if (prevSib && (prevSib.nodeType == 1)) {
                if (com.getNodeCharacterCnt(prevSib) == 0) {
                    // no rule without an exception: don't correct if we'd enter a link
                    // (IE doesn't allow for that)
                    if (com.isTag(prevSib, "a") && com.isAttribDefined(prevSib, "href")) {
                        return;
                    }
                    node = com.getPreviousCharacterNode(context, node);
                    if (node) {
                        nodeDef.node = node;
                        nodeDef.offset = (node.nodeType == 3 ? node.nodeValue.length : 0);
                    }
                }
            }
            // type: <p>abc <b>|def</b> ghi -> <p>abc |<b>def</b> ghi
            else if (!prevSib && (offs == 0)) {
                node = com.getPreviousCharacterNode(context, node, com.EDITBLOCK_TAGS);
                if (node) {
                    nodeDef.node = node;
                    nodeDef.offset = (node.nodeType == 3 ? node.nodeValue.length : 0);
                }
            }
        }
    };

    /**
     * Adjusts, if necessary,  a node definition that references a structural node directly
     * to a pointer to its parent node + the child index of the originally referenced node.
     * This format is required by Gecko/Webkit to correctly handle selection on structural
     * nodes, such as "br" (which are handled as characters, but actually are structural
     * nodes).
     * @param {CUI.rte.EditContext} context The edit context
     * @param {Object} nodeDef Node definition (will be adjusted accordingly)
     */
    var adjustNodeAndOffsetToParent = function(context, nodeDef) {
        if ((nodeDef.node.nodeType == 1) && (nodeDef.offset == null)) {
            nodeDef.offset = com.getChildIndex(nodeDef.node);
            nodeDef.node = com.getParentNode(context, nodeDef.node);
        } else if ((nodeDef.offset == 0) && com.isTag(nodeDef.node, "a")
                && com.isAttribDefined(nodeDef.node, "name")) {
            // take special care for a name="" to prevent inserting into the anchor
            nodeDef.offset = com.getChildIndex(nodeDef.node) + 1;
            nodeDef.node = com.getParentNode(context, nodeDef.node);
        }
    };

    /**
     * Adjusts parent node and offset as required for setting a range on IE to a certain
     * position. IE got several problems regarding anchors that are handled using this
     * method.
     */
    var adjustParentNodeAndOffset = function(context, nodeDef) {
        var node = nodeDef.node;
        var processingOffset = 0;
        var correctingOffset = 0;
        while (node) {
            node = com.getNextNode(context, node);
            if (!node) {
                break;
            }
            // handle anchors
            if (com.isTag(node, "a") && com.isAttribDefined(node, "name")) {
                correctingOffset++;
            }
            processingOffset += com.getNodeCharacterCnt(node);
            if (processingOffset > nodeDef.offset) {
                break;
            }
        }
        nodeDef.offset += correctingOffset;
    };

    /**
     * Determines if the specified node is an anchor (a name).
     * @param {HTMLElement} node The node to check
     */
    var isAnchor = function(node) {
        return com.isTag(node, "a") && com.isAttribDefined(node, "name");
    };

    /**
     * Checks if the specified node is at the very end of a table cell. This is required
     * for IE to workaround an issue that handles the end of a table cell different from
     * the end of other blocks.
     */
    var isTableCellCorner = function(context, node) {
        while (node) {
            if (com.isTag(node, [ "td", "th" ])) {
                return true;
            }
            var pNode = node.parentNode;
            if (com.getChildIndex(node) != (pNode.childNodes.length - 1)) {
                return false;
            }
            node = com.getParentNode(context, node);
        }
        return false;
    };

    /**
     * Maps the specified node and offset to a character node and offset if possible and
     * necessary.
     */
    var mapToCharNodeEquiv = function(context, node, offset, isEndOfSelection) {
        var sel = CUI.rte.Selection;
        if (node == null) {
            return null;
        }
        var isEmptyBlock = false;
        if ((node.nodeType == 1) && !com.isOneCharacterNode(node)) {
            var children = node.childNodes;
            var childCnt = children.length;
            var ftn, ltn, fn, ln;
            if ((offset != null) && (offset < childCnt)) {
                var child = children[offset];
                ftn = com.getFirstTextChild(child, true);
                if (ftn) {
                    node = ftn;
                    offset = sel.getFirstSelectionOffset(context, ftn);
                } else if (com.isEmptyEditingBlock(child)) {
                    // for example, empty list items are handled here
                    node = child;
                    offset = null;
                    isEmptyBlock = true;
                } else {
                    fn = com.getFirstChild(node);
                    if (fn) {
                        node = fn;
                        offset = null;
                    }
                }
            } else {
                ltn = com.getLastTextChild(node, true);
                if (ltn) {
                    node = ltn;
                    offset = sel.getLastSelectionOffset(context, ltn, isEndOfSelection);
                } else {
                    ln = com.getLastChild(node);
                    if (ln) {
                        node = ln;
                        offset = null;
                    } else {
                        // empty top-level editing blocks (<p></p>, <h1></h1>, etc.)
                        isEmptyBlock = com.isEmptyEditingBlock(node);
                    }
                }
            }
            return {
                "node": node,
                "offset": offset,
                "isEmptyBlock": isEmptyBlock
            };
        }
        return null;
    };

    var sharedProps = {

        getScrollOffsets: function(context) {
            return {
                "scrollTop": context.root.scrollTop,
                "scrollLeft": context.root.scrollLeft
            };
        },

        setScrollOffsets: function(context, scrollingInfo) {
            if ((scrollingInfo.scrollTop !== undefined)
                    && (scrollingInfo.scrollLeft !== undefined)) {
                context.root.scrollTop = scrollingInfo.scrollTop;
                context.root.scrollLeft = scrollingInfo.scrollLeft;
            }
        },

        /**
         * @private
         */
        hasWhitespaceOnly: function(text) {
            var whitespaces = " \n\r\t";
            if (com.ua.isGecko) {
                whitespaces += String.fromCharCode(160);
            }
            var charCnt = text.length;
            for (var charPos = 0; charPos < charCnt; charPos++) {
                var charToCheck = text.charAt(charPos);
                if (whitespaces.indexOf(charToCheck) < 0) {
                    return false;
                }
            }
            return true;
        },

        bookmarkFromProcessingSelection: function(context, selection) {
            var com = CUI.rte.Common;
            selection = {
                "startNode": selection.startNode,
                "startOffset": selection.startOffset,
                "endNode": selection.endNode,
                "endOffset": selection.endOffset
            };
            CUI.rte.Selection.normalizeProcessingSelection(context, selection);
            var startPos = com.getCharacterOffsetForNode(context, selection.startNode);
            if (com.isOneCharacterNode(selection.startNode)) {
                if ((selection.startOffset != null) && (selection.startOffset === 0)) {
                    startPos++;
                }
            } else if (selection.startOffset) {
                startPos += selection.startOffset;
            }
            var endPos = startPos;
            if (selection.endNode) {
                endPos = com.getCharacterOffsetForNode(context, selection.endNode);
                if (com.isOneCharacterNode(selection.endNode)) {
                    if ((selection.endOffset != null) && (selection.endOffset === 0)) {
                        endPos++;
                    }
                } else if (selection.endOffset) {
                    endPos += selection.endOffset;
                }
            }
            // todo probably at least insertObject should be calculated correctly
            return {
                "startPos": startPos,
                "charCnt": (endPos - startPos),
                "object": null,
                "insertObject": null
            };
        },

        /**
         * Compares the specified bookmarks.
         * @param {Object} bookmark1 First bookmark to compare (as created by
         *        {@link CUI.rte.Selection#createSelectionBookmark})
         * @param {Object} bookmark2 Second bookmark to compare (as created by
         *        {@link CUI.rte.Selection#createSelectionBookmark})
         */
        compareBookmarks: function(bookmark1, bookmark2) {
            if (bookmark1 == null) {
                return (bookmark2 == null);
            }
            if (bookmark2 == null) {
                return false;
            }
            return (bookmark1.startPos == bookmark2.startPos)
                    && (bookmark1.charCnt == bookmark2.charCnt)
                    && (bookmark1.object == bookmark2.object)
                    && (bookmark1.insertObject == bookmark2.insertObject);
        },

        /**
         * @private
         */
        isLineDelimiter: function(dom) {
            if (dom.nodeType != 1) {
                return false;
            }
            var lineDelimiters = CUI.rte.Selection.LINE_DELIMITING_TAGS;
            var lineDelTagCnt = lineDelimiters.length;
            var tagName = dom.tagName.toLowerCase();
            for (var tagIndex = 0; tagIndex < lineDelTagCnt; tagIndex++) {
                if (lineDelimiters[tagIndex] == tagName) {
                    return true;
                }
            }
            return false;
        },

        /**
         * @private
         */
        getLineDelimiter: function(context, dom) {
            while (dom) {
                if (dom.nodeType == 1) {
                    if (CUI.rte.Selection.isLineDelimiter(dom)) {
                        return dom;
                    }
                }
                dom = com.getParentNode(context, dom);
            }
            return null;
        },

        /**
         * <p>Calculates the actual end node of a (processing) selection.</p>
         * <p>As processing selections contain a pointer to the first character/node that
         * is not actually included in the selection, this method is required if you need
         * a hold on the last item that is actually included in the selection.</p>
         * @param {Object} selection The selection as created by
         *        {@link CUI.rte.Selection#createProcessingSelection}
         * @return {Object} The adapted selections
         */
        adaptToInclusiveEndNode: function(context, selection) {
            var sel = CUI.rte.Selection;
            var adapted = {
                startNode: selection.startNode,
                startOffset: selection.startOffset
            };
            if (com.isRootNode(context, selection.startNode)
                    && (selection.startOffset == selection.startNode.childNodes.length)) {
                adapted.isEOT = true;
                return adapted;
            }
            var endNode = selection.endNode;
            var endOffset = selection.endOffset;
            if (endNode) {
                var moveAfterPrevCharNode = function() {
                    var pcn = com.getPreviousCharacterNode(context, endNode);
                    if (pcn) {
                        endNode = pcn;
                        endOffset = sel.getLastSelectionOffset(context, pcn, true);
                    }
                };
                if (com.isOneCharacterNode(endNode)) {
                    // one character, "structural" node
                    if (endOffset == 0) {
                        // selection ends after a "one character node" -> inclusive
                        // selection must contain the begin of the "one character node"
                        endOffset = null;
                    } else {
                        moveAfterPrevCharNode();
                    }
                } else if ((endNode.nodeType == 1)
                        && !com.isEmptyEditingBlock(endNode, true)) {
                    var ltn;
                    // other structural nodes
                    if ((endOffset == undefined)
                            || (endNode.childNodes.length == endOffset)) {
                        // EOB
                        ltn = com.getLastTextChild(endNode, true);
                        if (ltn) {
                            endNode = ltn;
                            endOffset = sel.getLastSelectionOffset(context, endNode, true);
                        } else {
                            // should not happen, as there should always be a character
                            // node
                            moveAfterPrevCharNode();
                        }
                    } else {
                        // directly pointing at (= before) a node
                        endNode = endNode.childNodes[endOffset];
                        endOffset = null;
                        ltn = com.getPreviousTextNode(context, endNode);
                        if (ltn) {
                            endNode = ltn;
                            endOffset = sel.getLastSelectionOffset(context, ltn, true);
                        }
                    }
                } else if (endNode.nodeType == 3) {
                    // text nodes
                    if (endOffset > 0) {
                        // adjusting inside a single text node
                        endOffset--;
                    } else {
                        // adjusting to previous character node; move over block borders
                        // must be handled as corner cases
                        moveAfterPrevCharNode();
                        var isBlockMove = (com.getNextCharacterNode(context, endNode,
                                com.EDITBLOCK_TAGS) == null);
                        if (!isBlockMove) {
                            if (com.isOneCharacterNode(endNode)) {
                                endOffset = null;
                            } else {
                                endOffset--;
                            }
                        }
                    }
                }
                // check for IE problem with empty blocks that might be between old
                // and new end node and must be taken instead
                var nodeToCheck = selection.endNode;
                if (nodeToCheck != endNode) {
                    // (don't consider end node itself!)
                    nodeToCheck = com.getPreviousNode(context, nodeToCheck);
                    while (nodeToCheck && (nodeToCheck != endNode)) {
                        if (com.isEmptyEditingBlock(nodeToCheck)) {
                            if ((selection.startNode == nodeToCheck)
                                    && (selection.startOffset == null)) {
                                endNode = null;
                            } else {
                                endNode = nodeToCheck;
                                endOffset = null;
                            }
                            break;
                        }
                        nodeToCheck = com.getPreviousNode(context, nodeToCheck);
                    }
                }
                if (endNode != null) {
                    adapted.endNode = endNode;
                    adapted.endOffset = endOffset;
                }
            }
            return adapted;
        },

        /**
         * <p>Expands the given selection to cover whole lines.</p>
         * <p>Multiline selections are handled correctly. Note that the trailing linefeed
         * (&lt;br&gt;) is included in the selection and has to be handled by the calling
         * method.</p>
         * @param {CUI.rte.EditContext} context The edit context
         * @param {Object} selection The selection to be expanded
         */
        expandToLineBorders: function(context, selection) {
            var isLineDelimiter = CUI.rte.Selection.isLineDelimiter;
            var getLineDelimiter = CUI.rte.Selection.getLineDelimiter;
            var prevNode, tagNameLC;
            var startNode = selection.startNode;
            var endNode = selection.endNode;
            if (endNode == null) {
                endNode = startNode;
            }
            // expand start
            var lineStartNode = getLineDelimiter(context, startNode);
            if (lineStartNode == null) {
                var checkStartNode = startNode;
                while (checkStartNode) {
                    do {
                        prevNode = checkStartNode;
                        checkStartNode = com.getPreviousNode(context, checkStartNode);
                        if (!checkStartNode) {
                            break;
                        }
                        if (com.isRootNode(context, checkStartNode)) {
                            checkStartNode = null;
                            break;
                        }
                        if (getLineDelimiter(context, checkStartNode) != null) {
                            checkStartNode = null;
                            break;
                        }
                    } while (checkStartNode.nodeType == 3);
                    if (!checkStartNode) {
                        lineStartNode = prevNode;
                        break;
                    }
                    tagNameLC = checkStartNode.tagName.toLowerCase();
                    if (tagNameLC == "br") {
                        lineStartNode = prevNode;
                        break;
                    }
                }
            }

            // expand end
            var lineEndNode = getLineDelimiter(context, endNode);
            if (lineEndNode == null) {
                // corner case: whole line (incl. trailing "br") is already selected -
                // then we already found our end node
                if ((endNode.nodeType == 1) && (endNode.tagName.toLowerCase() == "br")) {
                    // handle empty lines correctly
                    lineEndNode = endNode;
                } else {
                    var checkEndNode = endNode;
                    while (checkEndNode) {
                        do {
                            prevNode = checkEndNode;
                            checkEndNode = com.getNextNode(context, checkEndNode);
                            if (!checkEndNode) {
                                break;
                            }
                            if (com.isRootNode(context, checkEndNode)) {
                                checkEndNode = null;
                                break;
                            }
                        } while (checkEndNode.nodeType == 3);
                        if (!checkEndNode || isLineDelimiter(checkEndNode)) {
                            lineEndNode = prevNode;
                            break;
                        }
                        tagNameLC = checkEndNode.tagName.toLowerCase();
                        if (tagNameLC == "br") {
                            lineEndNode = checkEndNode;
                            break;
                        }
                    }
                }
            }
            // handle container tags with content
            if (isLineDelimiter(lineStartNode)) {
                if (lineStartNode.childNodes.length > 0) {
                    lineStartNode = lineStartNode.childNodes[0];
                }
            }
            if (isLineDelimiter(lineEndNode)) {
                if (lineEndNode.childNodes.length > 0) {
                    lineEndNode = com.getLastChild(lineEndNode);
                }
            }
            return {
                "startNode": lineStartNode,
                "startOffset": (lineStartNode.nodeType == 3 ? 0 : null),
                "endNode": lineEndNode,
                "endOffset": (lineEndNode && lineEndNode.nodeType == 3
                        ? com.getNodeCharacterCnt(lineEndNode) : null)
            };
        },

        isNoInsertNode: function(node) {
            if (node.nodeType == 3) {
                return false;
            }
            var tagList = CUI.rte.Selection.NO_INSERT_TAGS;
            for (var i = 0; i < tagList.length; i++) {
                var isMatching = com.matchesTagDef(node, tagList[i]);
                if (isMatching) {
                    return true;
                }
            }
            return false;
        },

        /**
         * <p>Checks if the specified processing selection is a selection of at least one
         * character.</p>
         * <p>If this method returns false, either an object (for example an image)
         * is selected or the selection currently represents the caret. Note that this
         * method returns true if table cells are selected.</p>
         * @param {Object} selection The processing selection to be analyzed (as created by
         *        {@link CUI.rte.Selection#createProcessingSelection})
         * @return {Boolean} True if the specified processing selection represents an
         *         actual text selection as described above
         */
        isSelection: function(selection) {
            return (selection.endNode != null) || (selection.cellSelection != null);
        },

        /**
         * <p>Gets a single object that is currently selected through the specified
         * processing selection.</p>
         * <p>Note that this method only returns a valid DOM object if it is the only
         * selected object and no text selection exists.</p>
         * @param {Object} selection The processing selection to be analyzed (as created by
         *        {@link CUI.rte.Selection#createProcessingSelection})
         * @return {HTMLElement} The solely selected DOM element; null if there is no such
         *         element selected
         */
        getSelectedDom: function(selection) {
            var selectedDom = null;
            if ((selection.startNode && (selection.startOffset == null))
                    && !selection.endNode) {
                selectedDom = selection.startNode;
            }
            return selectedDom;
        },

        /**
         * <p>Gets the first possible selectable offset for the specified node.</p>
         * <p>This is 0 for a text node and null for structural nodes.</p>
         * @param {CUI.rte.EditContext} context The edit context
         * @param {HTMLElement} node The node to check
         * @return {Number} The last possible selection offset for the specified node
         */
        getFirstSelectionOffset: function(context, node) {
            return (node.nodeType == 3 ? 0 : null);
        },

        /**
         * <p>Gets the last possible selectable offset for the specified node.</p>
         * <p>This is the length of a text node, null for structural nodes, 0 for
         * structural nodes that are representing a character (img, a name, br).</p>
         * @param {CUI.rte.EditContext} context The edit context
         * @param {HTMLElement} node The node to check
         * @param {Boolean} isEndOfSelection (optional) True if the last selection offset
         *        for the end of a selection should be determined. Due to limitations in a
         *        browser's implementation, the values might differ.
         * @return {Number} The last possible selection offset for the specified node
         */
        getLastSelectionOffset: function(context, node, isEndOfSelection) {
            if (node.nodeType == 3) {
                return node.nodeValue.length;
            }
            if (com.isOneCharacterNode(node)) {
                // Gecko cannot select "behind" a br at the end of a block
                if (com.ua.isGecko && com.isTag(node, "br") && !isEndOfSelection) {
                    var nextCharNode = com.getNextCharacterNode(context, node,
                            com.EDITBLOCK_TAGS);
                    if (nextCharNode == null) {
                        return null;
                    }
                }
                return 0;
            }
            return null;
        },

        /**
         * <p>Checks if the selection should be normalized before it is used for creating a
         * {@link CUI.rte.NodeList}).</p>
         * <p>A selection should be normalized if it represents a selection rather than
         * a caret and in some corner cases even if it is representing a caret (for example,
         * if it points behind a "br").</p>
         * @param {CUI.rte.EditContext} context The edit context
         * @param {Object} selection The processing selection to check
         */
        shouldNormalizePSelForNodeList: function(context, selection) {
            var sel = CUI.rte.Selection;
            if (sel.isSelection(selection)) {
                return true;
            }
            var startNode = selection.startNode;
            if (!startNode) {
                // Invalid start node might occur in several focus edge cases on IE -
                // simply ignore them
                return false;
            }
            var startOffset = selection.startOffset;
            if (com.isOneCharacterNode(startNode) && (startOffset == 0)) {
                // we should normalize if we are after the end of an object
                return true;
            }
            if ((startNode.nodeType == 3) && (startOffset >= startNode.nodeValue.length)) {
                // we should also normalize if we are after the end of a text node
                return true;
            }
            if (startNode.nodeType == 1) {
                // of course we must normalize EOT/EOB situations as well ...
                return true;
            }
            return false;
        },

        /**
         * <p>Checks if the selection should be normalized before using (for example for
         * analyzing a selection).</p>
         * <p>A selection should be normalized if it represents a selection rather than
         * a caret and in some corner cases even if it is representing a caret (for example,
         * if it represents an EOB/EOT situation).</p>
         * @param {CUI.rte.EditContext} context The edit context
         * @param {Object} selection The processing selection to check
         */
        shouldNormalizePSel: function(context, selection) {
            if (CUI.rte.Selection.isSelection(selection)) {
                return true;
            }
            var startNode = selection.startNode;
            if (startNode && (startNode.nodeType == 1) && !com.isOneCharacterNode(startNode)) {
                // we must normalize EOT/EOB situations as well ...
                return true;
            }
            return false;
        },

        /**
         * <p>Normalizes the specified processing selection as far as possible.</p>
         * <p>It is ensured that start and end node both point to character nodes as far
         * as it is somehow possible.</p>
         * @param {CUI.rte.EditContext} context The edit context
         * @param {Object} selection The processing selection to be normalized (will be
         *        modified directly)
         */
        normalizeProcessingSelection: function(context, selection) {
            var sel = CUI.rte.Selection;
            var startNode = selection.startNode;
            var startOffset = selection.startOffset;
            var endNode = selection.endNode;
            var endOffset = selection.endOffset;
            if (startNode) {
                // map structural nodes to their character node equivalent
                var startDef = mapToCharNodeEquiv(context, startNode, startOffset, false);
                if (startDef != null) {
                    startNode = startDef.node;
                    startOffset = startDef.offset;
                }
                var endDef = mapToCharNodeEquiv(context, endNode, endOffset, true);
                if (endDef != null) {
                    endNode = endDef.node;
                    endOffset = endDef.offset;
                }
                // adjust start node if it points behind a character node
                if (com.isCharacterNode(startNode)) {
                    var mustCorrect = false;
                    var isCollapsed = false;
                    if (com.isOneCharacterNode(startNode)) {
                        mustCorrect = (startOffset == 0);
                    } else {
                        mustCorrect = (startOffset >= startNode.nodeValue.length);
                        isCollapsed = (startNode == endNode) && (startOffset == endOffset);
                    }
                    if (mustCorrect) {
                        var ntn = com.getNextCharacterNode(context, startNode,
                                com.EDITBLOCK_TAGS);
                        if (ntn) {
                            startNode = ntn;
                            startOffset = sel.getFirstSelectionOffset(context, ntn);
                            if (!isCollapsed) {
                                isCollapsed = (startNode == endNode)
                                        && (startOffset == endOffset);
                            }
                            if (isCollapsed) {
                                endNode = null;
                                endOffset = null;
                            }
                        }
                    }
                }
                selection.startNode = startNode;
                selection.startOffset = startOffset;
                selection.endNode = endNode;
                selection.endOffset = endOffset;
            }
        },

        /**
         * @private
         */
        LINE_DELIMITING_TAGS: [
            "p", "li", "h1", "h2", "h3", "h4", "h5", "h6"
        ],

        NO_INSERT_TAGS: [ {
                "tagName": "a",
                "attribsDefined": [ "name" ],
                "attribsUndefined": [ "href" ]
            }, {
                "tagName": "img"
            }, {
                "tagName": "span",
                "empty": true
            }
        ],

        /**
         * This list contains tag definitions for DOM objects that are individual items
         * of a selection.
         */
        SELECTION_INCLUSION_TAGS: [ {
                "tagName": "a",
                "attribsDefined": [ "name" ],
                "attribsUndefined": [ "href" ]
            }
        ]

    };

    // create browser specific variant of the helper class (using merge
    // is safe during initialization)
    return CUI.rte.Utils.merge(sharedProps, com.ua.isOldIE ? {

        /**
         * @private
         */
        getRangePosition: function(context, range) {
            range.collapse(true);
            var node = range.parentElement();
            // workaround for another IE problem: caret may be positioned directly
            // before/after a table, which leads to several problems
            if (node == context.root) {
                if ((range.htmlText.length == 0) && (range.text.length == 0)) {
                    var tmpRange = range.duplicate();
                    if (tmpRange.move("character", 1) == 1) {
                        range = tmpRange;
                        node = range.parentElement();
                    }
                }
            }
            var childCnt = node.childNodes.length;
            var nodePos = com.getCharacterOffsetForNode(context, node);
            // as always, there is a special case: if we got an "a name" as parent
            // element, actually the character behind that anchor is addressed
            if (com.isTag(node, "a") && com.isAttribDefined(node, "name")) {
                return nodePos + 1;
            }
            // text selection
            var textRange = range.duplicate();
            textRange.moveToElementText(node);
            textRange.collapse(true);
            textRange.setEndPoint("StartToEnd", range);
            var nodeRef = 0;
            var tmpOffs = 0;
            for (var childIndex = 0; childIndex < childCnt; childIndex++) {
                var childToCheck = node.childNodes[childIndex];
                if (childToCheck.nodeType == 1) {
                    var correctingRange = textRange.duplicate();
                    correctingRange.moveToElementText(childToCheck);
                    correctingRange.collapse(false);
                    var cmp = (correctingRange.compareEndPoints("StartToStart", range));
                    if (cmp <= 0) {
                        nodeRef = childIndex + 1;
                        textRange.setEndPoint("StartToStart", correctingRange);
                        nodePos += tmpOffs;
                        if (cmp < 0) {
                            nodePos += com.getNodeTextLength(childToCheck);
                            tmpOffs = 0;
                        } else {
                            // there are cases where the range matches to the end of
                            // a non-character structure (for example at the end of a
                            // link, but not for "normal" structure tags as b, i, u, ...),
                            // hence this case covers these as well as "behind one-character
                            // structures" situations
                            nodePos += com.getNodeTextLength(childToCheck);
                            break;
                        }
                    } else {
                        break;
                    }
                } else {
                    tmpOffs += com.getNodeTextLength(childToCheck);
                }
            }
            var text = textRange.text.replace(/[\n\t\r]/g, "");
            nodePos += text.length;
            return nodePos;
        },

        /**
         * @private
         */
        setRangePosition: function(context, charPos, ensureEndPoint) {
            var sel = CUI.rte.Selection;
            var range = context.doc.selection.createRange();
            var nodeDef = com.getNodeAtPosition(context, charPos);
            if (nodeDef == null) {
                // EOT
                range.moveToElementText(context.root);
                range.collapse(false);
                return range;
            }
            if (nodeDef.isNodeSelection) {
                // a structural node is selected
                if (nodeDef.startOfElement || com.isEmptyEditingBlock(nodeDef.dom, true)) {
                    sel.setNodeToRange(context, range, nodeDef.dom, true);
                } else {
                    range.moveToElementText(nodeDef.dom);
                    range.collapse(false);
                    // EOB must "of course" be handled different, but beware of table
                    // cells and anchors ("a name") ... additionally, IPE adds some more
                    // complexity (must not correct the corrected selection if the
                    // parentElement already points to the context root)
                    var pNode = range.parentElement();
                    var checkRange = range.duplicate();
                    if (sel.isNoInsertNode(pNode)) {
                        range.move("character", -1);
                        range.move("character", 1);
                    } else if (!isTableCellCorner(context, pNode)
                            && (checkRange.move("character", 1) == 1)
                            && (checkRange.parentElement() != context.root)) {
                        range.move("character", -1);
                    }
                }
                return range;
            }
            var parentNode = nodeDef.parentDom;
            var parentOffset = nodeDef.parentOffset;
            if (!parentNode) {
                // handle end of text situation correctly
                var nodeBefore = nodeDef.nodeBefore;
                if (nodeBefore) {
                    if (nodeBefore.nodeType == 3) {
                        range.moveToElementText(nodeBefore.parentNode);
                    } else {
                        range.moveToElementText(nodeBefore);
                    }
                } else {
                    range.moveToElementText(context.root);
                }
                range.collapse(false);
                return range;
            }
            var requiresNestedListWorkaround = nodeDef.isUnregularNestedIssue;
            var nestedItem;
            if (requiresNestedListWorkaround) {
                nestedItem = nodeDef.nestedItemDom;
            }
            nodeDef = {
                "node": parentNode,
                "offset": parentOffset
            };
            adjustParentNodeAndOffset(context, nodeDef);
            sel.setNodeToRange(context, range, nodeDef.node, true);
            // There's another IE bug with standard-compliantly nested lists: The selection
            // may only be moved behind the last character of the list if the range is
            // collpsed. Found no workaround yet. It seems to work with non-collapsed
            // ranges, so we may create a range that can be used for setting the end point
            // of such a node
            if (requiresNestedListWorkaround) {
                range.moveToElementText(nestedItem);
                range.collapse(true);
                if (ensureEndPoint) {
                    range.move("character", -2);
                    range.moveEnd("character", 1);
                }
                return range;
            }
            if (nodeDef.offset > 0) {
                range.move("character", nodeDef.offset);
            }
            return range;
        },

        getSelection: function(context) {
            return context.doc.selection;
        },

        getLeadRange: function(context) {
            return context.doc.selection.createRange();
        },

        getCaretPos: function(context) {
            var range = context.doc.selection.createRange();
            return CUI.rte.Selection.getRangePosition(context, range);
        },

        setCaretPos: function(context, charPos) {
            var range = CUI.rte.Selection.setRangePosition(context, charPos);
            if (range) {
                range.select();
            }
        },

        createRange: function(context) {
            return context.doc.selection.createRange();
        },

        selectRange: function(context, rangeToSelect) {
            rangeToSelect.select();
        },

        createRangeBookmark: function(context) {
            return {
                "single": true,
                "bookmark": context.doc.selection.createRange()
            };
        },

        selectRangeBookmark: function(context, bookmark) {
            if (bookmark && bookmark.single && bookmark.bookmark) {
                bookmark.bookmark.select();
            }
        },

        getRangeTextContent: function(context, range) {
            return range.text;
        },

        createSelectionBookmark: function(context) {
            var sel = CUI.rte.Selection;
            var range = context.doc.selection.createRange();
            var selectionObject = null;
            var insertObject = null;
            var startPos, endPos;
            if (range.item) {
                selectionObject = range.item(0);
                startPos = com.getCharacterOffsetForNode(context, selectionObject);
                endPos = startPos;
            } else {
                var startRange = range.duplicate();
                startRange.collapse(true);
                startPos = sel.getRangePosition(context, startRange);
                var endRange = range.duplicate();
                endRange.collapse(false);
                endPos = sel.getRangePosition(context, endRange);
                if (startPos == endPos) {
                    var parentEl = range.parentElement();
                    if (parentEl) {
                        if (parentEl.childNodes.length == 0) {
                            insertObject = parentEl;
                            if (sel.isNoInsertNode(insertObject)) {
                                insertObject = null;
                            }
                        }
                    }
                }
            }
            return CUI.rte.Utils.apply({
                "startPos": startPos,
                "charCnt": (endPos - startPos),
                "object": selectionObject,
                "insertObject": insertObject
            }, sel.getScrollOffsets(context));
        },

        selectBookmark: function(context, bookmark) {
            var sel = CUI.rte.Selection;
            var objectToSelect = null;
            var isControlRange = false;
            if (bookmark.object) {
                objectToSelect = bookmark.object;
                isControlRange = true;
            } else if (bookmark.insertObject) {
                objectToSelect = bookmark.insertObject;
            }
            var range;
            if (objectToSelect) {
                try {
                    if (isControlRange) {
                        // todo check if correct
                        range = context.root.createControlRange();
                        range.addElement(objectToSelect);
                    } else {
                        range = context.doc.selection.createRange();
                        range.moveToElementText(objectToSelect);
                        range.collapse(true);
                    }
                } catch (e) {
                    // if the object is not available anymore (which might be the cause
                    // when undoing), use the caret-position instead
                    if (bookmark.startPos) {
                        objectToSelect = undefined;
                    }
                }
            }
            if (!objectToSelect) {
                range = sel.setRangePosition(context, bookmark.startPos);
                if (bookmark.charCnt > 0) {
                    // as IE selection module has a bug with correctly nested lists, we'll
                    // use the ensureEndPoint flag to ensure that the range has a valid end
                    // marker (but an invalid start marker, if the range is behind the
                    // last character of an item containing a nested list)
                    var endRange = sel.setRangePosition(context,
                            bookmark.startPos + bookmark.charCnt, true);
                    range.setEndPoint("EndToEnd", endRange);
                }
            }
            if (range) {
                range.select();
            }
            sel.setScrollOffsets(context, bookmark);
        },

        /**
         * Trims leading and trailing whitespace from the given range.
         * @param {CUI.rte.EditContext} context The edit context
         * @param {TextRange} range The range to trim
         * @return {TextRange} A range that has no more trailing and/or leading whitespace
         */
        trimRangeWhitespace: function(context, range) {
            var sel = CUI.rte.Selection;
            var checkRange, tempRange;
            // don't do anything on object selections
            if (range.item) {
                return range;
            }
            // leading whitespace
            checkRange = range.duplicate();
            checkRange.collapse(true);
            var leadingCharsToTrim = 0;
            while (true) {
                tempRange = checkRange.duplicate();
                tempRange.moveEnd("character", leadingCharsToTrim + 1);
                if (!sel.hasWhitespaceOnly(tempRange.text)) {
                    break;
                }
                leadingCharsToTrim++;
            }
            // trailing whitespace
            checkRange = range.duplicate();
            checkRange.collapse(false);
            var trailingCharsToTrim = 0;
            while (true) {
                tempRange = checkRange.duplicate();
                tempRange.moveStart("character", -(trailingCharsToTrim + 1));
                if (!sel.hasWhitespaceOnly(tempRange.text)) {
                    break;
                }
                trailingCharsToTrim++;
            }
            // change range if necessary
            tempRange = range.duplicate();
            if (leadingCharsToTrim > 0) {
                tempRange.moveStart("character", leadingCharsToTrim);
            }
            if (trailingCharsToTrim > 0) {
                tempRange.moveEnd("character", -trailingCharsToTrim);
            }
            if (tempRange.text.length > 0) {
                range = tempRange;
            }
            return range;
        },

        /**
         * @private
         */
        getRangeNodeAndOffset: function(context, range, isSelection, isBeginOfSel) {
            // workaround for another IE bug: if the range is reported to be in some
            // container tags as <a name="">, take the first character of the next text node
            // as selection anchor
            var com = CUI.rte.Common;
            var sel = CUI.rte.Selection;
            var offset;
            var parentNode = range.parentElement();
            var parentRoot = (com.isRootNode(context, parentNode) ? parentNode : null);
            if (sel.isNoInsertNode(parentNode)) {
                var actualBlockNode = com.getTagInPath(context, parentNode,
                        com.EDITBLOCK_TAGS);
                var isEOT = false;
                parentNode = com.getNextCharacterNode(context, parentNode);
                // handle EOT corner case (where we won't get a succeeding character node)
                if (!parentNode) {
                    parentNode = actualBlockNode;
                    isEOT = true;
                }
                offset = sel.getFirstSelectionOffset(context, parentNode);
                // Handle EOL corner case
                var blockNode = com.getTagInPath(context, parentNode, com.EDITBLOCK_TAGS);
                if (!isEOT && (blockNode != actualBlockNode)) {
                    parentNode = actualBlockNode;
                    offset = null;
                }
                return {
                    "dom": parentNode,
                    "offset": offset
                };
            }
            var editElRange = range.duplicate();
            editElRange.moveEnd("character", 1);
            var colEditElRange = editElRange.duplicate();
            colEditElRange.collapse(false);
            var colEditElParent = colEditElRange.parentElement();
            var checkRange = range.duplicate();
            var node = range.parentElement();
            checkRange.moveToElementText(node);
            checkRange.collapse(true);
            if (checkRange.move("character", 1) == 1) {
                checkRange.move("character", -1);
            }
            // check if the selection is a structural node by checking the bounds of each
            // structural child nodes against the destination range
            var elNode = null;
            var elOffset = null;
            var childCnt = node.childNodes.length;
            var isStartToStart = false;
            for (var childIndex = 0; childIndex < childCnt; childIndex++) {
                var childToProcess = node.childNodes[childIndex];
                if (childToProcess.nodeType == 1) {
                    var backupRange = checkRange.duplicate();
                    checkRange.moveToElementText(childToProcess);
                    var endRange = checkRange.duplicate();
                    checkRange.collapse(true);
                    endRange.collapse(false);
                    if (checkRange.compareEndPoints("StartToStart", editElRange) == 0) {
                        elNode = childToProcess;
                        isStartToStart = true;
                        break;
                    } else if (endRange.compareEndPoints("EndToEnd", editElRange) == 0) {
                        var checkPNode = checkRange.parentElement();
                        if (com.isTag(childToProcess, "img") && isAnchor(checkPNode)) {
                            // another lovely IE bug: if the last previous character node
                            // is a "a name", then a "img" at the begin of the succeeding
                            // block is reported as "EndToEnd", but has to be handled as
                            // "StartToStart"
                            var prevCharSibling = com.getPreviousCharacterNode(context,
                                    childToProcess, com.EDITBLOCK_TAGS);
                            if (prevCharSibling != checkPNode) {
                                isStartToStart = true;
                            }
                        }
                        elNode = childToProcess;
                        var ltn = com.getLastTextChild(elNode, true);
                        if (ltn) {
                            elNode = ltn;
                            elOffset = sel.getLastSelectionOffset(context, elNode,
                                    !isBeginOfSel);
                        }
                        break;
                    } else if (colEditElParent == childToProcess) {
                        if (com.isTag(colEditElParent, "table") && parentRoot) {
                            elNode = parentRoot;
                            elOffset = com.getChildIndex(colEditElParent);
                        } else {
                            elNode = childToProcess;
                        }
                        break;
                    }
                    var hasContent = com.hasTextChild(childToProcess);
                    if (com.isOneCharacterNode(childToProcess) || hasContent) {
                        checkRange.moveToElementText(childToProcess);
                        checkRange.collapse(false);
                    } else {
                        backupRange.move("character", 2);
                        checkRange = backupRange;
                    }
                }
            }
            if (!elNode) {
                // text selection - determine offset to the last directly selectable node
                var textRange = range.duplicate();
                textRange.moveToElementText(parentNode);
                textRange.collapse(true);
                textRange.setEndPoint("StartToEnd", range);
                var nodeRef = 0;
                for (childIndex = 0; childIndex < childCnt; childIndex++) {
                    var childToCheck = node.childNodes[childIndex];
                    if (childToCheck.nodeType == 1) {
                        var correctingRange = textRange.duplicate();
                        correctingRange.moveToElementText(childToCheck);
                        correctingRange.collapse(false);
                        var cmp = (correctingRange.compareEndPoints("StartToStart", range));
                        if (cmp < 0) {
                            nodeRef = childIndex + 1;
                            textRange.setEndPoint("StartToStart", correctingRange);
                        } else {
                            break;
                        }
                    }
                }
                var text = textRange.text.replace(/[\n\t\r]/g, "");
                var textLen = text.length;
                var offs = 0;
                for (childIndex = nodeRef; childIndex < childCnt; childIndex++) {
                    childToCheck = node.childNodes[childIndex];
                    var childLen = com.getNodeTextLength(childToCheck);
                    if ((offs + childLen) > textLen) {
                        elNode = childToCheck;
                        elOffset = textLen - offs;
                        break;
                    }
                    offs += childLen;
                }
            }
            // handle structural nodes correctly
            if (elNode && (elNode.nodeType == 1) && !com.isRootNode(context, elNode)) {
                if (!com.isOneCharacterNode(elNode)) {
                    // get first child node for structural nodes that may have content
                    var textNode = com.getFirstTextChild(elNode);
                    if (textNode) {
                        elNode = textNode;
                        elOffset = 0;
                    }
                } else if (com.isTag(elNode, "img")) {
                    // for images: adjust offset if we are handling the end of a selection
                    // to exclude the image
                    if (!isStartToStart) {
                        elOffset = 0;
                    }
                }
            }
            if (!elNode) {
                // element is not directly text-related; may be EOT or EOB/EOL
                if (parentRoot) {
                    // EOT
                    elNode = parentRoot;
                    elOffset = parentRoot.childNodes.length;
                } else {
                    elNode = com.getLastTextChild(parentNode, true);
                    // if range is between two nodes, prefer first character of succeeding
                    // node (if available) for the begin of a selection
                    if (elNode) {
                        if (isSelection && isBeginOfSel
                                && ((elNode.nodeType == 3) || com.isTag(elNode, "br"))) {
                            var nextTextNode = com.getNextCharacterNode(context, elNode,
                                    com.EDITBLOCK_TAGS);
                            if (nextTextNode) {
                                elNode = nextTextNode;
                                elOffset = sel.getFirstSelectionOffset(context, elNode);
                            } else {
                                elOffset = com.getNodeTextLength(elNode);
                            }
                        } else {
                            elOffset = sel.getLastSelectionOffset(context, elNode,
                                    !isBeginOfSel);
                        }
                    } else {
                        elNode = parentNode;
                    }
                }
            }
            return {
                "dom": elNode,
                "offset": elOffset
            };
        },

        createProcessingSelection: function(context) {
            var sel = CUI.rte.Selection;
            var range = context.doc.selection.createRange();
            if (range.item) {
                return {
                    "startNode": range.item(0)
                };
            }
            var startRange = range.duplicate();
            startRange.collapse(true);
            var endRange = range.duplicate();
            endRange.collapse(false);
            var startDef;
            var endDef = {
                "dom": null,
                "offset": null
            };
            if (startRange.compareEndPoints("StartToStart", endRange) == 0) {
                startDef = sel.getRangeNodeAndOffset(context, startRange, false);
            } else {
                startDef = sel.getRangeNodeAndOffset(context, startRange, true, true);
                endDef = sel.getRangeNodeAndOffset(context, endRange, true, false);
                // if an empty editing block is caught as end node, we'll have to move
                // further, as the editing block has to be included in the selection
                if (com.isEmptyEditingBlock(endDef.dom)) {
                    var nextNode = com.getNextNode(context, endDef.dom);
                    while (nextNode) {
                        var isSuitableNext = com.isEmptyEditingBlock(nextNode)
                                || com.isCharacterNode(nextNode);
                        if (isSuitableNext) {
                            break;
                        }
                        nextNode = com.getNextNode(context, nextNode);
                    }
                    if (!nextNode) {
                        // EOT situation
                        endDef.offset = com.getChildIndex(endDef.dom);
                        endDef.dom = com.getParentNode(context, endDef.dom);
                    } else {
                        endDef.dom = nextNode;
                        endDef.offset = sel.getFirstSelectionOffset(context, nextNode);
                    }
                }
            }
            if ((startDef.dom == endDef.dom) && (startDef.offset == endDef.offset)) {
                endDef.dom = null;
                endDef.offset = null;
            }
            // check if selection is actually valid (IE 8 sometimes returns invalid
            // selections!)
            if (!com.isAncestor(context, context.root, startDef.dom)) {
                return null;
            }
            return {
                "startNode": startDef.dom,
                "startOffset": startDef.offset,
                "endNode": endDef.dom,
                "endOffset": endDef.offset
            };
        },

        /**
         * @private
         */
        setNodeToRange: function(context, range, dom, asInsertPoint) {
            if (dom.nodeType == 3) {
                throw new Error("Cannot select text node");
            }
            try {
                // IE is extremely buggy here: collapse() alone does not work if a
                // paragraph gets selected and the last element of the previous paragraph
                // is an an anchor
                range.moveToElementText(dom);
                var pNode = range.parentElement();
                if (asInsertPoint) {
                    if (isAnchor(pNode)) {
                        range.collapse(true);
                        range.move("character", -1);
                        if (isAnchor(range.parentElement())) {
                            // even more nasty: if collapsing a paragraph to it's start and
                            // the preceding paragraph has an anchor as last object, the
                            // anchor of the preceding paragraph is selected instead ...
                            if (range.move("character", 2) == 2) {
                                range.move("character", -1);
                            }
                            // with multiple anchors directly following each other, things
                            // are getting nearly incredible nasty
                            if (isAnchor(range.parentElement())) {
                                range.move("character", -1);
                            }
                        } else {
                            // another kind of nastyness: the block has an object at its
                            // end and the preceding block has an object at its beginning
                            // then the workaround used above selects the beginning of the
                            // preceding block
                            pNode = range.parentElement();
                            if ((dom != pNode) && !com.isAncestor(context, dom, pNode)) {
                                if (!isAnchor(dom)) {
                                    range.moveToElementText(dom);
                                    range.collapse(true);
                                }
                            }
                        }
                    } else {
                        range.collapse(true);
                        var ptn = com.getPreviousCharacterNode(context, dom);
                        // positioning the caret doesn't work as expected if an anchor is at
                        // the end of the previous block or the previous block is a list and
                        // we'll try to position the caret on an empty block, hence we'll
                        // once more have to work around that issue accordingly
                        var requiresWorkaround = (com.isTag(dom, com.EDITBLOCK_TAGS)
                                    && com.isTag(ptn, "a")
                                    && com.isAttribDefined(ptn, "name"))
                                || (com.isEmptyEditingBlock(dom, true)
                                    && com.isTag(dom.previousSibling, com.LIST_TAGS));
                        if (requiresWorkaround) {
                            if (range.move("character", "-1") == -1) {
                                // offset of 1 doesn't work, but 2 does move the caret one
                                // block too far, so we'll correct that later
                                if (range.move("character", "2") == 2) {
                                    // handle EOT accordingly
                                    if (com.getNextNode(context, dom) != null) {
                                        range.move("character", "-1");
                                    }
                                }
                            }
                        } else {
                            // workaround is contraproductive for empty editing blocks
                            if (!com.isEmptyEditingBlock(dom, true)) {
                                // todo document which IE bug requires this to be worked around
                                if (range.move("character", 1) == 1) {
                                    range.move("character", -1);
                                }
                            }
                        }
                    }
                }
            } catch (e) {
                // There are situations where IE doesn't recognize range objects previously
                // created. At the moment, we're just ignoring that, as it occurs only in
                // situations where it doesn't really matter (when editing an anchor)
            }
        },

        selectNode: function(context, dom, asInsertPoint) {
            if (dom.nodeType == 3) {
                throw new Error("Selecting a text node is not supported.");
            }
            var range = context.doc.selection.createRange();
            CUI.rte.Selection.setNodeToRange(context, range, dom, asInsertPoint);
            range.select();
        },

        resetSelection: function(context, mode) {
            var sel = CUI.rte.Selection;
            var range = context.doc.selection.createRange();
            var nodeToSelect = context.root;
            if (mode == "all") {
                range.moveToElementText(nodeToSelect);
            } else if (mode == "start") {
                var ftn = com.getNextEditableNode(context, context.root);
                if (ftn) {
                    nodeToSelect = ftn.parentNode;
                }
                sel.setNodeToRange(context, range, nodeToSelect, true);
            } else if (mode == "end") {
                var ltn = null;
                var ln = com.getLastChild(context.root);
                if (ln) {
                    if (com.isEditableNode(ln)) {
                        ltn = ln;
                    } else {
                        ltn = com.getPreviousEditableNode(context, context.root);
                    }
                    if (ltn) {
                        nodeToSelect = ltn.parentNode;
                    }
                }
                sel.setNodeToRange(context, range, nodeToSelect, false);
                range.collapse(false);
            }
            range.select();
        },

        /**
         * This method is currently Gecko-only. May be implemented if required by IE
         */
        flushSelection: function(context, keepSelection) {
            // may be implemented if necessary
        },

        /**
         * IE-only method to determine if the range specified is collapsed and therefore
         * represents a caret.
         * @param {TextRange} range The range to be checked
         * @return {Boolean} True if the range is collapsed
         */
        isCollapsed: function(range) {
            if (range.item) {
                return false;
            }
            var startRange = range.duplicate();
            startRange.collapse(true);
            var endRange = range.duplicate();
            endRange.collapse(false);
            return startRange.isEqual(endRange);
        }

    } : {

        /**
         * @private
         */
        getNodeCharacters: function(node) {
            var nodeText = node.nodeValue;
            if (nodeText) {
                return nodeText;
            }
            return "";
        },

        /**
         * @private
         */
        getCharPosition: function(context, node, offset) {
            var charPos = 0;
            var domWalker, nodeToProcess;
            // corner case: offset relative to a tag
            if ((node.nodeType == 1) && !com.isOneCharacterNode(node)) {
                // todo may also be a point of failure with div as root
                if (!com.isRootNode(context, node)) {
                    charPos = com.getCharacterOffsetForNode(context, node);
                }
                for (var childIndex = 0; childIndex < offset; childIndex++) {
                    var childToProcess = node.childNodes[childIndex];
                    charPos += com.getNodeCharacterCnt(childToProcess);
                    domWalker = context.doc.createTreeWalker(childToProcess,
                            NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT, null, false);
                    while (true) {
                        try {
                            nodeToProcess = domWalker.nextNode();
                        } catch (ex) {
                            // on purpose: ignore nextNode() error because IE9 crashes if there is no next node
                        }
                        if (!nodeToProcess) {
                            break;
                        }
                        charPos += com.getNodeCharacterCnt(nodeToProcess);
                        if (com.isTag(nodeToProcess, com.EDITBLOCK_TAGS)) {
                            charPos++;
                        }
                    }
                    if (com.isTag(childToProcess, com.EDITBLOCK_TAGS)) {
                        charPos++;
                    }
                }
                return charPos;
            }
            // handle one character nodes (br, img) as required: if they are pointed
            // to directly, with offset 0, the caret is actually placed behind the node
            // (character offset is 1 there, according to the caret positioning rules)
            if (node.nodeType == 1) {
                if (offset == 0) {
                    offset = 1;
                }
            }
            // by default, calculate through text node and offset
            return com.getCharacterOffsetForNode(context, node) + offset;
        },

        /**
         * @private
         */
        calcNodeAndOffsetForPosition: function(context, charPos, handleSelectionEnd, dom,
                                               calcPos) {
            var sel = CUI.rte.Selection;
            // Parameters dom and calcPos are optional (used for recursion)
            if (!dom) {
                dom = context.root;
                calcPos = 0;
            }
            var isSuitableNodeEnd, offset;
            if (!com.isRootNode(context, dom)) {
                var charCnt = com.getNodeCharacterCnt(dom);
                // special case: The beginning of a nested list has also to be counted as
                // a single character
                var isNestedStruc = false;
                if (com.isTag(dom, com.EDITBLOCK_UNREGNEST_TAGS)) {
                    if ((com.getChildIndex(dom) == 0) &&
                            com.isFirstNestedList(context, dom.parentNode)) {
                        var pNode = dom;
                        do {
                            pNode = com.getParentNode(context, pNode);
                            if (pNode && com.isTag(pNode, com.EDITBLOCK_UNREGNEST_TAGS)) {
                                charCnt++;
                                isNestedStruc = true;
                                break;
                            }
                        } while (pNode);
                    }
                }
                isSuitableNodeEnd = (charCnt > 0)
                        && (handleSelectionEnd ? (charPos <= (calcPos + charCnt))
                            : (charPos < (calcPos + charCnt)));
                if ((charPos >= calcPos) && isSuitableNodeEnd) {
                    if (isNestedStruc) {
                        offset = null;
                        var textDom = com.getPreviousCharacterNode(context, dom);
                        if (textDom) {
                            dom = textDom;
                            offset = sel.getLastSelectionOffset(context, dom,
                                    handleSelectionEnd);
                        }
                        return {
                            "node": dom,
                            "offset": offset
                        };
                    }
                    offset = charPos - calcPos;
                    if (dom.nodeType == 1) {
                        offset = (offset == 0 ? null : 0);
                        // Gecko doesn't select "br"/0 as end of a selection as one would
                        // expect, so use the first character of the next text node
                        // instead (don't use break tags here, as we may encounter
                        // empty paragraphs as well)
                        if (com.isTag(dom, "br") && (offset == 0) && handleSelectionEnd) {
                            var nextTextNode = com.getNextCharacterNode(context, dom);
                            if (nextTextNode) {
                                dom = nextTextNode;
                                offset = sel.getFirstSelectionOffset(context, dom);
                            }
                        }
                    }
                    return {
                        "node": dom,
                        "offset": offset
                    };
                }
                calcPos += charCnt;
            }
            var childCnt = dom.childNodes.length;
            for (var c = 0; c < childCnt; c++) {
                var childToProcess = dom.childNodes[c];
                var ret = CUI.rte.Selection.calcNodeAndOffsetForPosition(context,
                        charPos, handleSelectionEnd, childToProcess, calcPos);
                if (typeof(ret) == "object") {
                    return ret;
                }
                calcPos = ret;
                if (com.isTag(childToProcess, com.EDITBLOCK_TAGS)) {
                    // "End of block" corner case
                    if (charPos == calcPos) {
                        var lastTextNode = com.getLastTextChild(childToProcess, true);
                        if (lastTextNode) {
                            offset = sel.getLastSelectionOffset(context, lastTextNode,
                                    handleSelectionEnd);
                            return {
                                "node": lastTextNode,
                                "offset": offset
                            };
                        }
                        // on IE, this means that we have an empty edit block and must
                        // continue to the next text node if possible
                        offset = null;
                        if (com.ua.isIE) {
                            var nextEditBlock = com.getNextEditableNode(context,
                                    childToProcess);
                            if (nextEditBlock) {
                                childToProcess = nextEditBlock;
                            } else {
                                // EOT
                                childToProcess = context.root;
                                offset = context.root.length;
                            }
                        }
                        return {
                            "node": childToProcess,
                            "offset": offset
                        };
                    }
                    // add another character at the end of a edit block, but no rule
                    // without exception: don't add at the end of a nested list or an
                    // empty edit block on W3C-compliant IE versions
                    var isValidEOEB = true;
                    var hasSpecialHandling = false;
                    if (com.isTag(childToProcess, com.EDITBLOCK_UNREGNEST_TAGS)) {
                        var itemParent = com.getParentNode(context, childToProcess);
                        var pIndex = com.getChildIndex(childToProcess);
                        var isLastChild = (pIndex == (itemParent.childNodes.length - 1));
                        var isNestedList = com.containsTagInPath(context, itemParent,
                                com.EDITBLOCK_UNREGNEST_TAGS);
                        isValidEOEB = !(isLastChild && isNestedList
                                && com.isLastNestedList(context, itemParent));
                        hasSpecialHandling = !isValidEOEB;
                    } else if (com.isTag(childToProcess, com.EDITBLOCK_NESTED_TAGS)) {
                        isValidEOEB = !com.isLastElementOfNestingLevel(context,
                                childToProcess);
                        hasSpecialHandling = !isValidEOEB;
                    }
                    if (com.ua.isIE && !hasSpecialHandling) {
                        isValidEOEB = !com.isEmptyEditingBlock(childToProcess, true);
                    }
                    if (isValidEOEB) {
                        calcPos++;
                    }
                }
            }
            // handle EOT corner case somehow ...
            if (com.isRootNode(context, dom)) {
                var node = com.getLastChild(dom);
                offset = sel.getLastSelectionOffset(context, node, handleSelectionEnd);
                return {
                    "node": node,
                    "offset": offset
                };
            }
            return calcPos;
        },

        /**
         * @private
         */
        getSelectionObject: function(selection) {
            if (selection.anchorNode != selection.focusNode) {
                return null;
            }
            if (Math.abs(selection.anchorOffset - selection.focusOffset) != 1) {
                return null;
            }
            var offset = (selection.anchorOffset < selection.focusOffset
                    ? selection.anchorOffset : selection.focusOffset);
            var selectedNode = selection.anchorNode.childNodes[offset];
            if (!selectedNode) {
                return null;
            }
            if (selectedNode.nodeType == 3) {
                return null;
            }
            if (com.isTag(selectedNode, com.EDITBLOCK_TAGS)) {
                return null;
            }
            return selectedNode;
        },

        /**
         * @private
         */
        getTableSelection: function(context) {
            var tableSelection = {
                "cells": [ ],
                "otherContent": false
            };
            var selection = context.win.getSelection();
            for (var i = 0; i < selection.rangeCount; i++) {
                var range = selection.getRangeAt(i);
                var cell = null;
                if (range.startContainer == range.endContainer) {
                    cell = range.startContainer;
                    if (com.isTag(cell, "tr")) {
                        if (range.startOffset == (range.endOffset - 1)) {
                            cell = cell.childNodes[range.startOffset];
                        } else {
                            cell = null;
                        }
                    } else if (!com.isTag(range.startContainer, [ "th", "td" ])) {
                        cell = null;
                    }
                }
                if (cell) {
                    tableSelection.cells.push(cell);
                } else {
                    tableSelection.otherContent = true;
                }
            }
            return ((tableSelection.cells.length > 0) ? tableSelection : null);
        },

        getSelection: function(context) {
            return context.win.getSelection();
        },

        getLeadRange: function(context) {
            return context.win.getSelection().getRangeAt(0);
        },

        getCaretPos: function(context) {
            var selection = context.win.getSelection();
            if ((selection.anchorNode != selection.focusNode)
                    || (selection.anchorOffset != selection.focusOffset)) {
                return -1;
            }
            return CUI.rte.Selection.getCharPosition(
                    context, selection.anchorNode, selection.anchorOffset);
        },

        setCaretPos: function(context, charPos) {
            if (charPos < 0) {
                charPos = 0;
            }
            var selection = context.win.getSelection();
            var range = context.doc.createRange();
            var nodeAndOffset = CUI.rte.Selection.calcNodeAndOffsetForPosition(
                    context, charPos);
            // to get similar results to IE, correct to previous structure if we are at the
            // character directly following such a structure
            correctToPreviousStructure(context, nodeAndOffset);
            adjustNodeAndOffsetToParent(context, nodeAndOffset);
            var node = nodeAndOffset.node;
            var offset = nodeAndOffset.offset;
            if (com.isTag(node, "img") && (offset == 0)) {
                // selecting images at the end of an edit block fails on Webkit if the
                // parent element + offset is selected; selecting the image and collapsing
                // the selection to its end seems to work though
                range.selectNode(node);
                range.collapse(false);
            } else {
                // handle the selection of empty blocks on IE versions that support the DOM
                // selection model
                var isIEEmptyBlockSel = false;
                if (com.ua.isIE) {
                    if ((node.nodeType == 1) && !isNaN(offset)) {
                        var potentialBlock = node.childNodes[offset];
                        if (com.isTag(potentialBlock, com.EDITBLOCK_TAGS)
                                && (potentialBlock.childNodes.length === 0)) {
                            node = potentialBlock;
                            isIEEmptyBlockSel = true;
                        }
                    }
                }
                if (!isIEEmptyBlockSel) {
                    range.setStart(node, offset);
                    range.setEnd(node, offset);
                } else {
                    range.selectNodeContents(node);
                }
            }
            selection.removeAllRanges();
            selection.addRange(range);
        },

        createRange: function(context) {
            return context.doc.createRange();
        },

        selectRange: function(context, rangeToSelect) {
            var selection = context.win.getSelection();
            selection.removeAllRanges();
            selection.addRange(rangeToSelect);
        },

        createRangeBookmark: function(context) {
            var selection = context.win.getSelection();
            if (selection.rangeCount == 1) {
                return {
                    "single": true,
                    "bookmark": selection.getRangeAt(0)
                };
            } else {
                var ranges = [ ];
                for (var r = 0; r < selection.rangeCount; r++) {
                    ranges.push(selection.getRangeAt(r));
                }
                return {
                    "single": false,
                    "bookmark": ranges
                };
            }
        },

        selectRangeBookmark: function(context, bookmark) {
            if (bookmark && bookmark.bookmark) {
                var selection = context.win.getSelection();
                selection.removeAllRanges();
                if (bookmark.single) {
                    selection.addRange(bookmark.bookmark);
                } else {
                    var ranges = bookmark.bookmark;
                    for (var r = 0; r < ranges.length; r++) {
                        selection.addRange(ranges[r]);
                    }
                }
            }
        },

        getRangeTextContent: function(context, range) {
            var selectionFrag = range.cloneContents();
            var fragTreeWalker = context.doc.createTreeWalker(selectionFrag,
                    NodeFilter.SHOW_TEXT, null, false);
            var textContent = "",
                nodeToProcess;
            while (true) {
                try {
                    nodeToProcess = fragTreeWalker.nextNode();
                } catch (ex) {
                    // on purpose: ignore nextNode() error because IE9 crashes if there is no next node
                }
                if (!nodeToProcess) {
                    break;
                }
                textContent += CUI.rte.Selection.getNodeCharacters(nodeToProcess);
            }
            return textContent;
        },

        createSelectionBookmark: function(context) {
            var sel = CUI.rte.Selection;
            var selection = context.win.getSelection();
            var selectionObject = CUI.rte.Selection.getSelectionObject(selection);
            var insertObject = null;
            var cells = null;
            var startPos, endPos, range;
            var rangeCnt = selection.rangeCount;
            if (rangeCnt == 1) {
                startPos = sel.getCharPosition(context, selection.anchorNode,
                        selection.anchorOffset);
                endPos = sel.getCharPosition(context, selection.focusNode,
                        selection.focusOffset);
            } else if (rangeCnt > 1) {
                cells = [ ];
                for (var r = 0; r < rangeCnt; r++) {
                    range = selection.getRangeAt(r);
                    var cell = range.startContainer;
                    if (com.isTag(cell, "tr")) {
                        cells.push(cell.childNodes[range.startOffset]);
                    }
                    var rangeStartPos = sel.getCharPosition(context, range.startContainer,
                            range.startOffset);
                    if ((r == 0) || (rangeStartPos < startPos)) {
                        startPos = rangeStartPos;
                        endPos = rangeStartPos;
                    }
                }
            } else if (rangeCnt == 0) {
                // pre-init/unfocused state: no valid range available, assuming caret at
                // position 0
                startPos = 0;
                endPos = 0;
            }
            if (endPos < startPos) {
                var swap = endPos;
                endPos = startPos;
                startPos = swap;
            }
            if ((startPos == endPos) && !cells && (rangeCnt == 1)) {
                range = selection.getRangeAt(0);
                var parentEl = range.commonAncestorContainer;
                if (parentEl.nodeType == 1) {
                    var childCnt = parentEl.childNodes.length;
                    // workaround: FF may insert a br in an empty list item
                    if ((childCnt == 0) || ((childCnt == 1)
                            && com.isTag(parentEl.childNodes[0], "br"))) {
                        insertObject = parentEl;
                        if (CUI.rte.Selection.isNoInsertNode(insertObject)) {
                            insertObject = null;
                        }
                    }
                }
            }
            return CUI.rte.Utils.apply({
                "startPos": startPos,
                "charCnt": endPos - startPos,
                "object": selectionObject,
                "insertObject": insertObject,
                "cells": cells
            }, CUI.rte.Selection.getScrollOffsets(context));
        },

        selectBookmark: function(context, bookmark) {
            var sel = CUI.rte.Selection;
            var doc = context.doc;
            var objectToSelect = null;
            var range, selection;
            var cells = bookmark.cells;
            // if table cells are bookmarked, we're trying to select them first and use
            // the caret position only if none of the cells are available
            if (cells) {
                selection = context.win.getSelection();
                selection.removeAllRanges();
                var hasValidCells = false;
                var cellCnt = cells.length;
                for (var c = 0; c < cellCnt; c++) {
                    var cellToProcess = cells[c];
                    if (cellToProcess && cellToProcess.ownerDocument == doc) {
                        range = doc.createRange();
                        var container = cellToProcess.parentNode;
                        var offset = com.getChildIndex(cellToProcess);
                        try {
                            range.setStart(container, offset);
                            range.setEnd(container, offset + 1);
                            selection.addRange(range);
                            hasValidCells = true;
                        } catch (e) {
                            // intentionally ignored; will be handled through hasValidCells
                        }
                    }
                }
                if (hasValidCells) {
                    return;
                }
            }
            // the default selection process
            if (bookmark.object) {
                objectToSelect = bookmark.object;
            } else if (bookmark.insertObject) {
                objectToSelect = bookmark.insertObject;
            }
            range = doc.createRange();
            if (objectToSelect) {
                try {
                    range.selectNode(objectToSelect);
                    range.collapse(true);
                } catch (e) {
                    // if the object is not available anymore (which might be the cause
                    // when undoing), use the caret-position instead
                    if (bookmark.startPos != null) {
                        objectToSelect = undefined;
                    }
                }
            }
            var isRangeCreated = !!objectToSelect;
            if (!isRangeCreated) {
                var startNodeAndOffset = sel.calcNodeAndOffsetForPosition(context,
                        bookmark.startPos);
                var endNodeAndOffset = startNodeAndOffset;
                if (bookmark.charCnt > 0) {
                    endNodeAndOffset = sel.calcNodeAndOffsetForPosition(context,
                            bookmark.startPos + bookmark.charCnt, true);
                } else if (com.ua.isIE) {
                    // selecting an empty edit block on IE causes problems if the
                    // setStart... methods are used
                    if (com.isEmptyEditingBlock(startNodeAndOffset.node, true)) {
                        range.selectNodeContents(startNodeAndOffset.node);
                        isRangeCreated = true;
                    }
                }
            }
            if (!isRangeCreated) {
                correctToPreviousStructure(context, startNodeAndOffset);
                if (com.ua.isGecko) {
                    adjustNodeAndOffsetToParent(context, startNodeAndOffset);
                }
                if (bookmark.charCnt > 0) {
                    if (com.ua.isGecko) {
                        adjustNodeAndOffsetToParent(context, endNodeAndOffset);
                    }
                }
                var startNode = startNodeAndOffset.node;
                var startOffset = startNodeAndOffset.offset;
                var endNode = endNodeAndOffset.node;
                var endOffset = endNodeAndOffset.offset;
                if (!com.ua.isGecko && (startNode.nodeType == 1)) {
                    if (startOffset == null) {
                        // TODO probably needs "empty block/table cell" fix for IE (use setEnd?)
                        range.setStartBefore(startNode);
                    } else {
                        range.setStartAfter(startNode);
                    }
                } else {
                    range.setStart(startNode, startOffset);
                }
                if (!com.ua.isGecko && (endNode.nodeType == 1)) {
                    if (endOffset == null) {
                        // TODO probably needs "empty block/table cell" fix for IE (use setEnd?)
                        range.setEndBefore(endNode);
                    } else {
                        range.setEndAfter(endNode);
                    }
                } else {
                    range.setEnd(endNode, endOffset);
                }
            }
            selection = context.win.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
        },

        /**
         * Trims leading and trailing whitespace from the given range.
         * @param {TextRange} range The range to trim
         * @return {TextRange} A range that has no more trailing and/or leading whitespace
         */
        trimRangeWhitespace: function(context, range) {
            var sel = CUI.rte.Selection;
            var rangeText = sel.getRangeTextContent(context, range);
            var leadingWhitespaceCnt = 0;
            var checkPos = 1;
            var fragToCheck;
            while (checkPos < rangeText.length) {
                fragToCheck = rangeText.substring(0, checkPos++);
                if (!sel.hasWhitespaceOnly(fragToCheck)) {
                    break;
                }
                leadingWhitespaceCnt++;
            }
            var trailingWhitespaceCnt = 0;
            checkPos = rangeText.length;
            while (checkPos > 0) {
                fragToCheck = rangeText.substring(--checkPos, rangeText.length);
                if (!sel.hasWhitespaceOnly(fragToCheck)) {
                    break;
                }
                trailingWhitespaceCnt++;
            }
            if ((rangeText.length - leadingWhitespaceCnt - trailingWhitespaceCnt) > 0) {
                if (leadingWhitespaceCnt > 0) {
                    var startPos = sel.getCharPosition(context, range.startContainer,
                            range.startOffset);
                    startPos += leadingWhitespaceCnt;
                    var startNodeAndOffset = sel.calcNodeAndOffsetForPosition(context,
                            startPos);
                    range.setStart(startNodeAndOffset.node, startNodeAndOffset.offset);
                }
                if (trailingWhitespaceCnt > 0) {
                    var endPos = sel.getCharPosition(context, range.endContainer,
                            range.endOffset);
                    endPos -= trailingWhitespaceCnt;
                    var endNodeAndOffset = sel.calcNodeAndOffsetForPosition(context,
                            endPos);
                    range.setEnd(endNodeAndOffset.node, endNodeAndOffset.offset);
                }
            }
            return range;
        },

        createProcessingSelection: function(context) {
            var startNode, startOffset, endNode, endOffset;
            var selection = context.win.getSelection();
            var sel = CUI.rte.Selection;
            // table cell selection "support"
            var cellSelection = null;
            var isSingleCellSelected = false;
            if ((selection.focusNode == selection.anchorNode)
                    && (com.isTag(selection.focusNode, "tr"))) {
                isSingleCellSelected = true;
            }
            if ((selection.rangeCount > 1) || isSingleCellSelected) {
                cellSelection = sel.getTableSelection(context);
                var range = selection.getRangeAt(0);
                startNode = range.startContainer;
                startOffset = null;
                if (startNode.nodeType == 1) {
                    startNode = startNode.childNodes[range.startOffset];
                } else {
                    startOffset = range.startOffset;
                }
                range = selection.getRangeAt(selection.rangeCount - 1);
                endOffset = null;
                endNode = range.endContainer;
                if (endNode.nodeType == 1) {
                    if (range.endOffset < endNode.childNodes.length) {
                        endNode = com.getPreviousNode(context,
                                endNode.childNodes[range.endOffset]);
                    } else {
                        endNode = com.getLastChild(endNode);
                    }
                    if (endNode.nodeType == 3) {
                        endOffset = com.getNodeCharacterCnt(endNode);
                    }
                } else {
                    endOffset = range.endOffset;
                }
                return {
                    "startNode": startNode,
                    "startOffset": startOffset,
                    "endNode": endNode,
                    "endOffset": endOffset,
                    "isDiscontinuousSelection": true,
                    "cellSelection": cellSelection
                };
            }
            // selected "objects" (a name, img, etc.)
            var selectionObject = sel.getSelectionObject(selection);
            if (selectionObject) {
                return {
                    "startNode": selectionObject
                };
            }
            startNode = selection.anchorNode;
            startOffset = selection.anchorOffset;
            endNode = selection.focusNode;
            endOffset = selection.focusOffset;
            var isCollapsed = (startNode == endNode) && (startOffset == endOffset);
            var childCnt;
            // startNode might be null, so it's better to check that first
            if (startNode
                    && !com.isOneCharacterNode(startNode) && (startNode.nodeType == 1)) {
                childCnt = startNode.childNodes.length;
                if (childCnt == 0) {
                    startOffset = null;
                } else if (startOffset < childCnt) {
                    startNode = startNode.childNodes[startOffset];
                    startNode = com.getFirstChild(startNode) || startNode;
                    startOffset = (startNode.nodeType == 3 ? 0 : null);
                } else {
                    startNode = com.getLastChild(startNode);
                    if (startNode.nodeType == 3) {
                        startOffset = com.getNodeCharacterCnt(startNode);
                    } else if (com.isOneCharacterNode(startNode)) {
                        startOffset = 0;
                    } else {
                        startOffset = null;
                    }
                }
            }
            if (isCollapsed) {
                return {
                    "startNode": startNode,
                    "startOffset": startOffset,
                    "cellSelection": cellSelection
                };
            }
            if (!com.isOneCharacterNode(endNode) && (endNode.nodeType == 1)) {
                childCnt = endNode.childNodes.length;
                if (childCnt == 0) {
                    endOffset = null;
                } else if (endOffset < childCnt) {
                    endNode = endNode.childNodes[endOffset];
                    endNode = com.getFirstChild(endNode) || endNode;
                    endOffset = ((endNode.nodeType == 1)
                            && !com.hasTextChild(endNode, false) ? null : 0);
                } else {
                    endNode = com.getLastChild(endNode);
                    if (endNode.nodeType == 3) {
                        endOffset = com.getNodeCharacterCnt(endNode);
                    } else if (com.isOneCharacterNode(endNode)) {
                        endOffset = 0;
                    } else {
                        endOffset = null;
                    }
                }
            }
            var mustSwap = false;
            if (startNode == endNode) {
                mustSwap = (endOffset < startOffset);
            } else {
                var startIndex = com.createIndexPath(context, startNode);
                var endIndex = com.createIndexPath(context, endNode);
                mustSwap = (com.compareIndexPaths(startIndex, endIndex) < 0);
            }
            if (mustSwap) {
                var swap = endNode;
                endNode = startNode;
                startNode = swap;
                swap = endOffset;
                endOffset = startOffset;
                startOffset = swap;
            }
            return {
                "startNode": startNode,
                "startOffset": startOffset,
                "endNode": endNode,
                "endOffset": endOffset,
                "cellSelection": cellSelection
            };
        },

        selectNode: function(context, dom, asInsertPoint) {
            if (dom.nodeType == 3) {
                throw new Error("Selecting a text node is not supported.");
            }
            var selection = context.win.getSelection();
            var range = context.doc.createRange();
            if (asInsertPoint) {
                var textNode = com.getFirstTextChild(dom);
                if (textNode) {
                    range.setStart(textNode, 0);
                    range.setEnd(textNode, 0);
                } else {
                    // "empty line" handling
                    if ((dom.childNodes.length == 1)
                            && (dom.childNodes[0].nodeType == 1)) {
                        range.selectNode(dom.childNodes[0]);
                        range.collapse(true);
                    } else if (com.ua.isIE && com.isEmptyEditingBlock(dom, true)) {
                        // IE supporting W3C selection model needs special treatment
                        // for empty blocks
                        range.selectNodeContents(dom);
                    } else {
                        range.selectNode(dom);
                        range.collapse(true);
                    }
                }
            } else {
                range.selectNode(dom);
            }
            selection.removeAllRanges();
            selection.addRange(range);
        },

        /**
         * This method is Gecko only, as only Gecko seems to have problems with the caret
         * getting out of the visible area of the editor iframe.
         */
        getPreferredScrollOffset: function(context) {
            return context.root.scrollTop;
        },

        /**
         * This method is Gecko/Webkit only, as IE does not seem to have problems with the
         * caret getting out of the visible area of the editor iframe.
         */
        ensureCaretVisibility: function(context, preferredScrollOffset) {
            var sel = CUI.rte.Selection;
            var range = sel.getLeadRange(context).cloneRange();
            // workaround for selected cells (insertNode() doesn't handle them as expected)
            if (range.startContainer.nodeType == 1) {
                var nodeToCheck = range.startContainer.childNodes[range.startOffset];
                if (com.isTag(nodeToCheck, [ "td", "th" ])) {
                    range.selectNodeContents(nodeToCheck);
                }
            }
            // use a helper span to exactly determine current caret position/size in pixels
            if (context.iFrame) {
                var locSpan = context.createElement("span");
                var nbsp = context.createTextNode(dpr.NBSP);
                locSpan.appendChild(nbsp);
                range.insertNode(locSpan);
                var top = locSpan.offsetTop;
                var op = locSpan;
                while (op.offsetParent) {
                    op = op.offsetParent;
                    top += op.offsetTop;
                }
                var height = locSpan.offsetHeight;
                var scrollTop = context.root.scrollTop;
                var iframeHeight = context.iFrame.clientHeight;
                var scrollBottom = scrollTop + iframeHeight;
                var bottom = top + height;
                var maxScroll = context.root.scrollHeight;
                if ((maxScroll - bottom) < 8) {
                    bottom = maxScroll;
                }
                if (preferredScrollOffset != null) {
                    var preferredBottom = preferredScrollOffset + iframeHeight;
                    if ((top >= preferredScrollOffset) && (bottom < preferredBottom)) {
                        context.root.scrollTop = preferredScrollOffset;
                    } else {
                        if (top < preferredScrollOffset) {
                            context.root.scrollTop = top;
                        } else {
                            context.root.scrollTop = bottom - iframeHeight;
                        }
                    }
                } else if (bottom > scrollBottom) {
                    context.root.scrollTop = bottom - iframeHeight;
                } else if (top < scrollTop) {
                    context.root.scrollTop = top;
                }
                var pNode = locSpan.parentNode;
                pNode.removeChild(locSpan);
                pNode.normalize();
            }
        },

        /**
         * This method is Gecko-only. Can be used as a workaround to ensure no selection
         * artifacts are displayed onscreen.
         */
        flushSelection: function(context, keepSelection) {
            var selection = context.win.getSelection();
            var savedRanges;
            if (keepSelection) {
                savedRanges = [ ];
                var rangeCnt = selection.rangeCount;
                for (var r = 0; r < rangeCnt; r++) {
                    savedRanges.push(selection.getRangeAt(r));
                }
            }
            selection.selectAllChildren(context.root);
            selection.collapseToStart();
            if (keepSelection) {
                selection.removeAllRanges();
                for (r = 0; r < rangeCnt; r++) {
                    selection.addRange(savedRanges[r]);
                }
            }
        },

        resetSelection: function(context, mode) {
            var range;
            var selection = context.win.getSelection();
            var nodeToSelect = context.root;
            if (mode == "all") {
                selection.selectAllChildren(nodeToSelect);
            } else if (mode == "start") {
                var ftn = com.getNextEditableNode(context, context.root);
                if (ftn) {
                    nodeToSelect = ftn.parentNode;
                }
                if (com.ua.isIE && com.isEmptyEditingBlock(ftn, true)) {
                    range = context.doc.createRange();
                    range.selectNodeContents(ftn);
                    selection.removeAllRanges();
                    selection.addRange(range);
                } else {
                    selection.selectAllChildren(nodeToSelect);
                    selection.collapseToStart();
                }
            } else if (mode == "end") {
                var ltn = null;
                var ln = com.getLastChild(context.root);
                if (ln) {
                    if (com.isEditableNode(ln)) {
                        ltn = ln;
                    } else {
                        ltn = com.getPreviousEditableNode(context, context.root);
                    }
                    if (ltn) {
                        nodeToSelect = ltn.parentNode;
                    }
                }
                if (com.ua.isIE && com.isEmptyEditingBlock(ltn, true)) {
                    range = context.doc.createRange();
                    range.selectNodeContents(ltn);
                    selection.removeAllRanges();
                    selection.addRange(range);
                } else {
                    selection.selectAllChildren(nodeToSelect);
                    selection.collapseToEnd();
                }
            }
        }

    });

}();
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.UndoManager
 * @private
 * This class implements undo/redo functionality for the RichText component.
 * @constructor
 * Creates a new UndoManager.
 * @param {Number} maxUndoSteps Number of maximum undo steps
 */
CUI.rte.UndoManager = new Class({

    toString: "UndoManager",

    /**
     * Array that contains all currently available undo steps
     * @type CUI.rte.UndoManager.Step
     * @private
     */
    undoHistory: null,

    /**
     * Number of maximum undo steps
     * @type Number
     * @public
     */
    maxUndoSteps: 0,

    /**
     * Currently active undo step (as array index of array {@link #undoHistory})
     * @type Number
     * @private
     */
    activeUndoStep: 0,

    construct: function(maxUndoSteps) {
        this.undoHistory = [ ];
        this.maxUndoSteps = maxUndoSteps;
        this.activeUndoStep = 0;
    },

    /**
     * <p>Adds the specified undo step to the undo history.</p>
     * <p>The undo step is only added if it is different from the currently active
     * undo step.</p>
     * @param {CUI.rte.UndoManager.Step} stepToAdd The undo step to add
     * @return {Boolean} True if the step has actually been added
     */
    addStep: function(stepToAdd) {
        // special case: if we are somewhere in the history (except at their end) we
        // also have to check if the step to add is the same as the current step and leave
        // the history intact if this is the case.
        var activeStep;
        if (this.activeUndoStep > 0) {
            activeStep = this.undoHistory[this.activeUndoStep - 1];
            if (activeStep.hasEqualSnapshot(stepToAdd)) {
                // window.console.log("Skipping identical undo step.");
                return false;
            }
        }
        // remove all steps behind the currently active, as they become invalid through
        // the newly added
        this.clearRedoHistory();
        // finally add the step
        this.undoHistory.push(stepToAdd);
        // shorten history if it has grown too large
        if (this.undoHistory.length > this.maxUndoSteps) {
            var stepsToRemove = this.undoHistory.length - this.maxUndoSteps;
            /*
            window.console.log("Shortening undo history by " + stepsToRemove + " steps "
                    + " to ensure maximum size.");
            */
            this.undoHistory.splice(0, stepsToRemove);
            this.activeUndoStep -= stepsToRemove;
        }
        this.activeUndoStep++;
        // window.console.log("Step added: " + this.createShortDump());
        return true;
    },

    /**
     * Checks if there are undo steps are defined (and thus undo is available).
     * @return {Boolean} True if undo is currently available
     */
    canUndo: function() {
        return (this.activeUndoStep > 1);
    },

    /**
     * Checks if there are undo steps behind the currently active undo step (and thus
     * redo is available).
     * @return {Boolean} True if redo is currently available
     */
    canRedo: function() {
        return (this.activeUndoStep < this.undoHistory.length);
    },

    /**
     * Executes a one-step undo, if there are undoable steps available.
     * @param {CUI.rte.EditContext} context The edit context
     */
    undo: function(context) {
        // try to add another undo step to reflect the changes that may have been
        // made since the last undo step was recorded
        if (this.addStep(new CUI.rte.UndoManager.Step(context))) {
            // window.console.log("Recorded additional undo step");
        }
        if (this.canUndo()) {
            // the actual undo
            this.activeUndoStep--;
            this.undoHistory[this.activeUndoStep - 1].set(context);
            // window.console.log("After undo: " + this.createShortDump());
        }
    },

    /**
     * Executes a one-step redo, if there are redoable steps available.
     * @param {CUI.rte.EditContext} context The edit context
     */
    redo: function(context) {
        if (this.addStep(new CUI.rte.UndoManager.Step(context))) {
            // window.console.log("Recorded additional undo step");
        }
        if (this.canRedo()) {
            this.undoHistory[this.activeUndoStep].set(context);
            this.activeUndoStep++;
        }
        // window.console.log("After redo: " + this.createShortDump());
    },

    /**
     * <p>Initializes the undo manager from the given editor's iframe.</p>
     * <p>The undo history is cleared and re-initialized with a snapshot of the specified
     * editor content.</p>
     * @param {CUI.rte.EditContext} context The edit context
     */
    initialize: function(context) {
        // window.console.log("Initializing undo manager");
        this.undoHistory.length = 0;
        this.activeUndoStep = 0;
        this.addStep(new CUI.rte.UndoManager.Step(context));
    },

    /**
     * <p>Clears the undo history from the currently active undo step. This has the effect
     * that no more redo steps are available afterwards.</p>
     * <p>This method should be explicitly called if anything is changed after the last undo
     * and no undo step has yet been recorded for the change.</p>
     */
    clearRedoHistory: function() {
        var stepsToRemove = this.undoHistory.length - this.activeUndoStep;
        if (stepsToRemove > 0) {
            // window.console.log("Removing " + stepsToRemove + " steps.");
            this.undoHistory.splice(this.activeUndoStep, stepsToRemove);
        }
    },

    /**
     * Creates a (short) dump of the current undo history
     * @return {String} A short dump of the current undo history
     * @private
     */
    createShortDump: function() {
        var stepCnt = this.undoHistory.length;
        return "Undo history (" + stepCnt + " steps; active step: #"
                + this.activeUndoStep + "; maximum steps: " + this.maxUndoSteps + ")";
    },

    /**
     * Creates a (full) dump of the current undo history
     * @return {String} A full dump of the current undo history
     * @private
     */
    createDump: function() {
        var stepCnt = this.undoHistory.length;
        var dump = this.createShortDump() + ":\n";
        for (var s = 0; s < stepCnt; s++) {
            dump += "#" + s + ": " + this.undoHistory[s].createDump();
        }
        return dump;
    }
});


/**
 * @class CUI.rte.UndoManager.Step
 * @private
 * The UndoManager.Step represents a single undoable step of the undo history.
 * @constructor
 * Creates a new UndoManager.Step from the specified RichText edit frame.
 * @param {CUI.rte.EditContext} context The edit context
 * @param {Object} bookmark (optional) A selection bookmark to be used; if none is
 *        specified, the bookmark is created through the specified edit context
 */
CUI.rte.UndoManager.Step = new Class({

    toString: "UndoManager.Step",

    /**
     * The HTML snapshot representing the undo step
     */
    htmlSnapshot: null,

    /**
     * The bookmark representing the editor's selection at the time of the snapshot taken
     */
    bookmark: null,

    construct: function(context, bookmark) {
        var sel = CUI.rte.Selection;
        this.bookmark = (bookmark ? bookmark : sel.createSelectionBookmark(context));
        // delete object references from bookmark, as they would point to "zombie nodes"
        // after a undo/redo
        this.bookmark.insertObject = undefined;
        this.bookmark.object = undefined;
        var cleanupRoot = context.root.cloneNode(true);
        this.cleanup(cleanupRoot);
        this.htmlSnapshot = cleanupRoot.innerHTML;
    },

    /**
     * Removes temporary stuff from the DOM
     * @private
     */
    cleanup: function(dom) {
        var com = CUI.rte.Common;
        if (dom.nodeType == 1) {
            com.removeClass(dom, CUI.rte.Theme.TABLESELECTION_CLASS);
            var childCnt = dom.childNodes.length;
            for (var c = 0; c < childCnt; c++) {
                this.cleanup(dom.childNodes[c]);
            }
        }
    },

    /**
     * Sets the represented undo step to the RichText represented by the specified edit
     * context.
     * @param {CUI.rte.EditContext} context The edit context
     */
    set: function(context) {
        context.root.innerHTML = this.htmlSnapshot;
        CUI.rte.Selection.selectBookmark(context, this.bookmark);
    },

    /**
     * Compares the HTML snapshot of this undo step with the snapshot of the specified
     * undo step.
     * @param {CUI.rte.UndoManager.Step} stepToCompareWith The undo step to compare with
     * @return {Boolean} True if both steps have the same HTML snapshot
     */
    hasEqualSnapshot: function(stepToCompareWith) {
        return this.htmlSnapshot == stepToCompareWith.htmlSnapshot;
    },

    /**
     * Compares this undo step with the specified undo step.
     * @param {CUI.rte.UndoManager.Step} stepToCompareWith The undo step to compare with
     * @return {Boolean} True if both steps are identical
     */
    equals: function(stepToCompareWith) {
        var sel = CUI.rte.Selection;
        if (this.htmlSnapshot != stepToCompareWith.htmlSnapshot) {
            return false;
        }
        return sel.compareBookmarks(this.bookmark, stepToCompareWith.bookmark);
    },

    /**
     * Creates a dump of the undo step
     * @return {String} A dump of the undo step
     * @private
     */
    createDump: function() {
        var dump = "\n";
        dump += "Bookmark:\n" + this.bookmark.toSource();
        dump += "\nHTML-Snapshot:\n" + this.htmlSnapshot;
        dump += "\n\n";
        return dump;
    }

});
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.TableMatrix
 * @private
 * <p>This class implements an abstract representation of a table for easier processing
 * &amp; editing (especially regarding colspan/rowspan settings).</p>
 * <p>A table matrix basically consists of a two dimensional array which represents the
 * actual cells of the table. In contrast to the DOM representation of a table, cells are
 * actually adressable via their linear row/column numbers, even with
 * complex rowspan/colspan settings.</p>
 */
CUI.rte.TableMatrix = new Class({

    toString: "TableMatrix",

    /**
     * The table matrix
     * @private
     */
    matrix: null,

    /**
     * Row definitions
     * @private
     */
    rows: null,

    /**
     * The full table matrix
     * @private
     */
    fullMatrix: null,

    /**
     * The table
     * @private
     */
    tableDom: null,

    /**
     * @private
     */
    getPreviousRowCellDef: function(row, cellPos) {
        while (row > 0) {
            row--;
            var cellDefToCheck = this.matrix[row][cellPos];
            if (cellDefToCheck != null) {
                return {
                    "row": row,
                    "col": cellPos,
                    "cell": cellDefToCheck
                };
            }
            var prevCellPos = cellPos - 1;
            while (prevCellPos >= 0) {
                var cellDef = this.matrix[row][prevCellPos];
                if (cellDef) {
                    if ((prevCellPos + cellDef.colSpan) > cellPos) {
                        return {
                            "row": row,
                            "col": prevCellPos,
                            "cell": cellDef
                        };
                    }
                    break;
                }
                prevCellPos--;
            }
        }
        return null;
    },

    /**
     * Creates a table matrix for easier calculation of merged cells.
     * @param {HTMLElement} tableDom DOM node that represents the table
     */
    createTableMatrix: function(tableDom) {
        var com = CUI.rte.Common;
        this.tableDom = tableDom;
        this.matrix = [ ];
        this.fullMatrix = null;
        this.rows = com.getChildNodesByType(tableDom, "tr", true, "table");
        for (var r = 0; r < this.rows.length; r++) {
            var rowDefs = [ ];
            this.matrix.push(rowDefs);
            var cells = com.getChildNodesByType(this.rows[r], [ "th", "td" ], false);
            var cellPos = 0;
            for (var c = 0; c < cells.length; c++) {
                var cell = cells[c];
                var colSpanAttr = com.getAttribute(cell, "colspan");
                var rowSpanAttr = com.getAttribute(cell, "rowspan");
                var colSpan = (colSpanAttr ? parseInt(colSpanAttr) : 1);
                var rowSpan = (rowSpanAttr ? parseInt(rowSpanAttr) : 1);
                while (true) {
                    var prevRowCell = this.getPreviousRowCellDef(r, cellPos);
                    if (prevRowCell) {
                        var prevRow = prevRowCell.row;
                        var prevRowSpan = prevRowCell.cell.rowSpan;
                        if ((prevRow + prevRowSpan) <= r) {
                            rowDefs[cellPos] = {
                                "col": cellPos,
                                "row": r,
                                "colSpan": colSpan,
                                "rowSpan": rowSpan,
                                "cellDom": cell
                            };
                            cellPos += colSpan;
                            break;
                        }
                    } else {
                        rowDefs[cellPos] = {
                            "col": cellPos,
                            "row": r,
                            "colSpan": colSpan,
                            "rowSpan": rowSpan,
                            "cellDom": cell
                        };
                        cellPos += colSpan;
                        break;
                    }
                    cellPos++;
                }
            }
        }
    },

    /**
     * <p>Creates a "full" matrix from the (basic) matrix previously created by
     * {@link CUI.rte.TableMatrix#createTableMatrix}.</p>
     * <p>The "full matrix" is a different representation of the table. You usually don't
     * have to call this method explicitly, as all methods requiring the full matrix will
     * invoke it implicitly if necessary.</p>
     * @private
     */
    createFullMatrix: function() {
        if (this.matrix == null) {
            throw new Error("No basic matrix calculated; use createTableMatrix() before.");
        }
        this.fullMatrix = [ ];
        for (var i = 0; i < this.matrix.length; i++) {
            for (var j = 0; j < this.matrix[i].length; j++) {
                if (this.matrix[i][j] != null) {
                    var cell = this.matrix[i][j];
                    for (var c = 0; c < cell.colSpan; c++) {
                        for (var r = 0; r < cell.rowSpan; r++) {
                            var row;
                            if (this.fullMatrix[r + i]) {
                                row = this.fullMatrix[r + i];
                            } else {
                                row = [ ];
                                this.fullMatrix[r + i] = row;
                            }
                            row[c + j] = {
                                "isOrigin": (c == 0) && (r == 0),
                                "cellRef": cell
                            };
                        }
                    }
                }
            }
        }
    },

    /**
     * Get the actual table size (considering all colspan/rowspan settings).
     * @return {Object} The table site (properties: cols, rows)
     */
    getTableSize: function() {
        if (this.matrix == null) {
            throw new Error("No basic matrix calculated; use createTableMatrix() before.");
        }
        var rows = this.rows.length;
        var cols = 0;
        for (var c = 0; c < this.matrix[0].length; c++) {
            if (this.matrix[0][c]) {
                cols += this.matrix[0][c].colSpan;
            }
        }
        return {
            "cols": cols,
            "rows": rows
        };
    },

    /**
     * Get the cell definition for the specified row/column.
     * @param {Number} col column (0-based)
     * @param {Number} row row (0-based)
     * @return {Object} cell definition (properties: col, row, colSpan, rowSpan, cellDom;
     *         note that the column/row specified here might be different to the col/row
     *         specified by the caller as it always specifies the first col/row a cell
     *         occupies)
     */
    getCellForCoords: function(col, row) {
        if (this.fullMatrix == null) {
            this.createFullMatrix();
        }
        if (row >= this.fullMatrix.length) {
            return null;
        }
        var cells = this.fullMatrix[row];
        if (col >= cells.length) {
            return null;
        }
        return cells[col].cellRef;
    },

    /**
     * Get the cell definition for the specified DOM cell object.
     * @param {HTMLTableCellElement} cellDom The cell
     * @return {Object} cell definition (properties: col, row, colSpan, rowSpan, cellDom)
     */
    getCellDef: function(cellDom) {
        if (this.matrix == null) {
            throw new Error("No basic matrix calculated; use createTableMatrix() before.");
        }
        for (var r = 0; r < this.matrix.length; r++) {
            for (var c = 0; c < this.matrix[r].length; c++) {
                var cellDef = this.matrix[r][c];
                if (cellDef && (cellDef.cellDom == cellDom)) {
                    return cellDef;
                }
            }
        }
        return null;
    },

    /**
     * Calculate some additional information about the specified table cell.
     * @param {HTMLTableCellElement} cellDom The cell
     * @return {Object} cell definition (properties: isFirstCol, isFirstRow, isLastCol,
     *         isLastRow, cellDef)
     */
    getCellInfo: function(cellDom) {
        if (this.matrix == null) {
            throw new Error("No basic matrix calculated; use createTableMatrix() before.");
        }
        for (var r = 0; r < this.matrix.length; r++) {
            for (var c = 0; c < this.matrix[r].length; c++) {
                var cellDef = this.matrix[r][c];
                if (cellDef && (cellDef.cellDom == cellDom)) {
                    var maxRowExcl = r + cellDef.rowSpan;
                    var maxColExcl = c + cellDef.colSpan;
                    return {
                        "isFirstCol": (c == 0),
                        "isFirstRow": (r == 0),
                        "isLastCol": (maxColExcl >= this.matrix[r].length),
                        "isLastRow": (maxRowExcl >= this.matrix.length),
                        "cellDef": cellDef
                    };
                }
            }
        }
        return null;
    },

    /**
     * Creates a cell selection object ({@link CUI.rte.CellSelection}) from the
     * specified array of table cells.
     * @param {Array} selectedDomCells Array of table cells to create the selection from;
     *        elements of type HTMLTableCellElement
     * @return {CUI.rte.CellSelection} The cell selection object
     */
    createSelection: function(selectedDomCells) {
        if (!CUI.rte.Utils.isArray(selectedDomCells)) {
            selectedDomCells = [ selectedDomCells ];
        }
        var cellSelection = new CUI.rte.CellSelection(this);
        for (var i = 0; i < selectedDomCells.length; i++) {
            var cellDef = this.getCellDef(selectedDomCells[i]);
            if (!cellDef) {
                throw new Error("Invalid cell");
            }
            cellSelection.addCell(cellDef);
        }
        cellSelection.process();
        return cellSelection;
    },

    /**
     * Get the DOM object for the specified table row.
     * @param {Number} rowIndex number of the row (0-based)
     * @return {HTMLTableRowElement} the table row DOM object
     */
    getRowDom: function(rowIndex) {
        return this.rows[rowIndex];
    },

    /**
     * <p>Get an array of all table cells that intersect the specified table column.</p>
     * <p>Note that even cells that do not start at the given column, but intersect it by
     * their colspan setting, are returned by this method.</p>
     * @param {Number} colIndex number of the column (0-based)
     * @return {Array} all columns intersecting the specified column; element properties
     *         are: col, row, colSpan, rowSpan, cellDom)
     */
    getColumn: function(colIndex) {
        var com = CUI.rte.Common;
        if (this.fullMatrix == null) {
            this.createFullMatrix();
        }
        var columnCells = [ ];
        for (var r = 0; r < this.fullMatrix.length; r++) {
            var row = this.fullMatrix[r];
            if (row) {
                var cell = row[colIndex];
                if (cell && !com.arrayContains(columnCells, cell.cellRef)) {
                    columnCells.push(cell.cellRef);
                }
            }
        }
        return columnCells;
    },

    /**
     * <p>Get an array of all table cells that intersect the specified table row.</p>
     * <p>Note that even cells that do not start at the given row, but intersect it by
     * their rowspan setting, are returned by this method.</p>
     * @param {Number} rowIndex number of the row (0-based)
     * @return {Array} all rows intersecting the specified column; element properties
     *         are: col, row, colSpan, rowSpan, cellDom)
     */
    getRow: function(rowIndex) {
        var com = CUI.rte.Common;
        if (this.fullMatrix == null) {
            this.createFullMatrix();
        }
        var rowCells = [ ];
        var row = this.fullMatrix[rowIndex];
        if (row) {
            for (var c = 0; c < row.length; c++) {
                var cell = row[c];
                if (cell && !com.arrayContains(rowCells, cell.cellRef)) {
                    rowCells.push(cell.cellRef);
                }
            }
        }
        return rowCells;
    },

    /**
     * Get the next cell that actually starts in the specified row. If a cell starts at
     * the specified row/col, this cell is return.
     * @param {Number} colIndex column position (0-based)
     * @param {Number} rowIndex row position (0-based)
     */
    getRowCellForCoords: function(colIndex, rowIndex) {
        if (this.matrix == null) {
            throw new Error("No basic matrix calculated; use createTableMatrix() before.");
        }
        var row = this.matrix[rowIndex];
        if (!row) {
            return null;
        }
        for (var c = colIndex; c < row.length; c++) {
            if (row[c] != null) {
                return row[c];
            }
        }
        return null;
    },

    /**
     * Get the next cell "on the right" for the specified table coordinates.
     * @param {Number} colIndex column position (0-based)
     * @param {Number} rowIndex row position (0-based)
     */
    getFollowUpCell: function(colIndex, rowIndex) {
        if (this.fullMatrix == null) {
            this.createFullMatrix();
        }
        var row = this.fullMatrix[rowIndex];
        if (!row) {
            return null;
        }
        var baseCell = row[colIndex];
        if (!baseCell) {
            return null;
        }
        baseCell = baseCell.cellRef;
        for (var c = colIndex + 1; c < row.length; c++) {
            if (row[c] && (row[c].cellRef != baseCell)) {
                return row[c].cellRef;
            }
        }
        return null;
    },

    /**
     * <p>Extends the represented table (DOM and matrix representation) by the specified
     * amount of rows and columns.</p>
     * <p>Note that all cells are added with a colspan/rowspan of 1, so this is probably
     * not what the user expects when extending the table via "add column/row" commands.
     * </p>
     * @param {CUI.rte.EditContext} context The edit context
     * @param {Number} cols Number of columns to add
     * @param {Number} rows Number of rows to add
     */
    extendBy: function(context, cols, rows) {
        var tm = CUI.rte.TableMatrix;
        var cellToAdd, cellDef, rowDef, fmRowDef, c, r;
        // first, add missing rows
        var size = this.getTableSize();
        var tBody = this.rows[this.rows.length - 1].parentNode;
        for (r = 0; r < rows; r++) {
            var rowToAdd = context.createElement("tr");
            var row = this.rows.length;
            this.rows.push(rowToAdd);
            tBody.appendChild(rowToAdd);
            rowDef = [ ];
            this.matrix.push(rowDef);
            fmRowDef = null;
            if (this.fullMatrix) {
                fmRowDef = [ ];
                this.fullMatrix.push(fmRowDef);
            }
            for (c = 0; c < size.cols; c++) {
                cellToAdd = tm.createEmptyCell(context);
                rowToAdd.appendChild(cellToAdd);
                cellDef = {
                    "col": c,
                    "row": row,
                    "colSpan": 1,
                    "rowSpan": 1,
                    "cellDom": cellToAdd
                };
                rowDef.push(cellDef);
                if (fmRowDef) {
                    fmRowDef.push({
                        "isOrigin": true,
                        "cellRef": cellDef
                    });
                }
            }
        }
        // add columns
        var rowCnt = this.matrix.length;
        for (r = 0; r < rowCnt; r++) {
            rowDef = this.matrix[r];
            fmRowDef = (this.fullMatrix ? this.fullMatrix[r] : null);
            var rowDom = this.rows[r];
            for (c = 0; c < cols; c++) {
                cellToAdd = tm.createEmptyCell(context, rowDom.lastChild);
                rowDom.appendChild(cellToAdd);
                cellDef = {
                    "col": c + size.cols,
                    "row": row,
                    "colSpan": 1,
                    "rowSpan": 1,
                    "cellDom": cellToAdd
                };
                rowDef[c + size.cols] = cellDef;
                if (fmRowDef) {
                    fmRowDef[c + size.cols] = {
                        "isOrigin": true,
                        "cellRef": cellDef
                    };
                }
            }
        }
    },

    /**
     * <p>Merges the given cell area to a single cell.</p>
     * <p>If the cell area is not mergeable, an Exception is thrown. Also note that the
     * matrix itself is not adjusted accordingly; this operation processes DOM only.</p>
     */
    mergeToSingleCell: function(context, startCol, startRow, cols, rows) {
        var tm = CUI.rte.TableMatrix;
        var com = CUI.rte.Common;
        if (!this.fullMatrix) {
            this.createFullMatrix();
        }
        var endColExcl = startCol + cols;
        var endRowExcl = startRow + rows;
        var endColIncl = endColExcl - 1;
        var endRowIncl = endRowExcl- 1;
        // check corner cases
        var baseCell = this.matrix[startRow][startCol];
        if (!baseCell) {
            throw new Error("Invalid table structure.");
        }
        var topRight = this.fullMatrix[startRow][endColIncl];
        if (!topRight.isOrigin) {
            var topRightDef = topRight.cellRef;
            if ((topRightDef.row < startRow)
                    && ((topRightDef.col + topRightDef.colSpan) > endColExcl)) {
                throw new Error("Invalid table structure.");
            }
        }
        var bottomLeft = this.fullMatrix[endRowIncl][startCol];
        if (!bottomLeft.isOrigin) {
            var bottomLeftDef = bottomLeft.cellRef;
            if ((bottomLeftDef.col < startCol)
                    && ((bottomLeftDef.row + bottomLeftDef.rowSpan) > endRowExcl)) {
                throw new Error("Invalid table structure.");
            }
        }
        var bottomRight = this.fullMatrix[endRowIncl][endColIncl];
        if (!bottomRight.isOrigin) {
            var bottomRightDef = bottomRight.cellRef;
            if (((bottomRightDef.col + bottomRightDef.colSpan) > endColExcl)
                    && (bottomRightDef.row + bottomRightDef.rowSpan > endRowExcl)) {
                throw new Error("Invalid table structure.");
            }
        }
        for (var r = 0; r < rows; r++) {
            var row = r + startRow;
            var rowToProcess = this.fullMatrix[row];
            for (var c = 0; c < cols; c++) {
                var col = c + startCol;
                var cell = rowToProcess[col];
                var cellDef = cell.cellRef;
                var cellDom = cellDef.cellDom;
                var removeChild = false;
                if (!cell.isOrigin) {
                    if ((c == 0) && (cellDef.col < col)) {
                        com.setAttribute(cellDom, "colspan",
                                cellDef.col + cellDef.colSpan - col);
                    }
                    if ((r == 0) && (cellDef.row < row)) {
                        com.setAttribute(cellDom, "rowSpan",
                                cellDef.row + cellDef.rowSpan - row);
                    }
                } else {
                    removeChild = (c != 0) || (r != 0);
                    if ((cellDef.col + cellDef.colSpan) > endColExcl) {
                        removeChild = false;
                        com.setAttribute(cellDom, "colspan",
                                cellDef.col + cellDef.colSpan - endColExcl);
                        com.removeAllChildren(cellDom);
                        tm.addCellPlaceholder(context, cellDom);
                    }
                    if ((cellDef.row + cellDef.rowSpan) > endRowExcl) {
                        removeChild = false;
                        var newRowSpan = cellDef.row + cellDef.rowSpan - endRowExcl;
                        var rowDelta = cellDef.rowSpan - newRowSpan;
                        com.setAttribute(cellDom, "rowspan", newRowSpan);
                        cellDom.parentNode.removeChild(cellDom);
                        com.removeAllChildren(cellDom);
                        tm.addCellPlaceholder(context, cellDom);
                        var insertCellDef = this.getFollowUpCell(col, row + rowDelta);
                        var rowDom = this.rows[row + rowDelta];
                        if (insertCellDef) {
                            rowDom.insertBefore(cellDom, insertCellDef.cellDom);
                        } else {
                            rowDom.appendChild(cellDom);
                        }
                    }
                }
                if (removeChild) {
                    cellDom.parentNode.removeChild(cellDom);
                }
            }
        }
        var baseDom = baseCell.cellDom;
        com.setAttribute(baseDom, "colspan", cols);
        com.setAttribute(baseDom, "rowspan", rows);
        return baseDom;
    },

    /**
     * <p>Optimizes the column and row spans of the table.</p>
     * <p>Both the abstraction and the DOM get optimized.</p>
     */
    optimizeSpans: function() {
        if (this.matrix == null) {
            throw new Error("No basic matrix calculated; use createTableMatrix() before.");
        }
        var com = CUI.rte.Common;
        var tableSize = this.getTableSize();
        var rows = tableSize.rows;
        var cols = tableSize.cols;
        var c, col, r, row, spansToMerge;

        // optimize column spans - we're marking each column where a cell begins. If there
        // are columns where no cell begins, the colspans of the preceding cells can be
        // adjusted and the column therefore implicitly deleted
        var colStarts = [ ];
        for (r = 0; r < rows; r++) {
            row = this.matrix[r];
            for (c = 0; c < cols; c++) {
                if (row[c]) {
                    colStarts[c] = true;
                }
            }
        }
        c = 0;
        while (c < cols) {
            var baseCol = c;
            spansToMerge = 0;
            while ((c < cols) && !colStarts[c++]) {
                spansToMerge++;
            }
            if (spansToMerge > 0) {
                var colsToAdjust = this.getColumn(baseCol);
                for (r = 0; r < colsToAdjust.length; r++) {
                    var colToMerge = colsToAdjust[r];
                    colToMerge.colSpan -= spansToMerge;
                    if (colToMerge.colSpan > 1) {
                        com.setAttribute(colToMerge.cellDom, "colspan", colToMerge.colSpan);
                    } else {
                        com.removeAttribute(colToMerge.cellDom, "colspan");
                    }
                }
            }
        }

        // optimize row spans - works basically the same as optimizing column spans
        // (we could also use empty DOM rows for determining optimizable row spans, but
        // we stay in the TableMatrix system for now)
        var rowStarts = [ ];
        for (c = 0; c < cols; c++) {
            col = this.getColumn(c);
            for (r = 0; r < col.length; r++) {
                rowStarts[col[r].row] = true;
            }
        }
        r = 0;
        while (r < rows) {
            var baseRow = r;
            spansToMerge = 0;
            while ((r < rows) && !rowStarts[r++]) {
                spansToMerge++;
            }
            if (spansToMerge > 0) {
                var rowsToAdjust = this.getRow(baseRow);
                for (c = 0; c < rowsToAdjust.length; c++) {
                    var rowToMerge = rowsToAdjust[c];
                    rowToMerge.rowSpan -= spansToMerge;
                    if (rowToMerge.rowSpan > 1) {
                        com.setAttribute(rowToMerge.cellDom, "rowspan", rowToMerge.rowSpan);
                    } else {
                        com.removeAttribute(rowToMerge.cellDom, "rowspan");
                    }
                }
            }
        }

        // finally, remove empty rows - by adjusting the rowspan settings, those can
        // finally be removed
        for (r = this.rows.length - 1; r >= 0; r--) {
            var rowToCheck = this.rows[r];
            if (rowToCheck.childNodes.length == 0) {
                rowToCheck.parentNode.removeChild(rowToCheck);
                this.rows.splice(r, 1);
                this.matrix.splice(r, 1);
                var mr, mc, rowToAdjust;
                for (mr = r; mr < this.matrix.length; mr++) {
                    rowToAdjust = this.matrix[mr];
                    for (mc = 0; mc < rowToAdjust.length; mc++) {
                        if (rowToAdjust[mc]) {
                            rowToAdjust[mc].row--;
                        }
                    }
                }
                if (this.fullMatrix) {
                    this.fullMatrix.splice(r, 1);
                }
            }
        }
    }

});

/**
 * @private
 * @static
 */
CUI.rte.TableMatrix.createEmptyCell = function(context, refNode) {
    var tagName = "td";
    if (typeof(refNode) == "string") {
        tagName = refNode;
    } else if (refNode) {
        tagName = refNode.tagName;
    }
    var tdDom = context.createElement(tagName);
    var placeholder = CUI.rte.DomProcessor.createEmptyLinePlaceholder(context, false);
    if (placeholder) {
        tdDom.appendChild(placeholder);
    }
    return tdDom;
};

/**
 * @private
 * @static
 */
CUI.rte.TableMatrix.addCellPlaceholder = function(context, cellDom) {
    cellDom.appendChild(context.createTextNode(CUI.rte.DomProcessor.NBSP));
};

/**
 * @private
 * @static
 */
CUI.rte.TableMatrix.createEmptyCellMarkup = function() {
    var com = CUI.rte.Common;
    if (com.ua.isIE) {
        return "<td></td>";
    }
    return "<td><br " + com.BR_TEMP_ATTRIB + "=\"brEOB\"></td>";
};

/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.ListUtils
 * @static
 * @private
 * The ListUtils provides utility functions for handling lists.
 */
CUI.rte.ListUtils = function() {

    var com = CUI.rte.Common;

    var dpr = CUI.rte.DomProcessor;

    return {

        // --- selection-related stuff -----------------------------------------------------

        /**
         * <p>Postprocesses a list of selected items that was created from a
         * {@link CUI.rte.NodeList NodeList}, using the
         * {@link CUI.rte.NodeList#getTags getTags} method.</p>
         * <p>This is required to remove parent items that are included in the node list
         * (as they are actually part of the DOM structure), but are not really selected
         * (instead, one or more nested list item is selected).</p>
         * @param {Object[]} listItems Array containing list items, as created by
         *        {@link CUI.rte.NodeList#getTags}
         */
        postprocessSelectedItems: function(listItems) {
            var nodeCnt = listItems.length;
            for (var n = nodeCnt - 1; n >= 0; n--) {
                var node = listItems[n];
                if (!node.isAncestor) {
                    var mustRemove = true;
                    var children = node.childNodes;
                    if (children) {
                        var childCnt = children.length;
                        for (var c = 0; c < childCnt; c++) {
                            var childDom = children[c].dom;
                            if (!com.isTag(childDom, com.LIST_TAGS)) {
                                mustRemove = false;
                                break;
                            }
                        }
                    } else {
                        // empty list tags must also be kept (may occur on IE)
                        mustRemove = false;
                    }
                    if (mustRemove) {
                        listItems.splice(n, 1);
                    }
                }
            }
        },


        // --- processing-related stuff ----------------------------------------------------

        /**
         * <p>Creates a new list from the specified list of edit blocks.</p>
         * <p>This method handles auxiliary root correctly by adding their content as
         * separate lists.</p>
         * @param {CUI.rte.EditContext} context The edit context
         * @param {HTMLElement[]} blockList List with edit blocks to be used for creating
         *        the list
         * @param {String} listType The list type ("ul", "ol")
         */
        createList: function(context, blockList, listType) {
            var lut = CUI.rte.ListUtils;
            // preprocess if a table cell is reported as the only edit block
            if ((blockList.length == 1) && com.isTag(blockList[0], com.TABLE_CELLS)) {
                var tempBlock = context.createElement("div");
                com.moveChildren(blockList[0], tempBlock);
                blockList[0].appendChild(tempBlock);
                blockList[0] = tempBlock;
            }
            // simplify block list by using lists instead of their respective list items
            var blockCnt = blockList.length;
            for (var b = 0; b < blockCnt; b++) {
                if (com.isTag(blockList[b], "li")) {
                    var listNode = blockList[b].parentNode;
                    blockList[b] = listNode;
                    for (var b1 = 0; b1 < b; b1++) {
                        if (blockList[b1] == listNode) {
                            blockList[b] = null;
                            break;
                        }
                    }
                }
            }
            // common list creation
            var listDom = context.createElement(listType);
            blockCnt = blockList.length;
            for (b = 0; b < blockCnt; b++) {
                var blockToProcess = blockList[b];
                if (blockToProcess) {
                    var mustRecurse = com.isTag(blockToProcess, dpr.AUXILIARY_ROOT_TAGS);
                    if (!mustRecurse) {
                        if (listDom.childNodes.length == 0) {
                            // first, insert the list
                            blockToProcess.parentNode.insertBefore(listDom, blockToProcess);
                        }
                        if (!com.isTag(blockToProcess, com.LIST_TAGS)) {
                            // normal blocks
                            var listItemDom = context.createElement("li");
                            listDom.appendChild(listItemDom);
                            com.moveChildren(blockToProcess, listItemDom, 0, true);
                            blockToProcess.parentNode.removeChild(blockToProcess);
                        } else {
                            // pre-existing list
                            com.moveChildren(blockToProcess, listDom, 0, true);
                            blockToProcess.parentNode.removeChild(blockToProcess);
                        }
                    } else {
                        // create list recursively
                        var subBlocks = [ ];
                        var sbCnt = blockToProcess.childNodes.length;
                        for (var c = 0; c < sbCnt; c++) {
                            var subBlock = blockToProcess.childNodes[c];
                            if (com.isTag(subBlock, com.EDITBLOCK_TAGS)) {
                                subBlocks.push(subBlock);
                            } else if (com.isTag(com.BLOCK_TAGS)) {
                                // todo nested tables
                            }
                        }
                        if (subBlocks.length == 0) {
                            subBlocks.push(blockToProcess);
                        }
                        lut.createList(context, subBlocks, listType);
                        // start a new list if a non-listable tag has been encountered
                        listDom = context.createElement(listType);
                    }
                }
            }
            // check if we can join adjacent lists
            var prevSib = listDom.previousSibling;
            if (prevSib && com.isTag(prevSib, listType)) {
                com.moveChildren(listDom, prevSib, 0, true);
                listDom.parentNode.removeChild(listDom);
                listDom = prevSib;
            }
            var nextSib = listDom.nextSibling;
            if (nextSib && com.isTag(nextSib, listType)) {
                com.moveChildren(nextSib, listDom, 0, true);
                nextSib.parentNode.removeChild(nextSib);
            }
        },

        /**
         * Converts the specified list item (which must be part of a top-level list) to
         * a edit block of the specified type.
         * @param {CUI.rte.EditContext} context The edit context
         * @param {HTMLElement} liDom The list item to be converted
         * @param {String} tagName The edit block tag to convert the item to
         * @param {Object} attribs Attribute definition for the edit block tag
         */
        convertListItem: function(context, liDom, tagName, attribs) {
            var itemIndex = com.getChildIndex(liDom);
            var originList = liDom.parentNode;
            var itemCnt = originList.childNodes.length;
            var pNode = dpr.createNode(context, tagName, attribs);
            com.moveChildren(liDom, pNode);
            originList.removeChild(liDom);
            if (itemIndex == 0) {
                // first item - can be simply removed without splitting the list in two
                originList.parentNode.insertBefore(pNode, originList);
            } else if (itemIndex == (itemCnt - 1)) {
                // last item
                originList.parentNode.insertBefore(pNode, originList.nextSibling);
            } else {
                // split list
                var splitList = originList.cloneNode(false);
                com.moveChildren(originList, splitList, itemIndex);
                originList.parentNode.insertBefore(splitList, originList.nextSibling);
                originList.parentNode.insertBefore(pNode, splitList);
            }
            return pNode;
        },

        /**
         * <p>Gets the list item (if available) the specified DOM element is contained in.
         * </p>
         * <p>If the specified DOM element is a list item, the DOM element (and not its
         * "super item") is returned.</p>
         * @param {CUI.rte.EditContext} context The edit context
         * @param {HTMLElement} dom The DOM element to determine the list item for
         * @return {HTMLElement} The respective list item; null if the DOM element is not
         *         contained in a list item
         */
        getItemForDom: function(context, dom) {
            while (dom) {
                if (com.isTag(dom, "li")) {
                    return dom;
                }
                dom = com.getParentNode(context, dom);
            }
            return null;
        },

        /**
         * <p>Gets the list the specified list item is contained in.</p>
         * <p>The specified list item may be any DOM element of the corresponding list item.
         * If a list is specified as list item, the "super list" (if available) is returned.
         * </p>
         * @param {CUI.rte.EditContext} context The edit context
         * @param {HTMLElement} itemDom The list item to determine the corresponding list
         *        for; null if the DOM element is not contained in a list
         */
        getListForItem: function(context, itemDom) {
            itemDom = CUI.rte.ListUtils.getItemForDom(context, itemDom);
            var listDom = (itemDom ? com.getParentNode(context, itemDom) : null);
            if (listDom && !com.isTag(listDom, com.LIST_TAGS)) {
                listDom = null;
            }
            return listDom;
        },

        /**
         * Gets the top-level list the specified DOM element is part of.
         * @param {CUI.rte.EditContext} context The edit context
         * @param {HTMLElement} dom The DOM element
         * @return {HTMLElement} The top-level list element; null if the specified DOM
         *         element is not part of a list
         */
        getTopListForItem: function(context, dom) {
            var listDom = null;
            while (dom) {
                if (com.isTag(dom, com.LIST_TAGS)) {
                    listDom = dom;
                }
                dom = com.getParentNode(context, dom);
            }
            return listDom;
        },

        /**
         * Gets the nesting level of the specified DOM element.
         * @param {CUI.rte.EditContext} context The edit context
         * @param {HTMLElement} dom The DOM element
         * @return {Number} Nesting level (0 for top-level list; -1 if the specified DOM
         *         element is not part of a list
         */
        getNestingLevel: function(context, dom) {
            var nestingLevel = -1;
            while (dom) {
                if (com.isTag(dom, com.LIST_TAGS)) {
                    nestingLevel++;
                }
                dom = com.getParentNode(context, dom);
            }
            return nestingLevel;
        },

        /**
         * Checks if the specified DOM element is part of a top-level list.
         * @param {CUI.rte.EditContext} context The edit context
         * @param {HTMLElement} dom The DOM element
         * @return {Boolean} True if the DOM element is part of a top-level list
         */
        isTopLevelList: function(context, dom) {
            return (CUI.rte.ListUtils.getNestingLevel(context, dom) == 0);
        },

        /**
         * Checks if the specified DOM element is (part of) the very first list item of its
         * top-level list.
         * @param {CUI.rte.EditContext} context
         * @param {HTMLElement} dom The DOM element to check
         * @return {Boolean} true if the specified DOM element is the very first list item
         *         of its top-level list
         */
        isFirstListItem: function(context, dom) {
            var lut = CUI.rte.ListUtils;
            var tll = lut.getTopListForItem(context, dom);
            if (tll == null) {
                return false;
            }
            var itemDom = lut.getItemForDom(context, dom);
            return (tll.childNodes.length > 0) && (tll.childNodes[0] == itemDom);
        },

        /**
         * Checks if the specified DOM element is (part of) the very last list item of its
         * top-level list.
         * @param {CUI.rte.EditContext} context
         * @param {HTMLElement} dom The DOM element to check
         * @return {Boolean} true if the specified DOM element is the very last list item
         *         of its top-level list
         */
        isLastListItem: function(context, dom) {
            var lut = CUI.rte.ListUtils;
            var tll = lut.getTopListForItem(context, dom);
            var lastListNode = com.getLastChild(tll);
            if (lastListNode == null) {
                return false;
            }
            var lastItemNode = com.getTagInPath(context, lastListNode, "li");
            return (lastItemNode == dom);
        },

        /**
         * Moves the content of the specified list item to the specfied destination
         * element.
         * @param {HTMLElement} srcItem The list item to move content from
         * @param {HTMLElement} destDom The DOM element to move content to
         */
        moveItemContent: function(srcItem, destDom) {
            while (srcItem.childNodes.length > 0) {
                var childToMove = srcItem.childNodes[0];
                srcItem.removeChild(childToMove);
                destDom.appendChild(childToMove);
            }
        },

        /**
         * Checks if the specified list item has content other than nested lists.
         * @param {HTMLElement} itemDom The DOM element representing the list item
         * @return {Boolean} True if the specified list item has content other than
         *         nested lists
         */
        hasItemContent: function(itemDom) {
            var childCnt = itemDom.childNodes.length;
            for (var c = 0; c < childCnt; c++) {
                var childToProcess = itemDom.childNodes[c];
                if (!com.isTag(childToProcess, com.LIST_TAGS)) {
                    return true;
                }
            }
            return false;
        },

        /**
         * <p>Checks if the specified list is empty.</p>
         * <p>A list is considered empty if it is actually empty or all items and nested
         * lists are empty.</p>
         * @param {CUI.rte.EditContext} context The edit context
         * @param {HTMLElement} listDom The list's DOM element
         * @return {Boolean} True if the specified list is empty
         */
        isListEmpty: function(context, listDom) {
            if (listDom.childNodes.length == 0) {
                return true;
            }
            var itemCnt = listDom.childNodes.length;
            for (var i = 0; i < itemCnt; i++) {
                var itemToCheck = listDom.childNodes[i];
                if (com.isTag(itemToCheck, "li")) {
                    var childCnt = itemToCheck.childNodes.length;
                    for (var c = 0; c < childCnt; c++) {
                        var nodeToCheck = itemToCheck.childNodes[c];
                        if (com.isTag(nodeToCheck, com.LIST_TAGS)) {
                            var isListEmpty = CUI.rte.ListUtils.isListEmpty(context,
                                    nodeToCheck);
                            if (!isListEmpty) {
                                return false;
                            }
                        } else {
                            return false;
                        }
                    }
                    // IE might have empty items that count as content, in that case
                    // the list is not really empty
                    if ((com.ua.isIE && childCnt == 0)) {
                        return false;
                    }
                }
            }
            return true;
        },

        /**
         * Checks if the specified list item is empty (has no content or only empty
         * nested lists).
         * @param {CUI.rte.EditContext} context The edit context
         * @param {HTMLElement} dom The list item to check
         */
        isItemEmpty: function(context, dom) {
            var lut = CUI.rte.ListUtils;
            dom = lut.getItemForDom(context, dom);
            var childCnt = dom.childNodes.length;
            for (var c = 0; c < childCnt; c++) {
                var childToProcess = dom.childNodes[c];
                if (com.isTag(childToProcess, com.LIST_TAGS)) {
                    if (!lut.isListEmpty(context, childToProcess)) {
                        return false;
                    }
                } else {
                    return false;
                }
            }
            return true;
        },

        /**
         * Cleans up the specified list by removing empty list items (and empty nested
         * lists as well).
         * @param {CUI.rte.EditContext} context The edit context
         * @param {HTMLElement} listDom The list to be cleaned
         * @param {Boolean} removeHelperAttribs True if helper attributes on list items have
         *        also to be removed
         */
        cleanUpList: function(context, listDom, removeHelperAttribs) {
            var lut = CUI.rte.ListUtils;
            var itemCnt = listDom.childNodes.length;
            for (var i = itemCnt - 1; i >= 0; i--) {
                var itemToProcess = listDom.childNodes[i];
                var childCnt = itemToProcess.childNodes.length;
                for (var c = childCnt - 1; c >= 0; c--) {
                    var childToProcess = itemToProcess.childNodes[c];
                    if (com.isTag(childToProcess, com.LIST_TAGS)) {
                        lut.cleanUpList(context, childToProcess, removeHelperAttribs);
                    }
                }
                if (lut.isItemEmpty(context, itemToProcess)
                        && (com.isAttribDefined(itemToProcess, lut.REMOVAL_MARKER)
                            || com.isAttribDefined(itemToProcess, lut.CLONED_MARKER))) {
                    listDom.removeChild(itemToProcess);
                } else if (removeHelperAttribs) {
                    com.removeAttribute(itemToProcess, lut.REMOVAL_MARKER);
                    com.removeAttribute(itemToProcess, lut.CLONED_MARKER);
                }
            }
            if (lut.isListEmpty(context, listDom)) {
                listDom.parentNode.removeChild(listDom);
            }
        },

        /**
         * Checks if both specified DOM elements are lists and both determine the same
         * list type.
         * @param {HTMLElement} dom1 First DOM element; may be null
         * @param {HTMLElement} dom2 Second DOM element; may be null
         * @return {Boolean} True if both elements are lists and the list type is the same
         */
        isSameType: function(dom1, dom2) {
            if (dom1 && dom2) {
                if (com.isTag(dom1, com.LIST_TAGS)) {
                    return (dom1.tagName.toLowerCase() == dom2.tagName.toLowerCase());
                }
            }
            return false;
        },

        /**
         * Gets all nested lists of the specified item if available.
         * @param {HTMLElement} itemDom The item's DOM element
         * @return {HTMLElement[]} List with all nested lists
         */
        getNestedLists: function(itemDom) {
            var nestedLists = [ ];
            var childCnt = itemDom.childNodes.length;
            for (var c = 0; c < childCnt; c++) {
                var childToCheck = itemDom.childNodes[c];
                if (com.isTag(childToCheck, com.LIST_TAGS)) {
                    nestedLists.push(childToCheck);
                }
            }
            return nestedLists;
        },

        /**
         * Removes the specified item from the list.
         * @param {CUI.rte.EditContext} context The edit context
         * @param {HTMLElement[]} items Array of items to unlist; items must be adjacent
         *        (but may be on different hierarchical levels)
         * @param {Boolean} keepStructure True if the list structure should be kept if
         *        list splitting is required
         */
        unlistItems: function(context, items, keepStructure) {
            var lut = CUI.rte.ListUtils;
            var itemCnt = items.length;
            if (itemCnt == 0) {
                return;
            }
            var firstItem = items[0];
            var lastItem = items[itemCnt - 1];
            var tll = lut.getTopListForItem(context, firstItem.parentNode);
            var isFirstItemOfList = lut.isFirstListItem(context, firstItem);
            var isLastItemOfList = lut.isLastListItem(context, lastItem);
            var splitList = null;
            var insertRef = tll;
            for (var i = 0; i < itemCnt; i++) {
                // move item content to paragraph & insert paragraph after top level list
                var para = context.createElement("p");
                var item = items[i];
                com.setAttribute(item, lut.REMOVAL_MARKER, "true");
                var childCnt = item.childNodes.length;
                for (var c = childCnt - 1; c >= 0; c--) {
                    var childToMove = item.childNodes[c];
                    if (!com.isTag(childToMove, com.LIST_TAGS)) {
                        item.removeChild(childToMove);
                        com.insertBefore(para, childToMove, para.firstChild);
                    }
                }
                if (isFirstItemOfList) {
                    com.insertBefore(tll.parentNode, para, tll);
                    splitList = tll;
                } else {
                    com.insertBefore(tll.parentNode, para, insertRef.nextSibling);
                    insertRef = para;
                }
                dpr.fixEmptyEditingBlockIE(context, para);
            }
            var listToClone = lastItem.parentNode;
            // detect content that has to be additionally moved to the split list
            var listIndex = com.getChildIndex(listToClone);
            var elementsToMove = [ ];
            if (lut.getNestingLevel(context, listToClone) > 0) {
                var listParent = listToClone.parentNode;
                for (var m = listIndex + 1; m < listParent.childNodes.length; m++) {
                    elementsToMove.push(listParent.childNodes[m]);
                }
            }
            // split list if necessary
            if (!isLastItemOfList && !isFirstItemOfList) {
                var deepestItem = null;
                var isEmptyDeepestItem = false;
                while (listToClone) {
                    var clonedList = listToClone.cloneNode(false);
                    var clonedItem = context.createElement("li");
                    com.setAttribute(clonedItem, lut.CLONED_MARKER, "true");
                    if (deepestItem == null) {
                        deepestItem = clonedItem;
                        if (lastItem.childNodes.length == 0) {
                            isEmptyDeepestItem = true;
                        } else {
                            lut.moveItemContent(lastItem, deepestItem);
                        }
                    }
                    clonedList.appendChild(clonedItem);
                    if (splitList) {
                        clonedItem.appendChild(splitList);
                    }
                    splitList = clonedList;
                    listToClone = com.getParentNode(context, listToClone);
                    if (com.isTag(listToClone, "li")) {
                        listToClone = listToClone.parentNode;
                    } else {
                        listToClone = null;
                    }
                }
                // move content detected beforehand to split list
                var moveTarget = deepestItem.parentNode;
                for (m = 0; m < elementsToMove.length; m++) {
                    var domToMove = elementsToMove[m];
                    domToMove.parentNode.removeChild(domToMove);
                    com.insertBefore(moveTarget.parentNode, domToMove,
                            moveTarget.nextSibling);
                    moveTarget = domToMove;
                }
                // insert the split list
                com.insertBefore(para.parentNode, splitList, para.nextSibling);
                var copyItem = lastItem;
                var copyDest = deepestItem;
                while (copyItem) {
                    var childIndex = com.getChildIndex(copyItem);
                    var copyList = copyItem.parentNode;
                    var destList = copyDest.parentNode;
                    for (c = copyList.childNodes.length - 1; c > childIndex ; c--) {
                        var itemToMove = copyList.childNodes[c];
                        copyList.removeChild(itemToMove);
                        insertRef = (destList.childNodes.length > 1
                                ? destList.childNodes[1] : null);
                        com.insertBefore(destList, itemToMove, insertRef);
                    }
                    if ((copyDest == deepestItem) && isEmptyDeepestItem) {
                        destList.removeChild(copyDest);
                    }
                    copyItem = com.getParentNode(context, copyList);
                    if (!com.isTag(copyItem, "li")) {
                        copyItem = null;
                    }
                    copyDest = com.getParentNode(context, destList);
                }
            }
            // remove item & now-empty (nested) lists
            lut.cleanUpList(context, tll, false);
            if ((splitList != null) && (splitList != tll)) {
                lut.cleanUpList(context, splitList, false);
            }
            if (!isLastItemOfList && (splitList != null)) {
                // post-process structure to get a valid list again
                var itemToProcess = com.getFirstChild(splitList);
                itemToProcess = com.getTagInPath(context, itemToProcess, "li");
                if (itemToProcess) {
                    if (lut.isTopLevelList(context, itemToProcess)
                            && lut.isItemEmpty(context, itemToProcess)
                            && com.isAttribDefined(itemToProcess, lut.CLONED_MARKER)) {
                        // simply remove empty item if top-level (& clean up afterwards)
                        itemToProcess.parentNode.removeChild(itemToProcess);
                        lut.cleanUpList(context, splitList, true);
                    } else if (keepStructure) {
                        // keeping the list's structure intact: insert &nbsp; for all
                        // in-between hierarchical levels
                        while (itemToProcess) {
                            if (!lut.hasItemContent(itemToProcess)) {
                                com.insertBefore(itemToProcess,
                                        context.createTextNode(dpr.NBSP),
                                        itemToProcess.firstChild);
                            }
                            itemToProcess = com.getParentNode(context, itemToProcess);
                            while (itemToProcess && !com.isTag(itemToProcess, "li")) {
                                itemToProcess = com.getParentNode(context,
                                        itemToProcess);
                            }
                            lut.cleanUpList(context, splitList, true);
                        }
                    } else {
                        // adjusting the split list's structure - the algorithm used here
                        // works as follows:
                        // 1. start with the list that contains the first "real" list item
                        //    (may be nested deep in the hierarchy) -> source list.
                        // 2. insert the items of that list at the beginning of the
                        //    top-level list -> dest list
                        // 3. process the parent list of the previous source list
                        // 4. a) insert that parent list to the last item (shallow) of the
                        //       previous source list (that is now a top-level item, if
                        //       source and destination list are on different nesting levels
                        //    b) Merge source and destination list items otherwise
                        // 5. repeat 3 and 4 until the source list has reached nesting level
                        //    0 or both source and destination have reached the same
                        //    nesting level (which is step 4b)
                        // 6. clean up leftovers
                        var listsToClean = [ splitList ];
                        insertRef = splitList;
                        var deepestItemList = lut.getListForItem(context, itemToProcess);
                        var deepestListParent = lut.getItemForDom(context, deepestItemList);
                        if (deepestListParent == null) {
                            return;
                        }
                        var listToMove, l, moveDestList, mustMove;
                        var listsToMove = lut.getNestedLists(deepestListParent);
                        while (insertRef) {
                            var listCnt = listsToMove.length;
                            var baseListToMove = listsToMove[0];
                            var srcLevel = lut.getNestingLevel(context, baseListToMove);
                            // #5
                            if (srcLevel == 0) {
                                break;
                            }
                            var destLevel = lut.getNestingLevel(context, insertRef);
                            var parentList = lut.getListForItem(context, baseListToMove);
                            if (srcLevel == destLevel) {
                                // #4b/#5
                                moveDestList = (com.isTag(insertRef, "li")
                                        ? insertRef.parentNode : insertRef);
                                for (l = 0; l < listCnt; l++) {
                                    listToMove = listsToMove[l];
                                    mustMove = false;
                                    if (l == (listCnt - 1)) {
                                        if (lut.isSameType(listToMove, moveDestList)) {
                                            mustMove = true;
                                        }
                                    }
                                    if (mustMove) {
                                        com.moveChildren(listToMove, moveDestList, 0, true);
                                    } else {
                                        listToMove.parentNode.removeChild(listToMove);
                                        com.insertBefore(moveDestList.parentNode,
                                            listToMove, moveDestList.nextSibling);
                                        moveDestList = listToMove;
                                    }
                                }
                                break;
                            } else {
                                var lastList = listsToMove[listCnt - 1];
                                lastItem = lastList.childNodes[
                                        lastList.childNodes.length - 1];
                                if (com.isTag(insertRef, "li")) {
                                    // #4a
                                    for (l = 0; l < listCnt; l++) {
                                        listToMove = listsToMove[l];
                                        listToMove.parentNode.removeChild(listToMove);
                                        insertRef.appendChild(listToMove);
                                    }
                                } else {
                                    // #2
                                    moveDestList = insertRef;
                                    for (l = 0; l < listCnt; l++) {
                                        listToMove = listsToMove[l];
                                        mustMove = false;
                                        if (l == (listCnt - 1)) {
                                            if (lut.isSameType(listToMove, moveDestList)) {
                                                mustMove = true;
                                            }
                                        }
                                        if (mustMove) {
                                            com.moveChildren(listToMove, moveDestList);
                                        } else {
                                            listToMove.parentNode.removeChild(listToMove);
                                            com.insertBefore(moveDestList.parentNode,
                                                listToMove, moveDestList);
                                            listsToClean.push(listToMove);
                                        }
                                    }
                                }
                                // set insert ref to the last shallow item
                                insertRef = lastItem;
                            }
                            // #3 (use parent list(s))
                            if (lut.getNestingLevel(context, parentList) == 0) {
                                listsToMove = [ parentList ];
                            } else {
                                listsToMove = lut.getNestedLists(lut.getItemForDom(context,
                                        parentList));
                            }
                        }
                        // #6
                        for (l = 0; l < listsToClean.length; l++) {
                            lut.cleanUpList(context, listsToClean[l], true);
                        }
                    }
                }
            }
        },

        /**
         * Checks if the specified node/offset (as provided by a processing selection)
         * determines the position before a nested list.
         * @param {CUI.rte.EditContext} context The edit context
         * @param {HTMLElement} node The node
         * @param {Number} offset The offset
         * @return {Boolean} True if the specified node/offset determines the position
         *         before a nested list
         */
        isPositionBeforeNestedList: function(context, node, offset) {
            var editBlock = dpr.getEditBlock(context, node);
            if (!com.isTag(editBlock, "li")) {
                return false;
            }
            if (node.nodeType == 3) {
                var charCnt = com.getNodeCharacterCnt(node);
                if (charCnt > 0) {
                    if (offset < charCnt) {
                        return false;
                    }
                }
            } else if (com.isOneCharacterNode(node)) {
                if (offset != 0) {
                    return false;
                }
            }
            var nextChild = com.getNextNode(context, node);
            return com.isTag(nextChild, com.LIST_TAGS)
                    && (dpr.getEditBlock(context, nextChild) == editBlock);
        },

        /**
         * Marker attribute for empty list items that might be removed on clean up after
         * unlisting
         * @private
         * @type String
         */
        REMOVAL_MARKER: CUI.rte.Common.RTE_ATTRIB_PREFIX + "_invalid",

        /**
         * Marker attribute for list items that were cloned when an original list has been
         * split during unlisting (an) item(s)
         * @private
         * @type String
         */
        CLONED_MARKER: CUI.rte.Common.RTE_ATTRIB_PREFIX + "_cloned"

    };

}();
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

// todo synchronize DOM & data model
// ListRepresentation and ListRepresenation.Item should get suitable processing methods
// that handle both data model and DOM manipulation, which would make the code much more
// readable as currently is (and could improve performance, as there was no more need
// to recreate the representation from DOM after processing it)

/**
 * @class CUI.rte.ListRepresentation
 * @private
 * <p>This class implements an abstract representation of a list for easier processing
 * &amp; editing (especially hierarchical management, such as indenting and outdenting
 * multiple list items and ensuring correct nesting of multi-level lists).</p>
 * <p>Note that most processing methods of this class do not adjust the data model (but only
 * the DOM), hence the list representation has to be recreated before another processing is
 * executed on the represented list.</p>
 * @constructor
 * Creates a new ListRepresentation.
 * @param {CUI.rte.ListRepresentation} parentList The parent list (if any)
 * @param {Boolean} isCorrectHierarchy (optional) True if the list is correctly nested
 *        (defaults to true)
 */
CUI.rte.ListRepresentation = new Class({

    toString: "ListRepresentation",

    /**
     * Parent list (if available)
     * @type CUI.rte.ListRepresentation
     * @private
     */
    parentList: null,

    /**
     * The DOM node representing the list.
     * @type HTMLElement
     * @private
     */
    listDom: null,

    /**
     * Array containing the items of the list.
     * @type CUI.rte.ListRepresentation.Item[]
     * @private
     */
    items: null,

    /**
     * Flag if the list is correctly included in the list hierarchy (correctly nested)
     * @type Boolean
     * @private
     */
    isCorrectHierarchy: false,

    construct: function(parentList, isCorrectHierarchy) {
        this.parentList = parentList;
        this.items = [ ];
        this.isCorrectHierarchy = isCorrectHierarchy !== false;
    },

    /**
     * Creates a list representation from the specified list DOM object.
     * @param {HTMLElement} listDom The DOM element of the list from which the list
     *        representation is to be build; must be of type "ul" or "ol"
     */
    fromList: function(listDom) {
        var com = CUI.rte.Common;
        this.items.length = 0;
        this.listDom = listDom;
        var children = listDom.childNodes;
        var childCnt = children.length;
        var validItem = null;
        for (var c = 0; c < childCnt; c++) {
            var childToProcess = children[c];
            if (com.isTag(childToProcess, com.LIST_TAGS)) {
                // detected an invalidly nested list
                if (validItem == null) {
                    validItem = new CUI.rte.ListRepresentation.Item(this, this.listDom);
                    this.items.push(validItem);
                }
                var subList = new CUI.rte.ListRepresentation(this, false);
                subList.fromList(childToProcess);
                validItem.addSubList(subList);
            } else if (com.isTag(childToProcess, "li")) {
                var item = new CUI.rte.ListRepresentation.Item(this, childToProcess);
                this.items.push(item);
                item.detectSubLists();
                validItem = item;
            }
        }
    },

    /**
     * <p>Creates a list representation of the top-level list the specified item is part of.
     * </p>
     * <p>Note that actually the top-level list is used - not the list that actually
     * contains the list item if the item is part of a nested list.</p>
     * @param {CUI.rte.EditContext} context The edit context
     * @param {HTMLElement} itemDom The DOM element representing the list item (must be of
     *        type "li")
     */
    fromItem: function(context, itemDom) {
        var listDom = CUI.rte.ListUtils.getTopListForItem(context, itemDom);
        if (listDom == null) {
            throw new Error("Could not detect list node.");
        }
        this.fromList(listDom);
    },

    /**
     * <p>Gets the {@link CUI.rte.ListRepresentation.Item Item} that represents the
     * specified (DOM) list item.</p>
     * <p>The item is looked up recursively - you can always use the top-most list
     * representation to get a list item that is contained in a nested list.</p>
     * @param {HTMLElement} dom The DOM list item (must be of type "li")
     * @return {CUI.rte.ListRepresentation.Item} The Item representation; null if there
     *         is no suitable
     */
    getItemByDom: function(dom) {
        var itemCnt = this.items.length;
        for (var i = 0; i < itemCnt; i++) {
            var theItem = this.items[i].getItemByDom(dom);
            if (theItem != null) {
                return theItem;
            }
        }
        return null;
    },

    /**
     * <p>Gets the index (position in this list) of the specified
     * {@link CUI.rte.ListRepresentation.Item Item} in the represented list.</p>
     * <p>Note that this method does not work resursively, i.e. you must call it on the
     *{@link CUI.rte.ListRepresentation ListRepresentation} that actually contains the
     * specified {@link CUI.rte.ListRepresentation.Item Item}.</p>
     * @param {CUI.rte.ListRepresentation.Item} item The item
     * @return {Number} The index (list position) of the specified list item
     */
    getItemIndex: function(item) {
        return CUI.rte.Common.arrayIndex(this.items, item);
    },

    /**
     * <p>Removes the specified {@link CUI.rte.ListRepresentation.Item Item} from this
     * list.</p>
     * <p>Note that this method removes the item from the list representation only, keeping
     * the DOM as it is.</p>
     * @param {CUI.rte.ListRepresentation.Item} itemToRemove The item to remove
     */
    removeItem: function(itemToRemove) {
        var com = CUI.rte.Common;
        var removeIndex = com.arrayIndex(this.items, itemToRemove);
        if (removeIndex >= 0) {
            this.items.splice(removeIndex, 1);
        }
    },

    /**
     * Inserts the specified item after the specified reference item.
     * @param {CUI.rte.ListRepresentation.Item} itemToInsert The item to be inserted
     * @param {CUI.rte.ListRepresentation.Item} refItem The reference item; if null,
     *        the item is inserted at the beginning of the item list
     */
    insertItemAfter: function(itemToInsert, refItem) {
        if (refItem == null) {
            this.items.splice(0, 0, itemToInsert);
            return;
        }
        var refIndex = this.getItemIndex(refItem);
        if (refIndex < 0) {
            throw new Error("Invalid insert item; reference must be in 'this' list.");
        }
        this.items.splice(refIndex + 1, 0, itemToInsert);
    },

    /**
     * <p>Removes the specified {@link CUI.rte.ListRepresentation nested list} from this
     * list.</p>
     * <p>Note that this method removes the nested list from the list representation only,
     * keeping the DOM as it is.</p>
     * @param {CUI.rte.ListRepresentation} subList The nested list to remove
     */
    removeSubList: function(subList) {
        var itemCnt = this.items.length;
        var isRemoved = false;
        for (var i = 0; (i < itemCnt) && !isRemoved; i++) {
            var listsToCheck = this.items[i].subLists;
            var listCnt = listsToCheck.length;
            for (var l = 0; l < listCnt; l++) {
                if (listsToCheck[l] == subList) {
                    listsToCheck.splice(l, 1);
                    isRemoved = true;
                    break;
                } else {
                    isRemoved = listsToCheck[l].removeSubList(subList);
                    if (isRemoved) {
                        break;
                    }
                }
            }
        }
        return isRemoved;
    },

    /**
     * Indents the specified DOM list item.
     * @param {CUI.rte.EditContext} context The edit context
     * @param {HTMLElement} itemDom The list item to indent (must be of type "li")
     */
    indent: function(context, itemDom) {
        var item = this.getItemByDom(itemDom);
        if (item == null) {
            throw new Error("Could not determine item to indent.");
        }
        item.indent(context);
    },

    /**
     * Outdents the specified DOM list items.
     * @param {CUI.rte.EditContext} context The edit context
     * @param {HTMLElement[]} items The list items to outdent (must be of type "li")
     */
    outdent: function(context, items) {
        var com = CUI.rte.Common;
        // outdent each item
        var itemCnt = items.length;
        for (var i = 0; i < itemCnt; i++) {
            var item = this.getItemByDom(items[i]);
            if (item == null) {
                throw new Error("Could not determine item to outdent.");
            }
            var itemsToExclude = item.outdent(context);
            for (var e = 0; e < itemsToExclude.length; e++) {
                var itemDom = itemsToExclude[e].itemDom;
                var itemIndex = com.arrayIndex(items, itemDom);
                if (itemIndex > i) {
                    items.splice(itemIndex, 1);
                    itemCnt--;
                }
            }
        }
    },

    /**
     * <p>Ensures the correct hierarchical nesting.</p>
     * <p>This method may be used to convert lists that handle nested lists similar to
     * list items (&lt;li&gt;...&lt;/li&gt;&lt;ul&gt;...&lt;/ul&gt;) instead of appending
     * them to an existing list item (&lt;li&gt;...&lt;ul&gt;...&lt;/ul&gt;&lt;/li&gt;).
     * </p>
     * @param {CUI.rte.EditContext} context The edit context
     */
    ensureHierarchy: function(context) {
        var itemCnt = this.items.length;
        for (var i = 0; i < itemCnt; i++) {
            var itemToProcess = this.items[i];
            itemToProcess.ensureHierarchy(context);
        }
    },

    /**
     * Flattens the represented list to a series of paragraphs.
     * @param {CUI.rte.EditContext} context The edit context
     */
    flatten: function(context, topLevelList) {
        if (topLevelList == null) {
            topLevelList = CUI.rte.ListUtils.getTopListForItem(context, this.listDom);
        }
        var itemCnt = this.items.length;
        for (var i = 0; i < itemCnt; i++) {
            var itemToProcess = this.items[i];
            itemToProcess.flatten(context, topLevelList);
        }
        this.listDom.parentNode.removeChild(this.listDom);
    },

    /**
     * Creates a "plain text" version of the current state of the list representation.
     * @param {Number} indent (optional) Indentation level
     */
    createDump: function(indent) {
        if (indent == null) {
            indent = 0;
        }
        var i;
        var indentStr = "";
        for (i = 0; i < indent; i++) {
            indentStr += "   ";
        }
        var dump = indentStr + "List, type " + this.listDom.tagName + "; "
                + (this.isCorrectHierarchy ? "correct hierarchy" : "invalid hierarchy")
                + "\n";
        dump += indentStr + " parent: " + (this.parentList ? "yes" : "no") + "\n";
        for (i = 0; i < this.items.length; i++) {
            dump += indentStr + " Item #" + (i + 1) + ":\n";
            dump += this.items[i].createDump(indent + 1);
        }
        return dump;
    }

});

/**
 * @class CUI.rte.ListRepresentation.Item
 * @private
 * <p>This class represents a single list item as part of a
 * {@link CUI.rte.ListRepresentation ListRepresentation}.</p>
 * <p>Note that most processing methods of this class do not adjust the data model (but only
 * the DOM), hence the list representation has to be recreated before another processing is
 * executed on the represented list.</p>
 * @constructor
 * Creates a new ListRepresentation.Item.
 * @param {CUI.rte.ListRepresentation} list The list the item is contained
 * @param {HTMLElement} itemDom DOM representation of the list item (must be of type "li")
 */
CUI.rte.ListRepresentation.Item = new Class({

    toString: "ListRepresentation.Item",

    /**
     * Back reference to the list the item is contained
     * @type CUI.rte.ListRepresentation
     * @private
     */
    list: null,

    /**
     * DOM element that contains the list item
     * @type HTMLElement
     * @private
     */
    itemDom: null,

    /**
     * Subordinate list (if any)
     * @type CUI.rte.ListRepresentation[]
     * @private
     */
    subLists: null,

    construct: function(list, itemDom) {
        this.list = list;
        this.itemDom = itemDom;
        this.subLists = [ ];
    },

    /**
     * <p>Adds the specified nested list explicitly.</p>
     * <p>Note that the specified list is not inspected for further nested lists. Use
     * {@link #detectSubLists} explicitly on the specified list.</P>
     * @param {CUI.rte.ListRepresentation} subList The list representation to add
     */
    addSubList: function(subList) {
        this.subLists.push(subList);
    },

    /**
     * Inspects the list item for nested lists recursively and adjusts the item
     * representation accordingly.
     * @param {HTMLElement} subItem (optional) The DOM element to check; defaults to the
     *        DOM element representing the list item
     */
    detectSubLists: function(subItem) {
        var com = CUI.rte.Common;
        if (!subItem) {
            subItem = this.itemDom;
        }
        if (com.isTag(subItem, com.LIST_TAGS)) {
            var subList = new CUI.rte.ListRepresentation(this.list, true);
            subList.fromList(subItem);
            this.subLists.push(subList);
        } else if (subItem.nodeType == 1) {
            var childCnt = subItem.childNodes.length;
            for (var c = 0; c < childCnt; c++) {
                this.detectSubLists(subItem.childNodes[c]);
            }
        }
    },

    /**
     * <p>Gets the item representation of the specified DOM list item.</p>
     * <p>Note that this method works recursively, considering nested lists.</p>
     * @param {HTMLElement} dom DOM list item (must be of type "li")
     */
    getItemByDom: function(dom) {
        if (this.itemDom == dom) {
            return this;
        }
        var slCnt = this.subLists.length;
        for (var l = 0; l < slCnt; l++) {
            var item = this.subLists[l].getItemByDom(dom);
            if (item != null) {
                return item;
            }
        }
        return null;
    },

    /**
     * Gets the item that is located before "this" on the same hierarchical list level.
     * @return {CUI.rte.ListRepresentation.Item} The preceding list item; null if "this"
     *         is the first item of the list
     */
    getPreviousItem: function() {
        var subItems = this.list.items;
        var itemCnt = subItems.length;
        for (var i = 0; i < itemCnt; i++) {
            var item = subItems[i];
            if (item == this) {
                if (i > 0) {
                    return subItems[i - 1];
                }
                return null;
            }
        }
        return null;
    },

    /**
     * "Flattens" the child nodes of the item by moving them on the same hierarchical
     * level, directly following the item.
     * @private
     */
    flattenChildNodes: function() {
        var slCnt = this.subLists.length;
        var pNode = this.itemDom.parentNode;
        var refNode = this.itemDom.nextSibling;
        for (var l = 0; l < slCnt; l++) {
            var subList = this.subLists[l];
            var subItems = subList.items;
            for (var i = 0; i < subItems.length; i++) {
                var item = subItems[i];
                this.list.insertItemAfter(item, this);
                item.list = this.list;
                var itemPNode = item.itemDom.parentNode;
                itemPNode.removeChild(item.itemDom);
                if (itemPNode.childNodes.length == 0) {
                    itemPNode.parentNode.removeChild(itemPNode);
                }
                if (refNode) {
                    pNode.insertBefore(item.itemDom, refNode);
                } else {
                    pNode.appendChild(item.itemDom);
                }
            }
        }
        this.subLists.length = 0;
    },

    /**
     * Indents the item.
     * @param {CUI.rte.EditContext} context The edit context
     */
    indent: function(context) {
        var prevItem = this.getPreviousItem();
        if (prevItem == null) {
            return;
        }
        // if the previous item has a sub list, we will have to append the indented item
        // to it
        var slCnt = prevItem.subLists.length;
        var itemIndex = this.list.getItemIndex(this);
        this.list.items.splice(itemIndex, 1);
        if (slCnt > 0) {
            var subList = prevItem.subLists[slCnt - 1];
            this.itemDom.parentNode.removeChild(this.itemDom);
            subList.listDom.appendChild(this.itemDom);
            subList.items.push(this);
            this.list = subList;
            this.flattenChildNodes();
            return;
        }
        // we cannot use a previousSibling's sub list, so we'll have to create a new
        // list
        var newList = context.createElement(this.list.listDom.tagName);
        prevItem.itemDom.appendChild(newList);
        this.itemDom.parentNode.removeChild(this.itemDom);
        newList.appendChild(this.itemDom);
        var newSubList = new CUI.rte.ListRepresentation(prevItem.list, true);
        prevItem.addSubList(newSubList);
        newSubList.listDom = newList;
        newSubList.items.push(this);
        this.list = newSubList;
        this.flattenChildNodes();
    },

    /**
     * Outdents the item.
     * @param {CUI.rte.EditContext} context The edit context
     */
    outdent: function(context) {
        var com = CUI.rte.Common;
        var lut = CUI.rte.ListUtils;
        var slCnt, s, slItemCnt, itemToMove, listDom;
        var outdentedChildren = [ ];
        var listLevel = com.getListLevel(context, this.itemDom);
        if (listLevel == 1) {
            // first level items must be converted to paragraphs; sub-lists must be moved
            // out of the newly created paragraph
            slCnt = this.subLists.length;
            if (slCnt > 0) {
                var nextSib = this.itemDom.nextSibling;
                var newList;
                var insertRef;
                if (nextSib) {
                    newList = nextSib.parentNode;
                    insertRef = nextSib;
                } else {
                    listDom = this.list.listDom;
                    newList = context.createElement(listDom.tagName);
                    com.insertBefore(listDom.parentNode, newList, listDom.nextSibling);
                    insertRef = null;
                }
                for (s = 0; s < slCnt; s++) {
                    var slItems = this.subLists[s].items;
                    slItemCnt = slItems.length;
                    if (slItemCnt > 0) {
                        itemToMove = slItems[0].itemDom;
                        outdentedChildren.push(slItems[0]);
                        com.insertBefore(newList, itemToMove, insertRef);
                        var subListDom = slItems[0].list.listDom;
                        if (slItemCnt == 1) {
                            subListDom.parentNode.removeChild(subListDom);
                        } else {
                            itemToMove.appendChild(subListDom);
                        }
                    }
                }
            }
            var changedDom = lut.convertListItem(context, this.itemDom, "p");
            listDom = this.list.listDom;
            if (listDom.childNodes.length == 0) {
                listDom.parentNode.removeChild(listDom);
            }
            if (changedDom.nextSibling
                    && com.isTag(changedDom.nextSibling, com.LIST_TAGS)) {
                this.list.fromList(changedDom.nextSibling);
            }
        } else {
            // items on other levels have to be inserted behind the item of the sub list
            // they are currently contained; the sub list has to be removed if no more
            // items are contained after executing the outdent
            listDom = this.list.listDom;
            var parentItemDom = listDom.parentNode;
            var insertItem = this.list.parentList.getItemByDom(parentItemDom);
            var insertItemIndex = insertItem.list.getItemIndex(insertItem) + 1;
            var insertRefDom = parentItemDom.nextSibling;
            var pNode = parentItemDom.parentNode;
            this.itemDom.parentNode.removeChild(this.itemDom);
            if (insertRefDom) {
                pNode.insertBefore(this.itemDom, insertRefDom);
            } else {
                pNode.appendChild(this.itemDom);
            }
            var itemIndex = this.list.getItemIndex(this);
            var itemsToMove = [ ];
            for (var m = itemIndex + 1; m < this.list.items.length; m++) {
                itemsToMove.push(this.list.items[m]);
            }
            this.list.removeItem(this);
            if (this.list.items.length == 0) {
                listDom.parentNode.removeChild(listDom);
                this.list.parentList.removeSubList(this.list);
            }
            this.list = this.list.parentList;
            if (insertItemIndex < this.list.items.length) {
                this.list.items.splice(insertItemIndex, 0, this);
            } else {
                this.list.items.push(this);
            }
            // if the list item has a nested list with more than one item, indent all
            // but the first item to get the closest possible result
            slCnt = this.subLists.length;
            if (slCnt > 0) {
                for (s = 0; s < slCnt; s++) {
                    var subList = this.subLists[s];
                    slItemCnt = subList.items.length;
                    if (slItemCnt > 0) {
                        outdentedChildren.push(subList.items[0]);
                    }
                    if (slItemCnt > 1) {
                        var itemsToIndent = [ ];
                        for (var i = 1; i < slItemCnt; i++) {
                            itemsToIndent.push(subList.items[i]);
                        }
                        for (i = 0; i < (slItemCnt - 1); i++) {
                            itemsToIndent[i].indent(context);
                        }
                    }
                }
            }
            // if the new previousSibling has child lists, we'll have to insert them
            // as child lists of ourself.
            if (itemsToMove.length > 0) {
                var insertListDom = null;
                var insertSubList = null;
                if (this.subLists.length == 0) {
                    insertListDom = context.createElement(this.list.listDom.tagName);
                    this.itemDom.appendChild(insertListDom);
                    insertSubList = new CUI.rte.ListRepresentation(this.list, true);
                    insertSubList.listDom = insertListDom;
                    this.subLists.push(insertSubList);
                } else {
                    insertSubList = this.subLists[this.subLists.length - 1];
                    insertListDom = insertSubList.listDom;
                }
                for (m = 0; m < itemsToMove.length; m++) {
                    itemToMove = itemsToMove[m];
                    var moveDom = itemToMove.itemDom;
                    pNode = moveDom.parentNode;
                    pNode.removeChild(moveDom);
                    itemToMove.list.removeItem(itemToMove);
                    if (pNode.childNodes.length == 0) {
                        pNode.parentNode.removeChild(pNode);
                        itemToMove.list.parentList.removeSubList(itemToMove.list);
                    }
                    itemToMove.list = insertSubList;
                    insertListDom.appendChild(moveDom);
                    insertSubList.items.push(itemToMove);
                }
            }
        }
        return outdentedChildren;
    },

    /**
     * Ensures the correct nesting of lists that are subordinate to this list.
     * @param {CUI.rte.EditContext} context The edit context
     */
    ensureHierarchy: function(context) {
        var com = CUI.rte.Common;
        var dpr = CUI.rte.DomProcessor;
        var listCnt = this.subLists.length;
        for (var l = 0; l < listCnt; l++) {
            var subListToProcess = this.subLists[l];
            if (!subListToProcess.isCorrectHierarchy) {
                var listItem = this.itemDom;
                if (com.isTag(listItem, com.LIST_TAGS)) {
                    listItem = context.createElement("li");
                    listItem.appendChild(context.createTextNode(dpr.NBSP));
                    this.itemDom.appendChild(listItem);
                    this.itemDom = listItem;
                }
                var listToMove = subListToProcess.listDom;
                listToMove.parentNode.removeChild(listToMove);
                listItem.appendChild(listToMove);
                subListToProcess.isCorrectHierarchy = true;
            }
            subListToProcess.ensureHierarchy(context);
        }
    },

    /**
     * Flattens the represented item to a paragraph. The paragraph is inserted before the
     * specified top-level list.
     * @param {CUI.rte.EditContext} context The edit context
     */
    flatten: function(context, topLevelList) {
        var com = CUI.rte.Common;
        // flatten item
        var paraNode = context.createElement("p");
        topLevelList.parentNode.insertBefore(paraNode, topLevelList);
        var childCnt = this.itemDom.childNodes.length;
        for (var c = childCnt - 1; c >= 0; c--) {
            var itemToMove = this.itemDom.childNodes[c];
            if (!com.isTag(itemToMove, [ "ol", "ul" ])) {
                itemToMove.parentNode.removeChild(itemToMove);
                paraNode.insertBefore(itemToMove, paraNode.firstChild);
            }
        }
        // flatten sub lists
        var listCnt = this.subLists.length;
        for (var l = 0; l < listCnt; l++) {
            this.subLists[l].flatten(context, topLevelList);
        }
        this.subLists.length = 0;
        // remove item from DOM
        this.itemDom.parentNode.removeChild(this.itemDom);
    },

    /**
     * Flattens a single list item by adding its content to the prevoius sibling or parent
     * list item as a new line.
     * @param {CUI.rte.EditContext} context The edit context
     */
    flattenToParent: function(context) {
        var com = CUI.rte.Common;
        var listDom = this.list.listDom;
        var auxRoot = CUI.rte.DomProcessor.getAuxRootNode(context, listDom);
        if (auxRoot == listDom.parentNode) {
            // use outdent if we are "unlisting" a first-level list item
            this.outdent(context);
            return;
        }
        this.flattenChildNodes();
        var childCnt;
        var itemDomRef = null;
        var insertRef = null;
        if (this.itemDom.previousSibling) {
            // prefer previous sibling - but will have to search for a suitable insert
            // point (which is the last item in the last nested list, or a non-list node)
            itemDomRef = this.itemDom.previousSibling;
            while (true) {
                childCnt = itemDomRef.childNodes.length;
                if (childCnt == 0) {
                    break;
                }
                if (!com.isTag(itemDomRef.childNodes[childCnt - 1], com.LIST_TAGS)) {
                    break;
                }
                // get last item of list
                itemDomRef = itemDomRef.childNodes[childCnt - 1].lastChild;
            }
        } else {
            // use parent item if no suitable previous sibling exists
            itemDomRef = com.getParentNode(context, listDom);
            insertRef = listDom;
        }
        // move
        itemDomRef.insertBefore(context.createElement("br"), insertRef);
        var children = this.itemDom.childNodes;
        childCnt = children.length;
        for (var c = childCnt - 1; c >= 0; c--) {
            var childToMove = children[c];
            childToMove.parentNode.removeChild(childToMove);
            itemDomRef.insertBefore(childToMove, insertRef);
            insertRef = childToMove;
        }
        // remove self from DOM & data model
        listDom.removeChild(this.itemDom);
        if (listDom.childNodes.length == 0) {
            this.list.parentList.removeSubList(this.list);
            listDom.parentNode.removeChild(listDom);
        }
        this.list.removeItem(this);
        this.list = null;
    },

    /**
     * Creates a "plain text" version of the current state of the list item representation.
     * @param {Number} indent (optional) Indentation level
     */
    createDump: function(indent) {
        var com = CUI.rte.Common;
        if (indent == null) {
            indent = 0;
        }
        var i;
        var indentStr = "";
        for (i = 0; i < indent; i++) {
            indentStr += "   ";
        }
        var dump = com.dumpNodeRecursively(this.itemDom, indent);
        for (var l = 0; l < this.subLists.length; l++) {
            dump += indentStr + " Sub list #" + (l + 1) + ":\n";
            dump += this.subLists[l].createDump(indent + 1);
        }
        return dump;
    }

});
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.CellSelection
 * @private
 * This class represents a cell-based table selection as used internally by the table
 * plugin.
 * @constructor
 * @param {CUI.rte.TableMatrix} tableMatrix Table matrix that underlies the
 *        selection
 */
CUI.rte.CellSelection = new Class({

    toString: "CellSelection",

    /**
     * The table matrix the selection has been created from
     * @private
     * @type CUI.rte.TableMatrix
     */
    tableMatrix: null,

    /**
     * Array of cell definitions that represent the currently selected cells
     * @private
     * @type Array
     */
    cells: null,

    /**
     * Object that holds comprehensive information about the current selection; properties
     * are: minRow, minCol, maxRowExcl, maxColExcl, cols, rows, isRect, anchorCell;
     * isRect defines if the selection forms a rectangle; anchorCell specifies the cell at
     * the top/left corner of the selection
     * @property selectionProps
     * @type Object
     */
    selectionProps: null,

    construct: function(tableMatrix) {
        this.cells = [ ];
        this.tableMatrix = tableMatrix;
    },

    /**
     * Adds the cell specified by its cell definition to the current selection.
     * @param {Object} cellDef cell definition (as used/created by various mathods of
     *        {@link CUI.rte.TableMatrix})
     */
    addCell: function(cellDef) {
        this.cells.push(cellDef);
    },

    /**
     * <p>Expand the current selection by the specified number of columns to the
     * bottom/right.</p>
     * <p>The method ensures that the selection is rectangular again after expanding it by
     * adding additional cells as required. It also reprocesses the {@link #selectionProps}
     * property to fit the expanded selection.</p>
     * @param {Number} cols Number of columns to expand the selection by
     * @param {Number} rows Number of rows to expand the selection by
     */
    expand: function(cols, rows) {
        if (this.selectionProps == null) {
            this.process();
        }
        if (this.selectionProps == null) {
            return;
        }
        if (this.tableMatrix.fullMatrix == null) {
            this.tableMatrix.createFullMatrix();
        }
        var com = CUI.rte.Common;
        // first, add all cells that are really required to expand the selection
        var cellsToAdd = [ ];
        var baseCol = this.selectionProps.minCol;
        var baseRow = this.selectionProps.minRow;
        var expandCol = this.selectionProps.maxColExcl;
        var expandRow = this.selectionProps.maxRowExcl;
        var r, c, expR, expC, cellToAdd;
        if (cols > 0) {
            for (r = 0; r < this.selectionProps.rows; r++) {
                for (expC = 0; expC < cols; expC++) {
                    cellToAdd = this.tableMatrix.fullMatrix[baseRow + r][expandCol+ expC];
                    if (cellToAdd) {
                        cellToAdd = cellToAdd.cellRef;
                        if (!com.arrayContains(cellsToAdd, cellToAdd)) {
                            cellsToAdd.push(cellToAdd);
                        }
                    }
                }
            }
        }
        if (rows > 0) {
            for (c = 0; c < this.selectionProps.cols; c++) {
                for (expR = 0; expR < rows; expR++) {
                    cellToAdd = this.tableMatrix.fullMatrix[expandRow + expR][baseCol+ c];
                    if (cellToAdd) {
                        cellToAdd = cellToAdd.cellRef;
                        if (!com.arrayContains(cellsToAdd, cellToAdd)) {
                            cellsToAdd.push(cellToAdd);
                        }
                    }
                }
            }
        }
        // second, add additional cells that are required to make the selection rectangular
        // again
        var minCol = baseCol;
        var minRow = baseRow;
        var maxCol = expandCol + cols;
        var maxRow = expandRow + rows;
        var itMinCol = minCol;
        var itMinRow = minRow;
        var itMaxCol = maxCol;
        var itMaxRow = maxRow;
        var isProcessed = false;
        while (!isProcessed) {
            var cellCnt = cellsToAdd.length;
            for (c = 0; c < cellCnt; c++) {
                var cell = cellsToAdd[c];
                var cellMaxCol = cell.col + cell.colSpan;
                var cellMaxRow = cell.row + cell.rowSpan;
                if (cell.col < itMinCol) {
                    itMinCol = cell.col;
                }
                if (cellMaxCol > itMaxCol) {
                    itMaxCol = cellMaxCol;
                }
                if (cell.row < itMinRow) {
                    itMinRow = cell.row;
                }
                if (cellMaxRow > itMaxRow) {
                    itMaxRow = cellMaxRow;
                }
            }
            if ((itMinCol != minCol) || (itMinRow != minRow) || (itMaxCol != maxCol)
                    || (itMaxRow != maxRow)) {
                for (r = itMinRow; r < itMaxRow; r++) {
                    for (c = itMinCol; c < itMaxCol; c++) {
                        var cellToCheck = this.tableMatrix.matrix[r][c];
                        if (cellToCheck) {
                            if (!com.arrayContains(cellsToAdd, cellToCheck)) {
                                cellsToAdd.push(cellToCheck);
                            }
                        }
                    }
                }
                minRow = itMinRow;
                minCol = itMinCol;
                maxRow = itMaxRow;
                maxCol = itMaxCol;
            } else {
                isProcessed = true;
            }
        }
        for (c = 0; c < cellsToAdd.length; c++) {
            this.cells.push(cellsToAdd[c]);
        }
        this.process();
    },

    /**
     * <p>Processes the current selection to provide comprehensive selection information
     * through the {@link #selectionProps} property.</p>
     * @private
     */
    process: function() {
        if (!this.cells || (this.cells.length == 0)) {
            return;
        }
        var min = {
            "row": -1,
            "col": -1
        };
        var max = {
            "row": -1,
            "col": -1
        };
        var anchorCell = null;
        var cellArea = 0;
        for (var c = 0; c < this.cells.length; c++) {
            var cellToProcess = this.cells[c];
            if ((cellToProcess.col < min.col) || (min.col < 0)) {
                min.col = cellToProcess.col;
            }
            if ((cellToProcess.row < min.row) || (min.row < 0)) {
                min.row = cellToProcess.row;
            }
            var lastColExcl = cellToProcess.col + cellToProcess.colSpan;
            var lastRowExcl = cellToProcess.row + cellToProcess.rowSpan;
            if (lastColExcl > max.col) {
                max.col = lastColExcl;
            }
            if (lastRowExcl > max.row) {
                max.row = lastRowExcl;
            }
            if ((cellToProcess.col == min.col) && (cellToProcess.row == min.row)) {
                anchorCell = cellToProcess;
            }
            cellArea += cellToProcess.colSpan * cellToProcess.rowSpan;
        }
        var cols = max.col - min.col;
        var rows = max.row - min.row;
        var selectionArea = cols * rows;
        this.selectionProps = {
            "minRow": min.row,
            "minCol": min.col,
            "maxRowExcl": max.row,
            "maxColExcl": max.col,
            "cols": cols,
            "rows": rows,
            "isRect": (selectionArea == cellArea),
            "anchorCell": anchorCell
        };
    }

});
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.SearchableDocument
 * @private
 * The RichText.SearchableDocument provides means to execute
 * a plaintext search on a HTML document or fragment.
 */
CUI.rte.SearchableDocument = new Class({

    toString: "SearchableDocument",

    plainText: null,

    plainTextLC: null,

    refs: null,

    findPos: 0,

    currentSearch: 0,

    config: null,

    /**
     * @private
     */
    createInternally: function(dom) {
        var com = CUI.rte.Common;
        if (dom.nodeType == 3) {
            var text = com.getNodeText(dom);
            if (text) {
                this.refs.push({
                    "textPos": this.plainText.length,
                    "charCnt": text.length,
                    "nodeRef": dom
                });
                this.plainText += text;
            }
        } else if (dom.nodeType == 1) {
            var addWhitespace =
                    (com.isTag(dom, CUI.rte.SearchableDocument.WHITESPACE_TAGS)
                    || com.isTag(dom, com.EDITBLOCK_TAGS))
                    && (!com.strEndsWith(this.plainText, " "));
            if ((this.plainText.length > 0) && addWhitespace) {
                this.refs.push({
                    "textPos": this.plainText.length,
                    "charCnt": 1,
                    "nodeRef": dom
                });
                this.plainText += " ";
            }
            var children = dom.childNodes;
            for (var i = 0; i < children.length; i++) {
                this.createInternally(children[i]);
            }
        }
    },

    create: function(dom) {
        this.plainText = "";
        this.refs = [ ];
        this.createInternally(dom);
        this.plainTextLC = this.plainText.toLowerCase();
    },

    getRefForPosition: function(textPos) {
        for (var i = 0; i < this.refs.length; i++) {
            var refToCheck = this.refs[i];
            if ((refToCheck.textPos >= textPos)
                    && ((refToCheck.textPos + refToCheck.charCnt) < textPos)) {
                return refToCheck;
            }
        }
        return null;
    },

    createMatch: function(textPos, charCnt) {
        var result = [ ];
        var endPosIncl = textPos + charCnt - 1;
        var refCnt = this.refs.length;
        for (var i = 0; i < refCnt; i++) {
            var ref = this.refs[i];
            var refEndPosIncl = ref.textPos + ref.charCnt - 1;
            if (((ref.textPos >= textPos) && (ref.textPos <= endPosIncl))
                || ((refEndPosIncl >= textPos) && (refEndPosIncl <= endPosIncl))
                || ((ref.textPos >= textPos) && (refEndPosIncl <= endPosIncl))
                || ((ref.textPos <= textPos) && (refEndPosIncl >= endPosIncl))) {
                result.push({
                    matchPos: textPos,
                    matchChars: charCnt,
                    nodePos: ref.textPos,
                    nodeCharCnt: ref.charCnt,
                    node: ref.nodeRef
                });
            } else {
                // as the array is sorted ascendingly, we are finished if we have already
                // found something and the current reference is not part of the result
                // (anymore)
                if (result.length > 0) {
                    return result;
                }
            }
        }
        return result;
    },

    getRefForNode: function(node) {
        for (var i = 0; i < this.refs.length; i++) {
            if (this.refs[i].nodeRef == node) {
                return this.refs[i];
            }
        }
        return null;
    },

    find: function(text, config) {
        this.config = config;
        this.currentSearch = text;
        this.findPos = config.startPos || 0;
        return this.findNext();
    },

    findNext: function() {
        var baseText = (this.config.ignoreCase ? this.plainTextLC : this.plainText);
        var pattern = (this.config.ignoreCase ? this.currentSearch.toLowerCase()
                : this.currentSearch);
        var textPos = baseText.indexOf(pattern, this.findPos);
        if (textPos < 0) {
            this.findPos = 0;
            return null;
        }
        this.findPos = textPos + pattern.length;
        return this.createMatch(textPos, pattern.length);
    },

    adjustToReplace: function(replaceText) {
        this.findPos += replaceText.length - this.currentSearch.length;
    },

    createDump: function() {
        var dump = "Searchable text:\n" + this.plainText + "\n\n";
        dump += "References:\n" + CUI.rte.Common.dumpObject(this.refs);
        return dump;
    }

});

/**
 * Array that defines tags that should be handled as whitespace when searching an HTML
 * text
 * @static
 * @final
 * @type String[]
 * @private
 */
CUI.rte.SearchableDocument.WHITESPACE_TAGS =  [ "br", "img" ];
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.Compatibility
 * @private
 * @since 5.3
 */
CUI.rte.Compatibility = function() {

    var com = CUI.rte.Common;

    return {

        moveDeprecatedPluginConfig: function(config) {
            var compat = CUI.rte.Compatibility;
            compat.correctConfigOption(config, "defaultPasteMode",
                    "rtePlugins.edit.defaultPasteMode");
            compat.correctConfigOption(config, "stripHtmlTags",
                    "rtePlugins.edit.stripHtmlTags");
            compat.correctConfigOption(config, "tabSize",
                    "rtePlugins.keys.tabSize");
            compat.correctConfigOption(config, "trimLinkSelection",
                    "rtePlugins.links.trimLinkSelection");
            compat.correctConfigOption(config, "anchordialogConfig",
                    "rtePlugins.links.anchorDialogConfig");
            compat.correctConfigOption(config, "indentSize",
                    "rtePlugins.lists.indentSize");
            compat.correctConfigOption(config, "specialCharsConfig",
                    "rtePlugins.misctools.specialCharsConfig");
            compat.correctConfigOption(config, "formats",
                    "rtePlugins.paraformat.formats");
            compat.correctConfigOption(config, "cssStyles",
                    "rtePlugins.styles.styles");
            compat.correctConfigOption(config, "editMode",
                    "rtePlugins.table.editMode");
            compat.correctConfigOption(config,
                    "rtePlugins.table.tablePropConfig.tableStyles",
                    "rtePlugins.table.tableStyles");
            var tableStyles = compat.getConfigValue(config, "rtePlugins.table.tableStyles");
            if (tableStyles) {
                tableStyles = compat.convertToArray(tableStyles, "cssName", "text");
                compat.changeDeprecatedPropertyName(tableStyles, "className", "cssName");
                compat.setConfigValue(config, "rtePlugins.table.tableStyles", tableStyles);
            }
            compat.correctConfigOption(config,
                    "rtePlugins.table.tablePropConfig.defaultValues",
                    "rtePlugins.table.defaultValues");
            compat.correctConfigOption(config,
                    "rtePlugins.table.cellPropConfig.cellStyles",
                    "rtePlugins.table.cellStyles");
            var cellStyles = compat.getConfigValue(config, "rtePlugins.table.cellStyles");
            if (cellStyles) {
                cellStyles = compat.convertToArray(cellStyles, "cssName", "text");
                compat.changeDeprecatedPropertyName(cellStyles, "className", "cssName");
                compat.setConfigValue(config, "rtePlugins.table.cellStyles", cellStyles);
            }
        },

        moveDeprecatedHtmlRules: function(config) {
            var compat = CUI.rte.Compatibility;
            var filteredConfig = compat.createFilteredConfig(config, "linkbrowseConfig", [
                "cssInternal",
                "cssExternal",
                "protocols",
                "defaultProtocol",
                "targetConfig"
            ], true);
            var ruleConfig = filteredConfig[0];
            if (ruleConfig != null) {
                compat.setConfigValue(config, "htmlRules.links",
                        new CUI.rte.HtmlRules.Links(ruleConfig));
            }
            var dialogConfig = filteredConfig[1];
            if (dialogConfig != null) {
                compat.setConfigValue(config, "rtePlugins.links.linkDialogConfig",
                        dialogConfig);
            }
            compat.correctConfigOption(config, "removeSingleParagraphContainer",
                    "htmlRules.blockHandling.removeSingleParagraphContainer");
            compat.correctConfigOption(config, "singleParagraphContainerReplacement",
                    "htmlRules.blockHandling.singleParagraphContainerReplacement");
        },

        createFilteredConfig: function(config, path, filterIncl, removeJcrLeftovers) {
            var compat = CUI.rte.Compatibility;
            var configObj = compat.getConfigValue(config, path);
            if (configObj == null) {
                return [ null, null ];
            }
            if (filterIncl == null) {
                return [ configObj, null ];
            }
            if (removeJcrLeftovers) {
                compat.filterJcrLeftovers(configObj);
            }
            var filteredConfig = { };
            var leftoverConfig = null;
            for (var propName in configObj) {
                if (com.arrayContains(filterIncl, propName)) {
                    filteredConfig[propName] = configObj[propName];
                } else {
                    if (leftoverConfig == null) {
                        leftoverConfig = { };
                    }
                    leftoverConfig[propName] = configObj[propName];
                }
            }
            return [ filteredConfig, leftoverConfig ];
        },

        filterJcrLeftovers: function(obj) {
            if (obj["jcr:primaryType"]) {
                delete obj["jcr:primaryType"];
            }
            if (obj["xtype"] && (obj["xtype"] == "nt:unstructured")) {
                delete obj["xtype"];
            }
        },

        correctConfigOption: function(config, deprecatedPath, currentPath) {
            var compat = CUI.rte.Compatibility;
            var deprecatedValue = compat.getConfigValue(config, deprecatedPath);
            if (deprecatedValue != null) {
                compat.setConfigValue(config, currentPath, deprecatedValue);
                compat.removeConfigValue(config, deprecatedPath);
            }
        },

        getConfigValue: function(config, path) {
            var configObj = config;
            var parts = path.split(".");
            for (var p = 0; p < parts.length; p++) {
                configObj = configObj[parts[p]];
                if (configObj == null) {
                    return null;
                }
            }
            return configObj;
        },

        setConfigValue: function(config, path, value) {
            var configObj = config;
            var parts = path.split(".");
            var partCnt = parts.length;
            if (partCnt == 0) {
                return;
            }
            for (var p = 0; p < (partCnt - 1); p++) {
                var configParent = configObj;
                configObj = configObj[parts[p]];
                if (configObj == null) {
                    configObj = { };
                    configParent[parts[p]] = configObj;
                }
            }
            configObj[parts[partCnt - 1]] = value;
        },

        removeConfigValue: function(config, path) {
            var configObj = config;
            var parts = path.split(".");
            var partCnt = parts.length;
            if (partCnt == 0) {
                return;
            }
            for (var p = 0; p < (partCnt - 1); p++) {
                configObj = configObj[parts[p]];
                if (configObj == null) {
                    return;
                }
            }
            delete configObj[parts[partCnt - 1]];
        },

        /**
         * This method provides backwards-compatibility for the "enableXXX"-style
         * configuration that is now deprecated in favor of
         * {@link CUI.rte.RichText#rtePlugins}.
         * @param {Object} config The config object to be used for configuration
         * @param {CUI.rte.EditorKernel} editorKernel The editor kernel
         * @private
         */
        configurePlugins: function(config, editorKernel) {
            var isButtonEnabled = function(group, buttonId) {
                var isGroupEnabled = false;
                var groupConfig = null;
                if (group == "format") {
                    isGroupEnabled = config.enableFormat;
                    groupConfig = config.formatButtons;
                } else if (group == "alignments") {
                    isGroupEnabled = config.enableAlignments;
                    groupConfig = config.alignmentButtons;
                } else if (group == "lists") {
                    isGroupEnabled = config.enableLists;
                    groupConfig = config.listButtons;
                } else if (group == "links") {
                    isGroupEnabled = config.enableLinks;
                    groupConfig = config.linkButtons;
                } else if (group == "edit") {
                    isGroupEnabled = config.enableEditTools;
                    groupConfig = config.editToolButtons;
                }
                var isEnabled = (isGroupEnabled === undefined ? undefined : false);
                if (isGroupEnabled) {
                    if (groupConfig) {
                        isEnabled = !!groupConfig[buttonId];
                    } else {
                        isEnabled = true;
                    }
                }
                return isEnabled;
            };
            var checkPluginConfig = function(pluginId, feature) {
                var groupId = pluginId;
                switch (pluginId) {
                    case "format":
                        break;
                    case "justify":
                        groupId = "alignments";
                        feature = feature.substring(7, feature.length);
                        break;
                    case "lists":
                        break;
                    case "subsuperscript":
                        return config.enableSubSuperScript;
                    case "links":
                        if (feature == "modifylink") {
                            feature = "createlink";
                        }
                        break;
                    case "paraformat":
                        return config.enableParagraphFormat;
                    case "styles":
                        return config.enableStyle;
                    case "misctools":
                        if (feature == "sourceedit") {
                            return config.enableSourceEdit;
                        }
                        if (feature == "specialchars") {
                            return config.enableSpecialChars;
                        }
                        break;
                }
                return isButtonEnabled(groupId, feature);
            };
            var pluginConfig = config.rtePlugins;
            for (var pluginId in editorKernel.registeredPlugins) {
                if (editorKernel.registeredPlugins.hasOwnProperty(pluginId)) {
                    var plugin = editorKernel.registeredPlugins[pluginId];
                    var plgConfig = { };
                    var features = plugin.getFeatures();
                    var featCnt = features.length;
                    for (var f = 0; f < featCnt; f++) {
                        var isEnabled = checkPluginConfig(pluginId, features[f]);
                        if (isEnabled !== undefined) {
                            if (!plgConfig.features) {
                                plgConfig.features = [ ];
                            }
                            if (isEnabled) {
                                plgConfig.features.push(features[f]);
                            }
                        }
                    }
                    if (pluginConfig && pluginConfig[pluginId]) {
                        CUI.rte.Utils.apply(plgConfig, pluginConfig[pluginId]);
                    }
                    plugin.notifyPluginConfig(plgConfig);
                }
            }
        },

        /**
         * Ensures that the specified config object is an array. If it is not an array,
         * an array is created from the properties of the specified object: Each
         * property is converted to an array element that has two properties: one named
         * as specified by keyProp, containing the original property's name; another named
         * as specified by valueProp, containing the original property's value.
         * @param {Object} obj The object to ensure that it is an array.
         * @param {String} keyProp Name of the property containing converted property's name
         * @param {String} valueProp Name of the property containing converted property's
         *        value
         */
        convertToArray: function(obj, keyProp, valueProp) {
            if (!obj) {
                return null;
            }
            com.removeJcrData(obj);
            if (CUI.rte.Utils.isArray(obj)) {
                return obj;
            }
            var array = [ ];
            var item;
            for (var key in obj) {
                if (obj.hasOwnProperty(key)) {
                    var value = obj[key];
                    if (typeof(value) == "object") {
                        if (value[keyProp] && value[valueProp]) {
                            array.push(value);
                        } else {
                            item = { };
                            item[keyProp] = key;
                            item[valueProp] = value;
                            array.push(item);
                        }
                    } else {
                        item = { };
                        item[keyProp] = key;
                        item[valueProp] = value;
                        array.push(item);
                    }
                }
            }
            return array;
        },

        /**
         * <p>Changes a deprecated property name (in an array of objects) to the current
         * name.</p>
         * <p>For example: [ { deprecated: "A" }, "deprecated": "B" } ] is converted to
         * [ { "current": "A" }, { "current": "B" } ] (if called with "deprecated" as
         * parameter deprecatedName and "current" as parameter currentName).</p>
         * @param {Object[]} array The array to be converted
         * @param {String} deprecatedName Deprecated property name
         * @param {String} currentName Current property name
         */
        changeDeprecatedPropertyName: function(array, deprecatedName, currentName) {
            if (array == null) {
                return;
            }
            var itemCnt = array.length;
            for (var i = 0; i < itemCnt; i++) {
                var itemToCheck = array[i];
                if (itemToCheck.hasOwnProperty(deprecatedName)) {
                    if (!itemToCheck.hasOwnProperty(currentName)) {
                        itemToCheck[currentName] = itemToCheck[deprecatedName];
                        delete itemToCheck[deprecatedName];
                    }
                }
            }
        },

        /**
         * <p>Ensures that the specified property of the specified object is actually a
         * regular expression and handles default values.</p>
         * <p>This is a workaround for several issues around RegExp handling with CRX.</p>
         * <p>If the specified property does not exist or is undefined/null, the default
         * value is set. If the property value is a String, either a RegExp with the string
         * is created or the value is set to null if an empty string is found. Otherwise,
         * the property is kept "as is".</p>
         * @param {Object} obj The object
         * @param {String} prop The property name
         * @param {RegExp} defaultValue The default value
         * @since 5.5
         */
        adjustRegExp: function(obj, prop, defaultValue) {
            if (obj[prop] == null) {
                obj[prop] = defaultValue;
            } else if (CUI.rte.Utils.isString(obj[prop])) {
                var propValue = obj[prop];
                var opts = undefined;
                if (com.strStartsWith(propValue, "/")) {
                    var finalSlash = propValue.lastIndexOf("/");
                    if (finalSlash > 0) {
                        if (finalSlash < (propValue.length - 1)) {
                            opts = propValue.substring(finalSlash + 1, propValue.length);
                        }
                        propValue = propValue.substring(1, finalSlash);
                    }
                }
                obj[prop] = (propValue.length == 0 ? null : new RegExp(propValue, opts));
            }
        }

    };

}();
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.HtmlRules
 * This class and its sublasses represents the rules to be applied on HTML processing
 * from inside the {@link CQ.form.RichText RichText} component.
 * @since 5.3
 * @constructor
 * Creates a HtmlRules object.
 * @param {Object} config The configuration
 */
CUI.rte.HtmlRules = new Class({

    toString: "HtmlRules",

    /**
     * @cfg {Object} links
     * Defines how links are created/handled.
     */
    /**
     * @property links
     * Defines how links are created/handled.
     * @type CUI.rte.HtmlRules.Links
     */
    links: null,

    /**
     * @cfg {Object} serializer
     * Defines HTML serialization
     */
    /**
     * @property serializer
     * Defines HTML serialization
     * @type CUI.rte.HtmlRules.Serializer
     */
    serializer: null,

    /**
     * @cfg {Object} docType
     * Defines the doctype
     */
    /**
     * @property docType
     * Defines the doctype
     * @type CUI.rte.HtmlRules.DocType
     */
    docType: null,

    /**
     * @cfg {Object} blockHandling
     * Defines the rules for handling blocks (edit blocks, aux roots, and so on).
     */
    /**
     * @property blockHandling
     * Defines the rules for handling blocks (edit blocks, aux roots, and so on).
     * @type CUI.rte.HtmlRules.BlockHandling
     */
    blockHandling: null,



    construct: function(config) {
        config = config || { };
        var hrls = CUI.rte.HtmlRules;
        this.links = new hrls.Links(config.links);
        this.serializer = new hrls.Serializer(config.serializer);
        this.docType = new hrls.DocType(config.docType);
        this.blockHandling = new hrls.BlockHandling(config.blockHandling);
        delete config.links;
        delete config.serializer;
        delete config.docType;
        delete config.blockHandling;
        /*
        CUI.rte.Utils.applyDefaults(config, {
            "defaultEditBlockType": "p"
        });
        */
        CUI.rte.Utils.apply(this, config);
    }

});


/**
 * @class CUI.rte.HtmlRules.Links
 * The HtmlRules.Links class represents the HTML rules used for creating links.
 * @since 5.3
 * @constructor
 * Creates a HtmlRules.Links object.
 * @param {Object} config The configuration
 */
CUI.rte.HtmlRules.Links = new Class({

    toString: "HtmlRules.Links",

    /**
     * @cfg {String} cssMode
     * <p>Defines the CSS mode for links. Possible values are:</p>
     * <ul>
     *   <li>"remove" - removes class elements on links</li>
     *   <li>"keep" - keeps manually added classes "as is"</li>
     *   <li>"replace" - replaces manually added classes by using the classes defined by
     *     {@link #cssInternal} and {@link #cssExternal}.</li>
     *   <li>"auto" - (default) determines the cssMode through the settings of
     *     {@link #cssInternal} and {@link #cssExternal}. If at least one of these
     *     properties is set, mode "replace" is used. If none is set, mode "keep" is
     *     used instead.</li>
     * </ul>
     * @since 5.3
     */
    cssMode: null,

    /**
     * @cfg {String} cssInternal
     * CSS class to use for internal links
     */
    cssInternal: null,

    /**
     * @cfg {String} cssExternal
     * CSS class to use for external links
     */
    cssExternal: null,

    /**
     * @cfg {String[]} protocols
     * A list of available prototcols; use the entire protocol prefix (e.g. "http://",
     * "ftp://"). Note that internal links are always available.
     */
    protocols: null,

    /**
     * @cfg {String} defaultProtocol
     * The default protocol value; must be one of the values in {@link #protocols}
     */
    defaultProtocol: null,

    /**
     * @cfg {Object} targetConfig
     * <p>Defines how to handle the "target" attribute of the link being edited. Properties:
     * </p>
     * <ul>
     *   <li><code>mode</code> : String<br>
     *     Specifies the target mode; valid values are: "auto" - means that an automatic
     *     target is chosen (specified by the "targetExternal" property for external
     *     links and "targetInternal" for internal links). "manual" - means that the
     *     user can specify a target through an input field. "blank" - means that there
     *     is a checkbox to select if a link should be opened in a new window. "none" if no
     *     target attribute may be provided.</li>
     *   <li><code>targetInternal</code> : String<br>
     *     The target for internal links (only if mode == "auto")</li>
     *   <li><code>targetExternal</code> : String<br>
     *     The target for external links (only if mode == "auto")</li>
     * </ul>
     */
    targetConfig: null,

    /**
     * @cfg {Boolean} ensureInternalLinkExt
     * True if a proper extension (.html) should be ensured for internal links. False
     * if it's the user's responsibility to enter internal links correctly. Defaults to
     * true.
     * @since 5.4
     */
    ensureInternalLinkExt: false,

    /**
     * @cfg {RegExp} relativeLinkRegExp
     * A regular expression that is used to detect relative links. Relative links are
     * not prepended with an http:// link.
     * @since 5.5
     */
    relativeLinkRegExp: null,


    construct: function(config) {
        config = config || { };
        var defaults = {
            "cssMode": "auto",
            "protocols": [
                "http://",
                "https://",
                "ftp://",
                "mailto:"
            ],
            "targetConfig": {
                "mode": "blank"
            },
            "ensureInternalLinkExt": true
        };
        CUI.rte.Utils.applyDefaults(config, defaults);
        CUI.rte.Utils.apply(this, config);
        // adjust regexp
        CUI.rte.Compatibility.adjustRegExp(this, "relativeLinkRegExp",
                CUI.rte.HtmlRules.Links.REL_LINK_DEFAULT_REGEXP);
    },

    /**
     * Get the protocol (if containes in the protocol array) of the specified HREF.
     * @param {String} href The HREF (i.e. "http://host.domain.tld/path/to/file.ext")
     * @return {String} The protocol; null if no or no valid/allowed protocol is available
     */
    getProtocol: function(href) {
        if (this.protocols) {
            var pCnt = this.protocols.length;
            for (var p = 0; p < pCnt; p++) {
                var protocol = this.protocols[p];
                if (CUI.rte.Common.strStartsWith(href, protocol)) {
                    return protocol;
                }
            }
        }
        return null;
    },

    /**
     * <p>Checks if the specified HREF generally has (most probably) a protocol prefix.</p>
     * <p>The protocol is not checked against the protocols array.</p>
     * @param {String} href The HREF (i.e. "http://host.domain.tld/path/to/file.ext")
     * @return {Boolean} True, if a protocol has been detected for the specified HREF
     */
    hasProtocol: function(href) {
        return CUI.rte.HtmlRules.Links.hasProtocol(href);
    },

    /**
     * Checks if the specified HREF represents an internal link.
     * @param {String} href The HREF (i.e. "http://host.domain.tld/path/to/file.ext")
     * @return {Boolean} True, if the specified HREF represents an internal link
     */
    isInternalLink: function(href) {
        return CUI.rte.HtmlRules.Links.isInternalLink(href);
    },

    /**
     * Checks if the specified HREF represents a relative link.
     * @param {String} href the HREF (i.e. "http://host.domain.tld/path/to/file.ext")
     */
    isRelativeLink: function(href) {
        return CUI.rte.HtmlRules.Links.isRelativeLink(href, this.relativeLinkRegExp);
    },

    /**
     * <p>Validates the specified HREF.</p>
     * <p>The HREF is considered valid if:</p>
     * <ul>
     *   <li>It has a valid protocol.</li>
     *   <li>Or represents an internal link (note that the internal link is not verified
     *     to point to a valid node).</li>
     *   <li>Or is recognized as a link without protocol (i.e. "www.day.com",
     *     "localhost:80")</li>
     * </ul>
     * @param {String} href The HREF to validate
     * @return {Boolean} True if the HREF could be validated
     */
    validateHref: function(href) {
        var protocol = this.getProtocol(href);
        if (protocol) {
            // valid protocol prepended
            return true;
        }
        // internal & relative links
        if (this.isInternalLink(href)) {
            return true;
        }
        if (this.isRelativeLink(href)) {
            return true;
        }
        // invalid protocol?
        if (this.hasProtocol(href)) {
            return false;
        }
        // Link without protocol (i.e. www.day.com)
        return true;
    },

    /**
     * Applies the link rules to the specified DOM object.
     * @param {HTMLElement|Object} obj DOM object or JavaScript stub object to apply rules
     *        to
     */
    applyToObject: function(obj) {
        var com = CUI.rte.Common;
        var isDomObject = (obj.nodeType && (obj.nodeType == 1));
        var href;
        if (isDomObject) {
            href = CUI.rte.HtmlRules.Links.getLinkHref(obj);
        } else {
            href = obj.href;
        }
        var cssMode = this.cssMode;
        if (cssMode == "auto") {
            if ((this.cssInternal != null) || (this.cssExternal != null)) {
                cssMode = "replace";
            } else {
                cssMode = "keep";
            }
        }
        if (cssMode == "remove") {
            if (isDomObject) {
                com.removeAttribute(obj, "class");
            } else {
                obj.cssClass = null;
            }
        } else if (cssMode == "replace") {
            var cssClass = null;
            if (this.cssInternal && this.isInternalLink(href)) {
                cssClass = this.cssInternal;
            }
            if (this.cssExternal && !this.isInternalLink(href)) {
                cssClass = this.cssExternal;
            }
            if (isDomObject) {
                if (cssClass != null) {
                    com.setAttribute(obj, "class", cssClass);
                } else {
                    com.removeAttribute(obj, "class");
                }
            } else {
                obj.cssClass = cssClass;
            }
        }
        if (this.targetConfig) {
            switch (this.targetConfig.mode) {
                case "none":
                    if (isDomObject) {
                        com.removeAttribute(obj, "target");
                    } else {
                        obj.target = null;
                    }
                    break;
                case "auto":
                    var target = (this.isInternalLink(href)
                            ? this.targetConfig.targetInternal
                            : this.targetConfig.targetExternal);
                    if (isDomObject) {
                        if (target != null) {
                            com.setAttribute(obj, "target", target);
                        } else {
                            com.removeAttribute(obj, "target");
                        }
                    } else {
                        obj.target = target;
                    }
                    break;
            }
        }
        if (this.isInternalLink(href) || this.isRelativeLink(href)) {
            var anchorPos = href.indexOf("#");
            if (anchorPos == 0) {
                // change nothing if we have an "anchor only"-HREF
                return;
            }
            // add extension to internal links if necessary (relative links are considered
            // internal links as well)
            if (this.ensureInternalLinkExt && this.isPage(href)) {
                var anchor = "";
                if (anchorPos > 0) {
                    anchor = href.substring(anchorPos, href.length);
                    href = href.substring(0, anchorPos);
                }
                var query = "";
                var queryPos = href.indexOf("?");
                if (queryPos > 0) {
                    query = href.substring(queryPos, href.length);
                    href = href.substring(0, queryPos);
                }
                // add extension to href if necessary
                var extSepPos = href.lastIndexOf(".");
                var slashPos = href.lastIndexOf("/");
                var hasClosingSlash = (slashPos == (href.length - 1));
                if (((extSepPos <= 0) || (extSepPos < slashPos)) && !hasClosingSlash) {
                    obj.href = href + CUI.rte.Constants.EXTENSION_HTML + query + anchor;
                }
            }
        } else if ((this.getProtocol(href) == null) && !this.hasProtocol(href)) {
            // Two cases will end up here: either we have a relative link:
            //    relative/path/to/resource.html
            // or we have an absolute link where the user failed to specify the protocol:
            //    www.adobe.com/somePage.html
            // Trouble is, there's no definitive way to tell which we have.  So we apply
            // a few heuristics:
            if (this.isPage(href)) {
                // relative internal link to a page; doesn't need a protocol added
            } else {
                var hostname = href.substring(0, href.indexOf("/"));
                if (CUI.rte.HtmlRules.Links.PROBABLE_HOST_REGEXP.test(hostname)) {
                    // user forgot to type a protocol; give them a default one:
                    var protocol = this.defaultProtocol || "http://";
                    obj.href = protocol + href;
                } else {
                    // still might be a host which failed our PROBABLE_HOST_REGEXP test, but
                    // better to have a false-negative and do nothing than to wreck a user's
                    // valid relative URL.  (See bugs 32422 and 35868.)
                }
            }
        }
    },

    /**
     * Returns true if the href points to a page.
     * @param {String} href A relative or absolute path
     */
    isPage: function(href) {
        var path;
        if (this.isRelativeLink(href)) {
            path = CUI.rte.Utils.resolveRelativePath(href);
        } else if (this.isInternalLink(href)) {
            path = href;
        }

        if (!path) {
            return false;
        } else if (path.indexOf("?") >= 0) {
            path = path.substring(0, path.indexOf("?"));    // trim query parameter
        } else if (path.indexOf("#") >= 0) {
            path = path.substring(0, path.indexOf("#"));    // trim fragment identifier
        }

        // links are already considered URL encoded, so we'll have to decode them
        // before passing the path to #getPageInfo()
        return CUI.rte.Utils.isExistingPage(path);
    }

});

/**
 * The default regular expression used for detecting hostnames
 */
CUI.rte.HtmlRules.Links.PROBABLE_HOST_REGEXP = /^(localhost)|([\w\d\-\u0081-\uffff]+\.[\w\d\-\u0081-\uffff]+\.[\w\d\-\u0081-\uffff]+)$/;

/**
 * Checks if the specified HREF has a protocol prefix (http://, mailto:, etc.).
 * @param {String} href HREF to check
 * @return {Boolean} <i>true</i> if the specified HREF has a protocol prefix
 */
CUI.rte.HtmlRules.Links.hasProtocol = function(href) {
    return /^[A-Za-z][A-Za-z\d+\-.]*:(\/\/)?([^\d]|[\d]+@|$)/.test(href);
};

/**
 * Checks if the specified HREF defines an internal link.
 * @param {String} href HREF to check
 */
CUI.rte.HtmlRules.Links.isInternalLink = function(href) {
    return (href.length > 0) && ((href.charAt(0) == "/") || (href.charAt(0) == '#'));
};

/**
 * Checks if the specified HREF represents a relative link.
 * @param {String} href the HREF (i.e. "http://host.domain.tld/path/to/file.ext")
 * @param {RegExp} regEx The regular expression to be used for detecting the relative link;
 *        if null, no relative link detection is applied on the HREF.
 */
CUI.rte.HtmlRules.Links.isRelativeLink = function(href, regEx) {
    if (!regEx) {
        return false;
    }
    // console.log(regEx.test(href));
    return regEx.test(href);
};

/**
 * The default regular expression used for detecting relative links
 */
CUI.rte.HtmlRules.Links.REL_LINK_DEFAULT_REGEXP = /^\.{1,2}\/(.*)/;

/**
 * <p>Returns the HREF of the specified DOM element.</p>
 * <p>This method uses the proprietary RTE attribute if available. Otherwise, the
 * HREF attribute is taken and a guess is made if the HREF represents an internal link.
 * If so, the HREF is adjusted accordingly.</p>
 * @param {HTMLElement} dom The link element to check
 * @return {String} The link element's HREF attribute
 */
CUI.rte.HtmlRules.Links.getLinkHref = function(dom) {
    var com = CUI.rte.Common;
    var href;
    if (com.isAttribDefined(dom, com.HREF_ATTRIB)) {
        href = com.getAttribute(dom, com.HREF_ATTRIB);
    } else {
        href = com.getAttribute(dom, "href");
        if (href) {
            href = CUI.rte.HtmlRules.Links.removePrefixForInternalLinks(href);
        }
    }
    return href;
};

/**
 * Removes the server prefix (http://hostname:port/context; deliberately inserted by the
 * browser) from an internal link.
 * @param {String} href URL where the server prefix should be removed
 * @return {String} adjusted URL ("/content/foo/bar" for internal links;
 *         "http://hostname[:port]/foo/bar" for external links
 */
CUI.rte.HtmlRules.Links.removePrefixForInternalLinks = function(href) {
    var currentUrl = location.href;
    var currentServerPrefix = CUI.rte.Utils.getServerPrefix(currentUrl) + "/";
    var prefixLen = currentServerPrefix.length;
    if (href.length > prefixLen) {
        if (href.substring(0, prefixLen) == currentServerPrefix) {
            var isSamePage = false;
            var hasQueryString = false;
            if (href.length > currentUrl.length) {
                if (href.substring(0, currentUrl.length) == currentUrl) {
                    var sepChar = href.charAt(currentUrl.length);
                    switch (sepChar) {
                        case "?":
                            hasQueryString = true;
                            isSamePage = true;
                            break;
                        case "#":
                            isSamePage = true;
                            break;
                    }
                }
            }
            if (isSamePage && !hasQueryString) {
                // anchor-only link: remove protocol, host, path
                href = href.substring(currentUrl.length, href.length);
            } else {
                href = href.substring(prefixLen - 1, href.length);
            }
        }
    }
    return href;
};


/**
 * @class CUI.rte.HtmlRules.Serializer
 * The HtmlRules.Serializer class represents the rules used for serializing and
 * deserializing HTML from/to DOM objects.
 * @since 5.3
 * @constructor
 * Creates a HtmlRules.Serializer object.
 * @param {Object} config The configuration
 */
CUI.rte.HtmlRules.Serializer = new Class({

    toString: "HtmlRules.Serializer",

    /**
     * @cfg {String} mode
     * <p>Serializer mode. Valid settings are:</p>
     * <ul>
     *   <li>"auto" - uses the a suitable default serializer.</li>
     *   <li>"customized" - uses customized serializer and deserializer; must be provided
     *     through the {@link #serializer} and {@link #deserializer} config options.</li>
     * </ul>
     * <p>Defaults to "auto".</p>
     */
    mode: null,

    /**
     * @cfg {Object} config
     * Configuration if a standard serializer ({@link CUI.rte.HtmlSerializer},
     * {@link CUI.rte.XhtmlSerializer} is used. See the corresponding class for
     * respective config options. Ignored if mode == "customized". Defaults to null to use
     * the serializer's default configuration.
     */
    config: null,

    /**
     * @cfg {CUI.rte.Serializer} serializer
     * Provides a customized serializer. Ignored if mode != "customized". Defaults to null.
     */
    serializer: null,

    /**
     * @cfg {CUI.rte.Serializer} deserializer
     * Provides a customized deserializer. Ignored if mode != "customized". Defaults to
     * null.
     */
    deserializer: null,


    construct: function(config) {
        config = config || { };
        CUI.rte.Utils.applyDefaults(config, {
            "mode": "auto",
            "config": null,
            "serializer": null,
            "deserializer": null
        });
        CUI.rte.Utils.apply(this, config);
    },

    /**
     * Serializes the specified DOM tree.
     * @param {CUI.rte.EditContext} context The edit context
     * @param {HTMLElement} dom The root node of the DOM tree to be serialized; the root
     *        node itself is not serialized
     * @param {CUI.rte.HtmlRules.DocType} docType The doc type
     * @return {String} The serialized representation of the DOM tree
     */
    serialize: function(context, dom, docType) {
        // create serializer if necessary
        if (this.serializer == null) {
            switch (this.mode) {
                case "auto":
                    if (docType.baseType == "html") {
                        this.serializer = new CUI.rte.HtmlSerializer(this.config);
                    } else if (docType.baseType == "xhtml") {
                        this.serializer = new CUI.rte.XhtmlSerializer(this.config);
                    }
                    break;
                case "customized":
                    throw new Error("Using 'customized' serialization, but no custonized "
                            + "serializing object configured (use 'serializer' config "
                            + "option)");
                    break;
                default:
                    throw new Error("Invalid serialization mode: '" + this.mode + "'");
                    break;
            }
        }
        return this.serializer.serialize(context, dom);
    },

    /**
     * Deserializes the specified HTML fragment to the specified root DOM element.
     * @param {CUI.rte.EditContext} context The edit context
     * @param {String} html The HTML code to deserialize
     * @param {HTMLElement} dom The root node of the DOM tree the HTML is deserialized to
     * @param {CUI.rte.HtmlRules.DocType} docType The doc type
     */
    deserialize: function(context, html, dom, docType) {
        // create deserializer if necessary
        if (this.deserializer == null) {
            switch (this.mode) {
                case "auto":
                    if (docType.baseType == "html") {
                        this.deserializer = new CUI.rte.HtmlDeserializer(this.config);
                    } else if (docType.baseType == "xhtml") {
                        this.deserializer = new CUI.rte.XhtmlDeserializer(this.config);
                    }
                    break;
                case "customized":
                    throw new Error("Using 'customized' serialization, but no custonized "
                            + "deserializing object configured (use 'deserializer' config "
                            + "option)");
                    break;
                default:
                    throw new Error("Invalid serialization mode: '" + this.mode + "'");
                    break;
            }
        }
        return this.deserializer.deserialize(context, html, dom);
    }

});


/**
 * @class CUI.rte.HtmlRules.DocType
 * <p>The HtmlRules.DocType class represents some rules regarding document types.</p>
 * <p>It mostly influences the way HTML code is generated from the DOM (using some of the
 * {@link CUI.rte.HtmlProcessor} modules, especially the Postprocessor that is
 * responsible for the final HTML result.</p>
 * @constructor
 * Creates a new HtmlRules.DocType object.
 * @param {Object} config The configuration object
 */
CUI.rte.HtmlRules.DocType = new Class({

    toString: "HtmlRules.DocType",

    /**
     * @cfg {String} baseType
     * Basic document type; allowed values: "html", "xhtml"; defaults to "html"
     */
    baseType: null,

    /**
     * @cfg {String} version
     * Doctype version; only valid values: "4.0" for baseType == "html"; "1.0" for
     * baseType == "xhtml". Note that you'll have to provide the version as a String
     * object, not as a Number.
     */
    version: null,

    /**
     * @cfg {Object} typeConfig
     * Type-specific configuration. Currently supported config options:
     * <ul>
     *   <li><code>useSemanticMarkup</code> : Boolean<br>
     *     True if semantic markup should be used in favour of "physical style" markup
     *     (for example, use "strong" instead of "b" tags). The mapping of semantic to
     *     physical style tags is defined by semanticMarkupMap.</li>
     *   <li><code>semanticMarkupMap</code> : Object<br>
     *     Defines the mapping between physical style tags (key) and semantic markup tags
     *     (value). Note that you must specify a valid map, even if useSemanticMarkup is
     *     set to false.</li>
     *   <li><code>isXhtmlStrict</code> : Boolean<br>
     *     Defines if strict XHTML 1.0 has to be used (only if {@link #baseType} ==
     *     "xhtml"). Note that XHTML 1.0 strict has some limitations; for example the
     *     "u" tag is no longer supported.</li>
     * </ul>
     */
    typeConfig: null,

    /**
     * "Blacklist" of (RTE supported) tags that are not allowed by the current doc type
     * @private
     * @type String[]
     */
    tagBlacklist: null,

    construct: function(config) {
        config = config || { };
        CUI.rte.Utils.applyDefaults(config, {
            "baseType": "html",
            "version": "4.0",
            "typeConfig": {
                "useSemanticMarkup": false,
                "semanticMarkupMap": {
                    "b": "strong",
                    "i": "em"
                }
            }
        });
        CUI.rte.Utils.apply(this, config);
        if ((this.baseType != "html") && (this.baseType != "xhtml")) {
            throw new Error("Invalid doctype; must be 'html' or 'xhtml'");
        }
        this.tagBlackList = [ ];
        if (this.baseType == "html") {
            if (this.version != "4.0") {
                throw new Error("Invalid version; must be '4.0' for doctype 'html'.");
            }
        }
        if (this.baseType == "xhtml") {
            if (this.version != "1.0") {
                throw new Error("Invalid version; must be '1.0' for doctype 'xhtml'.");
            }
            if (this.typeConfig.isXhtmlStrict) {
                this.tagBlackList.push("u");
            }
        }
    },

    /**
     * <p>Checks if the specified tag is allowed by the current document type.</p>
     * <p>Note that this method currently does not use the DTD to detect invalid tags,
     * but a blacklist is used.</p>
     * @param {String} tagName The tag name to be checked
     * @return {Boolean} True if the specified tag name is allowed for the doctype
     */
    isAllowed: function(tagName) {
        return !CUI.rte.Common.arrayContains(this.tagBlackList, tagName.toLowerCase());
    },

    /**
     * Checks if the specified tag is listed as semantic markup and returns the
     * corresponding physical style markup.
     * @param {String} tagName The tag name to be checked
     * @return {String} The corresponding physical style tag; null, if the specified tag
     *         name is not registered as semantic markup
     */
    convertToPhysicalStyle: function(tagName) {
        var markupMap = this.typeConfig.semanticMarkupMap;
        if (!markupMap) {
            return null;
        }
        tagName = tagName.toLowerCase();
        for (var physStyle in markupMap) {
            if (markupMap.hasOwnProperty(physStyle)) {
                if (markupMap[physStyle] == tagName) {
                    return physStyle;
                }
            }
        }
        return null;
    },

    /**
     * Checks if the specified tag is listed as a physical style and returns the
     * corresponding semantic markup.
     * @param {String} tagName The tag name to be checked
     * @return {String} The corresponding semantic tag; null, if the specified tag
     *         name is not registered as a physical style
     */
    convertToSemanticMarkup: function(tagName) {
        if (!this.typeConfig.semanticMarkupMap) {
            return null;
        }
        tagName = tagName.toLowerCase();
        if (this.typeConfig.semanticMarkupMap.hasOwnProperty(tagName)) {
            return this.typeConfig.semanticMarkupMap[tagName];
        }
        return null;
    },

    /**
     * Adjusts the specified tag to the document type's requirements.
     * @param {String} tagName The name of the tag to adjust
     * @return {String} Adjusted tag name; null if nothing has to be adjusted; "" if the
     *         tag has to be ignored as it is not supported by the doctype
     */
    adjustToDocType: function(tagName) {
        if (this.typeConfig.useSemanticMarkup) {
            var convertedTag = this.convertToSemanticMarkup(tagName);
            if (convertedTag != null) {
                return (this.isAllowed(convertedTag) ? convertedTag : "");
            }
        }
        if (!this.isAllowed(tagName)) {
            return "";
        }
        return null;
    },

    /**
     * Adjusts the specified tag to the requirements of RTE.
     * @param {String} tagName The name of the tag to adjust
     * @return {String} Adjusted tag name; null if nothing has to be adjusted
     */
    adjustToRaw: function(tagName) {
        return this.convertToPhysicalStyle(tagName);
    }

});

CUI.rte.HtmlRules.BlockHandling = new Class({

    toString: "HtmlRules.BlockHandling",

    /**
     * @cfg {String} defaultEditBlock
     * The default edit block type to use; defaults to "p"
     * @since 5.4
     */
    /**
     * @property defaultEditBlockType
     * The default edit block type to use
     * @type String
     * @since 5.4
     */
    defaultEditBlockType: null,

    /**
     * @cfg {Boolean} removeSingleParagraphContainer
     * True if the paragraph element of texts that consist only of a single paragraph
     * should be removed on postprocessing (defaults to false).
     * For example, if a text is &lt;p&gt;Single paragraph text&lt;/p&gt;, the surrounding
     * "p" tag would get removed if this option was set to true. This option is mainly for
     * backward compatibility with CQ 5.1, where container tags had not yet been available.
     * Hence texts that were created by a CQ 5.1 instance will be surrounded by a single "p"
     * element before they are edited in a CQ 5.2+ instance. By setting this option to true,
     * this automatically added "p" tag will get removed before the text is saved, at least
     * if no other paragraphs or containers were added.
     */
    removeSingleParagraphContainer: false,

    /**
     * @cfg {String} singleParagraphContainerReplacement
     * Specifies the name of the tag that has to be used if a paragraph container cannot
     * be simply removed because it carries additional info (for example, alignment and/or
     * CSS classes; defaults to "div"). Note that this setting only takes effect if
     * {@link #removeSingleParagraphContainer} is set to true.
     */
    singleParagraphContainerReplacement: null,

    construct: function(config) {
        config = config || { };
        CUI.rte.Utils.applyDefaults(config, {
            "defaultEditBlockType": "p",
            "removeSingleParagraphContainer": false,
            "singleParagraphContainerReplacement": "div"
        });
        CUI.rte.Utils.apply(this, config);
    }

});
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.Serializer
 * <p>The Serializer class works as an "interface" for providing fully customized HTML
 * serializers.</p>
 * <p>Serializers are used to convert the DOM of the edited document (resp. its "body" part)
 * into a suitable HTML representation that is used for storing the document in the
 * repository or editing using HTML source view.</p>
 * <p>You should only consider implementing this interface directly if you have very special
 * requirements. Usually, it should make more sense to extend one of the default
 * serializers, {@link CUI.rte.HtmlSerializer} or {@link CUI.rte.XhtmlSerializer}.
 * </p>
 * <p>Serializers should usually do the following cleanup/adjustments:</p>
 * <ul>
 *   <li>Provide correct tag/attribute case (i.e., in XHTML output, tag and attribute names
 *     should be lowercase)</li>
 * </ul>
 */
CUI.rte.Serializer = new Class({

    toString: "Serializer",

    /**
     * <p>Serializes the specified DOM (sub-) tree.</p>
     * <p>Note that the specified DOM element itself must not get serialized.</p>
     * @param {CUI.rte.EditContext} context The edit context
     * @param {HTMLElement} dom The DOM (sub-) tree to serialize
     * @return {String} The serialized representation of the DOM (sub-) tree
     */
    serialize: function(context, dom) {
        // must be overridden by the implementing class
        return "";
    }

});
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.HtmlSerializer
 * @extends CUI.rte.Serializer
 * The HtmlSerializer is used to serialize a DOM (sub-) tree to its HTML (String)
 * equivalent.
 * @constructor
 * Creates a new HtmlSerializer.
 * @param {Object} config The configuration object
 */
CUI.rte.HtmlSerializer = new Class({

    toString: "HtmlSerializer",

    extend: CUI.rte.Serializer,

    /**
     * The edit context
     * @private
     * @type CUI.rte.EditContext
     */
    context: null,

    /**
     * HTML code that should be added to the next structural node that has no more child
     * nodes
     * @private
     * @type String
     */
    deepestChildAddHtml: null,

    /**
     * @cfg {String[]} nonClosingTags
     * Array that contains tags that must not be closed. Defaults to: [ "br", "hr", "img",
     * "area", "input", "col" ]
     */
    nonClosingTags: null,

    /**
     * @cfg {String} tagCase
     * Defines the case of tags; valid values are: "upper" (for uppercase tags), "lower"
     * (for lowercase tags), "keep" (to keep tag names as they are according to DOM).
     * Defaults to "lower".
     */
    tagCase: null,

    /**
     * @cfg {String} attribNameCase
     * Defines the case of attribute names; valid values are: "upper" (for uppercase tags),
     * "lower" (for lowercase tags), "keep" (to keep tag names as they are according to
     * DOM). Defaults to "lower".
     */
    attribNameCase: null,

    /**
     * @cfg {String} styleAttribNameCase
     * Defines the case of style attribute names; valid values are: "upper" (for uppercase
     * tags), "lower" for (lowercase tags), "keep" (to keep tag names as they are according
     * to DOM). Defaults to "lower"
     */
    styleAttribNameCase: null,

    /**
     * @cfg {String} idAttribMode
     * Defines how to handle the ID attribute; valid values are: "remove" (for removing
     * ID attributes), "keep" (to keep them). Defaults to "remove"
     */
    idAttribMode: null,

    /**
     * @cfg {Function} beautifier
     * A function that is called on every node. This function may add whitespace to
     * "beautify" the generated HTML. The function gets the edit context, the DOM object and
     * a flag that determines if the function is called before (true) or after (false)
     * processing the DOM object. The function may return "null" (= do nothing) or some
     * text to be added. The text to be added must be specified as an Object with
     * properties "before" and "after", defining the text to be inserted before/after
     * the opening resp. closing tag.
     */
    beautifier: null,

    construct: function(config) {
        this._init(config);
    },

    _init: function(config) {
        config = config || { };
        CUI.rte.Utils.applyDefaults(config, {
            "nonClosingTags": CUI.rte.HtmlSerializer.NON_CLOSING_TAGS,
            "tagCase": "lower",
            "attribNameCase": "lower",
            "styleAttribNameCase": "lower",
            "idAttribMode": "remove",
            "beautifier": CUI.rte.HtmlSerializer.defaultBeautifier
        });
        CUI.rte.Utils.apply(this, config);
    },

    /**
     * <p>Browser-independent way to get attribute values.</p>
     * <p>Contrary to {@link CUI.rte.Common#getAttribute}, this method does not do
     * any attribute-name translations, but works around an IE bug with cloned nodes (some
     * attributes are returned as 0 if accessed regularily) that the former method doesn't
     * work around.</p>
     * @param {HTMLElement} dom The DOM element to get the attribute value from
     * @param {String} attribName The attribute's name
     * @return {String} The attribute's value
     */
    getAttribValue: function(dom, attribName) {
        var com = CUI.rte.Common;
        // IE <= 7 handles named anchors differently; see bug #36231
        if (com.ua.isIE6 || com.ua.isIE7) {
            var nameLC = attribName.toLowerCase();
            if (CUI.rte.Common.isTag(dom, "a") && (nameLC == "name")) {
                return dom.attributes["name"].nodeValue;
            }
        }
        return com.ua.isOldIE ? dom.getAttribute(attribName, 2) : dom.getAttribute(attribName);
    },

    /**
     * Helper that determines if an attribute has actually to be serialized according to
     * the serializer's settings.
     * @param {Attr} attrib The attribute to check
     * @return {Boolean} True if the attribute must not be serialized
     */
    ignoreAttribute: function(attrib) {
        var com = CUI.rte.Common;
        var attrName = attrib.nodeName.toLowerCase();
        if ((attrName == "id") && (this.idAttribMode == "remove")) {
            return true;
        }
        return com.arrayContains(CUI.rte.HtmlSerializer.HELPER_ATTRIBUTES, attrName);
    },

    /**
     * Adjusts the case of the specified string.
     * @private
     */
    adjustCase: function(str, strCase) {
        switch (strCase) {
            case "upper":
                str = str.toUpperCase();
                break;
            case "lower":
                str = str.toLowerCase();
                break;
        }
        return str;
    },

    /**
     * Creates the tag name string for the specified DOM element.
     * @param {HTMLElement} dom The DOM element to create the tag name for
     * @return {String} The tag name ("img", "IMG", "a", "table", ...)
     */
    createTagStr: function(dom) {
        return this.adjustCase(dom.tagName, this.tagCase);
    },

    /**
     * Serializes the specified attribute of the specified DOM element.
     * @param {String} name The name of the attribute to serialize
     * @param {String} value The value of the attribute to serialize
     */
    serializeAttribute: function(name, value) {
        name = this.adjustCase(name, this.attribNameCase);
        var nameLC = name.toLowerCase();
        if ((nameLC == "style") && (this.styleAttribNameCase != "keep")) {
            var styleDef = CUI.rte.HtmlProcessor.parseStyleDef(value);
            value = "";
            for (var styleName in styleDef) {
                if (styleDef.hasOwnProperty(styleName)) {
                    var styleValue = styleDef[styleName];
                    // IE 9 may report empty style parts; ignore them
                    if (styleValue && (styleValue.length > 0)) {
                        if (value.length > 0) {
                            value += " ";
                        }
                        styleName = this.adjustCase(styleName, this.styleAttribNameCase);
                        value += styleName + ": " + styleValue + ";";
                    }
                }
            }
        }
        // don't write empty attributes, they don't make sense at all ...
        if ((value == null) || (value.length == 0)) {
            return "";
        }
        // ignore colspan/rowspan of "1"
        if ((nameLC == "colspan") || (nameLC == "rowspan")) {
            if (parseInt(value) == 1) {
                return "";
            }
        }
        return name + "=\"" + CUI.rte.Utils.htmlEncode(value) + "\"";
    },

    /**
     * Serializes the attributes of the specified DOM element.
     * @param {HTMLElement} dom The DOM element
     */
    serializeAttributes: function(dom) {
        var com = CUI.rte.Common;
        var attribFilter = (com.ua.isGecko ? com.FILTER_GECKO_TEMPORARY_ATTRIBS : null);
        var attributeNames = com.getAttributeNames(dom, true, attribFilter);
        var attribCnt = attributeNames.length;
        var attribsStr = "";
        var isFirstAttrib = true;
        for (var a = 0; a < attribCnt; a++) {
            var attrib = dom.attributes.getNamedItem(attributeNames[a]);
            if (!this.ignoreAttribute(attrib)) {
                var attrName = attrib.nodeName;
                var attrNameLC = attrName.toLowerCase();
                // IE bugs around, at least if DOM is cloned, so again use a special
                // treatment
                var attrValue = this.getAttribValue(dom, attrName);
                if (!attrValue) {
                    if (attrNameLC == "style") {
                        attrValue = dom.style.cssText;
                    } else if (attrNameLC == "class") {
                        attrValue = dom.className;
                    }
                }
                // handle helper attributes
                var tagNameLC = dom.tagName.toLowerCase();
                var attribMapping = CUI.rte.HtmlSerializer.HELPER_ATTRIB_MAPPINGS[
                        tagNameLC];
                if (attribMapping) {
                    for (var m = 0; m < attribMapping.length; m += 2) {
                        var srcAttrib = attribMapping[m];
                        if (attrNameLC == srcAttrib) {
                            attrValue = this.getAttribValue(dom, attribMapping[m + 1]);
                            break;
                        }
                    }
                }
                // at last, do the actual serializing
                var serializedAttrib = this.serializeAttribute(attrName, attrValue);
                if (serializedAttrib.length > 0) {
                    if (!isFirstAttrib) {
                        attribsStr += " ";
                    } else {
                        isFirstAttrib = false;
                    }
                    attribsStr += serializedAttrib;
                }
            }
        }
        return attribsStr;
    },

    /**
     * Serializes the specified text node.
     * @param {HTMLElement} dom The text node to be serialized (must be a text node!)
     * @return {String} The serialized representation of the text node
     */
    serializeTextNode: function(dom) {
        var markup = CUI.rte.Utils.htmlEncode(dom.nodeValue);
        return markup.replace(/\u00A0/g, "&nbsp;");
    },

    /**
     * Serializes the specified DOM node on "entering" the node (= before
     * processing/serializing child nodes).
     * @param {HTMLElement} dom DOM node to serialize
     * @return {String} The serialized representation of the DOM node
     */
    serializeNodeEnter: function(dom) {
        var com = CUI.rte.Common;
        if (dom.nodeType == 3) {
            return this.serializeTextNode(dom);
        }
        var html = "<" + this.createTagStr(dom);
        var attribsStr = this.serializeAttributes(dom);
        if (attribsStr.length > 0) {
            html += " " + attribsStr;
        }
        html += ">";
        // insert an additional linebreak after opening "pre" tags
        if (com.isTag(dom, "pre")) {
            html += "\n";
        }
        // add &nbsp; to empty editing blocks
        if (com.isEmptyEditingBlock(dom, true)) {
            this.deepestChildAddHtml = "&nbsp;";
        }
        if (this.deepestChildAddHtml != null) {
            if (dom.childNodes.length == 0) {
                html += this.deepestChildAddHtml;
                this.deepestChildAddHtml = null;
            }
        }
        return html;
    },

    /**
     * Serializes the specified DOM node on "leaving" the node (= after
     * processing/serializing child nodes).
     * @param {HTMLElement} dom DOM node to serialize
     * @return {String} The serialized representation of the DOM node
     */
    serializeNodeLeave: function(dom) {
        if (dom.nodeType == 3) {
            return "";
        }
        var com = CUI.rte.Common;
        var html = "";
        if (!com.isTag(dom, this.nonClosingTags)) {
            html = "</" + this.createTagStr(dom) + ">";
            if (com.isTag(dom, "pre")) {
                html = "\n" + html;
            }
        }
        return html;
    },

    /**
     * Serializes the specified subtree, including the specified subtree root.
     * @param {HTMLElement} dom The subtree root
     * @return {String} The serialized representation of the specified subtree
     */
    serializeSubTree: function(dom) {
        var preHtml = this.beautifier(this.context, dom, true);
        var html = "";
        var nodeHtml = this.serializeNodeEnter(dom);
        if (preHtml) {
            if (preHtml.before) {
                html = preHtml.before;
            }
            html += nodeHtml;
            if (preHtml.after) {
                html += preHtml.after;
            }
        }
        else {
            html = nodeHtml;
        }
        var childCnt = dom.childNodes.length;
        for (var c = 0; c < childCnt; c++) {
            html += this.serializeSubTree(dom.childNodes[c]);
        }
        nodeHtml = this.serializeNodeLeave(dom);
        var postHtml = this.beautifier(this.context, dom, false);
        if (postHtml) {
            if (postHtml.before) {
                html += postHtml.before;
            }
            html += nodeHtml;
            if (postHtml.after) {
                html += postHtml.after;
            }
        } else {
            html += nodeHtml;
        }
        return html;
    },

    /**
     * <p>Serializes the specified DOM (sub-) tree.</p>
     * <p>Note that the specified DOM element itself doesn't get serialized.</p>
     * @param {CUI.rte.EditContext} context The edit context
     * @param {HTMLElement} dom The DOM (sub-) tree to serialize
     * @return {String} The serialized representation of the DOM (sub-) tree
     */
    serialize: function(context, dom) {
        this.context = context;
        this.deepestChildAddHtml = null;
        var html = "";
        var childCnt = dom.childNodes.length;
        for (var c = 0; c < childCnt; c++) {
            html += this.serializeSubTree(dom.childNodes[c]);
        }
        return html;
    }

});

/**
 * Array containing (default) tags that should not have a closing tag in HTML
 * @type String[]
 * @private
 */
CUI.rte.HtmlSerializer.NON_CLOSING_TAGS = [ "br", "hr", "img", "area", "input", "col" ];

/**
 * Array that defines helper attributes that will not be serialized
 * @type String[]
 * @private
 */
CUI.rte.HtmlSerializer.HELPER_ATTRIBUTES = [
    CUI.rte.Common.HREF_ATTRIB,
    CUI.rte.Common.SRC_ATTRIB
];

/**
 * Object that defines the mapping of helper attributes
 * @type Object
 * @private
 */
CUI.rte.HtmlSerializer.HELPER_ATTRIB_MAPPINGS = {
    "a": [ "href", CUI.rte.Common.HREF_ATTRIB ],
    "img": [ "src", CUI.rte.Common.SRC_ATTRIB ]
};

CUI.rte.HtmlSerializer.defaultBeautifier = function(context, dom, isNodeEnter) {
    var com = CUI.rte.Common;
    if (com.isTag(dom, com.BLOCK_TAGS)) {
        if (isNodeEnter) {
            if (!com.isTag(dom, com.EDITBLOCK_TAGS)) {
                return {
                    "before": null,
                    "after": "\n"
                };
            }
        } else {
            return {
                "before": null,
                "after": "\n"
            };
        }
        return null;
    }
    if (com.isTag(dom, com.EDITBLOCK_TAGS)) {
        if (!isNodeEnter) {
            return {
                "before": null,
                "after": "\n"
            };
        }
        return null;
    }
    if (com.isTag(dom, "br")) {
        if (!isNodeEnter) {
            // don't add \n if we have a Gecko/WebKit empty line placeholder
            if (!com.ua.isIE) {
                var editBlock = com.getTagInPath(context, dom, com.EDITBLOCK_TAGS);
                if (editBlock) {
                    var contentNodes = com.getCharacterNodes(editBlock);
                    if (contentNodes.length == 1) {
                        return null;
                    }
                }
            }
            return {
                "before": null,
                "after": "\n"
            };
        }
    }
    return null;
};
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.XhtmlSerializer
 * @extends CUI.rte.HtmlSerializer
 * The XhtmlSerializer is used to serialize a DOM (sub-) tree to its XHTML (String)
 * equivalent.
 * @constructor
 * Creates a new XHtmlSerializer.
 * @param {Object} config The configuration object
 */
CUI.rte.XhtmlSerializer = new Class({

    toString: "XhtmlSerializer",

    extend: CUI.rte.HtmlSerializer,

    /**
     * @cfg {String[]} nonClosingTags
     * @hide
     * Must be set to [ ] for XHTML conformity
     */

    /**
     * @cfg {String} tagCase
     * @hide
     * Must be set to "lower" for XHTML conformity
     */

    /**
     * @cfg {String} attribNameCase
     * @hide
     * Must be set to "lower" for XHTML conformity
     */

    /**
     * @cfg {Boolean} useShortTags
     * Determines if "short tags" (i.e. &lt;br /&gt; should be used for empty elements;
     * defaults to false
     */
    useShortTags: false,


    _init: function(config) {
        config = config || { };
        delete config.tagCase;
        delete config.attribNameCase;
        delete config.nonClosingTags;
        CUI.rte.Utils.applyDefaults(config, {
            "tagCase": "lower",
            "attribNameCase": "lower",
            "useShortTags": false,
            "nonClosingTags": [ ]
        });
        this.inherited(arguments);
    },

    isShortTag: function(dom) {
        var com = CUI.rte.Common;
        if (com.isTag(dom, "a") && com.isAttribDefined(dom, "name")) {
            return false;
        }
        return (dom.childNodes.length == 0);
    },

    serializeNodeEnter: function(dom) {
        var com = CUI.rte.Common;
        if (dom.nodeType == 1) {
            if (this.useShortTags && this.isShortTag(dom)) {
                // Handle short tags that are no edit blocks here. If the empty
                // node is an edit block, the superclass will convert it to (for example)
                // <p>&nbsp;</p> instead of the (invalid) <p />.
                if (!com.isTag(dom, com.EDITBLOCK_TAGS)) {
                    var html = "<" + this.createTagStr(dom);
                    var attribsStr = this.serializeAttributes(dom);
                    if (attribsStr.length > 0) {
                        html += " " + attribsStr;
                    }
                    if (this.deepestChildAddHtml != null) {
                        html += ">" + this.deepestChildAddHtml;
                        html += "</" + this.createTagStr(dom) + ">";
                    } else {
                        html += " />";
                    }
                    return html;
                }
            }
        }
        return this.inherited(arguments);
    },

    serializeNodeLeave: function(dom) {
        var com = CUI.rte.Common;
        if (dom.nodeType == 1) {
            if (!com.isTag(dom, com.EDITBLOCK_TAGS)) {
                if (this.useShortTags && this.isShortTag(dom)) {
                    return "";
                }
            }
        }
        return this.inherited(arguments);
    }

});
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.Deserializer
 * <p>The Serializer class works as an "interface" for providing fully customized HTML
 * deserializers.</p>
 * <p>Deserializers are used to convert persisted HTML into a suitable DOM tree before
 * they are being edited.</p>
 * <p>You should only consider implementing this interface directly if you have very special
 * requirements. Usually, it should make more sense to extend one of the default
 * serializers, {@link CUI.rte.HtmlDeserializer} or
 * {@link CUI.rte.XhtmlDeserializer}.</p>
 * <p>Deserializers should usually do the following cleanup/adjustments:</p>
 * <ul>
 *   <li>Correct the incoming (X)HTML to be browser-compatible. For example, IE chokes if
 *     XHTML is directly set to the DOM.</li>
 * </ul>
 */
CUI.rte.Deserializer = new Class({

    toString: "Deserializer",

    /**
     * <p>Deserializes the specified HTML to the sppecified DOM root element.</p>
     * <p>Note that the specified DOM element itself is kept as is.</p>
     * @param {CUI.rte.EditContext} context The edit context
     * @param {String} html The HTML to be deserialized
     * @param {HTMLElement} rootDom The DOM (sub-) tree to deserialize the HTML to
     */
    deserialize: function(context, html, rootDom) {
        // must be overridden by the implementing class
    }

});
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.HtmlDeserializer
 * @extends CUI.rte.Deserializer
 * The HtmlDeserializer is used to deserialize HTML code to a suitable DOM tree.
 * @constructor
 * Creates a new HtmlDeserializer.
 * @param {Object} config The configuration object
 */
CUI.rte.HtmlDeserializer = new Class({

    toString: "HtmlDeserializer",

    extend: CUI.rte.Deserializer,

    construct: function(config) {
        this._init(config);
    },

    _init: function() {
        // may be overridden
    },

    /**
     * <p>Duplicates references to temporary attributes that are safe from being
     * changed deliberately by the browser.</p>
     * <p>For example, &lt;a href="/content/bla/en/blubb.html"&gt; is changed into
     * &lt;a href="/content/bla/en/blubb.html" _rte_href="/content/bla/en/blubb.html"&gt;.
     * </p>
     * @param {String} html The HTML code to process
     * @return {String} The processed HTML code
     */
    duplicateReferences: function(html) {
        var rules = CUI.rte.HtmlDeserializer.DUPLICATE_RULES;
        var ruleCnt = rules.length;
        for (var r = 0; r < ruleCnt; r++) {
            var rule = rules[r];
            html = html.replace(rule[0], rule[1]);
        }
        return html;
    },

    /**
     * Deserializes the specified HTML code to the specified DOM element.
     * @param {CUI.rte.EditContext} context The edit context
     * @param {String} html The HTML to be deserialized
     * @param {HTMLElement} rootDom The DOM (sub-) tree to deserialize the HTML to
     */
    deserialize: function(context, html, rootDom) {
        html = this.duplicateReferences(html);
        rootDom.innerHTML = html;
    }

});

/**
 * Array that defines the rules required for duplicating references to temporary attributes
 * that are safe from being changed deliberately by the browser. Each element consists of
 * two sub-elements. The first contains the regular expression used to match tags that
 * require attribute duplication; the second element contains the replacement string that
 * does the actual duplication .
 * @type Object[][]
 * @private
 */
CUI.rte.HtmlDeserializer.DUPLICATE_RULES = [ [
        /(<a[^>]*?href=")([^"]*?)(")((.|\n|\r)*?>)/gi,
        "$1$2$3 " + CUI.rte.Common.HREF_ATTRIB + "=\"$2\"$4"
    ], [
        /(<img[^>]*?src=")([^"]*?)(")((.|\n|\r)*?>)/gi,
        "$1$2$3 " + CUI.rte.Common.SRC_ATTRIB + "=\"$2\"$4"
    ]
];
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.XhtmlDeserializer
 * @extends CUI.rte.HtmlDeserializer
 * The HtmlDeserializer is used to deserialize XHTML code to a suitable DOM tree.
 * @constructor
 * Creates a new XhtmlDeserializer.
 * @param {Object} config The configuration object
 */
CUI.rte.XhtmlDeserializer = new Class({

    toString: "XhtmlDeserializer",

    extend: CUI.rte.HtmlDeserializer,

    _init: function() {
        this.inherited(arguments)
        // build Regex to remove unnecessary/harmful closing tags
        var nct = CUI.rte.HtmlSerializer.NON_CLOSING_TAGS;
        var regExpStr = "<\\/(";
        for (var n = 0; n < nct.length; n++) {
            if (n > 0) {
                regExpStr += "|";
            }
            regExpStr += nct[n];
        }
        regExpStr += ")>";
        this.regExp = new RegExp(regExpStr, "gi");
    },

    /**
     * Expands XHTML "short tags", as they confuse Internet Explorer.
     * @param {String} xhtml The XHTML to expand
     * @return {String} The expanded XHTML
     */
    expandShortTags: function(xhtml) {
        var xds = CUI.rte.XhtmlDeserializer;
        var expanded = xhtml.replace(xds.EXPAND_SHORT_XHTML,
                xds.XHTML_EXPANSION_REPLACEMENT);
        return expanded.replace(this.regExp, "");
    },

    /**
     * Deserializes the specified XHTML-compliant HTML code to the specified DOM element.
     * </p>
     * @param {CUI.rte.EditContext} context The edit context
     * @param {String} xhtml The HTML to be deserialized
     * @param {HTMLElement} rootDom The DOM (sub-) tree to deserialize the HTML to
     */
    deserialize: function(context, xhtml, rootDom) {
        // preprocess short tags
        xhtml = this.expandShortTags(xhtml);
        xhtml = this.duplicateReferences(xhtml);
        rootDom.innerHTML = xhtml;
    }

});

/**
 * Regular expression that is used to expand XHTML short tags
 * (&lt;a name="xyz"/&gt; -&gt; &lt;a name="xyz&gt;&lt;/a&gt;
 */
CUI.rte.XhtmlDeserializer.EXPAND_SHORT_XHTML = /<([^\/][^\n\r\t >]*)([^>]*)(\/>)/gi;

/**
 * Replacement pattern that is used to expand XHTML short tags
 */
CUI.rte.XhtmlDeserializer.XHTML_EXPANSION_REPLACEMENT = "<$1$2></$1>";
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.DomCleanup
 * This class implements a DOM-based cleanup module to ensure that the input can be
 * processed and the output is suitable for persisting it (the actual HTML is generated by
 * the component's {@link CUI.rte.HtmlSerializer}, which applies additional rules to
 * cleanup the generated HTML).
 * @constructor
 * Creates a new DomCleanup.
 * @param {Object} config The kernel's configuration
 */
CUI.rte.DomCleanup = new Class({

    toString: "DomCleanup",

    /**
     * @cfg {String[]} tagsToRemove
     * List of tags to be removed
     */
    tagsToRemove: null,

    /**
     * Rules for preprocessing pasted content. Only valid if {@link #prepareHtmlPaste} is
     * used. Format is defined at {@link CUI.rte.plugins.EditToolsPlugin#htmlPasteRules}
     * @private
     * @type Object
     */
    pasteRules: null,

    /**
     * The editor kernel we're working on
     * @private
     * @type CUI.rte.EditorKernel
     */
    editorKernel: null,

    /**
     * The edit context we're working in
     * @private
     * @type CUI.rte.EditContext
     */
    context: null,

    /**
     * The current HTML rules
     * @private
     * @type CUI.rte.HtmlRules
     */
    htmlRules: null,

    /**
     * Processing mode; as defined by the constants of this class.
     * @private
     * @type Number
     */
    processingMode: null,

    /**
     * Array of DOM elements to be removed after traversing the DOM tree
     * @private
     * @type HTMLElement[]
     */
    elementsToRemove: null,

    /**
     * Array of DOM elements to be changed after traversing the DOM tree. Each array
     * element has a domToChange property that determines the element to be changed, and
     * a changedDom property that defines the changed element.
     * @private
     * @type Object[]
     */
    elementsToChange: null,

    /**
     * Array of DOM elements to be inserted after traversing the DOM tree. Each array
     * element has a domToInsert property that determines the element to be inserted, a
     * parentDom property that defines the parent element it gets appended to, and an
     * (optional) refDom property that determines the sibling element the new element gets
     * inserted before
     */
    elementsToInsert: null,

    /**
     * Array of empty editing blocks that have to be "fixed for editing" on IE
     */
    emptyBlocksIE: null,


    construct: function(config) {
        CUI.rte.Utils.apply(this, config);
    },


    // -- Helpers --------------------------------------------------------------------------

    /**
     * <p>Marks the specified DOM element for being removed.</p>
     * <p>Using this method prevents that the same DOM element is added multiple times
     * to the list of elements to be removed.</p>
     * @param {HTMLElement} dom The DOM element to be removed
     */
    markForRemoval: function(dom) {
        if (!CUI.rte.Common.arrayContains(this.elementsToRemove, dom)) {
            this.elementsToRemove.push(dom);
        }
    },

    /**
     * Marks the specified DOM element for be inserted according the specified rules.
     * @param {HTMLElement} dom The element to be inserted
     * @param {HTMLElement} parentDom The parent element
     * @param {HTMLElement} siblingRef (optional) The element the new element is inserted
     *        before; if not specified, the DOM element will be appended
     */
    markForInsertion: function(dom, parentDom, siblingRef) {
        this.elementsToInsert.push({
            "domToInsert": dom,
            "parentDom": parentDom,
            "refDom": siblingRef
        })
    },

    /**
     * <p>Checks if we are doing any preprocessing.</p>
     * <p>This method returns true for "default" preprocessing, but also for paste
     * preprocessing.</p>
     * @return {Boolean} True if any kind of preprocessing is currently executed
     */
    isPreProcessing: function() {
        var dcu = CUI.rte.DomCleanup;
        return (this.processingMode == dcu.PASTE_PREPARE)
                || (this.processingMode == dcu.PRE);
    },

    /**
     * Flattens the specified DOM element by creating paragraphs from the specified
     * container structures and removing nested structures of the specified type.
     * @param {HTMLElement} dom The DOM element to be flattened
     * @param {String|String[]} tagsToFlatten Defines the tag or tags that contain content
     *        to be flattened; for example: "li" for list items
     * @param {String|String[]} nestingTags Defines the tag or tags that mark nested
     *        striucture; for example: "table" for nested tables
     * @return {HTMLElement} The first flattened element (changed container element)
     */
    flattenNestedStructure: function(dom, tagsToFlatten, nestingTags) {
        var com = CUI.rte.Common;
        var continueDom = null;
        var parentRef = dom.parentNode;
        var insertRef = dom.nextSibling;
        var replacementTag = this.pasteRules.fallbackBlockTag || "p";
        var nodesToFlatten = com.getTags(dom, tagsToFlatten);
        var nodeCnt = nodesToFlatten.length;
        for (var n = 0; n < nodeCnt; n++) {
            var domToFlatten = nodesToFlatten[n];
            var flattenedDom = this.context.createElement(replacementTag);
            if (continueDom == null) {
                continueDom = flattenedDom;
            }
            com.insertBefore(parentRef, flattenedDom, insertRef);
            // move children - skip nested containers (nested content elements are already
            // included in nodesToFlatten)
            var children = domToFlatten.childNodes;
            while (children.length > 0) {
                var childToMove = children[0];
                if (!com.isTag(childToMove, nestingTags)) {
                    flattenedDom.appendChild(childToMove);
                }
            }
        }
        dom.parentNode.removeChild(dom);
        return continueDom;
    },


    // -- Processing methods ---------------------------------------------------------------

    /**
     * Checks if the specified DOM element is valid according to current rules.
     * @param {HTMLElement} dom The DOM element to check
     * @return {Boolean} True if the DOM element is considered valid
     */
    isValidElement: function(dom) {
        var com = CUI.rte.Common;
        var tagName = dom.tagName.toLowerCase();
        var namespace = com.getNamespace(dom);
        if (namespace != null) {
            return false;
        }
        if (this.tagsToRemove) {
            if (com.arrayContains(this.tagsToRemove, tagName)) {
                return false;
            }
        }
        if (com.isTag(dom, "span") && com.isAttribDefined(dom, "_rtetemp")) {
            return false;
        }
        return true;
    },

    /**
     * <p>Change linefeeds in preformatted sections into "br" tags - although this is
     * no correct HTML, browsers tend to be more stable with br tags (and selection handling
     * is much easier) while editing.</p>
     */
    handlePreformattedSection: function(dom) {
        var context = this.context;
        var com = CUI.rte.Common;
        if (this.isPreProcessing()) {
            if (com.isTag(dom, "pre")) {
                var recurse = function(toProcess) {
                    var parentNode = toProcess.parentNode;
                    if (toProcess.nodeType == 3) {
                        var nodeText = toProcess.nodeValue;
                        nodeText = nodeText.replace(/\r\n/g, "\n");
                        nodeText = nodeText.replace(/\r/g, "\n");
                        do {
                            var pos = nodeText.indexOf("\n");
                            if (pos >= 0) {
                                if (pos > 0) {
                                    parentNode.insertBefore(context.createTextNode(
                                            nodeText.substring(0, pos)), toProcess);
                                }
                                parentNode.insertBefore(context.createElement("br"),
                                        toProcess);
                                nodeText = nodeText.substring(pos + 1, nodeText.length);
                            }
                        } while (pos >= 0);
                        if (nodeText.length == 0) {
                            parentNode.removeChild(toProcess);
                        } else {
                            toProcess.nodeValue = nodeText;
                        }
                    } else if (toProcess.nodeType == 1) {
                        var childCnt = toProcess.childNodes.length;
                        for (var c = childCnt - 1; c >= 0; c--) {
                            recurse(toProcess.childNodes[c]);
                        }
                    }
                };
                recurse(dom);
                // remove trailing br (if there is one), as it is implied by the closing
                // pre tag
                var lastTextChild = com.getLastTextChild(dom, true, false);
                if (com.isTag(lastTextChild, "br")) {
                    var predesc = com.getPreviousCharacterNode(context, lastTextChild,
                            com.EDITBLOCK_TAGS);
                    if (com.isTag(predesc, "br")) {
                        if (com.ua.isGecko || com.ua.isWebKit) {
                            com.setAttribute(lastTextChild, com.BR_TEMP_ATTRIB, "brEOB");
                        } else if (com.ua.isIE) {
                            lastTextChild.parentNode.removeChild(lastTextChild);
                            CUI.rte.DomProcessor.fixEmptyLinefeedIE(context, predesc);
                        }
                    } else {
                        lastTextChild.parentNode.removeChild(lastTextChild);
                    }
                }
            }
        } else {
            // change "\n"'s into "br"s inside "pre" blocks, as browsers tend to be more
            // stable when linefeeds are still represented as "br" while editing
            // (counterpart is in handlePreformattedSection)
            if (com.isTag(dom, "br")
                    && com.getTagInPath(this.context, dom, "pre")) {
                this.elementsToChange.push({
                    "domToChange": dom,
                    "changedDom": this.context.createTextNode("\n")
                });
            }
        }
    },

    /**
     * <p>Handles empty lines at the end of blocks for the browsers that require it
     * (currently WebKit and Gecko).</p>
     * <p>Additional "br" tags get removed on reverse cleanup again (see isValidElement).
     * </p>
     * @param {HTMLElement} dom The
     */
    handleEmptyLinesAtEOB: function(dom) {
        var com = CUI.rte.Common;
        var dpr = CUI.rte.DomProcessor;
        var brReplacement;
        if (this.isPreProcessing()) {
            var text = com.getNodeText(dom);
            if ((text == dpr.NBSP) && dpr.isBlockEnd(this.context, dom))   {
                if (com.ua.isWebKit || com.ua.isGecko) {
                    // Gecko/WebKit: replace &nbsp;s that are placeholders for empty lines
                    // at the end of a block by appropriately marked additional <br>s
                    brReplacement = this.context.createElement("br");
                    com.setAttribute(brReplacement, com.BR_TEMP_ATTRIB, "brEOB");
                    this.elementsToChange.push({
                        "domToChange": dom,
                        "changedDom": brReplacement
                    });
                } else if (com.ua.isIE) {
                    // IE: remove &nbsp;s that are placeholders for empty blocks
                    var prevNode = com.getPreviousCharacterNode(this.context, dom,
                            com.EDITBLOCK_TAGS);
                    if (com.isTag(prevNode, "br")) {
                        // placeholder for empty line at the end of an empty block
                        this.markForRemoval(dom);
                        dpr.fixEmptyLinefeedIE(this.context, prevNode);
                    } else if (!prevNode) {
                        this.markForRemoval(dom);
                        var block = dpr.getEditBlock(this.context, dom);
                        this.emptyBlocksIE.push(block);
                    }
                }
            }
        } else {
            if (com.ua.isGecko || com.ua.isWebKit) {
                // Gecko/Webkit: Remove unnecessary <br> nodes; replace them by &nbsp;s
                // if they are placeholders for empty lines at the end of a block;
                // "br"s in "pre" areas are handled in handlePreformattedSection()
                if (com.isTag(dom, "br") && !com.getTagInPath(this.context, dom, "pre")) {
                    var editBlock = com.getTagInPath(this.context, dom, com.EDITBLOCK_TAGS);
                    var isEmptyBlock =
                            editBlock && (com.getCharacterNodes(editBlock).length == 1);
                    if (isEmptyBlock) {
                        this.markForRemoval(dom);
                    } else {
                        var isMarkedDirty = com.isAttribDefined(dom, com.BR_TEMP_ATTRIB)
                                || com.hasAttributes(dom, { "type": "_moz" });
                        if (isMarkedDirty && dpr.isBlockEnd(this.context, dom)) {
                            this.elementsToChange.push({
                                "domToChange": dom,
                                "changedDom": this.context.createTextNode(dpr.NBSP)
                            });
                        }
                    }
                }
            } else if (com.ua.isIE) {
                // IE: Add &nbsp; if required
                if (com.isTag(dom, "br") && dpr.isBlockEnd(this.context, dom)) {
                    var nbsp = this.context.createTextNode(dpr.NBSP);
                    this.markForInsertion(nbsp, dom.parentNode);
                }
            }
        }
    },

    /**
     * Enforces HTML rules on the specified DOM element.
     * @param {HTMLElement} dom The DOM element to apply rules to
     * @return {Boolean} True if the DOM element was marked for removal
     */
    applyHtmlRules: function(dom) {
        // todo maybe we should move an extended version of this method to HtmlRules for common use?
        var com = CUI.rte.Common;
        // adjust tag names to more appropriate (regarding editing) tag names if
        // necessary
        var tagName = dom.tagName.toLowerCase();
        var changedTagName = (this.isPreProcessing() ?
            this.htmlRules.docType.adjustToRaw(tagName)
            : this.htmlRules.docType.adjustToDocType(tagName));
        var changedDom;
        if (changedTagName != null) {
            if (changedTagName.length > 0) {
                changedDom = this.context.createElement(changedTagName);
                this.elementsToChange.push({
                    "domToChange": dom,
                    "changedDom": changedDom
                });
            } else { //#37049 - remove blacklisted tags
                this.elementsToRemove.push(dom);
                return true;
            }
            return false;
        }
        if (this.isPreProcessing()) {
            // handle links (add attributes as specified by rules, remove links with invalid
            // HREFs)
            if (com.isTag(dom, "a")) {
                var href = com.getAttribute(dom, "href");
                if (href) {
                    if (this.htmlRules.links.validateHref(href)) {
                        this.htmlRules.links.applyToObject(dom);
                        return false;
                    } else {
                        this.markForRemoval(dom);
                        return true;
                    }
                }
            }
        }
        return false;
    },

    /**
     * <p>Handles alignment for the specified DOM element.</p>
     * <p>It is ensured that for several block tags the "style" attribute is used rather
     * than the "align" attribute (due to editing restrictions of several browsers).</p>
     * @param {HTMLElement} dom The DOM element to process
     */
    handleAlignment: function(dom) {
        var com = CUI.rte.Common;
        // currently, we only do this for div/p tags
        var tagsToHandle = [ "p", "div" ];
        if (com.isTag(dom, tagsToHandle)) {
            if (this.isPreProcessing()) {
                var alignAttrib = com.getAttribute(dom, "align", true);
                if (alignAttrib) {
                    com.removeAttribute(dom, "align");
                    dom.style.textAlign = alignAttrib;
                }
            }
        }
    },

    /**
     * <p>Handles "a" elements.</p>
     * <p>For named anchors, this means that a suitable CSS class is applied or removed.
     * Additionally, the DOM will be changed to meet editing requirements if necessary.</p>
     * <p>For links, a RTE-specific property is added that holds the original HREF. On
     * postprocessing, this RTE-specific property is moved to the HREF attribute again.</p>
     * <p>You can specify any DOM element, as the element is checked before it is
     * actually processed.</p>
     * @param {HTMLElement} dom The DOM element
     */
    handleAnchor: function(dom) {
        var com = CUI.rte.Common;
        var dcu = CUI.rte.DomCleanup;
        var nameAttrib;
        if (com.isTag(dom, "a")) {
            nameAttrib = com.getAttribute(dom, "name", true);
            var hrefAttrib = CUI.rte.HtmlRules.Links.getLinkHref(dom);
            if (nameAttrib) {
                if (this.isPreProcessing()) {
                    // change <a name="bla">text</a> to <a name="bla"></a>text
                    var children = dom.childNodes;
                    var parentDom = dom.parentNode;
                    var insertRef = dom.nextSibling;
                    while (children.length > 0) {
                        com.insertBefore(parentDom, children[0], insertRef);
                    }
                    if (!com.ua.isWebKit) {
                        com.addClass(dom, CUI.rte.Theme.ANCHOR_CLASS);
                    } else {
                        var imgReplacement = this.context.createElement("img");
                        com.setAttribute(imgReplacement, "src",
                                CUI.rte.Utils.getBlankImageUrl());
                        com.setAttribute(imgReplacement, com.A_NAME_REPLACEMENT_ATTRIB,
                                nameAttrib);
                        com.addClass(imgReplacement, CUI.rte.Theme.ANCHOR_CLASS);
                        this.elementsToChange.push({
                            "domToChange": dom,
                            "changedDom": imgReplacement
                        });
                    }
                } else if (this.processingMode == dcu.POST) {
                    com.removeClass(dom, CUI.rte.Theme.ANCHOR_CLASS);
                }
            }
            if (hrefAttrib) {
                if (this.processingMode == dcu.PASTE_PREPARE) {
                    var helperAttrib = com.getAttribute(dom, com.HREF_ATTRIB);
                    if (!helperAttrib) {
                        com.setAttribute(dom, com.HREF_ATTRIB, hrefAttrib);
                    }
                }
            }
        } else if (com.ua.isWebKit && com.isTag(dom, "img")
                && com.isAttribDefined(dom, com.A_NAME_REPLACEMENT_ATTRIB)) {
            if (!this.isPreProcessing()) {
                var anchorDom = this.context.createElement("a");
                nameAttrib = com.getAttribute(dom, com.A_NAME_REPLACEMENT_ATTRIB);
                com.setAttribute(anchorDom, "name", nameAttrib);
                this.elementsToChange.push({
                    "domToChange": dom,
                    "changedDom": anchorDom
                });
            }
        }
    },

    /**
     * <p>Handles images.</p>
     * <p>Here, the SRC-attribute is doubled for editing, as browser do nasty things with
     * it.</p>
     * <p>You can specify any DOM element, as the element is checked before it is
     * actually processed.</p>
     * @param {HTMLElement} dom The DOM element
     */
    handleImage: function(dom) {
        var com = CUI.rte.Common;
        var dcu = CUI.rte.DomCleanup;
        var srcAttrib;
        if ((this.processingMode == dcu.PRE) && com.isTag(dom, "img")) {
            srcAttrib = com.getAttribute(dom, CUI.rte.Common.SRC_ATTRIB);
            srcAttrib = (srcAttrib ? srcAttrib : com.getAttribute(dom, "src", true));
            com.setAttribute(dom, "src", CUI.rte.Utils.processUrl(srcAttrib,
                    CUI.rte.Utils.URL_IMAGE));
        }
        if (this.processingMode == dcu.PASTE_PREPARE) {
            if (com.isTag(dom, "img")) {
                srcAttrib = com.getAttribute(dom, "src", true);
                if (srcAttrib) {
                    var helperAttrib = com.getAttribute(dom, CUI.rte.Common.SRC_ATTRIB);
                    if (!helperAttrib) {
                        com.setAttribute(dom, CUI.rte.Common.SRC_ATTRIB, srcAttrib);
                    }
                }
            }
        }
    },

    /**
     * <p>Handles tables.</p>
     * <p>In this case, table without a border get a class added that makes the border
     * temporarily visible for editing.</p>
     * <p>You can specify any DOM element, as the element is checked before it is
     * actually processed.</p>
     * @param {HTMLElement} dom The DOM element
     */
    handleTable: function(dom) {
        var com = CUI.rte.Common;
        var dcu = CUI.rte.DomCleanup;
        if (com.isTag(dom, "table")) {
            var borderAttrib = com.getAttribute(dom, "border", true);
            var hasBorder = false;
            if (borderAttrib) {
                try {
                    hasBorder = (parseInt(borderAttrib) > 0);
                } catch (e) {
                    // ignore, as we can't do anything about it
                }
            }
            if (!hasBorder) {
                if (this.isPreProcessing()) {
                    com.addClass(dom, CUI.rte.Theme.TABLE_NOBORDER_CLASS);
                } else if (this.processingMode == dcu.POST) {
                    com.removeClass(dom, CUI.rte.Theme.TABLE_NOBORDER_CLASS);
                }
            }
        } else if (com.isTag(dom, [ "td", "th"] )) {
            if (this.processingMode == dcu.POST) {
                com.removeClass(dom, CUI.rte.Theme.TABLESELECTION_CLASS);
            }
        }
    },

    /**
     * <p>Handles lists.</p>
     * <p>It is ensured that nested lists are correctly structured.</p>
     * @param {HTMLElement} dom The DOM element
     */
    handleList: function(dom) {
        var com = CUI.rte.Common;
        var lut = CUI.rte.ListUtils;
        if (com.isTag(dom, com.LIST_TAGS)) {
            if (lut.isTopLevelList(this.context, dom)) {
                var listProcessor = new CUI.rte.ListRepresentation();
                listProcessor.fromItem(this.context, dom);
                listProcessor.ensureHierarchy(this.context);
            }
        }
    },

    /**
     * <p>Handles style information in the style attribute of span elements.</p>
     * @param {HTMLElement} dom The DOM element
     */
    handleSpanStyles: function(dom) {
        var com = CUI.rte.Common;
        if (this.isPreProcessing()) {
            if (com.isTag(dom, "span")) {
                var changedDom, changeDef;
                if (dom.style.fontWeight == "bold") {
                    changedDom = this.context.createElement("b");
                    changeDef = {
                        "domToChange": dom,
                        "changedDom": changedDom
                    };
                }
                if (dom.style.fontStyle == "italic") {
                    var italicDom = this.context.createElement("i");
                    if (changedDom) {
                        changedDom.appendChild(italicDom);
                        changeDef.childDom = italicDom;
                    } else {
                        changedDom = italicDom;
                        changeDef = {
                            "domToChange": dom,
                            "changedDom": changedDom
                        };
                    }
                }
                if (dom.style.textDecoration == "underline") {
                    var underlineDom = this.context.createElement("u");
                    if (changedDom) {
                        if (changeDef.childDom) {
                            changeDef.childDom.appendChild(underlineDom);
                        } else {
                            changedDom.appendChild(underlineDom);
                        }
                        changeDef.childDom = underlineDom;
                    } else {
                        changedDom = underlineDom;
                        changeDef = {
                            "domToChange": dom,
                            "changedDom": changedDom
                        };
                    }
                }
                if (changeDef) {
                    this.elementsToChange.push(changeDef);
                }
            }
        }
    },

    /**
     * This method handles several specific tags.
     * @param {HTMLElement} dom The DOM element
     */
    handleSpecificTags: function(dom) {
        this.handleAlignment(dom);
        this.handleAnchor(dom);
        this.handleImage(dom);
        this.handleTable(dom);
        this.handleSpanStyles(dom);
        this.handleList(dom);
        this.handlePreformattedSection(dom);
    },

    /**
     * This method handles empty content.
     * @param {HTMLElement} rootDom The root DOM
     */
    handleEmptyContent: function(rootDom) {
        var com = CUI.rte.Common;
        var dpr = CUI.rte.DomProcessor;
        var dcu = CUI.rte.DomCleanup;
        if (this.processingMode == dcu.PRE) {
            if (rootDom.childNodes.length == 0) {
                var placeholder = dpr.createEmptyLinePlaceholder(this.context, true,
                        this.htmlRules.blockHandling.defaultEditBlockType);
                rootDom.appendChild(placeholder);
            } else if (rootDom.childNodes.length == 1) {
                // newer Firefox versions automatically change an empty string set as
                // innerHTML into a single <br> node (which is corrected into <p><br></p>
                // by handleContainerRules
                var blockNode = rootDom.childNodes[0];
                var textNodes = com.getCharacterNodes(blockNode);
                if ((textNodes.length == 1) && com.isTag(textNodes[0], "br")) {
                    com.setAttribute(textNodes[0], com.BR_TEMP_ATTRIB, "brEOB");
                }
            }
        } else if (this.processingMode == dcu.POST) {
            if (rootDom.childNodes.length == 1) {
                var singleChild = rootDom.childNodes[0];
                if (com.isTag(singleChild, com.EDITBLOCK_TAGS)) {
                    if (dpr.isEmptyLineBlock(singleChild)) {
                        rootDom.removeChild(singleChild);
                    }
                }
            }
        }
    },


    /**
     * Handles container-related HTML rules, such as removing the block around a single
     * content block if configured accordingly.
     * @param {HTMLElement} rootDom The root DOM
     */
    handleContainerRules: function(rootDom) {
        var com = CUI.rte.Common;
        var dpr = CUI.rte.DomProcessor;
        var dcu = CUI.rte.DomCleanup;
        var blockRules = this.htmlRules.blockHandling;
        var defaultEditBlock = blockRules.defaultEditBlockType;
        var blockRepTag = blockRules.singleParagraphContainerReplacement;
        if (this.processingMode == dcu.PRE) {
            dpr.ensureBlockContent(this.context, defaultEditBlock, null, false, false);
            dpr.adjustTables(this.context);
            var fixIECnt = this.emptyBlocksIE.length;
            for (var i = 0; i < fixIECnt; i++) {
                dpr.fixEmptyEditingBlockIE(this.context, this.emptyBlocksIE[i]);
            }
        } else if (this.processingMode == dcu.POST) {
            if (blockRules.removeSingleParagraphContainer) {
                var rootElCnt = rootDom.childNodes.length;
                if (rootElCnt == 1) {
                    var blockDom = rootDom.childNodes[0];
                    if (com.isTag(blockDom, defaultEditBlock)) {
                        var bStyle = blockDom.style;
                        var blockClass = com.getAttribute(blockDom, "class", true);
                        if (blockClass || bStyle.textAlign || bStyle.marginLeft) {
                            // change tag, as there are properties to keep on the single
                            // block
                            if (defaultEditBlock != blockRepTag) {
                                var newBlockDom = this.context.createElement(blockRepTag);
                                if (blockClass) {
                                    com.setAttribute(newBlockDom, "class", blockClass);
                                }
                                if (bStyle.textAlign) {
                                    newBlockDom.style.textAlign = bStyle.textAlign;
                                }
                                if (bStyle.marginLeft) {
                                    newBlockDom.style.marginLeft = bStyle.marginLeft;
                                }
                                com.replaceNode(blockDom, newBlockDom);
                            }
                        } else {
                            // nothing to keep, so we'll simply remove the single block
                            dpr.removeWithoutChildren(blockDom);
                        }
                    }
                }
            }
        }
    },


    // -- Additional paste processing ------------------------------------------------------

    /**
     * Checks if the specified element is allowed for tags and marks it for removal if not.
     * @param {HTMLElement} dom The element to check
     * @return {HTMLElement} The element or null if the element has been marked for removal
     */
    checkAllowedForPaste: function(dom) {
        var com = CUI.rte.Common;
        var markForRemoval = true;
        // tags that are always allowed
        var defaultAllowedTags = [ "br" ];
        // tags that are considered "basic tags"
        var basicTags = {
            "b": "bold", "i": "italic", "u": "underline", "a": "anchor",
            "img": "image", "sub": "subscript", "sup": "superscript"
        };
        var basicTagDef = null;
        if (this.pasteRules.allowBasics) {
            var tagNameLC = dom.tagName.toLowerCase();
            if (basicTags.hasOwnProperty(tagNameLC)) {
                basicTagDef = basicTags[tagNameLC];
            }
        }
        if (this.pasteRules.table) {
            if ((this.pasteRules.table.allow)
                    || (this.pasteRules.table.ignoreMode == "paragraph")) {
                defaultAllowedTags.push("table");
                defaultAllowedTags.push("tbody");
                defaultAllowedTags.push("tr");
                defaultAllowedTags.push("td");
                defaultAllowedTags.push("th");
            }
        }
        if (this.pasteRules.list) {
            if ((this.pasteRules.list.allow)
                    || (this.pasteRules.list.ignoreMode == "paragraph")) {
                defaultAllowedTags.push("ul");
                defaultAllowedTags.push("ol");
                defaultAllowedTags.push("li");
            }
        }
        if (basicTagDef != null) {
            markForRemoval = (this.pasteRules.allowBasics[basicTagDef] !== true);
        } else if (com.isTag(dom, defaultAllowedTags)) {
            markForRemoval = false;
        } else if (com.isTag(dom, com.BLOCK_TAGS)) {
            // block tags are handled differently
            markForRemoval = false;
        } else if (com.isTag(dom, "span") && (com.parseCSS(dom).length > 0)) { // exception for span if it has css classes assigned
            markForRemoval = false
        }
        if (markForRemoval) {
            this.elementsToRemove.push(dom);
            return null;
        }
        return dom;
    },

    /**
     * Applies table-specific paste-rules.
     * @param {HTMLElement} dom The table's DOM element
     * @return {HTMLElement} The DOM element to continue processing with
     */
    handleTablesOnPaste: function(dom) {
        var com = CUI.rte.Common;
        var tableRules = this.pasteRules.table;
        if (tableRules.allow) {
            return dom;
        }
        if (tableRules.ignoreMode == "remove") {
            // delete child nodes directly to avoid unnecessary processing, and mark
            // table itself for removal
            com.removeAllChildren(dom);
            this.markForRemoval(dom);
            return dom;
        }
        return this.flattenNestedStructure(dom, com.TABLE_CELLS, "table");
    },

    /**
     * Applies list-specific paste-rules.
     * @param {HTMLElement} dom The table's DOM element
     * @return {HTMLElement} The DOM element to continue processing with
     */
    handleListsOnPaste: function(dom) {
        var com = CUI.rte.Common;
        var listRules = this.pasteRules.list;
        if (listRules.allow) {
            return dom;
        }
        if (listRules.ignoreMode == "remove") {
            // delete child nodes directly to avoid unnecessary processing, and mark
            // list itself for removal
            com.removeAllChildren(dom);
            this.markForRemoval(dom);
            return dom;
        }
        return this.flattenNestedStructure(dom, "li", com.LIST_TAGS);
    },

    /**
     * Checks if the specified DOM element is a block tag and changes it according to the
     * paste rules if necessary.
     * @param {HTMLElement} dom The DOM element
     */
    handleBlockTagsOnPaste: function(dom) {
        var com = CUI.rte.Common;
        if (com.isTag(dom, com.BLOCK_TAGS)) {
            var tagNameLC = dom.tagName.toLowerCase();
            // tables and lists must be handled specifically if a rule is available
            if (com.isTag(dom, "table") && this.pasteRules.table) {
                return this.handleTablesOnPaste(dom);
            }
            if (com.isTag(dom, com.LIST_TAGS) && this.pasteRules.list) {
                return this.handleListsOnPaste(dom);
            }
            var mustChange = true;
            if (this.pasteRules.allowBlockTags) {
                mustChange = !com.arrayContains(this.pasteRules.allowBlockTags, tagNameLC);
            }
            if (mustChange) {
                var fallbackTag = this.pasteRules.fallbackBlockTag || "p";
                var changedDom = this.context.createElement(fallbackTag);
                this.elementsToChange.push({
                    "domToChange": dom,
                    "changedDom": changedDom
                });
            }
        }
    },

    /**
     * Handles "class" attributes of elements due to the paste rules defined.
     * @param {HTMLElement} dom The DOM element
     */
    handleCssClassesOnPaste: function(dom) {
        var com = CUI.rte.Common;
        var cssMode = (this.pasteRules.cssMode || "remove");
        var cssClasses = com.parseCSS(dom);
        if (cssClasses && (cssClasses.length > 0)) {
            switch (cssMode) {
                case "remove":
                    com.removeAttribute(dom, "class");
                    break;
                case "whitelist":
                    var allowedClasses = this.pasteRules.allowedCssNames || [ ];

                    // get allowed classes from plugin
                    if(this.editorKernel.registeredPlugins.styles) {
                        var style,
                            stylesFromPlugin = this.editorKernel.registeredPlugins.styles.getStyles() || [];

                        for (var i=0; i < stylesFromPlugin.length; i++) {
                            allowedClasses.push(stylesFromPlugin[i].cssName);
                        }
                    }

                    var classCnt = cssClasses.length;
                    for (var c = 0; c < classCnt; c++) {
                        var classToCheck = cssClasses[c];
                        if (!com.arrayContains(allowedClasses, classToCheck)) {
                            com.removeClass(dom, classToCheck);
                        }
                    }
                    break;
            }
        }
    },

    /**
     * Compiles a RegExp object from the specified parameter if it is a String.
     * @param {String|RegExp} regex The potential regular expression
     */
    manageRegEx: function(regex) {
        // do it in a separate method to avoid potential leak
        if (typeof(regex) == "string") {
            regex = eval(regex);
        }
        return regex;
    },

    /**
     * Executes several security checks on the specified DOM element according to the
     * defined paste rules.
     * @param {HTMLElement} dom The DOM element
     * @return {HTMLElement} The DOM element or null if the element has been marked for
     *         removal
     */
    handleSecurity: function(dom) {
        var com = CUI.rte.Common;
        // execute link verification
        if (com.isTag(dom, "a")) {
            var hrefAttrib = com.getAttribute(dom, "href", true);
            if (hrefAttrib && this.pasteRules.linkRemoveRegEx) {
                var regex = this.manageRegEx(this.pasteRules.linkRemoveRegEx);
                if (regex) {
                    if (hrefAttrib.search(regex) >= 0) {
                        this.markForRemoval(dom);
                        return null;
                    }
                }
            }
        }
        return dom;
    },

    /**
     * Removes attributes that are not allowed.
     * @param {HTMLElement} dom The DOM element
     */
    handleAttributes: function(dom) {
        var com = CUI.rte.Common;
        var attribs = com.getAttributeNames(dom);
        var globalAllowed = null;
        var tagAllowed = null;
        var tagNameLC = dom.tagName.toLowerCase();
        if (this.pasteRules.allowedAttributes) {
            globalAllowed = this.pasteRules.allowedAttributes["*"];
            tagAllowed = this.pasteRules.allowedAttributes[tagNameLC];
        }
        var attribCnt = attribs.length;
        for (var a = 0; a < attribCnt; a++) {
            var attribName = attribs[a];
            var isAllowed = false;
            if (globalAllowed && com.arrayContains(globalAllowed, attribName)) {
                isAllowed = true;
            }
            if (tagAllowed && com.arrayContains(tagAllowed, attribName)) {
                isAllowed = true;
            }
            if (!isAllowed) {
                com.removeAttribute(dom, attribName);
            }
        }
    },

    /**
     * <p>This method handles the preprocessing for pasted HTML content.</p>
     * <p>It may be called in any processing mode.</p>
     * @param {HTMLElement} dom The DOM element to be processed
     * @return {HTMLElement} The DOM element to continue processing with
     */
    handlePasteProcessing: function(dom) {
        var dcu = CUI.rte.DomCleanup;
        var originalDom = dom;
        if ((this.mode = dcu.PASTE_PREPARE) && (this.pasteRules != null)) {
            if (dom) {
                dom = this.handleSecurity(dom);
            }
            if (dom) {
                this.handleBlockTagsOnPaste(dom);
                this.handleCssClassesOnPaste(dom);
                this.handleAttributes(dom);
            }
            dom = this.checkAllowedForPaste(dom);
        }
        // continue with original DOM if element has been marked for removal
        return dom || originalDom;
    },


    // -- Processing -----------------------------------------------------------------------

    /**
     * Traverses the specified sub-tree recursively.
     * @param {HTMLElement} dom Root element of the sub-tree
     * @param {Boolean} isRoot True if we are at the root node of the entire traversal
     */
    traverse: function(dom, isRoot) {
        if (!isRoot) {
            if (dom.nodeType == 1) {
                if (!this.isValidElement(dom)) {
                    this.markForRemoval(dom);
                } else {
                    // paste processing works as a "pre-filter"
                    dom = this.handlePasteProcessing(dom);
                    var isRemoved = false;
                    if (this.htmlRules) {
                        isRemoved = this.applyHtmlRules(dom);
                    }
                    if (!isRemoved) {
                        this.handleSpecificTags(dom);
                    }
                }
            }
            this.handleEmptyLinesAtEOB(dom);
        }
        var children = dom.childNodes;
        for (var c = 0; c < children.length; c++) {
            this.traverse(children[c], false);
        }
    },

    /**
     * Removes elements that were marked for removal while traversing the DOM tree.
     */
    removeElements: function() {
        var dpr = CUI.rte.DomProcessor;
        var removeCnt = this.elementsToRemove.length;
        for (var r = 0; r < removeCnt; r++) {
            dpr.removeWithoutChildren(this.elementsToRemove[r]);
        }
        this.elementsToRemove.length = 0;
    },

    /**
     * Replaces elements that were marked accordingly while traversing the DOM tree.
     */
    replaceElements: function() {
        var com = CUI.rte.Common;
        var replaceCnt = this.elementsToChange.length;
        for (var r = 0; r < replaceCnt; r++) {
            var changeDef = this.elementsToChange[r];
            var toChange = changeDef.domToChange;
            com.replaceNode(toChange, changeDef.changedDom, changeDef.childDom);
            // if element was marked for removal, we'll have to remove it from that list
            // as we'd otherwise provoke an exception
            for (var rm = 0; rm < this.elementsToRemove.length; rm++) {
                if (this.elementsToRemove[rm] == toChange) {
                    this.elementsToRemove.splice(rm, 1);
                    break;
                }
            }
        }
    },

    /**
     * Inserts the elements that were marked accordingly while traversing the DOM tree.
     */
    insertElements: function() {
        var com = CUI.rte.Common;
        var insertCnt = this.elementsToInsert.length;
        for (var i = 0; i < insertCnt; i++) {
            var changeDef = this.elementsToInsert[i];
            var toInsert = changeDef.domToInsert;
            var parentDom = changeDef.parentDom;
            var siblingRef = changeDef.refDom;
            if (siblingRef) {
                parentDom.insertBefore(toInsert, siblingRef);
            } else {
                parentDom.appendChild(toInsert);
            }
        }
    },


    // -- "Interface"/Implementation -------------------------------------------------------

    /**
     * Executes the DOM cleanup (used by each of the processing methods).
     * @param {CUI.rte.EditorKernel} editorKernel The editor representation
     * @param {HTMLElement} rootDom The root element to begin cleanup with
     * @private
     */
    execute: function(editorKernel, rootDom) {
        // init
        this.editorKernel = editorKernel;
        this.context = editorKernel.getEditContext();
        this.htmlRules = editorKernel.getHtmlRules();
        if (this.elementsToRemove != null) {
            this.elementsToRemove.length = 0;
        } else {
            this.elementsToRemove = [ ];
        }
        if (this.elementsToChange != null) {
            this.elementsToChange.length = 0;
        } else {
            this.elementsToChange = [ ];
        }
        if (this.elementsToInsert != null) {
            this.elementsToInsert.length = 0;
        } else {
            this.elementsToInsert = [ ];
        }
        if (this.emptyBlocksIE != null) {
            this.emptyBlocksIE.length = 0;
        } else {
            this.emptyBlocksIE = [ ];
        }
        // actually execute
        this.traverse(rootDom, true);
        this.insertElements();
        this.replaceElements();
        this.removeElements();
        this.handleContainerRules(rootDom);
        this.handleEmptyContent(rootDom);
    },

    /**
     * Executes DOM-based preprocessing on the specified root node.
     * @param {CUI.rte.EditorKernel} editorKernel The editor representation
     * @param {HTMLElement} rootDom The root node
     */
    preprocess: function(editorKernel, rootDom) {
        this.processingMode = CUI.rte.DomCleanup.PRE;
        this.execute(editorKernel, rootDom);
    },

    /**
     * Executes DOM-based postprocessing on the specified root node.
     * @param {CUI.rte.EditorKernel} editorKernel The editor representation
     * @param {HTMLElement} rootDom The root node
     */
    postprocess: function(editorKernel, rootDom) {
        this.processingMode = CUI.rte.DomCleanup.POST;
        this.execute(editorKernel, rootDom);
    },

    /**
     * Executes DOM-based preprocessing of HTML content that was pasted from a potentially
     * unknown source.
     * @param {CUI.rte.EditorKernel} editorKernel The editor representation
     * @param {HTMLElement} rootDom The root node
     * @param {Object} pasteRules The rules to be applied for pasted content
     */
    prepareHtmlPaste: function(editorKernel, rootDom, pasteRules) {
        this.processingMode = CUI.rte.DomCleanup.PASTE_PREPARE;
        this.pasteRules = pasteRules;
        this.execute(editorKernel, rootDom);
    }

});


/**
 * Mode: Preprocessing (= persisted to editable state)
 */
CUI.rte.DomCleanup.PRE = 0;

/**
 * Mode: Postprocessing (= edited to a pesistable state)
 */
CUI.rte.DomCleanup.POST = 1;

/**
 * Mode: Preprocessing of HTML content pasted from anywhere
 */
CUI.rte.DomCleanup.PASTE_PREPARE = 2;
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.commands.Command
 * @private
 * The Command should be implemented by all RTE commands that cannot be handled by the
 * browser's implementation itself.
 */
CUI.rte.commands.Command = new Class({

    toString: "Command",

    isCommand: function(cmdStr) {
        // this method must be overridden
        return false;
    },

    isUndoable: function(cmdStr) {
        // this method can be overridden by commands that are actually not undoable (for
        // example undo/redo commands themselves)
        return true;
    },

    requiresInitializedComponent: function(cmdStr) {
        // this method can be overridden by commands that do not require an initialized
        // RTE component, for example for configuration, setup, etc.
        return true;
    },

    getProcessingOptions: function() {
        return CUI.rte.commands.Command.PO_NONE;
    },

    execute: function(execDef) {
        // this method must be overridden
    },

    // todo use a single parameter
    queryState: function(selectionDef, cmd) {
        return false;
    }

});

/**
 * @static
 * @final
 * @type Number
 * @private
 */
CUI.rte.commands.Command.PO_NONE = 0;

/**
 * @static
 * @final
 * @type Number
 * @private
 */
CUI.rte.commands.Command.PO_SELECTION = 1;

/**
 * @static
 * @final
 * @type Number
 * @private
 */
CUI.rte.commands.Command.PO_BOOKMARK = 2;

/**
 * @static
 * @final
 * @type Number
 * @private
 */
CUI.rte.commands.Command.PO_NODELIST = 4;

/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.commands.CommandRegistry
 * This class is used to manage commands used for rich text editing. Each command has a
 * respective identifier by which it can be executed
 * {@link CUI.rte.EditorKernel#execCmd}.
 * @since 5.3
 * @private
 */
CUI.rte.commands.CommandRegistry = function() {

    var cmdRegistry = { };

    return {

        /**
         * Registers the specified class as a rich text editing command.
         * @param {String} command The command identifier
         * @param {Function} cls The command class (must extend
         *        {@link CUI.rte.commands.Command})
         */
        register: function(command, cls) {
            cmdRegistry[command] = cls;
        },

        /**
         * <p>Creates an associative array, containing instances of all currently
         * registered commands.</p>
         * <p>The created object may be used by a single {@link CUI.rte.EditorKernel}
         * instance.</p>
         * @return {Object} Associative array of instantiated commands
         */
        createRegisteredCommands: function() {
            var registeredCommands = { };
            for (var cmd in cmdRegistry) {
                if (cmdRegistry.hasOwnProperty(cmd)) {
                    registeredCommands[cmd] = new cmdRegistry[cmd]();
                }
            }
            return registeredCommands;
        }

    };

}();
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.commands.Delete
 * @extends CUI.rte.commands.Command
 * @private
 */
CUI.rte.commands.Delete = new Class({

    toString: "Delete",

    extend: CUI.rte.commands.Command,

    isCommand: function(cmdStr) {
        var cmdLC = cmdStr.toLowerCase();
        return (cmdLC == "delete") || (cmdLC == "delete");
    },

    execute: function(execDef) {
        CUI.rte.commands.Delete.executeDelete(execDef.editContext);
    }

});

/**
 * <p>Immediately executes the delete command (without using the EditorKernel's selection
 * adjustments).</p>
 * <p>Use this to delete the current (already preprocessed) selection from another command
 * and ensure that the editor is kept in a usable state (at least an empty block will be
 * available afterwards).</p>
 * @param {CUI.rte.EditContext} editContext The edit context
 * @private
 */
CUI.rte.commands.Delete.executeDelete = function(editContext) {
    editContext.doc.execCommand("delete", false, null);
    CUI.rte.DomProcessor.ensureMinimumContent(editContext);
};

// register command
CUI.rte.commands.CommandRegistry.register("delete", CUI.rte.commands.Delete);
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.commands.SurroundBase
 * @extends CUI.rte.commands.Command
 * @private
 */
CUI.rte.commands.SurroundBase = new Class({

    toString: "SurroundBase",

    extend: CUI.rte.commands.Command,

    tagName: null,

    attributes: null,

    construct: function(tagName, attributes) {
        this.tagName = tagName;
        this.attributes = attributes;
    },

    /**
     * @private
     */
    containsTag: function(list, tagName) {
        var com = CUI.rte.Common;
        for (var key in list) {
            var dom = list[key];
            if (com.isTag(dom, tagName)) {
                return true;
            }
        }
        return false;
    },

    isCommand: function(cmdStr) {
        return (cmdStr.toLowerCase() == this.tagName.toLowerCase());
    },

    getProcessingOptions: function() {
        var cmd = CUI.rte.commands.Command;
        return cmd.PO_SELECTION | cmd.PO_BOOKMARK | cmd.PO_NODELIST;
    },

    execute: function(execDef) {
        var com = CUI.rte.Common;
        var nodeList = execDef.nodeList;
        var context = execDef.editContext;
        var isActive = com.containsTagInPath(context, nodeList.commonAncestor,
                this.tagName);
        if (!isActive) {
            nodeList.surround(execDef.editContext, this.tagName, this.attributes);
        } else {
            nodeList.removeNodesByTag(execDef.editContext, this.tagName, null, true);
        }
    },

    queryState: function(selectionDef, cmd) {
        var consistentFormatting = selectionDef.consistentFormatting;
        // todo check attributes
        return this.containsTag(consistentFormatting, this.tagName);
    }

});

/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.commands.DefaultFormatting
 * @extends CUI.rte.commands.Command
 * @private
 */
CUI.rte.commands.DefaultFormatting = new Class({

    toString: "DefaultFormatting",

    extend: CUI.rte.commands.Command,

    /**
     * @private
     */
    containsTag: function(list, tagName) {
        var com = CUI.rte.Common;
        for (var key in list) {
            var dom = list[key];
            if (com.isTag(dom, tagName)) {
                return true;
            }
        }
        return false;
    },

    /**
     * @private
     */
    getTagNameForCommand: function(cmd) {
        var cmdLC = cmd.toLowerCase();
        var tagName = null;
        switch (cmdLC) {
            case "bold":
                tagName = "b";
                break;
            case "italic":
                tagName = "i";
                break;
            case "underline":
                tagName = "u";
                break;
            case "subscript":
                tagName = "sub";
                break;
            case "superscript":
                tagName = "sup";
                break;
        }
        return tagName;
    },

    isCommand: function(cmdStr) {
        var cmdLC = cmdStr.toLowerCase();
        return (cmdLC == "bold") || (cmdLC == "italic") || (cmdLC == "underline")
                || (cmdLC == "subscript") || (cmdLC == "superscript");
    },

    getProcessingOptions: function() {
        var cmd = CUI.rte.commands.Command;
        return cmd.PO_SELECTION | cmd.PO_BOOKMARK | cmd.PO_NODELIST;
    },

    execute: function(execDef) {
        var com = CUI.rte.Common;
        var nodeList = execDef.nodeList;
        var selection = execDef.selection;
        var context = execDef.editContext;
        if (!CUI.rte.Selection.isSelection(selection)) {
            execDef.editContext.doc.execCommand(execDef.command, false, null);
            return;
        }
        var tagName = this.getTagNameForCommand(execDef.command);
        var attributes = execDef.value;
        // see queryState()
        var isActive = (com.getTagInPath(context, selection.startNode, tagName) != null);
        if (!isActive) {
            nodeList.surround(execDef.editContext, tagName, attributes);
        } else {
            nodeList.removeNodesByTag(execDef.editContext, tagName, attributes, true);
        }
    },

    queryState: function(selectionDef, cmd) {
        var com = CUI.rte.Common;
        if (!selectionDef.isSelection) {
            return selectionDef.editContext.doc.queryCommandState(cmd);
        }
        var context = selectionDef.editContext;
        var tagName = this.getTagNameForCommand(cmd);
        // use the start node to determine state - that's how the browsers would do it
        // if we could use queryCommandState
        var selection = selectionDef.selection;
        return (com.getTagInPath(context, selection.startNode, tagName) != null);
    }

});

// register command
CUI.rte.commands.CommandRegistry.register("defaultfmt",
        CUI.rte.commands.DefaultFormatting);
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.commands.Anchor
 * @extends CUI.rte.commands.Command
 * @private
 */
CUI.rte.commands.Anchor = new Class({

    toString: "Anchor",

    extend: CUI.rte.commands.Command,

    addAnchorToDom: function(execDef) {
        var com = CUI.rte.Common;
        var dpr = CUI.rte.DomProcessor;
        var nodeList = execDef.nodeList;
        var name = execDef.value;
        var context = execDef.editContext;
        var anchors = [ ];
        nodeList.getNamedAnchors(context, anchors, false);
        if (anchors.length > 0) {
            // modify existing anchor(s)
            for (var i = 0; i < anchors.length; i++) {
                this.applyAnchorProperties(anchors[i].dom, name);
            }
        } else {
            // create new anchor
            var tagName;
            var attributes =  {
                "class": CUI.rte.Theme.ANCHOR_CLASS
            };
            // Webkit can't edit "a" elements directly, hence substitute to "img" element
            if (com.ua.isWebKit) {
                tagName = "img";
                attributes[com.A_NAME_REPLACEMENT_ATTRIB] = name;
            } else {
                tagName = "a";
                attributes["name"] = name;
            }
            var selection = execDef.selection;
            var dom = dpr.createNode(execDef.editContext, tagName, attributes);
            com.insertNode(dom, selection.startNode, selection.startOffset);
        }
    },

    /**
     * Applies anchor properties (name) to the given anchor dom element.
     * @param {HTMLElement} dom DOM element the link properties will be applied
     * @param {String} name Name of the anchor
     * @private
     */
    applyAnchorProperties: function(dom, name) {
        var com = CUI.rte.Common;
        // some browsers may use a substitute, so we'll have to use a special attribute
        // instead
        if (!com.isTag(dom, "a")) {
            com.setAttribute(dom, com.A_NAME_REPLACEMENT_ATTRIB, name);
        } else {
            com.setAttribute(dom, "name", name);
        }
        com.setAttribute(dom, "class", CUI.rte.Theme.ANCHOR_CLASS);
    },

    removeAnchorFromDom: function(execDef) {
        var dpr = CUI.rte.DomProcessor;
        var context = execDef.editContext;
        var nodeList = execDef.nodeList;
        var anchors = [ ];
        nodeList.getNamedAnchors(context, anchors, true);
        for (var i = 0; i < anchors.length; i++) {
            dpr.removeWithoutChildren(anchors[i].dom);
        }
    },

    isCommand: function(cmdStr) {
        var cmdLC = cmdStr.toLowerCase();
        return (cmdLC == "anchor");
    },

    getProcessingOptions: function() {
        var cmd = CUI.rte.commands.Command;
        return cmd.PO_BOOKMARK | cmd.PO_SELECTION | cmd.PO_NODELIST;
    },

    execute: function(execDef) {
        if (execDef.value) {
            this.addAnchorToDom(execDef);
        } else {
            this.removeAnchorFromDom(execDef);
        }
    },

    queryState: function(selectionDef, cmd) {
        return (selectionDef.namedAnchorCount > 0);
    }

});

// register command
CUI.rte.commands.CommandRegistry.register("anchor", CUI.rte.commands.Anchor);
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.commands.CutCopy
 * @extends CUI.rte.commands.Command
 * @private
 */
CUI.rte.commands.CutCopy = new Class({

    toString: "CutCopy",

    extend: CUI.rte.commands.Command,

    isCommand: function(cmdStr) {
        var cmdLC = cmdStr.toLowerCase();
        return (cmdLC == "cut") || (cmdLC == "copy");
    },

    execute: function(execDef) {

        var command = execDef.command;
        var doc = execDef.editContext.doc;

        try {
            doc.execCommand(command, false, null);
        } catch (e) {
            throw new Error("Cannot " + command + ".");
        }
    }

});

// register command
CUI.rte.commands.CommandRegistry.register("cutcopy", CUI.rte.commands.CutCopy);
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.commands.Format
 * @extends CUI.rte.commands.Command
 * @private
 */
CUI.rte.commands.Format = new Class({

    toString: "Format",

    extend: CUI.rte.commands.Command,

    isCommand: function(cmdStr) {
        return (cmdStr.toLowerCase() == "format");
    },

    getProcessingOptions: function() {
        var cmd = CUI.rte.commands.Command;
        return cmd.PO_BOOKMARK | cmd.PO_SELECTION;
    },

    execute: function(execDef) {
        var dpr = CUI.rte.DomProcessor;
        var com = CUI.rte.Common;
        var dom;
        var selection = execDef.selection;
        var context = execDef.editContext;
        var containerList = dpr.createContainerList(context, selection);
        if (containerList.length == 0) {
            var nodeList = execDef.nodeList;
            if (!nodeList) {
                nodeList = dpr.createNodeList(context, selection);
            }
            var auxRoot = com.getTagInPath(context, nodeList.commonAncestor,
                    dpr.AUXILIARY_ROOT_TAGS);
            if (auxRoot) {
                dom = dpr.createNode(execDef.editContext, execDef.value.tag);
                com.moveChildren(auxRoot, dom);
                auxRoot.appendChild(dom);
            }
        } else {
            dom = dpr.createNode(execDef.editContext, execDef.value.tag);
            dpr.changeContainerTag(execDef.editContext, containerList, dom, true);
        }
    },

    queryState: function(selectionDef, cmd) {
        // todo find a meaningful implementation -> list of container tags?
        return false;
    }

});


// register command
CUI.rte.commands.CommandRegistry.register("format", CUI.rte.commands.Format);
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.commands.Indent
 * @extends CUI.rte.commands.Command
 * @private
 */
CUI.rte.commands.Indent = new Class({

    toString: "Indent",

    extend: CUI.rte.commands.Command,

    isCommand: function(cmdStr) {
        return (cmdStr.toLowerCase() == "indent");
    },

    getProcessingOptions: function() {
        var cmd = CUI.rte.commands.Command;
        return cmd.PO_SELECTION | cmd.PO_BOOKMARK | cmd.PO_NODELIST;
    },

    execute: function(execDef) {
        var retValue = {
            "selOffset": {
                collapse: true
            }
        };
        var com = CUI.rte.Common;
        var dpr = CUI.rte.DomProcessor;
        var selection = execDef.selection;
        var nodeList = execDef.nodeList;
        var context = execDef.editContext;
        var tagExcl = CUI.rte.commands.Indent.TAGEXCL;
        var indents = nodeList.getTags(context, [ {
            "matcher": function(dom) {
                if (com.isTag(dom, com.BLOCK_TAGS) && !com.isTag(dom, tagExcl)) {
                    return true;
                }
                return com.isTag(dom, "li");
            }
        } ], true, true);
        // change auxiliary roots and add them to the indents list
        var auxRoots = dpr.getAuxRoots(context, selection);
        var rootCnt = auxRoots.length;
        for (var r = 0; r < rootCnt; r++) {
            var rootToProcess = auxRoots[r];
            var pNode = context.createElement("p");
            com.moveChildren(rootToProcess, pNode);
            rootToProcess.appendChild(pNode);
            indents.push({
                "dom": pNode
            });
        }
        // change indents of all detected block nodes
        var nodeCnt = indents.length;
        for (var nodeIndex = 0; nodeIndex < nodeCnt; nodeIndex++) {
            var nodeToProcess = indents[nodeIndex];
            var dom = nodeToProcess.dom;
            if (com.isTag(dom, com.BLOCK_TAGS)) {
                // block nodes
                var marginLeft = 0;
                if (dom.style.marginLeft) {
                    marginLeft = parseInt(dom.style.marginLeft);
                }
                marginLeft += execDef.value
                        || CUI.rte.commands.Indent.DEFAULT_INDENT_SIZE;
                dom.style.marginLeft = marginLeft + "px";
            } else {
                // list items
                var listProcessor = new CUI.rte.ListRepresentation();
                listProcessor.fromItem(context, dom);
                listProcessor.ensureHierarchy(context);
                listProcessor.indent(context, dom);
            }
        }
        return retValue;
    },

    queryState: function(selectionDef, cmd) {
        var com = CUI.rte.Common;
        var context = selectionDef.editContext;
        var tagExcl = CUI.rte.commands.Indent.TAGEXCL;
        var indents = selectionDef.nodeList.getTags(context, [ {
                "matcher": function(dom) {
                    if (com.isTag(dom, com.BLOCK_TAGS) && !com.isTag(dom, tagExcl)) {
                        return !!dom.style.marginLeft;
                    }
                    return com.isTag(dom, "li");
                }
            }
        ], true, true);
        return (indents.length > 0);
    }

});

/**
 * Block-tags that are excluded from being indented/outdented
 * @static
 * @final
 * @type String[]
 * @private
 */
CUI.rte.commands.Indent.TAGEXCL = [ "ul", "ol", "table" ];

/**
 * Default indent size
 * @static
 * @final
 * @type Number
 * @private
 */
CUI.rte.commands.Indent.DEFAULT_INDENT_SIZE = 40;


// register command
CUI.rte.commands.CommandRegistry.register("indent", CUI.rte.commands.Indent);
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.commands.InsertHtml
 * @extends CUI.rte.commands.Command
 * @private
 */
CUI.rte.commands.InsertHtml = new Class({

    toString: "InsertHtml",

    extend: CUI.rte.commands.Command,

    isCommand: function(cmdStr) {
        return (cmdStr.toLowerCase() == "inserthtml");
    },

    getProcessingOptions: function() {
        var cmd = CUI.rte.commands.Command;
        return cmd.PO_SELECTION;
    },

    execute: function(execDef) {
        var com = CUI.rte.Common;
        var htmlToInsert = execDef.value;
        if (htmlToInsert && (htmlToInsert.length > 0)) {
            if (com.ua.isIE) {
                // even IE with W3C compliant selection model don't support the
                // "inserthtml" command, so use the old selection model + pasteHTML
                // to insert the HTML
                try {
                    var range = execDef.editContext.doc.selection.createRange();
                    range.pasteHTML(htmlToInsert);
                } catch (e) {
                    throw new Error("Could not insert html due to IE limitations.");
                }
            } else {
                execDef.editContext.doc.execCommand("inserthtml", false, htmlToInsert);
            }
        }
    },

    queryState: function(selectionDef, cmd) {
        return false;
    }

});


// register command
CUI.rte.commands.CommandRegistry.register("inserthtml",
        CUI.rte.commands.InsertHtml);
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.commands.Justify
 * @extends CUI.rte.commands.Command
 * @private
 */
CUI.rte.commands.Justify = new Class({

    toString: "Justify",

    extend: CUI.rte.commands.Command,

    isCommand: function(cmdStr) {
        var com = CUI.rte.Common;
        return com.strStartsWith(cmdStr.toLowerCase(), "justify");
    },

    getProcessingOptions: function() {
        var cmd = CUI.rte.commands.Command;
        return cmd.PO_SELECTION | cmd.PO_BOOKMARK;
    },

    alignTableCells: function(context, cellSelection, alignment) {
        var com = CUI.rte.Common;
        var cells = cellSelection.cells;
        var cellCnt = cells.length;
        for (var c = 0; c < cellCnt; c++) {
            var cellToAlign = cells[c];
            var baseStyle = com.getStyleProp(context, cellToAlign.parentNode, "textAlign");
            baseStyle = (baseStyle ? baseStyle : "left");
            if (baseStyle != alignment) {
                cellToAlign.style.textAlign = alignment;
            } else {
                cellToAlign.style.textAlign = "";
            }
        }
    },

    execute: function(execDef) {
        var dpr = CUI.rte.DomProcessor;
        var com = CUI.rte.Common;
        var selection = execDef.selection;
        var cmd = execDef.command;
        var context = execDef.editContext;
        var textAlign = cmd.substring(7, cmd.length);
        if (selection.cellSelection) {
            this.alignTableCells(context, selection.cellSelection, textAlign);
        } else {
            var baseStyle;
            var containers = dpr.createContainerList(context, selection);
            var selectionTextAlign = com.getConsistentStyle(context, containers,
                    "textAlign", "left");
            var toggleStyle = (selectionTextAlign != null);
            var containerCnt = containers.length;
            for (var containerIndex = 0; containerIndex < containerCnt; containerIndex++) {
                var containerToChange = containers[containerIndex];
                baseStyle = com.getStyleProp(context, containerToChange.parentNode,
                        "textAlign");
                baseStyle = (baseStyle ? baseStyle : "left");
                var isPlainStyle = (baseStyle == textAlign);
                if (toggleStyle) {
                    if (isPlainStyle) {
                        containerToChange.style.textAlign = "";
                    } else {
                        containerToChange.style.textAlign = textAlign;
                    }
                } else {
                    containerToChange.style.textAlign = (isPlainStyle ? "" : textAlign);
                }
            }
            var auxRoots = dpr.getAuxRoots(context, selection);
            var rootCnt = auxRoots.length;
            for (var r = 0; r < rootCnt; r++) {
                var auxRootDom = auxRoots[r];
                if (com.isTag(auxRootDom, [ "td", "th" ])) {
                    baseStyle = com.getStyleProp(context, auxRootDom.parentNode,
                            "textAlign");
                    baseStyle = (baseStyle ? baseStyle : "left");
                    if (textAlign != baseStyle) {
                        auxRootDom.style.textAlign = textAlign;
                    } else {
                        auxRootDom.style.textAlign = "";
                    }
                }
            }
        }
    },

    queryState: function(selectionDef, cmd) {
        var com = CUI.rte.Common;
        var context = selectionDef.editContext;
        var containerList = com.arrayCopy(selectionDef.containerList);
        var auxRoots = selectionDef.auxRoots;
        var rootCnt = auxRoots.length;
        for (var r = 0; r < rootCnt; r++) {
            var root = auxRoots[r];
            if (com.isTag(root, [ "td", "th" ])) {
                containerList.push(root);
            }
        }
        var align = cmd.substring(7, cmd.length);
        var selTextAlign = com.getConsistentStyle(context, containerList, "textAlign",
                "left");
        return (align == selTextAlign);
    }

});


// register command
CUI.rte.commands.CommandRegistry.register("justify", CUI.rte.commands.Justify);
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.commands.Link
 * @extends CUI.rte.commands.Command
 * @private
 */
CUI.rte.commands.Link = new Class({

    toString: "Link",

    extend: CUI.rte.commands.Command,

    /**
     * Creates a styled link from the current selection.
     * @private
     */
    addLinkToDom: function(execDef) {
        var context = execDef.editContext;
        var nodeList = execDef.nodeList;
        var url = execDef.value.url;
        var styleName = execDef.value.css;
        var target = execDef.value.target;
        var attributes = execDef.value.attributes || { };
        var links = [ ];
        nodeList.getAnchors(context, links, true);
        if (links.length > 0) {
            // modify existing link(s)
            for (var i = 0; i < links.length; i++) {
                this.applyLinkProperties(links[i].dom, url, styleName, target, attributes);
            }
        } else {
            // create new link
            var sel = CUI.rte.Selection;
            var dpr = CUI.rte.DomProcessor;
            if (execDef.value.trimLinkSelection === true) {
                var range = sel.getLeadRange(context);
                range = sel.trimRangeWhitespace(context, range);
                sel.selectRange(context, range);
                nodeList = dpr.createNodeList(context, sel.createProcessingSelection(
                        context));
            }
            // handle HREF problems on IE with undo (IE will deliberately change the
            // HREF, causing the undo mechanism to fail):
            var helperSpan = context.createElement("span");
            helperSpan.innerHTML = "<a href=\"" + url + "\"></a>";
            attributes.href = helperSpan.childNodes[0].href;
            attributes[CUI.rte.Common.HREF_ATTRIB] = url;
            if (styleName) {
                attributes.className = styleName;
            }
            if (target) {
                attributes.target = target;
            } else {
                delete attributes.target;
            }
            for (var key in attributes) {
                if (attributes.hasOwnProperty(key)) {
                    var attribValue = attributes[key];
                    if ((attribValue == null) || (attribValue.length == 0)
                            || (attribValue == CUI.rte.commands.Link.REMOVE_ATTRIBUTE)) {
                        delete attributes[key];
                    }
                }
            }
            nodeList.surround(context, "a", attributes);
        }
    },

    /**
     * Applies link properties (href, style, target) to the given anchor dom element.
     * @param {HTMLElement} dom DOM element the link properties will be applied (should be
     * @param {String} url URL/href to set
     * @param {String} styleName Name of CSS class to apply
     * @param {String} target target frame of the link
     * @param {Object} addAttributes additional attributes
     * @private
     */
    applyLinkProperties: function(dom, url, styleName, target, addAttributes) {
        var com = CUI.rte.Common;
        dom.href = url;
        dom.setAttribute(CUI.rte.Common.HREF_ATTRIB, url);
        if (target) {
            com.setAttribute(dom, "target", target);
        } else {
            com.removeAttribute(dom, "target");
        }
        if (styleName) {
            com.setAttribute(dom, "class", styleName);
        } else {
            com.removeAttribute(dom, "class");
        }
        for (var attribName in addAttributes) {
            if (addAttributes.hasOwnProperty(attribName)) {
                var attribValue = addAttributes[attribName];
                if (attribValue && (attribValue.length > 0)
                        && (attribValue != CUI.rte.commands.Link.REMOVE_ATTRIBUTE)) {
                    com.setAttribute(dom, attribName, attribValue);
                } else {
                    com.removeAttribute(dom, attribName);
                }
            }
        }
    },

    /**
     * Removes a styled link according to the current selection.
     * @private
     */
    removeLinkFromDom: function(execDef) {
        var dpr = CUI.rte.DomProcessor;
        var context = execDef.editContext;
        var nodeList = execDef.nodeList;
        var links = [ ];
        nodeList.getAnchors(context, links, true);
        for (var i = 0; i < links.length; i++) {
            dpr.removeWithoutChildren(links[i].dom);
        }
    },

    isCommand: function(cmdStr) {
        var cmdLC = cmdStr.toLowerCase();
        return (cmdLC == "modifylink") || (cmdLC == "unlink");
    },

    getProcessingOptions: function() {
        var cmd = CUI.rte.commands.Command;
        return cmd.PO_BOOKMARK | cmd.PO_SELECTION | cmd.PO_NODELIST;
    },

    execute: function(execDef) {
        switch (execDef.command.toLowerCase()) {
            case "modifylink":
                this.addLinkToDom(execDef);
                break;
            case "unlink":
                this.removeLinkFromDom(execDef);
                break;
        }
    },

    queryState: function(selectionDef, cmd) {
        return (selectionDef.anchorCount > 0);
    }

});

/**
 * Placeholder object for explicitly removing an attribute
 */
CUI.rte.commands.Link.REMOVE_ATTRIBUTE = new Object();


// register command
CUI.rte.commands.CommandRegistry.register("link", CUI.rte.commands.Link);
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.commands.List
 * @extends CUI.rte.commands.Command
 * @private
 */
CUI.rte.commands.List = new Class({

    toString: "List",

    extend: CUI.rte.commands.Command,

    isCommand: function(cmdStr) {
        var cmdStrLC = cmdStr.toLowerCase();
        return (cmdStrLC == "insertorderedlist") || (cmdStrLC == "insertunorderedlist");
    },

    getProcessingOptions: function() {
        var cmd = CUI.rte.commands.Command;
        return cmd.PO_SELECTION | cmd.PO_BOOKMARK | cmd.PO_NODELIST;
    },

    /**
     * Gets all list items of the current selection. Using this method will not include
     * items of a nested list if a nested list is completely covered in the selection.
     * @private
     */
    getListItems: function(execDef) {
        var context = execDef.editContext;
        return execDef.nodeList.getTags(context, [ {
                "extMatcher": function(dom) {
                    return {
                        "isMatching": CUI.rte.Common.isTag(dom, "li"),
                        "preventRecursionIfMatching": true
                    };
                }
            }
        ], true, true);
    },

    /**
     * Gets all list items of the current selection. Using this method will include
     * items of a nested list as well.
     * @private
     */
    getAllListItems: function(execDef) {
        var context = execDef.editContext;
        var allItems = execDef.nodeList.getTags(context, [ {
                "matcher": function(dom) {
                    return CUI.rte.Common.isTag(dom, "li");
                }
            }
        ], true, true);
        CUI.rte.ListUtils.postprocessSelectedItems(allItems);
        return allItems;
    },

    /**
     * Gets the defining list element for the specified node list. The defining list element
     * is the list element that belongs to the first node contained in the list.
     * @param {CUI.rte.EditContext} context The edit context
     * @param {CUI.rte.NodeList} nodeList The node list
     * @return {HTMLElement} The defining list DOM; null if the first node of the list
     *         is not part of a list
     */
    getDefiningListDom: function(context, nodeList) {
        var com = CUI.rte.Common;
        var determNode = nodeList.getFirstNode();
        if (determNode == null) {
            return null;
        }
        var determDom = determNode.dom;
        while (determDom) {
            if (com.isTag(determDom, com.LIST_TAGS)) {
                return determDom;
            }
            determDom = com.getParentNode(context, determDom);
        }
        return null;
    },

    /**
     * Splits the specified array of list items into separate arrays of items for each
     * top-level list.
     * @private
     */
    splitToTopLevelLists: function(execDef, listItems) {
        var context = execDef.editContext;
        var itemsPerList = [ ];
        var topLevelLists = [ ];
        var itemCnt = listItems.length;
        for (var i = 0; i < itemCnt; i++) {
            var itemToCheck = listItems[i];
            var listDom = CUI.rte.ListUtils.getTopListForItem(context, itemToCheck.dom);
            var listIndex = CUI.rte.Common.arrayIndex(topLevelLists, listDom);
            if (listIndex < 0) {
                topLevelLists.push(listDom);
                itemsPerList.push([ itemToCheck ]);
            } else {
                itemsPerList[listIndex].push(itemToCheck);
            }
        }
        return itemsPerList;
    },

    /**
     * Changes the list type of all selected list items, inserting additional tables
     * as required.
     * @private
     */
    changeItemsListType: function(execDef, listItems, listType) {
        var com = CUI.rte.Common;
        var context = execDef.editContext;
        var itemCnt = listItems.length;
        for (var i = 0; i < itemCnt; i++) {
            var item = listItems[i].dom;
            var list = item.parentNode;
            if (!com.isTag(list, listType)) {
                // Change item ...
                var prevSib = list.previousSibling;
                var nextSib = list.nextSibling;
                var isFirst = (com.getChildIndex(item) == 0);
                var isLast = (com.getChildIndex(item) == (list.childNodes.length - 1));
                if (isFirst && prevSib && com.isTag(prevSib, listType)) {
                    // move to preceding list of correct type
                    list.removeChild(item);
                    prevSib.appendChild(item);
                    if (list.childNodes.length == 0) {
                        list.parentNode.removeChild(list);
                    }
                } else if (isLast && nextSib && com.isTag(nextSib, listType)) {
                    // move to succeeding list of correct type
                    list.removeChild(item);
                    com.insertBefore(nextSib, item, nextSib.firstChild);
                    if (list.childNodes.length == 0) {
                        list.parentNode.removeChild(list);
                    }
                } else {
                    // we need a new list
                    var newList = context.createElement(listType);
                    if (item == list.firstChild) {
                        // create new list before existing list
                        com.insertBefore(list.parentNode, newList, list);
                    } else if (item == list.lastChild) {
                        // create new list after existing list
                        com.insertBefore(list.parentNode, newList, list.nextSibling);
                    } else {
                        // split list
                        var splitList = list.cloneNode(false);
                        com.insertBefore(list.parentNode, splitList, list);
                        com.insertBefore(list.parentNode, newList, list);
                        while (list.childNodes[0] != item) {
                            var domToMove = list.childNodes[0];
                            list.removeChild(domToMove);
                            splitList.appendChild(domToMove);
                        }
                    }
                    list.removeChild(item);
                    newList.appendChild(item);
                    if (list.childNodes.length == 0) {
                        list.parentNode.removeChild(list);
                    }
                }
            }
        }
    },

    /**
     * Creates a new list from all (allowed) block nodes defined in the selection.
     * @private
     */
    createListFromSelection: function(execDef, listType) {
        var nodeList = execDef.nodeList;
        var context = execDef.editContext;
        // todo distinguish between entire cell and parts of a cell
        var blockLists = nodeList.getEditBlocksByAuxRoots(context, true);
        var listCnt = blockLists.length;
        for (var l = 0; l < listCnt; l++) {
            CUI.rte.ListUtils.createList(context, blockLists[l], listType);
        }
    },

    /**
     * Removes items from a list by appending them to their respective parent item
     * (including a separating "br" line break).
     * @private
     */
    unlistItems: function(execDef, listItems, keepStructure) {
        if (!listItems) {
            listItems = this.getAllListItems(execDef);
        }
        var context = execDef.editContext;
        var itemCnt = listItems.length;
        var itemsDom = [ ];
        for (var i = 0; i < itemCnt; i++) {
            itemsDom.push(listItems[i].dom);
        }
        CUI.rte.ListUtils.unlistItems(context, itemsDom, keepStructure);
    },


    execute: function(execDef) {
        var com = CUI.rte.Common;
        var context = execDef.editContext;
        var nodeList = execDef.nodeList;
        var command = execDef.command;
        var value = execDef.value;
        var listType = null;
        switch (command.toLowerCase()) {
            case "insertorderedlist":
                listType = "ol";
                break;
            case "insertunorderedlist":
                listType = "ul";
                break;
        }
        if (listType) {
            var listItems;
            var refList = this.getDefiningListDom(context, nodeList);
            if (refList == null) {
                // creating new list (and joining existing lists)
                this.createListFromSelection(execDef, listType);
            } else if (!com.isTag(refList, listType)) {
                // change list type of selected items (or entire list)
                listItems = this.getListItems(execDef);
                this.changeItemsListType(execDef, listItems, listType);
            } else {
                // unlist all items of lead list
                listItems = this.getAllListItems(execDef);
                if (listItems.length > 0) {
                    var itemsByList = this.splitToTopLevelLists(execDef, listItems);
                    var listCnt = itemsByList.length;
                    for (var l = 0; l < listCnt; l++) {
                        listItems = itemsByList[l];
                        this.unlistItems(execDef, listItems, value === true);
                    }
                }
            }
        }
    },

    queryState: function(selectionDef, cmd) {
        var com = CUI.rte.Common;
        var context = selectionDef.editContext;
        var nodeList = selectionDef.nodeList;
        var tagName;
        switch (cmd.toLowerCase()) {
            case "insertorderedlist":
                tagName = "ol";
                break;
            case "insertunorderedlist":
                tagName = "ul";
                break;
        }
        var definingList = this.getDefiningListDom(context, nodeList);
        return ((definingList != null) && com.isTag(definingList, tagName));
    }

});

/**
 * Placeholder for "no list functionality available"
 */
CUI.rte.commands.List.NO_LIST_AVAILABLE = new Object();


// register command
CUI.rte.commands.CommandRegistry.register("list", CUI.rte.commands.List);
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.commands.Outdent
 * @extends CUI.rte.commands.Command
 * @private
 */
CUI.rte.commands.Outdent = new Class({

    toString: "Outdent",

    extend: CUI.rte.commands.Command,

    isCommand: function(cmdStr) {
        return (cmdStr.toLowerCase() == "outdent");
    },

    getProcessingOptions: function() {
        var cmd = CUI.rte.commands.Command;
        return cmd.PO_SELECTION | cmd.PO_BOOKMARK | cmd.PO_NODELIST;
    },

    execute: function(execDef) {
        var retValue = {
            "selOffset": {
                "start": 0,
                "collapse": true
            }
        };
        var com = CUI.rte.Common;
        var nodeList = execDef.nodeList;
        var context = execDef.editContext;
        var tagExcl = CUI.rte.commands.Indent.TAGEXCL;
        var indents = nodeList.getTags(context, [ {
                "matcher": function(dom) {
                    if (com.isTag(dom, com.BLOCK_TAGS) && !com.isTag(dom, tagExcl)) {
                        return !!dom.style.marginLeft;
                    }
                    return com.isTag(dom, "li");
                }
            }
        ], true, true);
        // check each item if it is actually contained in the selection (may be not the
        // case for nested lists in several situations)
        CUI.rte.ListUtils.postprocessSelectedItems(indents);
        // finally, execute the outdenting
        var nodeCnt = indents.length;
        var lists = [ ];
        var listItemsToOutdent = [ ];
        for (var nodeIndex = 0; nodeIndex < nodeCnt; nodeIndex++) {
            var nodeToProcess = indents[nodeIndex];
            var dom = nodeToProcess.dom;
            if (com.isTag(dom, com.BLOCK_TAGS)) {
                // handle block nodes ourselves
                var marginLeft = 0;
                if (dom.style.marginLeft) {
                    marginLeft = parseInt(dom.style.marginLeft);
                    marginLeft -= execDef.value
                        || CUI.rte.commands.Indent.DEFAULT_INDENT_SIZE;
                    if (marginLeft <= 0) {
                        dom.style.marginLeft = null;
                    } else {
                        dom.style.marginLeft = marginLeft + "px";
                    }
                }
            } else {
                // list items
                var listDom = CUI.rte.ListUtils.getTopListForItem(context, dom);
                var listIndex = com.arrayIndex(lists, listDom);
                if (listIndex < 0) {
                    lists.push(listDom);
                    listItemsToOutdent.push([ dom ]);
                } else {
                    listItemsToOutdent[listIndex].push(dom);
                }
            }
        }
        for (var l = 0; l < lists.length; l++) {
            // outdent list items (per top level list)
            var listProcessor = new CUI.rte.ListRepresentation();
            listProcessor.fromList(lists[l]);
            listProcessor.ensureHierarchy(context);
            listProcessor.outdent(context, listItemsToOutdent[l]);
        }
        return retValue;
    }

});


// register command
CUI.rte.commands.CommandRegistry.register("outdent", CUI.rte.commands.Outdent);
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.commands.Paste
 * @extends CUI.rte.commands.Command
 * @private
 */
CUI.rte.commands.Paste = new Class({

    toString: "Paste",

    extend: CUI.rte.commands.Command,

    /**
     * Pre-processing module (DOM-based)
     * @private
     * @type CUI.rte.DomCleanup
     */
    domPreProcessor: null,

    construct: function() {
        this.domPreProcessor = new CUI.rte.DomCleanup({
            "tagsToRemove": [ "font" ]
        });
    },

    pasteAsPlainText: function(execDef) {

        var hpr = CUI.rte.HtmlProcessor;
        var dpr = CUI.rte.DomProcessor;
        var sel = CUI.rte.Selection;
        var com = CUI.rte.Common;

        var html = execDef.value.html;
        var text = execDef.value.text;
        var context = execDef.editContext;

        // preprocess plain text if necessary
        var plainText;
        if (text) {
            plainText = text;
        } else {
            plainText = (new hpr.StripTags()).strip(html);
            plainText = hpr.stripSurroundingWhitespace(plainText, true);
            if (execDef.value.stripHtmlTags) {
                plainText = CUI.rte.Utils.htmlDecode(plainText);
                plainText = CUI.rte.Utils.stripTags(plainText);
            }
        }

        // insert paragraph by paragraph (indicated by two linefeeds); different mode if
        // paste is executed inside a list
        var pSel = sel.createProcessingSelection(context);
        var insertNode = pSel.startNode;
        var insertOffset = pSel.startOffset;
        var isListPaste = com.containsTagInPath(context, insertNode, "li");
        // normalize linefeeds beforehand
        plainText = plainText.replace(/\r\n/g, "\n");
        plainText = plainText.replace(/\r/g, "\n");
        // use String for split, as IE will remove empty items/lines if a RegExp is used ...
        var splitRegEx = (isListPaste ? "\n" : "\n\n");
        var paras = plainText.split(splitRegEx);
        var paraCnt = paras.length;
        // Gecko-Bug: when everything is selected and something is pasted, it deletes
        // everything and we will have to ensure that we have an empty paragraph we can
        // paste to
        if (com.isRootNode(context, insertNode)) {
            insertNode = dpr.ensureMinimumContent(context);
            insertOffset = null;
        }
        for (var paraIndex = 0; paraIndex < paraCnt; paraIndex++) {
            if (paraIndex > 0) {
                // insertParagraph and insertText have different interpretations for
                // insertOffset == null -> insertParagraph interprets it as "behind
                // last child node", whereas insertText interprets it as "before first
                // child node"; insertOffset can only be null if an empty line gets
                // pasted (and inserttext gets never called), as insertText will never
                // return null as a new insertOffset
                if (insertOffset == null) {
                    var firstTextChild = com.getFirstTextChild(insertNode, true);
                    if (firstTextChild && !com.isOneCharacterNode(firstTextChild)) {
                        insertNode = firstTextChild;
                    }
                    insertOffset = 0;
                }
                insertNode = dpr.insertParagraph(context, insertNode, insertOffset);
                insertOffset = null;
            }
            var lines = paras[paraIndex].split("\n");
            var lineCnt = lines.length;
            for (var lineIndex = 0; lineIndex < lineCnt; lineIndex++) {
                var line = lines[lineIndex];
                if (lineIndex > 0) {
                    var brNode = context.createElement("br");
                    // begin of node
                    if (insertOffset == 0) {
                        if (!isListPaste) {
                            insertNode.parentNode.insertBefore(brNode, insertNode);
                        }
                    // end of node
                    } else if (insertOffset >= com.getNodeCharacterCnt(insertNode)) {
                        if (!isListPaste) {
                            insertNode.parentNode.insertBefore(brNode,
                                    insertNode.nextSibling);
                            insertNode = brNode.parentNode;
                            insertOffset = com.getChildIndex(brNode) + 1;
                        }
                    // middle of node
                    } else {
                        insertNode = dpr.splitTextNode(context, insertNode,
                                insertOffset)[1];
                        if (!isListPaste) {
                            insertNode.parentNode.insertBefore(brNode, insertNode);
                        }
                        insertOffset = 0;
                    }
                }
                if (line != "") {
                    var def = dpr.insertText(context, insertNode, insertOffset, line);
                    insertNode = def.node;
                    insertOffset = def.offset;
                }
            }
        }
        return {
            "startNode": insertNode,
            "startOffset": insertOffset
        };
    },

    /**
     * Cleans up DOM by adjusting the DOM structure (remove unnecessary whitespace,
     * correcting list nesting, removing invalid tags, etc.).
     * @param {CUI.rte.EditContext} context The edit context
     * @param {CUI.rte.EditorKernel} editorKernel The editor kernel
     * @param {HTMLElement} dom Root node to clean up
     * @param {Object} pasteRules The paste rules, as configured through the plugin
     * @private
     */
    cleanUpDom: function(context, editorKernel, dom, pasteRules) {
        var com = CUI.rte.Common;
        var pasteRemovalRules = [ {
                // extended additional cleanup for paste
                "fn": function(dom) {
                    // only handle structural nodes
                    if (dom.nodeType != 1) {
                        return false;
                    }
                    // remove images that point to a file:// location
                    if (com.isTag(dom, "img")) {
                        var src = dom["src"];
                        // if a RTE-specific SRC attribute is available, use it for more
                        // accuracy
                        if (dom[com.SRC_ATTRIB]) {
                            src = dom[com.SRC_ATTRIB];
                        }
                        // don't accept images that have a file:// protocol
                        if (!src || com.strStartsWith(src, "file://")) {
                            return true;
                        }
                    }
                    return false;
                },
                "keepChildren": false
            }, {
                // additional tags to remove
                "tagName": [ /* "span" */ "font" ],
                "keepChildren": true
            }
        ];
        CUI.rte.WhitespaceProcessor.process(context, dom, pasteRemovalRules, false);
        this.domPreProcessor.prepareHtmlPaste(editorKernel, dom, pasteRules);
    },

    /**
     * Pastes table content to an existing table, correctly extending it.
     * @param {Object} execDef Execution definition
     * @private
     */
    pasteTableToTable: function(execDef) {
        var com = CUI.rte.Common;
        var context = execDef.editContext;
        var html;
        var pastedDom = execDef.value.dom;
        var pastedTable = com.getTags(pastedDom, "table");
        if (pastedTable.length != 1) {
            this.insertHtml(execDef);
            return;
        }
        var undoHtml = context.root.innerHTML;
        var selection = execDef.selection;
        var nodeList = execDef.nodeList;
        var destTable = com.getTagInPath(context, nodeList.commonAncestor, "table");
        var pasteMatrix = new CUI.rte.TableMatrix();
        pasteMatrix.createTableMatrix(pastedTable[0]);
        pasteMatrix.createFullMatrix();
        var destMatrix = new CUI.rte.TableMatrix();
        destMatrix.createTableMatrix(destTable);
        var selectedCell = null;
        var cells = null;
        var r, c, cellToInsert, insertBefore, insertBeforeDom, pNode;
        if (selection.cellSelection) {
            cells = selection.cellSelection.cells;
            if (cells && (cells.length == 1)) {
                selectedCell = cells[0];
            }
        } else {
            // On IE, there might be a single "td" selected if the caret is placed in an
            // empty cell. This must be handled/considered beforehand.
            if (nodeList.nodes && (nodeList.nodes.length == 1)) {
                var firstNode = nodeList.nodes[0].dom;
                if (com.isTag(firstNode, com.TABLE_CELLS)
                        && (firstNode.childNodes.length == 0)) {
                    selectedCell = firstNode;
                }
            }
            if (selectedCell == null) {
                selectedCell = com.getTagInPath(context, nodeList.commonAncestor,
                        com.TABLE_CELLS);
            }
        }
        if (selectedCell) {
            // Mode 1: if only one cell is selected, the existing table is being extended
            // to fit the pasted table.
            var selectedCellDef = destMatrix.getCellDef(selectedCell);
            var pasteSize = pasteMatrix.getTableSize();
            var destSize = destMatrix.getTableSize();
            var destCol = selectedCellDef.col;
            var destRow = selectedCellDef.row;
            var extendCols = (destCol + pasteSize.cols) - destSize.cols;
            var extendRows = (destRow + pasteSize.rows) - destSize.rows;
            extendCols = (extendCols >= 0 ? extendCols : 0);
            extendRows = (extendRows >= 0 ? extendRows : 0);
            destMatrix.extendBy(context, extendCols, extendRows);
            var insertCellDom = null;
            try {
                insertCellDom = destMatrix.mergeToSingleCell(context, destCol, destRow,
                        pasteSize.cols, pasteSize.rows);
            } catch (e) {
                context.root.innerHTML = undoHtml;
                if (e.message == "Invalid table structure.") {
                    // todo implement nicely
                    this.editorKernel.getDialogManager().alert(
                            CUI.rte.Utils.i18n("Paste"),
                            CUI.rte.Utils.i18n("You are trying to paste table data into an existing table.<br>As this operation would result in invalid HTML, it has been cancelled.<br>Please try to simplify the table's structure and try again."));
                    return;
                }
                throw e;
            }
            destMatrix.createTableMatrix(destTable);
            destMatrix.createFullMatrix();
            insertCellDom.parentNode.removeChild(insertCellDom);
            for (r = 0; r < pasteSize.rows; r++) {
                for (c = 0; c < pasteSize.cols; c++) {
                    cellToInsert = pasteMatrix.fullMatrix[r][c];
                    if (cellToInsert.isOrigin) {
                        insertBefore = destMatrix.getFollowUpCell(c + destCol,
                                r + destRow);
                        insertBeforeDom = (insertBefore ? insertBefore.cellDom : null);
                        pNode = destMatrix.getRowDom(r + destRow);
                        var cellDom = cellToInsert.cellRef.cellDom;
                        var helperSpan = context.createElement("span");
                        // as dynamic table handling is completely screwed up in IE, we'll
                        // have to do it the hard way here ...
                        helperSpan.innerHTML = "<table><tr><td></td></tr></table>";
                        var tdDom = CUI.rte.Query.selectNode("td:first", helperSpan);
                        var trDom = tdDom.parentNode;
                        com.replaceNode(tdDom, cellDom);
                        html = trDom.innerHTML;
                        if (!html) {
                            html = "<td>" + (com.ua.isIE ? "&nbsp;" : "<br>") + "</td>";
                        }
                        if (com.ua.isIE) {
                            com.removeAllChildren(helperSpan);
                            helperSpan.innerHTML = "<table><tr>" + html + "</tr></table>";
                            trDom = CUI.rte.Query.selectNode("tr:first", helperSpan);
                        } else {
                            trDom.innerHTML = html;
                        }
                        pNode.insertBefore(trDom.childNodes[0], insertBeforeDom);
                    }
                }
            }
        } else if (cells) {
            // Mode 2: If more than one table cell is selected, the selected cells are
            // replaced by the table to be pasted if possible (must be a rectangular cell
            // selection). The table is pasted as a nested table.
            var cellSel = destMatrix.createSelection(selection.cellSelection.cells);
            if (!cellSel.selectionProps.isRect) {
                this.editorKernel.getDialogManager().alert(
                        CUI.rte.Utils.i18n("Paste"),
                        CUI.rte.Utils.i18n("You are trying to paste table data into an non-rectangular cell selection.<br>Please choose a rectangular cell selection and try again."));
                return;
            }
            try {
                insertCellDom = destMatrix.mergeToSingleCell(context,
                        cellSel.selectionProps.minCol, cellSel.selectionProps.minRow,
                        cellSel.selectionProps.cols, cellSel.selectionProps.rows);
            } catch (e) {
                context.root.innerHTML = undoHtml;
                if (e.message == "Invalid table structure.") {
                    // todo implement nicely
                    this.editorKernel.getDialogManager().alert(
                            CUI.rte.Utils.i18n("Paste"),
                            CUI.rte.Utils.i18n("You are trying to paste table data into an existing table.<br>As this operation would result in invalid HTML, it has been cancelled.<br>Please try to simplify the table's structure and try again."));
                    return;
                }
                throw e;
            }
            com.removeAllChildren(insertCellDom);
            insertCellDom.innerHTML = pastedDom.innerHTML;
        }
    },

    /**
     * <p>Removes superfluos DIVs.</p>
     * <p>For example: &lt;div&gt;&lt;p&gt;...&lt;/p&gt;&lt;div&gt; contains a superflous
     * div that has to be discarded (and the contained paragraphs have to be moved up
     * one hierarchical level).</p>
     * @param {HTMLElement} divDom The div to preprocess
     * @private
     */
    // todo move to DomCleanup?
    preprocessDiv: function(divDom) {
        var com = CUI.rte.Common;
        var c, divChildCnt, divChild;
        // recurse first
        divChildCnt = divDom.childNodes.length;
        for (c = divChildCnt - 1; c >= 0; c--) {
            divChild = divDom.childNodes[c];
            if (com.isTag(divChild, "div")) {
                this.preprocessDiv(divChild);
            }
        }
        // handle Block-Tags that are nested in DIVs correctly
        var hasBlockTags = false;
        divChildCnt = divDom.childNodes.length;
        for (c = divChildCnt - 1; c >= 0; c--) {
            divChild = divDom.childNodes[c];
            if (com.isTag(divChild, com.BLOCK_TAGS)) {
                if (!com.hasTextChild(divChild)) {
                    divDom.removeChild(divChild);
                } else {
                    hasBlockTags = true;
                }
            }
        }
        if (hasBlockTags) {
            divChildCnt = divDom.childNodes.length;
            for (c = divChildCnt - 1; c >= 0; c--) {
                divChild = divDom.childNodes[c];
                divDom.removeChild(divChild);
                if (divDom.nextSibling) {
                    divDom.parentNode.insertBefore(divChild, divDom.nextSibling);
                } else {
                    divDom.parentNode.appendChild(divChild);
                }
            }
            divDom.parentNode.removeChild(divDom);
        } else if (!com.hasTextChild(divDom, true)) {
            // if div is without content now, remove it
            divDom.parentNode.removeChild(divDom);
        }
    },

    insertInExistingNode: function(context, insertDef, insertParent) {
        var com = CUI.rte.Common;
        var dpr = CUI.rte.DomProcessor;
        var sel = CUI.rte.Selection;
        var insertNode = insertDef.startNode;
        var insertOffset = insertDef.startOffset;
        // we can't use insert node and offset if we are pointing behind the end of a
        // text node that's inside a link
        if (insertOffset == sel.getLastSelectionOffset(context, insertNode, false)) {
            var checkNode = insertNode;
            while (checkNode) {
                checkNode = com.getTagInPath(context, checkNode, "a");
                if (checkNode && com.isAttribDefined(checkNode, "href")) {
                    var nn = com.getNextNode(context, checkNode);
                    var ntn = null;
                    if (nn != null) {
                        ntn = com.getNextCharacterNode(context, nn, com.EDITBLOCK_TAGS);
                    }
                    if (ntn) {
                        insertNode = ntn;
                        insertOffset = sel.getFirstSelectionOffset(context, ntn);
                    } else {
                        insertNode = checkNode.parentNode;
                        insertOffset = null;
                    }
                    break;
                }
            }
        }
        // determine node insert position (we'll use a single node as insert point and
        // move the pasted content nodes before, behind or "as child of" that node insert
        // point)
        var insertBehind, insertAsChild;
        if (insertNode.nodeType == 3) {
            if (insertOffset == 0) {
                insertBehind = false;
                insertAsChild = false;
            } else if (insertOffset == com.getNodeCharacterCnt(insertNode)) {
                insertBehind = true;
                insertAsChild = false;
            } else {
                var splitText = dpr.splitTextNode(context, insertNode, insertOffset);
                insertNode = splitText[splitText.length - 1];
                insertBehind = false;
                insertAsChild = false;
            }
        } else if (com.isOneCharacterNode(insertNode)) {
            insertBehind = (insertOffset == 0) || com.isTag(insertNode, 'br');
            insertAsChild = false;
        } else if (insertNode.nodeType == 1) {
            if ((insertOffset == undefined)
                    || (insertOffset == insertNode.childNodes.length)) {
                insertBehind = false;
                insertAsChild = true;
            } else {
                insertNode = insertNode[insertOffset];
                insertBehind = false;
                insertAsChild = true;
            }
        }
        // insert child by child
        var insertChildren = com.childNodesAsArray(insertParent);
        var insertCnt = insertChildren.length;
        for (var i = 0; i < insertCnt; i++) {
            var childToMove = insertChildren[i];
            insertParent.removeChild(childToMove);
            if (insertAsChild) {
                insertNode.appendChild(childToMove);
            } else if (insertBehind) {
                com.insertBefore(insertNode.parentNode, childToMove,
                        insertNode.nextSibling);
                insertNode = childToMove;
            } else {
                com.insertBefore(insertNode.parentNode, childToMove, insertNode);
            }
        }
        // remove duplicate structures (<b>text <b>Pasted</b> text</b> ->
        // <b>text Pasted text</b>)
        var dupCheckEnd = insertChildren[insertCnt - 1];
        var finalNode = com.getLastChild(dupCheckEnd);
        if (finalNode != null) {
            dupCheckEnd = finalNode;
        }
        var def = dpr.removeDuplicateStructures(context, insertChildren[0], dupCheckEnd);
        return {
            "startNode": def.endNode,
            "startOffset": CUI.rte.Selection.getLastSelectionOffset(context,
                    def.endNode, false)
        };
    },

    insertAsSingleLine: function(context, insertDef, insertParent) {
        var com = CUI.rte.Common;
        var dpr = CUI.rte.DomProcessor;
        var emptyBlock = dpr.getEmptyLine(context, insertDef);
        if (emptyBlock != null) {
            // this one is easy: simply replace the empty block
            com.removeAllChildren(emptyBlock);
            com.moveChildren(insertParent, emptyBlock);
            return {
                "startNode": emptyBlock,
                "startOffset": undefined
            };
        }
        // otherwise, insert node-by-node at the specified starting point
        return this.insertInExistingNode(context, insertDef, insertParent);
    },

    // todo move to DomCleanup?
    ensureBlockStructure: function(context, dom) {
        var com = CUI.rte.Common;
        var children = dom.childNodes;
        var childCnt = children.length;
        for (var c = childCnt - 1; c >= 0; c--) {
            var childToProcess = children[c];
            if (!com.isTag(childToProcess, com.BLOCK_TAGS)) {
                var helperPara = context.createElement("p");
                var insertRef = childToProcess.nextSibling;
                dom.removeChild(childToProcess);
                helperPara.appendChild(childToProcess);
                while (c > 0) {
                    c--;
                    var childToCheck = children[c];
                    if (com.isTag(childToCheck, com.BLOCK_TAGS)) {
                        c++;
                        break;
                    }
                    dom.removeChild(childToCheck);
                    helperPara.insertBefore(childToCheck, helperPara.firstChild);
                }
                com.insertBefore(dom, helperPara, insertRef);
                childToProcess = helperPara;
            }
        }
    },

    preprocessPastedDom: function(editorKernel, pastedDom, pasteRules) {
        var com = CUI.rte.Common;
        var context = editorKernel.getEditContext();
        // preprocess: ensure correct top-level DOM structure of pasted content
        var childCnt = pastedDom.childNodes.length;
        var children = pastedDom.childNodes;
        for (var c = childCnt - 1; c >= 0; c--) {
            var childToPreProcess = children[c];
            if (com.isTag(childToPreProcess, com.BLOCK_TAGS)) {
                if (com.isTag(childToPreProcess, "div")) {
                    this.preprocessDiv(childToPreProcess);
                }
            }
        }
        // preprocess: ensure correct block structure
        this.ensureBlockStructure(context, pastedDom);
    },

    splitExistingNode: function(context, node, offset) {
        var com = CUI.rte.Common;
        var dpr = CUI.rte.DomProcessor;
        var sel = CUI.rte.Selection;
        // handle begin and end of editing block correctly (must not split there)
        var editBlock = com.getTagInPath(context, node, com.EDITBLOCK_TAGS);
        if (!editBlock) {
            throw new Error("No edit block found. Cannot split node.");
        }
        var firstChild = com.getFirstChild(editBlock);
        if (firstChild == node) {
            if (offset == sel.getFirstSelectionOffset(context, node)) {
                return {
                    "insertPoint": editBlock,
                    "insertBehind": false
                };
            }
        }
        var lastChild = com.getLastChild(editBlock);
        if (lastChild == node) {
            if (offset == sel.getLastSelectionOffset(context, node, false)) {
                return {
                    "insertPoint": editBlock,
                    "insertBehind": true
                };
            }
        }
        // include one character node if necessary
        if (com.isOneCharacterNode(node)) {
            if (offset == 0) {
                node = com.getNextNode(context, node);
                offset = null;
            }
        }
        // split
        insertPoint = dpr.splitToParent(editBlock, node, offset);
        insertBehind = false;
        return {
            "insertPoint": insertPoint,
            "insertBehind": insertBehind
        };
    },

    /**
     * Inserts the pasted content as HTML. Works around IE problems regarding inserting
     * tables and ensures paste results that are independent from browser-specific
     * implementations.
     * @param {Object} execDef Execution definition
     * @private
     */
    insertHtml: function(execDef) {

        var dpr = CUI.rte.DomProcessor;
        var sel = CUI.rte.Selection;
        var com = CUI.rte.Common;
        var atomicBlocks = CUI.rte.commands.Paste.ATOMIC_PROCESSING_BLOCKS;

        var context = execDef.editContext;
        var pastedDom = execDef.value.dom;
        var pSel = sel.createProcessingSelection(context);
        // handle multi cell selection by pasting to the first selected cell
        if (pSel.cellSelection && pSel.cellSelection.cells) {
            if (pSel.cellSelection.cells.length > 0) {
                var startNode = pSel.cellSelection.cells[0];
                var startOffset = null;
                var ftn = com.getFirstTextChild(startNode, true);
                if (ftn) {
                    startNode = ftn;
                    startOffset = sel.getFirstSelectionOffset(context, ftn);
                }
                pSel.startNode = startNode;
                pSel.startOffset = startOffset;
                pSel.endNode = null;
                pSel.endOffset = null;
            }
        }
        var isAtomic, insertLoc, c;
        var insertBehind = false;
        var insertAsChild = false;

        this.preprocessPastedDom(execDef.component, pastedDom, execDef.value.pasteRules);
        var children = pastedDom.childNodes;
        var childCnt = children.length;

        if (childCnt == 0) {
            // nothing to paste at all
            return null;
        }

        var caretNode = pSel.startNode;
        var isListInsert = com.getTagInPath(context, caretNode, [ "ul", "ol" ]);
        // if we got a list as the only thing to insert, and we're inserting in a list,
        // then we'll insert list items instead of an entire list
        if (childCnt == 1) {
            if (com.isTag(children[0], [ "ul", "ol" ])) {
                if (isListInsert) {
                    pastedDom = children[0];
                    children = pastedDom.childNodes;
                    childCnt = children.length;
                }
            }
        }

        // if we're inserting into a list, we'll convert all non-list related containers
        // to list items (<p>Para</p> -> <li>Para</li>)
        if (isListInsert) {
            var blueprint = context.createElement("li");
            for (c = childCnt - 1; c >= 0; c--) {
                var child = children[c];
                if (com.isTag(child, [ "ul", "ol" ])) {
                    // take list items
                    var items = child.childNodes;
                    while (items.length > 0) {
                        var itemToMove = items[0];
                        pastedDom.insertBefore(itemToMove, child);
                    }
                    pastedDom.removeChild(child);
                } else if (!com.isTag(child, "li")) {
                    dpr.changeContainerTag(context, [ child ], blueprint, false);
                }
            }
            childCnt = children.length;
        }

        if (childCnt == 1) {
            isAtomic = com.isTag(children[0], atomicBlocks);
            if (!isAtomic) {
                return this.insertAsSingleLine(context, pSel, children[0]);
            }
        }

        // if we are inserting multiple blocks into a table, ensure that the table cell
        // contains block content, as otherwise we would destroy the table's structure
        var tableCell = com.getTagInPath(context, caretNode, [ "td", "th" ]);
        if (tableCell != null) {
            this.ensureBlockStructure(context, tableCell);
        }

        // working on a copy of the block list ...
        children = com.childNodesAsArray(pastedDom);
        // if we are pasting to an empty block which is no table cell, we will replace this
        // block with the new content
        var emptyBlock = dpr.getEmptyLine(context, pSel);
        var isFullReplace = (emptyBlock != null) && !com.isTag(emptyBlock, [ "td", "th"]);
        var isEnforcedAtomic = false;
        if (isFullReplace) {
            insertLoc = emptyBlock;
            insertBehind = false;
            isEnforcedAtomic = true;
        }
        if ((emptyBlock != null) && !isFullReplace) {
            // Gecko will have a "br" node, which is recognized as "empty block" correctly;
            // get rid of it, as we'll replace the entire content
            com.removeAllChildren(emptyBlock);
            insertLoc = emptyBlock;
            insertAsChild = true;
            isEnforcedAtomic = true;
        }
        var finalSelection = null;
        // insert block-by-block
        for (c = 0; c < childCnt; c++) {
            var blockToProcess = children[c];
            isAtomic = com.isTag(blockToProcess, atomicBlocks) || isEnforcedAtomic;
            var isLastChild = (c == (childCnt - 1));
            var insertDef, splitDef, insertNode, insertOffset;
            var insertBlock = false;
            if ((c == 0) && !isAtomic) {
                // first block & non-atomic & no paste on empty block: append paste
                // block to existing content
                insertDef = this.insertInExistingNode(context, pSel, blockToProcess);
                insertNode = insertDef.startNode;
                insertOffset = insertDef.startOffset;
                splitDef = this.splitExistingNode(context, insertNode, insertOffset);
                insertLoc = splitDef.insertPoint;
                insertBehind = splitDef.insertBehind;
            } else if ((c == 0) && isAtomic) {
                // first block & atomic & no paste on empty block: split existing
                // content + insert in-between
                if (!insertAsChild) {
                    // handle paste to an empty cell correctly
                    splitDef = this.splitExistingNode(context, pSel.startNode,
                            pSel.startOffset);
                    insertLoc = splitDef.insertPoint;
                    insertBehind = splitDef.insertBehind;
                }
                insertBlock = true;
            } else if (isLastChild && !isAtomic && !isFullReplace) {
                // last block & non-atomic & no paste on empty block: prepend paste block
                // to existing content
                if (insertBehind) {
                    if (insertLoc.nextSibling) {
                        insertNode = com.getFirstTextChild(insertLoc.nextSibling, true);
                    } else {
                        // we're EOT/EOB; so we'll just insert the entire block
                        insertNode = null;
                        insertBlock = true;
                    }
                } else {
                    insertNode = com.getFirstTextChild(insertLoc, true);
                }
                if (insertNode != null) {
                    insertOffset = sel.getFirstSelectionOffset(context, insertNode);
                    insertDef = {
                        "startNode": insertNode,
                        "startOffset": insertOffset
                    };
                    insertDef = this.insertInExistingNode(context, insertDef,
                            blockToProcess);
                    finalSelection = insertDef;
                }
            } else {
                // others: insert behind previous block
                insertBlock = true;
            }
            if (insertBlock) {
                if (insertBehind) {
                    com.insertBefore(insertLoc.parentNode, blockToProcess,
                        insertLoc.nextSibling);
                    insertLoc = blockToProcess;
                } else if (insertAsChild) {
                    insertLoc.appendChild(blockToProcess);
                } else {
                    com.insertBefore(insertLoc.parentNode, blockToProcess, insertLoc);
                }
                // handle empty blocks correctly
                if (com.ua.isIE) {
                    dpr.fixEmptyEditingBlockIE(context, blockToProcess);
                } else {
                    var contentNodes = com.getCharacterNodes(blockToProcess);
                    if (contentNodes == 0) {
                        var placeholder = dpr.createEmptyLinePlaceholder(context, false);
                        if (placeholder) {
                            var placeholderParent = com.getFirstChild(blockToProcess);
                            if (placeholderParent == null) {
                                placeholderParent = blockToProcess;
                            }
                            placeholderParent.appendChild(placeholder);
                        }
                    }
                }
                // don't forget to calculate new caret position on last container
                if (isLastChild) {
                    finalSelection = {
                        "startNode": blockToProcess,
                        "startOffset": null
                    };
                }
            }
        }
        if (isFullReplace) {
            emptyBlock.parentNode.removeChild(emptyBlock);
        }
        return finalSelection;
    },

    /**
     * Executes pasting HTML code to the current selection.
     * @param {Object} execDef Execution definition
     * @private
     */
    pasteAsWordHtml: function(execDef) {

        var sel = CUI.rte.Selection;
        var com = CUI.rte.Common;

        var context = execDef.editContext;

        /*
        var startTc = new Date().getTime();
        */

        // cleanup first
        var pastedDom = execDef.value.dom;
        this.cleanUpDom(context, execDef.component, pastedDom, execDef.value.pasteRules);

        // detect if we're pasting a table into another table
        var pSel;
        var isTablePaste = com.containsTag(pastedDom, "table");
        var nodeList = execDef.nodeList;
        var isTableSelection = com.containsTagInPath(context, nodeList.commonAncestor,
                "table");
        if (isTableSelection && isTablePaste) {
            try {
                this.pasteTableToTable(execDef);
            } catch (e) {
                if (e.message != "Invalid paste structure.") {
                    throw e;
                }
                // todo alert user
            }
        } else {
            // pasting outside an existing table or pasting content not containing a table
            // into an existing table
            pSel = this.insertHtml(execDef);
        }

        /*
        var endTc = new Date().getTime();
        com.ieLog("paste: " + (endTc - startTc) + "ms", true);
        */

        var bookmark;
        if (pSel) {
            bookmark = sel.bookmarkFromProcessingSelection(context, pSel);
        } else {
            bookmark = sel.createSelectionBookmark(context);
        }
        // IE sometimes generates nested blocks, which we'll have to resolve to
        // keep the code consistent. For example: Given an existing content of
        // <h1>Heading</h1><p>Paragraph</p>. Select all. Paste something like <p>para1</p>
        // <p>para2</p>. This will unexpectedly result in <h1><p>para1</p><p>para2</p></h1>.
        // todo check: this should not be necessary anymore, as paste implementation has changed and should handle this differently
        // CUI.rte.DomProcessor.cleanupNestedBlocks(context.root);
        execDef.bookmark = bookmark;
    },

    isCommand: function(cmdStr) {
        if (cmdStr.toLowerCase() == "paste") {
            return true;
        }
    },

    getProcessingOptions: function() {
        var cmd = CUI.rte.commands.Command;
        return cmd.PO_BOOKMARK;
    },

    execute: function(execDef) {

        var com = CUI.rte.Common;
        var sel = CUI.rte.Selection;
        var dpr = CUI.rte.DomProcessor;
        var pcmd = CUI.rte.commands.Paste;
        var context = execDef.editContext;
        var value = execDef.value;
        var mode = value.mode;
        var pasteRange = value.pasteRange;

        // use browser's paste command if necessary
        if (mode == pcmd.MODE_BROWSER) {
            try {
                context.doc.execCommand("paste", false, null);
            } catch (e) {
                throw new Error("Cannot paste.");
            }
            return;
        }

        try {
            // clear selection content
            execDef.component.selectQualifiedRangeBookmark(context, pasteRange);
            var selection = sel.getSelection(context);
            var isCollapsed = (com.ua.isOldIE ? sel.isCollapsed(pasteRange.bookmark)
                    : selection.isCollapsed) && !pasteRange.cells;
            if (!isCollapsed) {
                var pSel = execDef.component.createQualifiedSelection(context);
                var cells = (pSel.cellSelection ? pSel.cellSelection.cells : undefined);
                if (!cells || cells.length == 0) {
                    CUI.rte.commands.Delete.executeDelete(context);
                } else {
                    for (var c = 0; c < cells.length; c++) {
                        var cell = cells[c];
                        com.removeAllChildren(cell);
                        dpr.ensureEmptyLinePlaceholders(context, cell);
                    }
                }
            }

            // provide correct selection/nodeList parameters
            execDef.selection = execDef.component.createQualifiedSelection(context);
            execDef.nodeList = dpr.createNodeList(context, execDef.selection);

            var finalPasteSelection;
            switch (mode) {
                case pcmd.MODE_PLAINTEXT:
                    finalPasteSelection = this.pasteAsPlainText(execDef);
                    break;
                case pcmd.MODE_WORDHTML:
                    finalPasteSelection = this.pasteAsWordHtml(execDef);
                    break;
                default:
                    throw new Error("Invalid paste mode: " + mode);
                    break;
            }

            var bookmark = execDef.bookmark;
            if (finalPasteSelection) {
                bookmark = sel.bookmarkFromProcessingSelection(context,
                        finalPasteSelection);
            }
            execDef.bookmark = bookmark;

            return {
                "calleeRet": {
                    "bookmark": bookmark,
                    "geckoEnsureCaretVisibility": true
                }
            };
        } catch (e) {
            try {
                console.log(e);
            } catch (e) {
                // ignore
            }
        }
        return {
                "calleeRet": {
                    "bookmark": execDef.bookmark,
                    "geckoEnsureCaretVisibility": true
                }
            };
    }

});

/**
 * Paste mode: use browser's paste implementation (should usually not be used, as this may
 * introduce unwanted markup)
 */
CUI.rte.commands.Paste.MODE_BROWSER = "browser";

/**
 * Paste mode: plain text inserts
 */
CUI.rte.commands.Paste.MODE_PLAINTEXT = "plaintext";

/**
 * Paste mode: Word-compatible HTML inserting
 */
CUI.rte.commands.Paste.MODE_WORDHTML = "wordhtml";

/**
 * Block nodes that require atomic pasting
 */
CUI.rte.commands.Paste.ATOMIC_PROCESSING_BLOCKS = [ "table", "ul", "ol" ];


// register command
CUI.rte.commands.CommandRegistry.register("paste", CUI.rte.commands.Paste);
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.commands.Style
 * @extends CUI.rte.commands.Command
 * @private
 */
CUI.rte.commands.Style = new Class({

    toString: "Style",

    extend: CUI.rte.commands.Command,

    /**
     * Formats the currently selected text fragment with the given CSS style.
     * <p>
     * The currently selected text will be surrounded with a <code>span</code> tag that
     * has the given style name as its <code>class</code> attribute..
     * <p>
     * Note that this method only works on text fragments that have no other styles
     * applied.
     * @private
     */
    addStyle: function(execDef) {
        var sel = CUI.rte.Selection;
        var com = CUI.rte.Common;
        var styleName = execDef.value;
        var selection = execDef.selection;
        // handle DOM elements
        var selectedDom = sel.getSelectedDom(selection);
        var styleableObjects = CUI.rte.plugins.StylesPlugin.STYLEABLE_OBJECTS;
        if (selectedDom && com.isTag(selectedDom, styleableObjects)) {
            com.removeAllClasses(selectedDom);
            com.addClass(selectedDom, styleName);
            return;
        }
        // handle text fragments
        var nodeList = execDef.nodeList;
        if (nodeList) {
            nodeList.surround(execDef.editContext, "span", {
                "className": styleName
            });
        }
    },

    /**
     * Removes the style of the text fragment that is under the current caret position.
     * <p>
     * This method does currently not work with selections. Therefore a selection is
     * collapsed to a single char if the method is called for a selection.
     * @private
     */
    removeStyle: function(execDef) {
        var com = CUI.rte.Common;
        var dpr = CUI.rte.DomProcessor;
        var sel = CUI.rte.Selection;
        var selection = execDef.selection;
        var context = execDef.editContext;
        var styleToRemove = execDef.value;
        var styleName, styleCnt, s;
        // handle DOM elements
        var selectedDom = sel.getSelectedDom(selection);
        var styleableObjects = CUI.rte.plugins.StylesPlugin.STYLEABLE_OBJECTS;
        if (selectedDom && com.isTag(selectedDom, styleableObjects)) {
            if (styleToRemove && !styleToRemove.styles) {
                com.removeClass(selectedDom, styleToRemove);
            } else if (styleToRemove && styleToRemove.styles) {
                styleCnt = styleToRemove.styles.length;
                for (s = 0; s < styleCnt; s++) {
                    styleName = styleToRemove.styles[s];
                    if ((typeof(styleName) == "object") && styleName.cssName) {
                        styleName = styleName.cssName;
                    }
                    if (com.hasCSS(selectedDom, styleName)) {
                        com.removeClass(selectedDom, styleName);
                    }
                }
            } else {
                com.removeAllClasses(selectedDom);
            }
            return;
        }
        // handle text selections
        var nodeList = execDef.nodeList;
        var spanTags = nodeList.getTags(context, [ {
                matcher: function(dom) {
                    return com.isTag(dom, "span");
                }
            } ], true);
        var spansToRemove = [ ];
        var spanCnt = spanTags.length;
        for (var spanIndex = 0; spanIndex < spanCnt; spanIndex++) {
            var spanToProcess = spanTags[spanIndex].dom;
            if (styleToRemove && !styleToRemove.styles) {
                if (com.hasCSS(spanToProcess, styleToRemove)) {
                    spansToRemove.push(spanToProcess);
                }
            } else if (styleToRemove && styleToRemove.styles) {
                styleCnt = styleToRemove.styles.length;
                for (s = 0; s < styleCnt; s++) {
                    styleName = styleToRemove.styles[s].cssName;
                    if (com.hasCSS(spanToProcess, styleName)) {
                        spansToRemove.push(spanToProcess);
                        break;
                    }
                }
            } else {
                if (spanToProcess.className) {
                    spansToRemove.push(spanToProcess);
                }
            }
        }
        var removeCnt = spansToRemove.length;
        for (var r = 0; r < removeCnt; r++) {
            var spanToRemove = spansToRemove[r];
            dpr.removeWithoutChildren(spanToRemove);
        }
    },

    isCommand: function(cmdStr) {
        var cmdLC = cmdStr.toLowerCase();
        return (cmdLC == "applystyle") || (cmdLC == "removestyle");
    },

    getProcessingOptions: function() {
        var cmd = CUI.rte.commands.Command;
        return cmd.PO_BOOKMARK | cmd.PO_SELECTION | cmd.PO_NODELIST;
    },

    execute: function(execDef) {
        switch (execDef.command.toLowerCase()) {
            case "applystyle":
                this.addStyle(execDef);
                break;
            case "removestyle":
                this.removeStyle(execDef);
                break;
        }
    },

    queryState: function(selectionDef, cmd) {
        // todo find a meaningful implementation -> list of span tags?
        return false;
    }

});


// register command
CUI.rte.commands.CommandRegistry.register("style", CUI.rte.commands.Style);
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.commands.Table
 * @extends CUI.rte.commands.Command
 * @private
 * <p>This class implements the RichText commands for creating and editing a table.</p>
 * <p>The following commands are supported (in parantheses: valid command values)</p>
 * <ul>
 *   <li>createtable</li>
 *   <li>modifytable</li>
 *   <li>removetable</li>
 *   <li>insertrow (before, after)</li>
 *   <li>removerow</li>
 *   <li>insertcolumn (before, after)</li>
 *   <li>removecolumn</li>
 *   <li>modifycell</li>
 *   <li>mergecells</li>
 *   <li>splitcell</li>
 *   <li>ensureparagraph (before, after)</li>
 * </ul>
 */
CUI.rte.commands.Table = new Class({

    toString: "Table",

    extend: CUI.rte.commands.Command,

    /**
     * @private
     */
    getTable: function(execDef) {
        var com = CUI.rte.Common;
        var context = execDef.editContext;
        return com.getTagInPath(context, execDef.nodeList.commonAncestor, "table");
    },

    /**
     * @private
     */
    createEmptyCell: function(execDef, refNode) {
       return CUI.rte.TableMatrix.createEmptyCell(execDef.editContext, refNode);
    },

    /**
     * @private
     */
    transferConfigToTable: function(dom, config) {
        var com = CUI.rte.Common;
        var noneConfig = CUI.rte.commands.Table.CONFIG_NONE;
        if (config.cellpadding) {
            com.setAttribute(dom, "cellpadding", config.cellpadding);
        } else {
            com.removeAttribute(dom, "cellpadding");
        }
        if (config.cellspacing) {
            com.setAttribute(dom, "cellspacing", config.cellspacing);
        } else {
            com.removeAttribute(dom, "cellspacing");
        }
        if (config.border) {
            dom.border = config.border;
            if (config.border == 0) {
                com.addClass(dom, CUI.rte.Theme.TABLE_NOBORDER_CLASS);
            } else {
                com.removeClass(dom, CUI.rte.Theme.TABLE_NOBORDER_CLASS);
            }
        } else {
            com.removeAttribute(dom, "border");
            com.addClass(dom, CUI.rte.Theme.TABLE_NOBORDER_CLASS);
        }
        if (config.width) {
            com.setAttribute(dom, "width", config.width);
        } else {
            com.removeAttribute(dom, "width");
        }
        if (config.height) {
            com.setAttribute(dom, "height", config.height);
        } else {
            com.removeAttribute(dom, "height");
        }
        var classNames = com.parseCSS(dom);
        for (var i = 0; i < classNames.length; i++) {
            if (classNames[i] != CUI.rte.Theme.TABLE_NOBORDER_CLASS) {
                com.removeClass(dom, classNames[i]);
            }
        }
        if (config.tableStyle && (config.tableStyle != noneConfig)) {
            com.addClass(dom, config.tableStyle);
        }
    },

    /**
     * @private
     */
    createTable: function(execDef) {
        var dpr = CUI.rte.DomProcessor;
        var sel = CUI.rte.Selection;
        var com = CUI.rte.Common;
        var context = execDef.editContext;
        var selection = execDef.selection;
        var insertNode = selection.startNode;
        var insertOffset = selection.startOffset;
        var insertBlock = dpr.getScopedBlockNode(context, insertNode);
        if (!insertBlock) {
            return;
        }
        var isAuxRoot = insertBlock.isAuxiliaryRoot;
        insertBlock = insertBlock.dom;
        var insertAsChild = false;
        var removeDom = null;
        if (dpr.isEmptyLineBlock(insertBlock) && !isAuxRoot) {
            removeDom = insertBlock;
            insertNode = insertBlock;
        } else if (com.isTag(insertBlock, com.TABLE_CELLS)) {
            // nested table
            insertNode = insertBlock;
            insertAsChild = true;
            // currently we'll remove all existing child nodes of the existing cell to
            // reduce complexity a bit, but that restriction may be removed later
            com.removeAllChildren(insertNode);
        } else if (dpr.isBlockStart(context, insertNode, insertOffset)) {
            insertNode = insertBlock;
        } else if (dpr.isBlockEnd(context, insertNode, insertOffset)) {
            insertNode = insertBlock.nextSibling;
        } else {
            insertNode = dpr.insertParagraph(context, insertNode, insertOffset);
            if (!insertNode) {
                return;
            }
        }
        var config = execDef.value;
        var nodeToInsert;
        var tableDom = null;
        var spanHelperDom = null;
        if (config.html) {
            spanHelperDom = context.createElement("span");
            spanHelperDom.innerHTML = config.html;
            nodeToInsert = spanHelperDom;
        } else {
            tableDom = context.createElement("table");
            nodeToInsert = tableDom;
        }
        if (!insertAsChild) {
            insertNode.parentNode.insertBefore(nodeToInsert, insertNode);
        } else {
            insertNode.appendChild(nodeToInsert);
        }
        if (removeDom) {
            removeDom.parentNode.removeChild(removeDom);
        }
        if (config.html) {
            var tables = CUI.rte.Query.select("table", spanHelperDom);
            for (var t = 0; t < tables.length; t++) {
                if (tables[t].border == 0) {
                    com.addClass(tables[t], CUI.rte.Theme.TABLE_NOBORDER_CLASS);
                }
            }
            dpr.removeWithoutChildren(spanHelperDom);
            return;
        }
        var headerConfig = config.header;
        var hasTopHeader = (headerConfig.indexOf("top") >= 0);
        var hasLeftHeader = (headerConfig.indexOf("left") >= 0);
        this.transferConfigToTable(tableDom, config);
        var tbody = context.createElement("tbody");
        tableDom.appendChild(tbody);
        var firstCell = null;
        for (var i = 0; i < config.rows; i++) {
            var tr = context.createElement("tr");
            tbody.appendChild(tr);
            for (var j = 0; j < config.columns; j++) {
                var tagName = "td";
                if (((i == 0) && hasTopHeader) || ((j == 0) && hasLeftHeader)) {
                    tagName = "th";
                }
                var cell = context.createElement(tagName);
                if (!firstCell) {
                    firstCell = cell;
                }
                tr.appendChild(cell);
                var placeholder = dpr.createEmptyLinePlaceholder(context);
                if (placeholder) {
                    cell.appendChild(placeholder);
                }
            }
        }
        execDef.bookmark = sel.bookmarkFromProcessingSelection(context, {
            "startNode": firstCell,
            "startOffset": null
        });
    },

    /**
     * @private
     */
    modifyTable: function(execDef) {
        var sel = CUI.rte.Selection;
        var com = CUI.rte.Common;
        var table = this.getTable(execDef);
        var config = execDef.value;
        if (table && config) {
            this.transferConfigToTable(table, config);
        }
        if (com.ua.isGecko) {
            sel.flushSelection(execDef.editContext);
        } else {
            execDef.bookmark = null;
        }
    },

    /**
     * @private
     */
    removeTable: function(execDef) {
        var sel = CUI.rte.Selection;
        var com = CUI.rte.Common;
        var dpr = CUI.rte.DomProcessor;
        var context = execDef.editContext;
        var table = this.getTable(execDef);
        if (table) {
            var bookmark = sel.bookmarkFromProcessingSelection(context, {
                "startNode": table,
                "startOffset": 0
            });
            var tableParent = table.parentNode;
            tableParent.removeChild(table);
            var cellParent = com.getTagInPath(context, tableParent, [ "td", "th" ]);
            if (cellParent) {
                dpr.ensureEmptyLinePlaceholders(context, cellParent);
            }
            // prevent completely empty document
            if ((tableParent == context.root) && (tableParent.childNodes.length == 0)) {
                context.root.appendChild(dpr.createEmptyLinePlaceholder(context, true));
            }
            // Gecko keeps the table handles drawn, so play around with the
            // selection to get rid of it
            sel.flushSelection(context);
            execDef.bookmark = bookmark;
        }
    },

    /**
     * @private
     */
    getTableBody: function(execDef) {
        var com = CUI.rte.Common;
        var table = this.getTable(execDef);
        var rows = com.getChildNodesByType(table, "tr", true);
        if (rows.length > 0) {
            table = rows[0].parentNode;
        }
        return table;
    },

    /**
     * <p>Checks if the specified cell is empty.</p>
     * <p>As most browsers use placeholders in such cases, a cell is empty if it either
     * has bo child not or only a placeholder
     * @param {HTMLElement} cellDom The cell DOM element to check
     * @private
     */
    isEmptyCell: function(cellDom) {
        return CUI.rte.DomProcessor.isEmptyLineBlock(cellDom);
    },

    /**
     * @private
     */
    getSelectedRows: function(execDef) {
        var com = CUI.rte.Common;
        var context = execDef.editContext;
        return execDef.nodeList.getTags(context, [{
                "matcher": function(dom) {
                    return com.isTag(dom, "tr");
                }
            }], true, true);
    },

    /**
     * Get all cells that occupy the same row as the specified cell.
     * @param {Object} execDef Execution definition
     * @param {HTMLElement} cell Reference cell
     * @return {HTMLElement[]} Array containing all cells that occupy the same row
     */
    getEntireRowForCell: function(execDef, cell) {
        var tableDom = this.getTable(execDef);
        var tableMatrix = new CUI.rte.TableMatrix();
        tableMatrix.createTableMatrix(tableDom);
        var cellDef = tableMatrix.getCellDef(cell);
        var baseRow = cellDef.row;
        var rowCells = [ ];
        if (cellDef) {
            var row = tableMatrix.getRow(baseRow);
            if (row) {
                for (var c = 0; c < row.length; c++) {
                    var cellToProcess = row[c];
                    // use only cells that actually *start* at the same row (not the ones
                    // that intersect by rowspan settings)
                    if (cellToProcess.row == baseRow) {
                        rowCells.push(cellToProcess.cellDom);
                    }
                }
            }
        }
        return rowCells
    },

    /**
     * Get all cells that occupy the same column as the specified cell.
     * @param {Object} execDef Execution definition
     * @param {HTMLElement} cell Reference cell
     * @return {HTMLElement[]} Array containing all cells that occupy the same column
     */
    getEntireColumnForCell: function(execDef, cell) {
        var tableDom = this.getTable(execDef);
        var tableMatrix = new CUI.rte.TableMatrix();
        tableMatrix.createTableMatrix(tableDom);
        var cellDef = tableMatrix.getCellDef(cell);
        var baseColumn = cellDef.col;
        var colCells = [ ];
        if (cellDef) {
            var column = tableMatrix.getColumn(baseColumn);
            if (column) {
                for (var c = 0; c < column.length; c++) {
                    var cellToProcess = column[c];
                    // use only cells that actually *start* at the same column (not the ones
                    // that intersect by colspan settings)
                    if (cellToProcess.col == baseColumn) {
                        colCells.push(cellToProcess.cellDom);
                    }
                }
            }
        }
        return colCells
    },

    /**
     * @private
     */
    insertRow: function(execDef, insertBefore, caretPosition) {
        var sel = CUI.rte.Selection;
        var context = execDef.editContext;
        var rows = this.getSelectedRows(execDef);
        if (rows.length == 1) {
            if (!caretPosition) {
                caretPosition = "default";
            }
            var cells = this.getSelectedCells(execDef);
            var tableDom = this.getTable(execDef);
            var tableMatrix = new CUI.rte.TableMatrix();
            tableMatrix.createTableMatrix(tableDom);
            var refCellDef = tableMatrix.getCellDef(cells[0].dom);
            var refRow = (insertBefore ? refCellDef.row
                : refCellDef.row + refCellDef.rowSpan - 1);
            var cols = tableMatrix.getRow(refRow);
            var row = context.createElement("tr");
            var refRowDom = tableMatrix.getRowDom(refRow);
            var insertRef = (insertBefore ? refRowDom : refRowDom.nextSibling);
            refRowDom.parentNode.insertBefore(row, insertRef);
            var cellToSelect;
            for (var c = 0; c < cols.length; c++) {
                var cell = cols[c];
                var cellDom = cell.cellDom;
                var newCell = this.createEmptyCell(execDef, cellDom);
                if (cellDom.colSpan > 1) {
                    newCell.colSpan = cellDom.colSpan;
                }
                if (caretPosition == "default") {
                    if (cell == refCellDef) {
                        cellToSelect = newCell;
                    }
                } else if (caretPosition == "firstCell") {
                    if (c == 0) {
                        cellToSelect = newCell;
                    }
                }
                if (cell.rowSpan == 1) {
                    row.appendChild(newCell);
                } else {
                    var extendExistingCell = (insertBefore ? (cell.row != refCellDef.row)
                            : ((cell.row + cell.rowSpan - 1) > refRow));
                    if  (!extendExistingCell) {
                        row.appendChild(newCell);
                    } else {
                        if (caretPosition == "default") {
                            if (cell == refCellDef) {
                                cellToSelect = cellDom;
                            }
                        } else if (caretPosition == "firstCell") {
                            if (c == 0) {
                                cellToSelect = cellDom;
                            }
                        }
                        cellDom.rowSpan++;
                    }
                }
            }
            // Gecko keeps the table handles drawn, so play around with the
            // selection to get rid of it
            sel.flushSelection(context);
            if (cellToSelect) {
                execDef.bookmark = sel.bookmarkFromProcessingSelection(context, {
                    startNode: cellToSelect,
                    startOffset: null
                });
            } else {
                execDef.bookmark = null;
            }
        }
    },

    /**
     * @private
     */
    removeRow: function(execDef) {
        var sel = CUI.rte.Selection;
        var dpr = CUI.rte.DomProcessor;
        var context = execDef.editContext;
        var table = this.getTable(execDef);
        var rows = this.getSelectedRows(execDef);
        if (rows.length == 1) {
            var tableMatrix = new CUI.rte.TableMatrix();
            tableMatrix.createTableMatrix(table);
            var tableSize = tableMatrix.getTableSize();
            if (tableSize.rows == 1) {
                this.removeTable(execDef);
                return;
            }
            var cells = this.getSelectedCells(execDef);
            var cellDef = tableMatrix.getCellDef(cells[0].dom);
            var rowToRemove = tableMatrix.getRow(cellDef.row);
            var cellToSelect;
            if (cellDef.rowSpan > 1) {
                cellToSelect = cellDef.cellDom;
            } else {
                if (cellDef.row < (tableSize.rows - 1)) {
                    cellToSelect = tableMatrix.getCellForCoords(cellDef.col,
                            cellDef.row + 1);
                } else {
                    cellToSelect =
                        tableMatrix.getCellForCoords(cellDef.col, cellDef.row - 1);
                }
                if (cellToSelect) {
                    cellToSelect = cellToSelect.cellDom;
                } else {
                    cellToSelect = table;
                }
            }
            var cellDom;
            for (var c = 0; c < rowToRemove.length; c++) {
                var cellToRemove = rowToRemove[c];
                cellDom = cellToRemove.cellDom;
                if (cellToRemove.rowSpan == 1) {
                    // remove
                    cellDom.parentNode.removeChild(cellDom);
                } else {
                    // decrease rowspan and remove content if necessary
                    if (cellToRemove.row == cellDef.row) {
                        while (cellDom.childNodes.length > 0) {
                            cellDom.removeChild(cellDom.childNodes[0]);
                        }
                        cellDom.appendChild(context.createTextNode(dpr.NBSP));
                        // move cell to next row
                        cellDom.parentNode.removeChild(cellDom);
                        var insertCellDef = tableMatrix.getRowCellForCoords(c,
                                cellDef.row + 1);
                        var insertCell = (insertCellDef ? insertCellDef.cellDom : null);
                        var parentNode = (insertCell ? insertCell.parentNode
                            : tableMatrix.getRowDom(cellDef.row + 1));
                        parentNode.insertBefore(cellDom, insertCell);
                    }
                    cellDom.rowSpan--;
                }
            }
            // remove tr element itself if necessary
            var rowDom = rows[0].dom;
            rowDom.parentNode.removeChild(rowDom);
            // optimize spans if possible
            tableMatrix.createTableMatrix(table);
            tableMatrix.optimizeSpans();
            // Gecko keeps the table handles drawn, so play around with the
            // selection to get rid of it
            sel.flushSelection(context);
            if (cellToSelect) {
                execDef.bookmark = sel.bookmarkFromProcessingSelection(context, {
                    startNode: cellToSelect,
                    startOffset: null
                });
            } else {
                execDef.bookmark = null;
            }
        }
    },

    /**
     * @private
     */
    getSelectedCells: function(execDef) {
        var context = execDef.editContext;
        var cellSelection = execDef.selection.cellSelection;
        if (cellSelection) {
            var cellsSelected = [ ];
            for (var c = 0; c < cellSelection.cells.length; c++) {
                cellsSelected.push({
                    "dom": cellSelection.cells[c]
                });
            }
            return cellsSelected;
        }
        var nodeList = execDef.nodeList;
        var com = CUI.rte.Common;
        var isTableFound = false;
        return nodeList.getTags(context, [{
                "matcher": function(dom) {
                    if (isTableFound) {
                        return false;
                    }
                    if (com.isTag(dom, [ "td", "th" ])) {
                        isTableFound = true;
                        return true;
                    }
                    return false;
                }
            }], true, true);
    },

    /**
     * @private
     */
    insertCol: function(execDef, insertBefore) {
        var sel = CUI.rte.Selection;
        var context = execDef.editContext;
        var cells = this.getSelectedCells(execDef);
        if (cells.length == 1) {
            var tableDom = this.getTable(execDef);
            var tableMatrix = new CUI.rte.TableMatrix();
            tableMatrix.createTableMatrix(tableDom);
            var refCellDef = tableMatrix.getCellDef(cells[0].dom);
            var refCol = (insertBefore ? refCellDef.col
                    : refCellDef.col + refCellDef.colSpan - 1);
            var rows = tableMatrix.getColumn(refCol);
            var cellToSelect;
            for (var r = 0; r < rows.length; r++) {
                var cell = rows[r];
                var cellDom = cell.cellDom;
                var newCell = this.createEmptyCell(execDef, cellDom);
                if (cellDom.rowSpan > 1) {
                    newCell.rowSpan = cellDom.rowSpan;
                }
                var insertRef = (insertBefore ? cellDom : cellDom.nextSibling);
                if (cell == refCellDef) {
                    cellToSelect = newCell;
                }
                if (cell.colSpan == 1) {
                    cellDom.parentNode.insertBefore(newCell, insertRef);
                } else {
                    var extendExistingCell = (insertBefore ? (cell.col != refCellDef.col)
                            : ((cell.col + cell.colSpan - 1) > refCol));
                    if  (!extendExistingCell) {
                        cellDom.parentNode.insertBefore(newCell, insertRef);
                    } else {
                        if (cell == refCellDef) {
                            cellToSelect = cellDom;
                        }
                        cellDom.colSpan++;
                    }
                }
            }
            // Gecko keeps the table handles drawn, so play around with the
            // selection to get rid of it
            sel.flushSelection(context);
            if (cellToSelect) {
                execDef.bookmark = sel.bookmarkFromProcessingSelection(context, {
                    startNode: cellToSelect,
                    startOffset: null
                });
            } else {
                execDef.bookmark = null;
            }
        }
    },

    /**
     * @private
     */
    removeCol: function(execDef) {
        var sel = CUI.rte.Selection;
        var dpr = CUI.rte.DomProcessor;
        var context = execDef.editContext;
        var table = this.getTable(execDef);
        var cells = this.getSelectedCells(execDef);
        if (cells.length == 1) {
            var tableMatrix = new CUI.rte.TableMatrix();
            tableMatrix.createTableMatrix(table);
            var tableSize = tableMatrix.getTableSize();
            if (tableSize.cols == 1) {
                this.removeTable(execDef);
                return;
            }
            var cellDef = tableMatrix.getCellDef(cells[0].dom);
            var colToRemove = tableMatrix.getColumn(cellDef.col);
            var cellToSelect;
            if (cellDef.colSpan > 1) {
                cellToSelect = cellDef.cellDom;
            } else {
                cellToSelect = tableMatrix.getFollowUpCell(cellDef.col, cellDef.row);
                if (!cellToSelect && (cellDef.col > 0)) {
                    cellToSelect = tableMatrix.getCellForCoords(cellDef.col - 1,
                            cellDef.row);
                }
                if (cellToSelect) {
                    cellToSelect = cellToSelect.cellDom;
                } else {
                    cellToSelect = table;
                }
            }
            var cellDom;
            for (var r = 0; r < colToRemove.length; r++) {
                var cellToRemove = colToRemove[r];
                cellDom = cellToRemove.cellDom;
                if (cellToRemove.colSpan == 1) {
                    // remove
                    cellDom.parentNode.removeChild(cellDom);
                } else {
                    // decrease colspan and remove content if necessary
                    if (cellToRemove.col == cellDef.col) {
                        while (cellDom.childNodes.length > 0) {
                            cellDom.removeChild(cellDom.childNodes[0]);
                        }
                        cellDom.appendChild(context.createTextNode(dpr.NBSP));
                    }
                    cellDom.colSpan--;
                }
            }
            // optimize spans if possible
            tableMatrix.createTableMatrix(table);
            tableMatrix.optimizeSpans();
            // Gecko keeps the table handles drawn, so play around with the
            // selection to get rid of it
            sel.flushSelection(context);
            if (cellToSelect) {
                execDef.bookmark = sel.bookmarkFromProcessingSelection(context, {
                    startNode: cellToSelect,
                    startOffset: null
                });
            } else {
                execDef.bookmark = null;
            }
        }
    },

    /**
     * @private
     */
    transferConfigToCell: function(context, dom, config) {
        var com = CUI.rte.Common;
        var noneConfig = CUI.rte.commands.Table.CONFIG_NONE;
        if (config.cellType && (config.cellType != noneConfig)) {
            if (!com.isTag(dom, config.cellType)) {
                var changedDom = context.createElement(config.cellType);
                com.copyAttributes(dom, changedDom);
                com.replaceNode(dom, changedDom);
                dom = changedDom;
            }
        }
        if (config.width) {
            com.setAttribute(dom, "width", config.width);
        } else {
            com.removeAttribute(dom, "width", config.height);
        }
        if (config.height) {
            com.setAttribute(dom, "height", config.height);
        } else {
            com.removeAttribute(dom, "height");
        }
        if (config.align) {
            if (config.align != noneConfig) {
                dom.style.textAlign = config.align;
            } else {
                dom.style.textAlign = "";
            }
        }
        if (config.valign) {
            if (config.valign != noneConfig) {
                com.setAttribute(dom, "valign", config.valign);
            } else {
                com.removeAttribute(dom, "valign");
            }
        }
        if (com.ua.isIE) {
            dom.removeAttribute("className");
        } else {
            dom.removeAttribute("class");
        }
        if (config.cellStyle && (config.cellStyle != noneConfig)) {
            com.addClass(dom, config.cellStyle);
        }
    },

    /**
     * @private
     */
    modifyCell: function(execDef) {
        var sel = CUI.rte.Selection;
        var com = CUI.rte.Common;
        var context = execDef.editContext;
        var cell = this.getSelectedCells(execDef);
        if (cell.length != 1) {
            return;
        }
        cell = cell[0].dom;
        var config = execDef.value;
        if (cell && config) {
            var applyTo = config._applyTo;
            var cellsToApply;
            switch (applyTo) {
                case "cell":
                    cellsToApply = [ cell ];
                    break;
                case "row":
                    cellsToApply = this.getEntireRowForCell(execDef, cell);
                    break;
                case "column":
                    cellsToApply = this.getEntireColumnForCell(execDef, cell);
                    break;
            }
            for (var i = 0; i < cellsToApply.length; i++) {
                this.transferConfigToCell(context, cellsToApply[i], config);
            }
        }
        // Gecko keeps the table handles drawn, so play around with the
        // selection to get rid of it
        if (com.ua.isGecko) {
            sel.flushSelection(context);
        } else {
            execDef.bookmark = null;
        }
    },

    /**
     * @private
     */
    mergeCells: function(execDef) {
        var com = CUI.rte.Common;
        var sel = CUI.rte.Selection;
        var context = execDef.editContext;
        var selProps = execDef.value.selectionProps;
        var anchorCell = (selProps ? selProps.anchorCell : null);
        if (anchorCell) {
            var table = this.getTable(execDef);
            var anchorDom = anchorCell.cellDom;
            var colSpan = selProps.cols;
            var rowSpan = selProps.rows;
            var cells = execDef.value.cells;
            var contentNodes = [ ];
            for (var c = 0; c < cells.length; c++) {
                var cellDom = cells[c].cellDom;
                if (cellDom != anchorDom) {
                    if (!this.isEmptyCell(cellDom)) {
                        // add space
                        contentNodes.push(context.createTextNode(" "));
                        var children = cellDom.childNodes;
                        for (var i = 0; i < children.length; i++) {
                            contentNodes.push(children[i]);
                        }
                    }
                    cellDom.parentNode.removeChild(cellDom);
                }
            }
            if (colSpan > 1) {
                com.setAttribute(anchorDom, "colspan", colSpan);
            } else {
                com.removeAttribute(anchorDom, "colspan");
            }
            if (rowSpan > 1) {
                com.setAttribute(anchorDom, "rowspan", rowSpan);
            } else {
                com.removeAttribute(anchorDom, "rowspan");
            }
            for (i = 0; i < contentNodes.length; i++) {
                anchorDom.appendChild(contentNodes[i]);
            }
            // optimize spans & table structure
            var tableMatrix = new CUI.rte.TableMatrix();
            tableMatrix.createTableMatrix(table);
            tableMatrix.optimizeSpans();
            // Gecko keeps the table handles drawn, so play around with the
            // selection to get rid of it
            sel.flushSelection(context);
            execDef.bookmark = sel.bookmarkFromProcessingSelection(context, {
                startNode: anchorDom,
                startOffset: null
            });
        }
    },

    /**
     * @private
     */
    splitCellHorizontally: function(execDef) {
        var sel = CUI.rte.Selection;
        var context = execDef.editContext;
        var table = this.getTable(execDef);
        var cells = this.getSelectedCells(execDef);
        if (table && cells.length == 1) {
            var cell = cells[0].dom;
            var newCell = this.createEmptyCell(execDef);
            if (cell.rowSpan && cell.rowSpan > 1) {
                newCell.rowSpan = cell.rowSpan;
            }
            if (cell.colSpan && cell.colSpan > 1) {
                // if the current cell already has some colspan, decrease by 1
                cell.colSpan = cell.colSpan - 1;
                cell.parentNode.insertBefore(newCell, cell.nextSibling);
            } else {
                // if the cell to be split has no colspan, increase colspan of all
                // cells in this cell's column by 1
                var tableMatrix = new CUI.rte.TableMatrix();
                tableMatrix.createTableMatrix(table);
                tableMatrix.createFullMatrix();
                var cellDef = tableMatrix.getCellDef(cell);
                var col = tableMatrix.getColumn(cellDef.col);
                cell.parentNode.insertBefore(newCell, cell.nextSibling);
                for (var c = 0; c < col.length; c++) {
                    if (col[c] != cellDef) {
                        var colSpan = col[c].cellDom.colSpan;
                        colSpan = colSpan || 1;
                        col[c].cellDom.colSpan = ++colSpan;
                    }
                }
            }
            // Gecko keeps the table handles drawn, so play around with the
            // selection to get rid of it
            sel.flushSelection(context);
            execDef.bookmark = sel.bookmarkFromProcessingSelection(context, {
                startNode: newCell,
                startOffset: null
            });
        }
    },

    /**
     * @private
     */
    splitCellVertically: function(execDef) {
        var sel = CUI.rte.Selection;
        var context = execDef.editContext;
        var table = this.getTable(execDef);
        var cells = this.getSelectedCells(execDef);
        if (table && cells.length == 1) {
            var cell = cells[0].dom;
            var newCell = this.createEmptyCell(execDef);
            if (cell.colSpan && cell.colSpan > 1) {
                newCell.colSpan = cell.colSpan;
            }
            var tableMatrix = new CUI.rte.TableMatrix();
            tableMatrix.createTableMatrix(table);
            tableMatrix.createFullMatrix();
            var cellDef = tableMatrix.getCellDef(cell);
            if (cell.rowSpan && cell.rowSpan > 1) {
                // if the current cell already has some rowspan, decrease by 1
                var lastCellRow = cellDef.row + cellDef.rowSpan - 1;
                var insertCellDef = tableMatrix.getRowCellForCoords(cellDef.col + 1,
                        lastCellRow);
                var insertCell = (insertCellDef ? insertCellDef.cellDom : null);
                var parentNode = (insertCell ? insertCell.parentNode
                        : tableMatrix.getRowDom(lastCellRow));
                parentNode.insertBefore(newCell, insertCell);
                cell.rowSpan = cell.rowSpan - 1;
            } else {
                // if the cell to be split has no rowspan, increase rowspan of all
                // cells in this cell's row by 1 and insert a new row
                var row = tableMatrix.getRow(cellDef.row);
                var cellRow = cell.parentNode;
                var newRow = context.createElement("tr");
                newRow.appendChild(newCell);
                cellRow.parentNode.insertBefore(newRow, cellRow.nextSibling);
                for (var c = 0; c < row.length; c++) {
                    if (row[c] != cellDef) {
                        var rowSpan = row[c].cellDom.rowSpan;
                        rowSpan = rowSpan || 1;
                        row[c].cellDom.rowSpan = ++rowSpan;
                    }
                }
            }
            // Gecko keeps the table handles drawn, so play around with the
            // selection to get rid of it
            sel.flushSelection(context);
            execDef.bookmark = sel.bookmarkFromProcessingSelection(context, {
                startNode: newCell,
                startOffset: null
            });
        }
    },

    ensureParagraph: function(execDef, ensureBefore) {
        var dpr = CUI.rte.DomProcessor;
        var com = CUI.rte.Common;
        var sel = CUI.rte.Selection;
        var context = execDef.editContext;
        var insertNode = null;
        var tableDom = this.getTable(execDef);
        if (!tableDom) {
            return;
        }
        var bodyNode = tableDom.parentNode;
        if (!com.isRootNode(context, bodyNode)) {
            return;
        }
        if (ensureBefore) {
            insertNode = tableDom;
        } else {
            insertNode = tableDom.nextSibling;
        }
        var paraNode = dpr.createEmptyLinePlaceholder(context, true);
        bodyNode.insertBefore(paraNode, insertNode);
        dpr.fixEmptyEditingBlockIE(context, paraNode);
        // Gecko keeps the table handles drawn, so play around with the selection to get
        // rid of it
        sel.flushSelection(context);
        execDef.bookmark = sel.bookmarkFromProcessingSelection(context, {
            startNode: paraNode,
            startOffset: 0
        });
    },

    /**
     * @private
     */
    isCommand: function(cmdStr) {
        var com = CUI.rte.Common;
        var cmdLC = cmdStr.toLowerCase();
        return com.strEndsWith(cmdLC, "table") || com.strEndsWith(cmdLC, "column")
                || com.strEndsWith(cmdLC, "row") || com.strEndsWith(cmdLC, "cell")
                || com.strEndsWith(cmdLC, "cells") || cmdLC == "ensureparagraph";
    },

    /**
     * @private
     */
    getProcessingOptions: function() {
        var cmd = CUI.rte.commands.Command;
        return cmd.PO_BOOKMARK | cmd.PO_SELECTION | cmd.PO_NODELIST;
    },

    /**
     * @private
     */
    execute: function(execDef) {
        var ret = undefined;
        var position;
        switch (execDef.command.toLowerCase()) {
            case "createtable":
                this.createTable(execDef);
                break;
            case "modifytable":
                this.modifyTable(execDef);
                break;
            case "removetable":
                this.removeTable(execDef);
                break;
            case "insertrow":
                var caretPosition = "default";
                if (typeof(execDef.value) == "string") {
                    position = execDef.value;
                } else {
                    position = execDef.value.position;
                    caretPosition = execDef.value.caret;
                }
                this.insertRow(execDef, !position || (position == "before"), caretPosition);
                ret = {
                    "calleeRet": {
                        "geckoEnsureCaretVisibility": true
                    }
                };
                break;
            case "removerow":
                this.removeRow(execDef);
                break;
            case "insertcolumn":
                position = execDef.value;
                this.insertCol(execDef, !position || (position == "before"));
                break;
            case "removecolumn":
                this.removeCol(execDef);
                break;
            case "modifycell":
                this.modifyCell(execDef);
                break;
            case "mergecells":
                this.mergeCells(execDef);
                break;
            case "splitcell":
                if (execDef.value == "horizontal") {
                    this.splitCellHorizontally(execDef);
                } else if (execDef.value == "vertical") {
                    this.splitCellVertically(execDef);
                }
                break;
            case "ensureparagraph":
                position = execDef.value;
                this.ensureParagraph(execDef, !position || (position == "before"));
                ret = {
                    "calleeRet": {
                        "geckoEnsureCaretVisibility": true
                    }
                };
                break;
        }
        return ret;
    },

    /**
     * @private
     */
    queryState: function(selectionDef, cmd) {
        var com = CUI.rte.Common;
        var context = selectionDef.editContext;
        if (cmd == "table") {
            return com.getTagInPath(context, selectionDef.nodeList.commonAncestor, "table");
        } else if (cmd == "modifycell") {
            return CUI.rte.commands.Table.getCellFromNodeList(context,
                    selectionDef.nodeList);
        }
        // todo find a meaningful implementation for other commands
        return false;
    }

});

/**
 * Gets the table cell where the current selection resides from the specified processing
 * selection.
 * @param {CUI.rte.EditContext} context The edit context
 * @param {Object} selection The processing selection to get the cell from
 * @return {HTMLElement} The cell corresponding to the processing selection; null if the
 *         selection is not cell-related or spans more than one table cell
 */
CUI.rte.commands.Table.getCellFromSelection = function(context, selection) {
    var com = CUI.rte.Common;
    if (selection.cellSelection && selection.cellSelection.cells) {
        if (selection.cellSelection.cells.length == 1) {
            return selection.cellSelection.cells[0];
        }
        return null;
    }
    var cell = com.getTagInPath(context, selection.startNode, com.TABLE_CELLS);
    if (cell && selection.endNode) {
        var endCell = com.getTagInPath(context, selection.endNode, com.TABLE_CELLS);
        if (endCell != cell) {
            cell = null;
        }
    }
    return cell;
};

/**
 * Gets the table cell that is represented by the specified node list.
 * @param {CUI.rte.EditContext} context The edit context
 * @param {CUI.rte.NodeList} nodeList The node list to get the cell from
 * @return {HTMLElement} The cell corresponding to the node list; null if the
 *         node.list is not cell-related or contains more than one table cell
 */
CUI.rte.commands.Table.getCellFromNodeList = function(context, nodeList) {
    var com = CUI.rte.Common;
    var cell = com.getTagInPath(context, nodeList.commonAncestor, com.TABLE_CELLS);
    // on IE, we might also have a single empty cell node in the list
    if (cell == null) {
        if (nodeList.nodes.length == 1) {
            var dom = nodeList.nodes[0].dom;
            if (com.isTag(dom, com.TABLE_CELLS)) {
                cell = dom;
            }
        }
    }
    return cell;
};

/**
 * Property placeholder for config value "none"
 * @private
 * @static
 * @final
 * @type Object
 */
CUI.rte.commands.Table.CONFIG_NONE = new Object();


// register command
CUI.rte.commands.CommandRegistry.register("table", CUI.rte.commands.Table);
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.commands.Image
 * @extends CUI.rte.commands.Command
 * @private
 */
CUI.rte.commands.Image = new Class({

    toString: "Image",

    extend: CUI.rte.commands.Command,

    createImage: function(execDef) {
        var value = execDef.value;
        var url = null;
        if (value.path) {
            url = CUI.rte.Utils.processUrl(value.path, CUI.rte.Utils.URL_IMAGE);
        }
        var alt = (value.alt ? value.alt : "");
        var width = (value.width ? value.width : null);
        var height = (value.height ? value.height : null);
        // todo encoding(?)
        if (url) {
            var imgHtml = "<img src=\"" + url + "\" alt=\"" + alt + "\"";
            imgHtml += " " + CUI.rte.Common.SRC_ATTRIB + "=\"" + value.path + "\"";
            if (width) {
                imgHtml += " width=\"" + width + "\"";
            }
            if (height) {
                imgHtml += " height=\"" + height + "\"";
            }
            imgHtml += ">";
            execDef.component.execCmd("inserthtml", imgHtml);
        }
    },

    applyProperties: function(execDef) {
        var props = execDef.value;
        var com = CUI.rte.Common;
        var selection = execDef.selection;
        if (selection.startNode && (selection.startOffset == undefined)
                && !selection.endNode) {
            var node = selection.startNode;
            if (!com.isTag(node, "img")) {
                return;
            }
            var stylePrefix = "style.";
            for (var propName in props) {
                if (props.hasOwnProperty(propName)) {
                    if (com.strStartsWith(propName, stylePrefix)) {
                        var styleName =
                                propName.substring(stylePrefix.length, propName.length);
                        if (styleName == "float") {
                            // IE < 9 requires to use node.style.styleFloat http://msdn.microsoft.com/en-us/library/ie/ms530755%28v=vs.85%29.aspx
                            // All other browsers and IE9 or newer allow node.style.cssFloat http://msdn.microsoft.com/en-us/library/ie/ff974668%28v=vs.85%29.aspx
                            if (com.ua.isIE6 || com.ua.isIE7 || com.ua.isIE8) {
                                styleName = "styleFloat";
                            } else {
                                styleName = "cssFloat";
                            }
                        }
                        node.style[styleName] = props[propName];
                    } else {
                        node.setAttribute(propName, props[propName]);
                    }
                }
            }
            if (com.ua.isGecko) {
                CUI.rte.Selection.flushSelection(execDef.editContext);
            }
        }
    },

    isCommand: function(cmdStr) {
        return (cmdStr.toLowerCase() == "insertimg");
    },

    getProcessingOptions: function() {
        var cmd = CUI.rte.commands.Command;
        return cmd.PO_BOOKMARK | cmd.PO_SELECTION;
    },

    execute: function(execDef) {
        switch (execDef.command.toLowerCase()) {
            case "insertimg":
                this.createImage(execDef);
                break;
            case "image":
                this.applyProperties(execDef);
                break;
        }
    },

    queryState: function(selectionDef, cmd) {
        var com = CUI.rte.Common;
        if (cmd.toLowerCase() == "image") {
            var selection = selectionDef.selection;
            if (selection.startNode && (selection.startOffset == undefined)
                    && !selection.endNode) {
                var node = selection.startNode;
                return com.isTag(node, "img");
            }
        }
        return false;
    }

});


// register command
CUI.rte.commands.CommandRegistry.register("image", CUI.rte.commands.Image);
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.commands
 * @private
 * The Command should be implemented by all RTE commands that cannot be handled by the
 * browser's implementation itself.
 */
CUI.rte.commands.UndoRedo = new Class({

    toString: "UndoRedo",

    extend: CUI.rte.commands.Command,

    /**
     * The undo manager object for this RichText instance
     * @private
     */
    undoManager: null,

    construct: function() {
        this.undoManager = new CUI.rte.UndoManager(50);
    },

    isCommand: function(cmdStr) {
        var cmdLC = cmdStr.toLowerCase();
        return (cmdLC == "undo") || (cmdLC == "redo") || (cmdLC == "undoconfig")
                || (cmdLC == "initializeundo") || (cmdLC == "addundostep")
                || (cmdLC == "clearredohistory");
    },

    isUndoable: function(cmdStr) {
        return false;
    },

    requiresInitializedComponent: function(cmdStr) {
        return (cmdStr != "undoconfig");
    },

    getProcessingOptions: function() {
        return CUI.rte.commands.Command.PO_NONE;
    },

    execute: function(execDef) {
        var cmdLC = execDef.command.toLowerCase();
        var context = execDef.editContext;
        switch (cmdLC) {
            case "undo":
                this.undoManager.undo(context);
                break;
            case "redo":
                this.undoManager.redo(context);
                break;
            case "undoconfig":
                if (execDef.value.maxUndoSteps != undefined) {
                    this.undoManager.maxUndoSteps = execDef.value.maxUndoSteps;
                }
                break;
            case "initializeundo":
                this.undoManager.initialize(context);
                break;
            case "addundostep":
                this.undoManager.addStep(new CUI.rte.UndoManager.Step(context));
                break;
            case "clearredohistory":
                this.undoManager.clearRedoHistory();
                break;
        }
    },

    queryState: function(selectionDef, cmd) {
        var cmdLC = cmd.toLowerCase();
        var state = false;
        switch (cmdLC) {
            case "undo":
                state = this.undoManager.canUndo();
                break;
            case "redo":
                state = this.undoManager.canRedo();
                break;
        }
        return state;
    }

});


// register command
CUI.rte.commands.CommandRegistry.register("undoredo", CUI.rte.commands.UndoRedo);
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.plugins.Plugin
 * <p>This class works as an interface and hence must be extended by all plugin
 * implementations.</p>
 * <p>Each plugin may provide one or more "features", that represent the actual editing
 * action and usually map 1:1 to a UI element (for example, a toolbar button or a context
 * menu entry).</p>
 * <p>Plugins should not be instantiated directly, but registred with
 * {@link CUI.rte.plugins.PluginRegistry} for implicit instantiation.</p>
 * @constructor
 * Creates a new Plugin.
 * @param {CUI.rte.EditorKernel} editorKernel The editor kernel the plugin is used by
 */
CUI.rte.plugins.Plugin = new Class({

    /**
     * @cfg {String/String[]} features
     * Defines which features of the plugin are activated. You may provide a String
     * value of "*" to enable all features of the respective plugin, or provide a String[]
     * that contains the IDs of active features. Features and their IDs are documented
     * at the corresponding plugin class. A String value of "-" can be used to explicitly
     * deactivate all features of the plugin.
     */
    features: null,

    /**
     * @property {String} pluginId
     * @since 5.6
     * The plugin ID
     */
    pluginId: null,

    /**
     * Back reference to the editor kernel the plugin is used from
     * @type CUI.rte.EditorKernel
     * @private
     */
    editorKernel: null,

    config: null,

    isFeatureEnabled: function(feature) {
        if (!this.config || !this.config.features || (this.config.features == '-')) {
            return false;
        }
        if (this.config.features === "*") {
            return true;
        }
        var featCnt = this.config.features.length;
        for (var featIndex = 0; featIndex < featCnt; featIndex++) {
            var featureToCheck = this.config.features[featIndex];
            if (featureToCheck == feature) {
                return true;
            }
        }
        return false;
    },

    construct: function(editorKernel, pluginId) {
        this._init(editorKernel, pluginId);
    },

    _init: function(editorKernel, pluginId) {
        this.editorKernel = editorKernel;
        this.pluginId = pluginId;
    },

    getFeatures: function() {
        // must be overridden by implementing plugins
        return [ ];
    },

    reportStyles: function() {
        return null;
    },

    notifyPluginConfig: function(pluginConfig) {
        this.config = pluginConfig;
    },

    initializeUI: function(tbGenerator) {
        // must be overridden by implementing plugins
    },

    execute: function(pluginCommand, value, envOptions) {
        // must be overridden by implementing plugins
    },

    updateState: function(selDef) {
        // must be overridden by implementing plugins
    },

    handleContextMenu: function(menuBuilder, selDef, context) {
        // may be overridden by implementing plugins if context menu access is required
    },

    manipulateSelection: function(selectionDef) {
        // may be overridden by implementing plugins if manipulating a selection before
        // applying a command/evaluating a selection's state is required
    },

    saveRangeBookmark: function(rangeBookmark) {
        // may be overridden by implementing plugins if saving additional data to a range
        // bookamrk is required
    },

    restoreRangeBookmark: function(rangeBookmark) {
        // may be overridden by implementing plugins if restoring additional data from a
        // range bookamrk is required
    },

    interceptContent: function(contentType, defs) {
        // may be overridden by implementing plugins if they have to modify/intercept
        // HTML code creation at certain points of processing
        return null;
    },

    getTooltip: function(command) {
        return (this.config.tooltips ? this.config.tooltips[command] : null)
    }

});

/**
 * Default sort index for table controls in table edit mode
 * @static
 * @final
 * @type Number
 * @private
 */
CUI.rte.plugins.Plugin.SORT_TABLE_TABLEMODE = 0;

/**
 * Default sort index for edit tools (cut, copy, paste)
 * @private
 * @static
 * @final
 * @type Number
 */
CUI.rte.plugins.Plugin.SORT_EDIT = 110;

/**
 * Default sort index for undo/redo
 * @private
 * @static
 * @final
 * @type Number
 */
CUI.rte.plugins.Plugin.SORT_UNDO = 120;

/**
 * Default sort index for format tools (bold, italic, underlined)
 * @private
 * @static
 * @final
 * @type Number
 */
CUI.rte.plugins.Plugin.SORT_FORMAT = 130;

/**
 * Default sort index for justification (left, center, right)
 * @private
 * @static
 * @final
 * @type Number
 */
CUI.rte.plugins.Plugin.SORT_JUSTIFY = 140;

/**
 * Default sort index for link controls
 * @private
 * @static
 * @final
 * @type Number
 */
CUI.rte.plugins.Plugin.SORT_LINKS = 150;

/**
 * Default sort index for list controls
 * @private
 * @static
 * @final
 * @type Number
 */
CUI.rte.plugins.Plugin.SORT_LISTS = 160;

/**
 * Default sort index for image controls
 * @private
 * @static
 * @final
 * @type Number
 */
CUI.rte.plugins.Plugin.SORT_IMAGE = 170;

/**
 * Default sort index for table controls
 * @static
 * @final
 * @type Number
 * @private
 */
CUI.rte.plugins.Plugin.SORT_TABLE = 180;

/**
 * Default sort index for styles
 * @private
 * @static
 * @final
 * @type Number
 */
CUI.rte.plugins.Plugin.SORT_STYLES = 350;

/**
 * Default sort index for paragraph formats
 * @private
 * @static
 * @final
 * @type Number
 */
CUI.rte.plugins.Plugin.SORT_PARAFORMAT = 360;

/**
 * Default sort index for the spellchecker
 * @private
 * @static
 * @final
 * @type Number
 */
CUI.rte.plugins.Plugin.SORT_SPELLCHECK = 370;

/**
 * Default sort index for misc tools
 * @private
 * @static
 * @final
 * @type Number
 */
CUI.rte.plugins.Plugin.SORT_MISC = 1000;
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.plugins.PluginRegistry
 * This class is used to manage plugins available for rich text editing. Each plugin has a
 * respective identifier by which it can be referenced.
 * @private
 * @since 5.3
 */
CUI.rte.plugins.PluginRegistry = function() {

    var pluginRegistry = { };

    return {

        /**
         * Registers the specified class as a rich text editing plugin.
         * @param {String} pluginId The plugin ID
         * @param {Function} cls The plugin class (must implement
         *        {@link CUI.rte.plugins.Plugin})
         */
        register: function(pluginId, cls) {
            pluginRegistry[pluginId] = cls;
        },

        /**
         * <p>Creates an associatve array, containing instances of all currently registered
         * plugins.</p>
         * <p>The created object may be used by a single {@link CUI.rte.EditorKernel}
         * instance.</p>
         * @param {CUI.rte.EditorKernel} editorKernel The EditorKernel the plugins are
         *        used by
         * @return {Object} Instantiated plugins
         */
        createRegisteredPlugins: function(editorKernel) {
            var registeredPlugins = { };
            for (var pluginId in pluginRegistry) {
                if (pluginRegistry.hasOwnProperty(pluginId)) {
                    var plugin = new pluginRegistry[pluginId](editorKernel, pluginId);
                    plugin = CUI.rte.Utils.onPluginCreated(plugin);
                    registeredPlugins[pluginId] = plugin;
                }
            }
            return registeredPlugins;
        }

    };

}();
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * <p>This class is used for dispatching plugin-related events, mostly used for
 * communications between editor core and plugins.</p>
 * <p>For example, a widget implementation (such as CUI.rte.RichText) may request
 * the source view from a "suitable" plugin (= a plugin that feels resposible for
 * the respective event type) by sending a "sourceedit" event.
 * @class CUI.rte.plugins.PluginEvent
 */
CUI.rte.plugins.PluginEvent = new Class({

    toString: "PluginEvent",

    /**
     * @private
     */
    type: null,

    /**
     * @property editContext
     */
    editContext: null,

    construct: function(type, editContext, params) {
        params = params || { };
        this.type = type;
        this.editContext = editContext;
        CUI.rte.Utils.apply(this, params);
    },

    getType: function() {
        return this.type;
    }

});
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.plugins.KeyPlugin
 * @extends CUI.rte.plugins.Plugin
 * <p>This class implements the basic key handling as a plugin.</p>
 * <p>The plugin ID is "<b>keys</b>".</p>
 * <p><b>Features</b></p>
 * <p>This plugin has no features, as it processes keystrokes globally.</p>
 * @since 5.3
 */

CUI.rte.plugins.KeyPlugin = new Class({

    toString: "KeyPlugin",

    extend: CUI.rte.plugins.Plugin,

    /**
     * @cfg {Number} tabSize
     * Number of &amp;nbsp;-s to be inserted if the tab key is hit (defaults to 4). Note
     * that the tab key works as a navigation aid when used inside a table, so this option
     * will only take effect outside a table.
     */

    /**
     * @private
     */
    mustEnsureBlocks: false,

    /**
     * @private
     */
    mustHandleAdditionalBR: false,

    /**
     * @private
     */
    _init: function(editorKernel) {
        this.inherited(arguments);
        editorKernel.addPluginListener("beforekeydown", this.handleKeyDown, this, this,
                false);
        editorKernel.addPluginListener("keyup", this.handleKeyUp, this, this,
                false);
    },

    /**
     * @private
     */
    isEOB: function(context, selection) {
        var nodeToCheck, offsetToCheck;
        if (CUI.rte.Selection.isSelection(selection)) {
            nodeToCheck = selection.endNode;
            offsetToCheck = selection.endOffset;
        } else {
            nodeToCheck = selection.startNode;
            offsetToCheck = selection.startOffset;
        }
        return CUI.rte.DomProcessor.isBlockEnd(context, nodeToCheck, offsetToCheck);
    },

    /**
     * @private
     */
    isTempBR: function(br) {
        var com = CUI.rte.Common;
        return (com.isAttribDefined(br, com.BR_TEMP_ATTRIB)
                || (com.isAttribDefined(br, "type")
                    && (com.getAttribute(br, "type", false) == "_moz")));
    },

    /**
     * Handles key strokes.
     * @param {Object} e The plugin event
     * @private
     */
    handleKeyDown: function(e) {

        if (e.cancelKey) {
            return;
        }

        var context = e.editContext;
        var dpr = CUI.rte.DomProcessor;
        var sel = CUI.rte.Selection;
        var com = CUI.rte.Common;
        var lut = CUI.rte.ListUtils;
        var ek = this.editorKernel;

        // IE allows invalid caret positions - we cancel key strokes other than caret keys
        // if this is the case
        var selection = (com.ua.isIE ? ek.createQualifiedSelection(context) : null);
        if (com.ua.isIE && !selection) {
            if (!e.isCaretKey()) {
                e.cancelKey = true;
            }
            return;
        }

        function ensureSelection() {
            if (selection == null) {
                selection = ek.createQualifiedSelection(context);
            }
            return selection;
        }

        var cancelKey = false;

        // handle TAB key
        if (e.isTab()) {
            var tabStr = "";
            var tabSize = this.config.tabSize;
            for (var nbsp = 0; nbsp < tabSize; nbsp++) {
                tabStr += "&nbsp;";
            }
            ek.execCmd("InsertHTML", tabStr);
            cancelKey = true;
        }

        // handle Space key - current Gecko releases insert an additional <br> if a space
        // is inserted at the end of an edit block
        this.mustHandleAdditionalBR = false;
        if (com.ua.isGecko && (e.isSpace() || e.isBackSpace())) {
            selection = ensureSelection();
            if (this.isEOB(context, selection)) {
                this.mustHandleAdditionalBR = true;
            }
        }

        // handle ENTER key
        this.mustEnsureBlocks = false;
        if (e.isEnter() && !cancelKey) {
            if (!e.isShift()) {
                var useBrowserCmd = false;
                var isBeforeNestedList = false;
                try {
                    selection = ensureSelection();
                    if (sel.isSelection(selection)) {
                        CUI.rte.commands.executeDelete(context);
                    }
                    selection = ek.createQualifiedSelection(context);
                    var node = selection.startNode;
                    var offset = selection.startOffset;
                    var editBlock = dpr.getEditBlock(context, node);
                    var nestedLists;
                    if (com.isTag(editBlock, "li")) {
                        useBrowserCmd = true;
                        // corner case: inserting at the last character of a parent item
                        // in a nested list must be handled differently for Gecko browsers
                        // (bug #37580)
                        nestedLists = lut.getNestedLists(editBlock);
                        if (com.ua.isGecko) {
                            isBeforeNestedList = lut.isPositionBeforeNestedList(context,
                                    node, offset);
                            useBrowserCmd = !isBeforeNestedList;
                        }
                    }
                    if (!useBrowserCmd) {
                        var para = dpr.insertParagraph(context, node, offset);
                        if (isBeforeNestedList) {
                            var placeholder = dpr.createGeckoPlaceholder(context);
                            com.insertBefore(para, placeholder, nestedLists[0]);
                        }
                        var nodeToSelect;
                        if (com.ua.isGecko) {
                            nodeToSelect = com.getFirstChild(para);
                            if (!nodeToSelect) {
                                nodeToSelect = para;
                            } else if (nodeToSelect.nodeType == 3) {
                                nodeToSelect = nodeToSelect.parentNode;
                            }
                        } else {
                            nodeToSelect = para;
                        }
                        sel.selectNode(context, nodeToSelect, true);
                        // both Gecko, Webkit and IE/W3C-compliant don't change the scroll
                        // offset accordingly, so we must do it on our own
                        if (!com.isOldIE && context.iFrame) {
                            // as we don't support complex layouts yet, this simple
                            // calculation is currently enough
                            var scrollTop = context.root.scrollTop;
                            var iframeHeight = context.iFrame.clientHeight;
                            var paraTop = para.offsetTop;
                            var paraHeight = para.clientHeight;
                            var scrollBottom = scrollTop + iframeHeight;
                            var paraBottom = paraTop + paraHeight;
                            if (paraBottom > scrollBottom) {
                                context.root.scrollTop = paraBottom - iframeHeight;
                            }
                        }
                        cancelKey = true;
                    }
                } catch (e) {
                    // window.console.log("Error: " + e);
                    // com.ieLog("Error: " + e.message, true);
                    // if we cannot insert a paragraph, use browser's ENTER handling instead
                    useBrowserCmd = true;
                }
                if (useBrowserCmd) {
                    if (com.ua.isGecko) {
                        // Workaround for Gecko bug that always inserts lines instead of
                        // paragraphs when for example a list is finished by pressing
                        // Enter on an empty list item
                        this.mustEnsureBlocks = true;
                    }
                }
            } else if (com.ua.isWebKit || com.ua.isGecko) {
                // handle Shift + Enter for WebKit & Gecko
                selection = ensureSelection();
                if (sel.isSelection(selection)) {
                    CUI.rte.commands.executeDelete(context);
                }
                selection = ek.createQualifiedSelection(context);
                var selNode = selection.startNode;
                var selOffs = selection.startOffset;
                var newBr = context.createElement("br");
                var caretPos = sel.getCaretPos(context);
                if (dpr.isBlockEnd(context, selNode, selOffs)
                        && !dpr.isEmptyLineDeterminator(context, selNode)) {
                    var helperBr = context.createElement("br");
                    com.setAttribute(helperBr, com.BR_TEMP_ATTRIB, "brEOB");
                    dpr.insertElement(context, helperBr, selNode, selOffs);
                    dpr.insertElement(context, newBr, selNode, selOffs);
                } else {
                    dpr.insertElement(context, newBr, selNode, selOffs);
                }
                var afterBr = com.getNextCharacterNode(context, newBr);
                if (afterBr.nodeType == 1) {
                    sel.selectNode(context, afterBr, true);
                } else {
                    sel.setCaretPos(context, caretPos + 1);
                }
                cancelKey = true;
            }
        }

        // pre-handle auxiliary roots
        this.auxRootParaNodeCnt = 0;
        if ((e.isBackSpace() || e.isDelete()) && !cancelKey) {
            selection = ensureSelection();
            if (com.ua.isOldIE) { // this is just necessary for IE < 9
                // handle deletion of empty lines before tables
                var emptyLineNode = dpr.getEmptyLine(context, selection);
                if ((emptyLineNode != null) && !com.isTag(emptyLineNode, com.TABLE_CELLS)) {
                    var pos = sel.getCaretPos(context);
                    emptyLineNode.parentNode.removeChild(emptyLineNode);
                    if (e.isBackSpace() && (pos > 0)) {
                        pos--;
                        sel.setCaretPos(context, pos);
                    }
                    cancelKey = true;
                }
            }
            var nodeList = dpr.createNodeList(context, selection);
            var auxRoot = com.getTagInPath(context, nodeList.commonAncestor,
                    dpr.AUXILIARY_ROOT_TAGS);
            if (auxRoot) {
                this.auxRootParaNodeCnt = com.getChildNodesByType(auxRoot, "p").length;
            }
        }

        this.preventAutoLinks = (!cancelKey && com.ua.isIE);
        e.cancelKey = cancelKey;
    },

    /**
     * Handles post-processing required for all browsers. The method is called whenever a
     * key has been pressed.
     * @param {Object} event The plugin event
     * @private
     */
    handleKeyUp: function(e) {

        var sel = CUI.rte.Selection;
        var com = CUI.rte.Common;
        var dpr = CUI.rte.DomProcessor;
        var context = e.editContext;
        var node, selection;

        // handle Gecko/Webkit <br>-placeholders
        if (com.ua.isGecko || com.ua.isWebKit) {
            this.handleBRPlaceholders(context);
        }

        // handle IE autolinks if necessary
        if (this.preventAutoLinks) {
            this.handleIEAutoLinks(context);
            this.preventAutoLinks = false;
        }

        // handle "absolutely empty" content
        dpr.ensureMinimumContent(context);
        if (this.mustEnsureBlocks) {
            // workaround for Gecko bug/inconsistency; see handleKeys
            selection = sel.getSelection(context);
            if (selection.focusNode && (selection.focusNode.nodeType == 1)) {
                node = selection.focusNode.childNodes[selection.focusOffset];
                if (com.isRootNode(context, node.parentNode) && com.isTag(node, "br")) {
                    var pNode = dpr.insertAsParent(context, node, "p", null);
                    sel.selectNode(context, pNode, true);
                }
            }
        }

        // handle Gecko's (mis-) behaviour of adding additional br's after inserting a
        // space at the end of an edit block
        var fn, nextNode;
        if (this.mustHandleAdditionalBR) {
            selection = sel.getSelection(context);
            fn = selection.focusNode;
            if (fn) {
                nextNode = fn.nextSibling;
                if (com.isTag(nextNode, "br")) {
                    com.setAttribute(nextNode, com.BR_TEMP_ATTRIB, "brEOB");
                }
            }
        } else if (e.isDelete()) {
            selection = sel.getSelection(context);
            fn = selection.focusNode;
            if (fn && (fn.nodeType == 3)) {
                var text = fn.nodeValue;
                var isSpaceDelimited = (text.length > 0
                        ? (text.charAt(text.length - 1) == " ") : false);
                if (isSpaceDelimited) {
                    nextNode = fn.nextSibling;
                    if (com.isTag(nextNode, "br")
                            && dpr.isBlockEnd(context, nextNode, null)) {
                        com.setAttribute(nextNode, com.BR_TEMP_ATTRIB, "brEOB");
                    }
                }
            }
        }

        if (e.isBackSpace() || e.isDelete()) {
            if (com.ua.isIE) {
                // Yet another IE bug: if the last character of a styled area is deleted,
                // IE stores the physical style internally and inserts all characters
                // typed with that physical style (but not the span we actually need).
                // So we're trying to flush this internal buffer by moving the caret forward
                // and backwards
                try {
                    var range = sel.getLeadRange(context);
                    var oldRange = range.duplicate();
                    if (range.move("character", 1) == 1) {
                        sel.selectRange(context, range);
                    } else if (range.move("character", -1) == -1) {
                        sel.selectRange(context, range);
                    }
                    sel.selectRange(context, oldRange);
                } catch (ex) {
                    // might fail, if for example an EOB anchor is tried being deleted using
                    // backspace (which won't work at all on IE); just ignore this
                }
            }
            // handle auxiliary block roots
            selection = this.editorKernel.createQualifiedSelection(context);
            if (selection && !sel.isSelection(selection)) {
                node = selection.startNode;
                var scopedBlock = dpr.getScopedBlockNode(context, node);
                if (scopedBlock) {
                    if (!scopedBlock.isAuxiliaryRoot) {
                        var blockParent = scopedBlock.dom.parentNode;
                        if (com.isTag(blockParent, dpr.AUXILIARY_ROOT_TAGS)) {
                            var parentParaNodes = com.getChildNodesByType(blockParent, "p");
                            var parentParaNodeCnt = parentParaNodes.length;
                            if ((parentParaNodeCnt == 1)
                                    && (parentParaNodeCnt < this.auxRootParaNodeCnt)) {
                                var blockNode = parentParaNodes[0];
                                // preserve indents & text alignments
                                if (!blockNode.style.textAlign
                                        && !blockNode.style.marginLeft) {
                                    var bookmark;
                                    if (com.ua.isIE) {
                                        bookmark = sel.createSelectionBookmark(context);
                                    }
                                    dpr.removeWithoutChildren(blockNode);
                                    if (com.ua.isIE) {
                                        sel.selectBookmark(context, bookmark);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    },

    /**
     * <p>Handles post-processing required for preventing automatically generated links
     * by IE.</p>
     * @private
     */
    handleIEAutoLinks: function(context) {
        var com = CUI.rte.Common;
        // remove all links that don't have a _rte_href attribute
        var aTags = context.root.getElementsByTagName("A");
        var aCnt = aTags.length;
        for (var a = aCnt - 1; a >= 0; a--) {
            var anchor = aTags[a];
            if (com.isAttribDefined(anchor, "href")
                    && !com.isAttribDefined(anchor, CUI.rte.Common.HREF_ATTRIB)) {
                CUI.rte.DomProcessor.removeWithoutChildren(anchor);
            }
        }
    },

    /**
     * <p>Handles &lt;br&gt; placeholders for empty lines.</p>
     * <p>Those placeholders get inserted on Shift+Enter and will either removed in this
     * method if it is not necessary anymore because there was content inserted before or
     * the placeholder marker is removed if there is another br placeholder found
     * directly after the existing placeholder &lt;br&gt;.</p>
     * @private
     */
    handleBRPlaceholders: function(context) {
        var com = CUI.rte.Common;
        var brTags = context.root.getElementsByTagName("BR");
        var brCnt = brTags.length;
        for (var i = 0; i < brCnt; i++) {
            var brToCheck = brTags[i];
            if (this.isTempBR(brToCheck)) {
                var prevCharNode = com.getPreviousCharacterNode(context, brToCheck,
                        com.EDITBLOCK_TAGS);
                var nextCharNode = com.getNextCharacterNode(context, brToCheck,
                            com.EDITBLOCK_TAGS);
                if (!com.isTag(prevCharNode, "br")
                        && (prevCharNode != null) || (nextCharNode != null)) {
                    // additional case: keep if previous character node ends with a space
                    var prevNodeText = com.getNodeText(prevCharNode);
                    var prevNodeLen = prevNodeText.length;
                    var lastChar = (prevNodeLen > 0 ? prevNodeText.charAt(prevNodeLen - 1)
                            : "");
                    if (lastChar != " ") {
                        brToCheck.parentNode.removeChild(brToCheck);
                    }
                } else {
                    if (this.isTempBR(nextCharNode)) {
                        com.removeAttribute(brToCheck, com.BR_TEMP_ATTRIB);
                    }
                }
            }
        }
    },


    notifyPluginConfig: function(pluginConfig) {
        pluginConfig = pluginConfig || { };
        CUI.rte.Utils.applyDefaults(pluginConfig, {
            "tabSize": 4
        });
        this.config = pluginConfig;
    }

});


// register plugin
CUI.rte.plugins.PluginRegistry.register("keys", CUI.rte.plugins.KeyPlugin);
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.plugins.SimpleFormatPlugin
 * @extends CUI.rte.plugins.Plugin
 * This class provides the plugin functionality that is required by simple formatting
 * operations.
 */
CUI.rte.plugins.SimpleFormatPlugin = new Class({

    toString: "SimpleFormatPlugin",

    extend: CUI.rte.plugins.Plugin,

    /**
     * @private
     */
    commands: null,

    /**
     * @private
     */
    commandsUI: null,

    /**
     * @private
     */
    groupDef: null,

    getFeatures: function() {
        return this.commands;
    },

    _init: function(editorKernel, groupId, groupSort, commands) {
        this.inherited(arguments);
        this.groupDef = {
            "id": groupId,
            "sort": groupSort
        };
        this.commands = commands;
    },

    initializeUI: function(tbGenerator) {
        this.commandsUI = [ ];
        var cmdCnt = this.commands.length;
        for (var cmdIndex = 0; cmdIndex < cmdCnt; cmdIndex++) {
            var command = this.commands[cmdIndex];
            var shortcut = null;
            if (typeof(command) == "object") {
                shortcut = command.shortcut;
                command = command.command;
                this.commands[cmdIndex] = command;
            }
            if (this.isFeatureEnabled(command)) {
                var commandDef = tbGenerator.createElement(command, this, true,
                        this.getTooltip(command));
                this.commandsUI.push(commandDef);
                tbGenerator.addElement(this.groupDef.id, this.groupDef.sort, commandDef,
                        (cmdIndex + 1) * 10);
                if (shortcut) {
                    this.editorKernel.registerKeyboardShortcut(shortcut, command);
                }
            }
        }
    },

    execute: function(id) {
        this.editorKernel.relayCmd(id);
    },

    updateState: function(selectionDef) {
        var cmdCnt = this.commandsUI.length;
        for (var cmdIndex = 0; cmdIndex < cmdCnt; cmdIndex++) {
            var command = this.commandsUI[cmdIndex];
            command.setSelected(this.editorKernel.queryState(command.id, selectionDef));
        }
    }

});
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.plugins.EditToolsPlugin
 * @extends CUI.rte.plugins.Plugin
 * <p>This class implements the basic editing functions (cut, copy, paste) as a plugin.</p>
 * <p>The plugin ID is "<b>edit</b>".</p>
 * <p><b>Features</b></p>
 * <ul>
 *   <li><b>cut</b> - adds the "cut" button</li>
 *   <li><b>copy</b> - adds the "copy" button</li>
 *   <li><b>paste-default</b> - adds a button that allows pasting using the default paste
 *     behaviour (see {@link #defaultPasteMode})</li>
 *   <li><b>paste-plaintext</b> - adds a button that allows pasting the clipboard content
 *     as plain text</li>
 *   <li><b>paste-wordhtml</b> - adds a button that allows pasting HTML-based content. Note
 *     that the HTML will be cleaned before inserting. This method is compatible with
 *     pasting content from Microsoft Word.</li>
 * </ul>
 */
CUI.rte.plugins.EditToolsPlugin = new Class({

    toString: "EditToolsPlugin",

    extend: CUI.rte.plugins.Plugin,

    /**
     * @cfg {String} defaultPasteMode
     * <p>Default mode when pasting is executed using the Ctrl + V key or the main paste
     * button (defaults to "wordhtml").</p>
     * <p>Valid values are:</p>
     * <ul>
     *   <li>"browser" - use browser's paste implementation (should usually not be used, as
     *     this may introduce unwanted markup or markup that could cause the RichText
     *     component to crash);</li>
     *   <li>"plaintext" - for plain text inserts;</li>
     *   <li>"wordhtml" - for Word-compatible HTML pasting (this should suffice for most
     *     use cases, as it will keep most of the formatting, but removes unsuitable
     *     tags and attributes.</li>
     * </ul>
     * @since 5.3
     */

    /**
     * @cfg {Boolean} stripHtmlTags
     * <p>True if HTML tags should be stripped off before inserting it on paste (defaults to
     * true).</p>
     * <p>The use-case for this option is a bit hard to explain: The system clipboard works
     * MIME type-based. If you select text from a web page directly, the clipboard will
     * usually contain a text/plain and a text/html variant of the selected text. The plain
     * text variant will contain no HTML tags at all, the text/html variant will contain
     * HTML as we would expect it. On the other hand, if you copy HTML code from any
     * source view, you will get at least get a text/plain variant, containing all tags.
     * In some cases (for example if you are using Firefox' "View source"), you will get
     * an additional text/html variant, that will contain the HTML-tags in an entitiy
     * encoded way (&amp;lt;b&amp;gt;bold text&amp;lt;/b&amp;gt;). On paste, the browser
     * will paste the text/html variant if available, the text/plain variant otherwise.
     * Given the second use-case, the HTML tags will appear in the pasted content, as
     * they get either entity encoded by the browser (text/plain) or are already
     * entity-encoded (text/html) on paste. This is where this option kicks in: By setting
     * it to true, the HTML tags from such a source code paste get removed before the
     * pasted content is inserted in the text being edited.</p>
     * <p>Note that this optiion will only work if {@link #defaultPasteMode} is set to
     * "plaintext".</p>
     * @since 5.3
     */

    /**
     * @cfg {Object} htmlPasteRules
     * <p>Defines rules to be applied to HTML code when pasting in wordhtml mode.</p>
     * <ul>
     *   <li><code>allowBasics</code> : Object<br>
     *     Defines basic elements to be allowed. Elements are defined as boolean
     *     properties. Available property names are:
     *     <ul>
     *       <li>"bold"</li>
     *       <li>"italic"</li>
     *       <li>"underline"</li>
     *       <li>"subscript"</li>
     *       <li>"suprscript"</li>
     *       <li>"anchor" (for the a tag in common, e.g. links and named anchors)</li>
     *       <li>"image"</li>
     *     </ul>
     *   </li>
     *   <li><code>allowBlockTags</code> : String[]<br>
     *     Defines a list of all allowed block tags. Block tags are headlines (h1, h2, h3),
     *     paragraphs (p), lists (ol, ul), tables (table) and so on (see DTD for details).
     *     </li>
     *   <li><code>allowedAttributes</code> : Object<br>
     *     Added in CQ 5.4<br>
     *     Defines valid attributes for each (or all) elements of pasted content. Only valid
     *     if {@link #prepareHtmlPaste} is used. Defaults to:
 <pre><code>
  {
     "*": [
         "class"
     ],
     "table": [
         "width", "height", "cellspacing", "cellpadding", "border",
     ],
     "td": [
         "width", "height", "colspan", "rowspan"
     ]
 }
 </code></pre></li>
     *   <li><code>fallbackBlockTag</code> : String<br>
     *     Defines the block tag that is used for blocks that use a block tag that is not
     *     included in allowBlockTags. "p" should suffice in most cases.</li>
     *   <li><code>table</code> : Object<br>
     *     Defines the behaviour for tables. The following properties must be set:
     *     <ul>
     *       <li><code>allow</code> : Boolean<br>
     *         True if tables are allowed for pasting.</li>
     *       <li><code>ignoreMode</code> : String<br>
     *         If allow is set to false, this property defines how to handle table content.
     *         Valid values for ignoreMode are:
     *         <ul>
     *           <li>"remove" - removes table content</li>
     *           <li>"paragraph" - turns table cells into paragraphs</li>
     *         </ul>
     *       </li>
     *     </ul>
     *   </li>
     *   <li><code>list</code> : Object<br>
     *     Defines the behaviour for lists. The following properties must be set:
     *     <ul>
     *       <li><code>allow</code> : Boolean<br>
     *         True if lists are allowed for pasting.</li>
     *       <li><code>ignoreMode</code> : String<br>
     *         If allow is set to false, this property defines how to handle list content.
     *         Valid values for ignoreMode are:
     *         <ul>
     *           <li>"remove" - removes list content</li>
     *           <li>"paragraph" - turns list items into paragraphs</li>
     *         </ul>
     *       </li>
     *     </ul>
     *   </li>
     *   <li><code>cssMode</code> : String<br>
     *     Defines how to cope with CSS classes. Valid values are:
     *     <ul>
     *       <li>"keep" - keep all CSS classes "as they are". Note that you might get
     *         unwanted results when pasting from external sources/websites</li>
     *       <li>"remove" - (default) remove all CSS classes</li>
     *       <li>"whitelist" - keep all CSS classes that are whitelisted through
     *         {@link #allowedCssNames}, remove all others.</li>
     *     </ul>
     *   </li>
     *   <li><code>allowedCssNames</code> : String[]<br>
     *     A list of all allowed CSS class names. Only used if cssMode == "whitelist".</li>
     *   <li><code>linkRemoveRegEx</code> : String<br>
     *     A regular expression that defines links that have to be removed. Defaults to
     *     null</li>
     *   <li><code>removeHandlers</code> : Boolean<br>
     *     Determines if handlers (as defined by handlersToRemove) should be
     *     removed from pasted HTML. Defaults to true.</li>
     *   <li><code>handlersToRemove</code> : String[]<br>
     *     Array that contains all handlers to be removed. Defaults to [
     *     "onabort", "onblur", "onchange", "onclick", "ondblclick", "onerror",
     *     "onfocus", "onkeydown", "onkeypress", "onkeyup", "onload", "onmousedown",
     *     "onmousemove", "onmouseout", "onmouseover", "onmouseup", "onreset",
     *     "onselect", "submit", "onunload" ]</li>
     * </ul>
     * @since 5.3
     */

    /**
     * Flag that determines if a paste operation is currently active.
     * @private
     * @type Boolean
     */
    isPasteOperation: false,

    /**
     * The paste range as a bookmark
     * @type Object
     * @private
     */
    pasteRange: null,

    /**
     * The hidden DIV that used to receive the clipboard data
     * @type HTMLElement
     * @private
     */
    clipboard: null,

    /**
     * Value that determines the preferred scrolling offset (Gecko only, for ensuring
     * caret visibility through {@link CUI.rte.Selection#ensureCaretVisibility}
     * @type Number
     * @private
     */
    geckoPreferredScrollingOffset: null,

    /**
     * @private
     */
    cutUI: null,

    /**
     * @private
     */
    copyUI: null,

    /**
     * @private
     */
    pasteDefaultUI: null,

    /**
     * @private
     */
    pastePlainTextUI: null,

    /**
     * @private
     */
    pasteAsWordUI: null,

    /**
     * @private
     */
    pasteDefaultDialog: null,

    /**
     * @private
     */
    pastePlainTextDialog: null,

    /**
     * @private
     */
    pasteWordHtmlDialog: null,

    _init: function(editorKernel) {
        this.inherited(arguments);
        if (!CUI.rte.Common.ua.isWebKit) {
            editorKernel.addPluginListener("beforekeydown", this.handleKeyDown, this, this,
                    false);
        } else {
            editorKernel.addPluginListener("paste", this.handlePaste, this, this, false);
        }
    },

    handleKeyDown: function(e) {
        if (e.cancelKey) {
            return;
        }
        var com = CUI.rte.Common;
        var key = e.getKey();
        if (this.config.defaultPasteMode != "browser") {
            var isPasteKey = false;
            if (com.ua.isMac) {
                isPasteKey = (e.isMeta() && (e.getCharCode() == 118))
                    || (e.isCtrl() && (key == 86));
            } else {
                isPasteKey = (e.isCtrl() && (key == 86))
                    || (e.isShift() && (key == 45));
            }
            if (isPasteKey) {
                this.beforePaste(e.editContext);
            }
        }
    },

    handlePaste: function(e) {
        if (this.config.defaultPasteMode != "browser") {
            this.beforePaste(e.editContext);
        }
    },

    /**
     * <p>Handler that is called when the paste shortcut is hit ("keydown" event) when
     * tags should get stripped from the pasted content.</p>
     * <p>It transfers the focus to a hidden div where pasting actually occurs. The pasted
     * string is later read and inserted in the actual content component (see
     * {@link #afterPaste}).</p>
     * @private
     */
    beforePaste: function(context) {

        if (this.isPasteOperation) {
            return;
        }

        var com = CUI.rte.Common;

        this.isPasteOperation = true;
        this.pasteRange = this.editorKernel.createQualifiedRangeBookmark(context);

        // can't use Ext functionality here, as it doesn't work correctly with the document
        // object of the iframe.
        this.clipboard = context.createElement("div");
        this.clipboard.style.position = "absolute";
        this.clipboard.style.left = "-10000px";
        this.clipboard.style.width = "9000px";
        this.clipboard.style.top = "0px";
        context.root.appendChild(this.clipboard);
        this.clipboard.appendChild(context.createElement("br"));

        var clipRange;
        if (com.ua.isOldIE) {
            clipRange = context.doc.selection.createRange();
            //force ie to calculate clipRange
            var w = clipRange.boundingWidth;
            clipRange.moveToElementText(this.clipboard);
            clipRange.select();
        } else {
            this.geckoPreferredScrollingOffset =
                    CUI.rte.Selection.getPreferredScrollOffset(context);
            clipRange = context.doc.createRange();
            clipRange.selectNodeContents(this.clipboard);
            var sel = context.win.getSelection();
            sel.removeAllRanges();
            sel.addRange(clipRange);
        }

        CUI.rte.Utils.defer(this.afterPaste, 1, this, [ context ]);
    },

    /**
     * <p>This is the second part of the "custom paste" implementation.</p>
     * <p>It reads the pasted content from the hidden div and inserts it into the regular
     * content.</p>
     * @private
     */
    afterPaste: function(context) {

        var sel = CUI.rte.Selection;
        var com = CUI.rte.Common;

        CUI.rte.DomProcessor.correctGeckoCopyBugs(context, this.clipboard);
        var clipboardHtml = this.clipboard.innerHTML;
        this.clipboard.parentNode.removeChild(this.clipboard);
        if (com.ua.isSafari) {
            CUI.rte.Selection.resetSelection(context, "start");
        }
        var execRet = this.editorKernel.execCmd("paste", {
            "html": clipboardHtml,
            "dom": this.clipboard,
            "mode": this.config.defaultPasteMode,
            "pasteRange": this.pasteRange,
            "stripHtmlTags": this.config.stripHtmlTags,
            "htmlRules": this.editorKernel.htmlRules,
            "pasteRules": this.config.htmlPasteRules
        });

        if (com.ua.isGecko) {
            if (execRet.geckoEnsureCaretVisibility && context.iFrame) {
                sel.ensureCaretVisibility(context, context.iframe,
                    this.geckoPreferredScrollingOffset);
            }
            if (execRet.bookmark) {
                sel.selectBookmark(context, execRet.bookmark);
            }
        } else if (com.ua.isWebKit) {
            if (execRet.geckoEnsureCaretVisibility && context.iFrame) {
                CUI.rte.Utils.defer(function() {
                    sel.ensureCaretVisibility(context, context.iframe,
                        this.geckoPreferredScrollingOffset);
                }, 1, this);
            }
        }

        this.clipboard = null;
        this.pasteRange = null;
        this.isPasteOperation = false;
        this.geckoPreferredScrollingOffset = null;
    },

    /**
     * @private
     */
    createPasteDialog: function(type, context, pasteFn) {
        var cfg = {
            "type": type,
            "editContext": context,
            "pasteFn": CUI.rte.Utils.scope(pasteFn, this),
            "cancelFn": CUI.rte.Utils.scope(function() {
                this.pasteRange = null;
            }, this)
        };
        return this.editorKernel.getDialogManager().create(
                CUI.rte.ui.DialogManager.DLG_PASTE, cfg);
    },

    /**
     * @private
     */
    showPasteDialog: function(dialog) {
        dialog.setValue("");
        this.editorKernel.getDialogManager().show(dialog);
    },

    /**
     * @private
     */
    pasteDefault: function(context) {
        var pcmd = CUI.rte.commands.Paste;
        var pasteMode = this.config.defaultPasteMode;
        var pasteDialogMode;
        switch (pasteMode) {
            case pcmd.MODE_BROWSER:
                this.editorKernel.relayCmd("paste", {
                    "mode": pasteMode
                });
                return;
            case pcmd.MODE_WORDHTML:
                pasteDialogMode = "iframe";
                break;
            case pcmd.MODE_PLAINTEXT:
                pasteDialogMode = "plaintext";
                break;
            default:
                throw new Error("Invalid default paste mode: '" + pasteMode + "'.");
        }
        if (!this.pasteDefaultDialog) {
            this.pasteDefaultDialog = this.createPasteDialog(pasteDialogMode, context,
                    this.execPasteDefault);
        }
        this.showPasteDialog(this.pasteDefaultDialog);
    },

    /**
     * @private
     */
    execPasteDefault: function(context, value, isHtml, dom) {
        if (isHtml) {
            this.execPasteWordHtml(context, value, isHtml, dom);
        } else {
            this.execPastePlainText(context, value);
        }
    },

    /**
     * @private
     */
    pastePlainText: function(context) {
        if (!this.pastePlainTextDialog) {
            this.pastePlainTextDialog = this.createPasteDialog("plaintext", context,
                    this.execPastePlainText);
        }
        this.showPasteDialog(this.pastePlainTextDialog);
    },

    /**
     * @private
     */
    execPastePlainText: function(context, value) {
        var pcmd = CUI.rte.commands.Paste;
        this.editorKernel.relayCmd("paste", {
            "mode": pcmd.MODE_PLAINTEXT,
            "text": value,
            "pasteRange": this.pasteRange,
            "stripHtmlTags": this.config.stripHtmlTags
        });
        this.pasteRange = null;
    },

    /**
     * @private
     */
    pasteWordHtml: function(context) {
        if (!this.pasteWordHtmlDialog) {
            this.pasteWordHtmlDialog = this.createPasteDialog("iframe", context,
                    this.execPasteWordHtml);
        }
        this.showPasteDialog(this.pasteWordHtmlDialog);
    },

    /**
     * @private
     */
    execPasteWordHtml: function(context, value, isHtml, dom) {
        var pcmd = CUI.rte.commands.Paste;
        this.editorKernel.relayCmd("paste", {
            "mode": pcmd.MODE_WORDHTML,
            "html": value,
            "dom": dom,
            "pasteRange": this.pasteRange,
            "htmlRules": this.editorKernel.htmlRules,
            "pasteRules": this.config.htmlPasteRules
        });
        this.pasteRange = null;
    },

    getFeatures: function() {
        return [ "cut", "copy", "paste-default", "paste-plaintext", "paste-wordhtml" ];
    },

    initializeUI: function(tbGenerator) {
        var plg = CUI.rte.plugins;
        var ui = CUI.rte.ui;
        if (this.isFeatureEnabled("cut")) {
            this.cutUI = tbGenerator.createElement("cut", this, false,
                    this.getTooltip("cut"));
            tbGenerator.addElement("edit", plg.Plugin.SORT_EDIT, this.cutUI, 10);
        }
        if (this.isFeatureEnabled("copy")) {
            this.copyUI = tbGenerator.createElement("copy", this, false,
                    this.getTooltip("copy"));
            tbGenerator.addElement("edit", plg.Plugin.SORT_EDIT, this.copyUI, 10);
        }
        if (this.isFeatureEnabled("paste-default")) {
            this.pasteDefaultUI = tbGenerator.createElement("paste-default", this, false,
                    this.getTooltip("paste-default"));
            tbGenerator.addElement("edit", plg.Plugin.SORT_EDIT, this.pasteDefaultUI, 30);
        }
        if (this.isFeatureEnabled("paste-plaintext")) {
            this.pastePlainTextUI = tbGenerator.createElement("paste-plaintext", this,
                    false, this.getTooltip("paste-plaintext"));
            tbGenerator.addElement("edit", plg.Plugin.SORT_EDIT, this.pastePlainTextUI, 40);
        }
        if (this.isFeatureEnabled("paste-wordhtml")) {
            this.pasteAsWordUI = tbGenerator.createElement("paste-wordhtml", this, false,
                    this.getTooltip("paste-wordhtml"));
            tbGenerator.addElement("edit", plg.Plugin.SORT_EDIT, this.pasteAsWordUI, 50);
        }
    },

    notifyPluginConfig: function(pluginConfig) {
        pluginConfig = pluginConfig || { };
        // workaround for a CUI.rte.Utils#applyDefaults problem (as it seems)
        var removeLinkRemoveRegEx = false;
        if (pluginConfig.htmlPasteRules) {
            removeLinkRemoveRegEx = (pluginConfig.htmlPasteRules.linkRemoveRegEx === "");
        }
        CUI.rte.Utils.applyDefaults(pluginConfig, {
            "defaultPasteMode": "wordhtml",
            "stripHtmlTags": true,
            "htmlPasteRules": {
                "allowBasics": {
                    "bold": true,
                    "italic": true,
                    "underline": true,
                    "anchor": true,
                    "image": true,
                    "subscript": true,
                    "superscript": true
                },
                "allowBlockTags": [
                    "p", "h1", "h2", "h3", "h4", "h5", "h6"
                ],
                "allowedAttributes": {
                    "*": [
                        "class"
                    ],
                    "table": [
                        "width", "height", "cellspacing", "cellpadding", "border"
                    ],
                    "td": [
                        "width", "height", "colspan", "rowspan", "valign"
                    ],
                    "a": [
                        "href", "name", "title", "alt"
                    ],
                    "img": [
                        "src", "title", "alt", "width", "height"
                    ],
                    "span": [
                        "class"
                    ]
                    /*

                    As we don't support changing list types at the moment, we should remove
                    it on paste as well to keep the markup in an editable state. Can be
                    re-enabled once we support editing the list type.

                    ,
                    "ul": [
                        "type"
                    ],
                    "ol": [
                        "type"
                    ]

                    */
                },
                "list": {
                    "allow": true
                },
                "table": {
                    "allow": true
                },
                "linkRemoveRegEx": null
            },
            "tooltips": {
                "cut": {
                    "title": CUI.rte.Utils.i18n("Cut (Ctrl+X)"),
                    "text": CUI.rte.Utils.i18n("Cuts the currently selected text and puts it in to the clipboard.")
                },
                "copy": {
                    "title": CUI.rte.Utils.i18n("Copy (Ctrl+C)"),
                    "text": CUI.rte.Utils.i18n("Copies the currently selected text to the clipboard.")
                },
                "paste-default": {
                    "title": CUI.rte.Utils.i18n("Paste (Ctrl+V)"),
                    "text": CUI.rte.Utils.i18n("Pastes the clipboard content with the default paste method.")
                },
                "paste-plaintext": {
                    "title": CUI.rte.Utils.i18n("Paste as text"),
                    "text": CUI.rte.Utils.i18n("Pastes the clipboard content as plain text.")
                },
                "paste-wordhtml": {
                    "title": CUI.rte.Utils.i18n("Paste from Word"),
                    "text": CUI.rte.Utils.i18n("Pastes the clipboard content from Word, applying some cleanup.")
                }
            }
        });
        this.config = pluginConfig;
        if (removeLinkRemoveRegEx) {
            delete this.config.htmlPasteRules.linkRemoveRegEx;
        }
        // some backward compatibility fixes
        if (pluginConfig.htmlPasteRules.table.allowed !== undefined) {
            this.config.htmlPasteRules.table.allow =
                    this.config.htmlPasteRules.table.allowed;
            delete this.config.htmlPasteRules.table.allowed;
        }
    },

    execute: function(id, value, env) {
        var context = env.editContext;
        this.pasteRange = this.editorKernel.createQualifiedRangeBookmark(context);
        var cmd = id.toLowerCase();
        switch (cmd) {
            case "cut":
            case "copy":
                this.editorKernel.relayCmd(cmd);
                break;
            case "paste-default":
                this.pasteDefault(context);
                break;
            case "paste-plaintext":
                this.pastePlainText(context);
                break;
            case "paste-wordhtml":
                this.pasteWordHtml(context);
                break;
        }
    },

    updateState: function(selDef) {
        if (this.cutUI) {
            this.cutUI.setDisabled(!(selDef.isSelection || selDef.selectedDom));
        }
        if (this.copyUI) {
            this.copyUI.setDisabled(!(selDef.isSelection || selDef.selectedDom));
        }
    }

});


// register plugin
CUI.rte.plugins.PluginRegistry.register("edit", CUI.rte.plugins.EditToolsPlugin);
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.plugins.FindReplacePlugin
 * @extends CUI.rte.plugins.Plugin
 * <p>This class implements find and replace as a plugin.</p>
 * <p>The plugin ID is "<b>findreplace</b>".</p>
 * <p><b>Features</b></p>
 * <ul>
 *   <li><b>find</b> - adds a button to find text</li>
 *   <li><b>replace</b> - adds a button to find text and replace it with another text</li>
 * </ul>
 */
CUI.rte.plugins.FindReplacePlugin = new Class({

    toString: "FindReplacePlugin",

    extend: CUI.rte.plugins.Plugin,

    /**
     * @private
     */
    findUI: null,

    /**
     * @private
     */
    replaceUI: null,

    /**
     * @private
     */
    findDialog: null,

    /**
     * @private
     */
    replaceDialog: null,

    /**
     * @private
     */
    currentSearchDef: null,

    /**
     * @private
     */
    savedRange: null,


    find: function(context) {
        var com = CUI.rte.Common;
        var dm = this.editorKernel.getDialogManager();
        if (com.ua.isIE) {
            this.savedRange = context.doc.selection.createRange();
        }
        if (!this.findDialog || dm.mustRecreate(this.findDialog)) {
            var config = {
                "editContext": context,
                "title": CUI.rte.Utils.i18n("Find"),
                "isReplace": false,
                "findFn": CUI.rte.Utils.scope(this.execFind, this),
                "cancelFn": CUI.rte.Utils.scope(this.execCancel, this)
            };
            this.findDialog = dm.create(CUI.rte.ui.DialogManager.DLG_FINDREPLACE,
                    config);
        }
        this.findDialog.setMode(true, false);
        dm.show(this.findDialog);
    },

    execFind: function(context, options, dialog) {
        var com = CUI.rte.Common;
        var sel = CUI.rte.Selection;
        var dpr = CUI.rte.DomProcessor;
        if (com.ua.isIE && this.savedRange) {
            this.savedRange.select();
        }
        var findText = options.findText;
        var matchCase = options.matchCase;
        if (this.currentSearchDef
                && ((this.currentSearchDef.findText != findText)
                        || (this.currentSearchDef.matchCase != matchCase))) {
            this.currentSearchDef = null;
        }
        var match, selection;
        if (!this.currentSearchDef) {
            selection = sel.createProcessingSelection(context);
            var startNode = selection.startNode;
            var startOffset = selection.startOffset;
            if (com.getNodeCharacterCnt(startNode) == 0) {
                startNode = com.getFirstTextChild(startNode, true);
                if (!startNode) {
                    startNode = com.getNextCharacterNode(context, selection.startNode);
                }
                if (startNode) {
                    startOffset = (startNode.nodeType == 1 ? null : 0);
                } else {
                    startOffset = null;
                }
            }
            var searchDoc = new CUI.rte.SearchableDocument();
            searchDoc.create(context.root);
            var config = {
                "ignoreCase": !matchCase
            };
            this.currentSearchDef = {
                "findText": findText,
                "matchCase": matchCase,
                "doc": searchDoc
            };
            var findPos = searchDoc.getRefForNode(startNode);
            if (findPos) {
                findPos = findPos.textPos + startOffset;
                config.startPos = findPos;
            }
            match = searchDoc.find(findText, config);
        } else {
            match = this.currentSearchDef.doc.findNext();
        }
        if (!match) {
            dialog.setMode(false, false);
            this.editorKernel.getDialogManager().alert(
                    CUI.rte.Utils.i18n("Find/Replace"),
                    CUI.rte.Utils.i18n("No more occurences of '{0}' found in document.<br>Search will be continued from the top.", [ findText ]),
                    CUI.rte.Utils.scope(this.findDialog.focusFindField, this.findDialog));

            this.currentSearchDef.doc.create(context.root);
        }
        if (match && (match.length > 0)) {
            dialog.setMode(false, true);
            var startDef = match[0];
            var endDef = match[match.length - 1];
            selection = {
                "startNode": startDef.node,
                "startOffset": startDef.matchPos - startDef.nodePos,
                "endNode": endDef.node,
                "endOffset": (endDef.matchPos - endDef.nodePos) + endDef.matchChars
            };
            if (com.ua.isIE) {
                this.editorKernel.focus(context);
            }
            var bookmark = sel.bookmarkFromProcessingSelection(context, selection);
            sel.selectBookmark(context, bookmark);
            if (!com.ua.isOldIE && context.iFrame) {
                // ensure correct scroll offsets for Gecko - which is a "little" bit tricky,
                // as we need to change the DOM and have to restore the DOM accordingly
                // afterwards
                var range = sel.getLeadRange(context);
                var parentNode = range.commonAncestorContainer;
                while (parentNode.nodeType == 3) {
                    parentNode = parentNode.parentNode;
                }
                var savedChildren = dpr.saveChildNodes(parentNode);
                var span = context.createElement("span");
                range.surroundContents(span);
                var top = span.offsetTop;
                var parent = span.offsetParent;
                while (parent) {
                    top += parent.offsetTop;
                    parent = parent.offsetParent;
                }
                var bottom = top + span.offsetHeight;
                var scrollTop = context.root.scrollTop;
                var iframeHeight = context.iFrame.clientHeight;
                var scrollBottom = scrollTop + iframeHeight;
                if (bottom < scrollTop) {
                    context.root.scrollTop = top;
                } else if (bottom > scrollBottom) {
                    var maxScroll = context.root.scrollHeight;
                    if ((maxScroll - bottom) < 8) {
                        bottom = maxScroll;
                    }
                    if (bottom > scrollBottom) {
                        context.root.scrollTop = bottom - iframeHeight;
                    }
                }
                dpr.removeWithoutChildren(span);
                parentNode.normalize();
                dpr.restoreChildNodes(parentNode, savedChildren);
                sel.selectBookmark(context, bookmark);
            }
            if (com.ua.isIE) {
                this.savedRange = context.doc.selection.createRange();
            }
        }
    },

    replace: function(context) {
        var com = CUI.rte.Common;
        var dm = this.editorKernel.getDialogManager();
        if (com.ua.isIE) {
            this.savedRange = context.doc.selection.createRange();
        }
        if (!this.replaceDialog || dm.mustRecreate(this.replaceDialog)) {
            var config = {
                "editContext": context,
                "isReplace": true,
                "findFn": CUI.rte.Utils.scope(this.execFind, this),
                "replaceFn": CUI.rte.Utils.scope(this.execReplace, this),
                "cancelFn": CUI.rte.Utils.scope(this.execCancel, this)
            };
            this.replaceDialog = dm.create(CUI.rte.ui.DialogManager.DLG_FINDREPLACE,
                    config);
        }
        this.replaceDialog.setMode(true, false);
        dm.show(this.replaceDialog);
    },

    execReplace: function(context, options, dialog) {
        var com = CUI.rte.Common;
        var dm = this.editorKernel.getDialogManager();
        if (com.ua.isIE) {
            this.savedRange.select();
        }
        var sel = CUI.rte.Selection;
        if (options.replaceAll) {
            this.editorKernel.focus(context);
            var searchDoc = new CUI.rte.SearchableDocument();
            searchDoc.create(context.root);
            var config = {
                "ignoreCase": !options.matchCase
            };
            var replaceCnt = 0;
            var match = searchDoc.find(options.findText, config);
            while (match) {
                var startDef = match[0];
                var endDef = match[match.length - 1];
                var selection = {
                    "startNode": startDef.node,
                    "startOffset": startDef.matchPos - startDef.nodePos,
                    "endNode": endDef.node,
                    "endOffset": (endDef.matchPos - endDef.nodePos) + endDef.matchChars
                };
                var bookmark = sel.bookmarkFromProcessingSelection(context, selection);
                sel.selectBookmark(context, bookmark);
                this.editorKernel.execCmd("inserthtml", CUI.rte.Utils.htmlEncode(
                        options.replaceText));
                searchDoc.adjustToReplace(options.replaceText);
                replaceCnt++;
                // todo implent more efficently
                searchDoc.create(context.root);
                match = searchDoc.findNext();
            }
            dm.hide(dialog);
            if (replaceCnt > 0) {
                this.editorKernel.getDialogManager().alert(
                        CUI.rte.Utils.i18n("Replace all"),
                        CUI.rte.Utils.i18n("Text '{0}' has been replaced {1} time(s).",
                                [ options.findText, replaceCnt ]),
                        CUI.rte.Utils.scope(this.editorKernel.focus,
                                this.editorKernel));
            } else {
                this.editorKernel.getDialogManager().alert(
                        CUI.rte.Utils.i18n("Replace all"),
                        CUI.rte.Utils.i18n("Text '{0}' not found."),
                        CUI.rte.Utils.scope(this.editorKernel.focus,
                                this.editorKernel));
            }
            this.editorKernel.focus(context);
        } else {
            var preventFind = false;
            try {
                this.editorKernel.focus(context);
                this.editorKernel.execCmd("inserthtml", CUI.rte.Utils.htmlEncode(
                        options.replaceText));
                this.currentSearchDef.doc.adjustToReplace(options.replaceText);
                // todo find a more efficient way than to recreate the entire searchable doc
                this.currentSearchDef.doc.create(context.root);
            } catch (e) {
                if (e.message == "Could not insert html due to IE limitations.") {
                    this.editorKernel.getDialogManager().alert(
                            CUI.rte.Utils.i18n("Replace"),
                            CUI.rte.Utils.i18n("Could not replace due to limited functionality in Internet Explorer."));
                    preventFind = true;
                } else {
                    throw e;
                }
                this.editorKernel.focus(context);
            }
            this.editorKernel.updateToolbar();
            if (!preventFind) {
                if (com.ua.isIE) {
                    this.savedRange = null;
                }
                this.execFind(context, options, dialog);
            } else {
                if (com.ua.isIE) {
                    this.savedRange.select();
                }
                dialog.setMode(false, false);
            }
        }
    },

    execCancel: function() {
        this.currentSearchDef = null;
    },

    getFeatures: function() {
        return [ "find", "replace" ];
    },

    initializeUI: function(tbGenerator) {
        var plg = CUI.rte.plugins;
        if (this.isFeatureEnabled("find")) {
            this.findUI = tbGenerator.createElement("find", this, false,
                    this.getTooltip("find"));
            tbGenerator.addElement("findreplace", plg.Plugin.SORT_EDIT + 5, this.findUI,
                    100);
        }
        if (this.isFeatureEnabled("replace")) {
            this.replaceUI = tbGenerator.createElement("replace", this, false,
                    this.getTooltip("replace"));
            tbGenerator.addElement("findreplace", plg.Plugin.SORT_EDIT + 5, this.replaceUI,
                    110);
        }
    },

    notifyPluginConfig: function(pluginConfig) {
        pluginConfig = pluginConfig || { };
        CUI.rte.Utils.applyDefaults(pluginConfig, {
            "tooltips": {
                "find": {
                    "title": CUI.rte.Utils.i18n("Find"),
                    "text": CUI.rte.Utils.i18n("Finds a text fragment in the text being edited.")
                },
                "replace": {
                    "title": CUI.rte.Utils.i18n("Replace"),
                    "text": CUI.rte.Utils.i18n("Replaces a text fragment with another fragment.")
                }
            }
        });
        this.config = pluginConfig;
    },

    execute: function(id, value, env) {
        switch (id) {
            case "find":
                this.find(env.editContext);
                break;
            case "replace":
                this.replace(env.editContext);
                break;
        }

    },

    updateState: function(selDef) {
        // todo implement
    }

});


// register plugin
CUI.rte.plugins.PluginRegistry.register("findreplace",
        CUI.rte.plugins.FindReplacePlugin);
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.plugins.FormatPlugin
 * @extends CUI.rte.plugins.SimpleFormatPlugin
 * <p>This class implements simple character formatting (bold, italic, underlined) as a
 * plugin.</p>
 * <p>The plugin ID is "<b>format</b>".</p>
 * <p><b>Features</b></p>
 * <ul>
 *   <li><b>bold</b> - adds the "bold" button</li>
 *   <li><b>italic</b> - adds the "italic" button</li>
 *   <li><b>underline</b> - adds the "underline" button</li>
 * </ul>
 */
CUI.rte.plugins.FormatPlugin = new Class({

    toString: "FormatPlugin",

    extend: CUI.rte.plugins.SimpleFormatPlugin,

    _init: function(editorKernel) {
        var plg = CUI.rte.plugins;
        plg.FormatPlugin.prototype.superClass._init.call(this, editorKernel, "format",
                plg.Plugin.SORT_FORMAT, [ {
                    "command": "bold",
                    "shortcut": "b"
                }, {
                    "command": "italic",
                    "shortcut": "i"
                }, {
                    "command": "underline",
                    "shortcut": "u"
                }]);
    },

    notifyPluginConfig: function(pluginConfig) {
        pluginConfig = pluginConfig || { };
        CUI.rte.Utils.applyDefaults(pluginConfig, {
            "features": "*",
            "tooltips": {
                "bold": {
                    "title": CUI.rte.Utils.i18n("Bold (Ctrl+B)"),
                    "text": CUI.rte.Utils.i18n("Make the selected text bold.")
                },
                "italic": {
                    "title": CUI.rte.Utils.i18n("Italic (Ctrl+I)"),
                    "text": CUI.rte.Utils.i18n("Make the selected text italic.")
                },
                "underline": {
                    "title": CUI.rte.Utils.i18n("Underline (Ctrl+U)"),
                    "text": CUI.rte.Utils.i18n("Underline the selected text.")
                }
            }
        });
        this.config = pluginConfig;
    }

});


// register plugin
CUI.rte.plugins.PluginRegistry.register("format", CUI.rte.plugins.FormatPlugin);
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.plugins.JustifyPlugin
 * @extends CUI.rte.plugins.SimpleFormatPlugin
 * <p>This class implements simple character formatting (bold, italic, underlined) as a
 * plugin.</p>
 * <p>The plugin ID is "<b>justify</b>".</p>
 * <p><b>Features</b></p>
 * <ul>
 *   <li><b>justifyleft</b> - adds a button to left-align the selected block</li>
 *   <li><b>justifyright</b> - adds a button to right-align the selected block</li>
 *   <li><b>justifycenter</b> - adds a button to center the selected block</li>
 * </ul>
 */
CUI.rte.plugins.JustifyPlugin = new Class({

    toString: "JustifyPlugin",

    extend: CUI.rte.plugins.SimpleFormatPlugin,

    _init: function(editorKernel) {
        var plg = CUI.rte.plugins;
        plg.JustifyPlugin.prototype.superClass._init.call(this, editorKernel, "justify",
                plg.Plugin.SORT_JUSTIFY, [ "justifyleft", "justifycenter", "justifyright"]);
    },

    notifyPluginConfig: function(pluginConfig) {
        pluginConfig = pluginConfig || { };
        CUI.rte.Utils.applyDefaults(pluginConfig, {
            "features": "*",
            "tooltips": {
                "justifyleft": {
                    "title": CUI.rte.Utils.i18n("Align Text Left"),
                    "text": CUI.rte.Utils.i18n("Align text to the left.")
                },
                "justifycenter": {
                    "title": CUI.rte.Utils.i18n("Center Text"),
                    "text": CUI.rte.Utils.i18n("Center text in the editor.")
                },
                "justifyright": {
                    "title": CUI.rte.Utils.i18n("Align Text Right"),
                    "text": CUI.rte.Utils.i18n("Align text to the right.")
                }
            }
        });
        this.config = pluginConfig;
    }

});


// register plugin
CUI.rte.plugins.PluginRegistry.register("justify", CUI.rte.plugins.JustifyPlugin);
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.plugins.LinkPlugin
 * @extends CUI.rte.plugins.Plugin
 * <p>This class implements links and anchors as a plugin.</p>
 * <p>The plugin ID is "<b>links</b>".</p>
 * <p><b>Features</b></p>
 * <ul>
 *   <li><b>modifylink</b> - adds a button to create and modify links</li>
 *   <li><b>unlink</b> - adds a button to remove existing links</li>
 *   <li><b>anchor</b> - adds a button to define anchors</li>
 * </ul>
 */
CUI.rte.plugins.LinkPlugin = new Class({

    toString: "LinkPlugin",

    extend: CUI.rte.plugins.Plugin,

    /**
     * @cfg {Boolean} trimLinkSelection
     * True if leading and trailing whitespace should removed from the selection (not from
     * the actual text/content!) before creating a new link (defaults to true).
     * @since 5.3
     */

    /**
     * @cfg {Object} linkDialogConfig
     * @since 5.3
     */

    /**
     * @cfg {Object} anchorDialogConfig
     * Configuration of the anchor dialog (defaults to { }). You may specify the same
     * config options as for a dialog in the toolkit used. Note that the default value
     * of null implies using a default dialog.
     * @since 5.3
     */

    /**
     * @private
     */
    linkDialog: null,

    /**
     * @private
     */
    anchorDialog: null,

    /**
     * @private
     */
    linkUI: null,

    /**
     * @private
     */
    removeLinkUI: null,

    /**
     * @private
     */
    anchorUI: null,

    getFeatures: function() {
        return [ "modifylink", "unlink", "anchor" ];
    },

    /**
     * Creates a link using the internal link dialog.
     * @private
     */
    modifyLink: function(context) {
        var com = CUI.rte.Common;
        var dm = this.editorKernel.getDialogManager();
        var dh = CUI.rte.ui.DialogHelper;
        if (!this.linkDialog || dm.mustRecreate(this.linkDialog)) {
            var dialogHelper = dm.createDialogHelper();
            var linkRules = this.editorKernel.htmlRules.links;
            var dialogConfig = {
                "configVersion": 1,
                "defaultDialog": {
                    "dialogClass": {
                        "type": dh.TYPE_DIALOG
                    }
                },
                "parameters": {
                    "linkRules": linkRules,
                    "editorKernel": this.editorKernel
                }
            };
            if (this.config.linkDialogConfig) {
                var addDialogConfig = this.config.linkDialogConfig;
                if (addDialogConfig.linkAttributes) {
                    com.removeJcrData(addDialogConfig.linkAttributes);
                    var linkAttribs = com.toArray(addDialogConfig.linkAttributes);
                    dialogConfig.additionalFields = [ ];
                    var attribCnt = linkAttribs.length;
                    for (var a = 0; a < attribCnt; a++) {
                        var attrib = linkAttribs[a];
                        var type = attrib.type || attrib.xtype;
                        var attribName = attrib.attribute;
                        var attribLabel = attrib.label || attrib.fieldLabel;
                        var itemData = {
                            "item": dialogHelper.createItem(type, attribName, attribLabel),
                            "fromModel": function(obj, field) {
                                if (dialogHelper.getItemType(field) == dh.TYPE_HIDDEN) {
                                    return;
                                }
                                var attribName = dialogHelper.getItemName(field);
                                var attribValue = com.getAttribute(obj.dom, attribName);
                                if (attribValue) {
                                    dialogHelper.setItemValue(field, attribValue);
                                } else {
                                    dialogHelper.setItemValue(field, "");
                                }
                            },
                            "toModel": function(obj, field) {
                                var attribName = dialogHelper.getItemName(field);
                                if (!obj.attributes) {
                                    obj.attributes = { };
                                }
                                var value = dialogHelper.getItemValue(field);
                                if (value && (value.length > 0)) {
                                    obj.attributes[attribName] = value;
                                } else {
                                    obj.attributes[attribName] =
                                        CUI.rte.commands.Link.REMOVE_ATTRIBUTE;
                                }
                            }
                        };
                        delete attrib.attribute;
                        delete attrib.type;
                        delete attrib.xtype;
                        delete attrib.label;
                        delete attrib.fieldLabel;
                        CUI.rte.Utils.applyDefaults(itemData.item, attrib);
                        dialogConfig.additionalFields.push(itemData);
                    }
                    delete addDialogConfig.linkAttributes;
                }
                dialogConfig.dialogProperties = addDialogConfig;
            }
            if (linkRules.targetConfig) {
                if (linkRules.targetConfig.mode != "blank") {
                    dialogConfig.disabledDefaultFields = [ "targetBlank" ];
                }
                if (linkRules.targetConfig.mode == "manual") {
                    if (!dialogConfig.additionalFields) {
                        dialogConfig.additionalFields = { };
                    }
                    var targetItem = dialogHelper.createItem(dh.TYPE_TEXTFIELD, "target",
                            CUI.rte.Utils.i18n("Anchor"));
                    dialogConfig.additionalFields.push({
                        "item": targetItem,
                        "fromModel": function(obj, field) {
                            if (obj.dom && obj.dom["target"]) {
                                dialogHelper.setItemValue(field, obj.dom["target"]);
                            }
                        },
                        "toModel": function(obj, field) {
                            if (!obj.attributes) {
                                obj.attributes = { };
                            }
                            var value = dialogHelper.getItemValue(field);
                            if (value && (value.length > 0)) {
                                obj.attributes["target"] = value;
                            } else {
                                obj.attributes["target"] = null;
                            }
                        }
                    });
                }
            }
            CUI.rte.Utils.applyDefaults(dialogConfig, this.config.linkDialogConfig || { });
            dialogHelper.configure(dialogConfig);
            this.linkDialog = dialogHelper.create();
            dialogHelper.calculateInitialPosition();
        }
        var linkToEdit = null;
        var selectionDef = this.editorKernel.analyzeSelection();
        if (selectionDef.anchorCount == 1) {
            linkToEdit = selectionDef.anchors[0];
        }
        linkToEdit = linkToEdit || { };
        if (typeof linkToEdit.attributes === 'undefined')
            linkToEdit.attributes = { };
        this.linkDialog.initializeEdit(this.editorKernel, linkToEdit,
                CUI.rte.Utils.scope(this.applyLink, this));
        if (com.ua.isIE) {
            this.savedRange = context.doc.selection.createRange();
        }
        dm.show(this.linkDialog);
    },

    applyLink: function(context) {
        var com = CUI.rte.Common;
        var linkObj = this.linkDialog.objToEdit;
        if (linkObj) {
            var linkUrl = linkObj.href;
            var cssClass = linkObj.cssClass;
            var target = linkObj.target;
            if (com.ua.isIE) {
                this.savedRange.select();
            }
            this.editorKernel.relayCmd("modifylink", {
                "url": linkUrl,
                "css": cssClass,
                "target": target,
                "trimLinkSelection": this.config.trimLinkSelection,
                "attributes": linkObj.attributes
            });
        }
    },

    /**
     * Creates an anchor using the anchor dialog.
     * @private
     */
    modifyAnchor: function(context) {
        var com = CUI.rte.Common;
        var dm = this.editorKernel.getDialogManager();
        if (!this.anchorDialog || dm.mustRecreate(this.anchorDialog)) {
            var editorKernel = this.editorKernel;
            var plugin = this;
            var defaultConfig = {
                execute: function(value) {
                    if (com.ua.isIE) {
                        plugin.savedRange.select();
                    }
                    editorKernel.relayCmd("anchor", value);
                }
            };
            var dialogConfig = this.config.anchorDialogConfig || { };
            CUI.rte.Utils.applyDefaults(dialogConfig, defaultConfig);
            this.anchorDialog = dm.create(CUI.rte.ui.DialogManager.DLG_ANCHOR,
                    dialogConfig);
        } else {
            this.anchorDialog.resetValues();
        }
        var selectionDef = this.editorKernel.analyzeSelection();
        if (selectionDef.namedAnchorCount == 1) {
            this.anchorDialog.setAnchor(selectionDef.namedAnchors[0]);
        }
        if (com.ua.isIE) {
            this.savedRange = context.doc.selection.createRange();
        }
        dm.show(this.anchorDialog);
    },

    initializeUI: function(tbGenerator) {
        var plg = CUI.rte.plugins;
        var ui = CUI.rte.ui;
        if (this.isFeatureEnabled("modifylink")) {
            this.linkUI = tbGenerator.createElement("modifylink", this, false,
                    this.getTooltip("modifylink"));
            tbGenerator.addElement("links", plg.Plugin.SORT_LINKS, this.linkUI, 10);
        }
        if (this.isFeatureEnabled("unlink")) {
            this.removeLinkUI = tbGenerator.createElement("unlink", this, false,
                    this.getTooltip("unlink"));
            tbGenerator.addElement("links", plg.Plugin.SORT_LINKS, this.removeLinkUI, 20);
        }
        if (this.isFeatureEnabled("anchor")) {
            this.anchorUI = tbGenerator.createElement("anchor", this, true,
                    this.getTooltip("anchor"));
            tbGenerator.addElement("links", plg.Plugin.SORT_LINKS, this.anchorUI, 30);
        }
    },

    notifyPluginConfig: function(pluginConfig) {
        pluginConfig = pluginConfig || { };
        CUI.rte.Utils.applyDefaults(pluginConfig, {
            "features": "*",
            "trimLinkSelection": true,
            "linkDialogConfig": {
                "targetConfig": {
                    "mode": "manual"
                }
            },
            "anchorDialogConfig": {
                // empty by default
            },
            "tooltips": {
                "modifylink": {
                    "title": CUI.rte.Utils.i18n("Hyperlink"),
                    "text": CUI.rte.Utils.i18n("Create or modify a hyperlink.")
                },
                "unlink": {
                    "title": CUI.rte.Utils.i18n("Unlink"),
                    "text": CUI.rte.Utils.i18n("Remove an existing hyperlink from the selected text.")
                },
                "anchor": {
                    "title": CUI.rte.Utils.i18n("Anchor"),
                    "text": CUI.rte.Utils.i18n("Add or edit an anchor.")
                }
            }
        });
        this.config = pluginConfig;
    },

    execute: function(cmd, value, env) {
        if (cmd == "modifylink") {
            this.modifyLink(env.editContext);
        } else if (cmd == "anchor") {
            this.modifyAnchor(env.editContext);
        } else {
            this.editorKernel.relayCmd(cmd);
        }
    },

    updateState: function(selDef) {
        var hasSingleAnchor = selDef.anchorCount == 1;
        var hasNoAnchor = selDef.anchorCount == 0;
        var selectedNode = selDef.selectedDom;
        var isLinkableObject = false;
        if (selectedNode) {
            isLinkableObject = CUI.rte.Common.isTag(selectedNode,
                    CUI.rte.plugins.LinkPlugin.LINKABLE_OBJECTS);
        }
        var isCreateLinkEnabled = hasSingleAnchor
                || ((selDef.isSelection || isLinkableObject) && hasNoAnchor);
        if (this.linkUI) {
            this.linkUI.setDisabled(!isCreateLinkEnabled);
        }
        if (this.removeLinkUI) {
            this.removeLinkUI.setDisabled(!hasSingleAnchor);
        }
        if (this.anchorUI) {
            var hasSingleNamedAnchor = (selDef.namedAnchorCount == 1);
            this.anchorUI.setSelected(hasSingleNamedAnchor);
        }
    }

});

/**
 * Array with tag names that define objects (like images) that are linkable when selected
 * @private
 * @static
 * @final
 * @type String[]
 */
CUI.rte.plugins.LinkPlugin.LINKABLE_OBJECTS = [
    "img"
];


// register plugin
CUI.rte.plugins.PluginRegistry.register("links", CUI.rte.plugins.LinkPlugin);
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.plugins.ListPlugin
 * @extends CUI.rte.plugins.Plugin
 * <p>This class implements the list functionality as a plugin.</p>
 * <p>The plugin ID is "<b>lists</b>".</p>
 * <p><b>Features</b></p>
 * <ul>
 *   <li><b>ordered</b> - adds a button to create or remove an ordered list</li>
 *   <li><b>unordered</b> - adds a button to create or remove an unordered list</li>
 *   <li><b>indent</b> - adds a button to indent list items or blocks</li>
 *   <li><b>outdent</b> - adds a button to outdent list items or blocks</li>
 * </ul>
 */
CUI.rte.plugins.ListPlugin = new Class({

    toString: "ListPlugin",

    extend: CUI.rte.plugins.Plugin,

    /**
     * @cfg {Number} indentSize
     * The size of an indent level in pixels (defaults to 40). Note that this setting
     * only takes effect if the "indent"/"outdent" features of the plugin are enabled and
     * if the indent is applied outside a list.
     * @since 5.3
     */

    /**
     * @cfg {Boolean} keepStructureOnUnlist
     * Defines how to handle the unlisting of nested list items. If set to true, the
     * structure of the two lists will be kept identically by inserting empty list items
     * accordingly. For example: In the given list
<pre>
<ul>
  <li>Item 1</li>
  <li>Item 2
    <ul>
      <li>Item 2.1</li>
      <li>Item 2.2</li>
    </ul>
  </li>
  <li>Item 3</li>
</pre>
     * Item 2.1 is unlisted. This will result in the following markup if
     * keepStructureOnUnlist == true:
<pre>
<ul>
  <li>Item 1</li>
  <li>Item 2</li>
</ul>
<p>Item 2.1</p>
<ul>
  <li>&nbsp;
    <ul>
      <li>Item 2.2</li>
    </ul>
  </li>
  <li>Item 3</li>
</ul>
</pre>
     * Respectively, if keepStructureOnUnlist == false:
<pre>
  <ul>
    <li>Item 1</li>
    <li>Item 2</li>
  </ul>
  <p>Item 2.1</p>
  <ul>
    <li>Item 2.2</li>
    <li>Item 3</li>
  </ul>
</ul>
</pre>
     * Defaults to false.
     */

    /**
     * @private
     */
    orderedListUI: null,

    /**
     * @private
     */
    unorderedListUI: null,

    /**
     * @private
     */
    indentUI: null,

    /**
     * @private
     */
    outdentUI: null,

    _init: function(editorKernel) {
        this.inherited(arguments);
        editorKernel.addPluginListener('beforekeydown', this.handleOnKey, this, this, false);
    },

    /**
     * This function creates new list entries (<li>) by pressing CRTL+ENTER
     * This workaround should be used if there is a block node within a list entry
     *
     * @param event
     */
    handleOnKey: function (event) {
        var range, rangeNode, parentNode, parentParentNode, newListNode;

        if (event.isEnter() && event.isCtrl()) {
            try {
                if (window.getSelection) {  // all browsers, except IE before version 9
                    range = CUI.rte.Selection.getLeadRange(event.editContext);
                }
                else {
                    if (document.selection) {   // Internet Explorer 6/7/8
                        range = document.selection.createRange();
                    }
                }

                rangeNode = range.commonAncestorContainer ? range.commonAncestorContainer :
                    range.parentElement ? range.parentElement() : range.item(0);
                parentNode = rangeNode.parentNode ? rangeNode.parentNode : rangeNode.parentElement();

                while (rangeNode !== parentNode && parentNode.tagName !== 'LI') {
                    rangeNode = rangeNode.parentNode ? rangeNode.parentNode : rangeNode.parentElement();
                    parentNode = rangeNode.parentNode ? rangeNode.parentNode : rangeNode.parentElement();
                }

                if (rangeNode.tagName && rangeNode.tagName !== 'LI' && parentNode.tagName === 'LI') {
                    parentParentNode = parentNode.parentNode ? parentNode.parentNode : parentNode.parentElement();

                    newListNode = event.editContext.doc.createElement('li');
                    newListNode.appendChild(rangeNode);

                    if (parentNode.nextSibling) {
                        parentParentNode.insertBefore(newListNode, parentNode.nextSibling);
                    } else {
                        parentParentNode.appendChild(newListNode);
                    }

                    CUI.rte.Selection.selectNode(event.editContext, newListNode, 1);
                }
            } catch (err) {
                // sometimes a node might be undefined
            }
        }
    },

    getFeatures: function() {
        return [ "ordered", "unordered", "indent", "outdent" ];
    },

    initializeUI: function(tbGenerator) {
        var plg = CUI.rte.plugins;
        var ui = CUI.rte.ui;
        if (this.isFeatureEnabled("unordered")) {
            this.unorderedListUI = tbGenerator.createElement("insertunorderedlist", this,
                    true, this.getTooltip("insertunorderedlist"));
            tbGenerator.addElement("lists", plg.Plugin.SORT_LISTS, this.unorderedListUI,
                    10);
        }
        if (this.isFeatureEnabled("ordered")) {
            this.orderedListUI = tbGenerator.createElement("insertorderedlist", this, true,
                    this.getTooltip("insertorderedlist"));
            tbGenerator.addElement("lists", plg.Plugin.SORT_LISTS, this.orderedListUI, 20);
        }
        if (this.isFeatureEnabled("indent")) {
            this.indentUI = tbGenerator.createElement("indent", this, false,
                    this.getTooltip("indent"));
            tbGenerator.addElement("lists", plg.Plugin.SORT_LISTS, this.indentUI, 40);
        }
        if (this.isFeatureEnabled("outdent")) {
            this.outdentUI = tbGenerator.createElement("outdent", this, false,
                    this.getTooltip("outdent"));
            tbGenerator.addElement("lists", plg.Plugin.SORT_LISTS, this.outdentUI, 30);
        }
    },

    notifyPluginConfig: function(pluginConfig) {
        pluginConfig = pluginConfig || { };
        CUI.rte.Utils.applyDefaults(pluginConfig, {
            "features": "*",
            "indentSize": 40,
            "keepStructureOnUnlist": false,
            "tooltips": {
                "insertunorderedlist": {
                    "title": CUI.rte.Utils.i18n("Bullet List"),
                    "text": CUI.rte.Utils.i18n("Start a bulleted list.")
                },
                "insertorderedlist": {
                    "title": CUI.rte.Utils.i18n("Numbered List"),
                    "text": CUI.rte.Utils.i18n("Start a numbered list.")
                },
                "indent": {
                    "title": CUI.rte.Utils.i18n("Indent"),
                    "text": CUI.rte.Utils.i18n("Indents the selected paragraph(s) or list item(s).")
                },
                "outdent": {
                    "title": CUI.rte.Utils.i18n("Outdent"),
                    "text": CUI.rte.Utils.i18n("Outdents the current paragraph(s) or list item(s).")
                }
            }
        });
        this.config = pluginConfig;
    },

    execute: function(id) {
        var value = undefined;
        if ((id == "indent") || (id == "outdent")) {
            value = this.config.indentSize;
        } else if (CUI.rte.Common.strStartsWith(id, "insert")) {
            value = this.config.keepStructureOnUnlist;
        }
        this.editorKernel.relayCmd(id, value);
    },

    updateState: function(selDef) {
        var context = selDef.editContext;
        var state, isDisabled;
        if (this.orderedListUI) {
            state = this.editorKernel.queryState("insertorderedlist", selDef);
            isDisabled = (state == null)
                    || (state == CUI.rte.commands.List.NO_LIST_AVAILABLE);
            this.orderedListUI.setSelected((state === true) || (state == null));
            this.orderedListUI.setDisabled(isDisabled);
        }
        if (this.unorderedListUI) {
            state = this.editorKernel.queryState("insertunorderedlist", selDef);
            isDisabled = (state == null)
                    || (state == CUI.rte.commands.List.NO_LIST_AVAILABLE);
            this.unorderedListUI.setSelected((state === true) || (state == null));
            this.unorderedListUI.setDisabled(isDisabled);
        }
        if (this.outdentUI) {
            // outdent is only available if the current selection has some indent
            this.outdentUI.setDisabled(!this.editorKernel.queryState("indent", selDef));
        }
        if (this.indentUI) {
            // indent is basically always available - but not if the selection contains
            // "first items", which cannot be indented using reasonable HTML
            var isEnabled = true;
            var listItems = selDef.nodeList.getTags(context, [ {
                    "matcher": function(dom) {
                        return CUI.rte.Common.isTag(dom, "li");
                    }
                }
            ], true, true);
            var itemCnt = listItems.length;
            for (var i = 0; i < itemCnt; i++) {
                var itemDom = listItems[i].dom;
                if (!itemDom.previousSibling) {
                    var parentItemDom = itemDom.parentNode.parentNode;
                    var isParentInSelection = false;
                    for (var c = 0; c < itemCnt; c++) {
                        if (listItems[c].dom == parentItemDom) {
                            isParentInSelection = true;
                            break;
                        }
                    }
                    if (!isParentInSelection) {
                        isEnabled = false;
                        break;
                    }
                }
            }
            this.indentUI.setDisabled(!isEnabled);
        }
    }

});


// register plugin
CUI.rte.plugins.PluginRegistry.register("lists", CUI.rte.plugins.ListPlugin);
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.plugins.MiscToolsPlugin
 * @extends CUI.rte.plugins.Plugin
 * <p>This class implements miscellaneous tools (sourceview, special chars) as a plugin.</p>
 * <p>The plugin ID is "<b>misctools</b>".</p>
 * <p><b>Features</b></p>
 * <ul>
 *   <li><b>specialchars</b> - adds an icon to invoke a dialog that may be used for
 *     inserting characters that are not easily accessible via the keyboard</li>
 *   <li><b>sourceedit</b> - adds an icon that allows to switch to source edit mode</li>
 * </ul>
 */
CUI.rte.plugins.MiscToolsPlugin = new Class({

    toString: "MiscToolsPlugin",

    extend: CUI.rte.plugins.Plugin,

    /**
     * @cfg {Object} specialCharsConfig
     * <p>Configuration of the special characters component. Valid config properties are:
     * </p>
     * <ul>
     *   <li><code>chars</code> : Object<br>
     *     Table of characters to be added to the special character dialog. Choose the
     *     property name for each element at your discretion. Each element defines a single
     *     character or a range of characters:
     *     <ul>
     *       <li>Use an "entity" property (String) to specify the HTML entity of a single
     *         character (for example: "&amp;copy;").</li>
     *       <li>Use "rangeStart" (Number)/"rangeEnd" (Number) properties to specify a range
     *         of unicode characters. Both rangeStart and rangeEnd must specify the numeric
     *         representation of a unicode character. Note that the character specified as
     *         rangeEnd is also included in the specified range.</li>
     *     </ul>
     *   </li>
     *   <li><code>tableCls</code> : String<br>
     *     The CSS class to be used for formatting the table that displays the special
     *     characters.</li>
     *   <li><code>cellCls</code> : String<br>
     *     The CSS class to be used for formatting cells of the character table.</li>
     *   <li><code>overCls</code> : String<br>
     *     The CSS class to be used for formatting cells of the character table if
     *     rolledover.</li>
     *   <li><code>magnifyCls</code> : String<br>
     *     CSS class to be used for the magnified view of the currently rolledover
     *     character.</li>
     * </ul>
     * <p>Defaults to:</p>
<pre>
{
    "tableCls": "cui-rte-scd-table",
    "cellCls": "cui-rte-scd-cell",
    "overCls": "cui-rte-scd-cell-over",
    "magnifyCls": "cui-rte-scd-magnify",
    "chars": {
        "copyright": {
            "entity": "&copy;"
        },
        "registered": {
            "entity": "&reg;"
        },
        "trademark": {
            "entity": "&trade;"
        }
    }
}
</pre>
     * @since 5.3
     */

    /**
     * @private
     */
    specialCharsUI: null,

    /**
     * @private
     */
    sourceEditUI: null,

    /**
     * @private
     */
    specialCharsDialog: null,

    /**
     * @private
     */
    savedRange: null,


    getFeatures: function() {
        return [ "specialchars", "sourceedit" ];
    },

    initializeUI: function(tbGenerator) {
        var plg = CUI.rte.plugins;
        var ui = CUI.rte.ui;
        if (this.isFeatureEnabled("specialchars")) {
            this.specialCharsUI = tbGenerator.createElement("specialchars", this, false,
                    this.getTooltip("specialchars"));
            tbGenerator.addElement("misc", plg.Plugin.SORT_MISC, this.specialCharsUI, 100);
        }
        if (this.isFeatureEnabled("sourceedit") && this.editorKernel.canEditSource()) {
            this.sourceEditUI = tbGenerator.createElement("sourceedit", this, true,
                    this.getTooltip("sourceedit"));
            tbGenerator.addElement("misc", plg.Plugin.SORT_MISC, this.sourceEditUI, 110);
        }
    },

    /**
     * Inserts a special character using the corresponding dialog.
     * @private
     */
    insertSpecialChars: function(context) {
        var com = CUI.rte.Common;
        var dm = this.editorKernel.getDialogManager();
        if (!this.specialCharsDialog || dm.mustRecreate(this.specialCharsDialog)) {
            var defaultConfig = {
                "insertCharacter": CUI.rte.Utils.scope(function(charToInsert) {
                    this.insertCharacter(this.editContext, charToInsert);
                }, this)
            };
            var dialogConfig = this.config.specialCharsConfig || { };
            CUI.rte.Utils.applyDefaults(dialogConfig, defaultConfig);
            this.specialCharsDialog = dm.create(CUI.rte.ui.DialogManager.DLG_SPECCHARS,
                    dialogConfig);
            // would throw a SecurityError if set in dialogConfig or while creating the
            // dialog
            this.specialCharsDialog.editContext = context;
        }
        if (com.ua.isIE) {
            this.savedRange = context.doc.selection.createRange();
        }
        dm.show(this.specialCharsDialog);
    },

    insertCharacter: function(context, charToInsert) {
        var com = CUI.rte.Common;
        if (com.ua.isIE) {
            this.savedRange.select();
        }
        this.editorKernel.relayCmd("InsertHTML", charToInsert);
    },

    notifyPluginConfig: function(pluginConfig) {
        // configuring "special characters" dialog
        pluginConfig = pluginConfig || { };
        var defaults = {
            "specialCharsConfig": {
                "tableCls": "cui-rte-scd-table",
                "cellCls": "cui-rte-scd-cell",
                "overCls": "cui-rte-scd-cell-over",
                "magnifyCls": "cui-rte-scd-magnify",
                "chars": {
                    "copyright": {
                        "entity": "&copy;"
                    },
                    "registered": {
                        "entity": "&reg;"
                    },
                    "trademark": {
                        "entity": "&trade;"
                    }
                }
            },
            "tooltips": {
                "sourceedit": {
                    "title": CUI.rte.Utils.i18n("Source Edit"),
                    "text": CUI.rte.Utils.i18n("Switch to source editing mode.")
                },
                "specialchars": {
                    "title": CUI.rte.Utils.i18n("Special characters"),
                    "text": CUI.rte.Utils.i18n("Insert a special character.")
                }
            }
        };
        if (pluginConfig.specialCharsConfig && pluginConfig.specialCharsConfig.chars) {
            delete defaults.specialCharsConfig.chars;
        }
        CUI.rte.Utils.applyDefaults(pluginConfig, defaults);
        this.config = pluginConfig;
    },

    execute: function(id, value, options) {
        var context = options.editContext;
        if (id == "specialchars") {
            this.insertSpecialChars(context);
        } else if ((id == "sourceedit") && this.sourceEditUI) {
            // defer is required for correct temporary focus handling
            CUI.rte.Utils.defer(this.editorKernel.requestSourceEdit, 1,
                    this.editorKernel, [ this.sourceEditUI.isSelected() ]);
        }
    },

    updateState: function(selDef) {
        var context = selDef.editContext;
        if (this.specialCharsUI != null) {
            var cells = selDef.nodeList.getTags(context, [{
                    "tagName": [ "td", "th" ]
                }
            ], false);
            var disable = (cells.length > 0);
            this.specialCharsUI.setDisabled(disable);
        }
    }

});


// register plugin
CUI.rte.plugins.PluginRegistry.register("misctools",
        CUI.rte.plugins.MiscToolsPlugin);
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.plugins.ParagraphFormatPlugin
 * @extends CUI.rte.plugins.Plugin
 * <p>This class implements paragraph formats (h1, h2, p, etc.)  as a plugin.</p>
 * <p>The plugin ID is "<b>paraformat</b>".</p>
 * <p><b>Features</b></p>
 * <ul>
 *   <li><b>paraformat</b> - adds a format selector (formats will always be applied on block
 *     scope).</li>
 * </ul>
 */
CUI.rte.plugins.ParagraphFormatPlugin = new Class({

    toString: "ParagraphFormatPlugin",

    extend: CUI.rte.plugins.Plugin,

    /**
     * @cfg {Object/Object[]} formats
     * <p>Defines the block formats (p, h1, h2, h3, ...) that are applicable to paragraphs.
     * </p>
     * <p>You can choose a deliberate (but unique) property name for each format, if you
     * chosoe to provide an Object rather than a Object[]. Each element (of the Array) or
     * property value (if choosing the Object representation) must have the following
     * properties:</p>
     * <ul>
     *   <li><code>tag</code> : String<br>
     *     The name of the tag that represents the block format (for example: "p", "h1",
     *     "h2", ...)</li>
     *   <li><code>description</code> : String<br>
     *     The text that represents the paragraph format in the format selector</li>
     * </uL>
     * <p>Note that this configuration only takes effect if the
     * {@link CUI.rte.plugins.ParagraphFormatPlugin "paraformat" plugin} is enabled.
     * Also note that you can't set additional DOM attributes using the "paraformat"
     * plugin.</p>
     * <p>Defaults to:</p>
<pre>
[
    {
        "tag": "p",
        "description": CUI.rte.Utils.i18n("Paragraph")
    }, {
        "tag": "h1",
        "description": CUI.rte.Utils.i18n("Heading 1")
    }, {
        "tag": "h2",
        "description": CUI.rte.Utils.i18n("Heading 2")
    }, {
        "tag": "h3",
        "description": CUI.rte.Utils.i18n("Heading 3")
    }
]
</pre>
     * @since 5.3
     */

    /**
     * @private
     */
    cachedFormats: null,

    /**
     * @private
     */
    formatUI: null,

    getFeatures: function() {
        return [ "paraformat" ];
    },

    /**
     * @private
     */
    getFormatId: function(dom) {
        var tagName = dom.tagName.toLowerCase();
        var formats = this.getFormats();
        var formatCnt = formats.length;
        for (var f = 0; f < formatCnt; f++) {
            var formatDef = formats[f];
            if (formatDef.tag && (formatDef.tag == tagName)) {
                return formatDef.tag;
            }
        }
        return null;
    },

    getFormats: function() {
        var com = CUI.rte.Common;
        if (this.cachedFormats == null) {
            this.cachedFormats = this.config.formats || { };
            com.removeJcrData(this.cachedFormats);
            this.cachedFormats = com.toArray(this.cachedFormats, "tag", "description");
        }
        return this.cachedFormats;
    },

    getFormatById: function(formats, id) {
        var formatCnt = formats.length;
        for (var f = 0; f < formatCnt; f++) {
            if (formats[f].tag == id) {
                return formats[f];
            }
        }
        return null;
    },

    initializeUI: function(tbGenerator) {
        var plg = CUI.rte.plugins;
        var ui = CUI.rte.ui;
        if (this.isFeatureEnabled("paraformat")) {
            this.formatUI = tbGenerator.createParaFormatter("paraformat", this, null,
                    this.getFormats());
            tbGenerator.addElement("paraformat", plg.Plugin.SORT_PARAFORMAT, this.formatUI,
                    10);
        }
    },

    notifyPluginConfig: function(pluginConfig) {
        pluginConfig = pluginConfig || { };
        var defaults = {
            "formats": [ {
                    "tag": "p",
                    "description": CUI.rte.Utils.i18n("Paragraph")
                }, {
                    "tag": "h1",
                    "description": CUI.rte.Utils.i18n("Heading 1")
                }, {
                    "tag": "h2",
                    "description": CUI.rte.Utils.i18n("Heading 2")
                }, {
                    "tag": "h3",
                    "description": CUI.rte.Utils.i18n("Heading 3")
                }
            ]
        };
        // remove predefined formats if userdefined formats are specified; otherwise both
        // would get merged
        if (pluginConfig.formats) {
            delete defaults.formats;
        }
        CUI.rte.Utils.applyDefaults(pluginConfig, defaults);
        this.config = pluginConfig;
    },

    execute: function(cmd) {
        if (this.formatUI) {
            var formatId = this.formatUI.getSelectedFormat();
            if (formatId) {
                this.editorKernel.relayCmd("format", this.getFormatById(this.getFormats(),
                        formatId));
            }
        }
    },

    updateState: function(selDef) {
        if (!this.formatUI) {
            return;
        }
        var com = CUI.rte.Common;
        var dpr = CUI.rte.DomProcessor;
        var formatToSelect = null;
        var nodeList = selDef.nodeList;
        var nodeToCheck = nodeList.commonAncestor;
        var hasParentFormat = false;
        var formats = { };
        var noFormatCnt = 0;
        var formatCnt = 0;
        var auxRoot = null;
        while (nodeToCheck) {
            if (nodeToCheck.nodeType == 1) {
                formatToSelect = this.getFormatId(nodeToCheck);
                if (formatToSelect) {
                    formats[formatToSelect] = true;
                    hasParentFormat = true;
                    formatCnt++;
                    break;
                } else if (com.isTag(nodeToCheck, dpr.AUXILIARY_ROOT_TAGS)) {
                    if (auxRoot == null) {
                        auxRoot = nodeToCheck;
                    }
                }
            }
            nodeToCheck = nodeToCheck.parentNode;
        }
        // check first level nodes also, if no parent format has been detected
        if (!hasParentFormat) {
            var nodeCnt = nodeList.nodes.length;
            for (var nodeIndex = 0; nodeIndex < nodeCnt; nodeIndex++) {
                nodeToCheck = nodeList.nodes[nodeIndex];
                if (nodeToCheck.dom.nodeType == 1) {
                    var newFormat = this.getFormatId(nodeToCheck.dom);
                    if (newFormat) {
                        if (!formats[newFormat]) {
                            formats[newFormat] = true;
                            formatCnt++;
                        }
                        if (formatToSelect == null) {
                            formatToSelect = newFormat;
                        }
                    } else {
                        noFormatCnt++;
                    }
                } else {
                    noFormatCnt++;
                }
            }
        }
        this.formatUI.selectFormat(formatToSelect, auxRoot, formatCnt, noFormatCnt);
    }

});


// register plugin
CUI.rte.plugins.PluginRegistry.register("paraformat",
        CUI.rte.plugins.ParagraphFormatPlugin);
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.plugins.StylesPlugin
 * @extends CUI.rte.plugins.Plugin
 * <p>This class implements styling text fragments with a CSS class (using "span" tags) as a
 * plugin.</p>
 * <p>The plugin ID is "<b>styles</b>".</p>
 * <p><b>Features</b></p>
 * <ul>
 *   <li><b>styles</b> - adds a style selector (styles will be applied on selection scope)
 *     </li>
 * </ul>
 */
CUI.rte.plugins.StylesPlugin = new Class({

    toString: "StylePlugin",

    extend: CUI.rte.plugins.Plugin,

    /**
     * @cfg {Object/Object[]} styles
     * <p>Defines CSS classes that are available to the user for formatting text fragments
     * (defaults to { }). There are two ways of specifying the CSS classes:</p>
     * <ol>
     *   <li>Providing styles as an Object: Use the CSS class name as property name.
     *   Specify the text that should appear in the style selector as property value
     *   (String).</li>
     *   <li>Providing styles as an Object[]: Each element has to provide "cssName" (the
     *   CSS class name) and "text" (the text that appears in the style selector)
     *   properties.</li>
     * </ol>
     * <p>Styling is applied by adding "span" elements with corresponding "class"
     * attributes appropriately.</p>
     * @since 5.3
     */

    /**
     * @private
     */
    cachedStyles: null,

    /**
     * @private
     */
    stylesUI: null,


    getFeatures: function() {
        return [ "styles" ];
    },

    reportStyles: function() {
        return [ {
                "type": "text",
                "styles": this.getStyles()
            }
        ];
    },

    getStyles: function() {
        var com = CUI.rte.Common;
        if (!this.cachedStyles) {
            this.cachedStyles = this.config.styles || { };
            com.removeJcrData(this.cachedStyles);
            this.cachedStyles = com.toArray(this.cachedStyles, "cssName", "text");
        }
        return this.cachedStyles;
    },

    initializeUI: function(tbGenerator) {
        var plg = CUI.rte.plugins;
        var ui = CUI.rte.ui;
        if (this.isFeatureEnabled("styles")) {
            this.stylesUI = new tbGenerator.createStyleSelector("styles", this, null,
                    this.getStyles());
            tbGenerator.addElement("styles", plg.Plugin.SORT_STYLES, this.stylesUI, 10);
        }
    },

    notifyPluginConfig: function(pluginConfig) {
        pluginConfig = pluginConfig || { };
        CUI.rte.Utils.applyDefaults(pluginConfig, {
            "styles": {
                // empty default value
            }
        });
        this.config = pluginConfig;
    },

    execute: function(cmdId) {
        if (!this.stylesUI) {
            return;
        }
        var cmd = null;
        var value = null;
        switch (cmdId.toLowerCase()) {
            case "styles":
                cmd = "applystyle";
                value = this.stylesUI.getSelectedStyle();
                break;
            case "styles_remove":
                cmd = "removestyle";
                value = {
                    "styles": this.getStyles()
                };
                break;
        }
        if (cmd) {
            this.editorKernel.relayCmd(cmd, value);
        }
    },

    updateState: function(selDef) {
        if (!this.stylesUI) {
            return;
        }
        var com = CUI.rte.Common;
        var styles = selDef.styles;
        var actualStyles = [ ];
        var indexToSelect, s;
        var styleableObject = selDef.selectedDom;
        if (styleableObject) {
            if (!CUI.rte.Common.isTag(selDef.selectedDom,
                    CUI.rte.plugins.StylesPlugin.STYLEABLE_OBJECTS)) {
                styleableObject = null;
            }
        }
        // TODO make toolkit independent
        var selectorDom = this.stylesUI.getSelectorDom();
        var stylesDef = this.getStyles();
        var styleCnt = stylesDef.length;
        if (styleableObject) {
            for (s = 0; s < styleCnt; s++) {
                var styleName = stylesDef[s].cssName;
                if (com.hasCSS(styleableObject, styleName)) {
                    actualStyles.push({
                        "className": styleName
                    });
                }
            }
        } else {
            var checkCnt = styles.length;
            for (var c = 0; c < checkCnt; c++) {
                var styleToProcess = styles[c];
                for (s = 0; s < styleCnt; s++) {
                    if (stylesDef[s].cssName == styleToProcess.className) {
                        actualStyles.push(styleToProcess);
                        break;
                    }
                }
            }
        }
        if (actualStyles.length == 0) {
            indexToSelect = 0;
        } else if (actualStyles.length > 1) {
            indexToSelect = -1;
        } else {
            if (selDef.isContinuousStyle || styleableObject) {
                var styleToSelect = actualStyles[0];
                var options = selectorDom.options;
                for (var optIndex = 0; optIndex < options.length; optIndex++) {
                    var optionToCheck = options[optIndex];
                    if (optionToCheck.value == styleToSelect.className) {
                        indexToSelect = optIndex;
                        break;
                    }
                }
            } else {
                indexToSelect = -1;
            }
        }
        selectorDom.selectedIndex = indexToSelect;
        if (styleableObject != null) {
            selectorDom.disabled = false;
            this.stylesUI.setRemoveDisabled(indexToSelect == 0);
        } else if (selDef.isSelection) {
            selectorDom.disabled = !((indexToSelect == 0) && this.getStyles());
            this.stylesUI.setRemoveDisabled(true);
        } else {
            this.stylesUI.setRemoveDisabled(indexToSelect == 0);
            selectorDom.disabled = true;
        }
    }

});

/**
 * Array with tag names that define objects (like images) that are styleable when selected
 * @private
 * @static
 * @final
 * @type String[]
 */
CUI.rte.plugins.StylesPlugin.STYLEABLE_OBJECTS = [
    "img"
];


// register plugin
CUI.rte.plugins.PluginRegistry.register("styles", CUI.rte.plugins.StylesPlugin);
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.plugins.SubSuperScriptPlugin
 * @extends CUI.rte.plugins.Plugin
 * <p>This class implements sub- and superscript as a plugin.</p>
 * <p>The plugin ID is "<b>subsuperscript</b>".</p>
 * <p><b>Features</b></p>
 * <ul>
 *   <li><b>subscript</b> - adds a button to format the selected text with subscript</li>
 *   <li><b>superscript</b> - adds a button to format the selected text with superscript
 *     </li>
 * </ul>
 */
CUI.rte.plugins.SubSuperScriptPlugin = new Class({

    toString: "SubSuperScriptPlugin",

    extend: CUI.rte.plugins.Plugin,

    /**
     * @private
     */
    subscriptUI: null,

    /**
     * @private
     */
    superscriptUI: null,


    getFeatures: function() {
        return [ "subscript", "superscript" ];
    },

    initializeUI: function(tbGenerator) {
        var plg = CUI.rte.plugins;
        var ui = CUI.rte.ui;
        if (this.isFeatureEnabled("subscript")) {
            this.subscriptUI = tbGenerator.createElement("subscript", this, true,
                    this.getTooltip("subscript"));
            tbGenerator.addElement("format", plg.Plugin.SORT_FORMAT, this.subscriptUI, 100);
        }
        if (this.isFeatureEnabled("superscript")) {
            this.superscriptUI = tbGenerator.createElement("superscript", this, true,
                    this.getTooltip("superscript"));
            tbGenerator.addElement("format", plg.Plugin.SORT_FORMAT, this.superscriptUI,
                    110);
        }
    },

    execute: function(id) {
        this.editorKernel.relayCmd(id);
    },

    updateState: function(selDef) {
        var hasSubscript = this.editorKernel.queryState("subscript", selDef);
        var hasSuperscript = this.editorKernel.queryState("superscript", selDef);
        if (this.subscriptUI != null) {
            this.subscriptUI.setDisabled(!selDef.isSelection);
            this.subscriptUI.setSelected(hasSubscript);
        }
        if (this.superscriptUI != null) {
            this.superscriptUI.setDisabled(!selDef.isSelection);
            this.superscriptUI.setSelected(hasSuperscript);
        }
    },

    notifyPluginConfig: function(pluginConfig) {
        // configuring "special characters" dialog
        pluginConfig = pluginConfig || { };
        var defaults = {
            "tooltips": {
                "subscript": {
                    "title": CUI.rte.Utils.i18n("Subscript"),
                    "text": CUI.rte.Utils.i18n("Formats the selected text as subscript.")
                },
                "superscript": {
                    "title": CUI.rte.Utils.i18n("Superscript"),
                    "text": CUI.rte.Utils.i18n("Formats the selected text as superscript.")
                }
            }
        };
        CUI.rte.Utils.applyDefaults(pluginConfig, defaults);
        this.config = pluginConfig;
    }

});


// register plugin
CUI.rte.plugins.PluginRegistry.register("subsuperscript",
        CUI.rte.plugins.SubSuperScriptPlugin);
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.plugins.TablePlugin
 * @extends CUI.rte.plugins.Plugin
 * <p>This class implements table functionality as a plugin.</p>
 * <p>The plugin ID is "<b>table</b>".</p>
 * <p><b>Features</b></p>
 * <ul>
 *   <li><b>table</b> - adds a button/context menu entry for creating new tables and editing
 *     the properties of existing tables</li>
 *   <li><b>removetable</b> - adds a context menu entry for removing a table</li>
 *   <li><b>insertrow</b> - adds a context menu entry for inserting a table row</li>
 *   <li><b>removerow</b> - adds a context menu entry for removing an existing table row
 *     </li>
 *   <li><b>insertcolumn</b> - adds a context menu entry for inserting a table column</li>
 *   <li><b>removecolumn</b> - adds a context menu entry for removing a table column</li>
 *   <li><b>cellprops</b> - adds a context menu entry for editing cell properties</li>
 *   <li><b>mergecells</b> - adds a context menu entry for merging selected cells (added in
 *     5.3)</li>
 *   <li><b>splitcell</b> - adds a context menu entry for splitting an existing cell (added
 *     in 5.3)</li>
 *   <li><b>selectrow</b> - adds a context menu entry for selecting an entire row (added in
 *     5.3)</li>
 *   <li><b>selectcolumn</b> - adds a context menu entry for selecting an entire column
 *     (added in 5.3)</li>
 * </ul>
 */
CUI.rte.plugins.TablePlugin = new Class({

    toString: "TablePlugin",

    extend: CUI.rte.plugins.Plugin,

    /**
     * @cfg {String} editMode
     * <p>Specifies the edit mode the RichText component is running (defaults to "default").
     * "table" represents the table mode which is used to allow editing a single table
     * only.<p>
     * <p>In table mode, the following restrictions apply:</p>
     * <ul>
     *   <li>The user can not enter text outside the table boundaries.</li>
     *   <li>The "Create table" context menu item is not available.</li>
     *   <li>The "Remove table" context menu item is not available.</li>
     * </ul>
     * <p>Note that there might be additional differences on the plugin-level; for
     * example the "table" plugin will add several icons to the toolbar in table mode,
     * which won't appear in default mode. Also note that in table mode, the "table" plugin
     * is automatically enabled with all features if you don't specify a specific
     * configuration for the table plugin (see {@link #rtePlugins}).</p>
     * @since 5.3
     */

    /**
     * @cfg {Object} defaultValues
     * <p>The default values for for newly created tables. May have the following
     * properties:</p>
     * <ul>
     *   <li><code>columns</code> : String<br>
     *     The initial number of columns of the table</li>
     *   <li><code>rows</code> : String<br>
     *     The initial number of rows of the table</li>
     *   <li><code>header</code> : String<br>
     *     Defines if the table should contain headers; valid values are: "none" for no
     *     headers, "top" for creating header cells for the first row, "left" for
     *     creating header cells for the first column, "topleft" for creating header
     *     cells for the first row and the first column</li>
     *   <li><code>width</code> : String (optional)<br>
     *     The initial table width</li>
     *   <li><code>height</code> : String (optional)<br>
     *     The initial table height</li>
     *   <li><code>cellspacing</code> : String (optional)<br>
     *     The initial cell spacing value of the table</li>
     *   <li><code>cellpadding</code> : String (optional)<br>
     *     The initial cell padding value of the table</li>
     *   <li><code>border</code> : String (optional)<br>
     *     The initial border value of the table</li>
     *   <li><code>tableTemplate</code> : String<br>
     *     A HTML template for creating the table</li>
     * </ul>
     * <p>Note that all properties should be provided as Strings.</p>
     * <p>Notes on using templates for creating a new table:</p>
     * <ul>
     *   <li>If you are specifying a table template (using the tableTemplate property), all
     *     other table properties are ignored. Templates take precedence over all other
     *     properties.</li>
     *   <li>The template must contain plain HTML code only. Currently no placeholders are
     *     supported.</li>
     * </ul>
     * <p>Defaults to: { "cellspacing": "0", "cellpadding": "1", "border": "1", "columns":
     * "3", "rows": "2", "header": "none", "tableTemplate": null }</p>
     * @since 5.3
     */

    /**
     * @cfg {Object/Object[]} tableStyles
     * <p>Defines CSS classes that are available to the user for styling a table. There are
     * two ways of specifying each table style:</p>
     * <ol>
     *   <li>Providing tableStyles as an Object: Use the CSS class name as property name.
     *   Specify the text that should appear in the style selector as property value
     *   (String).</li>
     *   <li>Providing tableStyles as an Object[]: Each element has to provide "cssName"
     *   (the CSS class name) and "text" (the text that appears in the style selector)
     *   properties.</li>
     * </ol>
     * <p>Styling is applied by adding a corresponding "class" attribute to the table
     * element appropriately.</p>
     * <p>Defaults to null.</p>
     * @since 5.3
     */

    /**
     * @cfg {Object} tablePropConfig
     * <p>This object configures the table properties dialog. It consists of the following
     * properties:</p>
     * <ul>
     *   <li><code>tableStyles</code> : Object<br>
     *     Object that defines the styles that are available for styling a table. This was
     *     the way of defining table styles for CQ 5.2. This is deprecated now; use
     *     {@link #tableStyles} as of CQ 5.3.</li>
     *   <li><code>defaultValues</code> : Object<br>
     *     Object that defines the default values for newly created tables. This was the
     *     way of defining default values for CQ 5.2. This is deprecated now; use
     *     {@link #defaultValues} as of CQ 5.3.</li>
     * </ul>
     * <p>Defaults to null (as of CQ 5.3) or (CQ 5.2):
<pre>
{
    "tableStyles": null,
    "defaultValues": {
        "cellspacing": "0",
        "cellpadding": "1",
        "border": "1",
        "columns": "3",
        "rows": "2",
        "header": "none"
    }
}
</pre>
     */

    /**
     * @cfg {Object|Object[]} cellStyles
     * <p>Defines CSS classes that are available to the user for styling a table cell. There
     * are two ways of specifying the CSS classes:</p>
     * <ol>
     *   <li>Providing cellStyles as an Object: Use the CSS class name as property name.
     *   Specify the text that should appear in the style selector as property value
     *   (String).</li>
     *   <li>Providing cellStyles as an Object[]: Each element has to provide "cssName" (the
     *   CSS class name) and "text" (the text that appears in the style selector)
     *   properties.</li>
     * </ol>
     * <p>Defaults to null</p>
     * @since 5.3
     */

    /**
     * @cfg {Object} cellPropConfig
     * <p>This object configures the cell properties dialog. It consists of the following
     * properties:</p>
     * <ul>
     *   <li><code>cellStyles</code> : Object<br>
     *     Object that defines the styles that are available for styling a table cell. This
     *     was the way of defining cell styles for CQ 5.2. This is deprecated now; use
     *     {@link #cellStyles} as of CQ 5.3.</li>
     *     </li>
     * </ul>
     * <p>Defaults to null (as of CQ 5.3) resp. { "cellStyles": null } (CQ 5.2)</p>
     */

    /**
     * @private
     */
    tableUI: null,

    /**
     * @private
     */
    insertRowBeforeUI: null,

    /**
     * @private
     */
    insertRowAfterUI: null,

    /**
     * @private
     */
    removeRowUI: null,

    /**
     * @private
     */
    insertColBeforeUI: null,

    /**
     * @private
     */
    insertColAfterUI: null,

    /**
     * @private
     */
    removeColUI: null,

    /**
     * @private
     */
    tableSelection: null,

    _init: function(editorKernel) {
        this.inherited(arguments);
        editorKernel.addPluginListener("mousedown", this.clearSelectionHandler, this,
                this, false);
        editorKernel.addPluginListener("mouseup", this.addSelectionHandler, this,
                this, false);
        editorKernel.addPluginListener("keydown", this.handleSelectionOnKey, this,
                this, false);
        editorKernel.addPluginListener("commandexecuted", this.clearSelectionHandler, this,
                this, false);
        editorKernel.addPluginListener("beforekeydown", this.handleTableKeys, this,
                this, false, 250);
    },

    isTableMode: function() {
        return (this.config.editMode == CUI.rte.plugins.TablePlugin.EDITMODE_TABLE);
    },

    handleTableKeys: function(e) {
        if (e.cancelKey) {
            return;
        }
        var com = CUI.rte.Common;
        var sel = CUI.rte.Selection;
        var context = e.editContext;
        var selection;

        // IE allows selections outside a table in table edit mode; ignore keystrokes there
        // if necessary
        if (this.isTableMode()) {
            if (com.ua.isIE) {
                selection = this.editorKernel.createQualifiedSelection(context);
                if (!selection || com.isRootNode(context, selection.startNode)) {
                    var cells = com.getChildNodesByType(context.root, [ "th", "td" ], true,
                            "table");
                    if (cells.length > 0) {
                        var cellToSelect;
                        if (selection && (selection.startOffset == 0)) {
                            cellToSelect = cells[0];
                        } else {
                            cellToSelect = cells[cells.length - 1];
                        }
                        sel.selectNode(context, cellToSelect, true);
                    }
                    e.cancelKey = true;
                }
            }
        }
        // handle Tab key
        if (e.isTab() && !e.cancelKey) {
            // handle Tab in Tables differently (jump to next cell, or insert a new row
            // at the end of the table)
            if (!selection) {
                selection = this.editorKernel.createQualifiedSelection(context);
            }
            if (!sel.isSelection(selection)) {
                this.editorKernel.execCmd("addundostep");
                var tableCell = CUI.rte.commands.Table.getCellFromSelection(
                        context, selection);
                if (tableCell) {
                    var nextCell;
                    var row = tableCell.parentNode;
                    cells = com.getChildNodesByType(row, com.TABLE_CELLS, false);
                    var cellIndex = com.arrayIndex(cells, tableCell) + 1;
                    if (cellIndex < cells.length) {
                        nextCell = cells[cellIndex];
                    } else {
                        var rowParent = row.parentNode;
                        var rows = com.getChildNodesByType(rowParent, "tr", false);
                        var rowIndex = com.arrayIndex(rows, row) + 1;
                        if (rowIndex < rows.length) {
                            row = rows[rowIndex];
                            cells = com.getChildNodesByType(row, com.TABLE_CELLS, false);
                            nextCell = cells[0];
                        }
                    }
                    if (nextCell == null) {
                        this.editorKernel.relayCmd("insertrow", {
                            "position": "after",
                            "caret": "firstCell"
                        });
                    }
                    if (nextCell != null) {
                        var preferredScrollOffset = (com.ua.isIE ? null
                                : sel.getPreferredScrollOffset(context));
                        sel.selectNode(context, nextCell, true);
                        if (com.ua.isGecko && context.iFrame) {
                            sel.ensureCaretVisibility(context, context.iFrame,
                                    preferredScrollOffset);
                        }
                    }
                    e.cancelKey = true;
                }
            }
        }
    },

    handleSelectionOnKey: function(e) {
        if (this.tableSelection) {
            if (e.isBackSpace() || e.isDelete()) {
                this.clearSelectionContent(e.editContext);
            }
        }
        this.clearSelectionHandler(e);
    },

    /**
     * @private
     */
    addSelectionHandler: function(e) {
        var com = CUI.rte.Common;
        var sel = CUI.rte.Selection;
        var cancelEvent = false;
        var addToSelection = (e.getType() == "mouseup") && (e.getButton() == 0)
                && e.isCtrl();
        if (addToSelection && (com.ua.isIE || com.ua.isWebKit)) {
            var context = e.editContext;
            var pSelection = sel.createProcessingSelection(context);
            var cell = CUI.rte.commands.Table.getCellFromSelection(context, pSelection);
            if (cell) {
                if (cell) {
                    this.addCellToSelection(cell);
                    e.preventDefault();
                }
                cancelEvent = true;
            }
        }
        return cancelEvent;
    },

    /**
     * @private
     */
    clearSelectionHandler: function(e) {
        var com = CUI.rte.Common;
        var context = e.editContext;
        var type = e.getType();
        var addToSelection = (type == "mousedown") && (e.getButton() == 0)
                && e.isCtrl();
        if (this.tableSelection) {
            var removeSelection = false;
            if (type == "keydown") {
                var key = e.getKey();
                if (key >= 32) {
                    // additionaly filter Cmd key on Mac - otherwise the selection would
                    // get removed if the user releases Cmd and presses it again to add
                    // further cells to the selection
                    if (!com.ua.isMac || (key != 91)) {
                        removeSelection = true;
                    }
                }
            } else if (type == "mousedown") {
                removeSelection = !addToSelection && (e.getButton() != 2);
            } else if (type == "commandexecuted") {
                switch (e.cmd) {
                    case "removetable":
                        this.tableSelection = null;
                        break;
                    case "addundostep":
                    case "clearredohistory":
                        break;
                    default:
                        removeSelection = true;
                        break;
                }
            }
            if (removeSelection) {
                this.removeTableSelection();
            }
        }
        if (type == "commandexecuted") {
            if (com.ua.isGecko) {
                var flushSelection = false;
                // this should be sufficient to detect table selections in an easy way
                var selection = e.editContext.win.getSelection();
                if (selection.rangeCount > 1) {
                    flushSelection = true;
                } else if (selection.rangeCount == 1) {
                    var rangeToCheck = selection.getRangeAt(0);
                    var parentDom = rangeToCheck.commonAncestorContainer;
                    if (parentDom && (com.getTagInPath(context, parentDom, "table"))) {
                        flushSelection = true;
                    }
                }
                if (flushSelection) {
                    CUI.rte.Selection.flushSelection(e.editContext, true);
                }
            }
        }
    },

    /**
     * @private
     */
    addTableSelection: function(selectionDef) {
        var com = CUI.rte.Common;
        if (this.tableSelection) {
            this.removeTableSelection();
        }
        var cellCnt = selectionDef.length;
        for (var c = 0; c < cellCnt; c++) {
            var cell = selectionDef[c];
            com.addClass(cell, CUI.rte.Theme.TABLESELECTION_CLASS);
        }
        this.tableSelection = selectionDef;
    },

    /**
     * @private
     */
    addCellToSelection: function(cellToAdd) {
        var com = CUI.rte.Common;
        if (!this.tableSelection) {
            this.tableSelection = [ ];
        }
        com.addClass(cellToAdd, CUI.rte.Theme.TABLESELECTION_CLASS);
        this.tableSelection.push(cellToAdd);
    },

    /**
     * @private
     */
    removeTableSelection: function() {
        var com = CUI.rte.Common;
        var cellCnt = this.tableSelection.length;
        for (var c = 0; c < cellCnt; c++) {
            var cell = this.tableSelection[c];
            com.removeClass(cell, CUI.rte.Theme.TABLESELECTION_CLASS);
        }
        this.tableSelection = null;
    },

    /**
     * @private
     */
    clearSelectionContent: function(context) {
        var dpr = CUI.rte.DomProcessor;
        var cellCnt = this.tableSelection.length;
        for (var c = 0; c < cellCnt; c++) {
            var cell = this.tableSelection[c];
            var nodeCnt = cell.childNodes.length;
            for (var n = nodeCnt - 1; n >= 0; n--) {
                cell.removeChild(cell.childNodes[0]);
            }
            var placeholder = dpr.createEmptyLinePlaceholder(context, false);
            if (placeholder) {
                cell.appendChild();
            }
        }
    },

    /**
     * @private
     */
    createOrEditTable: function(options, enforceNewTable) {
        var context = options.editContext;
        this.savedRange = options.savedRange;
        this.editorKernel.selectQualifiedRangeBookmark(context, this.savedRange);
        var table = this.editorKernel.queryState("table");
        var propConfig;
        var tableTemplate = null;
        if (table && !enforceNewTable) {
            // change properties
            propConfig = {
                "editContext": context,
                "cmd": "modifytable",
                "table": table
            };
        } else {
            // create new table
            tableTemplate = CUI.rte.Compatibility.getConfigValue(this.config,
                    "defaultValues.tableTemplate");
            if (!tableTemplate) {
                propConfig = {
                    "cmd": "createtable",
                    "table": null
                };
            }
        }
        var editorKernel = this.editorKernel;
        if (!tableTemplate && propConfig) {
            propConfig.listeners = {
                "show": function() {
                    editorKernel.fireUIEvent("dialogshow");
                },
                "hide": function() {
                    editorKernel.fireUIEvent("dialoghide");
                }
            };
        }
        if (tableTemplate) {
            // create new table directly through template
            this.editorKernel.selectQualifiedRangeBookmark(context, this.savedRange);
            this.editorKernel.relayCmd("createtable", {
                "html": tableTemplate
            });
        } else {
            // display table properties dialog
            propConfig.editContext = context;
            propConfig.pluginConfig = this.config;
            propConfig.execFn = CUI.rte.Utils.scope(this.execCreateOrEditTable, this);
            var dm = this.editorKernel.getDialogManager();
            var dialog = dm.create(CUI.rte.ui.DialogManager.DLG_TABLEPROPS, propConfig);
            dm.show(dialog);
        }
    },

    /**
     * @private
     */
    execCreateOrEditTable: function(cmd, tableConfig, context) {
        this.editorKernel.selectQualifiedRangeBookmark(context, this.savedRange);
        if (cmd && tableConfig) {
            this.editorKernel.relayCmd(cmd, tableConfig);
        }
    },

    /**
     * @private
     */
    editCellProps: function(options) {
        var context = options.editContext;
        this.savedRange = options.savedRange;
        this.editorKernel.selectQualifiedRangeBookmark(context, this.savedRange);
        var cell;
        if (options && options.selectionContext) {
            // should not use queryState("modifycell") for context menu invoking, as IE's
            // selection handling is way too buggy to get/set a valid range/selection at
            // this point, so prefer selection if provided on plugin call
            var selectionContext = options.selectionContext;
            cell = CUI.rte.commands.Table.getCellFromNodeList(context,
                    selectionContext.nodeList);
        } else {
            // it is safe to use queryState for toolbar-invoked plugin calls
            cell = this.editorKernel.queryState("modifycell");
        }
        if (!cell) {
            return;
        }
        var cfg = {
            "editContext": context,
            "pluginConfig": this.config,
            "cell": cell,
            "execFn": CUI.rte.Utils.scope(this.execEditCellProps, this)
        };
        var dm = this.editorKernel.getDialogManager();
        var dialog = dm.create(CUI.rte.ui.DialogManager.DLG_CELLPROPS, cfg);
        dm.show(dialog);
    },

    /**
     * @private
     */
    execEditCellProps: function(cellConfig, context) {
        this.editorKernel.selectQualifiedRangeBookmark(context, this.savedRange);
        if (cellConfig) {
            this.editorKernel.relayCmd("modifyCell", cellConfig);
        }
    },

    /**
     * @private
     */
    selectRow: function(def) {
        var tableMatrix = def.tableMatrix;
        var cell = def.cell;
        var cellDef = tableMatrix.getCellDef(cell);
        var row = tableMatrix.getRow(cellDef.row);
        var cells = [ ];
        for (var c = 0; c < row.length; c++) {
            cells[c] = row[c].cellDom;
        }
        this.addTableSelection(cells);
    },

    /**
     * @private
     */
    selectColumn: function(def) {
        var tableMatrix = def.tableMatrix;
        var cell = def.cell;
        var cellDef = tableMatrix.getCellDef(cell);
        var column = tableMatrix.getColumn(cellDef.col);
        var cells = [ ];
        for (var c = 0; c < column.length; c++) {
            cells[c] = column[c].cellDom;
        }
        this.addTableSelection(cells);
    },

    /**
     * @private
     */
    getFeatures: function() {
        // must be overridden by implementing plugins
        return [
            "table", "removetable", "insertrow", "removerow", "insertcolumn",
            "removecolumn", "cellprops", "mergecells", "splitcell",
            "selectrow", "selectcolumn"
        ];
    },

    reportStyles: function() {
        var compat = CUI.rte.Compatibility;
        var styles = [ ];
        var tableStyles = this.config.tableStyles;
        if (tableStyles != null) {
            tableStyles = compat.convertToArray(tableStyles, "cssName", "text");
            compat.changeDeprecatedPropertyName(tableStyles, "className", "cssName");
            styles.push({
                "type": "table",
                "styles": tableStyles
            });
        }
        var cellStyles = this.config.cellStyles;
        if (cellStyles != null) {
            cellStyles = compat.convertToArray(cellStyles, "cssName", "text");
            compat.changeDeprecatedPropertyName(cellStyles, "className", "cssName");
            styles.push({
                "type": "cell",
                "styles": cellStyles
            });
        }
        return (styles.length > 0 ? styles : null);
    },

    notifyPluginConfig: function(pluginConfig) {
        pluginConfig = pluginConfig || { };
        CUI.rte.Utils.applyDefaults(pluginConfig, {
            "tableStyles": null,
            "cellStyles": null,
            "defaultValues": {
                "cellspacing": "0",
                "cellpadding": "1",
                "border": "1",
                "columns": "3",
                "rows": "2",
                "header": "none"
            },
            "tablePropConfig": {
                "basicDefs": true,
                "basicStyling": true
            },
            "cellPropConfig": {
                "basicDefs": true
            },
            "tooltips": {
                "table": {
                    "title": CUI.rte.Utils.i18n("Table"),
                    "text": CUI.rte.Utils.i18n("Creates a new table or edits the properties of an existing table.")
                },
                "cellprops": {
                    "title": CUI.rte.Utils.i18n("Cell"),
                    "text": CUI.rte.Utils.i18n("Edit the properties of a selected cell.")
                },
                "insertrow-before": {
                    "title": CUI.rte.Utils.i18n("Insert Above"),
                    "text": CUI.rte.Utils.i18n("Insert a new row above the current row.")
                },
                "insertrow-after": {
                    "title": CUI.rte.Utils.i18n("Insert Below"),
                    "text": CUI.rte.Utils.i18n("Insert a new row below the current row.")
                },
                "removerow":  {
                    "title": CUI.rte.Utils.i18n("Delete Row"),
                    "text": CUI.rte.Utils.i18n("Delete the current row.")
                },
                "insertcolumn-before": {
                    "title": CUI.rte.Utils.i18n("Insert Left"),
                    "text": CUI.rte.Utils.i18n("Insert a new column to the left of the current column.")
                },
                "insertcolumn-after": {
                    "title": CUI.rte.Utils.i18n("Insert Right"),
                    "text": CUI.rte.Utils.i18n("Insert a new column to the right of the current column.")
                },
                "removecolumn":  {
                    "title": CUI.rte.Utils.i18n("Delete Column"),
                    "text": CUI.rte.Utils.i18n("Delete the current column.")
                }
            }
        });
        this.config = pluginConfig;
    },

    /**
     * @private
     */
    initializeUI: function(tbGenerator) {
        var plg = CUI.rte.plugins;
        var ui = CUI.rte.ui;
        // todo use correct tooltips for table mode buttons
        if (!this.isTableMode()) {
            if (this.isFeatureEnabled("table")) {
                this.tableUI = tbGenerator.createElement("table", this, false,
                        this.getTooltip("table"));
                tbGenerator.addElement("table", plg.Plugin.SORT_TABLE, this.tableUI, 10);
            }
        } else {
            // use a more detailed toolbar in table mode
            if (this.isFeatureEnabled("table")) {
                this.tableUI = tbGenerator.createElement("table", this, false,
                        this.getTooltip("table"), "x-edit-table-properties");
                tbGenerator.addElement("table", plg.Plugin.SORT_TABLE_TABLEMODE,
                        this.tableUI, 10);
            }
            if (this.isFeatureEnabled("cellprops")) {
                this.cellPropsUI = tbGenerator.createElement("cellprops", this, false,
                        this.getTooltip("cellprops"));
                tbGenerator.addElement("table", plg.Plugin.SORT_TABLE_TABLEMODE,
                        this.cellPropsUI, 20);
            }
            if (this.isFeatureEnabled("insertrow")) {
                this.insertRowBeforeUI = tbGenerator.createElement("insertrow-before", this,
                        false, this.getTooltip("insertrow-before"), null, {
                            "cmd": "insertrow",
                            "cmdValue": "before"
                        });
                tbGenerator.addElement("table.row", plg.Plugin.SORT_TABLE_TABLEMODE + 1,
                        this.insertRowBeforeUI, 10);
                this.insertRowAfterUI = tbGenerator.createElement("insertrow-after", this,
                        false, this.getTooltip("insertrow-after"), null, {
                            "cmd": "insertrow",
                            "cmdValue": "after"
                        });
                tbGenerator.addElement("table.row", plg.Plugin.SORT_TABLE_TABLEMODE + 1,
                        this.insertRowAfterUI, 20);
            }
            if (this.isFeatureEnabled("removerow")) {
                this.removeRowUI = tbGenerator.createElement("removerow", this, false,
                    this.getTooltip("removerow"));
                tbGenerator.addElement("table.row", plg.Plugin.SORT_TABLE_TABLEMODE + 1,
                        this.removeRowUI, 30);
            }
            if (this.isFeatureEnabled("insertcolumn")) {
                this.insertColBeforeUI = tbGenerator.createElement("insertcolumn-before",
                        this, false, this.getTooltip("insertcolumn-before"), null, {
                            "cmd": "insertcolumn",
                            "cmdValue": "before"
                        });
                tbGenerator.addElement("table.col", plg.Plugin.SORT_TABLE_TABLEMODE + 2,
                        this.insertColBeforeUI, 10);
                this.insertColAfterUI = tbGenerator.createElement("insertcolumn-after",
                        this, false, this.getTooltip("insertcolumn-after"), null, {
                            "cmd": "insertcolumn",
                            "cmdValue": "after"
                        });
                tbGenerator.addElement("table.col", plg.Plugin.SORT_TABLE_TABLEMODE + 2,
                        this.insertColAfterUI, 20);
            }
            if (this.isFeatureEnabled("removecolumn")) {
                this.removeColUI = tbGenerator.createElement("removecolumn", this, false,
                        this.getTooltip("removecolumn"));
                tbGenerator.addElement("table.col", plg.Plugin.SORT_TABLE_TABLEMODE + 2,
                        this.removeColUI, 30);
            }
        }
    },

    /**
     * @private
     */
    execute: function(cmdId, value, options) {
        var context = options.editContext;
        if (!options.savedRange) {
            options.savedRange = this.editorKernel.createQualifiedRangeBookmark(context);
        }
        var cmd = cmdId;
        var sepPos = cmdId.indexOf(".", cmdId);
        if (sepPos > 0) {
            cmd = cmdId.substring(0, sepPos);
            value = cmdId.substring(sepPos + 1, cmdId.length);
        }
        if (cmd == "table") {
            this.createOrEditTable(options, false);
        } else if (cmd == "createtable") {
            this.createOrEditTable(options, true);
        } else if (cmd == "cellprops") {
            this.editCellProps(options);
        } else if (cmd == "selectrow") {
            this.selectRow(value);
            this.editorKernel.deferFocus();
        } else if (cmd == "selectcolumn") {
            this.selectColumn(value);
            this.editorKernel.deferFocus();
        } else {
            this.editorKernel.relayCmd(cmd, value);
        }
    },

    /**
     * @private
     */
    updateState: function(selDef) {
        if (this.isTableMode()) {
            var context = selDef.editContext;
            var com = CUI.rte.Common;
            var nodeList = selDef.nodeList;
            var singleCell = CUI.rte.commands.Table.getCellFromNodeList(context,
                    nodeList);
            var isSingleCell = (singleCell != null);
            var tableDom = com.getTagInPath(context, nodeList.commonAncestor, "table");
            if (tableDom) {
                var tableMatrix = new CUI.rte.TableMatrix();
                tableMatrix.createTableMatrix(tableDom);
                var size = tableMatrix.getTableSize();
                this.removeRowUI.setDisabled((size.rows == 1) || !isSingleCell);
                this.removeColUI.setDisabled((size.cols == 1) || !isSingleCell);
                this.insertColBeforeUI.setDisabled(!isSingleCell);
                this.insertColAfterUI.setDisabled(!isSingleCell);
                this.insertRowBeforeUI.setDisabled(!isSingleCell);
                this.insertRowAfterUI.setDisabled(!isSingleCell);
            }
        }
    },

    /**
     * @private
     */
    handleContextMenu: function(menuBuilder, selDef, context) {
        var isTableMode = this.isTableMode();
        var com = CUI.rte.Common;
        var nodeList = selDef.nodeList;
        var selection = selDef.selection;
        var singleCell = CUI.rte.commands.Table.getCellFromNodeList(context, nodeList);
        var isSingleCell = (singleCell != null);
        var tableDom = com.getTagInPath(context, nodeList.commonAncestor, "table");
        var isTable = isSingleCell || (tableDom != null);
        var cellSel = null;
        var tableMatrix;
        var canRemoveCol = true;
        var canRemoveRow = true;
        if (isTable) {
            tableMatrix = new CUI.rte.TableMatrix();
            tableMatrix.createTableMatrix(tableDom);
            if (isTableMode) {
                var size = tableMatrix.getTableSize();
                canRemoveCol = (size.cols > 1);
                canRemoveRow = (size.rows > 1);
            }
        }
        if (isTable && !isSingleCell) {
            if (selection.cellSelection) {
                cellSel = tableMatrix.createSelection(selection.cellSelection.cells);
            }
        }
        var cellSubItems = [ ];
        if (isSingleCell) {
            if (this.isFeatureEnabled("cellprops")) {
                cellSubItems.push({
                    "text": CUI.rte.Utils.i18n("Cell properties"),
                    "plugin": this,
                    "cmd": "cellprops",
                    "iconCls": "rte-cellprops"
                });
            }
        }
        if (cellSel != null) {
            if (this.isFeatureEnabled("mergecells")) {
                if (cellSel.selectionProps.isRect) {
                    cellSubItems.push({
                        "text": CUI.rte.Utils.i18n("Merge cells"),
                        "plugin": this,
                        "cmd": "mergecells",
                        "cmdValue": cellSel,
                        "iconCls": "rte-cellmerge"
                    });
                }
            }
        } else if (isSingleCell) {
            if (this.isFeatureEnabled("mergecells")) {
                var cellInfo = tableMatrix.getCellInfo(singleCell);
                if (!cellInfo.isLastCol) {
                    cellSel = tableMatrix.createSelection(singleCell);
                    cellSel.expand(1, 0);
                    if (cellSel.selectionProps.isRect) {
                        cellSubItems.push({
                            "text": CUI.rte.Utils.i18n("Merge right"),
                            "plugin": this,
                            "cmd": "mergecells",
                            "cmdValue": cellSel,
                            "iconCls": "rte-cellmerge"
                        });
                    }
                }
                if (!cellInfo.isLastRow) {
                    cellSel = tableMatrix.createSelection(singleCell);
                    cellSel.expand(0, 1);
                    if (cellSel.selectionProps.isRect) {
                        cellSubItems.push({
                            "text": CUI.rte.Utils.i18n("Merge down"),
                            "plugin": this,
                            "cmd": "mergecells",
                            "cmdValue": cellSel,
                            "iconCls": "rte-cellmerge"
                        });
                    }
                }
            }
        }
        if (isSingleCell) {
            if (this.isFeatureEnabled("splitcell")) {
                cellSubItems.push({
                    "text": CUI.rte.Utils.i18n("Split cell horizontally"),
                    "plugin": this,
                    "cmd": "splitcell",
                    "cmdValue": "horizontal",
                    "iconCls": "rte-cellsplit-horizontal"
                });
                cellSubItems.push({
                    "text": CUI.rte.Utils.i18n("Split cell vertically"),
                    "plugin": this,
                    "cmd": "splitcell",
                    "cmdValue": "vertical",
                    "iconCls": "rte-cellsplit-vertical"
                });
            }
        }
        if (cellSubItems.length > 0) {
            menuBuilder.addItem(menuBuilder.createItem({
                "text": CUI.rte.Utils.i18n("Cell"),
                "subItems": cellSubItems,
                "iconCls": "rte-cell"
            }));
        }

        if (isSingleCell) {
            var colSubItems = [ ];
            if (this.isFeatureEnabled("insertcolumn")) {
                colSubItems.push({
                    "text": CUI.rte.Utils.i18n("Insert before"),
                    "plugin": this,
                    "cmd": "insertcolumn",
                    "cmdValue": "before",
                    "iconCls": "rte-insertcolumn-before"
                });
                colSubItems.push({
                    "text": CUI.rte.Utils.i18n("Insert after"),
                    "plugin": this,
                    "cmd": "insertcolumn",
                    "cmdValue": "after",
                    "iconCls": "rte-insertcolumn-after"
                });
            }
            if (this.isFeatureEnabled("removecolumn") && canRemoveCol) {
                colSubItems.push({
                    "text": CUI.rte.Utils.i18n("Remove"),
                    "plugin": this,
                    "cmd": "removecolumn",
                    "iconCls": "rte-removecolumn"
                });
            }
            if (colSubItems.length > 0) {
                menuBuilder.addItem(menuBuilder.createItem({
                    "text": CUI.rte.Utils.i18n("Column"),
                    "subItems": colSubItems,
                    "iconCls": "rte-column"
                }));
            }
        }
        if (isSingleCell) {
            var rowSubItems = [ ];
            if (this.isFeatureEnabled("insertrow")) {
                rowSubItems.push({
                    "text": CUI.rte.Utils.i18n("Insert before"),
                    "plugin": this,
                    "cmd": "insertrow",
                    "cmdValue": "before",
                    "iconCls": "rte-insertrow-before"
                });
                rowSubItems.push({
                    "text": CUI.rte.Utils.i18n("Insert after"),
                    "plugin": this,
                    "cmd": "insertrow",
                    "cmdValue": "after",
                    "iconCls": "rte-insertrow-after"
                });
            }
            if (this.isFeatureEnabled("removerow") && canRemoveRow) {
                rowSubItems.push({
                    "text": CUI.rte.Utils.i18n("Remove"),
                    "plugin": this,
                    "cmd": "removerow",
                    "iconCls": "rte-removerow"
                });
            }
            if (rowSubItems.length > 0) {
                menuBuilder.addItem(menuBuilder.createItem({
                    "text": CUI.rte.Utils.i18n("Row"),
                    "subItems": rowSubItems,
                    "iconCls": "rte-row"
                }));
            }
            if (this.isFeatureEnabled("table")) {
                menuBuilder.addItem(menuBuilder.createItem({
                    "text": CUI.rte.Utils.i18n("Table properties"),
                    "plugin": this,
                    "cmd": "table",
                    "iconCls": "rte-tableprops"
                }));
            }
            if (this.isFeatureEnabled("removetable") && !isTableMode) {
                menuBuilder.addItem(menuBuilder.createItem({
                    "text": CUI.rte.Utils.i18n("Remove table"),
                    "plugin": this,
                    "cmd": "removetable",
                    "iconCls": "rte-removetable"
                }));
            }
            if (this.isFeatureEnabled("table")) {
                menuBuilder.addItem(menuBuilder.createItem({
                    "text": CUI.rte.Utils.i18n("Create nested table"),
                    "plugin": this,
                    "cmd": "createtable",
                    "iconCls": "rte-createtable"
                }));
            }
            var hasSeparator = false;
            if (this.isFeatureEnabled("selectrow") && isSingleCell) {
                if (!hasSeparator) {
                    menuBuilder.addItem(menuBuilder.createSeparator());
                    hasSeparator = true;
                }
                menuBuilder.addItem(menuBuilder.createItem({
                    "text": CUI.rte.Utils.i18n("Select entire row"),
                    "plugin": this,
                    "cmd": "selectrow",
                    "cmdValue": {
                        "tableMatrix": tableMatrix,
                        "cell": singleCell
                    }
                }));
            }
            if (this.isFeatureEnabled("selectcolumn") && isSingleCell) {
                if (!hasSeparator) {
                    menuBuilder.addItem(menuBuilder.createSeparator());
                    hasSeparator = true;
                }
                menuBuilder.addItem(menuBuilder.createItem({
                    "text": CUI.rte.Utils.i18n("Select entire column"),
                    "plugin": this,
                    "cmd": "selectcolumn",
                    "cmdValue": {
                        "tableMatrix": tableMatrix,
                        "cell": singleCell
                    }
                }));
            }
            if (!isTableMode) {
                var pNode = tableDom.parentNode;
                if (com.isRootNode(context, pNode)) {
                    var tableIndex = com.getChildIndex(tableDom);
                    if ((tableIndex == 0)
                            || com.isTag(pNode.childNodes[tableIndex - 1], "table")) {
                        menuBuilder.addItem(menuBuilder.createItem({
                            "text": CUI.rte.Utils.i18n("Insert paragraph before table"),
                            "plugin": this,
                            "cmd": "ensureparagraph",
                            "cmdValue": "before"
                        }));
                    }
                    if ((tableIndex == (pNode.childNodes.length - 1))
                            || com.isTag(pNode.childNodes[tableIndex + 1], "table")) {
                        menuBuilder.addItem(menuBuilder.createItem({
                            "text": CUI.rte.Utils.i18n("Insert paragraph after table"),
                            "plugin": this,
                            "cmd": "ensureparagraph",
                            "cmdValue": "after"
                        }));
                    }
                }
            }
        }
        var isObject = (selection.startNode.nodeType == 1) && !selection.endNode
                && (selection.startOffset == null);
        if (!isTable && !isObject) {
            if (this.isFeatureEnabled("table") && !isTableMode) {
                menuBuilder.addItem(menuBuilder.createItem({
                    "text": CUI.rte.Utils.i18n("Create table"),
                    "plugin": this,
                    "cmd": "table",
                    "iconCls": "rte-createtable"
                }));
            }
        }
    },

    /**
     * @private
     */
    manipulateSelection: function(selectionDef) {
        if (this.tableSelection) {
            selectionDef.cellSelection = {
                "cells": this.tableSelection,
                "otherContent": false
            };
        }
    },

    /**
     * @private
     */
    saveRangeBookmark: function(rangeBookmark) {
        if (this.tableSelection) {
            rangeBookmark.cells = this.tableSelection;
        }
    },

    /**
     * @private
     */
    restoreRangeBookmark: function(rangeBookmark) {
        if (rangeBookmark.cells) {
            this.addTableSelection(rangeBookmark.cells);
        }
    },

    /**
     * Creates HTML for a new table according to the plugin's configuration.
     * @private
     */
    createEmptyTableHTML: function() {
        var tableInit = this.config.defaultValues || { };
        if (tableInit.tableTemplate) {
            return tableInit.tableTemplate;
        }

        var colCnt = tableInit.columns || 1;
        var rowCnt = tableInit.rows || 1;
        var tableHtml = "<table";
        for (var attrib in tableInit) {
            if (tableInit.hasOwnProperty(attrib)) {
                var prefixPos = attrib.indexOf(":");
                var hasInvalidPrefix = false;
                if (prefixPos >= 0) {
                    var prefix = attrib.substring(0, prefixPos);
                    hasInvalidPrefix = (prefix == "jcr");
                }
                if ((attrib != "columns") && (attrib != "rows") && (attrib != "header")
                        && !hasInvalidPrefix) {
                    tableHtml += " " + attrib + "=\""
                            + CUI.rte.Utils.htmlEncode(tableInit[attrib]) + "\"";
                }
            }
        }
        tableHtml += ">";
        for (var r = 0; r < rowCnt; r++) {
            tableHtml += "<tr>";
            for (var c = 0; c < colCnt; c++) {
                tableHtml += CUI.rte.TableMatrix.createEmptyCellMarkup();
            }
            tableHtml += "</tr>";
        }
        tableHtml += "</table>";
        return tableHtml;
    },

    interceptContent: function(contentType, defs) {
        var com = CUI.rte.Common;
        var dpr = CUI.rte.DomProcessor;
        if (!this.isTableMode()) {
            return null;
        }
        var context = (defs ? defs.editContext : null);
        if (contentType == "emptyContent") {
            return this.createEmptyTableHTML();
        } else if (contentType == "postprocessDom") {
            CUI.rte.DomProcessor.removeNonTableBlocks(context);
        } else if (contentType == "cleanDom") {
            if (this.tableSelection) {
                this.removeTableSelection();
            }
            var body = defs.root;
            var table = CUI.rte.Query.select("table:first", body);
            if (table && (table.length == 1)) {
                var isEmpty = true;
                table = table[0];
                var cells = com.getChildNodesByType(table, [ "td", "th" ], true);
                for (var c = 0; c < cells.length; c++) {
                    var cellToCheck = cells[c];
                    if (cellToCheck.childNodes.length > 0) {
                        if (!dpr.isEmptyLinePlaceholder(cellToCheck)) {
                            isEmpty = false;
                            break;
                        }
                    }
                }
                if (isEmpty) {
                    table.parentNode.removeChild(table);
                }
            }
        }
        return null;
    }

});


/**
 * Constant that defines "default editing mode" (i.e. word processing)
 * @static
 * @final
 * @type String
 */
CUI.rte.plugins.TablePlugin.EDITMODE_DEFAULT = "default";

/**
 * Constant that defines "table editing mode" (will allow table content only; some other
 * restrictions apply)
 * @static
 * @final
 * @type String
 */
CUI.rte.plugins.TablePlugin.EDITMODE_TABLE = "table";


// register plugin
CUI.rte.plugins.PluginRegistry.register("table", CUI.rte.plugins.TablePlugin);
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.plugins.ImagePlugin
 * @extends CUI.rte.plugins.Plugin
 * <p>This class implements the editing of image properties as a plugin.</p>
 * <p>The plugin ID is "<b>image</b>".</p>
 * <p><b>Features</b></p>
 * <ul>
 *   <li><b>image</b> - adds context menu entries for setting some image properties
 *     (currently only alignment is supported)</li>
 * </ul>
 * @since 5.3
 */
CUI.rte.plugins.ImagePlugin = new Class({

    toString: "ImagePlugin",

    extend: CUI.rte.plugins.Plugin,


    getFeatures: function() {
        return [ "image" ];
    },

    notifyPluginConfig: function(pluginConfig) {
        this.config = pluginConfig;
    },

    initializeUI: function(tbGenerator) {
        // nothing to do yet, as we are not using the toolbar for images
    },

    execute: function(pluginCommand, value, envOptions) {
        // todo implement
        if (pluginCommand == "image") {
            this.editorKernel.relayCmd("image", value);
        }
    },

    updateState: function(selDef) {
        // must be overridden by implementing plugins
    },

    handleContextMenu: function(menuBuilder, selDef, context) {
        var subItems;
        var ui = CUI.rte.ui;
        if (this.isFeatureEnabled("image")) {
            if (this.editorKernel.queryState("image")) {
                subItems = [
                    {
                        "text": CUI.rte.Utils.i18n("Left"),
                        "plugin": this,
                        "cmd": "image",
                        "cmdValue": {
                            "style.float": "left"
                        }
                    }, {
                        "text": CUI.rte.Utils.i18n("Right"),
                        "plugin": this,
                        "cmd": "image",
                        "cmdValue": {
                            "style.float": "right"
                        }
                    }, {
                        "text": CUI.rte.Utils.i18n("None"),
                        "plugin": this,
                        "cmd": "image",
                        "cmdValue": {
                            "style.float": "none"
                        }
                    }, {
                        "text": CUI.rte.Utils.i18n("No alignment"),
                        "plugin": this,
                        "cmd": "image",
                        "cmdValue": {
                            "style.float": ""
                        }
                    }
                ];
                menuBuilder.addItem(menuBuilder.createItem({
                    "text": CUI.rte.Utils.i18n("Image alignment"),
                    "subItems": subItems
                }));
            }
        }
    }

});


// register plugin
CUI.rte.plugins.PluginRegistry.register("image", CUI.rte.plugins.ImagePlugin);
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.plugins.UndoRedoPlugin
 * @extends CUI.rte.plugins.Plugin
 * <p>This class implements undo/redo functionality as a plugin.</p>
 * <p>The plugin ID is "<b>undo</b>".</p>
 * <p><b>Features</b></p>
 * <ul>
 *   <li><b>undo</b> - adds a button for undoing a single undo step</li>
 *   <li><b>redo</b> - adds a button for redoing a single undo step</li>
 * </ul>
 * @since 5.3
 */
CUI.rte.plugins.UndoRedoPlugin = new Class({

    toString: "UndoRedoPlugin",

    extend: CUI.rte.plugins.Plugin,

    undoUI: null,

    redoUI: null,

    /**
     * @cfg {Number} maxUndoSteps
     * Number of maximum undo steps (defaults to 50); use 0 to disable undo/redo completely
     * @since 5.3
     */
    maxUndoSteps: 0,

    /**
     * Flag that determines if we are currently in a "Delete"-Sequence (which will be
     * recorded as a single undo step)
     * @type Boolean
     * @private
     */
    isDeleteSequence: false,

    /**
     * Flag that determines if we are currently in a "Caret movement"-Sequence (which will
     * be handled specially regarding undo undo)
     * @type Boolean
     * @private
     */
    isCaretMovement: false,

    _init: function(editorKernel) {
        this.inherited(arguments);
        editorKernel.addPluginListener("mouseup", this.addUndoStep, this, this, false);
        editorKernel.addPluginListener("beforekeydown", this.handleKeyDown, this, this,
                false);
        editorKernel.addPluginListener("keyup", this.handleKeyUp, this, this,
                false);
        editorKernel.addPluginListener("beforecommandexecuted", this.handleCommand, this,
                this, false);
        editorKernel.addPluginListener("commandexecuted", this.handleCommand, this, this,
                false);
    },

    addUndoStep: function() {
        this.editorKernel.execCmd("addundostep");
    },

    handleCommand: function(e) {
        if (!e.customCommand || e.customCommand.isUndoable(e.cmd)) {
            this.addUndoStep();
        }
    },

    handleKeyDown: function(e) {
        // todo will this prevent some undo action from being recorded?
        if (e.cancelKey) {
            return;
        }
        var key = e.getKey();
        var isControl = e.isCtrl();
        var isShift = e.isShift();
        var isUndoKey = isControl && !isShift && (key == 90);
        var isRedoKey = (isControl && !isShift && (key == 89))
                || (isShift && isControl && (key == 90));       // Cmd + Shift + Z on Mac
        if (isUndoKey || isRedoKey) {
            e.cancelKey = true;
            this.editorKernel.relayCmd(isUndoKey ? "undo" : "redo");
        } else if (e.isSpace()) {
            // record a undo step if the space bar has been pressed
            this.editorKernel.execCmd("addundostep");
        } else if ((e.isBackSpace()) || (e.isDelete())) {
            if (!this.isDeleteSequence) {
                this.editorKernel.execCmd("addundostep");
                this.isDeleteSequence = true;
            }
        } else if (e.isCaretMovement()) {
            if (!this.isCaretMovement) {
                this.editorKernel.execCmd("addundostep");
                this.isCaretMovement = true;
            }
        } else {
            if (this.isDeleteSequence || this.isCaretMovement) {
                if (this.isDeleteSequence) {
                    // take a snapshot of the content after the deletion sequence
                    this.editorKernel.execCmd("addundostep");
                }
                this.isDeleteSequence = false;
                this.isCaretMovement = false;
            }
            if ((key > 32) && (key != 224)) {
                this.editorKernel.execCmd("clearredohistory");
            }
        }
    },

    handleKeyUp: function(e) {
        if (e.isEnter()) {
            // record a undo step if return has been pressed
            this.editorKernel.execCmd("addundostep");
        }
    },

    getFeatures: function() {
        return [ "undo", "redo" ];
    },

    notifyPluginConfig: function(pluginConfig) {
        var defaults = {
            "maxUndoSteps": 50,
            "tooltips": {
                "undo": {
                    "title": CUI.rte.Utils.i18n("Undo"),
                    "text": CUI.rte.Utils.i18n("Undo the last change.")
                },
                "redo": {
                    "title": CUI.rte.Utils.i18n("Redo"),
                    "text": CUI.rte.Utils.i18n("Redo previously undone changes.")
                }
            }
        };
        CUI.rte.Utils.applyDefaults(pluginConfig, defaults);
        this.config = pluginConfig;
        var commandCfg = {
            "maxUndoSteps": this.config.maxUndoSteps
        };
        this.editorKernel.execCmd("undoconfig", commandCfg);
    },

    initializeUI: function(tbGenerator) {
        var plg = CUI.rte.plugins;
        if (this.isFeatureEnabled("undo")) {
            this.undoUI = new tbGenerator.createElement("undo", this, false,
                    this.getTooltip("undo"));
            tbGenerator.addElement("undo", plg.Plugin.SORT_UNDO, this.undoUI, 100);
        }
        if (this.isFeatureEnabled("redo")) {
            this.redoUI = new tbGenerator.createElement("redo", this, false,
                    this.getTooltip("redo"));
            tbGenerator.addElement("undo", plg.Plugin.SORT_UNDO, this.redoUI, 110);
        }
    },

    execute: function(pluginCommand, value, envOptions) {
        if (pluginCommand == "undo") {
            this.editorKernel.relayCmd("undo", value);
        } else if (pluginCommand == "redo") {
            this.editorKernel.relayCmd("redo", value);
        }
    },

    updateState: function(selectionDef) {
        if (this.undoUI) {
            this.undoUI.setDisabled(!this.editorKernel.queryState("undo", selectionDef));
        }
        if (this.redoUI) {
            this.redoUI.setDisabled(!this.editorKernel.queryState("redo", selectionDef));
        }
    }

});


// register plugin
CUI.rte.plugins.PluginRegistry.register("undo", CUI.rte.plugins.UndoRedoPlugin);
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * This class defines the toolkit abstraction layer for the underlying UI toolkit.
 * @class CUI.rte.ui.Toolkit
 */
CUI.rte.ui.Toolkit = new Class({

    toString: "Toolkit",

    initialize: function() {
        // can be overridden for additional initialization the first time the toolkit
        // is acquired
    },

    requiresInit: function() {
        throw new Error("Toolkit#requiresInit is not implemented by the specific toolkit.");
    },

    createToolbarBuilder: function(hint) {
        throw new Error("Toolkit#createToolbarBuilder is not implemented by the specific "
                + "toolkit.");
    },

    createContextMenuBuilder: function(editorKernel) {
        throw new Error("Toolkit#createContextMenuBuilder is not implemented by the "
                + "specific toolkit.");
    },

    createDialogManager: function(editorKernel) {
        throw new Error("Toolkit#createDialogManager is not implemented by the specific "
                + "toolkit.");
    }

});

CUI.rte.ui.Toolkit.TBHINT_LOCAL = "local";

CUI.rte.ui.Toolkit.TBHINT_GLOBAL = "global";
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

CUI.rte.ui.ToolkitRegistry = function() {

    var toolkits = { };

    return {

        register: function(toolkitName, cls) {
            toolkits[toolkitName] = {
                "initialized": false,
                "obj": new cls()
            };
        },

        initialize: function(toolkitName, callback) {
            if (!toolkits.hasOwnProperty(toolkitName)) {
                throw new Error("No toolkit registered for type '" + toolkitName + "'");
            }
            CUI.rte._toolkit = toolkitName;
            var toolkitDef = toolkits[toolkitName];
            var toolkit = toolkitDef.obj;
            if (!toolkitDef.initialized && toolkit.requiresInit()) {
                toolkit.initialize(function() {
                    toolkitDef.initialized = true;
                    if (callback) {
                        callback(toolkit);
                    }
                });
            } else {
                if (callback) {
                    callback(toolkit);
                }
            }
        },

        get: function(toolkitName) {
            if (!toolkits.hasOwnProperty(toolkitName)) {
                throw new Error("No toolkit registered for type '" + toolkitName + "'");
            }
            var toolkitDef = toolkits[toolkitName];
            var toolkit = toolkitDef.obj;
            if (!toolkitDef.initialized) {
                if (toolkit.requiresInit()) {
                    throw new Error("Toolkit not yet initialized.");
                } else {
                    toolkitDef.initialized = true;
                }
            }
            return toolkitDef.obj;
        }

    };

}();
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * <p>This class is used for UI-related events.</p>
 * <p>UI-related events are used for communication between the toolkit-specific
 * implementation and the editor core. For example, a dialog (toolkit-specific) fires
 * events when it is shown or hidden to inform the editor's core about such actions.
 * The editor core then dispatches the event to registered listeners - allowing
 * other plugins to react on events triggered by an originating plugin.</p>
 * @type CUI.rte.ui.UIEvent
 */
CUI.rte.ui.UIEvent = new Class({

    toString: "UIEvent",

    /**
     * The event type
     * @type String
     * @private
     */
    type: null,

    /**
     * The edit context for the event
     * @property editContext
     */
    editContext: null,

    /**
     * Creates a new UI-related event.
     * @param {String} type The event type
     * @param {CUI.rte.EditContext} editContext The edit context
     * @param {Object} params The parameters (content is dependent on the event type)
     */
    construct: function(type, editContext, params) {
        params = params || { };
        this.type = type;
        this.editContext = editContext;
        CUI.rte.Utils.apply(this, params);
    },

    /**
     * Returns the UI event's type.
     * @return {String} The event type
     */
    getType: function() {
        return this.type;
    }

});
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.ui.ToolbarBuilder
 * @private
 * <p>This class is used to build toolbars from plugins.</p>
 * <p>Each toolbar consists of several groups of toolbar items. Each group is separated
 * from other groups visually. Each group has a sorting index to determine its position
 * relative to other groups. Each toolbar item has a sorting index to determine its position
 * relative to other icons of the same group.</p>
 * @constructor
 * Creates a new ToolbarBuilder
 */
CUI.rte.ui.ToolbarBuilder = new Class({

    toString: "ToolbarBuilder",

    /**
     * @private
     */
    groups: null,

    construct: function() {
        this.groups = [ ];
    },

    /**
     * @private
     */
    insertInArray: function(array, element) {
        var sort = element.sort;
        var itemCnt = array.length;
        for (var i = 0; i < itemCnt; i++) {
            if (array[i].sort && array[i].sort > sort) {
                array.splice(i, 0, element);
                return;
            }
        }
        array.push(element);
    },

    /**
     * @private
     */
    getGroupById: function(groupId) {
        var groupCnt = this.groups.length;
        for (var i = 0; i < groupCnt; i++) {
            if (this.groups[i].id == groupId) {
                return this.groups[i];
            }
        }
    },

    /**
     * Add a new toolbar item.
     * @param {String} groupId ID of the group the item belongs to
     * @param {Number} groupSort Group sorting index
     * @param {CUI.rte.ui.TbElement} element Toolbar item to add
     * @param {Number} elementSort Element sorting index
     */
    addElement: function(groupId, groupSort, element, elementSort) {
        var group = this.getGroupById(groupId);
        if (!group) {
            group = {
                "id": groupId,
                "sort": groupSort,
                "elements": [ ]
            };
            this.insertInArray(this.groups, group);
        }
        this.insertInArray(group.elements, {
            "sort": elementSort,
            "def": element
        });
    },

    /**
     * Create the toolbar as a suitable Ext component.
     * @return {CUI.rte.ui.Toolbar} The toolbar
     */
    createToolbar: function(editorKernel, options) {
        // must be overridden by the implementing class
        return null;
    },

    createElement: function(id, plugin, toggle, tooltip, css, cmdDef) {
        // must be overridden by the implementing class
        throw new Error("ToolbarBuilder#createElement is not implemented.");
    },

    createParaFormatter: function(id, plugin, tooltip, formats) {
        // must be overridden by the implementing class
        throw new Error("ToolbarBuilder#createParaFormatter is not implemented.");
    },

    createStyleSelector: function(id, plugin, tooltip, styles) {
        // must be overridden by the implementing class
        throw new Error("ToolbarBuilder#createStyleSelector is not implemented.");
    }

});

/**
 * @static
 * @final
 * @type Number
 * @private
 */
CUI.rte.ui.ToolbarBuilder.MAIN_TOOLBAR = 0;

/**
 * @static
 * @final
 * @type Number
 * @private
 */
CUI.rte.ui.ToolbarBuilder.STYLE_TOOLBAR = 1;
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

CUI.rte.ui.Toolbar = new Class({

    toString: "Toolbar",

    /**
     * The toolkit-specific representation of the toolbar
     */
    toolkitRep: null,

    construct: function(toolkitRep) {
        this.toolkitRep = toolkitRep;
    },

    getToolkitRep: function() {
        return this.toolkitRep;
    },

    getItem: function(itemId) {
        throw new Error("Toolbar#getItem is not implemented.");
    },

    getHeight: function() {
        throw new Error("Toolbar#getHeight is not implemented.");
    },

    adjustToWidth: function(width) {
        // may be overridden by implementing toolbar if adjustments to the available width
        // for the toolbar are required
    },

    enable: function() {
        throw new Error("Toolbar#enable is not implemented.");
    },

    disable: function(excludeItems) {
        throw new Error("Toolbar#disable is not implemented.");
    },

    destroy: function() {
        throw new Error("Toolbar#destroy is not implemented.");
    }

});
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.ui.TbElement
 * @private
 * This class represents a single element for use in
 * {@link CUI.rte.ui.ToolbarBuilder}.
 */
CUI.rte.ui.TbElement = new Class({

    toString: "TbElement",

    id: null,

    plugin: null,

    toggle: null,

    tooltip: null,

    toolbar: null,

    construct: function(id, plugin, toggle, tooltip, css, cmdDef) {
        this._init.apply(this, arguments);
    },

    _init: function(id, plugin, toggle, tooltip, css, cmdDef) {
        this.id = id;
        this.plugin = plugin;
        this.toggle = toggle;
        this.css = (css ? css : "x-edit-" + id);
        this.cmdDef = cmdDef;
        if (tooltip) {
            this.tooltip = tooltip;
            this.tooltip.cls = "x-html-editor-tip";
        } else {
            this.tooltip = null;
        }
    },

    getToolbar: function() {
        return CUI.rte.ui.ToolbarBuilder.MAIN_TOOLBAR;
    },

    addToToolbar: function(toolbar) {
        throw new Error("TbElement#addToToolbar is not implemented.");
    },

    notifyToolbar: function(toolbar) {
        throw new Error("TbElement#notifyToolbar is not implemented.");
    },

    createToolbarDef: function() {
        throw new Error("TbElement#createToolbarDef is not implemented.");
    },

    setDisabled: function(isDisabled) {
        throw new Error("TbElement#setDisabled is not implemented.");
    },

    setSelected: function(isSelected, suppressEvent) {
        throw new Error("TbElement#setSelected is not implemented.");
    }

});
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.ui.TbParaFormatter
 * @extends CUI.rte.ui.TbElement
 * @private
 * This class represents a paragraph formatter element for use in
 * {@link CUI.rte.ui.ToolbarBuilder}.
 */
CUI.rte.ui.TbParaFormatter = new Class({

    extend: CUI.rte.ui.TbElement,

    formatSelector: null,

    formats: null,

    construct: function() {
        // Dummy constructor to keep constructor chain alive
    },

    _init: function(id, plugin, toggle, tooltip, css, cmdDef, formats) {
        this.inherited(arguments);
        this.formats = formats;
    },

    notifyToolbar: function(toolbar) {
        this.toolbar = toolbar;
    },

    getToolbar: function() {
        return CUI.rte.ui.ToolbarBuilder.STYLE_TOOLBAR;
    },

    initializeSelector: function() {
        // must be overridden by implementing classes
        throw new Error("tbParaFormatter#initializeSelector is not implemented.");
    },

    getSelectorDom: function() {
        // must be overridden by implementing classes
        throw new Error("TbParaFormatter#getSelectorDom is not implemented.");
    },

    getSelectedFormat: function() {
        // must be overridden by implementing classes
        throw new Error("TbParaFormatter#getSelectedFormat is not implemented.");
    },

    selectFormat: function(formatToSelect, auxRoot, formatCnt, noFormatCnt) {
        throw new Error("TbParaFormatter#selectFormat is not implemented.");
    }

});
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.ui.TbStyleSelector
 * @extends CUI.rte.ui.TbElement
 * @private
 * This class represents a style selecting element for use in
 * {@link CUI.rte.ui.ToolbarBuilder}.
 */
CUI.rte.ui.TbStyleSelector = new Class({

    toString: "TbStyleSelector",

    extend: CUI.rte.ui.TbElement,

    styleSelector: null,

    styles: null,

    _init: function(id, plugin, toggle, tooltip, css, cmdDef, styles) {
        this.inherited(arguments);
        this.styles = styles;
    },

    /**
     * Creates HTML code for rendering the options of the style selector.
     * @return {String} HTML code containing the options of the style selector
     * @private
     */
    createStyleOptions: function() {
        var htmlCode = "<option value=\"\">[None]</option>";
        if (this.styles) {
            var styleCnt = this.styles.length;
            for (var s = 0; s < styleCnt; s++) {
                var styleToAdd = this.styles[s];
                var className = styleToAdd.cssName;
                var text = styleToAdd.text;
                htmlCode += "<option value=\"" + className + "\" class=\"" + className
                    + "\">" + text + "</option>";
            }
        }
        return htmlCode;
    },

    notifyToolbar: function(toolbar) {
        this.toolbar = toolbar;
    },

    getToolbar: function() {
        return CUI.rte.ui.ToolbarBuilder.STYLE_TOOLBAR;
    },

    initializeSelector: function() {
        // must be overridden by implementing classes
        throw new Error("TbStyleSelector#initializeSelector is not implemented.");
    },

    getSelectorDom: function() {
        // must be overridden by implementing classes
        throw new Error("TbStyleSelector#getSelectorDom is not implemented.");
    },

    getSelectedStyle: function() {
        // must be overridden by implementing classes
        throw new Error("TbStyleSelector#getSelectedStyle is not implemented.")
    },

    setRemoveDisabled: function(isDisabled) {
        // must be overridden by implementing classes
        throw new Error("TbStyleSelector#setRemoveDisabled is not implemented.");
    }

});
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.ui.ContextMenuBuilder
 * @private
 * This class is used to build the context menu from plugins in a implementation-independent
 * way.
 */
CUI.rte.ui.ContextMenuBuilder = new Class({

    toString: "ContextMenuBuilder",

    /**
     * List of items
     * @private
     * @type Array
     */
    items: null,

    /**
     * The menu built/managed
     * @private
     * @type Object
     */
    menu: null,


    construct: function(editorKernel) {
        this.items = [ ];
        this.editorKernel = editorKernel;
    },

    addItem: function(itemToAdd) {
        this.items.push(itemToAdd);
    },

    clear: function() {
        this.items.length = 0;
    },

    build: function(selectionContext, context) {
        // must be overridden by implementing classes
        throw new Error("ContextMenuBuilder#build is not implemented.");
    },

    createItem: function(config) {
        // must be overridden by implementing classes
        throw new Error("ContextMenuBuilder#createItem is not implemented.");
    },

    createSeparator: function() {
        // must be overridden by implementing classes
        throw new Error("ContextMenuBuilder#createSeparator is not implemented.");
    },

    // TODO move to a separate class that abstracts the context menu itself

    showAt: function(x, y) {
        // must be overridden by implementing classes
        throw new Error("ContextMenuBuilder#showAt is not implemented.");
    },

    hideAll: function() {
        // must be overridden by implementing classes
        throw new Error("ContextMenuBuilder#hide is not implemented.");
    },

    isVisible: function() {
        // must be overridden by implementing classes
        throw new Error("ContextMenuBuilder#isVisible is not implemented.");
    }

});
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.ui.CmItem
 * @private
 */
CUI.rte.ui.CmItem = Class({

    toString: "CmItem",

    build: function(menu, editorKernel, editContext, selectionContext) {
        // must be overridden by implementing class
        throw new Error("CmItem#build is not implemented.");
    }

});
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.ui.CmSeparator
 * @private
 */
CUI.rte.ui.CmSeparator = new Class({

    toString: "CmSeparator",

    build: function(menu) {
        // must be overridden by implementing classes
        throw new Error("CmSeparator#build must be overridden by implementing classes.");
    }

});
/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * This class should be overridden by toolkit-specific dialog implementations.
 */
CUI.rte.ui.DialogManager = new Class({

    create: function(dialogId, config) {
        throw new Error("DialogManager#create must be implemented")
    },

    mustRecreate: function(dialog) {
        throw new Error("DialogManager#mustRecreate must be implemented");
    },

    show: function(dialog) {
        throw new Error("DialogManager#show must be implemented");
    },

    hide: function(dialog) {
        throw new Error("DialogManager#hide must be implemented");
    },

    alert: function(title, message, fn) {
        throw new Error("DialogManager#alert must be implemented");
    },

    createDialogHelper: function() {
        throw new Error("DialogManager#createDialogHelper must be implemented");
    }

});

/**
 * ID for the "link" dialog
 * @type {String}
 */
CUI.rte.ui.DialogManager.DLG_LINK = "linkDialog";

/**
 * ID for the "anchor" dialog
 * @type {String}
 */
CUI.rte.ui.DialogManager.DLG_ANCHOR = "anchorDialog";

/**
 * ID for the "find &amp; replace" dialog
 * @type {String}
 */
CUI.rte.ui.DialogManager.DLG_FINDREPLACE = "findReplaceDialog";

/**
 * ID for the "paste" dialog
 * @type {String}
 */
CUI.rte.ui.DialogManager.DLG_PASTE = "pasteDialog";

/**
 * ID for the "special chars" dialog
 * @type {String}
 */
CUI.rte.ui.DialogManager.DLG_SPECCHARS = "specCharsDialog";

/**
 * ID for the "table properties" dialog
 * @type {String}
 */
CUI.rte.ui.DialogManager.DLG_TABLEPROPS = "tablePropsDialog";

/**
 * ID for the "cell properties" dialog
 * @type {String}
 */
CUI.rte.ui.DialogManager.DLG_CELLPROPS = "cellPropsDialog";

/*************************************************************************
*
* ADOBE CONFIDENTIAL
* ___________________
*
*  Copyright 2012 Adobe Systems Incorporated
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Adobe Systems Incorporated and its suppliers,
* if any.  The intellectual and technical concepts contained
* herein are proprietary to Adobe Systems Incorporated and its
* suppliers and are protected by trade secret or copyright law.
* Dissemination of this information or reproduction of this material
* is strictly forbidden unless prior written permission is obtained
* from Adobe Systems Incorporated.
**************************************************************************/

/**
 * @class CUI.rte.ui.DialogHelper
 * @private
 * <p>The DialogHelper provides helper functionality for creating extensible dialogs from
 * inside the richtext editor. It should be used by plugins to create and display
 * dependent dialogs.</p>
 * <p>The following features are available:</p>
 * <ul>
 *   <li>The default, "out-of-the-box" dialog can be extended with additional fields.</li>
 *   <li>Fields that are contained in the default dialog may be disabled as required.</li>
 *   <li>The default dialog may be replaced completely by a custom dialog.</li>
 * </ul>
 * @constructor
 * Creates a new DialogHelper with the specified configuration.
 * @param {Object} dialogConfig The dialog's configuration
 * @param {CUI.rte.EditorKernel} editorKernel The editor kernel the dialog is used from
 * @since 5.3
 */
CUI.rte.ui.DialogHelper = new Class({

    toString: "DialogHelper",

    /**
     * @cfg {Number} configVersion
     * Defines the version of the dialog configuration provided. Must currently be set to
     * 1 to use the extensible configuration. If no value is specified, the config is used
     * "as is" for CQ 5.2 compatibility.
     */
    configVersion: null,

    /**
     * @cfg {Object} defaultDialog
     * Defines the default dialog. This config property should only be set by the respective
     * plugin and not be used for customization. The object must contain an array named
     * items that contains Ext field definitions (as known from other component definitions)
     * or an Object named dialogClass which defines the xtype and optionally a
     * jcr:primaryType property. Additionally, an Object named dialogProperties can be
     * provided, which contains further dialog properties (such as width, height, title,
     * etc.). Note that each of the fields in the items array must contain a "name"
     * property which is used for referencing the field from other places.
     */
    defaultDialog: null,

    /**
     * @cfg {Object[]} additionalFields
     * <p>Array containing additional fields that have to be added to the default fields of
     * the dialog. Each element must have the following properties:</p>
     * <ul>
     *   <li><code>item</code> : String<br>
     *     The definition of the field (using a standard Ext item definition). Must contain
     *     a name property for further referencing.</li>
     *   <li><code>previousItem</code> : String<br>
     *     Name of the field that is located before the field to add. This is used to
     *     provide a certain sort order of the fields.</li>
     *   <li><code>fromModel</code> : Function<br>
     *     A function that is responsible for transferring the data from the model (usually
     *     the DOM object that is edited by the dialog, but actually depends on the
     *     context the DialogHelper is used in) to the additional field.</li>
     *   <li><code>toModel</code> : Function<br>
     *     A function that is responsible for transferring the user input from the
     *     additional field to the model (usually the DOM object that is edited by the
     *     dialog, but actually depends on the context the DialogHelper is used in)</li>
     * </ul>
     */
    additionalFields: null,

    /**
     * @cfg {String[]} disabledDefaultFields
     * An array of strings that contain the names of the default fields that should get
     * disabled. The actual names depend on the fields specified by {@link #defaultFields}.
     */
    disabledDefaultFields: null,

    /**
     * @cfg {Object} dialogProperties
     * Additional, overridden or customized dialog properties, such as width, height or
     * title.
     */
    dialogProperties: null,

    /**
     * Currently edited dialog (set in {@link #create})
     * @private
     * @type Object
     */
    dialogProcessed: null,

    /**
     * @cfg {Object} customDialog
     * <p>Config object that is used for replacing the default dialog by a completely
     * customized dialog.</p>
     * <p>The config object is a typical Ext component definition. If a jcr:primaryType
     * property is included, the customized dialog will be instantiated using the
     * respective toolkit's default method for instantiating dialogs indirectly. Otherwise
     * it is instantiated directly using the toolkit's standard component builder.</p>
     * <p>Note that all other config options are ignored if a custom dialog is used.</p>
     */
    customDialog: null,

    /**
     * The editor kernel the dialog is used from
     * @publicProp
     * @type CUI.rte.EditorKernel
     */
    editorKernel: null,


    construct: function(dialogConfig, editorKernel) {
        if (arguments.length == 1) {
            // required for backwards compatibility
            editorKernel = dialogConfig;
            dialogConfig = undefined;
        }
        this.editorKernel = editorKernel;
        if (dialogConfig) {
            this.configure(dialogConfig);
        }
    },

    configure: function(dialogConfig) {
        if (!dialogConfig.configVersion) {
            dialogConfig = {
                "configVersion": 1,
                "customDialog": dialogConfig
            };
        }
        CUI.rte.Utils.apply(this, dialogConfig);
    },

    /**
     * @protected
     */
    instantiateDialog: function(dialogConfig) {
        throw new Error(
                "DialogHelper#instantiateDialog must be implemented in a toolkit-specific "
                + "way");
    },

    /**
     * @private
     */
    createCustomDialog: function() {
        return this.instantiateDialog(this.customDialog);
    },

    /**
     * <p>Adds the additional fields to the specified dialog item configuration.</p>
     * <p>This method is used by {@link CUI.rte.ui.Window.BaseWindow} to apply custom
     * configuration. It should not be called directly.</p>
     * @private
     */
    addAdditionalItems: function(dialogItems) {
        var additionalFields = [ ];
        if (this.additionalFields) {
            var fieldCnt = this.additionalFields.length;
            for (var f = 0; f < fieldCnt; f++) {
                var fieldToAdd = this.additionalFields[f];
                if (fieldToAdd.item && fieldToAdd.item.name) {
                    var isInserted = false;
                    if (fieldToAdd.insertBefore) {
                        var itemCnt = dialogItems.length;
                        for (var i = 0; i < itemCnt; i++) {
                            var itemToCheck = dialogItems[i];
                            if (itemToCheck.name == fieldToAdd.insertBefore) {
                                dialogItems.splice(i, 0, fieldToAdd.item);
                                isInserted = true;
                                break;
                            }
                        }
                    }
                    if (!isInserted) {
                        dialogItems.push(fieldToAdd.item);
                    }
                    if (fieldToAdd.validator) {
                        fieldToAdd.item.validator = fieldToAdd.validator;
                        fieldToAdd.item.evaluateValidatorsFirst = true;
                    }
                    additionalFields.push({
                        "name": fieldToAdd.item.name,
                        "fromModel": fieldToAdd.fromModel,
                        "toModel": fieldToAdd.toModel
                    });
                }
            }
        }
        return additionalFields;
    },

    /**
     * <p>Removes the disabled fields from the specified dialog item configuration.</p>
     * <p>This method is used by {@link CUI.rte.ui.Window.BaseWindow} to apply custom
     * configuration. It should not be called directly.</p>
     * @private
     */
    removeDisabledItems: function(dialogItems) {
        var com = CUI.rte.Common;
        if (this.disabledDefaultFields) {
            var itemCnt = dialogItems.length;
            for (var i = itemCnt - 1; i >= 0; i--) {
                var item = dialogItems[i];
                if (com.arrayContains(this.disabledDefaultFields, item.name)) {
                    dialogItems.splice(i, 1);
                }
            }
        }
    },

    /**
     * <p>Merges two objects recursively.</p>
     * <p>Note that this method does not work with top-level Arrays.</p>
     * @param {Object} obj The base object
     * @param {Object} objToAppend The object that is merged into obj
     * @private
     */
    mergeObjects: function(obj, objToAppend) {
        for (var key in objToAppend) {
            if (objToAppend.hasOwnProperty(key)) {
                var value = objToAppend[key];
                if (typeof(value) == "object") {
                    var copyObj = CUI.rte.Utils.copyObject(value);
                    if (obj[key]) {
                        CUI.rte.Utils.applyDefaults(obj[key], copyObj);
                    } else {
                        obj[key] = copyObj;
                    }
                } else {
                    obj[key] = value;
                }
            }
        }
    },

    /**
     * @private
     */
    createExtensibleDialog: function() {
        var com = CUI.rte.Common;
        if (!this.defaultDialog) {
            throw new Error("Invalid dialogConfig; missing property defaultDialog");
        }
        if (this.defaultDialog.dialogClass) {
            var dialogConfig = CUI.rte.Utils.copyObject(this.defaultDialog.dialogClass);
            if (this.defaultDialog.dialogProperties) {
                this.mergeObjects(dialogConfig, this.defaultDialog.dialogProperties);
            }
            if (this.dialogProperties) {
                this.mergeObjects(dialogConfig, this.dialogProperties);
            }
            if (this.parameters) {
                dialogConfig.parameters = this.parameters;
            }
            return this.instantiateDialog(dialogConfig);
        } else if (this.defaultDialog.items) {
            // todo implement
            return null;
        } else {
            throw new Error("Invalid dialogConfig; missing property defaultDialog.items "
                    + "or defaultDialog.dialogClass.");
        }
    },

    /**
     * Creates the dialog as specified by the configuration that was passed to the
     * constructor.
     * @return {Object} The toolkit specific object representing the dialog
     */
    create: function() {
        if (this.customDialog) {
            this.dialogProcessed = this.createCustomDialog();
        } else {
            this.dialogProcessed = this.createExtensibleDialog();
        }
        return this.dialogProcessed;
    },

    /**
     * Calculates a suitable dialog position for the specified editor kernel.
     * @param {String} hint A positioning hint; allowed values are: "default"
     */
    calculateInitialPosition: function(hint) {
        if (this.dialogProcessed) {
            this.dialogProcessed.setPosition(this.editorKernel.calculateWindowPosition(
                    hint));
        }
    },

    /**
     * Creates a new item of the specified type with the specified config.
     * @param {String} type The Item's type
     */
    createItem: function(type, name, label) {
        throw new Error(
                "DialogHelper#createItem must be implemented in a toolkit-specific way");
    },

    /**
     * Returns the type of the specified, toolkit-specific item
     * @param {Object} item The item to retrieve the type from
     */
    getItemType: function(item) {
        throw new Error(
                "DialogHelper#getItemType must be implemented in a toolkit-specific way");
    },

    /**
     * Returns the name of the specified, toolkit-specific item
     * @param {Object} item The item
     * @return {String} The item's name
     */
    getItemName: function(item) {
        throw new Error(
                "DialogHelper#getItemName must be implemented in a toolkit-specific way");
    },

    /**
     * Returns the current value of the specified, toolkit-specific item
     * @param {Object} item The item
     * @return {String} The current item value
     */
    getItemValue: function(item) {
        throw new Error(
                "DialogHelper#getItemValue must be implemented in a toolkit-specific way");
    },

    /**
     * Sets the specified, toolkit-specific item's value.
     * @param {Object} item The item
     * @param {String} value The value to set
     */
    setItemValue: function(item, value) {
        throw new Error(
                "DialogHelper#setItemValue must be implemented in a toolkit-specific way");
    }


});

/**
 * The dialog's type for indirect instantiation
 * @type {String}
 */
CUI.rte.ui.DialogHelper.TYPE_DIALOG = "rtelinkdialog";

/**
 * Item type: Text field
 * @type {String}
 */
CUI.rte.ui.DialogHelper.TYPE_TEXTFIELD = "textfield";

/**
 * Item type: Hidden field
 * @type {String}
 */
CUI.rte.ui.DialogHelper.TYPE_HIDDEN = "hidden";